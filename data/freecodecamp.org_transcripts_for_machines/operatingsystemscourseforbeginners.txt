in this massive 25hour operating system course you will learn the fundamental and advanced operating system Concepts in detail the course starts with defining what an OS is and its various roles then you'll learn about topics like Process Management CPU scheduling deadlock handling strategies memory management and more this course will give you a comprehensive understanding of how operating systems function and manage resources hey there well you have just landed upon the most comprehensive operating system course on this platform we have gone to the depth and have discussed each and every important Concept in detail which is included in our us cabus so first let's discuss the cabus Opera operating system course can be divided into seven major parts the first one is Introduction and background now comes Process Management CPU scheding process synchronization or coordination then comes the deadlock memory management and then in the end file management I believe in certain phases of learning the first one is Theory we understand the concept with the help of real life examples the theory is completed now we comes to numericals I believe problem solving is the best way to check whether you have understood the concept or not then comes the revision my mother said if you fail to revise you fail to learn after some days when you will open the notes and you'll try to read from that everything will seem new to you it will feel like you have never attended this course okay revision is must now let me tell you what the course offers the course offers 25 hours of comprehensive content 400 pages of lecture notes are discussed here although I advise you to make your own short notes but if you want to have the same notes from which I teach to you then you can visit the website I'll paste the QR code there you can visit the website and download the notes from there now who should take this course this course is perfectly suited for University students for their semester exams perfectly suited we have taken 100 plus up Notch numericals all handpicked from the standard textbook of operating system like Stallings galin and Tenon bomb I have taken important problems from the gate exam course is perfectly suited for the University students the gate aspirant or anyone who wants their operating system fundamental solid anyone who is curious who is preparing for some job job interview this course is for you now one last thing a guideline you can cannot just sit back relax and watch this course as a Netflix series no when I discuss Theory you make short notes when I discuss numericals you pause the video and attempt the numerical first by your own see if you just directly see the solution of a problem the problem is wased for you this will not help you grow you will never understand the beauty behind the problem you will never understand where you could have made mistake and that mistake you are going to make in the exam that's why I sincerely request you pause the video first attempt by your own and the third important thing you need to revise let's meet in the first lecture bye welcome to the operating system course this is sh Sharma starting with the chapter one introduction and background so before starting this chapter I'm feeling the need to clarify that there are some prerequisites of this course so you should know or you should have a little bit knowledge about computer organization and architecture I mean little bit about what is computer it's Hardware how does it work its architecture little bit knowledge about that is required you should have a programming exposure with any language either C or Java or any language you prefer you should have little bit of programming exposure okay so these are the two prerequisite and if you do not have them there's no need to worry I will brush up those concepts for you and I will briefly explain you about them okay so we are starting with the chapter one introduction and background so what we will do in this chapter we'll start with what is operating system functions and goals of operating systems types of operating system multiprogram operating system architecture requirement and so on mode shifting system calls folk system calls and in the end as I have promised in the preview problem solving okay so these are the three textbooks which I'm following for creation of this course always concepts by galin tenan bomb and Stallings okay so let's start so the first question which arises in our mind is what is an operating system so I'll give you several definitions and I'll explain them one by one okay so operating system is an interface between user and computer what is an interface now I'll explain them but first we should know a little bit about component of Hardware then only you will get a better idea about what does operating system system basically do okay so there are three components or three units of Hardware input output memory input output memory and CPU which is also known as processor so in CPU there are two units control unit and arithmetic logic unit let me change the color I think this will be good okay so control unit and arthamatic logic unit we'll study about what is control unit so control unit is the unit that have power of of generation timing or control signal clock signals you may have heard about it that controls the operation it has also widely known for sequential execution of micro operations now the question arises what are micro operations these are the operations that are carried out on data stored on resistors let me clarify those definitions so this is the high level program written here int ABC B is = 1 Cal to 2 A = to B plus C okay so this is a high level statement a Max operation now when it is passed onto the compiler it converts into several micro instructions like load the value of B into register R1 load the value of B into register R1 load the value of C into register R2 now add R1 and R2 and load the result into R1 now store the value of R1 into memory a so these are some micro instructions okay now the control unit is responsible for sequential execution that is first you have to do this then this then this and then in the end this who is responsible control unit is responsible okay so this was the architecture in which memory input output and processor this was the architecture proposed by V Newman it is most famous architecture okay so now we'll move down so we have understood what is control unit now let's understand what is ALU ALU is called functional unit unit what functions is perform it performs like arithmetic and logical functions so it's the main unit that carries out arithmetic and logical operations it consists of adders subtractors and so on now comes the memory part so we have studied in our earlier classes that there are two types of memory primary memory and secondary memory primary memory is also called as main memory and secondary memory is also called as auxiliary memory primary memory includes Ram Rome cach registers it's faster to access it's expensive and it is lower size and one most important thing about primary memory is it's volatile what does volatile mean volatile mean that the content vanishes when the power supply goes off it doesn't happen in the secondary memory secondary memory is nonvolatile that is content does not vanishes when the power supply goes off let's take an example you have downloaded a movie now you shut down your computer when you start again you found find the movie present there already but let's take an example of um let's say terminal you have written some code and then when you close the terminal the code finishes it can never be brought back so this is the primary memory and the secondary memory are these are the hard disk the pen drives these are the example of secondary memory so we have in the one num architecture we have written the three parts memory CPU and input output so which memory here I am referring to I am referring here here to primary memory CPU access only primary memory which memory primary that's why I have written P then what about secondary memory I have not seen secondary memory in this architecture where is it so that's that's why I have written it in form of question so where is secondary memory then so as per volum architecture secondary memory are the part of input output devices input output devices I hope that you must know what are input output devices it's like monitor keyboard printer and hard disk these are input output devices okay now an important concept come here how are programs executed in the one Newman architecture so this is the most important part of one num architecture you must pay a little more Focus here okay so let's take with an example we started with a file test. C so this is a C file as here it is we are seeing the extension do c so it's a C file C file is passed to the compiler compiler converts into the executable form that is in form of instruction i1 I2 till I in let's say there are any instructions okay now this instruction this whole instruction is passed onto the operating system what does operating system do here it loads thee file into the main memory this is an important part so when a program is loaded in memory for execution this concept is known as stored program con concept this is an important concept so what does OS do it loads the exe file from hard disk to main memory and then from Main memory it is passed to the CPU and CPU do the sequential execution that is CPU first take the in instruction one i1 execute it then I2 then it will execute it until in the end I in now the question arises so here I have written CPU cannot execute the program directly from the hard disk why is it so why does CPU cannot directly access from the hard disk why does it require the main memory why does it require the operating system that needs that exe file first transferred into main memory and then in CPU why does it happen because hard diss are slow the computer has high and fast processing speed but it cannot fetch that much data from hard disk it requires a fast memory so CPU is fast hard disk is slow we need something that can match the speed of CPU so this is main memory that is RAM and it is fast as CPU okay so first operating system need to transfer XE file to main memory here which I have shown and then CPU loads the program from in memory itself and does sequential execution of the instructions so the instruction of the program are executed sequentially one after another that we will learn more in the computer organization architecture course so what we have learned about the fundamental principles of vum architecture we have learned about store program concept that is see operating system loads thex file from hard disk to CPU and then second point is then CPU does the sequential execution of the instructions any program that has to be executed must be stored in the main memory that is the Golden Rule you have to remember okay now you can understand what is an operating system so here is the user here is our Hardware so operating system act as a bridge for communication between user and hardware user talks in the high level language operating system system is an interface which converts that into machine language that is understandable by Hardware Hardware performs the execution then it send the result to operating system and then it send the result to user okay so what is this representation this represent that whole language of user is between symbols a to zed that is our English language and the whole language of the computer is between the set 0 and one between symbol 0 and one okay this is just the representation so question arises how does operating system perform so much of work how does it do this work so how it is done so OS consist of several modules it consists of modules like process manager memory manager file manager device manager and protection manager all this combines and become kernel kernel of operating system it is also known as core or nuclear is okay so what I have taught you till now let me put this all into the same picture this is our user this is our hardware and in between there is an interface so these are the users I have symbolized in the cycle form and in the bottom there's a hardware so operating system manages the hardware and it act as an interface so there are two levels of interface level one and level two level one is user OS interface that is like a command interpreter which consist of shell or GUI can be either so it's a user OS interface that helps in communication between user and the OS so the level one interface helps with communication between user and the OS and then OS kernel performs the operation that is required by the user with the help or with the management of the hardware Hardware consist of CPU main memory input output devices what are what is OS kernel OS kernel consist of all these module process manager memory manager file manager device manager and prodection manager okay so this was operating system definition number one now let's move to definition number two that is operating system also act as resource manager so which resources I'm talking about I'm talking about software resources and Hardware resources Hardware resources include computer sorry CPU monitors input output devices and software resources are file SEMA 4 monitors so you don't need to worry there's no need to worry we'll explain all of them file SEMA 4 monitors in detail when the time will come okay and the second part is control program it act as a control program let me also tell you one thing in Resource Management operating system perform the allocation of resources deallocation of resources freeing of resources Etc basically it manages the resources which resources hardware and software operating system is a control program a program that control all the operations of the computer definition number four set of utilities to simplify application development it takes charge of Hardware create environment or platform that help us to focus on development in the high level mode so what OS will do OS will perform the work at the back of the stage and will help or will allow us to write the code in the high level language and rest OS will manage we just have to write the code in high level language so this is the power of operting system so if I summarize what is an operating system operating system is a government so government is not a single person we cannot say uh let's say Joe Biden is the government of America no we don't say it like that we say government consist of lots of Ministries like Ministry of Health Ministry of Defense Ministry of uh science so operating system is is like a government it consist of several Ministries or we can say modules which modules I'm talking about I'm talking about the modules in the kernel like process manager file manager Etc so operating system is not a single program operating system is a service provider just like the government operating system is the resource manager just like the government so who manages the resources in the country government who provides the service to the people government okay so government controls the country in the same way OS controls everything in the computer okay so let me explain you again so user it communicate to the application of program application of program goes to the kernel operating system kernel then at the lowest level it is Hardware memory or devices okay so now the question arises in the introduction we should also study what are the goals of operating system operating system there are several goals like convenience that is the primary goal of daytoday operating system which we talk about and then efficiency efficiency means you should use your operating system make use of resources efficiently it should be reliable it means for which purpose operating system was designed that purpose should be achieved what is robustness operating system should be robust robust means strong enough to Bear errors operating system should be scalable operating system should have ability to evolve operating system should be portable it means it should have ability to work across different platforms Let me Give an example Windows operating system that is more portable than Mac operating system Mac operating system only works in the Apple devices whereas Windows operating system can Works in number of devices like Samsung Dell Etc okay so as I've said what is the primary goal of operating system the convenience so so there was a survey taken that which operating system would you prefer Unix or Windows most of the people have chosen Windows why because it was convenient even though Unix was more efficient Unix was more reliable it was more robust so the primary goal of operating system I'm not saying all operating system why because there are some different operating system like realtime operating system which have some deadline strict programs like like we say missile control satellite control nuclear system let's say air traffic control so all of these things have a strict deadline these are known as hard time real operating hard realtime operating system okay and the soft can be said to as ATM in which a deadline is strict deadline even if it's not met then it's not a big problem so in these cases here the main goal is reliability or efficiency in a missile system and is a missile control satellite control nuclear system Air Traffic Control efficiency and reliability are the main goal here convenience do not matter okay so it depends from operating system to operating system that which which is its primary goal either it is convenience or efficiency or reliability and so on what are the functions of operating system processor management these are all selfexplanatory functions it manages the processor memory detects the error it's responsible for the security and file management and we'll in detail explain I will explain them all in detail when we move ahead to this module of processor management to memory management these are all chapters okay so these are this is the first lecture let us revise what we have done we started with what is an operating system it's an interface between user and computer components of hardware is memory input output and CPU CPU consist of two control unit and arithmetic logic unit control unit is responsible for control signals that controls the operation and sequential execution of micro operations micro operations are the operations that are carried out on data stored in registers okay we have taken an example and then we understood what is ALU and then memory the two types of memory we have also understood what where is the secondary memory in one architecture how program are executed in one architecture this is an important part we've learned about stored program concept and sequential execution concept any program that has to be executed we've also learned this must be stored in the main memory then this we have learned we have learned how operating system act as a government okay this is the communication how does it communicates the user to Hardware there are two level of interfaces we have seen we have also understood how operating system act as a resource manager what are resources which we are here referring to control program application development simplification it act like a government and then goals and functions of operating system so in the next lecture we'll study types of operating system hello everyone welcome to the operating system course lecture two in this lecture we are going to study mainly about the multiprogramming operating system we are not going to discuss those operating system which could be understood just by the Google search so our main focus is understanding multiprogramming operating system we'll start with the introduction and then we'll move in depth okay so these operating system which are batch operating system multi program time sharing real time these are basic operating system and distributed OS and network os are Advanced operating system which has which are also known as multiprocessor operating system so what is multiprocessor and what what is uniprocessor we are going to learn later in the lecture so when the first generation of computer were arrived there were no OS in those computers in second generation magnetic tapes was introduced but then there also there was no operating system in third generation when magnetic disc was introduced which is hard dis or a floppy dis the operating system was introduced the operating system is basically divided into two parts uni programmed and multiprogrammed so the ability of operating system to hold a single program in a memory that is uni programming operating system okay so let us understood understand by the diagram so there are many ready to run programs in the hard disk and there is operating system also present in the hard disk at the time of booting operating system get loaded in the main memory so when booting occurs the operating system gets here in the main memory the area where the operating system resides is s area which is also known as system area and the area where programs get loaded are user area so in uni programming operating system only one out of these ready to run program s will get in the main memory so there is a restriction that only a one program from hard disk can be loaded in the main memory and when the CPU start execution on that program let's say in between the program want Services of iio devices input output devices let's say it is not present in CPU when it has went for the io devices then the CPU is empty and if CPU is empty then the proper utilization of CPU is not possible CPU is Idle we don't want that so in uni programming operating system the drawback is less efficiency less CPU utilization and less throughput we will see I have written all these things which I have said just now so let's understand again so there are various ready to run program in the hard disk these are the programs I'm talking about out of these program one program get loaded in the main memory OS can load only aing single program from the memory okay so if the single program that is loaded is not in the CPU let's say it has moved to the io devices then CPU becomes idle and if CPU becomes idle this is the situation we don't want we want efficient CPU utilization we want efficient CPU utilization because if CPU is idle throughput is less and efficiency is less what is throughput number of program executed per unit time okay so I've written that grut is number of programs completed in a unit time so let me clarify again in uni programming operating system the operating system can load only a single ready to run program from hard disk to main memory and if that program is not in CPU let's say it has gone for iio Io services so it is not in CPU there CPU is not uh working on that program then at that case CPU is Idle we don't want that because if CPU becomes idle the efficiency drops CPU zidle throughput drops what is throughput throughput is number of programs completed in a unit time okay do you know an example of uni programming operating system the example is Ms do Microsoft DOS it was there in the 1990s what is the full form Disk Operating System in MS DOS it was command based there was no GUI and only a single program can be loaded in the main memory what was the objective we want maximum CPU utilization so what do you suggest what do you suggest how can we maximize the CP utilization so we can maximize CP utilization by putting more and more programs there so if one program gets into the io devices or one program empty CPU for Io Services there should be other ready to run program for execution so if the P1 has moved to the io Services CPU will start executing on P2 hence CPU idleness decreases let's say even P2 went for Io Services then then also P3 will be there for CPU to work upon if three P3 went there will be P4 and so on so we want multiprogramming operating system multiprogramming operating system is operating system in which operating system has ability to load multiple program from hard disk to main memory okay so this is multiprogramming operating system operating system can hold hold multiple ready to run programs in the main memory so this is the case here are here is the P1 P1 went for Io Services now P1 the CPU is empty there are various program ready for execution the these are waiting okay so at one time yes this is the point I want to emphasize upon CPU can only execute or or only work upon a single program at a time so this I have written at a time only one program will run in any case in any case I'm talking about even multiprocessor operating system multiprocessor see the the computer which has multiple processor which has multiple CPU in that case also in one CPU there will be only one program that will be worked upon so at at at a time only one program only one will run in any case okay I hope I have clarified you I am absolutely sorry for my bad and nonfluent English because English is not my first language okay but I hope I'm able to speak that much English in which you understand the basic idea which I want to say okay so what we want we want maximum CPU utilization we want maximum efficiency we want maximum throughput so for that case multiprogramming operating system is a better choice okay because CPU idleness has been significantly decreased so multiprogramming operating system gives a impression of multiplexing because CPU is working upon different program first is let's say it's working upon P1 P1 went for iio now it's working on P2 now P2 has been executed P1 came back now it's working again on P1 then P2 then again P3 I hope you're getting the point so it's given a impression of multiplexing impression of multiplexing of CPU among different programs is there in multiprogramming operating system now you have also heard uh term named multitasking operating system so the multiprogramming and multitasking operating system are somehow same the Unix family of people says program as a program and windows family of people says program as a task so program is a programming task are the same thing okay now you now you may have doubt then what is process is process and program different we are going to learn that thing in detail in very much detail in the upcoming sections so for now just remember a program in execution is a process okay now let's move ahead now we'll learn the schematic view of multiprogramming operating system so let's say this is secondary storage it was a hard disk which I was talking about it has multiple ready to run programs like P1 P2 and P3 well program task and jobs are same thing these are the same thing just a notation okay so various jobs are loaded in the op in system let's say job one went for the io Services now job two is in execution and job two is in CPU so it is in execution and job three and job four these are ready and waiting for the CPU okay so this is a overall view of multiprogramming operating system let me explain again so this is a secondary storage it has multiple ready to run program that are loaded here let's say job one job two job three and job 4 job one has gone to the io devices job two is now in execution now also the there are two programs waiting and are ready and waiting for the CPU okay so this is a schematic view of multiprogramming operating system so in this case CPU utilization is increased and idleness is decreased now there are two types of multiprogramming also the preemptive one and non preemptive one what is preemptive multiprogramming forceful deallocation from CPU so this job one or let's say job two is in CPU so if a high priority job come here let's say it is job three job three has come there job three is waiting in main memory and it has a more priority then job two then what operating system will do operating system will say hey job two you should go now because a high priority job has come so job three will be there and job two will again be sent in there this is so this is forceful preemption job two has not completed his execution there are instructions remaining for execution in job two but a high high priority process job 3 came so operating system which for will forcefully deallocate job two and will send job three for allocation so this is preemptive multiprogramming forceful deallocation from CPU it can be based either upon priority or time let's say job two is working is is is getting executed from so much time that job three and job four are getting starved these are not getting chance to be there with CPU so what operating system will say operating system will say hey Job 2 you it's been a long time you have been there in the CPU now it's chance for job three and job four to be with CPU so either priority or time on the base of this CPU will forcefully deallocate processes from CPU what is non preemptive nonpreemptive is a type of multiprogramming in which nobody will force the program to leave the CPU it will release the CPU voluntarily in which cases either all the instructions are complete now there's no purpose of a job in the CPU because all all the instructions are now complete now why will job be with CPU now okay all instructions are completed the second case arises the job needs IOU job needs input output services so it will leave CPU voluntarily and the third is system call we will learn about this in detail in the later lecture okay so let us revise what we have learned till now so firstly we started with the types of operating system there are various type of operating system batch operating system multiprogramming time sharing realtime Network and distributed distributed and network are Advanced operating system and the rest are basic operating system these are basic operating system these are Advanced okay in the third generation magnetic dis was introduced a secondary storage was introduced which later gave the birth to different type of operating system uni programming and multiprogramming in uni programming the oper system can hold only a single program in the memory whereas in multiprogramming multiple program can be there or can be present in memory so if there is only one CPU at motherboard it is uniprocessor and if there are multiple CPUs at the motherboard these are multiprocessor operating system like I was talking about distributed and network okay so if multiple CP are present then is multiprocessor now let's talk about un programming schematic view so there are several there are several ready to run program in the hard disk now operating system has capability to load only one so P1 is loaded there P1 went for execution now P1 is there in the CPU CPU is working upon P1 but P1 wants IO services so P1 went P1 empties the CPU and goes to the io devices now CPU is empty it is not working upon any program it is Idle we don't want CPU idleness we want we want to minimize the CPU idess because CPU idleness decreases the efficiency and throughput so if CPU becomes idle then throughput and efficiency are decreased okay so we don't want that we want efficient CF utilization so there is example present MS DOS dis operating system which was introduced in the 1990s command based and it has no graphical user interface so what is our what was our objective to maximize CP utilization multiprogramming operating system is a better choice for that because o can hold multiple ready to run programs if a program is not present in the CPU let's say it's gone for Io Services then there are several other programs waiting to be there with CPU so CPU is never idle but there is a golden point at a time only one will run in the CPU at any case whether it is uniprocessor or multiprocessor so our objective is to maximize utilization maximize efficiency and maximize throughput multiprogramming operating system also gives an impression of multiplexing because CPU is working among different programs what is multitasking multitasking is the same as multiprogramming Unix family says program and windows family says task for the same thing now we have learned the schematic view of multiprogramming there are there is a secondary storage a hard disk or a floppy disc anything which has multiple ready to run programs now OS loads all these program several program whichever is the capacity we say degree the amount of programs let's say four programs are there in the main memory so the degree is four operating system can load four programs in the main memory so the degree of multiprogramming is four okay now job one has moved to the io devices job two is in execution still there are job three and job four ready and waiting for the CPU so this is a schematic view CPU utilization is increased and ID is decreased now we have learned about types of multiprogramming preemptive and non preemptive preemptive means forceful deallocation from CPU in non preemptive nobody will force the program to leave the CPU it will leave the CPU in only three cases either all the instructions are complete it needs an IO service or there's a system system call Okay so what is the drawback of multiprogramming operating system multiprogramming operating system can lead to starvation or indefinite waiting for other programs lack of interactiveness and responsiv how these are the tropics let me explain you so let's say there is a high priority task let's say antivirus antivirus wants to run there so let's say P1 is that antivir task now there are several this is in the CPU people in the CPU now there are several the task which are waiting P1 has been the antivirus scan has been going on since 2 hours now these tasks are starving to be there with CPU but this is not allowed this is a high priority task so response time for P2 P3 and P4 is significantly decreased interactiveness is decreased starvation or indefinite waiting for the other programs is there because P2 P3 and P4 do not know when will P1 leave the CPU so so these are the drawback of multiprogramming operating system or specifically saying non preemptive multiprogramming operating system so what do you think the recent operating system like Unix Linux and Mac operating system are they nonpreemptive or preemptive so I hope you have guessed correctly these are preemptive operating system because non preemptive introduces starvation which is undesirable so Windows 95 till Windows 11 Unix Linux and Mac these operating system are preemptive operating system because it improve responsiveness by forceful deallocation by operating system so that other rating program can get a chance to run on CPU okay so preemption is based on two things it's either on time or on priority so let's say operating system has given 10 seconds for PX NE and P and PX neither completed nor it went for Io so what operating system will say hey PX now you need to leave so these operating system are called as multiprogramming time shared operating system and let's move to the next part that is priority so PX was there enjoying with the CPU now a high priority task come let's say py and if priority of Y is greater than priority of X then OS remove PX from the CPU and let py enter the CPU because it has higher priority so preemption is done on two things time and priority if if it is done on time these are also known as time sharing operating system so this is a better schematic view of multitasking or multiprogramming operating system so if I say what is multitasking operating system then what is the difference between multitasking and multiprogramming then you can say a preemptive multiprogramming operating system is a multitasking operating system I hope you have understood very well till now so this is another schematic view a more detailed one so what happens first a job creation happen first and then it is moved to the ricq Don't Be Afraid by these names RQ IQ these are just uh a a way to symbolize things we are going to learn in detail in the section two Process Management okay so so the job is created first and then it has moved to the readyq when it is ready it stores ready to run program this is ready this is a type of data structure okay it is in the memory so scheduler is there which selects out of ready to run program which program should should go to the CPU let's say a program is there let's say P1 P1 is scheduled so P1 will be there on CPU now it will either be terminated so when in which cases P1 will leave CPU P1 will leave CPU in case of job termination or it wants an IO service so this is a part where it is V left CPU for Io services so it will request for Io there will be SE there may be several other program which were already there requesting for the iio so it has to wait in the queue and then it will get the io Services then it will go again in the RQ and and the cycle continues okay so when all the instructions are completed the job will get terminated now the important part comes there must be some architectural requirement for implementing a multiprogramming operating system architecture means Hardware requirement okay so let's discuss these there are three hard requirements so the first is secondary storage device which I was talking about let's say hard disk or oper input output devices these are the same must be dma compatible now you must be wondering what is dma and what does it mean by being dma compatible so we have discussed in detail in computer organization architecture course if you want to learn deep in the if you want to learn about dma for now just get this dma is direct memory access okay so what's the purpose of being DM compatible it means secondary storage devices must be efficient in data transfer between secondary storage and Main memory okay so first requirement is the secondary storage devices should be dma compatible the second requirement is memory system should support address translation now what is this address translation let me clarify so there is a program which is running on the CPU so how does it work it works like it generates The Logical address what is logical address it's a type of address to access its instruction or data from Main memory okay so what is The Logical address let's say let's understand by real word analogy okay so you come to me and you say hey shage do you know John's house I say yes from here you just go straight 200 M and turn left there's the John's house so this is a logical address this is your logical address and what is a physical address these are the exact coordinate of Jon's house I hope you are getting the point so program generate a logical address to access its instruction or data from Main memory okay and physical address is needed to access instruction or data from Main memory so now there must be a translator in between which translates or convert logical address into physical address so yes there exist a translator we call as memory management unit so what is what is its work its work is to trans or convert logical address into physical address physical address is the actual address of instruction and data unit in the main memory okay so now the question arises what is the need of logical address and physical address so the thing is security with one address let's say only physical each program would directly access physical memory Lo locations so let me clarify with the same example which we have taken so this is me this is you and this is John's house I said so what I said go 200 M and take left so this is The Logical address I have given just to you now if I given let's say the exact coordinate of John's address let's say 200 and 200 just take an example random example now if someone get to know this this will be a big problem let's say what I have told you if someone get to know that I have said you just know to go 200 M straight and then take left suppose this information is e dropped by someone else let's say Alice now Alice Alice has location different so if Alice tried to do do that 200 M and then to left it will not reach the John's house so it is for the security purpose that only logical address is being shared not the physical address so let's understand it formally so with one address only physical each program would directly access physical memory locations a buggy program could overwrite memory used by another program corrupting data and causing crashes logical addresses prevent this by creating an abstraction layer program operate with logical addresses and the O translate them to the physical addresses we are talking about this the memory management unit it translates logical address to the physical address ensuring program do not interfere with with each other's memory space so why we need two addresses just for the security purpose and in the later part of this course we will learn in very detail about logical address and physical address its conversion paging so the course has a lot of things to offer now the third Hardware requirement is CPU CPU must support dual mode operation so what is dual mode operation we are talking about user mode and kernel mode I'm sure you have heard about it user mode and kernel mode so what are user mode and kernel mode Let's discuss so user mode is a nonprivileged mode so what is the meaning of privilege and being nonprivileged so privilege instructions are like let's let's take an example it's like an ambulance on the road ambulance is privileged it does not have to follow the traffic symbols or any other traffic rule it is privileged for that because it is a priority to take patient as soon as possible to the hospital or let's say the Convoy of Chief Minister chief minister do not have to stop at the traffic right traffic light so these are the privileged people okay who are the nonprivileged people the Common Man common man is a nonprivileged people in the same way in the same way the user applications like Microsoft PowerPoint Microsoft Chrome Microsoft Word oops I have said Microsoft Chrome that mistake the Chrome the word the PowerPoint these these are the user applications these are like the common man on the road but there are some OS level kernel routine programs just like the chief minister and the ambulance which are privileged and what is the privilege they are getting that they will atomically perform no one will stop them in between when they are executing they will perform non preemptive multiprogramming and the user level user applications preemptive these are just the normal costs so user mode is preemptive mode and kernel mode is non preemptive mode because it is privileged so what are the example of user applications I have given Microsoft PowerPoint or any other random game you are playing these are example of user application what is the example of os level colel level routines Process Management file management system calls these are included in the privilege instructions so what does this signify the one and zero I have written besides user and kernel this symbolizes which mode we are in currently so there is there is a register in CPU which says PSW register that is processor status word it has a bit which we call is at mode bit if the mode bit is zero the mode is Kernel if the mode bit is one the mode is user mode okay so many times it becomes necessary to shift modes using user to Kernel or kernel to user so if some user application wants to Avil OS kernel level Services then mode shifting is required okay let let me read it again if some user application wants to Avail OS kernel level Services then more shifting is must because kernel level programs are privileged programs they run atomically and user level programs are nonprivileged programs so if user applications want to Avail some privilege instruction or Os services then mode should be shifted from user to Kernel okay in that case mode shifting is required okay so let me read this you will get more idea about what are what is actually kernel mode and a user mode in kernel mode the executing code has complete and unrestricted access to the underlying Hardware so I am talking about this so the upper layer contain users and then the users have access to the system programs application programs and the user program these all run in user mode Library routines also run in the user mode and then there exists some OS some Services which is availed only when their kernel mode is activated like system calls operating system or accessing the computer hardware which required kernel mode so the more we go up the more abstraction we achieve the more we go less the abstraction become less okay so now let let's discuss what I was discussing so in kernel mode the executing code has a complete and unrestricted access to the underlying Hardware it can execute any CPU instruction and reference any memory address so kernel mode can do anything in the computer so kernel mode is generally reserved for the lowest level most trusted functions of the operating system so we can we here we can also see the kernel mode is for the lowest level things so the kernel mode is generally reserved for the lowest level most Trust functions of the operating system because crashes in the kernel mode are catastrophic they will halt the entire PC so if kernel mode get crashed the change will be irreversible so let's discuss now about the user mode in user mode the executing code has no ability to directly access the hardware or reference memory so a user mode has a scope of till this it can at Max access the library routines okay so code running in the user mode must delegate to the system apis what are the system apis we are going to learn in detail in the next lecture let me tell you a little bit about it system apis are the interface which help to Transit from user mode to Kernel mode to access Hardware or memory so code running in user mode must delegate to the system API to access Hardware or memory due to the protection afforded by this sort of isolation crashes in the user mode are always recoverable because if something let's say if Google Chrome chist the operating system will be preserved because it is isolated so the crashes in the user mode are always recoverable unlike kernel mode crashes so most of the code running on your computer will execute in user mode so let's revise everything because it's it was a long lecture so first we started with the types of operating system then we understood the different types of operating system like uni program and multi program operating system in uni program the operating system can load only a single program from hard disk to main memory this introduces CPU idleness and it decreases through poent efficiency example of uni programming is dis operating system by macrosoft now our objective was to maximize CP utilization hence we introduced multiprogramming operating system in which operating system can load different programs from hard disk to main memory and if a program is not present in the CPU there are several other programs waiting to be with the CPU a golden rule was that at a time only one program will run in any case so this increases the CPU utilization it increases the efficiency it increases the throughput and it also gives impression of multiplexing of CPU among different programs program and task is the same thing Unix family people say program and windows family say task now there's a schematic view of operating of multiprogramming operating system there is a secondary storage there is a operating system in the S area and there are several jobs in the user area so if one job has gone to the I devices one is being executed there are several other like job three and job four ready and waiting for the CPU CPU utilization is increased and idleness is decreased there are two type of multiprogramming preemptive and non preemptive preemptive means forceful deallocation and non PR means nobody will force the program to leave the CPU it will leave CPU voluntarily in when what are the cases either all the instructions are complete the job is terminated or it needs an IO services or there's a system code we'll learn in detail what the system called in the next lecture what are the drawbacks of multiprogramming the drawback is it leads to starvation lack of interactiveness or responsiveness so the preemptive operating system preemptive types of multiprogramming improve the responsiveness by forceful deallocation the types the current operating system which we are using like Windows Linux Unix Max are preemptive operating system so preemption is based on time and priority if it is based on time then we say it's time sharing and if it's based on prty that there is no specific name just remember this if a high priority Tas come then CPU will throw the low priority task from the CPU so operating system will throw the low priority task from the CPU pardon me multitasking operating system is same as multiprogramming with preemption okay so this is another schematic view what are the architectural requirement the first is second day storage devices should be dma compatible what does it mean so the data should be transferred between secondary storage and memory efficiently memory system should support address translation it means logical address should be translated to physical address for the program to access instruction of data from the main memory why we need two addresses because of security reasons the processor should support dual mode what are the Dual mode user mode and kernel mode user mode has a mode bit of one and kernel mode has a mode bit of zero user mode have nonprivileged instructions and kernel mode is privileged it is nonpreemptive and it runs atomically so there is a mode bit which can be either zero or one Z symbolizes kernel mode and one symbolizes user mode the mode bit is in the register which register PSW processor status world so many times it becomes necessary to shift modes when it is necessary if a user application wants to Avail OS kernel level services so we have discussed in the end what is a kernel mode and user mode now in the next lecture we are going to learn how the mode shifting is done what is an interupt what is fork and then we will end the chapter one that is introduction background and then from the next to next lecture we'll start the new section Process Management hello everyone welcome to the operating system Master course problem solving session one of the section introduction and background so I have given you the dppp in the previous lecture I hope you have solved that and now you are seeing the solution see as I have said in the course preview if you failed to solve the DPP before and you are directly seeing the solution you are not going to appreciate the beauty behind the question the mistake which you may make and you have missed that okay you will fail to analyze where you are wrong you will never ever know where you are lagging in the concepts okay so I sincerely advise you to First solve the DPP and then see the solution okay so now let's move to the questions so the first question is multiple choice question it means out of these four choices only one is correct so let start consider the following statements operating system implementation has architectural constraints this is entirely true we have discussed it so many times let's take another example uh a a smartphone operating system cannot be implemented over a desktop operating system implementation have architectural constraints the second part says operating system is the set of utilities this is true we have given a definition of operating system based on this operating system is a set of utilities which simplifies application development I hope you remember that now so option C is correct both one and two are correct okay let's move to the question number two operating system working on strict deadlines are time sharing no realtime operating system yes this is true realtime operating system works on the strict deadlines and have time constraints for example like fire alarm system hard pacemaker missile control these are example of strict deadline or realtime operating system what must be the primary goal for a hard realtime operating system this is efficiency and only efficiency yeah it after efficiency reliability and robustness may come but the primary goal is the efficient convenience is not the primary goal it is primary goal for for some other operating system like mobile operating system or laptop operating system like Microsoft and Mac the convenien is primary goal for them but for hard realtime operating system like missile control can you afford a missile control to be inefficient no the consequences will be catastrophic then okay so the primary goal will be efficiency question number four this is a multiple select question it means out of these four one or more may be correct okay which of the following statement is our correct during booting OS is loaded into disk from Main memory no the opposite is true OS is loaded from disk to main memory during time of booting okay so this is false the area of memory where operating system is stored is known as the system area yes this is true I have said that this area is the system area and the area where programs or the process are stored are are user area so this was the system area this was the user area uni programming can load and execute a single program in a memory this is true yes it can load and execute only a single program in the memory uni programming suffers from idleness of the CPU this is also true because if a CPU goes for I device uh what I'm saying if the process leave the CPU for some IO Services the CPU is Idle then CPU has nothing to do so in uni programming CPU or unit programming suffers from the idleness of CPU in case of multiprogramming if one process goes for Io the other came for execution CPU will not remain as Idle as was in the uni programming okay so let's move to the question number five I hope the concept was clear for question number four it is a multiple choice question throughput is throughput is total number of program completed per unit time this is as simple as that this is false this is false this is false total number of program loaded now total number of program completed per unit time this was important question number six preemptive process have forceful deallocation this is true better response time yes this is true for example a process has been with the CPU with a a very long time and the other process which are waiting the RQ are starving so what OS will do OS will forcefully deallocate that process from CPU and will give other process waiting a chance to be with the CPU so a response time it's it is it has a better response time than nonpreemptive processes question number seven which of the following statements are true nonpreemptive process can lead to starvation yes this is the thing which I have discussed now non preemptive process is a good response time now preemptive process has a good response time noncp process can release CP voluntarily they always release CP voluntarily either in the case of execution of all instructions or some system call or IO call so for that for those reason nonpreemptive process release the CPU they cannot be forcefully deallocated from the CP question number eight function of operating system include Resource Management yes reliability uh no reliability is the goal of operating system it is not the function security yes security is the function control over system performance yes this is the function so reliability is the goal it is not the function so are there any more questions no the dpb is over now so I hope you got the point you need to First solve by yourself and then see the solution whether you have Sol it correctly or not okay goodbye welcome to the operating system Master course lecture 3 in this lecture we will learn more about user mode and kernel mode and we will see how mode shifting is done between user and kernel mode so we used to represent user and kernel mode like this so this is the user mode the kernel mode these are some user applications user applications are those application which you use like Google Chrome the Microsoft PowerPoint any game you play these are user application and they run in preemptive fashion it means nonatomic fashion it means that operating system can forcefully de locate if a high priority process has come okay and there is a kernel mode kernel mode in kernal mode OS program resides these are non preemptive and they run atomically they cannot be forcefully preemptive they cannot be forcefully deallocated from CPU by operating system so in CPU we have seen there is a registor named processor status World which has a bit named mode bit it could be zero or one zero represents kernel mode and one represents the user mode so we have seen that operating system is a service provider and user programs are the service user and whenever we need some operating system Services we need to shift our mode from user mode to Kernel mode and when our when our motive got completed after the completion of that service we need to switch back from kernel mode to user mode so this is the main objective of our course we will learn how this mod shifting done how the mode shifting is done and why it is necessary so we have seen that kernel level program are privileged program they run they have more rights than user level applications so whenever the user application want to get privileged or want some more rights the mode is shifted from user to gal mode okay so that's why the mode shifting is necessary because if user application want to Avail kernel level Services it has to shift mode from user to Kernel mode now I have also written a word named API so what is an API let's understand by an example so in India here we have EAS that act as an interface between the common people and the government let's let's represent government with a rectangle so these are eitas let's say government has issued a service of the citizenship identification card here in India it is known as AAR card AAR card so I want to Avail that Adar card that citizenship identi ification card from the government so I will not go directly to the any Ministry and will say I want an AAR card I will go to the eitas that will help me to Avail the service of AAR card given by the government for the people so to Avail those Services I will go to the emitra not the government in the same way we'll go to the application programmer interface then API which will tell us what OS Services we can Avail okay so now we will learn the implementation of mod shifting via application programmer interface that is API or seci what is Sci I also written here SCI is system call interface so either application programmer interface or a system call interface we'll learn the implementation of mode shifting via them okay so let's consider a program main int a b c these are the Vari variable I have declared then B = to 1 C = to 2 and then A = to B plus C so user program prr like a c program run in kernel mode no run in user mode so a user program like a c program run in user mode okay so I by mistake I have written this you need to correct them in your notes also okay so how this is implemented so firstly it will go to the compiler the compiler will translate it into instructions and then the ready to run programs that is the set of instructions will be loaded into main memory and then CPU will execute the instruction one by one and in this way these com these programs are executed now let's say I have also included a function here I also included a function okay so this is a user defined function so user defined functions are always implemented in user mode okay so let's say in this user defined function I have also defined I have also used print statement let's say print f percentage D and K we are printing the K value now tell me what is print F so print f is a predefined function we say it's a builin function or we also say it's a library function now I ask you where is the print F defined see f is defined in some let's say in another after the main f is defined okay now I ask you where is the print of defined in C program we write hash include std. do you think the print F defined in this file if you think so you are wrong print T is not defined in The Hider files print T are defined in the library file in header file in header file like stdi stdi Doh this only contain the function declaration or we also say that a function prototype not the function implementation the then where is the print T defined print T defined in the library files which has extension of Li so you must remember this C basic that print f is not defined in the header file it is defined in the library files then what is the use of header file it is used in type checking in syntactic correctness and if the proper argument are passed or not to check this the header file is there the function declaration is there but implementation of print f is not present in the header file so the implementation is present in library file like do a liary file anyway whether it is a predefined function or a user defined function all of both or or sorry both are executed in user mode pardon me English is not my first language that's why but I can speak well enough to make you understand the basic idea what I am trying to say okay so anyway whether it is a predefined function or a user defined function both are executed in user mode okay only operating system only operating system kernel routines or operating system service routines service routines routines or system calls system calls are executed in kernel mode rest functions like predefined function or builtin function we also say that and user defin function both are executed in user mode so which functions are executed in kernel mode or operating system service routine or system calls I hope you have got the idea so so why do predefined functions and user defined functions are executed in user mode simply because they are written by users now you may argue that printf is not or you can argue that in stdi file the print F declaration is there in I file the printf implementation is there I have not written them no you have not written but these are present in the compiler then I guess if they are present in the compiler they should be run by kernel level modes no you are wrong because compilers are not the part of operating system compiler is just a user application program like your other programs or other applications like Microsoft Excel compiler is no different from Microsoft Excel in terms of user and kernel mode so the other programs so the above program didn't require any mode shifting it can be executed completely in the user mode okay so let's take a program which require mode shifting so now I have included a system call in our program that is fork okay so main B = to 1 Cal to 2 the same program was there but I have included now a system call so what is a fork and what does it do so execution of fork result in creating child processes okay so what is a fork I have told you it result ex its execution results in creation of child process and what does it do it's a fun it's a type of function it's a special function and that special function is known as system call if you are conf getting confused between this definition don't worry in the next lecture we will go more and more deep in this part okay or we will take some good examples in the DPP which will help you to build your understanding on Fork so what is a fork Fork execution results in creation of child processes and it's a type of function it's a special function and these special functions are known as system calls what are system calls system calls are those functions which are called to the operating system and Fork is defined or implemented in the OS kernel Fork is an operat system routine so it cannot be directly executed by user mode so to execute this program we need to shift our mode from user to Kernel mode now we will see how to Avail the fork services offered by the operating system now the main concept starts of mode shifting so I have using using some uh short forms like CT CT means compile time BSA means branch and save address if you are getting confused what is a branch and save address and what is SVC supervisory call don't worry we will learn in detail what are those in our computer organization and architecture course for this course you just need to know what I'm going to tell for now okay so this was our program main we started with the main then there are some lines which we don't have to bother about then there is a function which is a predefined function or we can say a user defined function so at compile time user defined functions get transferred or get converted into instructions which we see as branch and save address and branch and save address instructions are non privilege instruction so if you are getting confused what is BSA do not worry we will learn in detail in our COA course okay so these branches save instructions save address instructions are executed in user mode and if an OS routine when it is compiled it is converted into SVC SVC is supervisory call so this supervisory call is executed in kernel mode because the fork requires some additional privileges because it has to replicate the parent process it has to create child processes so SVC includes some privilege instructions so what we need what we need now we need to change our mode from user to Kernel mode okay so let me let me clarify some of the basics high level program when it is compiled it's converted into instruction in the same way when user defined program that is written in the high level language when compiled it is converted into BSI instructions which is branch and C instruction and these are nonprivileged instruction so if user defined function is compiled it is compiled to a nonprivileged instruction and if an OS routine is compiled it is converted to the privilege instructions or it is also known as soft interrupt instructions so what is SVC SVC is supervisory call so when supervisory call at runtime will generate an software interrupt so there's interrupt interrupt means informing the operating system of some activity so there are two type of interrupt software interrupt and Hardware interrupt so we are seeing the example of software interrupt now let's take the example of Hardware interrupt why I'm writing the spelling wrong again and again Hardware interupt let's say Hardware interrupt is you are playing a game let's say rocket League at a CPU at a low processor and a low Ram let's say 2 GB Ram you you have installed a rocket League game on your 2GB Ram computer so the computer is getting Hot and Hot so an interrupt is generated from the hardware please close down these programs the CPU temperature is rising so these are Hardware interrupts and what are software interrupts software interrupts we are discussing now so SVC super supervisory call instructions which are generated when an OS routine is compiled so at compile time the OS routines in compile time generates the SVC and SVC during run time generates a software interrupt what is a software interrupt it informs the operating system of some activity so every instruction has a routine to serve it serve O Okay so this is known as ISR interrupt service routine let me clarify the story again so when OS routine are compiled it is converted into SVC when SVC during runtime is convert generates a software interrupt and software interrupts generate an ISR interrupt service routine every interrupt has a routine service routine to serve the operating system so interrupt service routine is generated and what interrupt service routine will do it has two major work so first firstly it will go and change the mode bit in the PS W processor status World register in the CPU it will change the mode bit from 1 to zero because we are converting from we are transferring from user mode to Kernel mode user mode has a mode bit of one and Kel mode has a mod bit of zero if we have changed the mode bit from 1 to Zer it means we have shifted to Kernel mode okay so now we have we are in the kernel mode we are in the kernel mode now now the question arises how to find where our Fork is we need the address of the fork okay so this was the first activity done by interupt service routine that it has changed the mode bit from 1 to zero now the second activity is interupt service routine has to find the address of the fork so for that OS maintains a table in the kernel known as dispatch table dispatch table is a data structure in Ram it tells what all services OS provides or the address with it so this is a dispatch table dispatch table and in dispatch table there is a name written a fork and its address so the address will be accessed and will go to Fork there are various instructions the instruction will be executed sequentially and the last instruction will be executed it will go again to the processor status word will convert the mode bit from 0 to 1 you know we have to also change back from kernel to user mode why why is necessary you know for the security purposes we cannot always give a user application the admin rights every time we need to change the rights as soon as the service is completed okay so as soon as the last instruction is executed you need to change the bit from 0 to 1 it means kernel mode to user mode so I I guess you have understood let me clarify the story again so what happens whenever the compiler find there is us kernel level program it during compile time it generates SVC that is supervisory call these are the privilege instruction so at SVC at runtime generate software interrupt and every interrupt has a routine to serve it so there is a ISR interrupt service routine interrupt what ISR will do it has two work firstly it will change the mode bit from 1 to zero and secondly it will go to the dispatch table in the operating system and we'll find the address where the where the fork is it will find the add address it will go to the fork execute the instruction one by one sequentially and the last instruction is executed it will again go to the PSW processor status word register and we will change the kernel mode to user mode by changing the mode bit from 0 to 1 and all operating systems follow this Paradigm of user and kernel mode conversion so there are three type of functions we have discussed in the previous 5 minutes the user defined function and the builtin functions these these functions user defin the builin are executed in user mode simply because they are written by the user kernel oh sorry compiler is not the part of operating system system calls are executed by kernel mode so there are three type of function user defined builtin and system calls the first two are executed in user mode and the last one that is system call is executed in the kernel mode okay so this was all the story of how mode shifting is performed now I have a task for you what you need to do you need to what you need to do you need to write everything which I have told in the previous 10 to 15 minutes in form of a flow chart in form of a flow chart you have to show how mode shifting is done and then you have to pause the video write that in your copy and then I will show you the answer so three 2 and 1 so this is the answer so OS routines are accessed through API so it will start with a fork like operating system routine at compile time it can generated SVC supervisory call and then at run time it generates ISR and then it generates it has to work changing the mode bit at the PSW and a dispatch table and in dispatch table it will find the address and it will do the sequential Atomic execution of instruction I have told you the in kernel mode the instructions are executed atomically because they are known preemptive privilege instructions and when the last instruction is executed it will go back to the processor status word and will change the mode bit and in this way the thing is completed okay so I have told you that print F implementation was in library file so if printf want to access the device and device control is with the operating system then it has also has to change the mode bit from user to Kernel so let's say in printf implementation there is some user mode level programs the statements and then suddenly a system call is there that is right so Library function like print F can also use system calls and when system call is there mode shifting will occur okay so in this way I have represented this so there is a user process user process executing system call and then system call Will generate a trap so you must be wondering now what is a trap don't worry it's same as an interrupt interrupt and trap are the same thing so mode WID will here is zero so it will execute it will change the mode WID from 0 1 to 0o mode bit is zero now now it will execute the system call it will change the mode bit from 0 to 1 and then it will return from the system call in this way the mode shifting is completed so no interrupt is generated during kernel to users transformation so you have you may see here there is a no trap while going back from kernel to user mode the interrupt is generated only when user to Kernel shifting is there okay so when we need just a vage instruction without interrupt to switch from kernel to user mode so we do not need an interrupt from kernel to user mode shifting so I hope you have understood how mode shifting is done and what are kernel and user mode properly so there's a DPP which I'm giving you right now you have to solve that and in the next lecture we will discuss them welcome to the operating system Master course this is DPP number two let's start so the first question says it is multiple select question which of the following statements are allowed in kernel mode only only kernel mode can do this user mode cannot do that so the first says enabling and disabling interrupts yes this is a kernel mode operation So the instructions that run in the kernel mode are known as privilege instructions and privilege instructions can only enable and disable interrupts reading the system time no user mode can also do do this contact switching contact switching is the part which we are going to learn later it is a very common thing we will learn don't worry for now so the Contex switching is also a kernel mode operation just remember this for now contact switching is a kernel mode operation and cannot be performed by user mode clear the memory clear the memory or remove any process from the memory this is a kernel mode operation so which options are the correct a c and d are correct okay let's move down to the question number two it is also a multiple select question it says which of the following are correct to switch from kernel mode to user mode the mode WID should be changed to one so so the kernel mode has a mode bit of zero and user mode has a mode bit of one to switch from kernel to user we have to change the mode bit to one so this option is correct to switch from kernel mode to user mode the mode should be so this is the same thing you have to what remember from kernel to user change the mode bit to one and from K uh user to Kernel change the mode bit to zero so this is a kernel mode operation this is a kernel mode bit and this is a user mode bit do you can do this now okay the question number two I hope you can do this the answer is uh change to one this is correct this is false this is false to switch from user to this is true so option A and D is true let's move to the question number three it is a multiple choice question user mode user mode is atomic no user mode is a mode bit of Zero no user mode is privilege no user mode is preemptive so this is true Cal mode is atomic it's mode bit has zero and it is privilege so I hope you can do this now this is true move to the question number four it is a multiple choice question system call is used to access operating system functionality system call is used to access operating system functionality this is common thing I don't think it needs some explanation question number five consider the following statements predefined function start executing in kernel mode and the second says user defined function start executing user mode so I've already told you predefined function whether it is predefined function or user defined function they both execute in user mode only the system calls or operating system service routine execute in the kernel mode so which is correct only second is correct user defined function start execute in the user mode predefined function also execute in the user mode it doesn't execute in the kernel mode question number six so this may be a tough question for you so let's solve it this now consider the following program main 444 so there are three folks and then a print statement and then return zero so what do you think how many times G to to 2 three will be printed uh so I have told you that execution of work results in the creation of child process so when this Fork will be executed these three will be copied I mean it's it's like the duplicating let's say if this is a fork and then some print statement print one so 2 * 1 will be printed so 1 one this will be the output let's say there are fork and then print one so when this Fork Fork will be executed these two will be duplicated let's say like this fork and print when this Fork will be executed this print will be duplicated so one and one and this this four will execute one and one so four * 1 will be printed in the similar way when there are three folks then eight time 2023 G 2023 will be printed so so I hope you are not understanding it properly so let me explain you a different way let me explain in form of a tree so when this Fork will be executed these three will be duplicated down there in the next level so I will write fork for this Fork another fork for this fork and a print statement for the last print statement now for this when this Fork will be executed these two child process will come there so Fork and the print statement will go there when this Fork executed this print will be duplicated so print will come here now when this Fork executed this fork and print will go there so I will write let me change the color uh let's choose this so it will like fork and then print when this Fork will be executed the print statement this print will go there okay when this for will executed this print statement will go there so print and then uh I guess now we will execute this Fork the print statement this print will go there so when we'll execute this Fork the print statement will come so now we can see all the forks are executed and only print statements are remaining in the leaf nodes so 1 2 3 4 5 6 7 and 8 so we have seen eight times the print statement was there what if I include another 4K here how many times this will be printed so we have seen if a fork if only one fork was there it was printed only one time oh it was printed for two time like fork and print so what will this Fork do it will duplicate this print statement so print and print two times print are there so if one fork was there it was printing two times if two Fork was there it will print four times if Three Forks are there we have seen it will print for eight times if if four Forks are there then it will print for 16 times times how did I get 16 so quickly because I have created a formula for this let end be the time Fork is present then the next statement just below the forks let's say fork Fork Fork so this Fork has present n times Fork n times so the next statement will be executed 2 ra to the^ n * here it was 2^ 1 it is 2^ 2 it is 2^ 3 if it is n then it will be 2 power N I hope now it is clear for you so let's move to the question number seven mod bit is present in is it present in main memory no it is present in dis now it is present in cash no it is present in the register I've already told you it is present in the register named PSW processor status world it is in the CPU at system boot time the hardware starts in kernel mode man the in the system boot times the hardware starts in the kernel mode okay so so this was the DPP number two we have discussed there was a special concept of fork which we learned and a formula we learned rest was the easy question so you should have done at least six question out of these eight correctly okay so if you're unable do not worry just try to focus more during the lectures and then avoid silly mistakes and you will make it through hello everyone welcome to the section two Process Management we are starting with the lecture six in this lecture we are going to learn everything about what is a process so some student may have doubt about a program and a process is the process and program same we will clarify that in detail in this lecture okay we will learn about what is a process it several definitions like we did in case of operating system in lecture one I will give you several definition of a process I will tell you what operations process can perform what are the attributes of a process how does the process look like in a memory so are you ready for this interesting lecture tighten your seat belts and let's start so we will first start with a difference between a program and a process so let me tell you straightly imagine you have written a high level code now you have compiled it it will be converted into doxe file if this is present in the hard disk this is a program if this is present in the memory this is a process it is so simple to understand so if a program ISE file and it is present in the hard disk it is a process it is a program and if a program is in execution I mean it is in the main memory then it it becomes a process so when program is loaded from dis to main memory it becomes the process process is the instance of a program process is the instance of a program okay so in program there are two things data and instructions data include operant and variables and instruction include add load multiply store there are various like SBC and BSA supervisory call and the BSA branch and save address we studied in the last lecture okay so let's understand by this example here we have declared three variable a b and c b is equal to 1 C = to 2 and a equal to B plus C so simple like that now when this will be passed to the compiler it will generate a list of instructions and this list of instruction is nothing but a program and if this is stored in the hard disk it is a program if this is stored in the memory it is a process so what we need to do we need to add the value of B and C and store it in a so we'll first load the constant value in B the constant value in C now the addition is performed between registers so we have to load the value of B into register 1 and C into register 2 add both registers and store the value or the result in R1 and then the store the value of R1 in a and we will get a equal to B plus C so this is the lowle instructions converted from the high level piece of Code by the compiler and these instructions if it stored in the hard disk are program if it stored in the memory is process so simple so process is something which is Created from the program okay now data is of two types static data and dynamic data so this is a part from C language course also but I think I am feeling the need to also add this here in the operating system course because this will be necessary when I will be explaining the process as abstract data type or process how the process look in the memory okay don't Focus what I said Just remember data is of two type static and dynamic static means fixed size or known size dynamic means it is weing or it may be of the fixed size but it is allocated at the run time so if Dynamic data is allocated at the run time is static data allocated at the compile time no the answer is wrong so I have written that at form of question at what time of a program execution memory allocation occurs for static data compile time no compile time is wrong why because compile time is meant for checking syntactic correctness and generating the code which code this instruction code I was talking about so what if just imagine the scenario what if I just compile the program and do not run it this is possible uh in Unix we see JCC and then uh the name test. c this mean I have compiled it and a file named a.out is created or okay so if I have to execute I have to write do/ a.out and then it will be executed okay but in this case what I'm doing I am just compiling the program and I'm not running it it means I have just written this in the terminal and pressed enter I have not written the next statement of executing so memory located at compile time is a wastage because I have not executed this I have just compiled what is the point of allocating the memory at compile time what if the user do not execute it it means the wastage of memory occurs if the memory is allocated at compile time compiler only decides how much memory allocation should be there compiler only decides how much okay so between compile time and run time there is another time that is load time what is load time load time is the time when the program is loaded from dis to memory for execution so for static data like this in a c for static data the memory is allocated at load time neither compile time nor run time but at the load time for dynamic data the memory is allocated at runtime okay I hope the concept is clear let's move ahead so I have written like this int n and I have created I have declared an array A N I have not created it I have declared an AR okay now what I'm doing I am taking the value of n from the user I taking the input n is this possible in C or is this valid in C so the answer is no this is not valid in C language so Dynamic array are not created in C language like this we are just taking the input and then a and no this is not the right way but can we do this in C++ yes this is allowed in C++ then if I want to implement the dynamic array how should I Implement in C so we used the term maloc okay if you are unaware about the Malo or you have heard the first heard the Malo for the first time this means you are weak in C programming so you must watch the C programming course before the operating system course because it is the prerequisite for the operating system course okay for now let's if you you have not don't worry for now I will give you enough information to understand the context which I'm here to give you for understanding this process thing okay so how we create the dynamic array of size n in C without by not doing this so alternatively we do this by Malo so we have created intn and declared a pointer and then we took the input from the user and then we declared a pointer which has created which in which is pointing the dynamic array of size n so this is how it is done this is how it is done so a regular integer is of two B so this n is of two B so this is declared in as a static form at the load time now this pointer is also declared the load time because this is also static now for Malo thing it means we are declaring a dynamic array so this Dynamic array will be allocating memory at run time so this point this pointer will be pointing to the dynamic array of size n this pointer is pointing to the dynamic array of size n so the address of the first element of the array and the pointer should be the same that is the only meaning of pointing it okay so this is how the dynamic memory location is done using Melo in C okay so we'll learn more about it in C and DSA Master course so as objec is to class in oops the same way process is to program object is the instance of a class in the same way process is the instance of a program okay so the first part of this lecture is over here which differentiate between a process and a program so I will say again what is the difference between process and program so high level code is converted intoe part by compiler if the XE file is in hard disk then it is a program if the XE file is in the memory then it is a process as simple as that okay so let's start with the process now the definition the representation the operation and the attributes this four thing we are going to learn about the process so what is the process process is the program in execution and if a program isn't execution it means it is using the computer resources program doesn't use the computer resources it is as good as dead but the process is alive it uses the Computer Resources it is like the program in execution so process is a program when it get loaded in the memory process is the instance of a program these three definitions I have already explained you the fourth one is process is active entity that is also I have explained you it means it using the computer resources program is passive it doesn't use resources it is dead and process is alive process is always in the memory program is always in the hard disk if the program is shifted from hard disk to memory it becomes the process process is the locus of control of operating system what does it mean it is the same as people are the locus of control for the government so people are the process and government is the operating system let me repeat locus of control of operating system is process in the same way locus of control of government is the people okay the process is the animated disp so this is a term used by an author so what does it represents it is representing that in a body there exist a soul in the same way in a program the soul is the process okay the program is dead without the process process is alive the soul is alive the body is dead the soul is alive the body is as good as dead if the soul is not present okay so I hope you understood what is the process its definition let me repeat process is nothing but a program in execution it is the instance of a program okay so when a program is transferred from hard disk to the memory it becomes the process now we have to learn from the developers perspective what is a process okay so process is an abstract data type or simply a data structure so any data structure is represented in four things each data structure have four part the definition the representation or we can say implementation third is Operation and fourth is attribute for example linked list link list is a data structure so what is the definition of the link list a link list is a linear data structure blah blah blah it has a definition how it is implemented it is implemented using nodes or data and reference to the next node what are the operation it can perform like insertion delion travel Etc what are the attributes he head tail size length data next null these are the attributes of the link list that's why I have told you that C+ C or C++ and DSA and Kaa is the prerequisite for this course so that you can relate better okay so for link list these are the four things any data structure have four parts definition representation operation and attributes like link list of the four parts the process similarly also have four parts I have I have cleared the definition for you now we will learn how the process is represented in the memory now in the same way we need to Define process we have defined the process how does the process look like in the memory okay so I have cleared you the program consist of two things instruction and data data is of two type static and dynamic and the program creates the process okay so how does the process look like in the memory how does the program creates the process by going from hard dis to the memory now the program is in memory it is process how does the process look like in the memory so the process process look like this the process has four parts text Data Heap and the St what is this aror representing is representing it is not fixed it is shiftable it shifted as per the needs okay so the first thing is the text text means the code section the second thing is the data data means Global variable and static data static data it means the fixed size data of fix size like we have seen int X that is the static data let me clarify the data is of two type the static data is of two type or the global variables is of two type or simply say data consist of two parts initialized and uninitialized data initialized data is like int x equal to 1 I have initialized the value of x to be one and un uninitialized data is that simply int X so uninitialized data is stored in another compartment and initialized data is stored in another compartment okay so text is clear it is the code section data is clear it is global variable and static data what is Heap Heap is the area in memory for dynamic memory allocation okay so Heap means D dynamic memory allocation and for a stack what is stack used the stack contains the activation record of function calls now if you are weak C Concepts you may wonder what are activation records so let me clarify that for you activation record does not not contain the address of the function so does activation record contain the address of the function no what does it contain then it contains the information and space of the local variables okay so let me give you an example so this is a piece of code int X Main and then static part static int y int K RL these are some variables I have defined and then a function and then again some something and then this function is this is the Declaration and this is the this is declaration and this is the definition okay now the function is defined here the function has two parameters int Zed and int e these are the argument these are the parameters so the function has two parameters int Z and int e and some other variables are also declared here like P Q and L blah blah blah so just take it as as example as a random code I have given to explain you how the activation records are created so this is what is this let me explain you what is this this is the global data so where is the global data will be stored it is stored here in the data section okay now now comes the main part main is the function I have said that activation records of function calls are stored in the stack so as soon as the compiler will reach at this line main an activation record for main will be created here so this activation record is created now in this activation record what does it store activation record stores the information and space of the local variables what are local variables here k r l are the local variables so I have written K RL the local variables here the space of the local variables and its information are stored plus a return address is also stored in the activation records so it will keep executing it will keep compiling these lines and then when it will reach here to another function call it will create an another activation record above the main activation record in the stack so another activation record is pushed as soon as it will reach this line of KR okay so what does it will contain it will contain the local variables z e p q l all are the local variables here so all of them will be stored plus I have said the return address so the return address is C let's say it's is a c so when this function will be compiled the compiler will point to this line that is the this is the return address let's say C is the return address so I will put return address is equals to C that is when this will be compiled you have to go back to the address which I'm giving you that is C so the compiler will start compiling from this line onwards K = to R+L and then the compilation continues so I hope you have you have got the idea what activation records are activation records are the part in the system Stacks that contain the information and a space of local variables plus it also contain the return address of that function in main it contain the return address of Main and in function f activation record it contains the returned address of function f that is if function f is completely compiled then the compiler has to move to this return address that is C that means the next line k equal to r+ okay so when the compiler will move to this this activation record will be deleted and when compiler will compile the last line of main this activation record of main will also be completed okay so activation record of main function gets deleted when the function is deleted or the function is completed okay I should have written completed here instead of deleted okay now it is good so how does the process look like it consist of four parts text it contains the code section initialized data it contains the data like int xal to 1 un uninitialized data it contains the data like int X and then Heap Heap contains the dynamic dynamically allocated memory and then stack contains the activation record of the function and they can shrink and grow as per the requirement okay and now I have a homework for you you have to learn about the VSS extension that is block start by symbol this is the homework you have to learn about this and then you have to comment I don't know you can comment here on you or not but this is the homework we will discuss that in the next lecture so activation record that part is discussed now we have also completed this part the representation part let's move to the operation part we'll move to the operation what several operation the process can perform it can perform the create create means resource allocation resource allocation process get created by this operation memory and resources which are necessary for the process are allocated I think it is simple it doesn't need any more explanation what is create operation create operation means allocating resources which are necessary for the process and the process gets created what is termination it means resource deallocation all the proc all the resources which were given to the process are taken back from the process and the process is destroyed for create the process was created and terminate the process gets terminated schedule the act of selecting process to run on the CPU out of several in multiprogramming operating system this was the OS and there were several processes waiting for the CPU so selecting out of these three which process should be there with the CPU first so this is scheduling the act of selecting process to run on the CPU execute or run executing instruction from code section so this is selfexplanatory I have no need to explain block and weight yes this is something which need explanation so process will get blocked when it will execute system call or iio operation it has to wait okay now the suspend part sometime we need to move the process from memory to disk so you must be wondering I have not explained this part the block and weight the suspend the resume so these all things are the part of transition diagram so process move from several States it starts from the create and then terminate in between there are several States like block ready running suspend these are the all parts of transition diagram of the process which we are about to discuss in the next lecture so for now just remember these are just the operation which process can perform what are those its intrig cases will be discussed in the next lecture when we will discuss the transition diagram of the process okay so what is block and weight the process will get blocked when it will execute system call or I operation suspend sometime we need to move the process from memory to disk resume if the if our motive is completed now we have to bring the process back from disk to memory this is the resume part and suspension means memory to disk resume means dis to memory okay now I have completed the third part of the process also that is the operations now let's come to the attributes so the first attribute is for identification type attribute that is the process ID the parent process ID the group ID Etc the CPU related attributes like program counter what is a program counter the program counter will always point to the next instruction to be executed so these are the attributes of the process priority that is the level of importance should be given by OS to the process the state which state the process is in is it in running State the suspended State the blocked State okay and the bust time how much time the process has spent in the C CPU for execution these all are the attributes CPU related okay memory related attributes the third thing it includes size limits the process in which area of the memory is present these are the things file related device related file related means list of the all files which are used by the process accounting related it means which of the following uh which resources are used by the process for execution so these all attributes identification related CPU related memory related file related device related accounting related Etc all the attributes are stored in the PCB that is process control block it is just like the ID card of the process it will contain the process ID its parent ID everything the every information about the process is in this PCB that is the process control block it contain the attribute of the process each process has its own PCB and the pcbs are stored in the memory so this was for this lecture six let's revise what we have done in this lecture so firstly we started with the difference between program and the process next we learned several C Concepts that were necessary to discuss and then next we move to the definition of the process and then we learn the process from developers perspective how the process is an abstract data type its definition it's representation implementation attributes and in the end we learned that all the attributes are stored in PCB the process control block which is stored in the memory each process has its own PCB now in the next lecture we will learn about the scheding cues queing diagrams the transition diagram which I was referring there and schedulers and dispatchers thank you hello everyone welcome to lecture eight of operating system Master course we'll start our discussion from process control block and then we will move to the states of the process which process covers from is it's beginning to end so during the whole process lifetime process covers several States process moves from one state to another and how the process moves which is represented through the process State transition diagram I'm going to guarantee you that the amount of depth which we are going to cover here in this lecture is unmatchable to any content on this platform and when I used to teach in classes people used to ask some common doubts I've also taken those doubts like this and their answers okay so we'll start our discussion now okay let's go so in the last lecture we have seen what PCB is so let's just revise so PCB is also known as process descriptor it's stored in the memory and the total content of the PCB is known as process context or process environment remember this I have talked about this in one of the DPP so context switching is related to this we are going to learn that context switching in the next next lecture okay so for now just remember the contents of the PCB is known as process context or process environment context the famous word during the process lifetime process goes from one state to another just like uh human it start with a child it it start with a infant and then child and then school boy adolesence and then youth in the end it dies old age and then it dies in the same way process also goes from various stages so this is the stage one the new in which process gets created resource allocation happens in the ready which process are in the ready state which are ready to run on the CPU so the process which are ready to run on the CPU belongs to the ready state in running State the process is actually in the CPU so the process is executing instructions on the CPU and then block SL weit it means it leave the CPU process need to perform I operation or execute a system call for I operation okay so I'm giving example like what is Io Io means reading something from the device writing something from writing something to the device I should use a proper preposition writing something to the device pardon me I'm learning the English language okay and then the last stage is terminate so the process has completed all of the instructions and resources are taken back from the process so resource deallocation happens okay so how many states are there new ready running block and wait and then terminate so we are starting with these five process only but as we move as we learn more we'll go we'll learn the two more stages that is suspend block and suspend ready okay so for now we will learn the process State transition diagram in five states only okay so this is the new state CPU oh operating system allocates the resource it create the process and when the process is created it is ready to be actually executed in the CPU so in this ready stage the process is ready for CPU okay now what is scheduling and what is dispatch scheduling means making a decision out out of many ready processes which will be chosen for the CPU I've told you several times that only one process can run on CPU at a time so out of several ready process out of sever I have let me represent out of several ready process I have already told you in in this way there are several process P1 P2 P3 PN out of these only one will be with the CPU being executed okay so now OS has to choose out of these ready processes which I have to s to CPU so that is scheduling and what is dispatch dispatch means CPU gains the right to execute instruction of that process CPU gains the right to execute instruction of that process so I'm feeling the need to clarify your doubt we say it's just a matter of saying that we say the first the process was in hard disk and then it has moved to main memory here the process has actually moved from hard disk to main memory in hard disk it was a program in main memory we say it as a process it has actually moved the process has actually moved but when we say the process from Main memory has moved to CPU that is just a a way of saying it has not actually moved to CPU CPU has got the control to execute instructions of the process let's imagine like this okay so this was the OS and then uh let's say the P1 process is in the main memory so there are several instruction like i1 I2 I3 now the CPU has gained the rights over the instruction instu of the process one to execute them now CPU will execute instruction one and then instruction two and then instruction three the the process has not actually went these instruction has not actually went to the CPU the CPU is at its place the process is in main memory CPU has got rights to execute those instructions okay so the process Still Remains in the main memory CPU just gets the control to execute the process in the same way when we say the process was initially in the CPU let's imagine this is just a way of seeing and then it has moved to the io devices to perform some iio Services now CPU is empty this is just a way to explain a child okay you are you are children in context to operating system so this is a way to explain the process has not actually moved from CPU to I devices okay the process resides in the main memory process does not perform the I operation we learn this later in this lecture okay so the process does not perform the I operation it is the operating system which perform the I operation process tells the O while remaining in the main memory that I need the I services so it will make a system call the process will make a system call that OS will hear and then OS will say what is it the process say to OS see OS I require this and this IO Services the pro the operating system will say okay you wait in here in the memory I will do that service for you and then I will give you the results I hope you got the point so the process always remains in the main memory either it is being executed by the CPU or it is getting some IO services from the operating system it is in the main memory or we will learn it later the process either it is in the main memory or in the hard disk sometimes the process need to be shifted from Main memory to the hard disk also from till now we have learned that we need to shift the program from hard disk to main memory so that it becomes the process now I'm also telling you that operating system also feel the need to shift the process from Main memory to hard disk can you guess why because there is so much clutter in the main memory so that operating system feel I need to clear some process I have to hold some process I have to keep some process on hold so it will shift the process from Main memory to the hard disk so that the number of process in the main memory becomes manageable for the OS okay so operate the process does not go to the CPU or to the io devices is it resides either in the main memory or in the hard disk so this was the concept I felt you must be cleared with Okay so this concept should be crystal clear now let's move to our state diagram so we started with the new the process get created the resource allocation done is done and then the process is moved to the ready State and then out of several ready State CPU will choose one and then uh sorry operating system will choose one and then it will give rights to the CPU to execute the instruction of the processes okay so that part if the CPU start executing it its instruction the process is in running State now if all the instructions of the process are executed then the process transits from running to termination running to termination because all of the instructions of the process has been executed now let's see the process feels that it requires some input output services so it will make a system call for an io2 oos hm so it will make a system call Now voice will say okay you wait so it will take the rights of execution from CPU and the process is in weight State or the process is blocked from being executed by operating system so the process is in waight state where it is waiting it is waiting in the main memory okay so the process is in weightage state when the io or system call has been completed the process has got what it wanted it is again shifted to it is again shifted to ready state so let me clear you the story again so the process started with a new resource allocation happens the process is created it is in the ready State ready to be executed by the CPU out of several ready processes CPU is given one process by the operating system that choosing the one process out of several ready process is scheduling and then giving the op uh giving the CPU the rights to execute the instruction is dispatching if the CPU start executing the instruction the process is in running State and then if all the instructions of the CPU if if all the instruction has been executed by the CPU then the process isn't termination stage okay while running there is a need for input output Services then the operate the process will make a system call to the operating system operating system will say okay you wait in the main memory I'll do the io services for you and we'll give you the results the when the operating when the operating system give the process the results or the io service which it needed it is again sent back to ready stage ready to be executed the rest of the instructions okay suppose let's say the instructions are i1 I2 I3 I4 and I5 in I3 it requires some IO services so the instruction one is executed by the CPU 2 is executed and then in the third stage if it needs IO then it will be the the operating system will take the rights from the CPU for ex for executing the instructions and the process will wait in the main memory and when the operating system completed the io services and give the io results to the process it will again be sent to the ready state for next instruction to be executed so when the scheduler will choose the process let's say this process was P1 when the Scher will choose P1 and send it to the running stage the CPU will execute its remaining instructions so I hope the story is clear to you okay so when will the process Transit from running to block State when it needs some IO call and when IO call is completed it is again sent back to ready state for its remaining instruction to be executed okay now there's a question arises by seeing this process straight transition diagram can you guess which type of operating system is it is it multiprogramming operating system or uni programming operating system so we can here observe that there is a ready State Ready State contain all those processes which are ready to be scheduled for Execution this itself clears the point that there are several processes which OS is holding in the main memory it means it is multiprogramming operating system so due to this ready State we can say this is a multiprogramming operating system now my question two whether this is a diagram of preemptive operating system or non preemptive operating system can you tell me yes you are correct this is a diagram of of non preemptive operating system because the process is exiting the CPU only when either it is completed or it needs an iio service if I made a shift like this it becomes a preemptive system that the process is forcefully preempted from the CPU and put back to the ready stage okay so what is scheduling and dispatching scheduling means selecting and dispatching means giving control okay so what should be the state transition diagram for uni programming operating system so for uni programming operating system there is a no need for ready stage because there's only one process so when the process is created it will directly send to the running state if it needs some IO it will go to the block State and then when the io service is completed it will again come back to the running stage and then it is terminated so no ready stage because there's only a single program or process okay so let's move now every process will complete from running state only so you you can see there's only one path for termination stage that comes from the running stage only there is only one path from running state to the termination state so the process will complete from running state only you should remember this because it is an important concept so I must clarify this more so we will write like this exit in the end of the program that statement must be executed on CPU to terminate the process so it should be in the running State before it get terminated okay so I have already cleared this this is a diagram for non preemptive and then if I do this transition that is forceful deallocation Force for deallocation now it has become preemptive okay so this is preemptive based m programming operating system okay so here you can see here in this you can see the process will leave the CPU voluntarily on its own when it is leaving the CPU either it is completed or it needs some I or system call so in this case in this case preemption is not occurring and here the preemption is there based on either time or either priority okay so let's move down here are some important notes that you must remember number either process is in a ready State running state or blocked State the process is in the main memory let me clarify either the process is in the ready State the running State or the blocked State the process is in the main memory okay this is the part where the process is entering the main memory the resource allocation is being occurring well this is a grammatical error so this is a part where resource allocation occurs and this is a part where resource deallocation occurs here it is entering the main memory here it is leaving the main memory in these three states that is ready running and block and weight the process is actually in the main memory okay so either process is in ready State running state or blocked State the process is in the main memory in new it is entering the main memory in terminate it is leaving the main memory Point number two there can be multiple process in ready and blocked State theoretically infinite process can be in the radiant block State there there is no limit there is no limit it depends upon the capacity of ram it depends upon the capacity of operating system to manage that much service that much processes okay so this is the operating system here let's say the hard disk it has theoretically infinite processes and this this Ram or main memory is theoretically infinite so operating system can load and manage theoretically infinite processes so how many state can be in the ready or blocked State theoretically infinite but how many process can be in the running state so I have told you several time that at a time CPU can work upon only a single process if it is a multiprocessor CPU let's say it has n CPUs then n processes can be in the running State let's say let's say if it has if the system has n CPU then end processes can be in the running State at a single time if it has one CPU if it is uniprocessor then only one process will be executed by the CPU at a time okay so I have written there can be at Max One Running process for one CPU at Max One Running process for one CPU if there are multiple CPU there can be multiple running process depending upon the number of CPUs so maximum process and radi blocked State can be theoretical infinite maximum process in the running State depends upon the number of CPUs there can be multiple process in radiant blocked state but there can be only one process running for one CPU okay so now the important part come that is the suspension so we'll learn the suspension part and we'll continue or the we'll continue the seven State transition diagram this part we will continue in the next lecture okay so now we'll understand what is suspension so let's take the example of a classroom suppose uh let me write in the this page okay suppose take this example this is me teaching in a classroom okay there are several students like let's say the capacity of classroom is 100 students so when I came from uh my home to to the school I see there are already 150 students sitting in the classroom for my lecture so what I will say I will say hey guys uh why didn't you 50 guys the 50 guys which were standing here by disciplined 50 guys there are there I say why hey why don't you 50 guys go out in another classroom when I will complete my lecture for these 100 students I will call you again and I will give you the same lecture so the 50 I says okay sir no problem we are good with this so what I have done these 150 students are the process which are unmanageable by this OS so the students are representing the process and this is me the operating system and what does this classroom represent this classroom represents the main memory and what does this classroom represents which I have told the 50 students to go go this represent the hard disk so you remember I have told you one time that there is a case in which the operating system transfer the process from Main memory to the disk what we usually do we usually brings the process from dis to main memory but here in this case we are transferring the process from Main memory to the dis why is it so why do you think I have sent those 50 student to the next class because I want to improve performance I don't want any disturbance the heat of the classroom will increase because there are so much students above capacity in the same way the suspension this process is suspension suspension of 50 50 students that is the 50 process the 50 processes should be moved from Main memory to the dis to improve the performance to improve the efficiency so the what does I have written here so let's say there are 120 ready programs ready to run programs in the main memory and Os can handle only 100 so the OS will transfer the rest 20 from Main memory to the hard disk to improve the performance this is suspension so I already took the example of a classroom now the question arises from which states we can suspend the processes we can State we can suspend from those we can suspend only those students see here we can suspend only those students which are already present in this classroom I cannot suspend the student which is standing outside the classroom I cannot suspend the student which is going out of this classroom what is the point of saying that I'm suspending a student which is already going out of a classroom so this student which is standing out of the classroom is the process in the new state and this student which is going out of the classro is the process in the termination stage so which isent students I can suspend I can suspend those students which are there in this classroom so I can suspend those processes operating system can suspend those processes which are in the main memory so which processes are in the main memory the process in the ready State the process in the running State and the process in the blogged state now can you guess which is the most desirable state for suspension the ready state is the most desirable State for the suspension because in this state the process is already being executed by the CPU in this state the process is waiting for operating system to complete its IO call so ready state is the most desirable state for suspension so I have written this ready state is the most desirable state for suspension because the there the process is neither running nor performing and input output call okay so in the next lecture this lecture length is going way high it's already half an hour so in the next lecture we will learn the seven State process transition diagram goodbye okay so let's continue our lecture so in the last lecture we discussed the need of suspension of the process because we want to improve the performance we've also discussed an example of the classroom so we can suspend the state from ready we can suspend the process from ready State running State and blocked State because these are the states in which the process is in memory what is a suspension suspension means Shifting the process from memory to the dis this is the suspension so we can only suspend those process which are in the memory we cannot suspend those process which are not in the memory like the process in the new state and the terminated state so which is the most desirable state for suspension ready State because there the process is neither running nor performing the io we have discussed all that in our previous lecture now we will see the transition diagram so from ready State we can suspend the process to the state suspend ready and if we want to bring the process back from dis to memory you will say it resume so suspend resume suspend means Shifting the process from memory to the disk and then resuming means shift Shifting the process back from disk to memory we can also suspend a process from CPU the process which is currently running but this is not desirable so I have denoted those transition which are possible but not desirable with dotted lines okay so we can also suspend from block State the process which is waiting in the memory for a long time we will suspend the process hey you can you are just waiting there and you are making the me memory messy so you can just go and wait in the dis because it's doing nothing it's just waiting so OS will say you can wait in the disc also so it will suspend the process to the suspended block State and well and when it thinks the process should be brought back to the memory it will resume so suspension resume okay so we have taken an example so this is the process Pi it was waiting for some IO from a long time now OS will say Hey you are just waiting so why can't you wait in the main why can't you wait in the disk instead of waiting the main memory so OS will transfer to disk to improve the pro efficiency it will transfer the process to the disk so it will come here Pi so it will in the suspended block State and when o will get the time to Surf this process when the iio operation is completed by the OS it won't remain in the suspended block state it is now ready to be brought back to the memory okay so this was the case suspended block state it was waiting for some resources now when it is ready to be scheduled it is in the suspended ready State and from suspended ready state it will go back to the ready State like this okay so for example if a process is waiting for a data from a file it will in the suspended block State until the data becomes available once the data is ready or IO service which it was asking for is completed the process transition to the suspended ready the process transition to the suspended ready State and can be scheduled to run by the operating system okay so so let's discuss these points I have written I summarized here let's read this process is running State initially the process is in running State execute its instructions okay now the process request for the io service or a system call the process may require IO service such as reading from a file or sending a data over the network it makes a system call to request the services this was the part two like it this is the thing which we are discussing now now the process is in the blocked State the process transition to a blocked State while waiting for the requested IO operation to complete while in this state the process is not actively executed instructions hence what the operating system will do it will send this process from memory to the disk to improve the efficiency now the operating Sy system handle the requested iio operation for example if the process requested to read data from a file the operating system would perform the necessary dis ey operation to read the data into the memory now the process resumes for I operation is complete the process transition back to the ready State indicating that it is ready to continue executing the operating system scheduler will determine when to schedule this this thing scheduler we will discuss in the next lecture what is a scheder and dispatcher okay in detail so I hope hope you are getting somewhat what I'm saying but to clarify it fully let us see the legendary seven State process transition diagram we'll clarify from the beginning to the end so the first the new state I hope you know what is a new state it is the state which contain the pcvs of the process which are ready to be loaded in the main memory so the process is created the process is allocated the resources in the ready state the scheduler will schedule the process and dispatch to the CPU so scheduling and dispatching is being done in the ready State the process transitions from ready to the Running by scheder and dispatcher and now three cases are there either it terminates or preemption happens or it needs an IO service from the operating system so if the preemption happens it goes back to the ready state if it's terminate it go to the terminate state it ends and if it requires some IO service it will go to the block State now if it is waiting from a long time the OS will say hey you're just waiting doing nothing in the memory memory is a place for the process which are important you are just waiting here so you can also wait in the dis so it will suspend the process and we'll move to the suspended block State now from suspended block state it can go two way either it will directly resume to the block state or it will go to the suspended ready and from suspended ready it will resume to the ready so the process may follow this path or may follow this path okay so here I have written when an application need to perform an ie operation such as reading or writing a file it make a request to the kernel through a system call the kernel then handles th operation and when the operation is complete it Returns the result to the application so this is the part the IE operation part which I'm discussing here now there is a case there is a new thing which I'm discussing for the first time this is the new thing suppose a process is in the ready State ready to be scheduled for Execution but suddenly OS says Hey process you are getting resources R1 R2 and R3 and I am in the sudden need of resource R1 so I am taking the resource R1 from you so the resource R1 is preempted by the OS now what will happen the process cannot be scheduled because it lacks the resources which it needed so it will go to the block State and when OS will return the resources to the process it will go to the r State again okay so now I have discussed completely what is a process State transition diagram how the process Transit from one state to another now let's address some of the doubts which may arise in your mind so why the process is moved from blogged to the suspended block okay so why the process has moved from blogged to the suspended block let's discuss here the process is moved to the suspended block State due to the resource management and multitasking needs so this is just the formal thing which I've told you already when the process is in Block state it is waiting for an ey operation to complete okay so this was the thing which Ive written there also it is waiting for some eye operation okay however sometime the operating system need to free up the resources like memory so or it might need to pause the process for other reasons like if the user searches to a different application in these cases the operating system can move the process from blogged state to the suspended blog State this is the thing from for these reason the operating system can move the process from blocked state to the suspended block State okay so I have summarized that point to just in to improve efficiency in suspended block State the process is not only waiting for an i operation to complete but it is also swept out of main memory it is in the disk now and placed onto the disk storage this frees of the system resources and allow the operation to work on active processes that's why the process a move from blogged state to the suspended blog State okay so this is the thing once the operation is complete the system resources are now available again the process can be moved back to the main memory and transition to the ready state where it is eligible to continue running on the CPU so that's the thing now the question number two why send to suspend ready instead of ready okay why is the need to send to suspend ready instead of just ready so why don't from this suspended block State why don't we can directly transfer it to the ready State instead of suspended ready State why is it so so transition from suspended block to suspended ready instead of directly to the ready state it is due to the way how operating system works it is the way of operating system it's due to the way operating system manage memory and resources so when a process is in supended blog state it is not in the main memory but it's swept out of the disk this is done to free of the main memory for active processes this is the same thing which is which I am telling you again and again so that you may remember it so when the I operation that the process was waiting for is complete now the I operation is complete this I operation is complete the process becomes ready in a logical sense but it is not in the main memory this is the thing you need to focus upon so when the operation is complete the process is ready in a logical sense but it is in the disk now it was in the dis and even when the I operation is complete the OS has not shifted the process from disc to memory it is even now in the disk only it is red in The Logical sense but it is even the but it is in the dis okay so it is not in the main memory so it is suspended ready State before the process can actually be executed move to the ready State actual ready state it need to be brought back to the main memory from the disk this operation is known as swapping or loading okay you need to remember this point swapping and loading it is important that's why I have put here because it will be an important thing in the next lecture we will learn about the contact switching okay so the decision of when to load the process back to the main memory is made by the operating system based on the various Vector like system load memory uses this is the thing okay now another question why resuming the process from suspended block to block instead of sending it to the suspended ready and then ready so now you may get the doubt that there are two paths from suspended block to reach the ready State path number one this path let me draw again this path and path number two this path which path it should follow in which cases can be the doubt so the process is just waiting in these both stages it's doing nothing nothing but waiting so if the process if the operating system resumes the process from suspended block to block state it we can infer that the operating system has enough resources to bring the process from disk to memory and when the operating system doesn't bring the process from dis to memory just it changes the stage from suspend block to suspend ready the process in both stages are in the disk only it suggest that the operating system is experiencing the lack of resources that's why it's keeping the process in disk and not bringing it to the memory and when the time will be appropriate the operating system will bring the process from suspend ready to ready States it mean when the time will be appropriate the operating system will bring the process from dis to the memory here in the both stages the process is doing nothing but waiting operating system has brought the process from dis to memory before time it means the operating system has enough resources okay so this was all the point let's summarize the full lecture from starting to the end so what was PCB PCB is nothing but the process descriptor we have seen there are several uh attributes pointer what is this pointer we will learn in the next lecture okay process State process number program counter registers everything so there are several stages like new ready running block and wait we have seen the process State transition diagram when the process Transit from one state to another in which cases what is the reason okay we have discussed everything in detail okay so this was all the thing which we have discussed several points and then what's the motive behind suspension several States regarding suspension uh example to explain the suspension properly and then the 7 State process transition diagram in the end and we have taken some doubts now okay you don't have to read this this was something absurd written so here we are ending your lecture goodbye hello everyone welcome to the lecture 10 of operating system Master course in the last lecture we have learned about the process transition diagrams in this lecture we will learn about the scheduling cues and the state queuing diagram okay so we'll first learn about what is a q so Q is a data structure which follows the fif discipline okay okay so I hope you know a little bit about what is a q how it is implemented so Q is implemented using a linked list okay so link list is also a data structure so there are two type of cues on memory que and on dis Q okay so on memory Q has another two types ready q and block Q This correspond to the states ready State and the blocked state so in ricq the pcbs of the process process which are ready to be executed are stored like P PJ PK these are the process which are ready to be executed so ricu contains the list of the pcbs of the ready process so what is a RQ it's a link list which follows the fif discipline okay so I hope you remember the image which I have shared of the PCB so it has the first block named pointer so now you have now you can understand what does that P that pointer mean so this is the PCB and it has a little bit a part of pointer which points to the next PCB just like the link list in link list one node points to the next node so this is the head node and this point to the next PCB then next then next and so on so nodes in this link list are the pcbs and this is the head pointer as we used to have in the linked list and another queue which is in the memory is the block Q block Q Q correspond corresponds to the block state in the process State transition diagram so block Q is also known as divice Q each input output device has its own Q like input output device one has its own device Q one two has its own Q three has its own queue so each device has its own que and it contains the list of the pcbs that get blogged onto that device okay so what does device que contain list of the PCB that get blogged onto that device those processes which are interested in getting the io Services of device one those pcbs are there in this device q1 okay so let me revise again there are two type of qes on memory q and on dis Q on memory Q contain two type of cues ready q and block Q ready Q contains the pcbs of those processes which are ready to be executed and device Q contains the list of the PCB that get blog onto that device for the iio services okay so block Q is also known as device Q these are the same thing device q and the block are the same thing let's now move to the on dis cues so on this queue contain job queue and suspend queue so this is similar to the process State transition diagram the job Q is corresponding to the new state and suspend Q is corresponding to the suspended block and suspended ready state so what does job Q contain it contain the program ready to be loaded in the memory okay and what does suspend que contain it contain the list of the processes that get suspended from the memory onto the disk this is simple to understand these names are selfexplanatory okay so let me again revise revision is the important thing we started with the scheding cues cues is a data structure which follows the fee for discipline there are two type of cues on memory and on disk on memory que contain ready q and block Q ready Q corresponding to the ready state which contains the list of the pcps which are of the processes which are ready to be executed by the CPU and the block Q contain there the block Q have several devices q and each device que contain the list of those processes or the PCB of those processes which are blogged onto that device for the io Services okay and on this queue contain two type of cues job Que and suspend Q job Q is corresponding to the new state and suspend Q correspond to these states suspended block and suspended ready job Q contain the program that are ready to be loaded in the memory these are the this is the hard disk it contains several programs now what we have to do we have to load this program into the memory so these programs are stored in the job que okay so I hope I'm clear with this okay now let's move to the state queuing diagram in this diagram we are also showing the cues as well as the states which it correspond hence its name is State queuing diagram which you also written here the state queing diagram so the cycle starts with job Cube the job cube contain list of the pcbs which are ready to be loaded in the main memory out of several ready process the scheduler chooses a one process and then shift the process from or give the control the process okay so now we are moving forward to the state queing diagram topic so the thing is started with job Q job Q contains the list of the PCB which are ready to be loaded in the main memory out of several ready processes the scheduler chooses a process and dispatcher give control of that process instruction to the CPU for execution now there are several possibilities either the process has all its instruction executed by the CPU then the process will terminate and if the process needs some IO operation then it will move to the block State the process needs some system call then also it will move to the block State the process got interrupted by some interrupt then it will also go to the block state or there is a possibility that the time given by operating system to the process for execution in the CPU has expired now the time SL is expired suppose the 10 second was given to the process 10 second is over the process has still not executed all its instruction by the CPU so the operating system will say now your time is over you need to go out and join the ricq again so the time SL expired preemption is done on the basis of time it could be on the basis of some interrupt either a system call so this is the state queuing diagram so we started with the job queue then ready queue then some device queue we can say and then the block Q the same thing now you may wonder what is the fork system called we have also talked about in our previous lecture by the execution of fork system call it creates the child process we have also discussed in our previous dpps okay so if any noncompleted process exits from the CPU will join back to the ricq eventually okay firstly it will it may go to the block State and then to the readyq or it may directly go to the RQ in case of preemption okay so this is the handmade diagram again so that you may remember it properly so let's create the state queing diagram we started with the job queue okay it's it correspond to the new state of the process State transition diagram so we started with job que then the program are loaded into the memory it becomes the process out of several ready process the scheduler chooses a one process and transfer to the CPU I know the Scher doesn't do that Scher just chooses the process the dispatcher is the main protagonist here the dispatcher give control to CPU for execution of the instructions of the process okay so scheduling will done out of several ready process one process will be selected and will be given to CPU for execution in case of preemption it comes back to the Rue now there are several possibility either it terminates or it move for to the blog state for some input output operation okay it is also possible that the process get suspended from ricu so it may get suspend or it may get resumed it can also be suspended from the running state but as we have talked in the previous lecture it is not desirable so this is the state King diagram okay now let's move to the topic schedulers and dispatchers so scheduling mean making a decision and dispatching beans we'll cover it later so first we'll learn about what is a scheder do scheduling what is scheduling making a decision what decision choosing a process out of several processes so where we have to make the decision we have to make the decision in the job queue ready queue suspend queue we have also we we we will also make a decision in the blog que but we will not focus on that we will focus on these three job queue readyq and the suspend que so what is the formal definition of scheduler Scher is the compon ENT of operating system that makes the decision as simple as that what are the three types of scheder longterm scheder shortterm scheder and mediumterm SCH why we say them as long short and medium these names are given on the basis of frequency of activation you will understand that more longterm Scher what does it do it brings the new process it brings the process from New State to ready state so from job Q to the ready que long long term Scher will work let me speak again from job queue to ready que longterm scheder will work what will it do see this is the hard disk it has several it has several programs that are ready to be loaded in the memory now we have to select only three programs from these six so scheder will choose which program I have to load in the memory so let's say longterm SCH decide this one this one and this one so this decision is made by the longterm scheder so what will longterm scheder do it will changes the state of the process from new to ready I hope you got the point now let's move to the most important shortterm scheder it will schedule the process out of several ready process it will schedule it will choose one process that need to be executed so it is also known as CPU Sher because it give it select the process for execution on CPU now the third scheduler is mid mediumterm scheder so what is it responsible for it is responsible for process suspension and resuming so this part this part is done by mediumterm scheduler this part is done by shortterm scheder and this part is done by longterm scheder I hope you are now clear with the point let me speak again this part of suspension and resuming is handled by mediumterm scheduler this part of scheduling to the CPU is handled by short ter scheder and this part of loading the process from disk to memory is handled by longterm Scher okay so this is the diagram you may read this from job Q to RQ longterm SCH RQ to CPU shortterm Scher and for suspension work mediumterm scheder is responsible so now another question important question which scheduler controls the degree of multiprogramming now you should remember what is the degree of multiprogramming so I have told you that this is the main memory this is operating system now there are several process in multiprogramming operating system in M minority let's say P1 P2 and P3 so what is the degree of this operating system what is the degree of multiprogramming we will say the degree is three because there are three process in the main memory now whose work is this to choose how many process will go from hard disk to main memory longterm schedu responsible so longterm scheder controls the degree of multiprogramming it loads the new program in the memory okay now we'll move to the dispatcher so how many topics we have covered till now we learned about the sheding cues the state queuing diagram the dispatcher the scheduler and now we'll move to the dispatcher okay so what is the dispatcher dispatcher is responsible for carrying out the activity of context switching now you may wonder what is contact switching so you you you can remember this name from the dpb1 we have discussed contact switching is entirely a kernel mode operation okay so what is contact switching we will discuss it now so contact switching is the activity of loading and saving the process during a process switch on CPU I hope you have understood nothing from this let me explain from an example so this is the radue there are several process p a PB PC and PD lying in the ricq this is the CPU this is the block Q okay so now you are clear with the diagram now you are clear with the situation okay so first firstly the PA was being executed in the CPU the PA was being executed in the CPU now preemption occurs let me speak speak again firstly p being executed in the CPU suddenly preemption occurs so what will this dispatcher will do it will save the context or we can also say PCB it will save the PCB from PA to the radue and will load the PCB of the next process let me let me speak the definition again activity of loading and saving the process during a process switch what is a process switch saving the PCB of the CPU living process so what was the CPU leaving process here PA was the CPU leing process so saving the PCB saving where either in the ricq or a block q that depends on the situation so what is a process switch saving the PCB of the CPU leaving process and loading the PCV of the next process let me let me clarify fully now so at first the context of PA was active there in the CPU so the context of PA was active now suddenly either preemption occurs or PA wants an IO service so what will it do it will leave the CPU so saving the PCB of CPU living process saving where if it is the case of preemption then saving to the RQ if it is the case of IO service then saving to the block Q so saving the pro PCB of the CPU leaving process and loading the PCB of next process now we need to load the PCB because CPU can't remain idle so we save the PCV of CPU living process and we load the PCV of the next process this is the context switch or the process switch so at first the context of P was active now the context of PC is active this is the contact switch now the time taken by the dispatcher to do this this contact switching is also known as contact switching time or CPU scheduling overhead or dispatch latency just remember the names now we will discuss these name when the topic will come like in CPU scheduling we will disc discuss this in detail okay now the next Point dispatcher is not involved in the suspension of process there the MTS will work the important Point regarding dispatcher was it works only with the shortterm scheduler so here here only dispatcher will work in this case the schedulers are there okay so dispatcher Works only with the shortterm Sher in case of suspension or loading the process from hard dis to main memory separate or individual schedulers are there like longterm Scher and mediumterm scheder so dispatcher has nothing to do with the suspension of the process so let's revise the full lecture now we started with the scheduling cues and then we learned the state queuing diagram then we saw some diagrams the handwritten State King diagram and then we learned about the schedulers and dispatcher what does it do scheder chooses and dispatcher does the rest of the work and then in the end we learned the the we learned about the dispatcher in detail in the next lecture we will learn about CPU scheduling and our this process management section will be over or new section that is CPU Shing start I'm giving you a DPP now you need to solve and explore how the process are scheduled what are the criterias the tiebreaker rules mode of operations every sort of process time like arrival time burst time completion time turnaround time and their formulas the algorithms like FCF FS sjf srtf lrf hrnn round robin priority based multi level Qing everything will be covered in this section and there are so much questions which we will do so my sincere request to you all is first try the question and then see the answer the chances of silly mistakes in this section is very high and it is a totally numerically oriented section there are lots and lots of questions in the DPP and in the lectures so without wasting any more time let's start so there was a thing which I want to discuss uh from the last lecture so I've included that in a form of question so the question says there's a two time T1 and T2 T1 is the time between user to colal mode shift and T2 is the process Swit time now which one is bigger so we can easily infer that T2 will be greater than T1 that is process which time will be greater than the user to Kernel mode switch time why because process switch or contact switch is a kernel mode operation itself and the default mode is user mode so we need to shift the mode from user to Kernel while switching the process so process switching time involves the mode shifting time so T2 involves T1 so T2 must be bigger than T1 now let's move to our main topic that is CPU scheduling what does CPU scheduling means it is nothing but design and implementation of shortterm Scher what was the work of shortterm Scher the work was out of several ready to run process schedule a process for execution on CPU now shortterm Scher must have some criteria to select the process okay so these criteria are included in the CPU scheduling technique so shortterm SCH have function and goal just like the any other component of operating system what is the function of shortterm scheder shortterm scheder so the function is to select a process from RQ to run on the CPU there are several process waiting in the ricq for CPU so selecting out of those waiting process for execution on CPU what is the goal to maximize CPU utilization to maximize the throughput to maximize the efficiency these are the goal and what is the other counterpart minimize waiting time minimize the turnaround time and minimize the response time so you must be wondering what are those waiting time turnaround time and response time you are well versed with CP utilization through point and efficiency now what are those waiting time response time so these are included in the topic process time so there are several we are going to look one by one so the first is arrival time or submission time this is the time at which the process enters the ricq for the first time so there was the hard disk and from hard disk there exist a program so that program will be loaded into main memory so this time when the process arrives in the main memory for the first time or in the ricu for the first time this Pro this time is known as arrival time and the process arrives from hard disk so in terms of State when the process come from New State to the ready State for the first time this is the arrival time why I'm saying for the first time because there will be several time when the process leaves the red EQ and come back again in the redu we have seen this in detail in our last section that is process transition diagram so from new to ready when the process arrives for the first time in the ricu this time is known as arrival time what is waiting time the time is spent by the process waiting the ricu I hope this is all clear so there is a time when the process spends in the ricu waiting for the execution by the CPU so that time will be the waiting time I have represented that time like this so it will be easy to remember what is the burst time the amount of time the process has spent in the running State or the time spent by the process running on CPU is the burst time so the burst time is the time which CPU takes for execution of the process or the time spent by the process running on CPU what is iob time the time spent by the process waiting for I operation in the blogged state so I have represented like this when the process is in blocked State waiting for IO this is the io bu time there's a note Ive discussed that already several time but for the revision purposes I've included that note in most modern operating system when a process initiates an IO input output operation it typically doesn't perform the actual I operation itself what is does instead it usually initiates the operation and then enters a blocked State waiting for the operation to handle the I of operation on its behalf waiting for the operating system to handle the ey operation on its behalf so what does it do it just initiates and the rest thing is handled by operating system okay now the fifth time is completion time as as the name suggests the time when the process shifts it state from running to terminated the time at which the process terminate the time at which the last instruction of the process is executed by the CPU the time at which the process leaves the CPU for termination stage okay so there is a diagram which is known as state timing diagram okay so the first when the process arrives in the Ric is known as arrival time and when the process weights in the ricu for the CPU that is the weight time one weight time one what is weight time one waiting for the CPU for first time and then the CPU executes then start executing the instruction of that process so that time will be the first time suddenly it requires some IO service so it will wait in the block distate that is the io wait and that time will be included in the iobs time it again goes to the Rue and then wait and waits for the CPU for the second time so this is the wait time to and and so on so process arrives in the radue arrival time process running on CPU burst time and process waiting for Io that is IO burst time so I hope this is clear let's move down what is turnaround time turn around time is the time spent by the process between the transitions in the States from new to terminate so it's it's like the lifetime of the process completion time minus arrival time the time which when it's come from hard disk to main memory till the time it get terminated that time is known as turnaround time I hope I am clear SO waiting time can also be expressed in form of turnaround time so this is the lifetime whole lifetime and this is the time it was being either it was being in the running state or it was in the blocked state so the time when the process was in ready state is total time minus when the process was in ready State and the process was in blog distate so I hope this is clear let me write it down this is the total time and this is the time when the process was in uh running State let me write again the running State and this was the time when the process was in log disted okay so waiting time can also be expressed like this let's move to the seventh part that is schedule length what is schedule length say total time taken to complete all n process as per the schedule Suppose there are n process in the Rue this was the Rue 1 2 3 till n so the total time taken by all these process to complete is schedule length Okay so what is a schedule schedule is the order in which the process gets completed like P1 P2 P3 this was the order okay so this is a schedule and what is its length we will discuss it after a minute or two so first of that I want to discuss the number of schedule that is possible with n process suppose this is there let's just take this example only so there are three process P1 P2 and P3 how many schedules are possible with these three process think about it suppose there are three students student one student three student student one student 2 and student 3 in how many orders you can arrange the students so in three factorial ways this is a common peration and combination if there are n objects we can arrange those n objects in N fact factorial ways in the same way how many schedule are possible with n process n factorial so is this always true why because this is true only in the case of non preemptive scheding let's take the example of preemptive scheding then with these three P1 P2 and P3 these are the three processes in how many possible schedules or we can schedule this in how many possible ways okay so let's take I first schedule P1 and then P2 and then P3 so this was the possible case one when the P1 was completely executed then P2 and then P3 now what I do I schedule let's say two instructions of P1 and then I preempted it now let's say I schedule two instructions of P2 and then I preempted it now P1 came again executed it next two in next two instructions then P2 came again then P3 came so I hope now you are getting the point that there is a infinite possibility let's start with the P2 and then I instruction I executed two instructions of P2 then P1 came now I executed three instructions of P1 and then P3 came then P1 came again then P2 came again then P1 came again then P2 came again then P3 came then P1 came then V2 G so there are so many possible ways in preemptive scheduling case so there are infinite theoretically infinite possible ways to schedule end processes if the processes are preemptive in non preemptive case P1 have to execute completely first and then P2 will come it will execute the complete first and then P3 will come let's take another uh case suppose P2 came first then P1 and then P3 suppose P1 came first and then P3 and then P2 let's take P2 came first and then P3 and then P1 let's take P1 uh P3 came first and then P1 and then P2 P3 came first and then P2 and then P1 so there are so many possible ways okay so is there any other way left P1 came first and then these two shifted and replaced and then P2 came first and then these two these two P1 and P3 and then P3 and P1 these two uh exchanged and then P3 came first P1 P2 and P2 P1 so only these six possible ways are there because in nonpreemptive case a process has to complete properly only then a new process will come into the CPU it will not be preempted forcefully so how many schedules are possible with n process and torial if the case is non preemptive and infinite if the case is preemptive I hope you got the point now we were discussing about the schedule length schedule length was the total time taken to complete all end process so how will you represent schedule length in terms of any formula is this sum of turnaround time is this the sum of life cycle of all the process no this is false because if you add turnaround time fall process it will become more than L that is uh I hope you get the feel of this if you add the life cycle of all the process it will be greater than the schedule length or if you add the bur time of all the process it will include I bur time too so what is l l is the completion time of last process minus arrival time of the first process this is the schedule length what was the schedule length you must focus on the definition total time taken to complete all in process as per schedule total time taken to complete all and process as per schedule so this is the schedule length so the completion time of the last process let's say P3 came at the last so the completion time of P3 where it goes yeah completion time of P3 minus arrival time of the first process that is P1 this is the schedule length that is completion time or arrival time of P1 to the completion time of P3 completion time of the last process minus arrival time of the first process this is the schedule length Okay so maximum of CI minus minimum of AI what is CI completion time and what is AI it is arrival time I hope you are clear now now throughput throughput is number of process completed per unit time so let's say there are n process and the total time was schedule length and the throughput will be n by number of process that is n completed per unit Time divid by L now there is another thing that is Contex switching time or scheduling overhead this is also known as dispatch latency so contact switching time or scheduling overhead is Delta we are representing is it with Delta and another point to note is for Simplicity we are just including the loading time we are not including the saving time in this data because it will increase the complexity of the problems process which was already running in the CPU taking that process out of the CPU and saving it somewhere else let's say in the blocked queue that time we are not taking we are only taking the the time for the dispatcher to load the PCB of a process in the radue to the CPU we are taking only that time to be Delta we are not taking this time just for the problem solving purposes just for the sake of Simplicity okay so the time taken by the dispatcher to load the PCB from RQ onto the CPU is Delta that is seding overhead just remember this okay so let's revise what we have done till now so we started our lecture with this that there are T1 and T2 I have discussed that the process switching time involved the mod shifting time then we move to the CPU scheding what is CPU scheding it is nothing but the implementation of shortterm scheder shortterm Sher has a goal and a function and we discuss several process times arrival time the time when the process arrives in the reue waiting time the amount of time is spent by the process in the RQ bu time the amount of time is spent uh by the process running on CPU I time the the time spent by the process in the blogged state completion time the time at which the process completes this is the completion time turnaround time completion time minus arrival time it's also known as lifetime of the process when the process came in the uh when when the process was allocated resources till the process was uh the resources was deallocated from the process that time is turn around time the time is spent with the process between new to terminated State waiting time can also be represented turnaround time that is the total time minus time spent by the process in the running State and the blocked State this was the time spend of the process in the ready state so we can write like this the time spent by the process in ready State plus the time spent by the process in running State plus the time spent by the process in the blocked state is the turnaround time I hope you are clear now so we are not taking we are not making that it that complex that we are including the suspend time and the suspended blocked and no we are just making it simple we are just uh dealing with with the five State transition diagram which we have we have discussed in the initial part of the lecture of process State transition diagram I hope you remember that now so for problem solving purposes we only include that we discussed the schedule length then schedule length is the total time total time taken to complete all in process it is not for a single process the above times which you have seen like completion time and arrival time these are the property of a single process the schedule length is the property or uh it is related with the schedule that is the total time taken to complete all n process it's Collective okay uh now we discussed the formula schedule possible with n process that was n factorial in case of preemptive infinite May possible and then we discuss the formula of L that is the completion time of last process minus arrival time of the first process maximum of completion time minus arrival of uh minimum of arrival time what was the throughput number of process completed per unit time and n represented the number of process and L represented the total time okay then we discussed the contact switching time or scheduling overhead that is Delta for Simplicity we just took the loading time we ignored the saving time so the time taken by dispatcher to load the PCV from Rue onto CPU so we stopped our last lecture at this point what was the Delta it was dispatch latency the time taken by the dispatcher to load the PCB from RQ onto CPU this time is taken and the saving time is ignored now where we need scheduling we not only need scheduling when the process Transit from ready to running state but at different parts of straight transition like running to terminated running to waiting and waiting to ready we also need scheding but our main focus will be on this transition because we are here implementing the shortterm scheduler okay so scheduling is of two type preemptive and non preemptive in algorithms where the process is forcefully deallocated because of the operating system way of working or any time constraint or priority you know all this so that part of scheduling is preemptive scheduling and the rest is non preemptive where the process completes its last execution it is it leaves the CPU voluntarily that is non preemptive and the preemptive you all know CPU bound process those process which perform a lot of computation in Long burst and very little IO you know what is birth time the time is spent by the process in in running state so CPU bound process are those process which perform long competitions in Long burst it means it take long time with the CPU and very little IO and IO bound process performs lots of IO followed by short bu of computation okay these are the process which are focused on iO and these are the pro process which works lot with CPU ideally system should be the mix of both to make maximize CPU and iio utilization let's say a process only works with a CPU then iio is idle and let's say the process perform lots of IO and and a very less competition than CPU is ID so in ideal case it should be a mix of both to maximize CPU and IO utilization okay so this was all the introduction now we will move to the main part of this that is the algorithms we will learn some algorithms so the first algorithm is first come first serve what is the selection criteria arrival time the process which comes first get scheduled first what is the mode of operation non preemptive mode of operation conflict resolution suppose two process arrived at the same time then we will choose the process with the lower process ID now I want to clarify a point that for conflict resolution there is a no fixed criteria but the best one is choose the process for lower process idid in any algorithm which we are going to discuss later in the course choose the process with the lower process ID whenever a conflict on selection criteria occurs suppose two process arrive at the same time choose the one with lower process ID okay you must remember that fcfs is non preemptive otherwise you are going to make mistakes there okay we'll also take some assumptions while discussing about these algorithm is time is in clock text we are not talking about some milliseconds or uncond n time is in clock text okay just for Simplicity no IO times and scheduling overhead we will take it as zero in later part of the course we will take or let's say in the next lecture we will take iob buus also and we will also take some significant value of Shing overhead too okay now I hope you get the idea what is CFS suppose the process which comes or arrives first get scheduled first but there is a serious problem with fcfs scheduling so let's say this is the process which arrived first so it says we I could stay here forever anyway I'm not going back to the end of the queue okay so and the operating system says to the these process which which say hurry up I waiting for you you have you with the processor for ages look at the size of that que this is the new process which came which arrived at the last and when these process complaint about the first process to operating system he says sorry first come first served so this is a serious problem this long process causes the starvation so in this course we will uh symbolizes the process with a large bus time as long process and the process with the short bus time as short process okay so large Bus Time long process Short Bus Time short process okay so this is the process which have a large bus time it is a long process which has been with the CPU for ages and these newly arrived process are waiting for that for a long time okay and this process it it has been in a grief that hey there are so many already waiting for the CP so it is just devastated to see look at the size of that queue and operating system give no shits it says sorry first come first start so fcfs causes a serious problem named starvation you can suggest uh why does it come it comes due to its non preemptive nature okay so this was just for additional information now we will practice some of the fcfs algorithm okay so let's practice the fcfs algorithm so we will be given with this type of uh table these are the process IDs 1 2 and three these are the process ID one signifies the process number one process number two and process number three 80 is the arrival time BT is the first time CT is the completion time turnaround time and waiting time so these are given to us that is the process ID arrival time and the burst time now we need to find the completion time turnaround time and waiting time how we are going to find that how will know that the process one will complete at which time or what is the life cycle time of the or turnaround time of the process one how we will know that for how much time the process waited in the ricu so to solve this we need to learn a technique of making a chart known as Gant chart a Gant chart okay so how we will make this so the first point about the Gant chart which you need to remember is it always start from zero no matter what so what does fcfs algorithm say the one who arrives first get scheduled first so who arrived first all of them arrived at the same point at Time Zero it means when we start looking at this all of the process were in the ricu so we will say the time was zero so all arrived at the same time now what we will use as the tiebreaking rule lower process ID will be scheduled first if the rest arrived at the same time so process number one will be scheduled first so process number one will be scheduled there for how much time it will run in the CPU so this Gant CH represent the CPU this is the CPU I can write here CPU okay so for how much time the process one will be with the CPU for four units so for four units the process will be P1 will be in the CPU and then it will be executed so the process P1 will be over after four time four units now process 2 was already waiting and it will be given more priority than process 3 because of its lower process ID so between P2 and P3 P2 will be scheduled so after P1 P2 will be scheduled and for how much time it will be with the CPU for three units so 4 units was the time taken by process one and then later three units that is from 4 unit to S units P2 will be with the CPU so we will write for 427 P2 will be there and now the P3 will be scheduled for how much time it will it will be with the CPU for 5 units so from 7 unit to 12 unit P3 will be there with the CPU so these are the Bus Time 4 3 and 5 and this is the timeline so in G chart what we represent so this is a Gand chart Gand chart it represent the CPU in this bar we write process and then in the xaxis this AIS time elapsed okay so I hope now I'm clear in G chart is a way of representing a schedule so what is a schedule here P1 then P2 then P3 this was the schedule so G chart represent a schedule and in the xaxis time elapsed is the represented okay so 12 unit was needed to complete the schedule so schedule length will be from 0 to 12 this will be the schedule length Okay so what will be the completion time of P1 P1 completed at four units so completion time of P1 will be 4 units okay what will be the completion time of P2 P2 completed at 7 so the completion time of P2 will be 7 what will be the completion time of P3 12 so 4 7 and 12 this will be the 4 7 and 12 will be the completion time now what is the turnaround time turn around time is completion time minus arrival time so here arrival time is zero so we can say that turnaround time will be equal to the completion time so we can write here as it is 4 7 and 12 now we'll see waiting time okay so what is my tip is to you regarding waiting time is you should calculate waiting time with the chart instead going to the formula okay so what is waiting time let's let's look at by the chart so when P P1 arrived at Zer and it get scheduled at the zero so for how much time it waited it waited for 0 time units because when it arrived it get immediately scheduled okay P2 arrived at0 when was it scheduled it arrived at Zer it has to wait for 4 units and then it was scheduled so waiting time will be 4 and when did P3 arrived it arrived at zero and when it get scheduled it scheduled at 7 from so from 0 to 7 it has to wait so waiting time was 04 and 7 I hope you are now clear with this you see if you want to calculate the waiting time with the formula you can also do that so what is with the waiting time turn around time minus bust time so turnaround time was nothing but completion time and burst time was it's written there so you just need to subtract the completion time from Bust time so let's do this completion timeus Bus Time 4 4 is 0 7 3 is 4 and 12 5 is 7 so I have taught you how to calculate the waiting time from either chart or from the formula okay so let's revise let's revise because the next question you have to do that fcfs algorithm first come first sir one who arrived first gets served first if all arrived at the same time then lower process ID will be given preference so here P1 will be scheduled first P1 scheduled first it will run for how many units of time four units of time because fcfs is completely nonpreemptive the process will leave the CPU voluntarily okay so we are not talking about any IO here so it will be with the CPU until it completes so from 0 to 4 we will how how did we write four here all right because the bu time of process one was 4 4 so from 0 to 4 P1 will be the will be with the CPU and from 4 to 7 three units P2 will be scheduled why because after because this is the priority given while checking the process ID P1 will be given the highest priority and then P2 and then P3 because we give more priority to the lower ID process okay so after uh P2 was over then P3 came it scheduled it was with the CPU for 5 units so from 7 to 12 it was with the CPU so from 0 to 4 P1 4 to 7 P2 and 7 to 12 was P3 okay so let's try another question it says so this was already given to us let's trite so two process arrived at Time Zero process one and process two which will be scheduled first process one will be scheduled first so we will write process one here and for how much time for two bus times so for two units P1 will be with the CPU okay now which will be scheduled P2 will be scheduled because it arrived earlier P2 will be scheduled then rest of the process so how for how much time P2 will be scheduled the bus time that is 1 so from 2 to three p will be there now this get executed completely this get executed now there these are the three process remaining who arrived first among the three process three arrived first because it arrived at two units okay so for how much time it will be executed 3 units so 3 to six 3 units P3 will be executed now these three are completed rest two are remaining who arrived earlier P4 arrived earlier so P4 will be scheduled for two units so from 6 to 8 P4 will be there now the last one it gets scheduled for and for how much time four units so 8 to 12 4 units so if you are facing problem indirectly doing this you can also make a time and a rue thing so it keep it helps you to keep track of the process which are in the ricq so at Time Zero P1 and P2 were present at time two P1 was gone and P2 and P3 was there in the Rue at time two P2 and P3 were there in the Ric okay at time three P3 and P4 were there at time three at time 3 P3 and P4 were there because it arrived at unit 2 and it arrived at time three so at time three both were present in the ricu at Time 5 P3 P4 and P5 at time 6 P4 and P5 so the basic purpose of uh writing this is time and ricu thing is you get to know which process are present in the ricq and among which process you have to compare the arrival time suppose at time Zer we saw P1 and P2 was present so we need to compare the arrival time of these two process only so we'll compare for these two process whose arrival time is more see both are same so now what we will do we will apply the tiebreaking rule that is lower process ID so which has lower process ID P1 is lower process ID right P1 is lower than P2 P2 is higher so we are talking about these numbers okay so so between them P1 will be scheduled first and then P2 so when P1 was getting scheduled for two units at time two P3 was also present and P2 was was also present in the ricu and P1 has went to running and then ex execute and then terminated so P1 was terminated and then at time two P2 and P3 were present in the ricq okay so in this way you can do this and now you have to compare between P2 and P3 between P2 and P3 who arrived earlier P2 arrived earlier so P2 will be scheduled P2 will be scheduled for one bu time so at time three we will see P2 was gone and P4 came so now we to compare between P3 and P4 so it's just a helping hand if you get more and more confused in how to apply fcfs algorithm it will signify significantly reduce your Sly mistakes let's move to the question number three it's again on fcfs algorithm so this is given to you to us and now we have to calculate completion time turnaround time and waiting time so I'll create the Gant chart and you have to fill the values by seeing the Gant chart so this you have to do as your homework okay so we will see here so there are four process which arrived at different times so the first process arrived at time three so now you may Wonder between time 0 and time three what will CPU do it has nothing to do it will remain idle so from 0 to 3 the CPU will remain idle now I have told you you must remember that in Gant chart you always start with zero so from 0 to three no one was there with the CPU so we will represent this part as Idle now at time P1 came and it get executed with the CPU for five units so from 3 to 8 P1 came at 3 and from it executed till 5 units so from 3 to 8 P1 was there with the CPU the next process came at 10 so 8 to 10 again the CPU is idled and from 10 to 12 P2 get executed for two busts okay so for for two unit P2 get executed now the next process that is the P3 which came at time 15 so again from from 12 to 15 CPU is idled the process 3 get executed for 4 units so from 15 to 19 P3 will be there with the CPU and then now no idleness because P4 came 1 second before or one unit before the P3 get completed P4 came one unit before P3 came completed P3 completed at 19 and P4 came at 18 so there's no idess P4 will wait for one unit until the P3 get completed and then P4 will get immediately scheduled so from 19 to 5 minutes more that is 24 P4 will be there so this is the Gant chart and it always start from zero so for CPU was idle for how many units three here two here and three again here so 3 and 3 6 6 and 2 8 so CPU was idle for 8 units what is the schedule length what is the schedule length completion time of the last process to AR time of the first process I should speak in opposite order so the arrival time of first process to the completion time of last process this is the schedule length this will not be counted in the schedule length so there is an interesting concept of percentage CPU idleness so what will be the percentage CPU idess for this G chart so one thing you must remember about the percentage CP idess is it is always calculated over schedule length l so we will not see we will not see this part we will only calculate the percentage where CPU was idle for this duration only so the percentage CP idess is calculated over l so for how much time the CP was idled 2 and three so 5 units divided by 24 to 23 is 21 so 5x 21 into 100 this was the percentage CPU idleness so 5x 21 into let me divide 100 for percentage we multiplied by 100 to calculate the percentage so this was the percentage CPU idleness now we will see one more question and then there's a homework for you you have to calculate the percentage CP idleness in this given question okay so let's do this so we are again given with the three things process number arrival time and the burst time okay so let me take this now it's good so we will compare the arrival time who arrived first Pro process to arrived at time three so between 0 to 3 it will be idle and for time three it arrived so P2 will be scheduled at time three and it will run for 1 unit from 3 to 4 it will run and then the next process arrived at Time 5 so 4 to 5 CPU will be idle and then process one will be scheduled for two units so from 5 to 7 process one will be there and the next process arrived at time 8 so from 7 to 8 again the CP will be added and the process three will be scheduled at time 8 and it will run for 4 units so from 8 to 12 the process three will be with the CPU so what will be the G chart this is the G chart it always start with a zero what will be the schedule length the schedule length will be the completion time of last process to arrival time of the first process to 12 3 that is 9 is the schedule length Okay so in the same way in the same way you should try a question on yourself too so try this question and I have given you the answer that is percentage C is 4X 23 so you you should get get this must remember if such situation arise where the CPU idle for initial part do not include this in the percentage CPU ID L because it is always calculated over the schedule length so we'll only calculate this and this okay so try this and try to get the answer and do not stop until you get this 4X 23 okay welcome to the interesting part of CPU scheduling in which we will include the Delta and IUS time too so my intention is not to scare you but this is a new variety of problems which we are going to see in this lecture this is an important lecture sit with pen and paper and first solve the question by yourself when I will say and then see the solution okay so what what is Delta what is the significance of Delta let me explain Suppose there uh suppose take the case in which the Delta is negligible okay P1 was there in the RQ at time zero and it has a burst time of 4 units so what we did we used to directly schedule P1 for 0 to 4 we did like that but now the scenario has changed the dispatcher has took two unit of time before the process can start running so from 0 to 2 it was the time taken by the dispatcher to transmit or or Transit the process from ready to running so this was the time taken by the dispatcher and now the process will run for 4 units so initially the process was completing at 4 units of time now the process is completing at 6 unites so completion Time Has Changed okay so don't worry we we will learn about this when we see the problems so in problems we will be given with the process life cycle like first it was with the running first it was running and then it got to blocked State and then again it came uh for running so this is the life cycle which will be given burst time iob bur time and the bur time okay it can also be like iur time burst time and iob burst time that will be a another difficult part this what I'm saying this IO burst time burst time and I burst time so this is a Next Level problem okay so don't worry we will see them one by one so initially in the initial problems we will be given with the burst time IO burst time and the burst time and let's say Delta is one okay so this is we will start with just one process so this is process number one arrived at the RQ at time zero and this is the life cycle that is it was running in the CPU for 3 units then for 5 units it went for Io and then again two units it went it run on the CPU and then it terminated so at time Z P1 was present in the RQ so the load time of dispatcher that it loaded did the PCB of P1 in the CPU it took one unit of time so from 0 to 1 the time was taken by the dispatcher and for three units the time was taken by the process to run on CPU so 1 to 4 that is the three unit of time taken by the process to run so and one unit of time was taken by the dispatcher so we have completed for four units we have completed this part okay now the process has went for Io so from 4 to 9 that means the five unit the process was with the io okay and it came back again at time 9 see if you if you directly jumped to the CP lecture without understanding the process State transition diagram you will never going to understand what is going on here see what the process State transition diagram was the process was in the ready State then it moved to the running State and then whenever process get blogged for Io it cannot go back directly here what it will do it will first go to the ready like this and then from readyq it will be scheduled and again there dispatcher will take the load time because what is the straight transition happening here from ready to running from ready to running so dispatcher will take again one unit of time so from 9 to 10 let me explain again okay from 0 to 1 it was the time taken by dispatcher to load the process 1 PCB from ricq to the CPU and 1 to 4 was time taken by the process one in the CPU from 4 to 9 that is the five unit is taken by the process at IO at time 9 it came again at the RQ and one unit was taken by the dispatcher to schedule it to the CPU or trans transfer or load the process in CPU and for two units the process ran at the CPU and then it got terminated so I hope this thing is now clear to you okay let's take another question yeah so we did not took the time okay I have written this so the the time taken by dispatcher or the Delta like here one unit it was the only time taken to load the process the saving time was not in included it was negligible hence or we took it we took it as negligible so the time taken by dispatcher only to load was taken but saving was not taken what did dispatcher do it load and save the time taken to load was taken and save was ignored okay question number two okay do you want to try it yourself go ahead be brave and try now I'm giving you the answer so the we are doing the fcfs algorithm so we will compare the arrival time who arrived first process one arrived first so process one will be in the RQ at time zero and the scheduling uh or the dispatch latency is Time 1 so to load the process in CPU it will take one unit of time so to loading P1 it will take one unit and then P1 will run for three units so P1 will run for three units and then for seven units it will go to the iio so from 4 to 11 it will go to the iio and will and it will go back again to the RQ at time 11 okay so at Time 4 there was no one with the CPU so OS will decide or scheder will decide there is no one with the CPU and there are there is a process arrived at time two that is ready to be scheduled so P2 arrived at time two and no one is there in the CPU at time four so what OS will do OS will say hey P2 you can go in the CPU so P2 will be loaded in the CPU the loading time is 1 unit and P2 will load for 5 so from 5 to 10 P2 will be there with the CPU okay now at 10 at 10 no one is there with the CPU and P3 has arrived at Time 5 and P2 went for the iio for two units so P2 will return in the RQ at time 12 from 10 to 12 from 10 to 12 it was with the io and at 12 it will return in the r Q so at time 10 no one is there with the CPU so what OS will decide there is a process which came at Time 5 is ready to be scheduled at the CPU so why not schedule process three so one unit of time will be taken for loading and then one unit of time is the bust time so 12 11 to 12 P3 will be there now P3 will go for Io for till tell to 16 so at time 16 P3 will be there with the ricu so now time 11 P1 came and now at time 12 no one was there with the CPU so o will say Hey listen at time 11 P1 came and no one is there with the CPU hey scheduler why don't you schedule the process P1 again at the CPU so sh would say okay sir P1 will be scheduled and one unit of time was taken for loading and two units of time was taken by P1 at the CPU so from 13 to 15 this will be completed at time 15 P1 will leave the CPU and it will get terminated because this was completed this was completed and this was completed at time 15 the CPU is again empty so o will say hey there is a process which came to the r equ at time 12 why don't you schedule that so okay we will schedule that so at time 15 P2 will get scheduled so one unit of time will be taken for loading and the rest three units will be taken by as a bu time now at time 19 no one is there with the CPU but os's hey there's a process which came at time 16 why don't you schedule that okay sir we'll schedule P3 so one unit of time will be taken to load and two units to complete so two units to complete so I hope everything is clear I hope everything is clear so what will be the schedule length completion time of the last process till the arrival time of the first process now there is a very very important thing I want to clarify this timing this loading timing is not a waiting time for the P1 let's say let's let's imagine this suppose you are the process and you are in the RQ and there's a CPU which is empty so what I'm doing now so this is you and this is CPU okay uh let's take a time that is uh you arrived at the process Q at 400 and the CPU became empty at 500 okay so at 500 I said to you hey come on let's go to the CPU CPU is empty now now the time taken by you to go from ricq to the CPU was 10 minutes so the CPU started execution on you at 510 so what will be the time you waited you waited for only 1 hour this this time was not the waiting time try to understand this so so this Transit time is not waiting time okay now I have important thing to discuss that system has multiple IO devices this thing you should notice here so from Time 4 to 11 P1 was with the iio from 10 to 12 P2 was with the IU so at time 11 or let's say at time uh 10.5 both P1 and P2 was with the iio this is only possible when system has multiple iio devices and I operation can be concurrent if the system has a single device then P2 has to wait till 10 to 11 until P1 get gets it IO done at time 11 so at 10 to 11 P2 will wait and then from 11 to 13 P2 will completes its IO I hope that's clear now and the CPU idleness so during the whole schedule length at what time CPU is Idle No CPU is not idle for any time this is the transit time CPU is not idle okay now let's let's calculate the waiting time so I have told you two ways to calculate the waiting time one from the G chart and from the formula so we'll first calculate the Gant chart okay so P1 was ready at Time Zero when when was it scheduled for the first time it was scheduled at time zero so first the time the weight was zero and then when it came again it came again at time 11 when was it scheduled it was scheduled at time 12 so from 11 to 12 1 unit of time was there to wait in the ricu see I have told you an example that 10 minutes was not included in the waiting time so we will not include this in the waiting time this is Transit time not waiting time will take this time as the time when P1 was actually scheduled okay so P1 only waited from time 11 to 12 when it was finally decided to get scheduled over the CPU okay so the waiting time of P1 was 0 and 1 0 and 1 this was the time P1 waited okay so 1 was the waiting time of of P1 waiting time of P2 it arrived at time two when was it scheduled first time it it was scheduled at Time 4 so two units of time from 2 to 4 this was the time P2 waited in the RQ so two units and when it came again it came again at time 12 when was it scheduled again it was scheduled at time 15 okay so see we will not include this time in the waiting time so it was scheduled at time 15 so from 15 to 12 how much time is wa it waited for 3 units okay now P3 when did P3 came in the Rue at Time 5 so P3 was there in the Rin Time 5 when was it scheduled it was scheduled at time 11 so see this was the mistake you can do in generally we see this time but now we have to take in account this time also so from 5 5 to 10 it waited only we will not include this time time as the waiting time 5 to 10 only 5 so 5 will be there see why I'm focusing on this so much that you should not include this time is the waiting time why I'm focusing on this because generally when we calculate waiting time from the chart what we see when it arrived and when did it get scheduled so we directly see like this okay we tend to ignore that part in general cases when there is no scheduling uh or CPU Shing overhead so we tend to ignore this part and we directly take this so this can be a critical mistake you may make okay so you have to remember this part that this is not waiting time you do not include that part in the waiting time okay so five was the waiting time made done by the process 3 at the first and then when it came again in the RQ it came again in time 16 when was it scheduled again it was scheduled at time 19 so from 16 to 19 it it waited for 3 units so from chart we calculated the waiting time but you should not calculate the waiting time from formula why not formula because there may be some cases like in this case you may remember your old waiting time formula that is turnaround time minus bust time but here a special case has come that is this is also present this may change the formula that is the weight time as formula was turnaround time minus burst time so according to the formula 15 was the turnaround time 15 was the turnaround time the time spent by the process or the whole life cycle of the process so the turnaround time was completion time minus arrival time so 15 was the turnaround time what was the bu time this was The Bu time that is bus time and the I bu time 7 and 3 10 10 and 2 12 so 15 12 is 3 so P1 should have waited for three units but it only waited for one unit it so where did we go wrong we ignored that part okay so waiting time in waiting time this will be the formula when we take account as CPU scheduling overhead 2 so turnaround time minus bus time plus I time plus n into Delta number of time a process get scheduled on the CPU so P1 was scheduled for how much time 1 and two so what will be the formula now 15 minus this was 12 plus two time it was scheduled and what was the CP scheding overhead 2 so 2 into sorry I think the CP shoulding over was 1 yes one so 1 1 into 2 that is 2 so it will come here so 15 14 is equal to 1 now the answer is correct so to remove all this begining let's always take a pledge to let's take a pledge to always calculate waiting time from the chart ignore the formula it may make it may let you to make mistake okay take this pledge you will always calculate the waiting time from the chart okay that is the Gant chart you will calculate waiting time from here not the formula let's move to another question in which iob buus time is bus time and then iobs time so this is a great question you should try your you should try this question on your own first and then see the solution so let's see the solution so there are three process which arrived at time zero so all three process was present in the radic at time 0 P1 P2 and P3 were present at Time Zero okay the process started with the iob bus time first and then the bus time came do you think it is possible is it possible for a process to directly go from ready state to the io no this is not possible so how can IUS time come first so this should have been the scenario so the first process go from Runing to running and then from running it should go to the block state that is the io so what a special thing is that when the process get scheduled from ready to running CPU scheduling overhead will come it will execute a single instruction in the CPU and then it will go to the io let me write and then block a process cannot directly go from ready to block unless the case of resource preemption happens but this that's a rare case we are just taking the general scenario so from ready to running and then block can a process directly go to the io no so it has to first go to the running State and then block so when the process Transit from running ready to running State data comes there is a time which dis dispatcher takes to Transit the process from ready to running so Delta will be accounted here okay so what I'm trying to tell you is so when the process P1 will be scheduled at the process P1 will be scheduled at the running and then it will execute a single instruction and it will go to the IU so Delta for P1 will be there one unit of time and then it will will go to the io from 1 to let's say 2 units so from 1 to 3 1 to 3 for 2 units it will be the io now the process two will come it will again go to the running State and the time will be taken by the dispatcher will be 1 units so from 1 to 2 P2 came to the running State and then immediately it went for Io immediately went for Io for how much time for four units so for four units it was with the io it came back to the RQ at time six and P1 came back to the r at time three now P3 when did P3 came at time zero so P3 will be scheduled now P3 will be scheduled for running and then from running state it will immediately transit to IO so from 3 to how much time six units so from 3 to six that is for 9 units it will be the io and at time 9 it will again come back to the RQ now who is in the RQ P1 P2 and P3 are in the ricu at times doots 3 6 and 9 respectively so at time three P1 will be scheduled in the running quebe uh what I'm saying P1 will be scheduled from ready to running State okay so again dispatcher will take its own time so 3 to 4 will be the time taken by dispatcher for P1 and then P1 will perform its bu time with the CPU so from 4 to 11 P1 will perform its bus time and then from 11 to 12 it will perform its IO for one unit so it will perform its IO and then at time 12 it will come back to the RQ so P1 came back at time 12 okay now now now I want to I want to uh tell something important about this P1 state it has completed this this and this when the P1 came back at the RQ it has to again schedule to exit Okay uh let me again Mark the point so first the P1 was in the RQ it goes to the running state for this so that it can go to the block state to perform the io of two units it again performed the io of two units now when it performed the I of two units it came back to the ready State and then it was again scheduled to perform the bus time for S units okay it performed the bus time and then it was uh it go to the block state to perform the I of one unit okay the I of one unit is performed now the process has done its every part now the process want to terminate how can it terminate I have to told several times that process can terminate only from the running state so it will go again there at the right State get scheduled again and from running state it will terminate so this was the important point or this was the beauty behind this question so P1 will be scheduled again P1 will schedule again it will execute its exit instruction the last instruction and then at time 49 it will terminate okay so where were we in the diagram so P1 completed it came at time 12 okay so now at time 11 now at time 11 who is present in the ricu at time 11 P2 and P3 both are present so which we will take P2 we will take so P2 will get scheduled due to its lower process ID when P2 will be scheduled the dispatcher will take one unit of time and then P2 will take its 14 unit of BU time so 14 unit of BU time taken by P2 now the time is 26 okay P2 will go to the I P2 will go to the io for time 28 so at time 28 P2 will go back to the RQ this is clear now at time 26 CPUs is ID there's no one with the CPU so we need to schedule a process for CPU so who is in the redq P3 and P1 are present in the RQ at time 26 so we will schedule P3 so one unit of time taken by the dispatcher and P3 will take 21 units of time as a burst time so 21 unit of time as the burst time has taken and then three unit as IO so 48 to 51 at 51 the P3 will be again at the RQ now at time 48 who CPU is Idle who will come who will come now P1 will get scheduled so P1 will get scheduled it got terminated and then who will be get scheduled P2 will get scheduled so P2 will get scheduled for how much time no time see see see no time no time no time to execute just a single instruction exit and then it will terminate so this was the time taken by dispatcher process took negligible time again the time taken by the dispatcher process took negligible time from 50 to 51 no one was present in the Ric Cube at time 51 P3 came so for 50 to 51 CPU will remain idle at time 51 P3 came so P3 came at time 51 P3 will get scheduled one unit toen by the dispatcher and nothing was taken by the P3 because it has to execute a single instruction only and then it will execute so let me clarify the whole question again so at first process need to come to the running state so that it can go for Io and at last process need to come at the running state so that it can terminate and in between the simple uh thing which we were doing was the same so this was the part which was good about this question okay so let me clarify again so what happened here there were three process initially we scheduled the process based on the lower process ID Delta was the time taken by the dispatcher and then process executed or the process took its time in the blocked State when the OS performed its I operation so 1 2 3 this was the I operation done by the process and then at time three P1 will came so we did like this so there's one important thing that when the time when the time when the process completes IO you should remember to transfer that process to Rue and write the time above it otherwise it will be confusing suppose at time let's say 50 at time 50 if you did not write the time here 51 you may forgot that the P1 the P3 came at 51 and it there's a slight chance possible that you schu P3 at time 50 if you fail to write here 501 okay so what my advice to do such complex question is make ricu and then uh do the calculations for the Gant chart you have any problem understanding this question try to do do this on your own explore okay watch the video repeat the video okay so this was an important question to clarify your fcfs Concepts this was the hardest question possible in the fcfs okay uh another next category could be that there is only single I this will this will be the supreme god question for fcfs if I say the iobt comes first there is a CPU shiing overhead and there is a single iio device that will be the Supreme question or the hardest question that can be formed on fcfs okay but that is not required and academics level so we will just go with this okay so this was the important concept here from ready to running to go to the block distate from ready here the process want to to go to the block distate from ready state so it cannot directly go from ready to block it has to come to the CPU first it has to come to the CPU first execute a single instruction for iio for Io it will execute a system call and then the OS will allow the process to go to the blocked State and when the process want to terminate so here the process was in blocked State and it want to what is going on so here the process wanted to terminate but it cannot directly terminate at from blocked state so it has to go to the running State that's why these three part came okay so this was an really good question now here are the tips to solve such question always create time and ricu thing this is must okay start G chart from zero this is also a good tip always remember transition diagram if you forgot the transition diagram you may make a mistake of including of not including this and this part in the Gant chart do not include the delta in the waiting waiting time while including while calculating from the chart okay so these are the four tips let me read again always create time in ricu things start gting chart from zero always remember transition diagram and do not include Delta in waiting time we stopped our last lecture at this amazing question this was a really good question in which the process started with the io bu time and then bu time and then again came the iur time in this question the process need to go to the CPU first and then block Q it will execute a single instruction on the CPU let's say the system call so that it can go to the block que and when it came back when it has completed all its IO and in and it came back for termination it has to again go to the CPU to execute a single instruction let's say exit instruction to terminate so this part and this part people generally misses because they do not have a conceptual understanding understanding of process transition diagram which we have okay so we also seen some tips like we need to always create time and ricu we should start our G chart from Time Zero we should always remember the transition diagram okay like in this question and we should not include the dispatch Laten in waiting time okay now I have another question for you a simpler one so you need to do the same question with dispatch latency as zero and you need to find the CPU idleness and the schedule length the answer is this so I request you to solve the question first and then until the answer arrives you need to you need to fight okay so let's see the answer now so we are solving with zero dispatch latency okay so in the radue at time zero three processes process 1 2 and three were available so these proces are present at time zero so we'll schedule this process at Time Zero again the process need to go from ready state to block state but it is not possible unless the case of resource preemption is there so for ready Q to block Q it has to go to the running State first and then it can go to the block Q so it will come to the CPU execute a single instruction let's say for negligible time and then it will go to the io so it will perform a two unit of IO and then at time two it will again go to the RQ so from 0 to0 P1 was executing in the CPU and then for two unit it went for the iio and at time two it came back with the ricq same stories for P2 from 0 to Z it performed the a single instruction at CPU it went for Io for four units at and at time four it came to the RQ similarly for B3 it came to the RQ at time six okay now now at time two at time two P1 was there but from 0 to 2 there was no one with the CPU so from time 0 to time 2 the CPU will remain idle because the first process which came in the Rue for CPU came at time two so from 0 to two CPU was idle at time 2 P1 came for performing the seven unit of verst time so from 2 to 9 that is the seven unit P1 will be with the CPU at time 9 it will go for Io so for one unit so it will came back to the ricu at time 10 so P1 was back in the ricu at time 10 now at time 9 who was who are in the readyq ready to be scheduled so till time 9 P2 and P3 are available who will be schedule now the process which came earlier who came earlier P2 came earlier so we will schedule P2 for how much time for 14 unit so from 9 to 23 that is the 14 unit P2 will be with the CPU at time 23 it will go to perform IO so from 23 to 25 it be it will be performing IO and at time 25 it will come back to the RQ now at time 23 which processes are in the CPU so at time 23 P3 and P1 are present who came earlier P3 came earlier so we will schedule P3 now from time 23 to 44 that is the 21 units of BU time P3 will be there with the CPU and at time 44 it will go to the io so it will perform IO for three units of time and at time 47 it will come back to the ricq so at time 44 which processes are present in the ricq so P1 and P2 are present in the ricq so we will schedule P1 now P1 will be scheduled for how much time see this part was completed this part was completed this part was completed too now P1 will come to the CPU just for performing a single instruction that was the exit instruction so it will come to the CPU for negligible time let's say for time zero so from time 44 to time 44 P1 will be the with the CPU performing a single operation and then it will end so P1 ended and it didn't come back to the ricu because the process is complete now now we will schedule P2 according to the arrival time again P2 will execute a single instruction and then it will terminate now at time 44 who is present in the ricq see no one is present in the ricq these all process gets terminated at time 47 P3 came so from time 44 to 47 CPU will remain idle and at time 47 P3 will come to the CPU for executing a single instruction that is the exit instruction and then it will terminate so I hope thing is clear now if you made some mistake try to analyze where did you lag in your Concepts okay so what will be the schedule length completion time of the last process till the arrival time of the first process so this will be the schedule length that is the 47 and what is the CPU idleness CPU was idled for 2 units here and three units here so total 5x 47 okay I hope it is clear uh now you have to calculate for part A for this part you have to calculate the CPU overhead activity dispatcher was working for how much time divided by the schedule length total time dispatcher time upon total time that will give the percentage CPU overhead activity so total time was completion time of the last process that is 53 till the arrival time of the first process process processes were ready uh processes arrived at the Ric time Z from 0 to 52 that will be the schedule length so from 0 to 52 52 will come at the denominator for schedule length and for how much time the dispatcher was active so percentage CP you overhead 1 2 3 4 5 6 7 8 and 9 so 9 by 52 will be the answer that will give the percentage CP over reductivity okay to calculate the percentage you need to multiply it by 100 now if I ask what will the percentage CPU efficient then total minus percentage C over activity plus percentage CV or you can calculate directly like the time when the CP was active efficiently working was this time this time and this time this is nothing this is nothing and this is nothing so you can calculate like this or if you have already calculated the percentage CP over acity and percentage CP ID you can directly subtract them by 100 and you will get your answer for percentage CPU efficiency now I have three good questions for homework and you must solve it otherwise if you just seeing the video and do are not solving the homework question which I'm giving you will lag behind in the end okay you'll eventually not make the most out of this course okay so you need to solve the question which I give to you similarly this question for Shing overhead equals to two and uh Next Level question for I iobt first then BT and then iobt for scheding over length equals to scheduling overhead equals to 1 now a third question try question one and two we need to try this question and this question assuming system has only one IO device did we discuss a question uh in which the system has only one I device this is see if you are getting scared by this question number three do not get scared it is as simple as the previous ones are what you need to do just take into account that just like CPU we were doing that there can be only one process in a CPU at a time in the same way you have to take into account that there can be only one process performing Io if the if another process want to perform IO at the same time then it has to wait until the first first process completes its IO so you need to take account an additional waiting time okay it is not as hard as it seems okay so you need to try question one and two you need to try this question and this question if the system has only one IO device if one process is performing the io other has to wait okay so I want you to try them now it is the time to discuss the homework question which I have given you for fcfs algorithm so there are three process available along with the arrival time and their lifetime it was first with the CPU then IO and then the CPU so let's start so which process is available at time Z P1 is available so P1 will be scheduled and the dispatch Laten is two so two unit will be taken by dispatcher and three unit will be taken by P1 now at time five which process are available at in the ricq P2 is available so two unit will be taken by the dispatcher and two unit will be taken by the P2 now you may see there is no IO it means zero unit of IO performed it means the process didn't even go for the io that means the process will continue till completion so from 7 it will go till 12 at time 12 which process is available so P1 went for the io at Time 5 for 4 unit so it will return back in the radue at time 9 so P1 will be available at time 12 so we will schedule P1 there two unit will be taken by the dispatcher and two unit will be taken by the the P1 so 12 to 14 dispatcher and 14 to 16 taken by the P1 now at time 16 which process are available no process available P3 came at time 20 so from 16 to 20 CP will remain idle at time 20 P3 will get scheduled so from 20 to 22 the dispatch latency P3 will be scheduled and for one unit it will with the CPU at time 23 it will go for 15 unit of IO so from 23 to to 38 the process have gone for Io and no processor is available in the Radu at time 23 so CPU will remain idle at time 38 the P3 will go back in the radue so at time 38 P3 will be available for scheduling we will schedule P3 two unit will be taken by dispatcher and six unit will be taken by the P3 and then at time 46 all of them will end let's move to the question number two in this question there are three process and three uh and their arrival times in their life cycle is given so this question was the special one as we discussed earlier in the lecture the the process directly want to go to to the block Q from ready but this is not possible as you know so the process has to go to the running State and from there it can go to the block State and from block when it will complete its IO for the last time it it cannot go directly to exit state so first it has to go to the ready State and then then it has to go to the running State and then it will terminate so when the process will go from ready to running for the first time it will execute a single instruction that is the system call and when the process want to terminate directly from the Block state it has to go to the running State first VI ready state to execute a single instruction that is exit so we will assume that it took negligible time to exit to uh execute those instructions so we took 10 and one and and 11 can you see from 11 to 11 from 10 to 10 from 1 to 1 so these are the time taken to execute just a single instruction for the first phase the instruction was system call and for the last phase like this one and and this one and this one so these are the exit instructions so I hope you can do that now uh I know I have made a Sil mistake here I was very exhausted while solving these questions so I made a mistake that from time 0 to 3 the CPU will remain idle but I forgot that the process the first process arrived at time three so I started with time zero so you have to shift the whole timeline by three units but that won't work because there are some idle patches in the Gart so you have to do this question whole again this is wrong the calculation is wrong but the concept is correct you have to do as I have told you in the concepts remember the transition diagram and check again because the chances of s mistakes in these questions are very high let's solve the question number three so the question number three was you have to solve the about two question with a with assuming that there is only one IO why why don't we take a new question and we will assume that the nonconcurrent io is present it means the whole system has only a single IO device so let's start so process 1 2 3 arrival time is given and their life cycle so which process is available at time Z P1 is available in the rad at time Z so we will schedule P1 and we have assumed that the dispatch Laten is zero so we will directly schedu P1 we schedu P1 at Time Zero it will run for two units it will run for two units and then it will go to iio for 2 to 2 to 7 for 5 units for 5 units it will go to iio so till time 7 P1 will Beck the io let's discuss about the CPU so at time 2 P1 went for the io so CPU is Idle now but there is a process ready to be scheduled in RQ that is P2 so why don't we P2 we scheduled P2 for three units of time so from 2 to 5 P2 will be the CPU and for 10 units P2 went for the io so P2 went for the io for how much time for 10 minutes so from 5 to 10 from 5 to 10 P2 has to go to the io but but but there's only a single device which will which is being used by the process 1 till time 7 so from 7 5 to 7 it has to wait until the I device becomes empty then from 7 to 17 for 10 units P2 will work so you have to account this waiting time also because there is a single IO device so when it will be emptied by P1 then only P2 can go to that device so from unit 5 to unit 7 it has to wait and from 7 to 17 this will execute this uh or from 7 to 17 it will use di services for 10 minutes of time okay now let's discuss about the C CPU then at time which process is present in the CPU P2 and P3 both are present but P3 and went for the iio so P2 is went for the io so P3 is the only process we will schedu P3 for one unit of time so from 5 to 6 P3 will get scheduled and from and then it has to do three units of IO so it will wait until the process two leaves the io at time 17 at time 17 it will do three units of IO from 17 to 20 it will come back in the radue at time 20 P2 will come back in the radue at time 17 and P1 will come back in the Rue at time 7 so from 6 to 7 there's no process available in Rue for scheduling so the CPU will remain idle at time 7 P1 will get scheduled for three unit of time so from 7 to what I've have done oh no I again made a mistake here you should not try this question when you were exhausted so from 7 to it should be 10 it should be 10 so it should be 10 so from 7 to 10 P1 will uh execute at rest of the bust time that is the three unit of time at time 17 so from 10 to 17 the CP will remain idle at time 17 P2 will come P2 will execute its two unit of IO so from 7 to 19 uh it's not I it bus time so it will execute two unit of its bus time so from 17 to 19 P2 will work and and at time 19 no process is present in the ricu the process P3 came at the ricu at time 20 so from 19 to 20 the CPU will again remain idle and at time 20 P3 will get scheduled for the 5 unit of its first time remaining so at time 25 this will be over so I hope there is no confusion but I'll explain it again so what we have done what we have done this is 10 okay so what we have done now we will assume that there is only one IO device and if there is only one IO device the process has to wait until the previous process exits the io hi we completed our fcfs algorithm in the last lecture and from this lecture we will start our new algorithm that is the shortest job first so as the name suggest what you think about it in fcfs we scheduled that process which arrived first so in sgf that is the shortest job first we will schedule those process which has a less less burst time so this is based on the burst time the amount of time the process spends with the CPU if the process has less bus time it will be given higher priority than the process which as a large bus time so we will represent those process which is a high bus time as a long process and the process Which is less bus time or short bu time is short process so short process are given priority than the long process in shortest job first and like fcfs it is non preum to so a process cannot be forcefully deallocated okay so for conflict resolution as we did in the fcfs we will take the lower process ID see if P1 and P2 both has the same bus time then we will schedule P1 first okay okay so among the process present in the ricu select the process with least bust time and schedule it on the CPU so this is the line you have to remember for shortest job first among the process present in the RQ we need to select those process which have least bus time and schedule it on CPU okay let's solve the question so these were the processes and these are the arrival time and these are the bus time this is the thing which will be given to us okay now remember this point remember this point among the process present in the Rue among the process present in the radue we need to compare the bus time of only those process which are already present in the Rue all already remember this word already present in the Rue do not compare those process if they are not present in the ricu okay so a process arrived at time zero so P1 arrived at Time Zero we will schedule P1 no matter what because this is the only process present in the ricu now so we will schedule P1 and if P1 is scheduled in non preemptive algorithms then it will not exit CPU unless it has completed all its instruction or it need to perform the io okay so here I the case of I is not present so we will we will take the case that it will exit the CPU only if it will it has completed all its instruction so for two bust units it will be there with the CPU and then it will exit at time two which processes are present in the Rue at time two only P2 is present because P1 has exited and P2 is present in the RQ so we will schedule P2 directly without any comparison because this is the only process present in the RQ so for three units of time P2 will be with the CPU at time five which processes are present in the CPU so at time three P3 came and and time five P4 came so we will see till time five which process are present in the CPU so P3 and P4 are present in the ricu I I didn't want to use the word cvu it was Ru okay so P3 and P4 are present in the ricq at time five so we will compare the bu time of those process which are present in the Rue at the same time so for P3 and P4 which process has less Bus Time P3 has less bus time so we schedule P3 there we will schedule P3 and it will it will be with the CPU for one bu unit so it will be with the CPU till time 6 and it will exit at time six which Pres process are present in the Rue so at time six no new process has came so we'll schedule P4 because this is the only process present in the Rue P4 will be with the CPU for two units so from 6 to 8 P4 will be present with the CPU and at time P4 at time at time 8 P4 will exit Okay so at time 8 which process are present in the ricq at time 8 P5 is the only process in the Rue so we will schedule P5 without any thinking so from 8 to 11 for three bust unit P3 will be with the CPU at time 11 which process are present in the red CU process 6 it came at time 10 so we will schedule P6 without any thinking so we will schedule P6 for two units of time so from two units of time from 11 to 13 P6 will be the CPU I hope the point is clear why I took this question with this data set so as to clear the point that we need to compare the bus time of only those process which are present in the ricu and among those process select the process with least but time least bu time and schedule it on CPU I hope the point is clear now I have written there also that bus time is only compared with the processes in the r okay let's try another question so these are the six processes their arrival time and bust time are given to us now let's see which process are present in the ricu at time zero so no process is present in the radic at Time Zero the first process which came in the ricu was P4 at time two so from 0 to two CPU will be idle because no process is present in the ricq at time two P4 came so we will schedule P4 for how much time for three units so from 2 to 5 P4 will be present at time five which process are present in the RQ at time five P5 is present P6 is present and P2 is present so P5 P6 P2 P5 and P6 are present at time five so which process will be scheduled among the these these three process which are present in the r at same time the process which has least bust time which process has least bust time among these three process P2 P5 and P6 P2 P5 and P6 uh all these process have the same bus time so we will use the tiebreaking criteria that is schedule the process which have lower process ID so we schedule P2 here P2 will be executed for two units so from 5 to 7 P2 will be the CPU at time 7 which processes are present in the CPU at time 7 P3 a new process came so these process are present in the CPU at time seven because these two got executed and these three are present so we need to compare the bust time of these three process P5 P6 and P3 so P5 P6 have bust time of two and P3 have a burst time of four so we will schedule either P5 or P6 now we will use the tiebreaking criteria P5 is a lower process ID than P6 so we will schedu P2 P5 so we will schedule P5 here P5 will get a executed for two units so from 7 to 9 P5 will be executed at time 9 which process is present in the CPU so at time 9 no new process came these two process are available we will schedule the process which has a lower burst time so process 6 has a lower bu time so we will schedule process 6 okay for two units so at time 11 which processes are available in the RQ P1 came a new process P1 came at time 10 so these two process are ail avilable till time 11 so we will schedule the process which has a lower bus time which process has a lower Bus Time among P3 and P1 so P1 has a lower bust time so we'll schedule P1 for one bust unit so from 11 to 12 P1 will be the CPU and at the last P3 will get scheduled for 4 units so from 12 to 16 P3 will be with the CPU and then the P3 will exit at time 16 which process are present in the Rue all the processes has been executed so no new process is there we will end our Gant chart here now if I ask what is the schedule length the schedule length is the arrival time of the first process to the completion time of the last process so schedule length will be 14 what will be the percentage CPU idleness the CPU was not idle during the whole schedule length Okay so I hope the point is clear now let me revise again or let me give you the road map see at any time see the process which are present in the ricu if there are mple process present in the RQ see which process is a lesser bur time schedule this that process and if two process have the same bur time schedule the process with the lower process ID only compare the bus time of those process which are present in the radue at the same time okay so here we see at time five at time five P3 and P4 represent in this sgf we do not see the arrival time of the process okay the arrival time is only seen when there is a single process present in the RQ like there it was the single process present so we'll schedule that without any thought okay so I hope the point is clear how the sgf works so in the last lecture we completed the sgf algorithm that is the shortest job first now we will learn the preemptive sgf a new type of sgf that is the preemptive sgf and we call it as srtf shortest remaining time first what will be the selection criteria of this srtf similar to g f that is the burst time we will schedule those process which have a lower burst time okay and the mode of operation will be preemptive and the tiebreaking rule will be the similar to SDF that is the lower process ID I have an important note for you preemption of running process is based on the availability of a strictly shorter process this is an important point I will come back to it again when we will see some questions then I will refer it again now another point that is out of the process present in the radue select the one having the least was time similar to sgf and we will continue to the run on CPU that process until a new process with shorter Bus Time arrives and I should not write here shorter we should I should write strictly shorter strictly shorter bus time okay so let me read it again out of the process this is the part which you need to remember for sgf out srtf okay in sgf till this part was correct and as it was non preemptive so we will continue to the run on CPU until the process completes but here a new additional thing came that is we need to preempt the process if a new process with shorter bu time arrives okay so I hope the point is clear so let's try so we will first schedule the process based on the sgf algorithm that is the nonpreemptive algorithm at Time Zero which process are present in the RQ at Time Zero only P1 was present so we will schedule that P1 no matter what so we will schedule that P1 for five best units so we P1 from 0 to 5 at time five which processes are present in the ricu only P2 is present P1 is ended so P2 will be scheduled for two units so from 5 to 7 P2 will be scheduled so this was when the sgf case was there when we were talking about the non preemptive case now let's take the case of srtf what I have said select the one with have least verse time so which process are present in the radic at time zero so P1 was present in the IQ so we will schedule the process P1 okay so from 0 to 2 units we only schedule till 2 units why because we will continue to the run that process of CPU until a new process arrives at time to a new process arrives so from 0 to two we will run and a new process arrives so we'll see that if the new process has a burst time strictly shorter than the remaining bust time that is three so two is strictly shorter than three so we we will preempt the P1 we will preempt the P1 and we will schedule P2 for two units of BU time so we will schedule the P2 for 2 unites of bus time so P2 completed at Time 4 and then we will go back to P1 P1 will be scheduled for 3 units of its remaining time so from 4 to 7 P un was scheduled let me clarify it again in sgf we directly Shu the process by just comparing the burst time of the process present in the RQ at P1 was present in the RQ so P1 was scheduled so from 0 to 5 as it was non preemptive P1 will completes and then after completion it will leave the CPU so at time five which process are present P2 was present so we schedule the P2 for 2 units that way now in srtf I have said we need we will continue to run the process on CPU until a new process arrives and if a new process AR we need to compare the burst time if the burst time of the new process is strictly less than the remaining time of the old process then we will schedule the new process and preempt the old process I hope you got the point so here in the case of srtf which process are present in the radicate time zero only P1 was present so we will schedule P1 and we'll continue to the Run P1 until a new process arrive at time two a new process arrive so we will compare the burst time of the new process and the remaining time of the old process if the burst time of new process is strictly shorter than the remaining time of old process we will preempt the old process and will schedule the new process so P1 will be preempted at time to and P2 will be scheduled P2 will be scheduled so no new process came till P2 has completed its instructions so at time for P2 will leave the CPU and the remaining process that is P1 will came to execute its rest of the instruction for three units of time so I hope the point is clear now I want to make another point that is if P2 also is a burst time of three let's let's write this if P2 also has a burst time of three so then we will check time to a new process arrived yes a new process arrived does the new process have a strictly shorter burst time than the already running process no it is not strictly shorter it's it's equal so we will not preempt the process in that case I have written shorter or I should write strictly shorter okay so if P2 also has a burst time of three then remaining burst time is not strictly greater than the uh new process burst time so no preemption will be there at time two there is another process available in RQ which is a bu time is lesser than the remaining bu time of currently running process hence we preempted that in older case in this case if the first time would have been three then we should we would not have preempted that part okay I hope the srtf is clear now let's move down and we will see a question which algorithm has more context switches is it sgf or srtf we are given with this information P1 P2 and 3 P3 are the process numbers this is the arrival time and this is the burst time so we'll first draw the Gant chart for sgf and then srtf so let's draw for sgf first so at Time Zero which process was present in the rigu at time Z P1 was present for bu time five so P will run in the CPU from 0 units to 5 units okay at time five which process are present in the Rue process two and process three are present process two came at time one and process three came at time two so till time five these two process are present in the ricu with this bus time now we will choose the process with lesser bus time so P3 will be chosen I will schedule P3 for two units so from 5 to 7 P3 will run and for rest of the time for four units P2 will come so how many contact switches first Contact switch and second contact switch so it took two switches in sjf now let's see for srtf in srtf which process will be scheduled only P1 will be scheduled because it was the only process present in the Rue so we will schedule P1 for how much time we will schedule until a new process arrives so at at time one we will see and stop we will stop and then see whether a new process arrived yes new process arrived that is P2 does the P2 have a birst Time strictly shorter than the remaining bus time of P1 so at Time 1 P1 have run for one unit so the remaining bus time will be four now P2 also have a bus time of four and P1 also have bus time of four there is no strictly shorter concept they are equal so we will not preempt so this will go run till P at time to at time to a new process arrived till time to P1 have run for two units so the remaining bus time was three and the bus time of new process is strictly shorter than the remaining bus time so here we will preempt the P1 and then P3 will be scheduled P3 will be scheduled for 2 units because this has the least best time so for 2 to 4 P3 will be scheduled and then which will come P1 will come because it has a lesser bus time than P2 so P1 will come and it will run for the remaining three units so from 4 to 7 P will been run and then from 7 to 11 the remaining this part P2 it will run from 7 to 11 so how many contact switches 1 2 and three so three contact switches for srtf and two contact switches for sgf so it was it was an obvious thing because srtf was preemptive it was an obvious thing to suggest that srtf would have more contact switches than sgf okay so what is this point I have written check every time whenever new process arrives so at time one we checked because a new process arrived at time one at time two we check because a new process arrived at time two so we need to check every time whenever new process arrives and if the bust time of the new newly arrived process is strictly shorter than the B first time of remaining process or currently running process then we will preempt otherwise we will not preempt I hope the point is clear let's see another question so why don't to do it as a homework okay I have also given you a solution so try this as a homework and in the next lecture we will discuss so let's start with the homework question which I have given you so this is srtf question and there are six process given to us along with your arrival time and birst time so we need to calculate the entries in the grand chart for srtf algorithm so we can see at time 0 to2 there is no no process available so from 0 to two CPU will be idle at time two we can see there are two processes that is P2 and P6 that have arrived and The Bu time of P6 is lesser than bu time of P2 so we will schedule P6 first and we have to run P6 until a new process arrives so a new process arrives at time three a new process arrives at time 3 which is a burst time of 6 and the remaining burst time of P6 was 7 so we need to preempt it because you know the reason so at time three P6 will be preempted and will be sent back to RQ and P1 will be scheduled because it has a bus time lesser than the remaining bus time of P6 so we need to run P1 for how much time till a new process arrives so we have to keep running P1 until a new process arrives at time for a new process arrive that is P5 and it has a burst time lesser than the remaining burst time of P1 so we will schedule P5 we have to run P5 until a new process arrive at time five a new process arrive which is a burst time lesser than the burst time of remaining P5 so we will schedule P3 and we have to keep running P3 until a new process arrive at time six a new process arrive which is a burst time equal to the remaining bus time of P3 so we will not preempt P3 we preempt only in the case of strictly shorter I have told you this several times so we will not preempt P P3 at time six we will keep it running till it's completes so at time seven there's no new process now now I want to clarify an important point there that I should write it here it behaves like sjf when new process stops coming so now if the new process stops coming preemption will stop okay because the preemption only happens when there is a new process which has a shorter bu time than the remaining bus time of the old process so when new no new process is coming then there will be no preemption sgf become srtf becomes sgf so at time 8 at time 7 also no new processor is there so now which which process is in the RQ at time seven at time 7even all of the process have been arrived so we will schedule the process which has the least best time that is P4 P3 is completed so we will schedule P4 now P4 will come there and it will run for one unit until it get completes so now how many process are completed P4 is completed P3 is completed is there any process which is completed no the rest are remaining now at time it which process will be scheduled the process which has a lesser bus time so we will see which process is a lesser bus time it has a five it has 10 it has three it has seven so three is a lesser bus time so we will schedule P5 for how much time until it completes because on this time srtf becomes sgf so P5 got completed now P5 is also complete which process should be scheduled next the one which has a lesser bus time out of 5 10 and 7 five is a lesser bus time so we will schedule P1 there and it will complete till 5 minutes so till 11 11 to 16 P1 will run now which process should be scheduled this is also completed there are two process remaining 10 and 7 so we will schedule the seventh one that is P6 so we will schedule P6 16 + 7 that is 23 so we will schedule until 23 and then at time 23 the last process that is P2 which has the largest bu time will be scheduled so at 22 to 33 P2 will be there I think this has become easy now okay it it may seems difficult in the beginning but everything is difficult in the beginning okay when you were small when you when you used to write a b c d that was also difficult at that time everything is difficult in the beginning okay do not worry so this is a homework question for you this is a homework question you need to solve I have also given you the answer this is 8.25 okay now another question three process arrive at Time Zero with CPU but of 16 20 and 10 milliseconds if the scheder has a prior knowledge about the length of the cvu bust the minimum achievable waiting time for these process in a non preemptive Sher is how many milliseconds now to solve this question we need to learn about the performance of sgf and srtf so we need to learn about the performance of sgf that is non preemptive and srtf that is preemptive and these two algorithm are said to be optimal algorithm so is there any problem regarding these algorithm why are they optimal because both of them favors the shorter process I I have said shorter process refers to those process which has a less burst time with respect to other process so what are the advantages and disadvantages of doing this favoring shorter process the disadvantages is it causes starvation to the longer process as soon as new process with shorter Bus Time Keeps arriving the longer process will never get a chance to run on CPU and what is the advantage an ages as they favor shorter process so in a fixed time segment more number of process can be completed or more jobs could be done in less duration it means it maximizes throughput minimizes the average waiting time and average turnaround time okay now is there any problem regarding these sgf and srtf they are good yes there is a problem because think about this they work on the burst time burst time is the time required by the process to execute all its instruction on CPU they work on the burst time their implementation is the problem because we do not know the prior bust time of the processes how can we how can we know for how much time process will run on the CPU that's why it needs prior bust time its implementation is not possible okay so since the bu time of process are not known a Priory they are not practically implementable if this is the case then why did you teach a shage you may ask this question then why did we study them because theoretically sgf is an optimal algorithm and we use sgf as a benchmark to measure the performance of other algorithms okay this is quite understand understandable thing so sgf can be implemented with predictive verst times what are the techniques to predict the best time we'll see later but let us do that question what was the question there there are three processes which arrive at Time Zero it means at Time Zero all three processes were available in the RQ with CPU bust off 16 20 and 10 Mond if the scheder that's why it is written there it has already prior knowledge about the length of the CPU bust this is theoretical okay the minimum achievable average waiting time for these process in a non preemptive mode is so which is the best algorithm for the least waiting time sgf and srtf and which one out of these two we have to use here the one which is non pre that is sgf so we will use sgf okay so it's a easy question you just have to apply sgf and calculate the waiting time I hope you can do that let's move to the next question you should try this on your own and then see the solution so there are four process P1 P2 and P3 P4 and the buth time of P4 that is equals to Z is unknown to us and the thing which is given is total waiting time should be equal to 4 now solve the question this is a good question you must solve this and then see the solution otherwise you won't appreciate the beauty of this question okay so let's go so there are four process along with the arrival times and first time are given so we need to calculate the value of Zed okay so let's discuss the approach first so what we will do we will calculate the waiting time we will we will see that this process has to collectively wait for four unit of time okay so we will schedule the process in such a way that the waiting time equals 4 Okay so at time Z which process was available only P1 was available so P1 will get scheduled from 0 to 1 P1 will scheduled and at Time 1 a new process has arrived which is a burst time lesser than the burst time of currently running process so P1 will get preempted and P2 will run for one unit and at time two and at time two only P1 was present in the RQ these process came later after time to so P1 will get scheduled again till here let's calculate the waiting time let's calculate the waiting time so P1 has waited for how much time P1 waited for one unit of time when P2 was running P2 waited for how much time P2 waited for zero now P3 and P4 are remaining so let's erase all this P3 and P4 both has to wait three unit of time I hope you got this because P1 has already waited for one unit of time now these two collectively have to wait three unit of time okay P3 arrived at time three P3 arrived at time three so it has already waited for one unit of time it has already waited for one unit of time so we can write here that P3 and P4 has to wait two unit of time okay let me uh speak again P3 arrived at this moment and the next schedule process the next process which have to be scheduled will be scheduled at Time 4 so P3 is already waited for one unit of time so these two process have has to now collectively wait for 2 units of time now let's discuss the important part which process should be scheduled first out of these P3 and P4 as we don't know the value of Z so let discuss the cases let's say P3 will get scheduled first okay let's schedule the P3 first if we schedule P3 first then P4 will have to wait for how much time the first time of P3 when weu P3 then it will run for 7 and then p 4 will get scheduled now P4 will wait for how much time it will wait for three units of time if P4 will wait for three units of time that is not possible that's already exceeding this so it is not possible that we scheduled P3 first it means we have to schedule P4 first let's schedule P4 first if we schedule P4 first and for how much time P3 have to wait it it has to wait for Z unit of time so P3 has to wait for Zed unit of time and for how much time P4 Will Wait P4 had had arrived at time four and and it gets scheduled at time four it arrived at time four and it gets scheduled the time for so for how much time it has waited it has waited for nothing so Z + 0 = 2 it means Z = to 2 it means the first time of process 4 will be two now after we have found the value of two let's verify so let's do this as two now let's schedule the remaining process so P4 will get schedule first P4 will get scheduled first because it is a lesser first time so P4 will run for two units that is six and then P3 will be scheduled for 3 units of time that is N9 now let's calculate the waiting time of all process for how much time P1 has waited P1 has waited initially nothing and then P1 has waited for 1 unit of time okay for how much time P2 waited P2 waited for nothing as it arrived at Time 1 and it get scheduled at Time 1 so P1 waited for nothing now for how much time P3 had waited P3 had waited for one unit here as it arrived let's let's discuss directly as it arrived at time three and it get schedule for time six so it waited for three units so total weight will be four the total weight will be four so the option is uh the value we have found is correct so in the previous lecture we somewhere discussed that sgf is the optimal algorithm but there is a problem with the sgf it's implementation we do not know the bur time a prior we can only predict them so in this lecture we are going to learn about some of the prediction techniques for CPU birds so there are two type of techniques static and dynamic in a static Technique we look at the total verst time let me give you an example so first is the process size there was an old process which is a size of 101 KB and it ran on the CPU for 20 seconds there's a new process which has a size of 100 KV so we can say that it will approximately run around 20 seconds in the CPU so this is how we predicted based on the size okay there is another method to predict the static burst time on the basis of type there are four let's say there are we have segregated these processes in various classes let's say the operating system type process interactive process foreground process background process OS process take an average burst time of 5 Seconds interactive process average bust time of 10 seconds then 15 seconds and 30 seconds then there is a new process which has arrived and it has a type of background process so we can say it will approximately run around 30 seconds so these are the methods which we have predicted the static first times okay now the another technique is dynamic but what I want to tell you is while remaining in the radue we want to predict how much time will be of the next burst so while remaining in the NQ we need to predict how much time will it is going to take for the next burst while remaining The Rue we want to predict how much time it will take for the next burst while remaining The Rue I hope you got the point so these are the two predictions which we have already made now while remaining in this radue we want to make the predictions for this CPU P so how can we do that now how we will predict dynamically so for dynamic predictions we have a technique named exponential averaging technique or aging algorithm so this is the diagram which I was there referring to this is T1 that is the completed bus time so T1 will represent the this vt1 T1 will represent the bt1 and to one will represent and T one will represent the time which we have predicted for the first bust I hope you got the point this was the actual and this was we predicted let me write again this was the time which we predicted and this was the time which actually process took so for this to3 will be the time which we want to predict and T3 will be the time which was actually taken by the process so to n + 1 represent the next CPU busts so here the value of n will be 2 what is the n signifies n signifies how many times the process has already been with the CPU so here two times the process has already been with the CPU now we want to predict for the next bursts see to n plus1 represent the next CPU bu so the formula that we experimentally derived that is to n +1 is equals to Alpha TN + 1 Alpha TN so what does this signify Alpha is just a constant which lies between 0 to 1 so what does this Alpha signify it signifies the weight so for the prediction of next CPU bust how much weightage we are giving to the already completed CPU busts plus how much weightage we are giving to the predicted CPU busts okay so to calculate the next CPU bust we are giving some weightage to the actual time taken plus we are giving some weightage to the pr predicted time I hope I am able to clarify what I want to say weightage given to the actual time taken weightage given to the predicted time so we will calculate the T n+1 in this way so what is it it is a recurrence relation so how are we going to solve this recurrence relation V will put the value of TN so this this method is known as back substitution so what does we do here we will find the value of TN and we'll put it back here okay so if the equation as a t n + 1 = Alpha TN + 1 Alpha t n so what we will do we will just subtract 1 so this will become t n equal to Alpha tnus 1 + 1 Alpha t n minus 1 so this will give the value of to n this is how recurrence relation work so what we will do we will substitute back the value of TN now we get this what we will do now we will solve it first we'll simplify it first so we will get this after the substitution value of TN and then we will get to n minus one what we will do we'll again find the value and we will put it so we found the value of to n minus one and then we put it what we will get then we get this part and then we will keep putting the value of to then we will put the value of to n minus 2 and then to n minus 3 and we will keep putting the value until we reach to 1 this is to until we reach to one now now the thing now the question arises okay so we started with to n we put the value of t n minus one and then we put the value of t n minus 2 and at last we reach the value of to n what we will do then we have to do nothing because the value of to 1 will be given to us this value is known as initial guess so let's take the analogy of factorial we cannot find factorial of any number until we know the factorial of zero that is one can you find the factorial of five yes uh without 0 factorial No 5 into 4 into 3 into 2 into 1 into 0 factorial you can find the value of this but how will you get the value of this because in factorial you cannot put negative values so you cannot find the value of any factorial until the initial guess is given to you so here the value of T1 will be given that is to1 will be given that is the initial guess so what we can infer given the value of L Alpha and to one one can predict any CPU bus let me clarify again so in HF the main problem which arised was its implementation we do not know the burst time of the process a prior so we need some prediction techniques to predict some CPU bus so there were two techniques static and dynamic in static we used the two methods of size and type in Dynamic what we do while remaining in the Rue we want to predict how much time it will take for the next verse so we derived a recurrence relation so this was the recurrence relation given what we will do we want to solve this recurrence relation so we found the value of TN and then we put the value of TN back in the original equation and we will keep on doing until we reach T1 and the value of T1 we know because it is the initial guess it is similar as if we know the value of 0 factorial to find the factorial of any number so given the value of T1 and Alpha we can predict any next CPU bu so let's take the question it will clarify you more let's solve this question now consider a system using so I hope the point is clear let's move to the question consider a system using aging algorithm to predict the next CPU bu given alal to 2 and to 1al to 10 the process Bus Time hour that is this is T1 this is T2 this is T3 this is T4 these are the actual completed burst time now we need to predict the next CPU first okay so we'll use the equation to n + 1 equal to Alpha TN + 1 Alpha t n so we need to find the fifth bust so we'll predict the next CP bu four has already been completed so n is equal to 4 so we will put the value of n equal to 4 so T 5 = to Alpha T4 + 1 Alpha T 4 so we got this equation here we know the value of alpha T4 1 Alpha we don't know the value of T4 so we'll write the equation for T4 what we will do we will put n = 3 so we will get T 4 = to Alpha to T3 + 1 Alpha to 3 we don't know the value of to 3 we'll do this again uh to 3 = to Alpha T2 + 1 Alpha to 2 we do this again to 2 = to Alpha T 1 + 1 Alpha T 1 we did this we kept on putting the values until we reach the initial guess are we given the value of initial guess yes so this is the value which we are given with now we know the value of this this this and this so we can find the value of T 2 we will put the value of T2 here we'll find the value of to 3 we will put the value of T 3 here we'll find the value of T 4 and we'll put the value of T 4 and we'll get the value of to 5 so in this way we'll get the next CPU burst it was an easy question so this is an important formula you need to remember this what does it say t n + 1 equal to Alpha TN + 1 Alpha t n Alpha signifies the weightage okay but the problem of starvation is still continuing in this sgf whether preemptive or non preemptive because longer process will starve against the solter process this fact cannot be denied so how we will solve this problem yes that is the hrrn algorithm highest response ratio next now you may wonder what is response ratio so response ratio is this waiting time plus burst time divided by burst time and burst time is also known as service time so the response ratio is commonly known as W + S / s Well w is the waiting time s is the worst time and s in the denominator is the first time can you can you infer something from this response ratio can you infer something yes the process with the shorter bus time is preferred but the process which has been waiting for a long time is being given more priority than the shter process do not worry when we will see the numerical you will get a more understanding of this so the next process is to run is the one whose response ratio that is this part is the highest so the response ratio is highest that process will be given more priority longer process waiting from a long time will have high response ratio and that was the problem which got solved with this hrr and algorithm now W + S / s that means if waiting time increases then response ratio increases if burst time decreases then response ratio increases it means the shorter process is given priority that fact cannot be denied but the longer process which has been waiting from long time will have high response ratio so when waiting time increases the response ratio increases and that process will be scheduled first whose response ratio is high and its mode is non preemptive it works on a non preemptive mode and the tiebreaker thing is again the lower process ID suppose two process have same response ratio then the process which have lower process ID will be favored so let's see a numerical and then we'll get a better idea of this so these are the data sets now let's first solve using sgf so which process is available at Time Zero process one so we will schedule process one for bus time three so till process 0 till time 0 to 3 P1 will run at time three is there any new process which has arrived yes P2 has arrived so we'll schedule P2 for sixth bus time so from 3 to 9 P2 will run now all three process has been arrived till P2 completes now P3 P4 and P P5 are present in the ricu which process has shorter bust time P5 has shorter bust time so we schedule P5 from for two bust units so from 9 to 12 P5 will run from 9 to 11 P5 will run now out of them which process is shorter Bus Time P3 so their P3 will run for 4 units of time so from 11 to 15 P3 will run and at last for five units of time P4 will run so this part this Gant chart is based on the hgf algorithm what we can infer from this see at this point at at time 9ine at time 9 see at this point P3 arrived at Time 4 but it got scheduled at time 11 and P5 arrived at time 8 and it get immediately scheduled because it was shorter so this is something unfair being done to process the now let me speak again P3 arrived at Time 4 and P5 arrived at time 8 but still P5 got scheduled at timeline just because it has a shorter bus time this was something unfair being done to process 3 it arrived at Time 4 it should be scheduled earlier but P5 is favored because of a shorter bus time so P3 has been waiting for a long time this should not be the thing so how can this problem be solved using hrnn SO waiting time of P5 is 1 and waiting time of P3 is 7 this is unfair so let's solve this by using hrrn now what we do in hrnn let me recall so out of the process present in the RQ we calculate the waiting time and The Bu time and then we will do waiting time plus bust time divided by bust time that is the response ratio and we'll compare the response ratio between those process only which is present in the Radu at the time of scheduling and there's a special thing this waiting time is not the waiting time for the complete Gant chart it is the waiting time till the time which we are seeing when we'll solve the question you will get a better idea what I I want to say okay so which process is present in the radue at Time Zero P1 is present so we will schedule P1 for three units of time as I say it was non Prem for time at time 2 P2 was present so P2 will be scheduled because this was the only process we need not to think anything if there is only process in the ricu for scheduling scheder will not think anything and it will directly schedule that only process so P2 will be scheduled so from 3 to 9 as it is a bu time of 6 P2 will be there at time 9 which processes are present in the Rue at time 9 P3 P4 and P5 are present so these processes are present in the Rue at time 9 now we will calculate the response ratio because there out of these three process scheder has to select one so it will calculate the response ratio for these three processes for P3 what is the waiting time it arrived at time 4 and we are seeing at time 9 or the short time scheduler is at the moment of time 9 so from 4 to 9 how much unit P3 waited P3 waited for 5 units of time and what was the birth time of P3 4 and 4 so 5 + 4 divided 4 that is 9 by 4 which is 2.25 let's calculate for P4 P4 arrived at time six and shortterm Sh is planning to schedule at time 9 so at this time till this time how much unit P3 P4 waited P4 waited for 3 units of time and what is the first time 5 so 3 + 5 divid 5 that is 1.6 is the response ratio for P4 till time line now we'll see P5 so P5 P5 arrived at time 8 and the current time is time 9 so tell how much time is wait it waited it waited for 1 unit so 1 + 2 divided 2 that is 1.5 now out of these three response ratio 2.25 is the highest that is of P3 so we will schedule P3 here and it will run non preemptively for four units of bus time so from 9 to 13 P3 will run at time 13 which processes are present in the RQ P4 and P5 now we'll calculate the waiting time till time 13 so we'll calculate for P4 P4 arrived at time 6 till time 13 how much unit it has waited it waited for 7 units of time and The Bu time was 5 so we have written 7 + 5id 5 that is 2.4 is the response ratio for P4 now let's calculate for P5 so for P5 what is the arrival time it arrived at time 8 and the current time is 13 so till how much time it waited it waited for 5 units of time so 5 plus its bu time 2id 2 that is 3.5 out of these two which is greater 3.5 is greater so we'll schedule P4 P5 next and P5 will run for how much unit of time two units so 13 to 15 P5 will run and in the end the only process which is remaining in the ricq is P4 so we will schedule P4 directly so and P4 will run for 5 minutes of time so from 15 to 20 P4 will run now what we can see this was the longer process and this was the shorter process hrnn preferred that longer process which has been waiting from a long time so the problem of starvation solved so let's start our class with a new algorithm that is longest remaining time first this algorithm is exactly the opposite of algorithm srtf which we have studied earlier in srtf we used to schedule those process which has a shortest worst time among the process present in the ricu so here as the name suggest we will schedule the longest one but there is a catch that we will discuss later while solving the question so this algorithm is not easy as it seems this is a difficult one you have to be extra careful while solving these questions so the selection criteria is first time and the mode of operation is preemptive this make it dangerous and there is another thing that is the tiebreaker rule which was common in all of the algorithm which we have discussed if the tie if there is a need of tiebreaker rule we will we will take the lowest process ID we will prefer that process okay so let's start with the question and you will get an idea of what I was saying so at the time zero there are three process available in the radue so we will schedule the process which has a largest bus time so P3 has the largest bus time that is 8 so we will schedule P3 now for how much time P3 will run that is the main thing so in srtf what we used to say out of the several process present in the red EQ we will choose a process and we will schedule it to the CPU and for how much time this process will run this process will run until a new process arrives or there is a process present in the radue which has a burst time which has a burst time strictly shorter than the remaining verst time of currently running process so this we used to say we used to emphasize more upon strictly shorter thing as I said this algorithm is exactly the opposite of srtf so what we will do in this algorithm or you tell me what is the opposite of a strictly shorter thing the opposite of a strictly shorter is equal or greater equal or greater the opposite of strictly shorter is equal or greater so what we will do here we will keep P3 running will keep P3 running until there is a process present in the radue which has a burst time of either will will check of either eal or greater than the remaining burst time of currently running process I mean I am saying this very slowly because this needs an extra care so we will keep P3 running until there's a new until there's a process present in the ricu that is P2 which is a burst time of either equal so yes equal thing satisfies P3 is a bus time of 8 and it has already run for 4 units so the remaining bus time will be 4 and four and four are equal so what we will do we will preempt P3 and we will send it back to the radue and we will schedule P2 and we will schedule P2 because this is the process which has a burst time equal or greater than the burst time of than the remaining burst time of previously running process so four and four were equal so what we did we preempted P3 see we we never used to preempt a process in srtf if the bur time were equal but in ltf we will preempt a process if the bus time are equal so at time four four and four are equal so what we did we preempted P3 and we scheduled P2 so P2 will be scheduled now for how much time P2 will run P2 will run for only one unit of time because when P2 will run for one unit of time there is a process present in the RQ which is a bu time of greater than the remaining bus time of P2 so 4 is greater than three so we will preempt P2 and we and we will send it back to the RQ and will schedule P3 now for how much time P3 will run P3 will also run for one of time only because when P3 will run for one unit of time there is a process present in the RQ which has a burst time equal to the remaining bus time of process P3 so we will preempt P P3 send it back to the radue and we will schedule P2 again now P2 will run for only one unit of time because there is a process present in the RQ which has a burst time greater than the remaining bus time of P P2 so we will preempt P2 and we will schedule P3 now P3 will also run for 1 unit of time because the remaining bus time of P3 is equal to the bust time of two processes present in the radue now out of these two process which we will choose the process with the lower bu ID so we will choose the process P1 okay now P1 will run again see have you seen some pattern here the same pattern is going to follow now the B time of P1 P2 and P3 is 222 so which will be scheduled first so they will they will be scheduled alternatively so first P1 will run as P1 will run its remaining time will become one remaining bu time will become one now there are two process present in the redq which is a first time greater than the remaining bu time of P1 so we will schedule out of these two process now which process we will choose the process with the lower bu lower process ID so P2 will be scheduled here so P1 will be send back to the ricq and P2 will be scheduled P2 will be scheduled now P2 will also run for unit of time because there is a process present in the RQ which is a bu time greater so P3 will be scheduled now for how much time P3 will will run P3 will run for only one unit of time because if it has run for one unit of time there are two process present in the radue which is a burst time equal to the bu time of remaining bu time of currently running process so we will preempt P3 and now out of these two process we will schedule a process which is a lower bust ID lower process ID so we will SCH P1 and the same thing goes goes on P3 when when P1 will run this will become zero and there are two process present in the r which is burst time greater than zero so out of these two the process with the lower bur lower process ID will be preferred so P2 will be scheduled P2 will run for one unit of time and then there is a process present in the radue which is a Burge time greater than P2 so P2 will be preempted and P3 will go and in this manner all the process ends so this was a little bit weird algorithm and it and it requires an extra care to to solve such question okay so let's draw another question so this is the thing which we are given with and we have to find the average completion time of A and B okay so let's do this now there are three process present in the radue at time zero so we will schedule the process which has a largest bu time so now c will go there c will run for three units of time because at three unit of time there will be a process present in the RQ which has a bus time equal to the bus time of currently running process so six and six are equal so we will schedule C and we will so we will preempt C and we will schedule b b will run for how much time we will run for only one of time because there is a process present in the radue which has a bur time greater than the remaining bus time of currently running process so C's bust time is greater than than the B's bu time so 6 is greater than 5 so we will preempt B and we will schedule C now C3 will again run for one unit only so this thing will goes on and on until they all becomes equal so c will go there his bus time will become five five and five are equal c will get preempted B will be get scheduled then B's bus time will become four now there's a process which has a bu time greater so c will again get scheduled now c will run for only one unit because there are process available which is a bu time equal to C so out of these two the one which has a lower process ID that is a will be scheduled so a will come here a will run for only one unit as there are process with greater bust time so out of these two B will be scheduled so B will run for three and there's a process with greater verst time then C will be scheduled c will run for only one unit of time because there are process available in the RQ which which has a bust time equal to the bust time of currently running process so after of these two the process with the lower lower process ID will get scheduled so a will get scheduled here a will run for only one unit because the two is shorter than two is lesser than three and three so after these two B will be scheduled as it has a lower process ID so B will go there b will run for two units because 3 is greater B will run for only one unit remaining time will be two 2 is lesser than three so three uh that is the c will be scheduled now the same thing goes and on until the everything ends to zero so I hope you got the idea so now what we were asked we were asked find the average of the completion time of A and B so what will the completion time of A and B A completed at 17 and B completed B completed at 18 so 17 + 18 divid 2 is the answer let's solve some other questions in a system in a system using single processor a new process arrives at a rate of 10 process per minute and each such process requires 5 Second of service time what is the percentage CP utilization so this this is a very easy question six in 60 seconds that is a new process arrive at at a rate of 10 process per minute it means in 60 second 10 processes arrive that means in 6 second one process arrives and each such process requires 5 Second of service time so what is the CP utilization so there are 10 process each requires 5 Second of service time so 50 seconds will be the service time of all these 10 processes and the completion time will be the 60 so the percentage utilization will be the useful time upon the total time the useful time will be 50 and the total time was 60 so 50 divid 60 into 100 will be the percentage C utilization so this was a easy question let's move to another question six jobs are waiting to be run the expected running times are 975 21 so I made in this way and X respectively so this is X find the value of x using hdf algorithm so I have included those questions of old algorithm so for the revision purposes okay so I was thinking something about the dpps so I thought I should share the DPP with you for your practice uh I think I have solved enough questions in the lectures only uh so I will share the DP with you you solve them I will share the answers and the detailed solution detailed printed solution I will type them with you instead of making a whole video of this lengthy uh solving because there are at least 7 to eight questions per DPP and there are almost 5 to six dpps so it will take lot of time to discuss each question one by one and there are and they are easy question as compared to the question discussed in the lectures so what I was thinking I will share them with you if you get some doubt you may ask me and I will share the detailed solution with you okay so let's move to this question six jobs are waiting to be run then expected running times are this one find the value of x using SDF okay so let us schedule all the process are available at time zero so which process has the least bu time because this is sgf shortest job first and this is nonpreemptive so P5 will be scheduled it will run until completion at time when which process are present all of them are present so P5 will be over now I have to choose the smallest among the among these process except P5 so P4 this process has the shortest ver time so P4 will get scheduled it will run until completion now which process now P3 P3 is the shortest among 97 and x x is the One X lies between 5 and 7 so it will be greater than five hence P3 will be scheduled first P3 will be scheduled until 8 now X will come because its value lies between 5 to 7 and these ones are greater than 7 so X will be sh to next so P6 P6 with the first time of X so 8 to 8 + 6 will be scheduled next now P2 for 7 so 15 + x and then P1 that is 24 + x so what we are given there the expected running times are this and this uh X is the range of X is given and average completion time is 13 so we'll add the completion time of all and will divided by six because there are six process that will give me the average so P5 completed at 1 P4 at 3 P3 at 8 P6 at 8+ 6 P2 15 + 6 and P1 is 24 We'll add all of them and divide by six as there are six process and this 13 is given to us so X will be equal to this part and in just computation so I hope you got the idea how to solve these type of questions in the next lecture we will see an important algorithm that is priority based scheduling let's move to the new algorithm named priority based Shing this algorithm works exactly like sgf or srtf that means it could be nonpreemptive or it could be preemptive except that it looks for priority instead of BU time so the process with the hard priority will be given preference in terms of scheduling what is a priority it is a number assigned in corresponding to the level of importance of a process let's say OS processes the that is operating system service routine will be given higher preferences than the user process okay so the OS process will have higher priority it could be non preemptive or preemptive and the tie breaker will be the same that is lower process ID okay so if two process with the same priority comes then the one with the lower process ID will be selected So based on the type size and the resources integer value is given to a process that is the priority okay so what is the default convention the default convention is higher the number higher the priority will be there higher the number higher the priority okay so if it is given in the question that 10th be the lowest priority and number one be the highest priority then you have to take accordingly okay but the default one is higher number higher priority so let's solve using both preemptive and non preemptive so these are the process these are the priority of the process arrival time and the burst time let's solve using non preemptive so this is the arrival time P1 arrived first so we will schedule P1 and it will run until completion because this is the case of non preemption so it will run until 4 at time four which processes are available process two and process three which has a higher priority process three so we will schedule process three until it completes so it will run for 5 minutes of time so 4 to 9 process 3 will run and in the end process two will run for 9 to 12 so this was the case for non preemptive and for the preemptive case process will continue to run until a new process with the higher priority arrives so P1 was the first to come in the C in the RQ so P1 will be scheduled first and it will run until a new process the higher priority arrives so P2 is the new process with higher priority so it will run until one and then P1 will be preempted and P2 will be scheduled and P2 will run until a new process with high priority arrives so P2 will run until one unit and P3 arrives now P3 is the process with the highest priority so it will run until completion so it is a worst time of 5 so it will run from 2 to 5 and then which processes are present in the ricu now P1 and P2 which is a higher priority P2 so we will schedule P2 until it completes see see in srtf whenever the process stopped arriving it behaves like sgf or the preemption or we do not preempt the process when there is no new process arrival okay so when new process stops coming will stops the preemption so here at time three 0 1 2 so at time three at time three no new process came so after this we did not preempt any process before its completion okay so these process left the CPU after their completion only okay so I got the point this is similar to srtf and sgf but in srtf we used to focus on first time and here we will focus on priority this is as simple as that let's solve another question so there are six process available these are the priority this is the arrival time and this is the burst time so let's create Gant chart so we can see there is no new no process at Time Zero so the the first process arrived at time two from 0 to two the CPU will remain idle at time two at time two I can see that process 4 is available at time two the process 4 is available with priority three so I will schedule process 4 until a new process arrives at time three that is a higher priority than process four priority so six is greater than three so we will preempt four and we will schedule P2 now P2 will run until a new process arrives with a higher priority so after time time three new process arrives when a new process arrives at time four that is P1 but it Priority is lesser than the priority of P2 so we will ignore that process and then another process comes at P at time five which is a higher priority so we will preempt that process and we will schedule the process with the higher priority so P5 will be scheduled and I can see that it has a second highest priority so it will run until the new process with the higher priority comes so after 3 units a new process with the high PRI but it bu time is two so it will complete at time 7 at time seven which process are available in the RQ P2 is available with the the highest priority because at time five P5 got erased and the new process with the highest priority will come at time 8 so at time 7 P2 will be the process with the highest priority so we will schedule P2 and it will run until a process with the highest priority that is P3 with the priority 8 will come so as the process with the highest priority come the process with the lower priority that is six is lower with lower as compared to eight so this will get preempted and P3 will be scheduled and it will run until it gets completed because it the highest priority process so till 8 to 14 it will run as it is a bus time of 6 okay now which process will come now which process will come P6 will come P6 has a priority of five and it has arrival time of three so P6 will be scheduled why not P2 I think P2 got completed here 3 to 5 that is 2 unit and 1 unit so P2 was completed and the next highest process and the process with the highest priority after P2 and P5 was P6 so we will schedule P6 here so P6 will run for how much time P6 will run for five minutes of time because now new process has start arriving so whenever new process stops arriving the mode changes it becomes from preemptive to non preemptive okay so say the mode changes from preemptive to non preemptive now when the process get scheduled it will run until completion so this will run until completion run until completion run and run okay so at time 23 P4 will get over so what will be the schedule length completion time of the last process till the arrival time of the first process so from 2 to 23 that is 21 will be the answer for schedule length so let's start the part two of priority based scheduling in priority based scheding what we used to do we used to schedule the process based on the priority it is a number assigned to the process which was corresponding to the level of importance given to process okay so priority can be the static or dynamic static priority means fixed priority and dynamic means wearing can priority be wearing yes we will understand after some time so the problem will pursue that is the starvation to lower priority process because if high priority process keeps on coming then OS will never schedule a low priority process that will cause to the starvation to it and this is unfair so what we will do we will increase the priority so lower priority process will become higher priority process after some time that means the priorities are not fixed they are wearing they are Dynamic so Dynamic priorities that is based on the Aging algorithm will be the solution for starvation don't worry we will solve some questions on that okay so let's move to the question number one what does it say uh there's a system with three process P1 P2 and P3 and they have infinite instances of these process so the first instance arrival time of each process first instance is 1 millisecond what I want to say there are three process P1 P2 and P3 and they have infinite instances of them okay the first instance are arrived at Time 1 millisecond the second instance of P1 arrived at Time 4 and the third instance at time 7 so they have periods okay 3 7 and 20 3 7 and 20 okay so now the question is what is the completion time of first instance of process P3 so I have said there are three process P1 P2 P3 there they have infinite instances so when the what is the time when this instance will get over okay so nothing we have to just schedule and there is one more Point given that the priority is inverse of the period so the parity of process one will be 1X 3 P2 will be 1X 7 and third will be 1x2 so let's schedule so we will start with Time Zero which process is available at Time Zero no process was available all of them came at Time 1 millisecond so from 0 to 1 CPU will become idle at Time 1 which process will be scheduled the process with the higher priority this will be scheduled P1 will be scheduled for how much time as this is of higher priority it will complete until it will execute until completion so from 1 to two P1 will schedule so first instance of P1 completed at time two now who will come P2 will come P2 will run for 2 units of time so P2 will run for 2 unites of time because this is the highest priority process among P2 and P3 P1 was over now P2 and P3 are remaining so P2 will be scheduled for 2 unites of time so from 2 to 4 P2 will get scheduled now which process are available in the ricq P3 and P1 the second instance of P1 came at Time 4 so P3 and P1 these are the two process present in the ricq Which is higher priority P1 is high priority so P1 will get sched for how much time for one unit of time it has one unit of bust time now at time five which processes are present at time five only P3 is present I guess yes only P3 is present so P3 will run for how much time until a new process with higher priority arrives so P3 will run for 2 units of time because at time 7 P1 came which is of higher priority so P3 will get preempted at time 7 and P1 will come okay so from 7 to 8 it will run because it will run until completion as it is the process with the highest priority so it has wor time of one so it will run from 7 to 8 now which pluses are present in the RQ P2 is present because at time 8 the second instance of P2 came so P2 is present P2 will come in the RQ or P2 will come in the CPU and it will run for 2 units of time so from 8 to 10 P2 will run now the third instance came from came at time 7 third instance I think this was all completed now the fourth instance of P2 oh sorry a fourth instance of P1 will come at time 10 so fourth in instance will get scheduled it will run for one unit of time I said they have infinite instances they have infinite instances so the fourth will come at time 10 now P1 Will C schedu see P3 is not getting chance to be run after this first P1 came then P2 came then again P1 came now P3 will give the chance because P2 is over and its next instance will come come at time 15 P1 is over and its next instance will come at time 13 so at time 11 only P3 have have been in the CPU so it will run for how much time its remaining bu time so P3 has already run for 2 units here so it will run for 2 minutes here so what will the completion time of first instance of P3 at 13 so 13 will be the time 13 millisecond will be the answer now let's solve a question on Aging algorithm consider a system using preemptive priority baseding dynamically changing priorities the priorities are Dynamic on its arrival a process is assigned to a priority of zero so when the process arrives the priority is set to Zero running process priority increases at the rate of beta and the priority of process in ricu increases the rate of alpha by dynamically changing the values of Alpha and beta one can achieve different scheding disciplines well that is clear because see if the priority if the prior of the process in the RQ is more than the priority of process running then it will be preemptive and if the priority of running process is more than the priority of ready process then it will be non preemptive I hope you got the point so what will be the disciplin be followed by the following conditions so let's see if the process arrives the priority is zero process in ricu increases by Alpha rate and processes running increases by Beta rate so in a job queue when a new process arrives it has a priority of priority increase by Alpha rate so let's say at time one at time one what will the priority of ricq what will the pariy of processing ricq at Time 1 it will be Alpha because initially at Time Zero it was Zero at time one let's say it increased by Alpha so the priority of process in the ricu will be Alpha and what will the priority of process in the CPU running at Time 1 it will be beta so now we have to compare Alpha and beta beta so if beta is greater than Alpha which I mean to say if the priority of process running is greater than priority of process in the ready then no ready process can ever preempt the running process because beta is greater than Alpha so it will behave like fcfs first come first serve and if if ready process have always greater priority than the running process if ready process have always the greater priority than running process process but but a newly arrived process have always greater priority than ready process and running process then what will happen think think if a newly ared process have greater priority than running process and ready process then the newly arrived process will be scheduled first which means the one who came at last will get scheduled first so last come first serve and here the one who came earlier will be scheduled first I hope you going to point the one who came earlier will be scheduled first and in this the one who came at last will be scheduled first okay so if you have some doubt this is an easy question think about it here's the question read it again think about it see the solution and you will and your doubt will clear automatically welcome to the new lecture and in this lecture we learn about the round robin algorithm this is the most famous scheduling technique in this roundr algorithm let's understand the IDE if the process fails to execute all its instruction in the given time Quantum so we assign a fixed time Quantum let's say of 4 seconds if the process gets its all instruction complete in the 4 second this is well and good otherwise the pro the OS will preempt that process and will give chance to other processes to be with the CPU and that process that preempted process will go to the end of the Rue and go to the end of the ricq so let's see round an algorithm this algorithm is used in preemptive based multiprogramming time sharing operating system okay what does it do it improves interactiveness and responsiveness of the system so let's understand this by real life example so what we used to do in India we used to play cricket on the Terrace of our house okay so I I can recall when we were smaller when we when we were younger there was a big uh there was a big ba the big brother he used to play for so so far so long he used to play and we we the smaller kids do not get a chance to bet so we decided a rule we created a rule that every one of us will play only six balls that is in in one hour consist of six balls so every one of us will play only six balls and whether you are out or not you have to retire and give chance to other players to bet okay so that such things do not happen that uh a player who is good to a player who is good in cricket do not get out easily and we used to just ball and field and and in in childhood days we we used to think that balling and Fielding is boring and batting is a good thing so we all of us want to bat but this big boy doesn't let us to bat he was good in cricket so we decided a rule that whether you are out or not you have to leave you have to retire after after six balls you will go there in the fielders and one of us will go to B okay so the similar case is there the similar case is here in the round robin we assign a Time Quantum to a process whether a process completes its instruction in this time Quantum or not the process has to leave after that time Quantum and other processes who are waiting for the CPU will get a chance to be with the CPU so the criteria will be the arrival time plus the time Quantum and the mode of operation will be this is obvious preemptive okay so let's see the question first before starting the question I have a tip for you always maintain the status of ricu and keep cutting the processes which have been over from ricu see this is an important thing this is not only mandatory for round robin I suggest you should maintain ricq for any of the SCH algorithm this will decrease the chances of silly mistake which you may make but in case of round robin it is almost impossible or it is very very difficult to create Gant chart without the help of radue otherwise you may make mistake okay so what is my tip always maintain the status of ricu always and always maintain the status of ricu especially while solving the round robin questions and keep cutting the process from ricu like this way those which are completed keep cutting okay so let's see this question here the time Quantum is two which means a process will run for 2 units and then it will pre automatically so let's start so P1 P2 and P3 all are available at time zero so which process will will schedule the one who arrived earlier all of the arrived them same time so we will use the tri breaker rule TI breaker rule that is the lower process ID so we will schedule P1 what is the burst time of P1 P1 is burst time of 4 unit so we will schedule for two time Quantum and then it will preempt so P1 P2 and P3 all of them were available at Time Zero now what will happen till time two till time two P1 will run and it will go to the end of the radue at time two see I have seen I have written this I have written this if the time Quantum expires then OS will preempt the process and the preempted process will go to the end of the ricu so this P1 this P1 when it will get preempted it will go to the end of Rue so this was the Rue and it will go there now what will happen let's see at time to P2 will get scheduled now P2 will get scheduled it will run for how much time it will run for 2 units of time so it will run for 2 minutes of time now the remaining bus time I have maintained here 5 3 and 4 two now who will run now P3 will run P3 will run for how much time it is a bu time of three so it will run for two units and the remaining will be one so it will run there and after at Time 4 P2 will go at the end of ricu and at time 6 p 3 will go at the end of ricu now what will happen see this was completed now I will schedule P1 so P1 will get scheduled for how much time for 2 units of time so this will get over and P1 completed if P1 completed there is no need to send back to the Rue it will go to the terminate stage it will end so at time 8 P1 ended now which process is available P2 is available so we'll schedule P2 so we'll schedule P2 then the remaining time will be 1 unit so at time 10 P2 will again go back to the ready Cube okay so now P2 gets over now the turn is of P3 so P3 will run for how much time the remaining bus time is one so P3 will run for one unit of time so from 11 P3 will run and it will end here now P2 will run so I will cancel it and P2 will go there so in this way if you just put a cross mark there it will be easy for you to remember that we have scheduled all the process which has a cross mark okay I I hope you got the idea so this round dropping is a new type of uh Shing technique so I suggest you to do this Sol this question or on your own now and get this G chart okay so let us go there and solve another question this is a new question this is a another variety of round dring question which you will explore see there are five processes okay each arrived at different time and they have the bus time also given the time Quantum is two so we will schedule process P4 as it arrived at time three the earliest so from 0 to 3 CP will remain idle and at time three P4 will get scheduled for how much time the time Quantum is two so out of three two will get over so one will remain now at time five at time five P4 will go at the back of Rue but at time five we can see that P1 and P5 are also present in the ricu so firstly the new process will come and then the preempted process will join them at the back I'll speak again P4 ran in the CPU from time 3 to 5 L A Time five I see there are two process already available that is P1 and P5 so what I will do I will enter these process I will enter this process in the ricq first and then the preemptive process will go at the back of Rue so the firstly the new arrived process so the new process will come in the RQ and then the preemptive process will go let me this week again first the new process and then the preemptive process the new process and then the preemptive process so I hope you got the idea now let's continue our discussion so so P4 was present in the radic time three so from 0 to 3 the CP will remain idle and at time three P4 will come P4 will run for 2 units of time P4 will run for 2 units of time and the remaining bus time will be one at time five there are two new process that is P1 which arrived at time four and P5 which arrived at time five so I will schedule the new process in the RQ I will sent the new process in the RQ and then the preemptive preempted process will go so new process then preemptive process now I will cancel this part and then when I schedule P1 I will cancel this part okay so I have already scheduled P4 now I'm going to schedule P1 so I will cancel this P1 will get scheduled P1 is a bu time of four so it will run for 2 units of time it run for 2 units of time that is from 5 to 7 from 5 to 7 p Dr at time 7 is there a new new process no no new the next new process came at time 8 so at time 7 no new process came so I will directly send this P1 at the end of RQ this was the end of RQ then there so P4 will go there and P1 will go at the end of ricu now I will schedule P5 so P5 will come P5 is a bus time of four so two will be the remaining bus time so P5 will get scheduled here now from 7 to9 P5 will come P5 will come at time line I can see that there is a new process so the firstly the new process will come and then the preempted process will come new process will come first and then the preempted process so preempted process will go there now what I will do now I will schedule P4 so P4 was scheduled again for how much time it will run for one unit of the remaining bus time so P4 will run for one unit at time 10 is there any new process no the next new process is going to come at time 15 so at time 10 which process are available these processes are available so I will schedule P1 first then P3 and then P5 I can see the process which that is P2 came at time 15 so the new process will come first so at time 15 P2 will come and then the preempted process that is P3 will go there okay so I hope you got the idea so in the same way you have to complete the Gant chart so let me revise again what we have done till now so round dring algorithm is a kind of algorithm which has a fixed time unit a fixed time slice if the time slice expires then the OS will preempt the process and then that preempted process will go at the end of RQ after the new process comes Okay so the tip was always maintain the status Rue and keep cutting from Rue so we have seen this question let us let us do let us uh revise this question again because this is an important question firstly 0 to 3 CP will remain idle at time three P4 will get scheduled it will run for how much time at time three P4 run for two unit of time because this is time Quantum two one will be remaining this one will be scheduled later at this moment of time so P4 will get completed at 10 now will come P1 will come so P1 will get scheduled at time 7 at time 7 which process are available in the RQ P5 and P4 are available so they will come first and then people will go behind them and then we will schedule accordingly P5 P4 P1 and then the new process will come that is P3 and then the old process that is p P5 will go there now new process is present then it will come otherwise this this get over P5 P4 get over then P3 will go there here new process come then P5 that is this part will get sheded so in the same way you have to keep on going this is a ly question I don't want to waste my time on this I hope I have given you the concept now the computition part you can do on your own let's see another question let's move to another question this is a smaller one so we'll complete this question this is a round robin question in this question the process first go to The Bu time and then I and then again comes okay so let's solve I think this is an interesting question so the first process arrived at time zero so we'll schedule process P1 for how much time for two time Quantum so from 0 to 2 P1 will be there and I have I have written the bu time in there okay so from 0 to two two units will be subtracted from three so one will remain now which will come at time two P2 also arrived in the RQ so P2 will be scheduled for how much time for 2 units so from five 2 units subtracted that this three will remain now at Time 4 which process will come P3 is present in the ricq but it came at time three and P1 came back to the Ric time two so P1 will come first so P1 will come here for how much time it will run for one unit of time so it will run for 1 unit of time it has completed its bus time the first phase of the bus time now it will go to IO at time then time from 5 to 5 from 5 to 5 that is time 10 so it will come back in the ricu at time 10 okay at time five which process are present in the ricu at time five these processes are present in the ricu P3 was over so P1 was over so P3 will be there for how much time P3 will run P3 will run for 2 units of time so P3 will run for 2 units of time now the first phase of first phase for the first time of P3 was over now it will go for I from 7 to 9 it will go to I and then P3 will come back to the to the Rue at which time at 9 so P3 will come back here now P2 will be scheduled for how much time see time Quantum was 2 unit and three was the remaining bus time so one will remain for the bus time of P2 so two unit will be there now P3 will come again P3 has completed this part and this part now P3 will come there again from 9 to 11 11 P3 will end so P3 ended at time 11 now which processes are present in the RQ now P2 will get scheduled P2 will get scheduled for how much time P2 will run for just one unit so from 11 to 12 P2 will run now which process will come P1 will come and at time 12 P2 completed this part so it will go for Io till 20 till 20 okay so it will come back to the radic at time 20 now P1 P1 is a how much time remaining 1 so P1 will execute for how much time no no no no now we have moved to this part so P1 will execute for two units of time so two unit will be remaining so P will execute for two unit of time but there is no other process in the Rue so it will execute for two more so execute for two more so from 12 to 16 it will execute now there's an important part which I want to emphasize upon you think operating system will preempt P1 at this moment yes it has preempted P1 in this moment because so P1 will continue its execution preemption will obviously happen there at time 14 at time 16 which process are present in the ricu see P1 got over P1 got over P3 got over now the only process which is left is P2 but what it is doing it is performing its IO till 20 so CP is nothing to do till 20 so will wait till 20 so at this time CPU will remain idle at time 20 it will come back to the CPU to execute the one unit of B time so it will come back to from 20 to 21 P2 will come back to the CPU and at time 21 this will preempt or this will terminate okay so these are the some questions for homework so these are the easy questions you can do on your own okay so I have also shared the solution with you see the question the next one this is also homework homework question and in the next lecture we will learn about the response time so in the last lecture we have seen about round robin algorithm we have solved some questions on it in this lecture we will learn about the performance of round robin see the homework question and learn the New Concept of response time in the first lecture of CPU scheding I have talked about it that the goal of CPU scheding is to minimize the turnaround time waiting time and response time we have talked about this but this was remaining so in this lecture we'll clarify what is response time so let's start with the performance of round robin performance of round robin depends upon the time Quantum its value if it is taken very small small large and very large what is the consequence of that so if we have taken very small time Quantum then the efficiently will be nearly zero most of the time will be taken by dispatcher to schedule the task as soon as the task starts running on the CPU it will again be preempted and then a new process has to come dispatcher has to work and as soon as the new process start to be executed then that process will also get preempted and a new process will come so efficiency the net efficiency will drop to zero dispatcher will take the most of the time and the useful time what is the formula of efficiency useful time upon total time so the total time will be contributed most by the dispatcher and the useful time will be very less so efficiency will drop to zero if the time Quantum is taken small then then there will be more contact switching and there will be more overhead what is overhead dispatch latency but the responsiveness will increase if the time Quant is reasonably small then responsiveness will definitely increase if the time Quantum is reasonably large then contact switching will less so overhead will be less but interactiveness will decrease if I took time Quantum very large then let's say the time Quantum is is greater than the maximum of BU time then the round robin will perform like fcfs because none of the process will get preempted in between because the time Quantum is greater than the maximum of burst time so it will be least interactive and it will behave just like the fcfs algorithm what was the selection criteria of round robin arrival time plus time time Quantum and if time Quantum if time Quantum is greater than the first time of any process then it will behave just like fcfs I hope you got the idea let's discuss the homework question which I have given you it is a very nice question if you haven't solved this till now I request you I sincerely request you to please pause the video and solve this question this will teach you so many things okay so let's begin it is it is not a difficult question it is an easy question just a conceptual one so what this what does this question say we will learn consider a system okay with n processes arriving at time zero so at Time Zero all the end process are present in the ricu with substantially large bust time so bust time let's say each process a bust time of 100 the CPU scheduling overhead is s so the Delta is s the time Quantum is QC and time Quantum is Q using round robin scheduling what must be the value of time Quantum Q such that each process is guaranteed to gets gets a turn at time at the CPU exactly after T seconds in it subsequent run on the CPU okay so how we will start this question see every CPU scheduling question it starts with the creation of Gant chart as soon as you create Gant chart you'll get an idea of how to solve it so let us start so here it is written every process there are n process and every process arrived at time zero so each process was present in the radue at time zero and it has a very large ver time so we need not think of B time why this line is given this line is given to prevent this case Okay so if bu times are substantially large then it will be mandatory for for the process to preempt in between of its execution bus time is larger than the time Quantum okay the CPU scheduling overhead is s second and time Quantum is Q using this we have to schedule in such a that each process is guaranteed to gets its turn at CPU exactly after T seconds in the subsequent run so what I have said in round robin when the process gets preempted it go back and join the end of the queue so when all these process will get it turn after that P1 turn will come so we are asking this is asking just that part that we have to schedule in such a way that each process is guaranteed to get its turn exactly after T seconds so this should be the T P1 got it turned exactly after the 3 second so this should be t Okay so let's draw the G chart schedule P1 0 to S we have seen that overhead was s so 0 to S will be the time taken by dispatcher s to S + q that is Q will be time taken by process P1 and then again P2 will get scheduled so s will be the time taken by the dispatcher so 2 s+ Q will be the time taken by the dispatcher and Q will be the time taken by P2 so 2 s + 2 Q will be the time taken by P2 in the same way if P1 completed at s+ Q P2 completed its first turn at 2 s + 2 Q so PN will complete this this process will complete its first turn at NS + NQ P1 at 1 s + 1 Q P2 at 2 s + 2 Q P3 at 3 S + 3 Q so PN at NS + NQ now this P1 will go and join the back of the que so now it is the turn for P1 to get scheduled s will be the time taken by the dispatcher now the turn off now after this much time P1 got it turn to run on CPU here it is written it subsequent run on CPU it subsequent run on CPU so after how much time P1 will start running so for for this case we will include this Delta 2 you must have made a mistake if you haven't read the question properly here it is written using Round Rob and scheding what must be the value of time Quantum Q such that each process is guaranteed to get its turn at the CPU exactly after TC in its subsequent run on CPU run on CPU is given so we will so from this part P1 have started running so we will include this Delta 2 so from this this this moment to this moment this will be the T so exactly after T second P1 got a chance to run on CPU so now what we will do we'll calculate this length so what is this length this is s+ q and this is n + 1 s + Q This was NS + NQ and there is a additional s so it will be n + 1 s+ Q so n + 1 s + Q minus s+ Q will give me this length so I have written this and then from this equation I have solved to get the value of Q easy peasy now there are some inferences which we can derive from this Q so if Q is equal to exactly equal to tus NS n minus1 tus NS nus1 then process P1 will get onto CPU exactly after T second if Q is less what is does it mean time Quantum is less then P2 will run less P3 will run less P4 will run less but the but the t is fix so what does this signify this signify that process will get onto CPU at least once within the time T if the time Quantum decreased then P2 will run less P3 will run less P4 will run less but this this length is fixed let me right this length is fixed this length is fixed if the process between these lengths between this length run for lesser time let's say P2 run for this time only and get preempted P3 run for this time only and get pred so P1 will get a chance earlier than the previous case are you following let me speak again this length is fixed the t is fixed if Q is lesser which means P2 run less than before P3 run less than before P4 run less less than before PN run less than before so P1 will get a chance earlier than the previous case Okay so process will get onto CPU at least once within the time T here the proc process got onto CPU exactly after the time T here the process will get onto CPU exactly once within the time T and when time Quantum become large and when time Quantum is become large it means P2 has run more P3 has run more P4 has run more so what can we infer we can infer process will get onto CPU after at least every time 10 seconds I have also explained them more so what does this say signify process will get onto CPU after at least every 10 second this says if the value of Q is large P1 will wait either TC or more than T that is selfexplanatory because if this become larger if this become larger then P1 has to wait either t or more than T if this become smaller if P2 run lesser than the usual then P1 has to wait either less than t or equal 2 D I hope you are understanding see let me speak again let me speak again if this is exactly equal then P1 get to run on CPU exactly after the TC this was the time T if the time Quantum is decreased in time Quantum is decreased then every process will run lesser than the usual P2 will run less P3 will run less so in this case in this case process will get onto at least once within the time T So P1 has to wait either time T second or lesser than time TC if P2 run less then P3 run less P4 run less so all the process will over earlier than the previous case so P1 will get a chance earlier that is the point I'm trying to make here P1 will get a chance earlier here P1 will get a chance later here P1 will get a chance exactly after T I hope now the point is clear okay so this I have mentioned so this was a fantastic question let us learn about A New Concept that is response time time of admitting the request to the time of generating its result there the one thing is missing that is first result and it is not end yes the right is correct so you may think response time as the turnaround time it is somewhat similar to turnaround time in turnaround time what we used to say completion time minus arrival time the time when the process was admitted in the ricq till the time the process ended that time was the turnaround time but here one thing got changed that is time of admitting the request to the Rue till the time of generating its first result so when the process will complete for the first time that time minus arrival time will be the response time let's take an example suppose there's a process P1 which arrived in the ricu OR got admitted at the time let's say 4 so at Time 4 it was let's say sheduled or let's say it has to wait for 6 unit so at time 10 it was scheduled and it is a bust time of total 20 so it has run for 5 minutes of time so from 10 to 15 it has run now the remaining ver time is 15 so the time when it was admitted in the process till the time it has generated its first result that is the response time I hope you have got the idea now so let me clarify again the difference between turnaround time and response time so the turnaround time was that was the total time taken to execute a process starting from the moment till it enter the system until it completes the execution and exits the system the formula of turnaround time was completion time minus arrival time I hope you remember that now what is response time response time is the time taken from a from response time is the time taken from when a request was submitted until the first response was produced so this time was the response time when the request was taken until the first response was produced okay so the formula of response time will be first response time minus arrival time I hope now you have the clear idea of what is a response time let's solve a question on this then we will end our lecture consider a system using round dring scheduling with 10 process all arriving at Time Zero each process is associated with 20 identical request each process request consumes 20 millisecond of CPU time after which it spends 10 m milliseconds time on iO thereafter initiate subsequent request assume scheduling CPU scheduling overhead of 2 millisecond and time Quantum of 20 calculate the response time of first request of the first process easy question I have told you definition try to solve on your own just give it a try okay let's see the solution so what was given in the question each process was present in the radue at time zero and there are 10 processes each process has identical request 20 identical requests each process each process I has a 20 identical request and each request takes 20 milliseconds of CPU and 10 milliseconds of IO and the time Quantum is 20 the scheding over overhead is two now the question is asked as response time of first request of the first process so what we do in such type of question nothing the approach one is create G chart and we will automatically know what we have to do so we'll do the scheduling so what P11 represent it represent the first request of the first process so P11 represent the first request of the first process so P1 will be scheduled two unit taken by dispatcher and 20 as the bus time and the time Quantum is also 20 so it's a good coincidence so from 2 to 22 P1 will run P11 will run and for 10 seconds or milliseconds whatever be the unit 10 milliseconds it will go for iio at time 32 it will go again at here so this will be the this will be the second request of the process one how many pro how many requests are there 20 requests are there how many process are there 10 process are there so I hope you got the point at this time P11 left the CPU for 10 units it was in the io and then at time 32 the second request of process one enters the ricu Okay so what is the response time of first request of the first process so the time when it was admitted till the time it has generated its first result that is from 22 to 0 that is the 22 millisecond will be the answer now the another question is calculate the response time of first request of the last process first request of the last process response time of first request of the last process what is the last process P1 is the last process so P10 is the last process when was P10 admitted the first request of P10 that is p101 when it was admitted they all were admitted at Time Zero when it got completed it got completed at time 220 so from 0 to 220 this will be the response time so 220 will be the answer question number three response time of subsequent request of any process in these type of question just take the process one so what will the response time of subsequent request which means the request number two so the response time of request number two that is p12 will be the time at which it was admitted till the time at which it was completed so it were admitted at time 32 we have seen here and when it will be completed it will be complet at time 242 so the response time will be result minus admission that is 242 32 which will give 210 as the answer so this was also a good question in lectures we have taken questions which is handpicked by me these are all questions which will give you a new a new thinking okay so now our response time topic is over round robin topic is over in the next lecture we'll start with the multilevel CU congratulations we are at the last lecture of CPU scheduling we will start with the multilevel queue and after this the CPU scheduling will be complete I have something to tell you that in CPU scheding section we have solved enough numericals so I don't think there is a separate problem solving session for each algorithm so even though I will give you a dppp with detailed answers so you can try them on your own and one thing I was planning I should make a revision video of whatever we have done till now let's revise them in let's say an half an hour we make a revision video okay so let's start with the multilevel Q scheduling all algorithm which we have read till now was based on the single ricq system isn't it fantastic whatever algorithm which we have read till now was based on single ricu system so every kind of process every type of process was fit in a single ricu whether it was OS process background process foreground process a user process every process was in a single ricu system and for every kind of process we can apply only a single scheduling technique could it be possible that for OS process we can apply first come first serve and for user process we can apply round robin algorithm no it was not possible until the multilevel ricu came so what were the drawbacks of single ricu system there are different type of process all mixed up and placed in a single ricu so the different process are os process user process user process include interactive process foreground process background process so when all these process are mixed up and placed in a single Rue the searching time and filtering time of these process will be high if I want to search a single process let's say a foreground process then in a single ricu where all these process are mixed up the searching time and filtering time will be high each process is bound to follow a single scheduling technique which I have discussed earlier so what is the solution for this multiple rues so what we will do we will create multiple ricu like system process interactive process interactive editing process badge process student process so these are the different ricu for different type of process this is the ricu for least priority process and this is the ricu for highest priority process so different radices for different type of process now what happens different scheduling algorithm can be applied to different Q let's say I decide to apply fcfs here and apply round robin here can it be done yes it is possible but in the case of single ricq it was not possible so Q's are now divided in the the based off priorities the higher priority process should be scheduled first and then only lower priority process can be scheduled do you know what I'm talking about it the higher priority process should be scheduled first and then only the lower priority process can be scheduled can youer what I'm about to say let's say there's a process P1 in the student process so this P1 can only be scheduled when this process when this Rue this Rue this radue and this ricq all are empty then only P1 will be scheduled let's say there's a process named PX this PX can only be scheduled when this and this rues are empty so to schedule this to schedule this these three should be these three higher priority CU should be empty because the higher priority Pro higher priority process should be scheduled first then only lower priority process can be scheduled so this is a problem man this student process will start so what could be done star of the process lying on the low level what could be done the solution is multilevel Q scheduling so what we will do see we will penalize the process that have been running longer we will penalize them we will put that process in the lower CU suppose the the process in the ricq one it is already ran for let's say some four units of time now what we will do we will shift that process from this queue to this queue we will decrease its priority so what we will do we will penalize the process penalize it in what terms in terms of priority so we'll decrease the priority of those process which have been running longer so what we will do let's say this was ricu Zero at the top top level this process was admitted dispatched it has run for time Quantum of three but it has not completed so we will transfer it to the RQ one that is of lower priority we will increase the time Quantum time Quantum is equals to 5 now it has gone to CPU again it was not completed so we will move to the ricq 2 which means we will decrease the priority we will penalize them for the those process which have been running longer now you may have a doubt so how can be three CPUs no it's not 3 CPU it's just a representation it is one okay so the process which have been running longer will keep on decreasing the priority when the process is transfer from readyq 0 to RQ 1 we will not schedule the process immediately we will wait until the first que becomes empty so I've already told you the student process will only be scheduled when these four process are EMP when these four ricu are empty there is no process in these ricu then only this ricu process will be scheduled so when the process is transferred we will not schedule that immediately we'll wait until the upper cubes become empty so let's solve a question on this consider a system which is a CPU bond process CPU bond process means which is no IO which require the burst time of 80 Seconds the multilevel feedback you why we say feedback feedback feedback that's why we say feedback the multi level feedback Q scheduling algorithm is used and the Q time Quantum is 4 second time Quantum is 4 second and in each level It Is incremented by 10 second I have said we'll increase the time Quantum so here the time Quantum is incremented by 10 seconds how many times the process will be interrupted or preempted how many times the process will be preempted on which Q the process will terminate its execution so it's it's an easy problem so time Quantum was 80 this is a longer process it started its execution from q1 so at q1 the first the time Quantum was four so it will execute for four units of time and the remaining bus time will be 76 it will be feeded back to the RQ 2 which is of lower priority it has a Time Quantum of 14 we have said that time Quantum will increment by 10 seconds so 4 to 14 now it will run for 14 minutes of time and then it will be preempted what is 76 14 that is 62 so 62 will be preempted to this now 10 unit will be increased more 62 24 what will be the answer 38 38 will be preed to this 38 34 will again increase 10 34 will be preempted to this this no not 34 38 34 is 4 so 4 will be preempted to this and 44 4 will be as only four the time Quantum is 44 and the remaining best time is only four so it will complete here okay so at which queue it got completed 1 2 3 4 and F on Fifth Q it was completed and how many times it was interrupted 1 2 3 4 it was not interrupted here it got completed so for four times it got interrupted and it completed at the fifth que so this was an easy concept of multilevel Q scheduling at this moment or CPU scheding lecture is completely over congratulations hello welcome to the new section process synchronization and coordination this is lecture one we we going to learn about how process communicates interprocess communication and processing synchronization what is synchronization and what is its need so let me give you in introduction about the section this section is different from CPU scheduling that was numerically oriented and this section is logical and is reasoning oriented you have to focus while learning okay it is not hard but you need to focus okay it is logical so let's start what is IPC IPC is interprocess communication so let's talk generally there are two entities person one and person two let let's put it here person one with a mobile and person two with a mobile and they wish to communicate in this world when two entities wish to communicate there should be a shared media in between there should be a shared media and that shared media should be accessible to both it could be Hardware or software Hardware include wire cables wireless and software include protocols so my main point is if two entities wish to communicate there should be a shared media and that shared media should be accessible to both that I want to explain in the same way if two process wish to communicate there should be a shared media too it could be a file so a file in memory is known as pipe okay so what is pipe pipe is equivalent of file in hard disk so this shared media is known as IPC mechanism interprocess communication mechanism it could be a simple Global variable so what you have to remember if two process wish to communicate there should be a shared media there should be a shared media okay and this communication can be intra process too suppose in a process if two entities wish to communicate what what can be these two entities these two entity can be function so if these two entities wish to communicate there should be a common thing too there should be a shared thing too so let's uh let me recall you some of the C Concepts how can two functions in a program communicate by parameter passing and Global variables here you can also see shared thing okay so whatever I I have spoken till now you have to remember just a single line if two entities wish to communicate there should be a shared media that's it okay now let's talk about processes so the process are of two type independent and coordinating as the name suggest as the name suggest independent means no communication between the processes and coordinating means they cooperate they communicate okay communication happens so these are the type of processes okay now let's move to the main part that is synchronization what is synchronization you have heard about it so many times what is synchronization let me explain you in layman terms synchronization is nothing but doing something that is agreed or performing that is already decided that is synchronization okay so what problems arises due to the lack of synchronization let's discuss them one by one so in IPC environment lack of synchronization lead to the following problem the first one is inconsistency how inconsistency is generated we commonly call it as race problem to process race to update a common variable and they produce an unexpected result or they produce an incorrect result or wrong result that is inconsistency okay data loss as the name suggest and the third is deadlock what is deadlock or lock up deadlock is waiting for something that is never going to happen deadlock is waiting for something that is never ever going to happen we also call it as infinite blocking of the processes suppose uh the traffic got accumulated from all the four sides now this part of traffic expecting these three of them to back off and this part is expecting these three of them to back off so in this biger ring they all get stuck at the same place and none of them is ready to move back so this part this this situation is known as dead Lock they got logged up for infinite time and Deadlock is the most undesirable situation because processes not only get blocked but they also hold up the resources so that's why that's why we need synchronization synchronization is very much essential okay so let me explain you synchronization with the help of some examples so what is synchronization agreement or understanding between the entities let's take the example number one sharing a lawn among neighbors so these are the two neighbors H1 and H2 H1 is the house owner of house one and H2 is the house own of house to they have pets H1 has cat and H2 has a dog now there should be an agreement regarding the timing of lawn uses otherwise you know the consequences this could release cat and this could release the dog and you know what will happen so there should be a agreement regarding the timing so let's say they decide that the morning session will be for the cat and evening will be for the dog so this agreement is known as synchronization and and these two follows the agreement then they are in the syn okay let's discuss another problem more milk problem I hope you know what is PG paying guest so let's say in a hostel there are three paying guests P1 P2 and P3 okay so they have an agreement what is agreement if any one of us notices that that there is no milk in the fridge he should go out and buy so this fellow came come to the fridge and he notices that there is no milk in the fridge he goes out when he was out another fellow comes he notices that there is no milk in the fridge he also goes out he also do the same thing so they all are out at the same time and they all of them bring milk for each other also so what will be the problem all of them notice one by one and goes out to buy milk so what will be the problem more milk problem so what is the solution solution will be past it note suppose he goes out he paste a note that I'm going out and when these two will come and see that there is no milk in the fridge but P1 has go P1 has gone out to buy some milk so they will stay and wait for him so this could lead to a solution so what I'm basically trying you to explain is what is synchronization let's understand it formally now so process synchronization refers to the coordination and control of the concurrent process why concurrent process because if the process are not concurrent suppose P1 is uh performing its action at 8 a.m. let's let's just take an example and P2 is performing its uh actions on let's say 12 p.m. so they are working on different times so they are not concurrent so what will be the need of synchronization synchronization is only needed when the process are working together control of the concurrent process in computer system so that they execute properly without interfering with each other it involves methods and mechanism to manage to access to manage access to the shared resources such as data device or in that example loan loan was the shared resource preventing conflicts ensuring orderly execution what is orderly execution so in the morning session cat will come and in evening section dog will come so that is the orderly execution so let's discuss again what is process synchronization agreed upon protocol in IPC environment V process work according to the agreed upon protocol that is synchronization to avoid inconsistency data loss and Deadlock Okay so P1 and P2 they are having some shared resources which is accessible to both and there exist an agreement protocol between them for synchronization let's let's take an example this is process one that is the track one and this is process two that is the track two now there exist a shared resource there exist a shared resource so there should be a protocol for the uses of this shared resource by both of the process otherwise the you know the consequences that could be catastrophic if both the trains come from here at the same time let's take another example suppose this is device one device two they both issues a command for printing the file at the same time so what will happen may result print of two different PDFs at the same page okay so these are the problem that could arise if the process lacks synchronization so what could be solution for this problem let's talk about generally what could be solution depending upon whether the printed is already printer is already begin used by another process or not the operating system must decide whether to Grant the printing request if the printer is free or to deny the request and classify the process as waiting process until the printers available becomes available so this gives the command this also gives the command so operating system will decide you wait I will first print the file of this computer and then I will come to you so this is a general solution okay I hope you all know now let's talk about the type of synchronization what are the two types of synchronization listen this synchronization thing only happens when the process communicates so in independent process there is no need of synchronization synchronization is only needed in coordinating process when communication happens so there are two type of synchronization competitive and and the second one is cooperative so as the name suggest what is competitive process compete for the accessibility of a shared resource process compete and what is cooperative execution of one process affects the another that is dependency so I hope you are craving for an example of both weit for Cooperative process there is a famous example that is producer consumer problem I hope you have heard it before if you have read operating system already this is a very famous problem and we are going to look for its solution in many different ways let's first talk about the competitive synchronization for the Amazon sale there's an single iPhone piece available that is that is available at at a great discount so all of three buy to wants to buy an iPhone for a single piece of iPhone listed on Amazon at the same time so these three are competiting these are these are in competition for this iPhone so this is an example of competition let's take another example in terms of process so this is P1 and this is P2 and this is a shared variable that is variable C so P1 wants to increment the value of C that's C = to C + 1 and P2 wants to decrement the value of C that is C minus minus so what will be the expected result so the expected result will be uh first P1 increments that is 5 + 1 6 and P2 decrements that is five so the expected result is five but there are some cases when we get the result either six or four this could also possible that we can get result either six or four so this is the example of competitive synchronization example four people trying to book a single seat in a train that is example of competitive synchronization okay let's understand the producer consumer problem so there is a producer which produce an item and there is a consumer which consumes an item what item a data item okay so what does producer do producer attempts to place the data item onto buffer and consumer attempts to consume the data item from buffer so what does producer do it it produces and what does Consumer do it consumes but there is a catch they attempts why attempts because the buffer is bounded so if the buffer is full then producer cannot place the item into to the buffer and if the buffer is empty consumer cannot consume that's why I used the word attempts okay so let's say producer produces X and then producer produces y now producer want to produce Zed what is what is this this is a variable which has a data type of integer and what does it what does it store it stores the value of next empty slot firstly when these two were there the next empty slot was two and when producer produces this data item Z then the next empty slot becomes three so this will update the value three these are the slots I hope you know so this is the producer consumer problem so what will the what will be the condition if the buffer is full producer cannot produce and if the B is empty consumer cannot consume so this is an example of cooperating processes P1 that is process producer process and consumer process they are cooperating because the actions of one affects the actions of the other that's why they are in the cooperation and this example which we have seen that three people are trying to buy a single piece of iPhone present in the Amazon sale or two process want to update the value of of a shared variable at the same time or four people trying to book a single seat in a train that is example of competitive synchronization and this is an example of Cooperative synchronization when actions of the world affect the actions of the other okay so if the synchronization is competitive then what does the lack of synchronization causes is it causes inconsistency and data loss in case of Cooperative it causes data lock so can data lock arise in in this producer and consumer problem we will see later okay and there there is another note what does it say an application in IPC environment may involve either cooperation competition or both so later we will see that producer consumer problem is an example of both competitive and and Co Cooperative how competitive we'll see it later when we'll see the code the C code okay so what we have learned in this whole lecture we have learned that for communication there need a shared resource and that shared resource should be accessible to the both entities okay and process are of two type independent and coordinating independent process do not communicate hence they do not require synchronization coordinating process communicates hence they require synchronization and what does the lack of synchronization causes inconsistency that is wrong results data loss and Deadlock we learned a new term that is deadlock what is deadlock waiting for an event that is never going to happen we have seen some examples that is sharing a laan m Mill problem and we have also learned a formal definition of process synchronization okay and then in the end we learn learned what is competitive and Cooperative synchronization we have seen some examples and we also learned that application in an IPC can involve either cooperation or competition or both let's start lecture two in this lecture we will see a famous condition known as race condition in the last lecture we have studed about synchronization what is the need of synchronization how process communicate we learned about IPC its mechanism shared media and stuff in this lecture we'll start with the race condition so there are two process P1 and P2 and they are in a race they are in a competition to update the value of a shared variable let's say C P1 wants to increment it and P2 wants to decrement it so what will be the high level code it could be Cal to C + 1 and the low level and the high level code for decrement will be Cal to cus1 and what will be the low LEL code corresponding to them the low level will be this so this will the low level will be generated by compiler that is the assembly code so the three instructions are there and they will be executed sequentially so what we will do we'll first load the value of C into register R1 we'll increment the value of register R1 and we will store the value of R1 back to C so this is how it will be executed at low level similarly for decrement the value of C that is the memory will be loaded into register R2 it will be decremented and the decremented value will be stored back to the memory so C is a memory okay this part till this part whatever computation is being done it is being done in the register at part I3 it changes the value at memory remember this till this part whatever being done whatever competition is being done is done at register level the final value of register is not stored until instruction three at instruction 3 the value of C is changed okay so now how we can get the result 6 or four when the expected result is five this is inconsistency so how inconsistency happen let's see suppose consider this scenario in RQ there are two process available P1 and P2 at time t CPU scheder decide let's schedule P1 first so P1 will be scheduled now before going ahead I want to share a universal assumption that in user process they can get preempted after any instruction this user process can be preempted even before executing instruction one it could be preempted after execut instruction one before I2 it could be preempted here it could be preempted here any anywhere it could be preempted anywhere here so user process can be preempted anytime anywhere after any instruction you have to take into account this assumption so P1 ver first scheduled what happens P1 executes instruction i1 and I2 what will P1 do P1 loads the value of register of memory P1 loads the value from memory into register that is value five and it will increment it so the value of R1 is 5 instruction I2 okay let's go back so what it will do it will first load the value of C into R1 and it's incremented so what will the value of R1 now the value of R1 is six okay this part is represented like this i1 and I2 that is the R1 is now have value six at this point it got preempted it it got preempted at this point I have said user process can be preempted at any time so user process gets preempted here so P1 gets preempted here so P represents preempted now it's time for P2 because CPU can't be added so P2 will be brought from ricq to the CPU and P1 which was which was previously in the CPU will be sent back to the ricq because it has its instruction remaining to be executed so at time T1 let's say at another time P2 will start executing its instructions so P2 will execute i1 I2 and I3 so it has executed all of three so let's go back so what it will do it will first load the value of C into R2 it has decremented the value and it has again loaded the value of C of R2 into C that is it has made the final changes it has made the final changes because it has also executed its instruction three it has first loaded the value it has first loaded the value into R2 the value of C was five so five has loaded it has decremented the value now the value of al2 is four and and it has loaded the value of R2 back into the C so it has stored the value of R2 into C see the instruction I3 okay so the third instruction is the instruction in which final changes has been made this was remaining okay now P2 has completed all its instructions so it will leave the CPU it's turned for P1 to come back so now P1 will come back and I have I have told you several times that when a process comes back from ricu to the CPU it will resume it will not restart so it will resume from instruction I3 where it got preempted so what is instruction I3 making the final changes again what is instruction I3 is storing the value of R1 what is the value of R1 the value of R1 was six so it will store the value of R1 that is 6 back into C now what is the final value the final value is six and what was the expected value the expected value should be five because P1 increments and P2 decrements so the result should be unchanged so it should be five but what we got we got six this is inconsistency this is race condition P1 and P2 are not in synchronization so this type of problem are caused now we have got value six but can we got value four yes the thing is opposite there are two ways to get four so the first is do the same same thing in opposite fashion start with the P2 first preempt here complete the instruction of P1 and when P2 comes back make the final changes again store the value of R2 into the C that was four okay another way is another way is at time T1 so this was the time at time T P1 executed instruction i1 and I2 and it got preempted so the first case this this and that preempted now what is the what is the scenario R1 has the value of six the value of C is still five because no final changes has been made because it got preempted before final changes now what happens at time T1 P2 also gets preempted here P2 executes these two instruction and get preempted now in Ru there are two process now in readyq there are two process P1 and P2 ready to make the final changes now it depends now it depends if P1 make the changes first let's say P1 make the changes first and then P2 make the changes that is four so the final fin changes the final answer will be four case two P2 make the changes first the value of C will be four and now P1 comes so it will change back to six so the value of C can be either six or can be either four depending which process updates or make the final changes first so what was expected the expected value was what was expected the expected value was five but what we got we got either six or four depending which process updates first so this is raise condition I so this is an important point I should I felt that I should write it in the notes whenever a process comes back to the CPU it will resume not restart so this above scenario is a clear demonstration of inconsistency the process to update last will win then what is the solution is it ever possible to get a correct value is it possible if yes then in which scenario the answer is when there is no preemption when there is no preemption what P1 does P1 executes all these three instruction and then when it gets completed it leaves the CPU and then P2 comes it executes all these three instructions so what happens let's see P1 executes all these three instructions so what happens this is the value of R1 this is the value of C that is five first load the value of C into R1 so value of C will be loaded into R1 c will be loaded into R1 that is 5 now what happens increment R1 let's increment R1 let's make it six now store the value of R1 back into the C store the value of R1 back into the C now the value will be six now the value of C will be six okay P1 has executed all its instruction now it's chance for P2 to execute P2 will come load the value of R2 into C sorry load the value of C into R2 the one which is written later that value will be loaded into the thing which is written before see if we have to store we will write R2 later if we have to load we will write R2 first okay so value of C will be loaded into R2 so what is the value of C 6 6 will be loaded into R2 what are decrement R2 so five will be the value store the value of R2 back into C so now the value will be five finally the value is five so this is the expected value this is the correct result when we got correct result when there is no preemption when we executed either P1 first and then P2 or either P2 first and then P1 in both cases we will get correct result but if any of the process get preempted in between then it causes inconsistency so here I have written so when there is no preemption then we will get correct result but as an end user see as an end user we want a solution that always give me correct result why I should bother let's say let's say there is a there's a children 5yearold children wants to play a game in a in a smartphone but it has got some problem problem because of risk condition why should the end user a 5yearold give about whether a process gets preempted or not he wants a correct solution every time he wants a correct result every time whether preemption takes place or not I do not I do not bother whether preemption happens or not as an end user I want correct solution let's start with the implementation of producer consumer problem there are two processes a producer process and a consumer process producer process produces an item and place the item into through the bounded buffer why bounded bounded means a fixed size so the size will be n and the index will be from 0 to n minus one I hope this is clear so process P that is the producer process is going to produce an item and place it onto the bounded buffer and what will consumer do it is going to consume an item from the bounded buffer producer produces consumer consumes as simple now now there are two pointers pointer in and pointer out pointer in refers to the pointer of next empty slot what is the next empty slot here two and out refers to the first filled slot what is the first filled slot you can see Zero that is X now producer produces and place it onto the buffer in I hope I'm making sense because this is the next empty slot producer will see the next empty slot and will place an item onto the bounded buffer what from where the consumer consumes it consumes the from buffer out what is out the first filled slot now let's move to the code part we are defining a global variable n what is n the size of the bounded buffer let's say it is 100 now we are also defining a variable named count it is also a global variable count what does count refer to it refers to the number of data items in the buffer if a producer produce and place the data item in the buffer the count will increase and if a consumer will consume then the count will decrease we are also defining a bounded buffer of size n so it's an array of integer type buffer n now we are going to write the producer and the consumer code so what are the major changes that we are going to make when a producer produce and when a consumer consumes let's discuss them so we are first going to check a producer produce only when the bounded buffer is not full and a consumer consume only when the bounded buffer is not empty okay so what will producer do first it will produce and place the item in a variable named item P let's say the produced item item P let me write item P so the producer produced and placed the item in this variable item P now we have to place the item p in the buffer where we will place we will place at buffer in so we'll play place it as buffer in okay but these all will only happen when the bounded buffer is speak after me bounded buffer is not full so if the bounded buffer is full what we have to do we have to make the producer busy weight until the consumer consumes and make a space for the item to be placed into the bounded buffer okay so when the item will be placed in the buffer in then we have to increase the value of count two so we will do count Plus+ also so let's see in the code so what we will do we will produce and place the item into the variable named item P so what will produce item do let's say the produce item is a function in a library already present produced item is placed in the variable item P okay now we will check we will check whether the bounded buffer is full or not so we will use while count equals to equals to n we will check whether count count equals to equals to n whether count is equals to n or I can directly say if the bounded buff is full then the producer cannot produce and place the atom it it may produce the producer May produce but it cannot place so it may produce but it cannot place so it has to first check whether the bounded buffer is full or not if full then it will wait until preemption happens and consumer takes the control and it consumes an item and makees space for the producer to place the item so producer May produce but it cannot place before checking so we'll first check we'll first check so the busy waiting thing will happen what is busy waiting busy waiting is testing the condition again and again and what is waiting for what it is waiting for to proceed further okay so let me speak again producer will produce and place the item into the variable item P now it is in the variable item P it is not in the buffer so before place before placing into the buffer we have to first check so we checked and it is not full it has some space available it will go down buffer in equals to item P we will place the item P what is item P item p is containing the produced item so we will place the item P into the in what is in the next empty slot so we plac item P into the buffer in now we have to increase the value of n because now the next empty slot will be the next one let's let's take this case what is the next empty slot two if the producer Place item let's say Z Now the next empty slot will be three so we have to increase the value of in also what does this circular thing say let's say the last here it is produced so it will go back and produce that and place the item at index 0o if the last item was at n minus one it will go back and place the item at zero I hope this point is clear this thing is for the circular and count Plus+ because item is placed into the buffer so the number of item will be increased so this was the code for producer item so for the producer now I am giving you a challenge to write the code for the consumer what changes you have to think about it so for Consumer the consumer consumes when the consumer can consume it can consume only when it can consume only when there exists some item into the buffer when the buffer is nonempty okay let's say the buffer is non empty what changes you have to make you have to make you have to decrease the value of count because the consumer has consumed an item you have to increase the value of out because what does out signify first filled slot let's say consumer had consumed this now the first filled slot is this one that is one so we have to increase the value of out two same same case for the last thing suppose consumer consume from this part now from where the next time consumer will consume from this so it has to go back so for circular thing will be out equals to out + 1 modul n okay so let's see the consumer code vo consumer void now item C item c will be the item C represents the consumed item the item which is going to be consumed so before anything before making changes before any change making we have to check whether the whether the bounded buffer is empty or not if the bounded buffer is empty busy wait until the producer produce and place an item into the buffer then item c will be representing the item that is going to be consumed so which item is going to be consumed buffer out now we have to increase the value of out decrease the value of count and consume the item in the end see see there is a thing in consumer the condition was at the top while in producer the condition was at the second statement at B why why this is so because a producer can produce but it cannot place so this represent a producer can produce but it cannot place before placing it has to check the condition no statement can be made before checking if the bounded buffer is empty none of these changes will be made I hope I am clear so this was the all the implementation of producer and consumer in C language in the last lecture we discussed about the producer and consumer problem implementation so we are going to see some more points on that so the producer and consumer problem are involved in Cooperative synchronization why because they are getting affected by each other now this this point you all know but there is some special point that this case of producer and consumer problem is involved in both competitive and Cooperative synchronization how competitive uh let me tell you see if you carefully watch the uh if you carefully observe the code then you can see there is a shared variable count there's a shared variable count so let's say this is the producer code this is the consumer code the producer executes these four instruction and get preempted here and the consumer execute these three instruction get preempted here just before updating the value of count because they are user process and user process can be preempted anywhere at any time so they got preed here there this part and this part they get preed just before updating the value of now this is the situation producer and consumer process are in the ricq waiting to update the value of count okay so this situation this situation if you recall is exactly similar to our previous problem that causes inconsistency what was the previous problem the race condition so these producer and consumer are in a race to update the value of Shield variable count okay so let let me recall you there are two process producer and consumer producer want to increase the value of count consumer want to decrease the value of count let's say the initial value of count is five now the expected expected results are six and uh expected result is five but what we can get we can get six and four depending on which process updates the value of count at last the one which update first loses and the one which updated to the last that value of count will be the final value of count so this I have already discussed before in our previous lecture what point I'm here to make that producer and consumer is a case in which a process or the processes are involved in a cooperative and competitive synchronization both okay I hope the point is clear so to solve this problem we are going to need a synchronization tool a synchronization tool so that synchronization tool we are going to see in the next lecture in the previous lecture we saw that we need a synchronization tool to avoid some problems in this lecture we are going to explore more suppose uh let's talk about a disease named malaria I hope you have heard about it so what is the necessary condition for malaria to spread in a Lo in a locality so the necessary condition is stagnant water if a stagnant water is not present so mosquito larva won't breed there and mosquitoes won't be there so the main culprit that is the mosquito would not be present in that locality so chances of malaria spreading is very less so stagnant water mosquitoes the main culprit should be there and unhygienic environment so these are the necessary condition for malaria to spread in a locality let's talk about the synchronization problem so this was a problem these are the necessary condition this is the problem let's talk about the synchronization problems necessary condition condition so the first condition is critical section there should be a shared resource if there is no shared resource there won't be any synchronization problem we have discussed it earlier also okay so what is critical section the part of a program where shared resources are accessed the part of a program where shared resources are accessed okay so let's say this is a program it consists of two things noncritical section and critical section noncritical section consist of local variables which belong to that process only and critical section consist of those variables which belongs to both the processes let's say two process are there want to communicate so critical section is the section which has shared variable let's talk here uh in the case of producer consumer problem let's say item P equals to produce item this is a noncritical section because item P or produce item this belongs only to the producer process while this count this n this buffer this count again this and this belongs to both the processes producer and consumer they can be they are accessible to both the process so this is the critical section see remember the first class of Process Management I have said that not Process Management process synchronization I have said that for communication to happen between two entities there should be a shared media and that shared media should be accessible to both that's the same thing okay so that shared media is known as critical section so for synchronization problem there must present a critical section and the second condition is raise condition say if the processes are not in rise to update a update a shared variable let's say count if producer and consumer are not in Risk to update the value of count then there will be no problem for synchronization problem to occur what are the necessary condition the first is that there should be some shared variable there should be critical section and the second is for that shared variable processes should be in race to update the value okay so the race condition is necessary situation where the process are trying to access critical section and final result depends on the order they finish their update now here like malaria for the case of malaria stagnant water and unhygienic environment is similar as critical section and race condition but the main culprate is still missing can you guess the name of main culprit think yes the the main culprit is preemption which type of preemption premature preemption let let's let's see the situation so here are the critical section P1 enters the critical section P1 was still executing the instructions of the critical section but it got preempted prematurely now P2 wants to enter critical section P2 will enter and that causes problem so the premature preemption when a process has not completed the all this all its instructions in the critical section but it got preempted prematurely and some another process enters critical section that causes problem so what is the main culprit here preemption and which type of preemption premature preemption okay so we need some solution uh to solve all these problems so the solution is we need some synchronization mechanism or let's say security guard so can you guess the purpose of the security guard see the problem arise when two or more process enters critical section when two or more process are in the critical section see critical section and CPU are different things let's say here is the CPU these process are present in the ricu okay now P1 is in the CPU now P1 is in the CPU P1 started executing its instruction the critical section let's in between it got preempted P1 is still in the critical section this is the uh denot we denote it like that that P1 has not completed all its instruction from the critical section P1 got removed from the CPU it went back to the RQ now P2 enters P2 enters okay so P2 is in the CPU started executing instructions want to enter the critical section but P1 has its unfinished work in the critical section so it's still lying there not executing any instructions further because it is not present in the CPU P2 is there so it's still lying there now the problem arise when P2 enters critical section 2 so this is the problem so we need to solve this problem using a security guard so can you guess the purpose of security guard yes you guessed correctly security guard will allow only one process enter at a time in the critical section let's say P1 get preempted in between let's say p P2 has P2 is in the CPU now security guard will prevent P2 entering the critical section P2 cannot enter critical section security guard will prevent it okay let's say P2 got preed again and P1 get the chance P1 is present in the CPU now P1 resumed its instruction completed critical section get over got terminated now when P2 comes it is allowed to enter critic iCal section okay so this is the purpose of security guard not only this not only this security guard also notifies other processes when a process or the previously running process in the critical section has completed its instructions let's say P1 has completed its instruction so the security guard will notify other processes hey critical section is empty now you can go any one of you can go okay so there are two purposes of security first is and we have divided security guard in two entry section and exit section entry section will allow out of these three process only one to enter critical section and exit section what's the purpose of exit section it will notifies other process that the previously running process in the critical section has completed its instruction now any one of you can go now in the critical section I hope I'm clear uh let's see again here so P1 p P3 want to enter critical section so there comes the enter section first which allows only one process to access critical section let's say P1 entered P1 completed its instruction went to the exit section this exit section notifies other process P2 and P3 that critical section is empty now okay so when process exits the critical section it notifies the other processes so how this synchronization mechanism looks like first comes the noncritical section or the section which does not have any shared resource for critical section that is this is critical so we need some security guard up and Below enter section and exit section then again comes the noncritical section so this is the this is the synchronization mechanism okay note what is the note process running in user mode can get preempted anywhere any number of times after completing any instruction so this is a kind of assumption we will take to solve synchronization problem what is the Assumption process running in user mode can get preempted anywhere after any instructions any number of times okay you have to remember this in the next lecture we will see the requirements of critical section problem here we have seen the necessary condition so what is the difference between necessary condition and requirements so necessary conditions are the conditions which are necessary for problem to happen like mosquitoes are necessary for malaria to spread and what are the requirement these are the requirement to be fulfilled to make sure the solution is correct okay so we will discuss them in the next lecture let's discuss the requirements of critical section problem these are the conditions that must be satisfied by synchronization mechanism to make sure the solution is correct and what was necessary condition these are the condition necessary to happen necessary for problem to happen Okay so let's discuss the requirements the first is Mutual exclusion what does this say that there should be only a single process in the critical section at a time no two process should be present in the critical section at the same time remember this line in any synchronization mechanism we discuss the first thing which we are going to check is this line is there any possibility that two process enter critical section at the same time if yes then the mutual exclusion is not guaranteed so what is mutual exclusion no to process should be present in critical section at the same time as this diagram depicts so a process is already present in the critical section uh another process enter this is wrong more processor enter this is wrong in this critical section only single process there and these all processes are out so this is good thing okay so only one rest are out so mutual exclusion is guaranteed so repeat after me what is mutual exclusion no go to process should be in the critical section at the same time okay let's discuss the second condition that is progress okay so what does progress mean that a process let's say P1 P2 and P3 these are the process P1 is not interested to enter critical section so it should not block the interested processes like P2 and P3 let me speak again noninterested process process or uninterested process should not block the entry of interested process this is the progress okay so P1 and P2 these two want to enter P3 is not interested so P3 has no right to block the progress of others uninterested process should not block the entry of interested process this is progress okay now the third part bounded waiting listen carefully P1 P2 P3 these are the three process wants to enter critical section P1 first uh goes to entry section allowed because no other process is present in the critical section vents to critical section comes out now it goes again it goes again joins the queue goes again enter enter the entry section goes to critical section again goes to exit section now this fellow joins again see P1 is laughing at the face of P2 and P3 that you fellows are waiting from so much time and whenever I come back I directly go to the critical section so you keep on waiting I will keep on going into the critical section P1 will laugh at the face of P2 and P3 so this is not correct P2 and P3 do not know for how much time they have to wait okay so this should not happen this should not happen this is not fair so this is the thing which I have represented P1 enters goes to critical section exits joins the que again enters again goes to critical section exits goes again enter this keep on happening and P2 and P3 are waiting so this these these two process P2 and P3 should not wait forever for their turn Okay so this is bounded waiting okay so let me erase all these things huh so I have written in form of statements no process has to wait to access critical section there should be a bound on number of times a process is allowed to enter critical section before other process request is granted let me uh revise all the requirements again the first was Mutual exclusion what does it say no two process should be allowed in the critical section at the same time What does progress say an uninterested process has no right to block the progress of other interested process and what does bounding waiting bounded waiting say no process has no process can enter critical section again in again while the other interested process are waiting forever okay so the weight should be bounded it should not be unbounded that they are starving for infinite time okay so these are the requirements if P2 and P3 are not interested then P1 should not be blocked otherwise progress will be violated if Mutual exclusion is not guaranteed then what problems that arise are inconsistency and loss of data if Mutual exclusion is not guaranteed two or more process can enter critical section and they will be in RIS condition then to update a value of count as we saw that let's say producer want to update the value of count by + one and consumer want to decrease the value of count by minus one and the initial value of Count by Five so the expected result was five but we got four or six so this uncon inconsistency happens due due to the reason that producer and consumer entered critical section at the same time so when Mutual exclusion is not guaranted inconsistency and loss of data happens what is inconsistency wrong results and this is selfexplanatory loss of data if bounded waiting is not guaranted then starvation P2 and P3 are starving here okay and if progress is not guaranted then then it is unfair solution indefinite postponement let's say P3 is not interested and it has also blocked the entry of P1 and P2 so this is unfair so we have completed the requirements in the next in the next lecture we are going to see some synchronization mechanisms or simply Solutions of these problems now comes the synchronization mechanisms I'm going to take the name of all synchronization mechanisms that we are going to study later so I should not say synchronization mechanisms are the solution these are just the tries we try to solve the problem okay so let me give an example uh busy waiting and non busy waiting and these are subcategorized into software hardware and OS based that you can all read lock variables and strict alternation are not solution so which synchronization mechanism I should categorize them as solution the one which guarantees Mutual exclusion the one which guarantees progress and bounded waiting if these three are satisfied by a Sol by a mechanism then I can categorize that mechanism as solution out of all these I cannot say all of them are solution let me give you an example see take these two log variable guarantees progress but it fails to guarantee Mutual exclusion and bounded waiting these two are not guaranted strict alternation is opposite it hinders progress but it guarantees Mutual exclusion and bounded waiting which loog variable was unable to give and loog variable was giving something which was not possible for strict alternation to give so why don't we merge the good qualities of both of them let me let me explain loog variable gives Mutual exclusion uh sorry log variables gives progress fails to give Mutual exclusion and bounded waiting strict alternation provides Mutual exclusion hinders progress and provides bounded waiting so why don't we mer mer the good qualities of them and create a perfect solution that is Peterson or ders algorithm so we cannot categorize lock variable and strict alternation as solution sometimes we say them as solution but they are not in literal terms what is solution solution is the one that satisfy all the requirement Mutual exclusion bounded waiting and progress lock variables and District alternation are not Solutions Peterson and deer algorithm solution okay but sometime sometimes we say lock variable as software solution we just say we doesn't mean that as actual solution okay so let me read so synchronization mechanisms are of two types bounded waiting and nons sorry busy waiting and non busy waiting busy waiting is also known as spin lock and non busy waiting is also known as blocking and these are subcategorized into software hardware and OS based software are user mode Hardware as special instructions and OS based or kernel mode so four these are the four type of software solution two types of Hardware solution TSL instruction and swap instruction and OS based are sleep and wake up semaphor and monitors I hope you have somewhere heard the name of semap for before okay so don't worry we are going to study them in detail in every case possible in each of the synchronization mechanisms we are going to solve lots of problem in these uh synchronization mechanisms and these problems will be logical okay so let's see some assumptions process enter critical section for finite amount of time this is the first assumption because if say the process enters critical section for infinite amount of time and we have also guaranteed its Mutual exclusion it will make other process starve because Mutual exclusion won't allow any other process to enter critical section and this process is not leaving the crital section so other process will Dive Dive because of die because of starvation so we have to assume that process enter critical section for a finite amount of time and come out of it it never gets stuck in the critical section this is the first assumption process can never get stuck in a critical section second thing is if a process is in entry section then it means it is interested in the critical section uh in the previous lecture I have discussed about process sorry progress what was progress an uninterested process should not block the entry of interested process now I should clarify what is interested process interested process the process who wants to enter critical section and if a process wants to enter critical section then only they will enter entry section otherwise they will never enter into entry section let me speak again if a process is interested in critical section or wants to go in critical section then only it will tries to to enter entry section otherwise it will not okay so this is the second assumptions we are taking the third is a process is said to have left the critical section only when it has executed its exit section and the fourth is a process can get preempted from CPU while executing either entry section or critical section or exit section a user process can get preempted anywhere after any instruction any number of time okay so let me read the assumptions again a process will never stuck in the critical section A process will enter into entry section only when it is inst interested in the critical section and the third is a process is said to have left critical section only when it has executed its exit section and the fourth is a process can get preempted from anywhere after any instruction any number of times let's discuss our first synchronization mechanism that is lock variable can you suggest something from the name lock variable a variable named lock which is used to represent whether critical section is free or in use it is a busy waiting solution I hope you all know what is busy waiting and it is a software solution do you remember the the types we discussed in the last lecture software solution Hardware solution operating system system and software solution are implementable at user mode Hardware Solutions are are special instructions and operating systems are based on kernel mode okay so it is a software solution so it is a way to say a solution it is not an actual solution okay I have discussed that thing in the last lecture we just say it as a solution but is not an actual solution it does not satisfy all the requirements to be a solution can you remember the requirements yes the requirements are it should guarantee Mutual exclusion it should guarantee progress and bounded waiting okay so let's see how does it work so in entry section we Define a variable named lock variable which can take two value either zero or one what does Z represent Z represent that critical section is free no process is in the critical section at the moment and what does one represent critical section is in use a process is already present in the critical section okay so let's say it is the beginning okay a process enters into entry section see that lock is zero that means critical section is free goes into critical section and changes the value of log to one it's it's similar as if uh there's a there's a room someone enters the room and lock it it from inside and when it is logged from inside if some other process see a room is logged from inside then it understands that someone is already present in the room so lock 0 or 1 0o means critical section is free and one means critical section is in use and what does exit exit section do when a man comes out of a room then what does it do it unlocks the room and goes out see it is similar like a like a bathroom situation or toilet situation whatever you call if a man enters into a toilet what does he do he locks it from inside suppose another man comes and see a toilet is locked from inside understand that someone is already present he will wait until the man unlocks and comes out okay same is the case Zero means critical section is free one means critical section is in use and when a process EX exits what does it do it changes the log to zero which says critical section is now free okay so this is the main idea of lock now let's see the implementation the entry section okay so we Define lock and we sets set it value initially to zero what does Z represent initially the critical section is free no one is in the toilet okay or any room let's say toilet if you feel it gross so let's take an example of a room so let's say in a room initially the room is open anyone can enter hence the lock is equals to zero void process in I so this is a process code now here it comes noncritical section and then the entry section while loog equals toal to 1 then busy weight what does this represent this represent busy weight it says if loog equals to 1 whether log is equals to 1 what does one say critical section is in use so it says if critical section is is in use check this condition again and again again and again and it busy weits busy in what checking the condition whether critical section is free or in use and waiting to proceed further okay so if critical section is in use it will busy weit and let's say critical section is not in use this is the initial case so loog is equals to0 while loog equals to equals to 1 no this is false it will go down lock equals to 1 it will change the value of lock equals to 1 and it will enters the critical section and when it has performed all the instructions of critical section the process intends to go out so before going out what does it do changes the value of lock equals to Zer it unlocks the room okay so I hope you got the idea just think think it it as a toilet or some room uh for um for couples to to go in okay so let's say process represent a couple I hope uh now you can get the idea let's say a process represent a couple a couple enters the room an open room uh and then locks the room from inside do whatever they want to do in the critical section and when they want to come out they will unlock the room for another couples I hope now you got the idea so what is the two things the couples do before entering into the room the first thing is the first thing is it will check it will check if someone is already present in the room if yes then they will wait busy wait if no they will enter lock the room perform whatever they want to perform and then they comes out by unlocking the room I hope you got the idea see this entry section is in the written in the high level code when it will be in the when it will pass to compiler it will be changed to low level code that is assembly good so what does it look like load the value of lock into some resistor RI compare the value of RI with zero jump if not zero to statement B again so this is busit and store the value of lock store the value of one constant one into lock do to get this is the same thing written here did you get it see lock the uh load the value of lock into RI let's say this is register RI and the value of lock was initial zero so this value will be loaded here compare RI with zero is the value of RI equals to Z yes it is equals to Z so what will it will do it will go to the next statement jump if not zero but it is zero so it will ignore this statement will go down store the value of constant 1 into the lock variable so now in lock in lock variable one will be stored now I hope you got the idea in the last that is exit section store the value of 0er into the loog what does this mean lock the room from inside what does this mean check if critical section is free and what does this mean unlock the room when you comes out in the last lecture we have seen the high level implementation and lowlevel implementation of lock variable let's understand from this diagram also there are two process P1 and P2 available in the ricq let's say P1 enters in the CPU P1 got scheduled on the CPU P1 shows interest to enter into critical section so what it has to do it has to enter into entry section first and what is entry section check if the value of log equals to 1 if not then change the value of lock equals to 1 so P1 enters P1 P1 want to enter critical section so it will check if the value of lock equals to one no the value of lock was zero so it will change the value of lock equals to 1 now P2 P1 is started executing there some instructions of the critical ction and suddenly premature preemption happens let's say P2 is a high priority process P2 comes here P2 comes in the CPU what it will do it has also interest to go into the critical section so it will go to the entry section first while value of lock equals to 1 yes the value of lock equals to 1 check the condition again does the value of lock equals to 1 yes check the condition again is log equals to one yes check the condition again so it will keep on checking the condition again and again it will busy wait until the time slice expires now the P2 got preempted from the CPU P1 got the chance again P1 was shed on the CPU P1 resumed P1 resumed completed its critical section when it got when it want to get out from the critical section it has to execute exit section and what does exit section say change the value of lock to zero now the value of loog is zero now P2 got chance P1 has P1 has been terminated now P2 got chance on the CPU again P2 will resume so P2 will check is the value of log equals to 1 so the value of loog loog is not equals to one the value of loog is zero so it will escape the busy V now it will change the value of loog equals to one so value of loog will be changed again to one goes into gral section complete the critical section and when it come comes out it will unlock the critical section so I hope you got the idea how does loog variable work so let me read it again when P1 was in the critical section lock variable will not allow P2 enter critical section so P2 will be busy waiting until P1 comes back exits critical section by updating the lock variable so I hope you understand how does log variable works so now I a question for you does this law guarantees Mutual exclusion every time is there any possibility that Mutual exclusion get violated is there any possibility that P1 and P2 gets into critical section at the same time think about it see the code and think about it is there any possibility that P1 and P2 enters the critical section at the same time what I'm about to say is a Golden Rule for solving questions like that whenever you see whenever you see an entry section of two statements preempt in between let me speak again whenever you see entry section of two statements preempt in between if you preempt in between of these two statements then you will get some uh good results to infer okay so we are going to do the same let's preempt in between so we have to preempt the process in such a manner that two process are in the critical section at the same time that is mutual exclusion is violated we try in such a way so how we can do that we will preempt between the two statements of Entry section so the first statement consist of these three instructions and the second consist of this one instruction so we try to preempt after this instruction let's go so here let me draw the value of lock R1 and R2 okay now store the value or load the value of lock into R1 so what is the initial value of log initially is zero initially is zero so we'll load that value into R1 now compare the value of R1 with 0o is it zero yes it is zero so it will go to the statement three jump if not zero but it is zero so it will not go anywhere it tries to go to statement 4 but what we have to do we have to preempt before it can execute the statement 4 so it got preempted before the process can change the value of lock now process two is in the CPU process two starts load the value of lock into R2 what is the value of lock it is zero load it into the R2 okay compare the value of R2 is the value of R2 equals to Z yes it is z jump if not zero to statement B but it is zero so it will not jump anywhere now it tries to go to store lock equals to 1 so you can see preempting P2 here will give us no benefit because let me explain more so now P2 has executed fourth statement also so you have to preempt just one process either P1 or P2 so we have preempted P1 so no need to preempt P2 P2 executed fourth instruction also that is store the value of one into the log so change the value 0 to 1 okay now what does loog equals to 1 represent loog equals to 1 represent that critical section is not free so P2 gets into critical section start executing critical section but what what happens premature preemption so we are preempting P2 here premature preemption happens P2 is in the critical section but it got preempted from the CPU now what will happen P1 will start its execution P1 will resume what P1 will do P1 will start from this instruction P1 will change the value of lock 1 to1 this instruction will executed what does this instruction say load the value or store the value of constant one into the lock so one will be stored into the lock now what we will do it will enter the critical section no one is going to stop P1 from entering the critical section so P1 will enter the critical section P2 was already present in the critical section this will cause inconsistency and loss of data so does lock guarantees Mutual exclusion every time no it doesn't guarantee Mutual exclusion if pre happens between the two statements of Entry section I hope you got the idea you want to read I have also written the numbers so first this will instruction this instruction will executed this one this one and then it will get preempted now what will happen P1 gets preempted P2 will start execution it loads the value of lock into R2 these things happens now it will change the value of lock from 0 to 1 starts execute using the instructions of critical section but it gets preempted in between now P2 gets in P1 gets into the CPU started from where it left store the value of loog equals to one loog was already one but it will change the value of lock equals to 1 now it will enter critical section is there anyone present to stop P1 from entering critical section given that P2 is already there in the critical section no one is there so P1 and P2 will be in the critical section at the same time this is a major reason for inconsistency Mutual exclusion is violated so both process are in critical section Mutual exclusion is violated is progress guaranteed can a noninterested process prevent interested process from going into the critical section no see I have explained you an assumption I think the Assumption number two it was that if a process is uninterested in critical section it will never ever enter the entry section and if a uninterested process never enters the entry section how can it change the value of lock equals to 1 can an uninterested couple go inside and lock lock them themselves in the room so that other couples do not enter no this not happen that this does not happen so in the same way a process will not go into the intersection even if it is uninterested to go to critical section and lock the critical section this will not do this this won't be done by any process who is uninterested so can a noninterested process prevent interested process process prevent the interested process from going to the critical section no this doesn't happen so yes progress is guaranteed okay so I have also explained in this way P1 is not interested P2 is interested P1 will be busy here in noncritical SE it will never ever enter the entry section so lock value will always be zero for P2 for P2 critical section will be always free okay now the third condition is waiting bounded a process should not go into critical section when there exist another interested process okay so what does uh bounded waiting say a process should not go to critical section uh I should write here again when there is an another existing interested process so let's check let's check suppose P1 completes its critical section check if the value of log equals to Z yes the value of loog equals to0 changes the value of loog equals to 1 enters critical section when completes all the instruction enters exit section change the value of lock equals to Z again comes here now the value of lock is again Z so lock is zero it will go there check if the value of lock equals to Z no change the value of lock equals to 1 enters critical section changes the value of log to zero again goes again goes again goes again no one is there to stop P1 going again and again while P2 is there waiting for its turn to get into the critical section so bounded waiting no bounded waiting is not guaranteed waiting can be unbounded for P2 so suppose p exits critical section make the value of log equals to zero and quickly joins readyq to go into the critical section again a process can successfully enter critical section multiple times while other process are waiting for their turn to ENT critical section so lock variable guarantees progress but it fails to guarantee Mutual exclusion and bounded vitting okay so let's see a this thing lock variable is a busy waiting solution leading to wastage of CPU time Cycles so yes it is a busy fitting solution because see this part can something be done like this a process comes to the entry section check if critical section is free or not let's say it is not free so why does it have to check the condition again and again wasting the CPU Cycles why does it have to check the condition again and again with wasting the CPU Cycles can something be done like this that a process check the condition that critical section is not free it itself gets blogged and when the process which was in the critical section comes out in the exit section it wake up wakes up the wakes up the blocked process or it's unblocked the sleeping process are you getting what I'm trying to say see this point lock variable is a busy waiting solution leading to the wastage of CPU time Cycles why does the CPU Cycles get wasted because a process checks the condition again and again can something be done like this that the process need not have to check the condition again and again instead what happens is process checks the condition once see if the critical section is not free then it itself get blocked it itself get blocked let's say P1 sleeps let's say P2 P1 was in the critical section P2 comes check that critical section not free get into the sleeping que let's say sleeping queue this is the new name sleeping queue now when P1 completes the critical section goes to the exit section now it is responsibility for P1 to wake up the sleeping process that is P2 it says Hey P2 wake up now I have completed the critical section you can go into the critical section if something like this can be happened then the wastage of CPU cycle can be pre preempted prevented okay so let's see what is this several concurrent process are attempting to share an iio device in an attempt to achieve Mutual exclusion each process is given a following structure Okay so code unrelated to device use that is noncritical section repeat until b equals to false b equals to True code to X is shared b equals to false code unrated to device see what happens even if the variable is changed we we thinks that is a difficult question it is exactly similar to the lock variable which have which we have discussed earlier so here busy is equals to loog false is zero and true equals to 1 now check codee unrelated to device that we don't bother about noncritical section repeat until bz equals to false that is lo lo equals to0 if lock equals to0 then go to the next statement b equals to 2 which means lock equals to 1 now so this is similar like while log so this is similar to what we have studied in the previous uh this code this thing this is exactly similar what they have done instead of lock they have written busy instead of one they have written true and instead of uh zero they have written false so this thing can also be written like that log is not equals to Z okay so they have just changed the way of a representation so this code is exactly similar to the lock variable code which we have discussed now check the following uh options which of the following are true for this approach it provide a reasonable solution to the problem of guanting mutual exclusion no we have discussed recently that lock variable does not guarantee Mutual exclusion because if you preempt here Mutual exclusion is not guaranteed it may consume substantial CPU time accessing the busy variable yes this thing lock variable is a busy betting solution it leads to wastage of CPU time or Cycles third it will fail to guarantee Mutual exclusion yes this is true so option option two and option three are correct in the last lecture we have seen log variable in this lecture we will move to the next synchronization mechanism that is strict alternation do you remember the problems which lock variable has caused the first was Mutual exclusion lock variable doesn't guarantee Mutual exclusion every time in which cases Mutual exclusion was not guaranteed in in entry section when there were two statements preempt in between the two statements preempt after one statement is executed in that case Mutual exclusion was not guaranteed and bounded waiting was also not guaranteed a progress can go again and again while some other interested process kept on waiting for infinite time or starving for unbounded time now the next synchronization mechanism is strict alternation let's check so the strict alternation is also a busy waiting solution and it is a software solution implementable at user mode similar to the lock variable and it is a two process solution do you remember the lock variable was a multiprocess solution where is it so the lock variable was a multiprocess solution strict alternation and Peterson algorithm these are the two process solution what does two process mean this solution only work when there are two process in consideration so what we do strictly on Alternate bi basis process takes turn to enter critical section so strictly on Alternate basis first P1 goes then P2 then again P1 goes then P2 and in this way they completes the critical section so let's see the code int turn equals to random 0 or 1 so turn is a variable that can take two values either Z or 1 and we randomly assign the value of the variable turn it can can be either zero or one randomly so let's write the code void process Z here it is a problem it should be process one yeah void process Zer so we are talking about p 0 and P1 so these are the two processes while noncritical section while turn equals to 1 critical section turn equals to one so what does this say this says so the turn turn signifies which process should go in the critical section now if turn is zero then p 0 should go into the critical section if turn is 1 then P1 should go in the critical section so here in the busy weight condition it checks while turn equals to 1 is it the case that turn equals to 1 if yes then keep on checking the condition busy weight if turn equals to 1 keep on checking the condition busy weight otherwise go into critical section after you complete the critical section change the value to of turn initially let's say the value of turn was Zero let's say the value of turn was zero so critical section completed condition checking turn is not equals to one so it will bypass it goes to the critical section when it completes the critical section now it has to change the value of turn to one because what we said strictly on Alternate basis so first turn value of turn was Zero it means p 0 went to the critical section now when it has completed its critical section then it has to change the value of turn equals to 1 which means now it is the turn of process one to go into the critical section so let's check this while P1 similar for process one check if turn equals to zero then Vis it otherwise go into critical section and when you complete the critical section make sure to change the value of turn I hope you understand this solution this is easier than lock variable okay so is mutual exclusion guaranteed can you check this so when was Mutual exclusion not guaranted in lock variable when we preempt in between two statements of Entry section what is the entry section here just this one and exit section just this one so mutual exclusion will be guaranteed let's see let's see so the what does log variable meant if it is zero which means critical section is free if it is one which means critical section is not free if turn equals to I which means it is p is turned to enter into the critical section and if turn equals to J it is PJ is turned to enter into the critical section I hope this is clear now let's check the scenario there are two process p 0 and P1 in the RQ which are interested in going to critical section let's say p 0 was scheduled first on the CPU and turn equals to zero and this was randomly saved randomly assigned so p 0 was executing its instructions in the critical section at s finally it got preempted so p 0 was already present in the critical section now let's say p 0 is preempted from the CPU P1 comes so P1 will start so the value of turn equals to 0 because p 0 has not completed its critical section and the value of turn equals to one is still remaining to be executed so the value of turn equals to zero now goes to the noncritical section while turn equals to Z yes turn equals to Z so it will keep on checking the condition again and again until the time slice or the time Quantum of P1 expires when P1 expires then P1 is preed from the CPU sent back to the RQ and p 0 comes back now p 0 will resume when p 0 complete this its instruction of the critical section then it goes to the exit section what is the exit section change the value of turn so the turn equals to one now now when one tries to enter critical section it will because it will not get stuck in the busy waiting condition okay so what is the busy waiting condition turn equals to equals to Z but the value of turn is one now because p 0 has completed this instruction so the value of turn has changed now when P1 will try to enter when P1 will try to execute this instruction it will not get stuck in the busy waiting I hope the thing is clear so now P1 cannot enter critical section until p 0 set the value of turn as one so is mutual exclusion guaranted yes the mutual exclusion is guaranteed can you infer more so let's say turn equals to random 0a 1 see see there are two process p 0 and P1 and the value of turn is set randomly let's say the value of turn is zero here but p 0 is not interested to go to the critical section if p 0 is not interested to go to the critical section it will never ever enter entry section it will never go to this critical section and it will never execute this turn equals to one and if turn equals to 1 is never executed then P1 in any case cannot go into the critical section so p 0 is uninterested process is hindering the progress of P1 which is interested process let me speak again p 0 is not interested to go to critical section if it never goes to critical section which means it will never execute the exit section and what was the exit section change the value of turn so turn equals to 1 will never happen and if this never happen P1 cannot go to critical section ever so an uninterested process has hindered the progress of interested process so progress is hindered here which was not in the lock variable so this is the same thing let's say turn equals to random 0 1 gives one it means it is Pi's turn to enter critical section but she is not interested ENT the critical section if she doesn't enter I'm talking about the process if she doesn't doesn't enter in the critical section then she will never execute the exit section turn will never be set to zero p 0 is blocked by a noninterested one progress is hindered so it is just an example what I want to say Mutual exclusion is guaranteed progress is hindered because an uninterested process take anyone either p 0 or P1 it is just an example take any process that uninterested process will never change the value of turn equals to the other process so other process other interested process will never be equal will will never be able to enter the critical section so an uninterested process is blocking the progress of interested process so progress is hindered is the waiting bounded yes wait is bounded what was the meaning of unbounded waiting the meaning of unbounded waiting was P1 kept on going to the critical section again and again again and again again and again while an other interested process that is P1 is starving and p 0 is laughing at the face of P1 this was bounded waiting this was unbounded waiting now here in the case you see when p 0 enters into the critical section it must change the value of turn equals to other process which means p 0 is giving chance to other process to enter to the critical section now which means p 0 cannot enter into the critical section two times in a row let me explain so let's say the initial value of turn was Zero Turn was zero this condition will be escaped goes to the critical section now turn equals to one try to go again now it will get stuck here as turn equals to one when it tries to go again it will get stuck in this Loop so bounded waiting is present as there is a strict alternation bounded waiting as there is a strict alternation now let's revise so lock variable and turn variable what is the difference Mutual exclusion was not guaranted by lock variable it was it is guaranteed by turn progress progress is guaranteed by lock variable but in turn an un uninterested process can block other interested process bounded waiting bounded waiting was not uh ensured in lock variable but it is ensured in turn as there is a strict alternation between the order of process which goes into the critical section busy waiting the both are busy waiting solution and busy waiting vage the CPU Cycles okay and last thing is number of process lock variable is a multiprocess solution while turn variable is a two process solution so these are the difference between lock variable and turn variable so till now we have covered two synchronization mechan mechm lock and turn okay now the last thing the value of turn need not to be equals to 0 or 1 it can be any either I comma J so we are generalizing it is not necessary that only p 0 and P1 are there in the program it can be either process like it can be p8 and P9 that can also be possible so we are generalizing in terms of I and J so let's say in turn equals to random I comma J so we are assigning the value of turn randomly either I or J turn can take here two values I or J if it is I then it is the turn of process I to enter the critical section and if it is J then it is the proc it is the turn of process J to enter the critical section so simil same thing in process I check if it is the turn of process J to enter if yes then keep on busy waiting otherwise goes to the critical section and in the exit section change the value of turn to the other process same thing is happening here okay so lock and strict alternation are incorrect solution why because they are not satisfying all the requirements log was not log was not giving Mutual exclusion and bounded waiting and alternation is not giving progress so all three condition Mutual exclusion progress and bounding waiting should be satisfied but here some of the other is not satisfied so these are incorrect Solutions so here is a homework problem here's a homework problem check this in turn equals to random i j so this is a problem you have to tell is this guanting Mutual exclusion is this guanting progress and bounded waiting try this in the last lecture we have seen strict alternation which provides Mutual exclusion and bounded waiting and if you recall the middle one that is the progress was ensured by lock variable so Lo variable has ensured progress strict alternation in ensures bounded waiting and mutual exclusion why not we Club the good qualities of both and create a perfect solution we have done the same thing that is Peterson solution has been made by combining the good qualities of lock variable and strict alternation and it is a solution in literal terms it provides all the three matual exclusion bounded waiting and progress it is a busy waiting solution software solution implementable at user mode and it is a two process solution that means it will only work when there are two process into consideration let's say pi and PJ so we are defining so let me tell you what is the main idea of this Peterson solution we are using two variables flag variable and turn variable so what does flag and turn refer to flag variable suggest if a process is interested to go into critical section or not flag gives the interest for a process let's say for process I if the value of flag is zero which means process is not interested and if the value is one which means process is interested and turn you all know what is the meaning of turn which process should enter into the critical section which process so turn means if turn equals to I that suggest Pi should enter into critical section if turn is I which means Pi should enter into the critical section and if it is J which means PJ should enter I hope this is clear so what we are doing here is what we are doing initially initially we are setting the value of flag to false we are saying initially no process is interested to go into the critical section okay now when the process code will be there here let's check this check the intersection we are changing the value of flag it to true for process I we are changing the value of flag I to true and we are changing the value of turn to the value of the process we are changing the value of turn to the value of the process what does this mean so the concept of turn that is a global variable will be used when both of them are interested simultaneously if turn equals to zero so both the processes are updating the value of turn according to their value if it is process I then it will change the value of turn to I and if it is J then it will change the value of turn to J okay so let's say there are two process p 0 and P1 p 0 updated the value of turn to zero and what will P1 do it will change the value of turn to one now comes the important part now comes the important part the process to update the value of turn and the last will wait the process which will update the value of turn in the last Will Wait so we will check what is the value of turn if the value of turn is one it means that p 0 has updated it already and P1 has updated later and if the value of turn is zero which means P1 has already updated the value and p 0 has updated it in the last so we will check what we will check change the value of flag I to True make the process interested change the value of turn to the process value now check if other process is interested and the value of turn equals to I then busy weight let me explain again let's say p 0 and P1 both are interested to enter into the critical section both has changed the value of flag to True when both are interested they will change the value of flag to true now both wants to change the value of turn to their value so p 0 update p 0 change the change the value of turn to zero and P1 changed the value of turn to one now when you see if the value of turn is zero that means P1 has updated first and then p 0 has updated in the last that's why the value of turn is zero you all know the process which updates last that value of turn will be saved finally let me write this the process which updates last that value of turn will eventually remain so if the value of turn equals to I that means the process I has updated the value of turn in the last so the the process which will update the value of turn in the last will wait okay so check if other process is interested and the value of turn equals to I this means that the other process that is the the process J has already changed the value of turn to J and later Pi I changed the value of turn to I that's why the value of turn is I eventually so which process should wait whose value is there in the turn so that process Will Wait so I hope the point is clear let me explain again initially what we are doing we are defining the value of n22 that is n refers to the number of process true means one and false means zero we are also defining this we are also defining an array of size n initialized to false so initi initially we are saying that all process are uninterested so let's say if there are two process then flag two and both are initialized to false that is both the process are uninterested in the beginning and in turn we are declaring a variable turn see here we are not initializing turn in the pre previous case that is of a strict alternation what we were saying we were saying Turn equals to random of I comma G we are not doing this here what we are doing we are letting the process change the value of turn accordingly according to their values and the process which updates the value of turn at the last that process has to wait because the other process has already updated the value of turn so that process should go first same concept we are applying here so this is the process code void process in I we are talking about process I and J refers to the other process what does this line means this line says that J is the other process here comes the critical section what we are doing changing the value of lag to True making the process interested changing the value of turn to I which means it is the turn of process I to enter critical section this is how process thinks and when it will check that other process is also interested and the value of turn is equals to my value which means I have updated the value of turn in the last and other process is interested too which means the other process should enter the critical section first because it has changed the value of turn earlier than me so I should wait okay so this is entry section and what is exit exit section so when the process completes the critical section it will make itself uninterested okay so let's summarize what we have said what a process does it change the flag value to True set the turn equals to the process ID check if other process is interested and I am the last one to update turn then I should bate so this is the main summary of Peterson solution okay so how does the process gets he was the last one to update if a process find out find out its ID and the value of turn is same then it is the last one to update so I have said said this thing several times I hope the thing is clear let me speak again P1 and P2 are two process P1 should change the value of turn to one and P2 should change the value of turn to two in the end we finally see that the value of turn is two so which process do you think has updated the value of turn earlier p okay so this is clear in the next video we will see how this is a correct solution in the last lecture we have seen the implementation of Peterson solution in this lecture we will see why Peterson solution is a correct solution so initially two processes are in the ru p 0 and P1 and the value of flag is initialized to false which means in the beginning both the process are uninterested to go into the critical section pz is scheduled into the CPU at time T1 and P1 at time T2 so T1 at time T1 p 0 is in the CPU and I is equals to0 and J equals to 1 which means the process which we are considering has the ID of zero and the other process has the ID one see in turn and in lock we have written two solutions for for p 0 different different code for P1 different code but here what we are doing we are have written this line that this is the code of whichever process we are considering and J is the other process Pi is the process which we are considering and J is the other process so in this case in this case which is pi p 0 and in this case which is Pi Pi is P1 so in this case we were considering p 0 and in this case we are considering P1 so whichever process we are considering I refers to that process ID and J is the process ID of other process so P0 has completed three sections noncritical section flag 0 equals to True which means it has completed these three instructions these three instructions and it got preed here noncritical section changed the value of FL to true and turned to I which means zero so these three part are completed and it got preempted here now at time T2 P1 is scheduled so I = to 1 J = to 0 it does the similar thing noncritical section change the value of like to true and turn to one now you know that P1 was the last one to update the value of turn so it will bate check here when it will it has completed noncritical section change the flag to True did this turn equals to I now see when it will check this condition we are talking about the P1 when P1 will check this condition it will it will see that the other process is interested as P0 has already completed this instruction so it will see the flag of P0 is true the flag of p 0 that is the flag of other process is true and the value of turn equals to one because this process has updated in the last so it will get stuck in this condition checking it will busy so which process will busy weight P1 will busy weit so it will be busy weting now at time D3 p 0 will join the CPU again now the value of I equal to 0 and J = to 1 I refers to the current process which is the current process zero so I will refer to the ID of the current process so I equals to Z and J equals to the other process what it will do now it will start from this p 0 will start from statement D because it got printted here and when process returns it will resume it will not restart so it will start from statement D it will check is the other process interested yes the other process is interested and what is the value of turn the value of turn is equals to J the value of turn is equals to J in the last turn equals to 1 so the value of turn equals to J so it will not wait it will escape this waiting condition and enters the critical section enters the critical section okay so this is how Mutual exclusion is guaranteed when both process are interested so whichever process updates the value of turn in the last will beate c p 0 and P1 were both interested to go into the critical section and here we can see that one process has to busit so this is how Mutual exclusion is guaranteed when both the process are interested now we have a concept of flag if other process is not interested then it won't let the other process busy it because of her see busy waiting only happens when the other process is interested and the other process has updated the value of turn earlier than the current process I will speak this line again busy waiting only happens when the other process is interested and the other process has changed the value of turn earlier than the current process now in context to progress the other process will never change the value of flag to True see I have already said if a process is interested then only it will go to the entry section and the first statement of the entry section is change the value of true if a process is not interested it will never go to the entry section it will never change the value of flag to true so it will never let the other process busy weit so the progress is not hindered here I hope you are appreciating the beauty of Peterson solution so now we have concept of flag if other process is not interested then it won't let the other process busy because of it okay so noninterested process guaranteed progress now how the bounded weight is guaranteed let's say let's see from the code let's see from the code p 0 wants to enter critical section two times in a row can this happen or not let's check P0 completes noncritical section change the value of flag to True change the value of turn to zero now it's checks if flag J equals to true and turn equals to I initially let's say it escapes this condition because we are checking if it can enter the critical section two times in a row so let's assume it has entered first time completes the critical section completes the exit section change the value of flag to false now it wants to go again so what it will do completes the noncritical section change the value of flag to True change the value of turn to I so this is the critical thing change the value of turn to I which means change the value of turn to zero other interested process is there and the value of turn equals to zero which means it will busiate it cannot go again similar thing I have written here let's Z let's say p 0 completes critical section and it quickly completes its rest of the instruction to enter the critical section again while the other process is still waiting which means while the other process is interested okay which means the flag of other process is true is that possible no why because we have a concept of turn if p 0 wants to go again it cannot go because let's say for the first time it completes the critical section completes the ex exit section now goes again to the entry section change the value of FL to True change the value of turn to zero you got this other process is interested and the value of turn is equals to Z see p 0 itself changed the value of turn to Z and in the next statement it checks whether the value of turn equals to zero or not it is zero and the other person is interested so it will buyit it cannot enter again because P0 was the last one to update the turn and the process which updates the turn in the last should be Z so did you see how intricately this is crafted this Peterson solution let's revise again so what we do in the peton solution we change the value of flag to true we change the value of turn equals to the idea of the process and checks if the other process is true if the flag of the other process is true which means other process is also interested and the value of turn equals to the I which means this process has updated the value of turn in the last which means this process should Bey okay so this is how Peterson solution guarant is mutual exclusion in the second case we have a concept of flag an uninterested process will never change the value of flag to True initially it is set to false an uninterested process will never go to the entry section and it will never change the value of flag to true that's why it will never hinder it will never hinder the progress of other interested process in the third bounded waiting we have a concept of turn which ensures that a process cannot go into the critical section two times in a row so that's why Peterson solution is a correct solution I hope now it is clear hi do you remember the problem which I have given you you have to tell whether this piece of code provides Mutual exclusion bounded waiting and progress or not so let's check line by line in turn equals to random I comma J so we are randomly assigning the value of turn to either I or J void process in I so this is the code of running process I refers to the running process and J refers to the process which is other than I J equals to not I the process which is not running while one noncritical section while turn is not equals to I so this can also be written as y turn equals to J so what does this line say it says if if it is the turn of another process then busy weit change the value of turn to J and what is J J is not I goes to the critical section again change the value of turn to J so this is the code now we are here to check whether this provide a mutual exclusion or not so do not have to read from this PDF I made a little mistake here read from this so what are the statements of the entry section initially the noncritical section then in the intersection we are checking if it is the turn of another process if yes then bate change the value of turn to J now I've told you that whenever there are Whenever there are two or more statements in the entry section then preempt in between to check M exclusion or deadlock or anything preempt in between so we are doing the same thing we are preempting in between p 0 is the process under consideration so the value of I equal to 0 and value of JAL to 1 and we are seeing initially the value of turn is zero p 0 completes the noncritical section now checks the condition while turn is not equals to zero well the value of turn is equals to zero so this condition is false do not vate escapes this condition and here it got preempt preempt just before turn equals to one okay so whenever the process comes back it will start with turn equals to one okay now comes P1 so now P1 is the process under consideration so the value of I will be 1 and value of J will be zero completes the noncritical section tries to enter into the critical section so firstly it have to go into the entry section now the value of turn equals to Z checks while turn is not equals to 1 yes turn is not equals to 1 it is equals to Z the condition is true B it so it is not able to enter into the critical section while this process can enter so here we can say Mutual excution is guaranteed but but have you checked the traditional way what was the traditional way what was the definition the definition is two process should not be into the critical section at the same time so what what are we doing we are letting one process enter into the critical section and there we are preempting it and we will see that if another process can also enter into the critical section or not so at time T1 P0 is the process in the consideration I = to 0 Z = to 1 turn equals to 0 initially completes the noncritical section why turn equals 2 equal to 1 no no this is false escapes the busy weight change the value of turn to one goes to the critical section gets preempted here now the value of turn is 1 okay p 1 is the process let's say at time T T2 P1 is the process into the consideration I = 1 J = to 0 completes the noncritical section while turn equals to equals to zero is this true no this is false turn equals to one so it will not busy weight goes to the next statement turn equals to0 enters the critical section when p 0 is in critical section when p 0 is in critical section no one is there to stop P1 from entering so here we can say m Mutual exclusion is not guaranteed let's check for Progress so we are randomly initializing the value of I and J let's say the value of turn is value of turn is J as we can as it is randomly initialized so we can say we can initialize the value of turn to anything either I or J okay so let's say the turn turn is initialized to J which means it is the turn of process J to enter critical section but process J is not interested not interested to enter critical section if it is not interested it is never going to change the value of turn to another process so the progress is hindered progress now turn let's say the value of turn was J so pi and PJ are two process in the RQ PJ is the not process which is not interested for critical section so Pi will get stuck in the v loop as PJ will never enter into the critical section so the value of turn equals to I will never happen so the progress is hindered here what about bounded waiting can a process enters into the critical section two times in a row if yes then the waiting is unbounded let's see let's see p 0 is the process goes into critical section so here I equal to 0 and Jal to 1 goes into the noncritical section while false because let's say the turn equals to Z zero in the beginning so is it the turn of another process no condition becomes false now the value of turn is changed to one so what does this say it is the turn for another process to enter so when the when after completing all these steps when p 0 trying to enter again into the critical section there it will get stuck in the busy weight Loop because the value of turn has been changed to one so P0 cannot enter into the critical section so the bounded waiting is guaranteed so I hope you now know how to get how to infer from a piece of code that either bounded waiting Mutual exclusion or progress is guaranteed or not okay in the at the last time for the last time I should use better prepositions for the last time let's see the formal definitions of all these things all these requirements Mutual exclusion I'm just going to read it you all know the meaning of all things them just for the formal sake this property ensures that if a process is executing in its critical section then no other process can execute in their critical section okay this property ensure that if no process is executing in its critical section and there exist some process that wish to enter their critical section then selection of the process that will enter the critical section next cannot be postponed indefinitely this is progress and bounded waiting this property ensures that there exist a bound or limit on the number of times there exist a bound or limit on the number of times that other process are allowed to enter into their critical sections after a process has made a request to enter into critical section and before that request is granted so what does bounded waiting say that a process should not be allowed or there should be a limit on the number of process going into the critical section again and again if there exists some another interested process and what does progress say progress says that an uninterested process should not hinder or should not block the interested process and what does mutual exclusion say you all know there should not be two or more process in the critical section okay so in the next lecture we are going to start dear's algorithm hope you all remember Peterson algorithm in this Le we are going to see the optimized version of Peterson algorithm that is D's algorithm and it is a correct algorithm too it provides M exclusion bounded waiting and progress so how does it work let's see void Deckers algorithm in I so I is the process under consideration and J is the other process okay while one noncritical section so let me give you a situation this is u this is the other process you are process I and your friend is the process J so both are friends so what happens there is a TV screen here which gives the value of turn variable so what happens you loudly say I am interested to go into the critical section so what you do you change the value of flag I to true but you also check at your friend's face he also seems interested to go into the critical section so what do you check you check whether your friend is interested to go to the critical section if he is interested then what you will do you will look at the TV screen of turn if it is the turn of your friend to go into the critical section what you will do you will become a good man you will say okay my friend should go into the critical section I am an uninterested for now I am uninterested for now so we'll change the value of your flag to false and you will say I will wait until it's my turn to enter into the critical section so until the turn equals to equals to J you are going to busy wait and as soon as as soon as at the TV screen you say it's my turn to go into the critical section what you will do you will change your flag to interested or true through you'll go into the critical section and when you comes out it is your responsibility to say okay I have done my work now I am un interested to go into the critical section my friend you can go will change the value of false and you will say the value of turn will be equals to J so this is how Decker's algorithm work okay so let's read the full code Decker's algorithm vo Decker in i j is the other process I is the process under consideration completes the noncritical section you say hey I am interested but you will also look at your friend's face if he also seems interested and then you look at the TV screen of turn the turn suggest that J should go so you will become a good man you will say hey my friend you can go I am uninterested for now and I will wait until it's my turn to go into the critical section and as soon as your turns appear uh or your ID appears at the TV screen you say now I am interested to go into the critical section you goes to the critical section after the completion of critical section you say now I'm uninterested my friend you can go it's now your turn I hope dear algorithm is clear now now we'll see why dear algorithm is correct algorithm let's check for Mutual exclusion the algorithm uses two Boolean variable flag I and flag J to indicate if a process wants to enter critical section it also users turn to decide which process can enter critic section when both want to this ensure that only one process can enter into a critical section providing Mutual exclusion so the mutual exclusion is guaranteed now let's check for Progress if a progress doesn't want to enter the critical section it sets its flag as false this allow other process to enter critical section if it wants to this ensure that if a process GS to ENT critical section it eventually will providing progress see initially the value of flag is false for both the process and I have said that a process will enter into the entry section only when it is interested to go into the critical section so it will never change its value to true the value of flag will always remains false and if the value of flag will always remains false it will never going to bate the other process so the progress is guaranteed because the value of flag will never be set to true if a process doesn't enter the entry section and an uninterested process never ever enters the ENT section bounded waiting the turn variable ensures that the process alternately enter the critical section and they both want to enter c here whenever it completes the exit section the turn is set to J and if it tries to go again it will stuck here okay so process cannot enter the critical section two times in a row in bounded waiting okay so I hope the point is clear how deer algorithm is correct it provides Mutual exclusion progress and bounded waiting we have completed the software solution for synchronization the lock variable the turn variable that is a strict alternation Peterson solution and Decker's algorithm in this lecture we are going to start the new topic synchronization using Hardware but before that let's discuss some problems so there are two process P1 and P2 that need to access critical section of the code consider the following synchronization con used by these process and you have to tell whether they provide mutex progress mutex means Mutual exclusion progress bounded waiting and Deadlock okay so for the mutex let's discuss the two condition the first is preempt in the critical section and see if the other process is also able to enter into the critical section or not the other one is preempt in between the two state M of Entry section so let's check for the critical section first there are two variable want one and want two initially set to false now let's see what happens want 1 equals to True here in this code wants 1 equals to true so I'm going to change the value to True while wants two equals to true no this is false so we are not going to busy weit enter into the critical section preempt here let's go to the second process wants 2 equals to true so we are changing the value of wants two to true now while want 1 equals to True is it true yes it is true so it is going to Vis it it won't be able into the it won't be able to enter into the critical section now we will check the second condition that is preempt here want 1 equals to True preempt wants two equals to true so this is the the case now go here while wants to equals to True yes it is true so it is going to busy go here now while wants 1 equals to True yes it is true so it is also going to both process are busy waiting this is the case of dat log let me explain again first this statement wants one equals to true then this statements 1 to equals to true then this statement and then this so both are busy waiting both get blocked so this is the case of Deadlock so deadlock is present Mutual exclusion is also guaranteed now check for Progress let's see P2 is the process uninterested to go into the critical section so initially the value of want one and want two is set to false and P2 is the process that is not interested to go into the critical section if P2 is not interested can it block P1 to go into the critical section if P2 is not interested it will never change its value to true and if the value of want to is never true then P1 is never going to beate so progress is also guaranteed an uninterested process is not hindering or blocking the interested process to enter into the critical section so progress is also guaranteed Mutual exclusion guaranteed progress guaranteed deadlock also guaranteed check for the bounded waiting for bounded waiting see if a process can enter into the critical section two times in a row wants 1 equals to True while one two equals to True initially the one two is false so it enters into the critical section now want to equals to false okay now wants to equals to false it was initially False only so this is true once one has become true and this is false it tries to go again want one is true change the value to True is want to equals to true no it is false enters into the critical section now change the value of one two to false again tries to go again wants two equals to True yes it is true is the value of one 22 true no it is false so it enters again a process can enter again and again into the critical section while other interested process is waiting so bounded waiting is not guaranted if it was the case of strict alternation then bounded waiting will also be present and for case of a strict alternation they never have deadlock the case of Deadlock will never be present in the case of strict alternation okay let's let's see another question variable P equals to false variable Q equals to false code for process X is given for process Y is given you have to tell is there any possibility of Deadlock does this guarantee Mutual exclusion this is an homework question and easy one you can do this on your own let's move to the synchronization Hardware so each processor supports some special Hardware instructions that are Atomic in nature okay so do you mean what do you mean by atomic Atomic means that they cannot be preempted until they gets completed it's just like the kernel mode instructions okay so these instructions these special instructions are Atomic in nature so we are discussing about TSL and swap instruction they are also based on busy waiting and they can be used at user mode as a special instructions so they are they are being used as user mode only but they are special instructions hence Atomic in nature they belong to the hardware category and it is a multiprocess solution see lock variable was a multiprocess solution turn variable was a two process solution Peterson was a two process solution deers was a two process solution this TSL and swep we will see it later later these are multiprocess solution this Hardware solution TSL and swap are multiprocess solution what are they we are going to see in the next lecture and it is a lock based solution lock based solution do you know the full form of TSL test and set lock so these are the lock based solution this is just an introduction video we are going to see them in detail you in this lecture we are going to start our first synchronization Hardware mechanism that is TSL TSL stand for test and set lock so what does it do let me tell in brief DSL takes a parameter lock m% loog that is the address of lock so what does TSL do TSL Returns the current value of lock let's say initially the loog is set to the loog is set to false so what does TSL will return TSL will return the value as false and then it will change the value of log to true so what does TSL do TSL Returns the current value of log and set the value of log to True okay so this is what I have written TSL M loog process executing TSL Returns the current value of log and sets the value of log always to true so first it will read the current value and write the current value to True okay so whatever be the value either true or false this will be returned and then the value of log will be changed to true so this is what TSL does now before we are going to see how TSL is going to solve the critical section problem we'll first see how TSL works so what is the function behind TSL bull TSL why bull because TSL returns a boan variable either true or false I have said first it will return it Returns the current value of loog so what does loog contain either true or false so firstly it will return so return type will be Boolean Bo esteric Target so here we have written m% lock and here we have written esteric Target so Target is a pointer pointing to the lock here we are using passing by reference so Target is a pointer pointing to the lock what does return Value Store bu return value return value is going to store the current value of lock let's say let's discuss the previous example which I have given so according to that previous example the return value of lock will be false and so let me write it again so initially the value of log was set to false okay so return value is going to store the value of log that is false so return value will store false and then set the value of log to true so we are going to set the value of log to true and return the return value what is the return return value false so what does it will return TSL will return false and will set the value of log to True okay so this is how TSL work now last statement which I am going here to made before we will see how this solves the critical section problem is these three instruction will execute atomically no preemption so it Returns the value of log and set it to true and this is done atomically okay so let's see how this solves the critical section problem initially let's set the value of log to false void process in I while one now see noncritical section is executed and then while TSL M percent loog is equals to is equals to true this is entry section critical section and then set log to false let's see how how it is going to solve the critical section problem there are two process in the RQ P1 and P2 okay P1 P1 firstly scheduled at CPU start executing the critical section P1 is still in the critical section and it gets preempted now P2 comes now P2 is in the CPU let's check whether P2 can also enter into the critical section or not if it is capable to enter into the critical section this DSL is not going to provide the mutual exclusion let's see whether it is capable or not so initially when the P1 wants to enter critical section what it has to do it has to First execute the noncritical section it will check whether the value which TSL return is true or not so initially the value was false so what does TSL will do TSL will change the value of log to true and Returns the current previous value what was the previous value false so it will return false is false equals to true no it is not hence it will go into the critical section it was still in the critical section before it got preempted so P1 is still in the critical section now P2 got scheduled let's check whether P2 is also capable executes the noncritical section while TSL M m% log what does TSL do TSL Returns the current value of log what is the current value of log true so it will return true and sets the value of log to true so it return true is true equals to True yes it is true so it will keep on visting visting and visting until until P1 completes the critical section goes to the exit section change the value of log to fals so it will change the value of log to FS now when P2 will get hold of CPU when P2 will be in the CPU it will resume resume from where from here now it will see TSL Returns the current value of log what is the current value of log false is false equals to true no it is not now it can go into the critical section so I can make a statement P2 can go into the critical section only when P1 has completed its exit section so it guarantees Mutual exclusion does it guarantees progress yes it guarantees progress how because let's say there are two process P1 and P2 P1 is not interested to go to the critical section so a process which is not interested to go to the critical section will never ever visit the entry section so the value of lock will be never changed to true it will remain false so when P2 tries to enter false is not equals to true it will easily Escape The Waiting condition so P1 is not hindering P1 is uninterested process so uninterested process not hindering the way of interestate process hence progress is guaranteed noninterested process will never change the value of log to ro okay now comes the now comes the scenario of bounded waiting is bounded waiting satisfied I think it's not why let's see P1 completes the critical section goes to the TSL initially the value of lock was false so when this will be executed this DSL it will change the value of log to true but it will return the current value as false so false is not equals to True easily escapes the critical section goes to the ENT section it will change the value goes to the exit section it will change the value to false again try to go what does TSL will return it will return the current value that is false false is not equal to True will again Escape The Waiting condition hence P1 can go into the critical section again and again while P2 is still waiting so P1 will l in the face of P2 but P2 can do nothing so bounded waiting is not guaranteed but I have seen in this logic bounded waiting is not guaranted but in galin textbook so which textbook textbook are we referring to we are referring to galin so in galin textbook they have added additional logic in TSL which will make it right like a round robin so first P1 will go it will execute for some time and then P2 will go so in this manner a a type of turn is introduced P1 P2 P1 P2 it's it's like a round robin so they have added additional logic and if that additional logic is there then it will ensure bounded weight but here in the basic logic bounded weight is not ensured P1 can go into the critical section again and again so if you are interested you can just go to the Galvin textbook read the additional logic and try to understand okay but here in the uh the case which we are talking about bounded weight is not initialized P1 can go into the bounded weight is not there not present P1 can go into the critical section again and again okay so I hope how TSL work is clear in the next lecture we are going to see the swep mechanism let us start the swap mechanism this is based on lock in key mechanism so what does I refer here to we'll see later but let's first see the introduction part swap mechanism based on lock and key and it is atomic in nature so this web function this will make sure that these three instructions will be ex executed atomically so what does are the these three instruction these three instructions are for swapping the values stored in the variable A and B so why are we using here the call by reference not directly because we want the changes to reflect into the original data also we are changing inside a function we also want that original data should also be changed that's why we are using call by reference if you don't know call by reference it's your homework to understand how call by reference work okay so let's first understand how spping work for swapping what we have to do we have to use a temporary variable otherwise the value of one variable will be lost what I am saying here is let's see this is variable a this is variable B it is stored value five it store value 7 now I want to swap the values of A and B let's say I want seven here and five here how can this be achieved let's see okay I cannot directly store the value of a into B I cannot directly write here five otherwise the seven will be gone okay so first we have to store the value of s into a temporary variable before changing the value of B so we have stored the value of B into some temporary variable T now this can be overridden and here the value of T will be stored back to a so this is how swipping is done let's see here we are defining a temporary variable we store the value of a into the temporary variable now the value of a is safe I can directly store the value of B into a the value of a is already safe now the B value of B is stored in a and then the value of a indirectly I'm saying the value of a is now stored in B so value of B is stored in a and value of a is stored in B this is how swipping is done using a temporary variable now you got how spping is done let's see how this spping is useful in solving the critical section problem set the value of lock to false initially the value of lock that is a global variable is set to false void process in I P1 let's say P1 is the process and has a value of key to True initially we have set the value of key2 true P now P1 wish to enter into the critical section so what it will do it will first execute the noncritical section goes to statement B while key equals to equals to true it will check whether key equals to True yes it is true it will enter into the V Loop swap the value of lock in key now we have to exchange the value of lock and key lock will become true and key will become false as it is a vop it has to go check the condition again the value of key is true no the value of key is false so it is going to escape this while loop goes to the critical section now we wish to now we wish that this spping mechanism solve the critical section problem so so we are going to check when P1 is in the critical section does another process also enters is another process capable to enter into the critical section that we are checking so we will preempt in the critical section so P1 is still in the critical section P2 wish to enter what is the value of lock lock is true now P2 wish to enter so this is P2 and I have said initially the value of key in process is true P2 completes the noncritical section is the value of key to is true yes it is true it will swap the value of key and lock the value of key and lock will be swed so true will be here and true will be here the value of Key and Lock is swapped but the keys is still true so when it is going to check the condition again it has to swap again the value of login key so it is going to it is just swipping the value again and again checking the condition swipping the value busy weight busy weight until the value of log becomes false and how can value of log become false when P1 completes the critical section executes the exit section now value of loog has been changed to false now if P2 wish to enter see in now presently no one is the no one is in the critical section now P2 wish to enter the value of lock has been changed to false by P1 exit section so P2 will start here check check does the value of key is equals to True yes it is equals to True swap the value of lock and key so it will swap this will become false and this will become true now it is going to check the condition again is the value of key true no it is false so it will escape now it can enter easily into the critical section but what a statement I can make here the mutual exclusion is guaranteed see here P1 completes non critical section key equals to True swap the value now lock is true key is false enters critical section got preempted P2 is to enter completes noncritical section key is true swap the value of lock in key but it has to CH it has to check the condition again key is true yes swap the value key is true yes swap the value key is true yes swap the value until P1 completes its exit section change the value of lock now when it will swap the value the key will become false and lock will true now when it's going to check the condition the key is false so now it can enter into the critical section only when P1 completes the critical section so we can say Mutual exclusion is guaranteed P2 is unable to enter into the critical section when P1 was present there does it guarantee progress yes progress is guaranteed as no uninterested process will change the value of lock not blocking the other process okay in particular the code could lead to the situation known as starvation if one process quickly finish its critical section and reenters it before the other process it has it chance to set lock it could potentially keep reentering the critical section indefinitely while the other process Waits unboundedly so here I can also say that bounded waiting is not guaranteed a process can enter into the critical section again and again again and again by setting the value of log to false okay see to enter into the critical section what is the major thing required the value of log should be false critical section should not be logged the value of log should be false so a process can change the value of log to false in its EX in it exit section and can enter into the critical section again and again while other process is waiting so bounded waiting is not guaranteed but similar to the TSL if additional logic is added then bounded waiting can be guaranteed but here in this case bounded waiting is not guaranteed so this was swap mechanism it guarantees Mutual exclusion progress but fail to guarantee bounded w so we have completed test and set and swep mechanism let's see a problem on this enter critical section and leave critical section functions are there to implement the critical section of a process and are realized using test and set instruction X is initialized to zero which says critical section is free so when test and set X will be executed it will return the value of x and will set to one which says critical section is busy so this is similar to the test and set which we have studied now based on this try to solve or try to guess which of the following four options is correct so the first says the about solution of critical section is deadlock free yes test and set is deadlock free the solution is starvation free no this is false because a process can enter into the critical section any number of times while some other process is waiting other process is starving so starvation free this is false starvation can be present the process enters critical section in feif folder no this is false there's no no restriction for process to enter only in folder they can enter in any order fourth more than one process can enter critical section at the same time no test and set log successfully provide Mutual exclusion so only option one is correct now an interesting problem that is priority inversion problem see if someone ask you an interview which is a high probability give me a best example of Deadlock give me a best example of Deadlock then you are going to say this priority inversion problem this has happened in one of a NASA's Mars project finder project so what happened that let me explain you in brief there are two process PL and pH PL refers to the low priority process and pH refers to the higher priority process so all correct busy waiting Solutions suffer from Priority inversion problem and this problem is only when we are using preemptive priority based scheduling I hope you all recall what is preemptive priority based scheduling so initially PL was there PL got to the CPU went to the entry section completed entry section was executing the instructions of critical section but suddenly it sees that there is a high priority process present in the ricu so it has to leave it has to leave CPU go back into the ricu now pH is entering into the CPU pH is in the CPU pH says I wish to enter into the critical section 2 tries to enter into the critical section but denied why because PL is PL is already present pH feels bad I am the process with higher priority how can pH remain in critical section when I am I want to enter PL Hey listen PL you should leave the critical section immediately PL says listen sir the thing is I cannot complete my instructions until you leave the CPU so that I can complet my complete my remaining instruction of critical section exit and then you can go to the critical section till I am in the critical section you cannot enter into the critical section PL says how dare you to talk me to talk to me like this I am the process with the higher priority I am not leaving the CPU PL also says okay go and try try to enter to critical section if you can I am not leaving the critical section as well so pH is waiting for PL to enter critical section PL is waiting for pH to leave CPU so that it can complete the remaining instructions of critical section pH is waiting on PL PL is waiting on ph deadlock perfect example of Deadlock so let me read pH is also interested into critical section but it it cannot be allowed no matter how high the priority is it cannot be allowed until there is some process present in the critical section so pH cannot be allowed to enter section until P1 completes and for completion PL needs CPU pH won't leave CPU because of its ego so there are the they present the conflict of two principles the first is priority and the second is of mutual exclusion priority says a low process a low priority process should leave whenever a high priority process come Mutual exclusion says there should be only a single process into critical section pH cannot enter into the critical section until PL leaves both will be adment do you know the meaning of adment the adment means stubborn stubborn both are stubborn to leave this causes deadlock so I have given you if I have already told you if someone in the interview ask you example of Deadlock this is the best one this problem occurred in the NASA's Mar Mars Pathfinder project so what is the solution the solution of the problem is priority inheritance see the thing is you can drive the inter VI the way you speak let's say it has started with tell me your favorite subject and then you say operating system they ask what is deadlock you give the definition of Deadlock now they ask can you give me an example then you say yes I can give you an example and you give this perfect example this priority inversion problem first thing is the interview will be the interviewer will be very much impressed and the second thing is he will ask what is the solution then then you are going to say priority inheritance PL will inherit the priority of pH and vice versa for PL so what happens when this uh when this type of problem occurs then that uh a low priority process is present in the critical section and a high priority process has occupied CPU then we have to invert the priority PL will get the priority of pH so what will happen now pH will leave PL will come PL will execute the instructions and then when the critical section will be over it will execute the exit section and then it will get its own priority back now pH will enter into the CPU and then can easily enter the critical section so I hope you all you have understood what is priority inversion problem and what is the solution priority inherit inheritance we are going to exchange the priority of low priority and high priority process now an amazing homework question it has various parts and if you can do this give yourself a nice trate this is an amazing question we are going to discuss this in the next lecture let me explain you the problem Fetch and add X comma I is an atomic read modify WR instruction that reads the value of memory location X increment it by value of I and Returns the old value of x it is used in the studio code as shown below to implement a busy weight lock so this this Fetch and add L comma fun this could be implemented like in this way this is not a part of question this I have given you in form of a hint so fetch and add log int X in I these are the parameters taken by Fetch and adlog these are the parameters int return value the store the value of x into the return value increment the value of x by I and then return the return value so what does it do read modify write instruction that reads the value of memory location X reads the value of memory location X incremented by value I incremented by value I and Returns the old value of x and Returns the old value of x it is used in the pseudo code shown bu to implement a busy weight lock L is assigned integer unassigned integer and shared variable initialized to zero the value Z correspond to the lock being available if the value is zero which means the lock is available while any nonzero value correspond to the lock being not available non zero says the lock is not available Zer says lock is available okay so acquire lock while Fetch and add L comma 1 initially let's say the value of L is set to zero initially the critical section is free what it will do Fetch and add l so what is going to do L increase the value of L by 1 so now what will be the value of L the value of L will be 1 and in the next instruction it says set the value of loog to one set the value of loog to One release loog so this was the end entry section and this is the exit section so to release loog set the value of loog to zero so what are we doing here while Fetch and add it is going to increase the value of loog by one and then in the next line we are setting the value of loog to one okay so what does this entry section make it will make the program it will make the process busy weight if L is greater than zero so if L equals to Z CR section is free if L is greater than Z CR section is not free so if L is greater than Z then it will busy weate and why we have written Lal to 1 here that you have to figure it out why we have written Lal to 1 so so in log while one Fetch and add and n% log one so this is atomic returning the value of log and and increasing the value of block by one will be done atomically and then L equal to 1 why are we doing this figure it out so these are the problems which you have to solve so the first problem is we have set the value of Lal to 1 if this would not have been there then the value overflow would have been occurred how value of overflow would be occurred if L is not one figure it out the second problem is does this provide Mutual exclusion does this piece of code provide Mutual exclusion the third is can it be possible after a moment that no one can go to the critical section can it be possible that lock is one and critical SE critical section is three what I've said in the beginning if lock is zero then critical section is free if Any number greater than zero then not free but is it possible that the value of lock is one and critical section is free starvation from some starvation for some process is it there so you have to figure out these five questions this is an amazing amazing problem give it a Time solve it and if you are able to solve it correctly give yourself a nice trck because this is a difficult question this requires presence of mind this requires logic so in the last lecture I've given you a problem to solved this was a nice and interesting question before solving this let's first revise some some of the synchronization mechanism properties so the lock variable and District alternation are just the opposite lock variable doesn't provide Mutual exclusion and bounded waiting while stct alternation provides lock variable provides progress but stct alternation doesn't p and Decker are complete TSL and swap they provide Mutual exclusion and progress but fails to provide bounded waiting but an additional logic tsln swap also provides bounded waiting so it depends in which context we are talking about so now we will move on to the question we have been given a function fetch an add which Returns the value of x and increase the value of x by I and this was the enter section and this was the exit section now the first question if you remember was what will happen if Lal to 1 wouldn't have been there wouldn't have been there so for that case let's trace this initially the value of log is zero it goes there what it will return it will return zero and increases the value of log by one so now the value of log is one remember this while zero it will not get entered into the loop it will escape this condition goes into the critical section okay now the value of lock is one for another process when it will go there while fetching at lock what it will return it will return one and increase the value of loog by 1 so initially the value of log was zero so 0 was returned and then it was increased to one now for the second time when this will come here the value of log is one so one will be written and it will be increased by 1 so now the value of log will be 2 for the third time when it will come two will be returned and it will be increased by 1 three four time four will be returned and it will increase to I hope you are getting the point so this will happen only when L = to 1 is not set there okay so this will only happen when Lal to 1 is not present but if Lal to 1 is present then this overflow wouldn't have been there let me repeat for the first time lock is zero goes there what it will return zero escapes the condition goes into the critical section for the second process when it comes what will the value of lock see when the first time when the value of lock equals to0 was return it was also increased by one so now the value of lock is one if the value of lock is one it will return one and increase the value of loog by 1 so now the value of loog is two and we have assumed that Lal to 1 is not present goes again returns two and increase the value of log by 1 now three goes again returns three increase the value of log by one now the value of log will be four goes again returns four increase the value of log by one the value is five so this cycle will keep on going on going on and going on until the value overflow would be there okay so I hope you got the point how Lal to 1 is saving the overflow now we we are taking the case when Lal to 1 is present then what will happen initially L equal to 0 it returns Z change the value of log to one goes into the critical section for this another process now the value of loog is one is returned and then the value of loog is increased by one so now the value of loog is two but it will also go there in the loop in the loop condition so Nal to 1 is set so value of two will be set to 1 so by writing this C equals to 1 it will keep on oscillating between 1 and 2 okay so I hope you got the point how Lal 1 is saving the Overflow if Lal 1 is not present the value overflow will be there if Lal to 1 is present the value of log will oscillate between 1 and two I hope you got the idea now the second question does it provide manual exclusion so let's check Suppose there are three process in the RQ P1 P2 and P3 okay critical section initially is empty and the value of log equals to zero for the first time okay now what happens P1 at the time T1 goes try to go into the critical section so fa AA is the Fetch and add log initially the value of log was zero so it will return zero and will change the value of log to one okay so it has all passed the conditions now it can easily go into the critical section so it will go into the critical section and there it get preempted okay so now P1 is in the critical section it has not completed the critical section but before it got preempted and the value of log is one now at time T2 let's say P2 also want to enter the critical section goes to the fion add log what it returns it Returns the value of log one and changes the value of log to two and then what will happen in the v you you remember that we have set the value of log to one so the value of log will be set to one and then when it goes again to check the condition the value of one will be return return and log will be set to two and then again so it will busy here it will busy here loog will be one initially the loog one will be written the value of log will be changed to two and then when this statement will be executed the log value will be back changed to one goes again the value of 1 will be returned 2 1 2 1 this will keep on going on so this cycle one will be returned increase to two again set to one one will be return increase to two so this will keep on going on it will busy wa now let's say at time T3 P1 comes again completes the critical section and it will execute the exit section and what was in the exit section L equal to 0 so it will change the value of log to 0 at time T4 P2 wants to go again so it P2 goes to the Fetch and add lock so now the value of lock is zero so fetch and add lock loog will return zero increase the value of log by one now what is the value of uh log log is one and the value of log which was return was zero so it will not get stuck in the busy weight it can easily go into the critical section completes the critical section and again set the value of L to zero to show that now the critical is free so I hope you got the idea that overflow is not possible and it also guarantees Mutual exclusion okay it it was easy so question in question B was easy now let's check question C can it be possible after a moment that no one can go to the critical section can it be possible so let's see that at time T1 let's say P1 wants to enter the critical section initially the value of log was zero so it will return zero and will change the value of log to one goes to the critical section and then get preempted now at time T2 P2 wants to enter into the critical section the value of log was changed to one so it will return one and will increase the value of log to 2 now what happens is it gets preempted before it could set the value of log to one so let me show it here so this was all these statements were executed but here it got preed before it can set the value of log to one so we are solving the question can it be possible after a moment that no one can go to the critical section for that case we are preempting before it could set L equal to 1 now what will happen see so here is a general observation Whenever there are two statements in entry section preempt after one to get good inferences so I have told you several times Whenever there are two statements in the entry section so there were two statements preempt after one preempt here to get good inferences and here we have got also so now the value of lock what is the value of lock now the value of lock is two okay so at time P1 at time at time at time T3 P1 was there in the critical section if you remember P1 was preempted while it was in the critical section so P1 was in the critical section what it do now it completes the critical section change the value of log to 0 and leaves okay P1 has done all all its work now at time P4 P2 comes back P2 comes hold of the CPU it start executing its instruction so which instruction it will execute it will execute Lal to 1 it will execute lals to 1 fet and now what will happen see P2 has executed this instruction so it will go again and check the condition so it will go again and check the condition it will go again and check the condition what fetch ad log will return it will return one and it will increase the value of log to two so you got the idea it is busy waiting now so it is busy waiting is there anyone in the in the critical section no no one is the is in the critical section P1 was present in the critical section but it has completed all its work work it has left the critical section no one is present in the critical section but when P2 came it itself changed the value of log to one and you should remember the value of log equals to 1 represent that the critical section is not free but in reality the critical section is free no one is present so this is something wrong here P2 should logically go into the critical section because critical section should be free P1 when it when it was leaving it has changed the Val of log equals to0 which imply that critical section is free anyone can go into it but what happened P2 changed the value of log equals to one so this is something like this P2 without entering into the critical section has said to everyone has has told everyone that critical section is logged but actually inside no one is in the critical section so P2 should logically go into the critical section but it failed critical section is free the value of log is oscillating between 1 and two but no one is able to go into the critical section let's let's say at another time P3 P3 will always busy weit because lock is not equals to Z afterward so this is something stuck see no now what is the situation no one can go into the critical section critical section is logged into from inside so this is similar to the room which is logged from inside and no one is present in there also so that similar case have been occurred so have you noticed something there will be so many processes which can be preempted after increasing the value of L so this this may also this may also be the case so what I have said preempt before it can set the value of log equals to one so this is similar like a process one come process one came increase the value of log by one and fail to set the value of log equals to one process two came increase the value of loog by one process three came increase the value of loog by one and all of them all of the process failed to set the value of lock equals to one so each and every process will come increase the value of Lock by one come increase the value of Lo by one come increase the value of log by one and eventually what will happen if the value of log will keep on increasing and increasing and increasing what will happen overflow so this is the similar case so here overflow will occur so there will be so many processes which can be preempted after increasing the value of L so overflow may happen let's say the let's say the integer is of two bytes we are taking the 32bit architecture so let's say the integer value is of 2 by so the maximum value possible is 32,767 so if the number of process are less than this number then this mechanism will work correctly but if the number of process are more than the size of integer you know what will happen overflow okay so this was the case now we have done this question this question and this question now uh fine a fine question can it be possible that a loog equals to 1 which means the critical section is logged no one can go into it until it is the lock is released so can it be possible then critic that critical section is logged and also it is free log equals to 1 and critical section is also free can it be possible so we have already seen that it is possible here in the case lock was one lock was one and critical section was also free because no one was in the critical section P1 has already left the critical section but what happened that P2 when it came it by mistake set the value of lock equals to 1 so this was also done starvation for some process does some process starve obviously the process will starve so now I have important note I have important note for you that unless special focus is given to exceptional case think generally so one of my student come to me and ask this question which of the following algorithm suffers from starvation so I told him that sgf and priority will be the answer but he also said that fcfs should also be there because in some rare cases fcfs also suffers from starvation so I have given me I have been given the solution Manual of of galin textbook exercise so what happened I show in the answer of the actual the authorized authors the galin so there it was given that fcfs doesn't suffer from starvation it inherently doesn't suffer from starvation except the case for infinite Loops so until a special focus is given to exceptional case we should always think generally for this question the answer will be sgf and priority not the fcfs now comes to the blocking mechanisms or non busy Solutions so in the entry section we have a while loop we are talking about the busy Solutions so why busy Solutions were not preferred so in the entry section we have a while loop so have you ever thought how it sus for the CPU to check condition again and again again and again even if in the one check we get an idea that critical section is free or not so this this this V condition is the vage of CPU time in form of Loops so the process in just one check it can get the idea whether critical section is free or not why it has to busy wait until the time Quantum expires why is it so it is wasting its's time so to tackle that we got an idea that the process should test the condition only once if the critical section is free you are free to enter go into the critical section if not it should immediately get blocked it should immediately release the CPU and should get blocked let's let me explain suppose P1 is present in the ricu P1 goes to the CPU start executing the ENT section in ENT section in just one check it get an idea that critical section is not free someone is already present there let's say P2 so what it will do it will immediately release the CPU and should get blocked so that the other process present in the critical section that is P2 should take charge of the CPU so the P2 comes into the CPU start executing its remaining instructions of the critical section so that it can quickly execute critical section come out execute critical execute the exit section and unblock the blogged process let me tell you the story again there were two process P1 and P2 P2 was already present in the critical section okay so P1 wants to also go there P1 goes to the CPU start executing the instruction of Entry section in entry section in just one check it got an idea that critical section is not free P2 is already present there so what it will do it will immediately leave the CPU why so that P2 can complete it critical section see it is a winwin situation for both P1 cannot enter into the critical section until P2 leaves the critical section because only one process can be present in the critical section so P1 wants to to go into the critical section as soon as possible but it will it can only be it will only happen when P2 completes the remaining section of the critical section so instead of busy waiting again and again checking the condition again and again wasting the time of P1 and P2 both why shouldn't it get blocked and let P2 get charge of the CPU so that it can complete its remaining instructions when P2 completes its remaining instructions P1 is also getting benefited because P1 when P2 quickly execute the critical section P2 will come out execute the exit section and will unblock the blocked process so P1 was blocked it will unblock P1 hey even now you can go into the critical section it is free so this is the best case for busy waiting we have used while and in non busy waiting we will use if then else in while what will happen we will go again and again check the condition again and again if then else will only work once condition true then block if false then enter simple and easy so for this blocking mechanism we have three things sleep and wake up SEMA force and monitors so first learn about the sleep and wake up sleep and wake up it is a blocking construct based on the blocking mechanism or non Business Solutions it is a multiprocess solution and it behaves like an primitive like system call which means it is non preemptive no one can preempt it in between it's Atomic so let me tell you the story when the process executes sleep it gets blogged into the Sleep que a new name sleep que till some other process wakes up so let's take this scenario P1 was present in the RQ goes into the CPU start executing the entry section but what happens it checks that P2 is present in the critical section already it goes execute the sleep function sleep function will put the P1 into the Sleep Q so P1 will release the CPU immediately and P2 will take the charge now what happens P2 is in the CPU it completes the remaining instruction of the critical section and exits the critical section now it will exit it it will complete its exit section in the exit section what it will do it will wake up P1 so from the Sleep Q it will put P1 back to the RQ now P1 can go into the CPU do the same thing again checks the ENT section now critical section is free it can easily go into the critical section so this is how sleep mechanism work instead of being there in the CPU checking the condition again and again wasting the time of itself and also P2 it get blocked and let P2 completes its critical section when P2 completes goes to the exit section P2 will put the P1 back to the radic from the Sleep Cube now in the r CU P1 can go check the condition critical section is free and P1 is free to enter critical section so this is how it work now we will see the producer consumer problem but with the non busy solution we are going to do we will convert the busy waiting solution into the non busy waiting solution so what we are going to do we will make the consumer sleep when the buffer is empty and make the producer sleep when the buffer is full okay okay so we are not going to check the condition again and again wasting the time what we will do we will simply check if the buffer is empty consumer go to sleep buffer is full producer go to sleep now it is the duty of producer and consumer for producer to wake up the consumer and for Consumer to wake up the producer process so producer process will wake up the consumer when the first item is placed before that it might be sleeping so and the consumer will wake up the producer when the first item will be consumed so consumer will wake up producer when an item is consumed from the full buffer before that it might be sleeping so these are the four point that you have to remember now let's go to the code so this these were the global variables which we have defined void producer producer in item P item P will be the produced item and initially in was zero so do you remember the producer consumer process in the buffer there are these are this was the bounded buffer and we have two pointers in and out in will be the index of next empty slot for the produced item to be placed and out will be the index of the first empty slot first filled slot the slot from where the consumer can consume so in Empty Out full in is for the producer out is for the consumer I hope you remember that item P so we'll place the produce item into the the item P variable if count equals to equals to N Sleep If count equals to equals to n what does it mean that the buffer is full if the buffer is full no need of producer just go to the sleep if it is not so then place the produced item into the buffer at the empty slot and increase the value of empty slot by one and if it is if it is the last slot then do the circular thing that's why mod n so if this is the last not then go there place it here okay increase the value of counter by one but why because an item is placed and in the end if count equals to one wake up the consumer see we have to wake up the consumer when the first item is placed if the count equals to one which means the first item is placed we have to wake up the consumer let me repeat again declare a variable item P place the produced item at item P if count equals to n which means if the buffer is full make the producer sleep if it is not place the produced item into the buffer increase the value of n by one increase the value of count by one and if the count equals to one which means the first item is placed then we have to wake up the consumer because before that it might be sleeping similarly for the consumer code item c will be the item that will be consumed so if the count equals to zero which means the buffer is empty then there's no need for Consumer to wake up so it just go to the sleep because buffer is empty it cannot consume from empty buffer if it is not then item c will be the item at the buffer so from the out it will consume an item C out will be increased by one and count will be decreased by one see let me uh give you a pictorial representation let me check if it is recording yes okay so let's say the initially the value of count is zero so the consumer will go to sleep producer produce an item and it wakes up the consumer consumer got waked up now let's say this was the item C so the buffer do out this was the first item placed by the producer consumer is now ready to consument so item c will be equals to buffer. out so this will be the item C now we have to increase the value of out plus out plus one so now the out will be this consumer has already consumed this item so we have to increase the value of out if it is the circular case just for the producer just like the producer we have to do the circular thing if it is the last uh item if it is the last item in the buffer then it has to go again to the first item so that's why more than and we have to decrease the value of count because a item is consumed okay so I hope you got the idea now last thing if count equals to n minus one from the full buffer from the full buffer if one item is consumed now what is will be the number of items n minus one full buffer is n items one item is consumed so the item will be nus one so if count equals to n minus1 from the full buffer one item is consumed we have to wake up the producer because before that it might be sleeping and then consume item C see these four things are the main make consumer sleep when the buffer is empty make producer sleep when the buffer is full wake up consumer when the first item is placed wake up producer when the when an item is consumed from the full buffer okay so this was the code now we will analyze it in the next video Let's analyze the solution which we have discussed in the last lecture I have told you so many times Whenever there is more than one statement in the intersection preempt after one let's say there are two statements preempt after one preempt in between that will this will give you so many nice inferences let's check here this is an very very very interesting case Okay so focus and listen there's a cooperation and competition both so is there any possibility of Deadlock or inconsistency let's see so this was the entry section I have told you to preempt here if I preempt here before a process can go to sleep what will happen let's see so I have taken a small buffer of three things of three slots 0 1 and two and initially the value of count is zero n is equal to 3 there are three slots okay so n equal to 3 now what happens at time T1 consumer comes if count equals equals to Z yes count equals to Z initially the count is zero no item is in the buffer so what it has to do it has to make itself sleep but what happens before it can make itself sleep it get preempted here so whenever it will come back it will go to the sleep so whenever process come back whenever consumer get hold of the CPU it will start executing from the next instruction and what is the next instruction sleep so whenever it will come back it will go to the sleep at time T2 producer comes does count equals to n no count is not equals to n count is zero and N is three so it will produce its first item place it in the buffer increment the count now count is one if you remember if the count is one the it is the duty of producer to wake up the consumer so if count is one it will wake up the consumer but consumer never slept so producer will think it has done its work it has done its duty of waking up the consumer but the consumer never slept so what producer will do it will goes back and repeats this until the buffer is full producer will keep on producing item and item and item until the buffer is full buffer is now full X Y and Z these items are produced now count equals to three which is equals to n so if count equals to Wi yes then go to sleep producer goes to the sleep now producer go to The Sleep producer goes to sleep now consumer will get hold of the CPU what consumer will do it will execute it next instruction that is sleep producer goes to producer is already in the Sleep queue consumer also comes in the Sleep queue see this is a very dangerous situation producer will think that consumer will wake her up consumer will think that producers will wake her up and they are both sleeping comfortably in the Sleep ke so this is the case of Deadlock so here I have said producer goes to the sleep thinking that consumer will wake her up as soon as she consumes an item but producer doesn't know that consumer is also going to sleep so both the process are sleeping comfortably with assumption that one will wake the other so this is the case of Deadlock so yes deadlock is there and is there any case of inconsistency yes inconsistency is also also there because producer and consumer tries to update the value of count simultaneously so this is similar to the race condition so what is the solution of this problem this is a very very nice problem that both have gone to the Sleep Queue at the same time producer will think consumer will wake her up consumer will think producer will wake her up and they're both sleeping this was the case of dead dog and and for the inconsistency they tries to update the value of count simultaneously like the is condition p p tries to increase so this is just a case let's say the value of count is five P tries to producer tries to increase it and consumer tries to consume it so the value should be five but we get the answer like six and four I've discussed this so many times this is the race condition so what is the solution of this the solution is SEMA 4 and this is what we practically use we are going to learn more about SEMA 4 in the next lecture let's see what is semap 4 it is a practical inuse tool we use it practically most famous blocking construct OS based that is component of operating system Cal which means the operations are Atomic in nature general purpose utility which means it is used to solve several problems like critical section problem classical IPC problems and concurrency mechanisms it is implemented as an abstract data type like we used to do in the process thing process was also implemented as an abstract data type which has its own implementation and it has its own operations so what are the operations involved in semaphore the first is down and the second is up the down operation what does it do it just decrease the value by one it is also known as weight or p and what does up suggest it suggest it will increase the value by one it's also known as signal or V okay so what is the definition definition SEMA 4 abstract data type that takes only integer values remember this it only takes integer values and for integer value it can be classified into two binary SEMA 4 and Counting SEMA 4 binary SEMA 4 as the name suggest takes only two values Z or one it is also known as MX and Counting seor takes any integer value and it is also known as general semap for so we are going to first see the counting semaphor that is sm4 and the values it take is from minus infinity to plus infinity this is how it it is represented typed F struct int values Q Type L counting sem 4 so the counting sem4 consist of two things the first is it is a structure and it is named as counting S 4 which has two things the first is the value and the second is Q Type L and what does this Q type contain it contains the list of PCV of those process that gets blocked while performing down operation unsuccessfully so what is unsuccessful down operation we are going to see in a few minute so this thing this is Kernel mode and this is user mode so after defining the variable we have to mandatorily initialize it and the initialize value will be it depends on the application whatever value we initialize similarly or accordingly it will work so this means will depends upon application so let's say we have said the counting semap 4 S do value is one so we said the value is one if we perform the down operation then what happens then again it goes to the kernel mode as I said the operations are Atomic in nature so the down operation so this we did the initialization or the Declaration kernel mode setting the values user mode and Performing the operation again on the kernal mode so what does down operation do it decrements the current value of s that is the SEMA 4 so this was s do value we declared a sem 4 accounting SEMA 4 S and we set the value equals to 1 now we are performing a down operation on that counting S4 s so what does a down operation do it decrements the current value of sem 4 S by 1 so what was the value initially it was one so s do Val equal to S do valus one we say that the result is either successful or unsuccessful if it is successful it goes to the next statement if it is unsuccessful it's blogged in the Q so this was I was talking about Q Type L it contains the list of pcbs of those process that gets blocked while performing down operation unsuccessfully so I've said while performing down operation two things can happen either it can get performed successfully or unsuccessfully if it is successfully performed we go to the next statement if it is unsuccessfully performed we are blocked in the queue which Q This Q Type L ql okay so this is the next thing now the question arises how to identify whether we are blocked or unblocked whether the operation was successful or unsuccessful so if S4 do value is negative put the process PCV in the Q that is the Sleep Q and block the process s DOL is this is the Q name you can see here we declared accounting S for S so s DOL this is the que so we will put the process in the queue and block the process which means it's sleeping now else return to the next statement okay so how we get to know that the operation was successful or unsuccessful if the value of counting sem4 becomes negative then it is unsuccessful if the value if the return value is positive or greater than or zero if it is positive or zero then it is successful if negative unsuccessful if positive or zero successful okay now comes the question if we set the value equals to 5 how many down operations can be carried out successfully if the value of count4 is set to five how many down operation can be performed successfully so what we did we start decreasing the value by one so at five We performed down operation successful four how we know it was successful because the value is still positive we decreased it one down operation four another down operation three another down operation two another down operation 1 now let's let's perform another down operation another down operation it is zero now is it successful yes what I said if it is non negative then it is successful it doesn't depend whether it is zero or positive if it is non negative successful so five down operations were successful let's perform another down operation now the value is minus one now we can say the value became negative hence it is unsuccessful okay now another process came and performed another down operation another down operation it becomes minus 2 again unsuccessful so this the process which perform down operation on this and the process which perform down operation on this both get blogged so the number of blogged process are two so there are two process in UL suppose another process which came and performed down operation on this so the value of s will be minus 3 and number of blocked process will be three I hope you got the idea okay so positive value of the SEMA 4 indicate that those many down operations can be performed successfully so what was the value of 74 here s = to 5 so we performed five down operations successfully and after that process starts getting blocked we can also observe another thing here let's say when the value of sem 4 was min2 how many processes were blocked two processes were blocked let's say another process came and performed down operation now the value is minus 3 how many process are blocked now so the process which performed down operation on this did an unsuccessful down operation so this process will also be blocked so the number of blocked process will be three now when the value of 74 was minus 3 so a thing we can notice when it was minus one then one process was blocked when it was min2 two process were blocked when it was minus 3 three processes were blocked so we can give two inferences here positive value of the sem 4 indicate that those many down operation can be performed and after carrying out a series of down operation if the value of SEMA 4 becomes negative then the magnitude of the negative value indicates get the number of blogged process so I hope the point is clear so the first thing says if s equal to 5 these many down operations can be performed and after performing a series of down operation if the value of sem4 let's say is minus 8 then we can say 8 process 8 process are blocked eight process are residing in the ql okay so now let's check another thing so this was the radue now out of these ready out of these three process some process will enter into the entry section so let's say a process enters into the ENT section performs the uh instructions in the ENT section goes to the critical section P1 goes to the critical section and then completes the exit section and then goes out so by doing this what we do how does this sem4 thing how does the sema4 provides Mutual exclusion we are going to see that so out of these three process a process came and performs the ENT section and in ENT section what we do we decrease the value of S 4 by one so initially let's say the sem4 value was X so X down operation can be performed successfully when X becomes zero then the number of let's say uh three down operations will performed so all three process will get blogged okay and let's say the value of initially let's say the value of x was three so 1 two three three down three down operations can be performed successfully so all three process will be successful in performing down operation and they all will enter the critical section are you getting the point let me explain more clearly so initially let's say the value of sem 4 was one only okay P1 got the chance to get hold of CPU and it start executing the instructions of Entry section what is the instruction in the entry section P of s which means down operation of on S so what is the value of s one so it will perform down operation and now the value of s will become zero nice okay it will go into the critical section P1 is still in the critical section and somehow it got preempted now let's say P2 get the chance P2 goes to the entry section will perform a down operation on S equals to0 if s equals to 0 then down operation will be minus one and I hope you remember that if the value of down operation after performing the value of down operation if the value of s is negative then it is an unsuccessful down operation and in the case of unsuccessful down operation we block the process so the process P2 will get blocked it will it won't be able to enter into the critical section same case for the P3 let's say P3 also attemp to go into the critical section so what was the value of s it was minus one it performs another down operation it becomes minus 2 which means two process now P3 is also blocked two process are blocked and only P1 can complete okay now let's see P1 was in the critical section P1 get again chance to get hold of CPU see it start executing the remaining instructions of critical section completes the critical section now V of s what is V of s it is the up operation so what P1 will do it will perform an up up operation so s equals to from minus 2 it will perform an up operation from 2 to 1 what does minus one suggest it suggest that only one process should be blocked so it will wake up another process let's say P2 is waked up now what will P2 do it will start executing from the next instruction it has already executed this so the next instruction is just the critical section it goes to the critical section happily now when it comes out it will perform the up operation when it will perform the up operation this minus one will become zero what does this suggest it means P2 will wake up P3 also P2 exits the exit section now it's turned for p P3 P3 will again resume from where from the next instructions so it will it has already completed this it will go directly in the critical section P3 comes out what does it will do now it will increase the value of S 4 by 1 so one so this is how sem 4 provides Mutual exclusion if one process in the critical section is present then no other process will be able to go into the critical section if they try they will get blocked and they will will be awaken or they will uh come out of the blocked que only when some process completes their exit section so I hope you got the idea let's read this thing also so when P1 was in the critical section and P2 and P3 tries to go into the critical section then they get blocked in the ql and it is a f4q generally so the basic objective of up operation is to wake up a sleeping process so s = to min2 when the up operation was performed it was minus one so what does this suggest P3 is sleeping now and P2 is awake and P2 is awake then it will go to the Rue as you have as you have studied that from the blocked que we go to the RQ so it goes to the RQ and then it will start executing from the next instruction what is the next instructions go to the critical section okay as it has already completed its entry section so what does up operation we have studied the down operation what does up operation look like up on counting sem4 s increase the value by 1 if the value is negative if the value is negative or equals to zero select a process from sleeping que and wake up else return so it is the duty of up operation that if the value is negative or equals to Z then it has to wake up a sleeping process okay so this is what we had done here when the value was increased when the value was increased from 2 to 1 up operation has awaken P2 and when the value was increased fromus 1 to 0 up operation has awaken P3 okay so this is how it work so when P1 is performing up operation indirectly it wakes up P2 and put it into the critical section and when P2 performs up operation it wakes a P3 P3 goes to the Ric and then critical section and then again it performs the operation and for that case for that case when performs the up operation the value is now one see for P3 what was the value for P3 s was already zero so when P3 has completed the exit section which means P3 will perform an up operation on zero so what will be value now one so P3 has performed up operation the value is now one is the value if the value is negative or equals to Z no it is positive so it will not perform the waking up of any process if s equals to Z and then up up operation is performed on it then the process will not wake any process why because there is no process in the slip que because the value of s equals to Z suggest what there is no process in the slip CU and this is what we had written here in form of condition I hope you got the idea so no wake up call if s do value is positive if s equals to Z I have to wake up one more process if the initial value of s was one so mutual exclusion is violated here are you understanding it if the value of su 4 was not one if the value of sem4 was not one see here if the value of sem4 was not one then Mutual exclusion will be violated let's say I put the value of S 4 S2 so what does s = to 2 suggest it means two process can now go into the critical section simultaneously let me show you let's say the value of S4 was 2 P1 comes decrease the value by 1 P1 goes to the critical section let's say P1 get preempted here P2 comes decrease the value by 1 now it is zero see both P1 and P2 has performed a successful down operation so no one is stopping P1 P2 also to go to the critical section so at the same time P1 and P2 are both present in the critical section so this is how Mutual exclusion is violated if the value of sem4 is greater than one okay so this is how semor works this is how the ensures Mutual exclusion in the next lecture we are going to see some of the basic problems of uh up and down operation now let's discuss some super easy questions in the initial value of counting SEMA 4 is 8 and we have to perform these operations what will the final value super easy this is down operation p is down operation and V is up operation for down operation you do nothing but to incre to decrease the value by one and for up operation you increase the value by one so for this what can you do 8 10 + 1 5 + 2 6 + 3 what will be the value you get you get 7 and what does 7 signify it says that there are 17 process blocked in the Sleep G another question counting sem4 what will be the initial value of counting sem4 such that after performing these operations up and down the final value which I get is minus 6 super easy you can do this by two ways either you can make an equation like x 12 + 4 6 + 3 8 + 1 should be equal to 6 you can do do like this or you can just think like that let's say we started with 6 and instead of doing down operation we what we did we did up operation so it's nothing just we started the opposite thing minus 6 for up operation we added and for down operation we subtracted so in this way we get the final value as 12 you can do that from the both ways or directly saying this is the same thing which you did in the equation also okay so the final value which you got is 12 which means if the initial value of sem4 would have been 12 then after performing these series of down and up operation we get the final value as Min 6 another question question consider a non negative counting S 4 S the operation PS decrements s and vs increments s same thing during execution 20 PS operations and 12 vs operations are issued in some order okay the largest initial value of s for which at least one PS operation will remain blocked so for at least one PS operation that remain blocked in the end the value of SEMA 4 in the end should be less than or equal to minus1 for at least we have written this less than or equal to minus1 for exactly one operation one PS operation to remain blocked then value should be minus one and for at least one then value should be less than equal to minus1 so what we did we take the initial value as X so X and how many down operation 20 so x 20 how many up operation 12 + 12 = to S and that s should be less than equal to 1 after performing calculations we get the value of x should be less than equal to 7 so what will the largest value 7 Easy Peasy okay let's see the practical application of sem4 how it is used in Practical life Suppose there is a client server architecture there are several clients and server can manage only 100 request at a time and there are so many clients that they are sending 5,000 request so if all the 5,000 request reach at the server how does server is going to manage them so this problem can be solved using counting SEMA 4 which ensure that only 100 or th000 requests so whatever be the number 1,000 request go and rest wait so what we did we set the value of s equals to 1,000 try to set an analogy or try to set a connection see in the case of process and critical section whatever be the value we set that number of process can go into the critical section here we said that if s equal to 2 then P1 and P2 both can go into the critical section if I said s = to 1 only then only P1 was able to go and rest two of them were blocked similarly think that there are 5,000 processes and it is feasible that only thousand of them can go into the critical section so for that case what should be the value of s so the value of s should be set to th000 so this is how so these processes can be set as clients and the critical section can be sent as server I hope you got the idea so how to set that only thousand process should go into the server so this can be solved as setting the value of counting some of 4S th000 so every request will perform a down operation on S and after it gets served it will perform up then so this is how this will work so when th000 down operation will be performed or when th000 request will go to the server for uh servicing then 1,1 request will be blocked because the value is set to, so this is how it works okay in the next lecture we are going to see binary SEMA 4 Counting sem4 is complete now so we should make a revision so how does counting sem4 work type def instruct what is the use of type def to give it a name so we give it a name as counting se4 so counting se4 is two things values and Q the value mean what is the initial value of counting sem4 let's say for the client server architecture the initial value was 1,000 okay so this uh declaring is done in the kernel mode setting up the value initializing is done in the user mode and we have to mandator initialize it let's say we initialize that to th000 so th000 process can go into the critical section so it has two operations the first is down and the second is up for down operation what you have to do you have to decrease the value by one and after decreasement if the value becomes negative then we have to put the process into sleep Q else go to the next statement and how we get to know that the process is process has performed a successful or unsuccessful down operation the down operation is successful when the value is non negative and it is unsuccessful when the value is negative okay so we have seen everything how it is ensuring Mutual exclusion and then we will see up operation and what you have to do in up operation increase the value by one if the value is less than or equals to zero which means we have to select a process and wake it up from the sleeping quebe otherwise else return okay let's start the binary semap 4 binary semap 4 can takes only two value either zero or one so how it is declared type def struct type def for BM because we want to rename it and struct because it is a structure which contains two things just like the CM now we have to use enum why enum because this variable value of type enum can take only two values either zero or one it is a binary semore and it can take only two Val vales either 0 or 1 it has a sleep que similar to the counting semap 4 which contains the list of all those processes PCB which fail to perform perform an successful down operation okay so while performing down operation there are only two possibilities because the value of s can be either Z or 1 so when down operation is performed on zero the value will still remain zero it won't become minus one because it is a binary semap 4 so the value will still remain zero and it will be blocked but if the down oper operation is performed on one the value will become zero and success it won't get blocked okay so there are only two possibilities while performing down operation you can get on zero the result will be zero but for one case the process will be blocked and for another case it will be successful user mode binary sem4 we have to initialize it we can initialize it from either zero or one if it is initialized to zero which means no process can go into the critical section if it is initialized to one which means only one process can be in the critical section at a time okay so we have to perform down operation and if the down oper operation is successful we go to the next statement so what is down operation down on binary sem 4 S if the value of s is 1 set the value to zero return else put the this process PCB in sleep q and block it so this is what we are doing while performing down operation if the value is one then set the value to zero return return where return to the next statement otherwise put this process PCB and block it what is the otherwise case this is the case if the value of s is not one which means the value will be zero if it is zero then block it if it is zero put this process PCB in the slip Cube while performing dou operation okay so it will never take negative values we won't know how many processes are blocked there okay so in counting semaphore when we used to do down operation the value of s keep on decreasing as I have said in the previous video uh in one question we get the value of s is minus 17 so we can easily identify that there are 17 processes sleeping in the block Q or 17 process blocked in the cing both are the same but here we can only see the value of s s either 0 or 1 if the value of s is z we cannot tell how many process are there in the sleeping queue because it won't take any negative values okay so let's see this scenario there are three process present in the radue and they are both eager to go into the critical section and they are all eager to go into the critical section let's say a process P1 gets a chance to get hold of CPU start executing the instructions of Entry section performs the down operation on S performs the down operation s now it becomes zero goes to the critical section is it still in the critical section but somehow it get preempted P2 wants to go into the critical section performs the down operation on zero and if the down operation is performed on zero what happens it get blocked so P2 is blocked now P3 comes what is the value of down what is the value of s it is still zero P3 comes to the entry section start executing this down operation but again when the down operation is performed on zero it will also get blocked so there are two processes blocked but the value of SEMA 4 is zero so by seeing the value of semor in this case we cannot tell how many process are blocked but this is somehow providing Mutual exclusion because when P1 was in the critical section P2 and P3 were unable to go into the critical section so what will happen P1 completes the instructions of critical section comes out of the critical section goes to the exit section and what and what does it will do it will increase the value by one so what is vs increase the value of sem4 by 1 so the value of sem 4 will be directly increased to one will this happen let's see let's see so if there is a process in either critical section or block Q the value of SEMA 4 must be zero must be zero if the process is in either critical section or block Q the value of S4 must be zero so how will up operation will be performed for up operation check if there is no block process then the value set value to one and and if there are block process in the block Q then wake up a process and send it to the critical section are you getting the point see let's say the value of s at some point is zero can you tell me by seeing this how many process are blocked in the uh sleeping queue can you can you tell me no it is not possible so how can you directly increase the value of s to one by performing up operation when there are still processes present in the sleeping queue you can't so we are going to check it first if there is no process in the sleeping queue what we are going to do we are going to just increase the value by one and if there are process present in the sleeping Q then what will will do we won't increase the value directly to one for up operation we will we are going to wake up a process from the sleeping key just wake up the process no need to increase the value of s okay so this is what we are doing here how will up operation will be performed if there is no block process then value of s is 1 if there are process in the block block you then wake up a process and send it to the critical section why we are sending it directly to the critical section because when a process get blocked it has already completed the instructions of the critical section and when it will come again it will resume from the next instruction what is the next instruction critical section so it will go directly into the critical section so this is how up operation is performed up on binary sem 4 S if sleep Q is not empty select a process from L and wake up and if it is empty select set the value of s to one so for performing down operation we had two possibilities if the value was Zero block it if the value was one decrease the value and success go to the next instruction But Here If s equals to Z again two possibilities set it to zero and when when the Q is not empty and select a process and wake it up if Q is empty set the value to one and remember one thing whether it is a case of binary sem 4 or counting SEMA 4 up operation is always and always successful for the case of down operation the thing of success and unsuccess is defined up operation is always successful down operation is somewhere sometimes successful and sometimes not when successful I've already told you so what does s equals to one suggest s equals to 1 says critical section is free and the Q is also empty and what does s equal to0 suggest it says a process is is either in the critical section or in the block Q okay so if s = to 1 and and some say let's increase the value or uh perform an unop up operation then the value will remain one only because it is a binary S4 it can take only two values either 0o or one so performing an up operation on one will result in one only it won't increase it to two because it is a binary sem4 okay for S = to 0 up operation if it is the first operation so if it is the first operation then it logically means that Q is empty what I'm saying here is the value of s is set to zero and up operation is the first operation which means that the Q is empty because it is just the starting of the thing so in that case the value of s will be directly set to one and the status is Success so the up operation will be always successful and what do s equal to one suggest critical section is free and Q is empty s equal to0 says a process is in either in the critical section or block q but if we are directly saying s equals to 0 we are performing an oper up operation what will be the value we cannot directly tell if it is the first operation then we can directly tell s equal to 1 because the Q will be empty and if it is not the first operation we have to see whether Q is empty or not then we will tell what will be the value when up operation is performed on zero okay you got the idea process never get blocked while performing up operation can get blocked while down whether it is counting or binary semop 4 I have already made this point this sleeping Cube which we are talking about here is dynamic of course dynamic because a process comes performs the down operation and get blocked if it is not Dynamic if it is not Dynamic let's say there are only two slots present process one came get blocked process two came get blocked p 0 was already in the critical section so P1 came get blocked P2 came get blocked now what will happen if the P3 come it should also get blocked in the same Q so for that thing we have kept this sleeping Q as Dynamic okay let us revise and then we will solve the question so for binary semap 4 it can take only two Val either 0 or one if the value is zero if the value is zero what does this suggest it says that critical section is not free or a process is in the sleeping Cube okay and if it is one it says critical section is also free and there is no process in the sleeping okay it has two operations just like the counting semor down and up but there their working is different in down operation there are two possib ities if the value of sem4 is 0 or one if the value of sem4 is zero and we are performing a down operation block the process which means what does zero suggest appro critical section is not free so when a down operation will be performed on zero which means a process is wants to go to the critical section when it is being acquired by some other process so what we have to do we have to block that process if it is one what does that mean critical section is free so just decrease the value and it is Success okay and how up operation will be performed if there is no block process if the Q is empty if the Q is empty increase the value by one and what does one suggest critical section is free and if the Q is not empty wake up a process select a process from the que and wake it up so this is how down and up operations is get performed now now comes a question binary sem 4 S is set to one initially and there are several or there is a series of up and down operation 10 down operation 2 up 18 down 3 up 4 down five up okay so what will be the value of s now you cannot directly do this 1 10 + 2 + 18 now you cannot directly do this we have to keep track of number of process in the block Q so how this will happen let's say s = to 1 and what we are doing we we are performing 10 down operation so what will happen there will be nine process in the block you see P1 process will be able to go into the critical section and P2 P3 till P10 will be blocked okay now what happens two up operations so for two up operation this P2 and P3 will be waken up by the process so P2 and P3 will be waken up and we are performing 18 down operations again so what will be the uh status of Q here P4 to P10 now 18 down operation so P4 P5 to p28 three up operation P4 P5 and P6 will be waken up so p7 to p28 now four up operations four up four down operations which means p7 p8 from p28 four new process will come and join this sleep que so p32 five five operations so p7 p8 P9 P10 P1 will be wck so from p12 to p32 these process will be in the sleeping so what will be the size of Q size of uh Q the size will be 21 and what will be the final value s = to 0 I hope you got the point how we are doing this let me explain again see we cannot directly do like this I hope you know why we can't directly do like this because this is a binary sem for it can take only two values either 0o or one so when s = to 1 and we have performed 10 down operations so P1 will be able to go into the critical section rest process will get blocked so P2 P3 and P10 will get blocked now we have performed two up operation how does up operation work we see whether the Q is empty or not Q is not empty so when Q is not empty the value remains zero but what we do we wake up the two process from the Sleep Q so we wake up P2 and P3 will be waken up P2 and P3 will be removed from on the sleeping quebe now P4 P5 till P10 is in the sleeping queue we performed 10 down operation which means 18 new process came and get blogged so these process came and get blogged now what we do we perform three up operation what happens the value is zero and the Q is not empty so we will select three process and wake them up P4 P5 and P6 will be removed and from p7 to p28 they will be in the sleeping queue four down operation four new process came and join this queue p32 five of operation five process will be removed from this queue p7 p8 P9 P10 P1 and from p12 to p32 they will remain in the Sleep C and what is the value zero okay and what is the size 21 and the value is zero so I hope you understand what is sem 4 how does it work what is counting SEMA 4 how up and down operation works both in counting and binary SEMA 4 why we cannot increase is the value of binary S 4 just like as we did in the counting S 4 so these were some basic things which you should know let's see if semap 4 provides Mutual exclusion bounded waiting in progress or not in the previous lecture we have seen that counting SEMA 4 with s equal to 1 or binary SEMA 4 provides Mutual exclusion okay now let's okay let's see again how does it provide a mutual extion just for the sake of revision first P1 goes to the critical section by changing the value of s from 1 to 0 okay P1 is still in the critical section but somehow it get preempted now P2 wants to go to the critical section so first it has to pass the entry section in entry section it has to perform down operation on S equals to0 the value will remain zero but P2 will get blocked similarly if P3 also wanted to go to the critical section it has to first pass the entry section and the value of s is still zero so when it will perform down operation what happens is P3 will also get blocked so if a process is already present in the critical section it has changed the value of s from 1 to zero and if some other process wants to go to the critical section at the same time then s = to0 will prevent them from entering because performing a down operation on S equal to 0 the value will remain zero but the process get blocked so this is how Mutual exclusion is ensured now let's talk about progress suppose P1 P2 and P3 were the three process present in the ricu P1 and P2 were the interested process and P3 was not interested to go to the critical section so I have told you several time that a process who is not interested to go to the critical section will never ever enters the entry section so P3 will never enter the entry section P3 will never perform a down operation on S so P3 will never bother P1 and P2 it will not become hindrance in the path of P1 and P2 if P3 is not interested she will not bother about us so in that case progress is also ensured let me repeat again Mutual exclusion is ensured because of value of s equal to Z if some other process tries to go they will get blocked progress will be ensured because P3 will never ever enters the entry section so it will never bother P1 and P2 okay now comes the interesting part let's check if P1 can enter into critical section again and again while other interested process are sleeping can it happen which means does it provide bounded waiting let's check so P1 P2 and P3 were the three process present in the ricq interested to go to the critical section okay P1 initially the value of s was one P1 goes to the ENT section section change the value of s from 1 to 0 present in the critical section now somehow it got preempted here P2 attempts to go to the critical section by first passing from the entry section but what happens from zero value will remain zero but P2 will get blocked so P2 is in the sleeping Q now P3 also attempts so P3 also performs done operation the value will remain zero but P3 will get blocked okay okay now P1 get the chance of CPU again it started it execution it performed the remaining execution of critical section goes to the exit section and then in the exit section what will it will do it will wake up P2 and put it back to the ricq okay by performing the exit section P1 is free now but it it is still in the CPU so what it will attempt it will attempt to go to the entry section again again P2 is in the ricq P3 is sleeping and P1 is in the CPU okay the value of s is zero now so when P1 tries to go to the critical section by first passing from the entry section what happens the value will still remain zero but P1 will get blocked because the value of s was zero so now P1 is blocked what happens P3 is sleeping P2 is in the ricu and P1 has also joined P3 so P3 and P1 are in the Ric are in the sleeping q and P2 is in the RQ P2 will get now chance of the CPU will start its execution from the remaining instruction from the next instruction so what is the next instruction the critical section itself so P2 will go to the critical section now so this is how we have preent prevented pre P1 to go to the critical section again and again if a process attempts to go to the critical critical section again it get blocked so this is how bounded waiting is also ensured and semaphor we are given with two semaphores s and t both initialized to one and two process process I and process J in entry section we have down on S down on T and here in process J we have down on T and then down on S for exit section up on T upon on S here up on S and then up on T so the question is does it guarantee Mutual exclusion and what about deadlock okay so for that we has to preempt somewhere in C and I have told you several times that whenever there are two statements in the entry section preempt in between so you remember the note so we going to preempt here initially the value of s is one and value of T is also one so let's say the first process I tries to go to the critical section goes to entry section down on S the value of s is now zero preemption process J comes down on T tal to Z okay preemption now process I again down on T the value of T is already zero so when it perform down on T process I will get blocked now it is the chance of process J down on S the value of s was already zero P process J will also get blocked so if preemption occurs here in the both process and then the other process continue from the next section both of the process gets blocked and there is no one to wake them up because in sem force it is the duty of other process to wake the sleeping process and here both the process are sleeping comfortably who is going to wake them up so this is the case of Deadlock so when preemption happens here Pi will be blocked and PG will be blocked too is deadlock present yes deadlock is present now the question is does it guarantee Mutual exclusion let's see so first what happens the case is again from the starting s = to 1 and T = to 1 process 1 goes to the critical section change the value of s to 0 change the value of T to 0 goes to the critical section somehow got preempted before it can complete the critical section now it is the chance of process J to go to the critical section attempts down on T get blocked so if a process is already present in the critical section the other process can not go so does it does it guarantee Mutual exclusion no it is not possible you can preempt anywhere in check Mutual exclusion is present and Deadlock is also present so deadlock is there preemption between the two of the down operations now the question arises if I preempt between these two down operation deadlock happens can something be done that even I preempt after the first instruction that headlock is saved can something be done think about it pause the video think about it can something be done yes the sequence of both the process performing down operation should be the same in above question the sequence was reversed that was the case when deadlock was occuring let's see if the sequence of both the process performing down operation is same so we are taking the case this to thick m p of s p of T and here P of S and P of T not changing the sequence now when s = to 1 comes to this it changes the value of s to0 we are preempting here now it is the chance of process J process J again start with performing a down operation on S the value of s was already zero so this process will get blocked I hope you are getting the point deadlock was occurring because the sequence was different if the sequence was same PS is PS will will perform the down operation on S and then process G when tries to do the same it gets blogged so this is how deadlock can be preempted if the sequence is different okay so this was a nice question let's move to the question number two byus semor s = to 1 and tal to 0 so now we have two sem fores s and t the value of s is initialized to 1 and T to Zer there are two process process I and process J okay this is the critical section and these are the entry section entry and exit section respectively entry and exit section respectively okay so the question is what is the regular expression that gets generated when these two work concurrently suppose firstly process I wants to go to the critical section p on T which means if the value of T is set to zero it is necessary that process J should start first because if process I tries to start first it gets blocked so process J will start first s = to 1 PS it will perform a down operation on S the value of s will now be zero goes to the critical section print 0o print zero okay so what does this suggest this suggest that the regular expression that will be generated in that regular expression zero will be printed first okay now the case can arise can I preempt here and start from this no because until the value of T is increased 1 cannot be pred so first two Z will be there okay so I have written I explained the same thing s = to 1 and T = to 0 if tal to 0 if this tries to go there it get blogged so firstly we have to start with PJ s = to 0 both are printed now when the value of t equal to 1 is there so when this both 0 and0 will be printed and then the up operation will be performed on this SEMA 4 T when the up operation will be performed the value will be one okay so now we can go there perform down on T now the value will be zero then print one and then print one so now again the question arise can I preempt here and then from Start From Here Again can it be possible no it is not possible because the value of s was changed to Zero by this statement so 0 will not come again until this vs is executed let me speak again from the beginning so first we'll start from here print two zeros make the value of T2 1 we'll start from here print 2 one and then we will change the value of S2 again 1 okay so the answer will be 0 0 1 1 0 0 1 1 and this will keep on going on okay so 0 0 1 1 plus repeat so this will this is the regular expression that will be generated okay so I hope you got the point we are going on alternatively because of these in process I we are performing a down operation on T but up operation on S similarly in process J we are performing down operation on S but up operation on T so this will ensure the alternative printing of 0 and one so for Zer and then ones Zer and then ones and why not 1 1 0 0 1 1 0 0 why not this because the initial value of T was set to zero okay now the question arise does it ensures Mutual exclusion progress and bounded waiting let's check Mutual exclusion is ensured because until a process increases the value of t or s or I can say until a process completes its exit section other process cannot start to go to the critical section this is clear so mutual exclusion is ensured does it provides progress let's check suppose suppose PJ is uninterested to go to the critical section if PJ is uninterested can Pi can go no let me speak again PJ is not interested to go to the critical section so PJ will never ever go to the entry section will never ever go to the exit section and will not increase the value of T and if the value of T is zero then Pi can also not go to the critical section in this way an uninterested process is hindering the progress of interested process so progress is not guaranteed progress is not there bounded waiting can a process go again and again again and again again and again while some other interested process is waiting no we have seen that alternation is ensured first 0 0 then 1 one then 0 0 then 1 one so yes Mutual exclusion ured progress not and bounded waiting is ured okay so we can say that Mutual exclusion there progress not there and Boundary diving implication of a strict alternation Pi cannot enter until PG exits from exit section so this is this was an also a nice question let's move to the question number three we are given an array of binary S 4 we name it as M and it it consist of five elements and all initialized to one so m0 initialized to one M1 initialized to one M2 initialized to one so in this way till M4 it is initialized to one so there are five binary s fors all initialized to one now there are five processes also from 0 to 1 so p 0 P1 P2 till P4 are the five processes involved in this question and we are given a code of each process also while one p of MI i p of m i + 1 mod 4 critical section so this is the entry section and this is the exit section so we should write the code of first process to get a better understanding so we are writing the code of p 0 here okay p 0 the first statement will be P of m0 which means for process0 the binary S 4 value will be decreased and for p of M1 which means the binary process the binary semaphor of process one process one will also be decreased to zero so if p 0 tries to go to the critical section m0 will be made zero M1 will also be made zero okay goes to the critical section performs an un up operation on both m0 and M1 so this is how a process is working and why this percentage mode for for the circular thing for case for this case when we are writing the code of P4 then we are thinking we are talking about P4 and p 0 so that's why we are using a mod for the circular thing okay so p 0 and P1 for this p 0 uh I should write this m0 and M1 for p 0 M1 and M2 for P1 M2 and M3 for P2 M3 and M4 for P3 and M4 and m0 for P4 this is how it works okay so we are writing the code for P1 also M1 M2 critical section M1 M2 I hope you got the idea okay so what I was doing I was explaining the question so now the question is what is the maximum number of process that can be in the critical section so what is the maximum number of process p 0 Let's first start directly P0 wants to go to the critical section decreases the value of m0 and M1 is in the critical section let's say preemption happens here P1 tries to go to the critical section P1 will get blocked because p 0 has decreased the value so P1 will get blocked now let's talk about P2 can P2 enter P2 can enter because it doesn't contain m0 or M1 so P2 can enter P2 will change the value of M2 and M3 to zero now let's check for P3 can P3 enter so M3 and M4 is included in P3 but P2 has changed the value of M3 so for this reason P3 will also get blocked now the question for P4 can P4 enter no because m0 was made to zero so P4 will also get blocked so p 0 and P2 can be in the critical section at the same time Mutual exclusion not guaranteed so the question was what is the maximum number of process that can be in the critical section two okay I think I should explain the question from the beginning again and should give you a brief idea again so the question was we have a array of binary sem4 forget about this we are given with m0 and M1 that will be included in the code of process p 0 so when p 0 tries to go to the critical section it decreases the value of two binary semaphores itself and the other one so m0 and M1 will be made to zero for case of P1 M1 and M2 will be made to zero so in this way the thing goes on now the question is how many processes can go into the critical section at the same time that's what we are checking so for case of p 0 it decreases the value of m0 and M1 to 0 when P1 tries to go due to P0 this Mischief P1 cannot go P1 will be blocked now for the case of P2 can P2 go yes there's no one blocking P2 M2 and M3 will be made to zero and P2 will pass can P3 go to critical section no because P2 has made the value of M3 to0 so P3 will also be blocked can P4 go P4 will also not be able to go because the value of m0 was made to Z by p 0 that's why P4 cannot go to the critical section so the two process which can go are P2 and p 0 and P2 I hope it's clear now or you can do like that also uh let's start with P1 if P1 can go to the critical section then apart from P1 P3 can go and D all will be blocked okay so this is how this work now Mutual exclusion is not guaranteed the question number two does it uh suffer from deadlock let's see what happens is as there are two instructions in the critical section we say preempt in between so we preempt it from here here here here and here this is a dangerous Case C if I preempt it from here the value of M will be Chang m0 will be zero if I PRT it from here the value of M1 will be Zer and for this case M2 will also be zero for this case M3 will be Z and for this case M4 will be zero all of them are made to zero all of the process for perform their first instruction and get preempted and they will wait on each other for their second instruction they cannot go the c p 0 performs the first instruction okay and get preempted P1 performs the first instruction and get preempted so the value of binary sem4 is now zero for all of the M when p 0 will start performing this it will get blocked when P2 will P1 will start performing this it will get blocked for P2 blocked in this way P3 and P4 will also get blogged all of the process are now blogged and no one is there to wake them up so this is a case of Deadlock let's see another interesting question binary semap 4 S T and z are given so the initial value of s is 1 and T and z are zero so what can you say by seeing this only you can say that whichever process which is using T and Zed as their semap 4 in their entry section those process cannot start first so PJ and PK cannot start first so Pi will be bound to start first because the value of s is one okay this is the entry section this is the exit section and this is the critical section while one which means Pi can run again and again PG and PK will run only once because they don't have any while loop here okay so let's see the flow Pi while one it will change the value of s20 print and star and then it will invoke pi and PK PG and PK so it will change the value of T from 0 to 1 Z from 0 to 1 enabling PJ and PK to run okay so now the value of T 1 T = to 1 will be changed to zero in this statement and then VSS so now PJ and PK PJ and PK are helping pi to run again and again okay now the question is what is the minimum and maximum number of stars that can get printed can you tell me the maximum and minimum number of stars see Pi is helping PG and PK and PG and PK are helping pi to print more and more stars so initially the value of s was one changed to zero but here the value value of s was again changed to one and then when PK will run after PJ it will perform an an up operation on value one performing an un operation up operation on value one is going to waste that up operation because up the value will remain the same so this is the main point that you have to focus upon that you cannot increase the value more than one if this is the case you are wasting an up operation here so why why can't you fit Pi again in between to get the maximum number of stars what I'm saying is if you perform like this Pi PJ and PK and then Pi you are getting two stars and but if you doing like this Pi PJ and then you are enabling Pi again here pi and then PK and then again Pi you are getting three stars here okay if you're feeling difficulty in it let me give you a nice explanation here okay initially the value was set to one it will go here change the value to zero print an star change the value of VT and v z to one so now the value of T is 1 and Zed is 1 this operation will be performed the value of T will become zero now and value of Z will become zero okay now vs so the value of s was initially zero it will change back to one and then if you perform directly PK after PJ then this the value was one up operation will performed on one the value will still remain one and then if you try to perform Pi again the value was one it can go again there print another star and then we'll change the value of VT and VZ back to one but even after VT and VZ even after T and Zed are one again these process cannot run because there is no while loop in in them they are destined to run only once so these will not run again now when p p tried to run again it cannot run the value was Zero okay so in this way only two stars can get printed okay but now what we are doing we have enabling Pi here also so when pi will be performed here let me uh give you an idea so we have enabled Pi here Pi will run first change the value of s to zero and then it this will run change the value of s to one again now if we if we use Pi here the value of s will be changed to zero and then we use PK it will change back to one and then we can use again Pi here by using pi in between PG and PK we are utilizing an up operation that was being wasted in the previous case so this is how we can get maximum and minimum number of stars let's see another variation of this question in which we are not using VZ here this is the question okay so here in this question we are not using VZ here there's no VZ here so what are we doing Pi is enabling PJ PJ is enabling PK and PK is again enabling Pi so in this case a type of cycle is being formed so what will happen now now s equals to initially was one will be changed to zero one star will be printed PJ will be enabled and then PK will be enabled Z will be changed back to zero s will be changed back to one again P will run another star will print and then value of T will be changed to one but unfortunately there's no while loop in P PG and PK so PG and PK cannot run again cannot increase the value of s again that's why two stars will be printed only in every case which means the maximum and minimum number of stars that can be printed were only two okay so this is an homework question what does this say consider a counting SEMA 4 initialized to two there are four concurrent process Pi PJ PK and pl the process pi and PJ desire to increment the current value of variable C by 1 so p i and PJ will increase the value of C by 1 whereas PK and PK PK and pl decrement the value of C by 1 PK and pl will decrement by one minus what can be the minimum and maximum value of C after all the process finish their update and remember the value of counting sem 4 is two so value of counting sem 4 was two pi and PJ wants to increase the value and PK and pl wants to decrease the value okay and a process will execute only once there's no while loop now you have to tell what is the maximum and minimum value of C after all the process finish their update okay so you can write the code of process like that process X increment decrement increment and then C = to C+ 1 depends on the process for I and J the value will be plus and for K and L the value will be minus and this is not a single operation it consists of three micro operation load increment decrement and store So based on this you have to think where to preempt where not and then you have to tell me the maximum and minimum possible value of C after all the process finished their update okay let's see some more questions consider three processes using four binary sem4 a b c and d in the order shown below which sequence is a deadlock free sequence Okay so so we need to preempt in such a manner that in any preemption cases even one of the XY Z is able to complete then it is deadlock free and if not then deadlock is present so we are given with binary semop fores which means they are all initialized to one initialize to one okay so we need to see which sequence is deadlock fore so let's start with option one PA a value a changeed to zero PB value B changed to zero and PC value C changed to zero okay now PB it will get stuck here PC will get stuck here and PD value changeed to zero PC will get stuck PD will get stuck and Pa will get stuck so all of them are stuck this sequence is not deadlock free so this is how you have to attempt let's move to option two PB uh change to zero then again PB stuck PA change to zero PA a stuck PC change to zero now again PC stuck PC stuck PD change to zero and then again stuck now what you can see all see all of them are not stck like in the case one what will happen now PD will start executing so the process with sem4 d will start executing because this process has not been blocked so PD is going to release its sem4 at some point so when it will release this D from block block state will come back and when this will come back D will be going to execute it coming back there at this line okay so this C let me use some different pen this C is going to be executed because this is not blog so it's going to release release its semaphor at some point so what will happen this C this blogged c will come back to life okay so this has this has completed this has completed and this has already been uh has never been blocked so all of these are completed so this sequence is not deadlock free you cannot preempt in any case which you want and lead to a deadlock this won't happen Okay so this sequence is deadlock free I can guaranteed say that option two is deadlock free let's check for some more options B will change to zero c will change to zero a will change to zero then deadlock okay so this is not deadlock free obviously a will change to z c will change to zero blogged B will change to Zero blogged D change to zero c blogged d blocked a blocked so this is again going to lead to deadlock so option two is the deadlock free sequence okay I have explained it here also so because how option two is not deadlock because it's going to release the resources it SEMA 4 at some point later so it will change the value back to one okay so this is how this is not deadlock free it's time for the homework problem so each of the set of n process executes the following code using two semaphor A and B so there are two semores A and B A is initialized to one b b is initialized to zero and there is a shared variable named count which is initialized to zero and it is not used in code section P so there is a code section P then some lines of code and then code section Q what does this line of code say perform weight on a and then increase the value of count if count equals to number of process then signal on B signal on a weight on B signal on B so let me explain you more uh clear way let's say there are three process P1 P2 and P3 okay so P1 first performs the code section P now it has to perform weight on a so it will change the value of a from 1 to Z the value of count will be increased the value of count will be increased and this won't be performed because the value of count is not equals to one perform signal on a we perform signal on a change the value of a to one and wait on B see the value of B was initially zero so this will be blocked another process comes let's say P2 comes goes to the code section P perform weight on a same thing goes to code section P perform weight on a does the count equals to number of process no increase the value of a and get blocked okay now another process P3 comes performs code section p P perform uh weight on a so the value of a will be changed back to zero does the count equals to the number of process yes now the count is equals to number of process change the value of uh B to 1 signal on B We performed signal on B signal on a we change the value of a back to one and then perform weight on B We performed weight on B and then signal on B and then performed the code section Q So based on this you you have to answers you have to answer or choose among these of the four options the first option says it ensures that no process execute code section Q before every process has finished code section P it ensures that two process are in code section Q at any time it ensures that all the process execute code section P mutually exclusively it ensures that at most n minus1 process are in code section P at any time so out of these four options you have to select okay so this is a homework question now this is an interesting problem consider two functions increment and decrement increment goes like this weight on S increases the value of signal on S weight on S decreases the value signal on S and the initial value of x is given as 10 five process invoke increment and three process invoke decrement X is a shared variable initialized to 10 okay so there are two cases case one and case two case one says the value of s is set to one and it is a binary semap 4 and case two says the the value of s is set to two and it is a counting S 4 so what can you infer from this for case one we have to do sequential execution and for case two we can let two process enter into the critical section and for these two cases V1 and V2 are the values minimum possible values of the implementation of in i1 and I2 then chooses for the value of x for V1 and V2 okay so V1 and V2 are the minimum possible values of X when i1 and I2 are implemented so we have to now tell the value use of V1 and V2 so how how are we going to approach this question let's say there are five process P1 P2 P3 P4 and P5 interested for the increment and three process P6 p7 p8 interested for the decrement okay so the weight this is the increment function weight on S increases the value signal on S but this is not a single single statement this consist of three micro operations load increment and store similarly wait on S decrement load decrement store and signal on S so this is how it work and for case i1 the value of s is one which means we have to do sequential execution okay so P1 will come increases the value P6 will come and decrease the value so anyhow they perform in any order the value will remain 12 why 10 was the initial value five process for incrementation and three for decementation the value will remain 12 no matter how what is the order of these process let's say P1 and then then P6 and then p7 and then p8 and then P2 and then P4 and then P3 and P5 no matter what be the order the value for case 1 will be 12 the minimum value will be 12 okay or I can say the maximum will also be the 12 because no matter how the process executes the value will remain 12 I have already told you so the the minimum and maximum is the same for case two the things get interesting because now there are two process that can be into the critical section okay and if there are two process in the critical section what will happen the rise condition two process will raise to update the value of s of X and if two process raise to update the value of x we should let the decrement one win so that we get the minimum possible value of uh X so what are we doing we are making these process race P1 and P6 and let P6 win P2 and p7 and let p7 win P3 and p8 and let p8 win and then P4 and P5 will run but do not let them run individually we are going to race between them also for P4 and P5 we will let any of them one win so what will be the value 10 and then P6 win so 9 and then p7 win and then 8 and then p8 win and then seven and out of these two anyone will win so eight again so the final value should be8 so the value answer should be 12a 8 but don't be too don't be in too hurry to take the answer because this is wrong why it is wrong see we are going to we are letting two process race so what are we basically doing we are wasting P1 P2 and P3 we are intentionally wasting P P1 P2 and P3 by fighting it to P6 p7 and p8 so P1 P2 and P3 are wasted and among them we have uh made any one of them win so the final value should be it how it is wrong let me tell you let's say initially P1 and P6 were in the fight P1 has completed its load increment and store but what happened P6 P6 has completed its load liement but somehow it has not stored its value in critical section the two process which were there in initially was P1 and P6 P1 has completed and changed the value of x from 10 to 11 and P6 is still in execution it has not executed its instruction 3 so the store instruction is not executed by P6 now what will happen P1 will go out and P2 will come P2 will increase the value again from 12 but P6 has has intentionally not completed its third instruction that is stored okay now what will happen P2 has completed all these three instructions and then P3 will come P3 will change the value from 12 to 13 but P6 is doing some mischief and it is not executing its third instruction so store will now also not executed P3 has changed the value to 13 now it is time for P4 P4 came changed the value from 13 to 14 P6 is still not P6 has still not executed in store now it's time for P5 P5 completed the value has changed to 15 now the value of x is now 15 but P6 has still not executed its instructions now what will happen when P5 has stored P5 is stored the value of 15 now P6 comes and say Hey I want to store the value so the OS asks P6 what is your value P6 says when I was doing my computation I did on like this so now the value which I want to store is nine so P6 is going to store the value from 15 to 9 see this uh see the cunningness of P6 from 15 it has changed back to it 9 now p7 comes now p7 comes and then among p7 p8 they have made such a uh coalition between them that p7 says hey p8 you first decrements the value p p says okay so it's it has stored the value 8 now p7 says now I will store now so the minimum value is now 7 that's why I have said don't be hurry to take the answer because 12a 8 was also present in the option so many of your students must have chosen this but the correct answer is 12a 7 so this was the question from the gate examination of India amazing question okay so this I have written everything in form of statement so that it would be easy for you to read again for revision purposes so initially s = to 22 process can be in critical section at the same time let them raise to update the value of x and then always makes makes the decrement one win so this was our first approach so among P6 and P1 and P6 we made P6 win P2 and p7 we made p7 win and then among P4 and P5 we made anyone win so the final value which we thought of is eight but this was wrong then a idea pop into our mind that is it necessary to store the decreased value of count after only one increment so let all P1 P P1 P2 P3 P4 and P5 increment it to 15 and now P6 stores its value from that is X = to 9 and then p7 P had come X = to 7 is the final answer if you want more clarity or another way of of proceeding I have written this you can read this same thing but uh some different way to uh Express okay in the next lecture we are going to see some classical IPC problems producer consumer now this now the correct implementation reader writer and dining philosophers okay let's discuss the homework problem first and then we'll move to the producer consumer problem okay so we were given with a variable C equals to Z initialized to zero and two process pi and PJ wants to increments the value of c and PK and pl were wishing to decrement the value of C we have seen that counting Su of 4 S = to 2 means two process can be in the critical section at the same time and in this question we had to find the minimum and maximum value of C so for minimum value we will put these two in the critical section and let both them race and make pkin similarly we did in the last lecture last question we make them PJ and P PG and pl race and let PL win so the value minimum value will be min2 okay and for incrementing part for the maximum value what we'll do we'll make pi and PJ win so the maximum value will be two minimum value will be min2 and if I say binary SEMA 4 instead of using counting SEMA 4 you are using binary sem 4 S = to 1 then what will the minimum and maximum value the minimum and maximum value will be same which will be C equals to Z see by using binary semop 4 race condition is eliminated so pi and PJ pi and PK only one process can be in the critical section at the same at the time so Pi will be in the critical section will increase PK then will come and decrease PJ will come and then again increase and pl will come and then again decrease so the process will execute sequentially that's why for binary 4 the value will be zero for minimum and maximum case both now comes the producer and consumer problem the interesting thing till now we have seen two implementations of producer consumer problem the first one was busy waiting the second one was sleep wake up busy waiting suffers from inconsistency and sleep wake up suffers from deadlock remember when producer and consumer both are sleeping comfortably in the Sleep queue thinking that other will other one will wake them up but both were sleeping so these were the incorrect implementations now we are going to see the correct implementation using semap fores so we are going to define the bounded buffer of size 100 okay so these were the global variables bounded buffer of size 100 okay now instead of defining the count thing the count variable what are we doing we are defining two counting semap fores empty and full initially all the slots are empty so we are defining mtal to n and initially no no one was full all the slots were empty that's why full was zero and then binary S 4 MX = to 1 used between producer and consumer to ensure Mutual exclusion between buffer and these two were used for condition checking okay now let's see the producer code item P this will be the produced item in equals to Z I hope you remember what is in in is the next empty slot for producer to place an item so initially the in will be set to zero we are going to place the produced item into item P this was the noncritical section and now we are defining the entry section the entry section consist of two down operations the first is down on empty can you tell me when the producer process needs to be blocked when all the slots are full at that case producer should stop that's what we are doing here if Mt equals to Z which means all the slots are full we need to to stop the producer that's why we are performing down operation on empty and then we are performing down operation on mutex so this is just for the mutual exclusion and then the intersection is completed now comes the critical section we are going to place that buffer place that item P that is the produced item into the buffer where at index in that is the empty slot and then we are going to increase the value of Mt slot after placing that item in equals to n+ 1% per n okay and now comes the exit section we are going to up the MX upon full y upon full because we have increased a value which value see initially the full was Zero we have incremented one so now the full will be one now comes the code of consumer item c will be the consumed item out equals to zero remember what out signify it signify the index from which cons conser can consume an item while one down on full we need to stop the consumer when there is no item to consume in the buffer so that case full equals to zero so we will perform down on full when full is zero which means there is no item to consume then we need to block the consumer and down on mutex just for the mutual exclusion item c will be the consumed item increase the value of out upon mutex up empty why upon empty because we have made another slot empty consumer has consumed from an item so the value of empty slot will increase that's why upon Mt and then consume item item C this is the noncritical section again so this is how producer and consumer work by the help of sem for so this is a correct implementation now the question arise how producer and consumer are in cooperation so here it is written this were the implementation this was the producer implementation and this was the consumer implementation see the producer wakes up the consumer here producer wakes up the consumer here and consumers wake up the producer here so this is how they are both in cooperation okay so you need to remember these Five Points the first is if the buffer is full block producer P if if buffer is empty block consumer see producer should wake up consumer when he is sleeping and consumer should wake up producer when he is sleeping and mutual exclusion should exist between producer and consumer so these are the five points that will ensure the correct implementation of semur or producer consumer problem using SEMA 4 I should say okay have you remembered we discussed a question in which the order the changing the order between the entry section was leading the situation to deadlock similar thing will happen here if the mutex is not at the second instructions second instruction of the entry section this will lead to deadlock or I should say if we change the order then this will lead to deadlock see down on Mt initially the value was n decreased to n minus one down on MX initially the value was 1 decreased to zero down on full the value was already full this will be blocked so no case of mutual exclusion is VI viated okay now comes the deadlock thing can deadlock occur can both the process get blocked no this won't get blocked both of them will run now to check whether deadlock will occur we are going to preempt here okay as we used to do down on Mt n minus one down on full Full was full was already zero so this will get blocked but this this won't so this will run keep on running and then after it completes the exit section this is going to wake up the consumer thing okay so this is how it works no case of Deadlock but what if I change the order down on empt down on mutex but what I'm doing here down on mutex and then down on full okay let's see so first we did this down on mutex mutex value changed to zero down on full get blocked the value is minus one and then comes here down on empty the value change to n minus1 and then down mutex the mutex is already zero this will get blocked so both are blocked here if both are blocked then this is the case of Deadlock so what you have to remember while writing this down newex will always be in the instruction two of the entry section when it was this at the second instruction it was working fine when the mutex value changed or the for one case the mutex came up in that case deadlock occurred so this is an un undesirable case that's why the order is important in the last lecture we have seen the implementation of producer consumer problem using semap in this lecture we are going to see some more problems on that so that our understanding becomes better okay Ive also told you to remember a fact that mutex should always be at the instruction two of the entry section if it is not at one case if it's come above then the chances of Deadlock are present deadlock seems to happen Okay let's solve this question it says consider the following solution to the producer consumer synchronization problem I sincerely request you to First you attempt this question and then we will discuss okay so this is just an implicit advice you have to follow that in each and every question we discuss i' I've told you in the beginning also that whenever I solve a question pause the video and solve yourself try to attempt yourself even if you fail doesn't matter but when you attempt you are going to appreciate the beauty appreciate the beauty behind the concept of the question you can appreciate where you had made mistake or where you can make mistake and okay so I I hope you got the point what is the purpose of solving the question first and then seeing the solution okay so let's solve consider the following solution producer consumer synchronization problem the shared buffer sizes n semap 4 R Mt full and mutex defined with the respective value of 0 n and one seeing something odd empty value is zero which means the buffer is already full full Valu is n which means the buffer is already full and MX is one see in the solution which we have discussed using SEMA 4 V what we have assumed that initially the buffer is empty but I think here we are using assuming that the buffer is initially full okay we'll go with that semop 4 empty denotes the number of available slots in the buffer for the consumer to read from now this is this is just the opposite which we have learned before I I got the idea behind the question they are just trying to confuse us so what are they trying to do they they have just changed the meaning of empty and full they are also they are also taking the empty buffer in the beginning I got this okay so SE empty denotes the number of available slots in the buffer for Consumer and full denotes it must be for the producer to write to yes so empty denotes available slots filled with the item and full denotes number of empty slots okay placeholder variables PQ and r r s and they can be assigned with either empty or full and valid sem for operations are weight and signal so we have to assign the value of pqrs in such a way that this code works for uh producer consumer problem okay producer consumer I have told you five things to remember do you remember the five things are when the buffer is full block producer when the buffer is empty block consumer producer should wake up consumer when he's sleeping and consumer should wake up producer when he's sleeping and mutual exclusion should be there we will apply the exact same concept producer it should be sleeping when the buffer is full okay and what does full denotes full denotes the number of empty slots if I say if number of empty slots in the beginning is zero then producer should get blocked so we are performing weight operation on full what does full represent here this is not that typical full it represents number of empty slots and if I say number of empty slots is zero in the beginning which means producer should go to sleep that's why we are performing weight operation here on the foot and when an item is added to the buffer empty SEMA 4 should be increased with one when an item is added empty sema4 should be increased with one why because empty empty symbolizes available slots filled with an item so when an item is added to the buffer available slots filled with an item should increase okay so if you're getting confused just see that they have just changed the meaning of full and empty so what we are going to do we are going to just change the assignment of full full and empty here so you remember we have a sign like this empty full full empty so what are we going to here do full empty empty full so the answer should be full empty empty full C so you have to correct them at your notes also answer is not D it's C okay it's just a a mistake to take D but the answer is full empty empty full how we have done that we have just notices that the meaning of full and empty has changed here so we will just change the assignment also so full empty empty full is the answer let's move to question number two consider the procedure below for producer consumer problem which uses SEMA fores okay so this is a nice question SEMA 4 n Nal to Z number of items sem 4 S = to 1 it represents the mutex okay there are two codes given producer and consumer what does producer do it produce an item apply log to the critical section goes to the action add the item to the buffer free the lock increase the value of n because number of items here are now increased with one void consumer while true what is consumer doing consumer is first applying log to the critical section Sam wait why s wait here because it cannot go to the critical section or consume from a bounded buffer until there is some item already present for there it to be consumed okay that's why Sam weit n if there is item present go to the critical section consume the item s signal as free the lock and then we are free to consume okay so what we have done here let me repeat again producer produces apply a lock add the item to the buffer remove the lock increase the value of n what consumer do apply lock check if there is some item present or not if not then get blocked remove the item from the buffer remove the lock consume the item okay so this is what happens now the question is producer will be able to add an item to the buffer but consumer can never consume it why is it so let's check is that is true or not so producer will be able to add an item to the buffer producer produces apply a lock add the item to the buffer removes the loog increase the value of number of items so producer is able to produce yes but consumer can never consume it why is it so let's see same weight on s s is changed to zero same weight on n n is equal to Z Now removes the item from the buffer s is set to one consumes the item so this statement is false because consumer is able to consume the item question number or the option b the consumer will remove no more than one item from the buffer why is it so let's say the producer produced 10 item consecutively 1 2 2 3 4 5 6 okay till 10 items Now consumer is free to consume no one is just stopping that see while true consumer can consume as many times same weight on S so when producer has produced an item or it has left the critical section it must have changed the value of S2 one so now consumer won't be blocked here Sam weight on N so this will change the value to 9 removes the item from the buffer change the value of signal s back to 1 so n should be n here and it can consume okay so this was the first cycle now it tries to goes again s weit on S it will change the value of s to zero s weight on N it will change the value of n to 8 removes item from the buffer change the value of s to one again and consumes so it has consumed more than one item from The Bu so this is also false deadlock occurs if the consumer succeeds in acquiring sema4 s when the buffer is empty yes this is true how let's say consumer tries to go Sam weight on s s is changed to zero Sam weight on n n is initially already zero so this consumer will get blocked now comes here same weight on s s was already zero so this is this also get blocked this also get blocked let me repeat again the initial value of s is 1 and N is Zer when consumer applies log to the critical section s is changed to zero and it gets blocked here because the value of n is zero so consumer is blocked here now now producer tries to go consumer has changed the value of H to Zer producer cannot also go producer will also get blocked so both the process are blocked it is the case of Deadlock next option the starting value for the sem 4 n must be one and not zero for deadlock free operation is that necessary let's see so we are given that the starting value of sem 4 n must be one and not zero for deadlock free operation next's check so for deadlock free operation what we have to do this instruction mxe is at instruction one so we have to swap for solving the deadlock so let's say we have S that in that case the deadlock can be resolved but what we are given here the value of n should be initially one and not zero for deadlock fre operation let's see so we can think of any case in which n is one and Deadlock can happen can you think of that let's see from the consumer side s is changed to zero n is changed to consumer can freely go it is not blocked let's say it get preed here tries to go from here producer tries to go s is already zero producer will get blocked consumer will now chance consumer will consume or consumer will uh change the value of n to zero again now it's chance for producer to go consumer will change the value of s also to one so producer can freely go now in that case either you start with the producer first n is initially one no one is stopping producer to go to the critical section if one process can go to the critical section then other will also go after some time when the lock is released so the if the starting value of sem for n is 1 and not zero then it is dead log free yes it is true so this is again wrong this is this is true okay so C and D is the answer you need to correct that both in your uh notes okay the first question answer is C and the second question answer is C and D in the next lecture we are going to see reader writer problem solution in the last lecture we have seen some problems on producer consumer SEMA for implementation in this lecture we are going to see the interesting reader writer problem and it solution using semor let me tell you what is reader writer problem Suppose there is some database with records okay now there are two process a reader and a writer both have access to the database and what does reader do it read one or more records from the database and what does writer do writes to one or more records from the database or to the database okay now the problem is reader and writer should not be able to access database at the same time this is the problem it should not be there that reader and writer both are present in the database because a writer may be writing that thing and reader May read the updated value or reader May read the old value and writer May write to the new value so there is some kind of of problem there you can feel it too so what we want that reader and writer should not be able to access database at the same time what is the solution just just use a mutex let's say there is a binary 7 for mutex equal to 1 down on mutex critical section upon mutex problem solved this is it no there is something more to the problem which is there are multiple readers and multiple writers so multiple writers multiple writers cannot be in the critical section at the same time you can feel it too a reader and a writer cannot be in the critical section at the same time but multiple readers can be in the critical section at the same time or multiple readers can be in the database at the same time because readers are causing no harm they are the writers because writers update the value so multiple writers should not be there a reader and writer should not be there multiple readers can be there so this is what we have to implement using semap see this there can be multiple readers and writers so the reading is not a problem reading plus writing will be a problem writing will be a problem so multiple writers can't be there multiple readers can be there a reader and writer can't be there so this is what we have to implement okay and there is some another problem which is starvation to the writers let's say this is our database okay I have assigned so there is a reader and there is a writer so I have told reader to go into the into the critical section of the database first so reader goes okay start its reading another reader comes because multiple readers can be in the critical section at the same time that's why I allow another reader to go to the critical section also then another reader come then another reader come so the readers keep on coming and the writer is waiting so the writer is waiting and readers keep on coming this caus starvation to the writers let's take another case in which writer goes first reader got blocked when another writer comes let's say writer two writer three and writer four all of them will get blocked until writer one performs its operation and let's say writer one is performing its operation for a long time then writer two writer three and writer four and every writer which will come after writer four or the writers will keep on coming and will and will get and will keep on getting blogged and blogged so this will cause a starvation to the writers so this is the problem which we have to solve okay so what can we think of it let me explain you there are two process reader and writer okay let me explain you the main idea what happens this is the database okay for the first case writer comes it will lock the database from inside perform its writing operation and when it will come out it will remove the lock and will go out so this is what a writer do as simple as that but the problem is with the readers so what a reader going to do let's say this is R1 this is the leader of the reader this is the first reader which has shown interest to enter into the database reader come check the database if it is logged from the inside let's say writer one is present already what it will do it will tell the other writers hey the critical section or the database is logged from inside all of us should get blogged until the writer perform its operation okay so this is how readers are going to cooperate but let's say there is no there's no writer present in the database so what it will do reader one will come lock the database from inside for the writers only for the writers only and will allow its fellow readers to enter into the database so R2 can easily go R3 can easily go R4 can easily go and when they will come out of the database or let's say they have Performance Reading so they will go out R1 goes out R2 goes out R3 goes out and now it is the the responsibility for R4 that is the last reader to tell the writers that now we have performed our reading you can go now so R4 have the responsibility to remove the lock which the first reader that is the leader of the reader R1 has applied on the database are you getting the point let me repeat again and then we will move to the code see there are reader and the writer Pres if writer comes it will lock for lock the database from inside for everyone either either it be a reader or it be a writer writer one performs its operation writes the thing and before going out it will remove the lock and it goes out so this is how R do its operation and how reader do reader one will come and check if there is a lock on the database already for the readers which some writer must have been applied or or locked the database from inside it will car its fellow readers R2 R3 and R4 to get blocked that we all of us should get blogged until writer one perform its operation and when writer one will perform the operation it will go by removing the lock at the database so the lock will be removed now reader one comes it applies the log log for whom only for the writers reader one comes it allows other its fellow readers to go and read at the database reader one has completed its reading so it will leave reader two has completed reader two will leave reader three will leave but now the last reader the last reader that is reader 4 it is the responsibility for reader 4 to remove the lock which reader one has acquired at the database so that other writers may get to know that the now database is free we can go into the database I hope you got the idea let's see the implementation of reader and writer using SE we will maintain a reader count also to know that if that reader is the first reader or the last reader that's why because we have to take account of leaders and the last reader that's why we are maintaining a readers count okay so int RC that is the readers count that is number of readers present in the critical section okay so readers count is the value of uh the readers present in the critical section see suppose RI is the reader that wants to enter into the critical section so it will try to increase the value of readers count and RJ is the reader that has completed its reading so it will try to decrease the value of readers count can you see this as a race condition because multiple readers may want to access readers count for incre increment and decrement so this will cause inconsistency in some way that's why we are maintaining a mutex which is used by readers for readers count and we are maintaining a binary 74 database which is used by reader and writer to access database as the critical as access database as critical section are you getting the point we are maintaining two binary seaone the first one is mutex mutex is for the readers count and another one is the database database is for the critical section mutex is used only by the readers and database is used by the readers and writer to get access of the critical section okay now what is the major function of the writer it has to just go to the database apply the lock and if someone is present get blocked this is the uh major work and whenever the writing is done when it will go it will release the lock so this is what we have done here void writer perform down operation on database that is acquiring the lock performing the database right and releasing the lock as simple as that but the readers implementation is a bit tricky what readers have to do whenever a reader enter into the database it has to increase the value of readers count by one to prevent inconsistency we have to perform or the reader have to perform a lock or a down operation on mutex so that some if some another reader want to decrement that won't cause inconsistency suppose if a reader is incrementing the value of reader count and another reader comes and it wants to decrement the value of readers count let's say somewhere at this point then this will prevent them download mutex will prevent them for causing inconsistency okay so mutex is used by readers only to increment or decrement the readers count okay suppose reader one comes perform down on mutex increase the value of reader count initially it was zero so now reader count is one and I have told you if the reader is the leader or it is the first reader it has to check whether some writer is present into the critical section or not if it is present then other readers should also get blogged so reader one will get blogged where it will get blogged at the instruction C and let's say some reader two also wants to go to the critical section it tries to first in the value of readers count it won't be able to it will get blocked directly here so R1 R2 and any other reader which try to go will get blocked so this is what happens mutex initially changed to zero reader counts changeed to one database let's say the DB that is the down on mutex is already Zero by some writer so a leader will be blocked at instruction C at this point and rest others will be blocked at instruction a at this point only I hope you are getting the idea okay now what happens let's say there is no writer present in the critical section so now what leader of the readers will do it will change the value of DB to Z why to prevent other writers entering into the critical section okay now as it has changed the value of RC to 1 it will increase the value of mutex or it will release the lock it has acquired on the readers count shared variable now what it will do it has successfully entered into the critical section or I can say it has sucessfully enter into the database so it will perform the read operation on the database and now when it has done when it is done with its reading then what will happen it should go out of the database so before going out of the database it should decrease the value of readers count by one so what it will do it will perform the down operation it will acquire the lock performs the reading or performs the decrement on the readers count and will release the mutex but here is the catch also I have told you if it is the last leader that is R4 in our case then it should be a responsibility for R4 to tell other writers that database is now free so the last one should unlock so if it is the last one that is reader count equals to zero then it should unlock the database and then upon M Tex so this is how reader wrer problem is solved using 74 let me read again if it's the first writer it checks that database has writer already then it will get blocked rest all of the readers will be blocked and if it sees no one is there in the database it can go there and simply lock it for the writers only readers can enter and no need to lock every time so the first reader is the leader of all other readers so what are we doing here down mutex before accessing the reader count and before making it up lock if it is the first reader and unlock if it is the last one so the last one is unlocking and lock is performed by the first leader okay so this is how it work now let's revise what we have done in the readers writer problem let me repeat again what happens there is a database there are two process reader process and the writer process a writer process can go only if there is no other writer or reader present in the database so when a writer process try to go it will perform a down operation on DB which will automatically adjust if there's some other reader or other writer present then it will get blogged if not it will go acquire the lock go into the critical section if some other writer tries to enter it will get blocked now what for the reader let's say there are four readers R1 R2 R3 and R4 R1 is the reader R sorry R1 is the first reader so it will become the leader first reader is the leader so when a reader leader tries to enter it will see that critical section is logged or not if yes it will tell other readers also to get blogged so all of the readers will get blogged and when this it will go out it will tell the other readers that c section is not free you can go so R1 will go R1 will go first R1 will go first we'll see if this if there is no other reader no other writer it will lock the database from inside for the writers only and other readers are free to go so R2 will go then R3 will go and R4 will go and when they have performed their reading operation R1 will go out will decrement the value of RC R2 will go out will decrement the value of RC R3 will go out will decrement the value of RC and when R4 will go out the RC will be zero because there is no other reader present in the database so RC will become zero and when RC will Zero it is the responsibility of reader 4 that is the last reader to tell other writers that database is now free you can go and write or perform your right operation so this is how reader writer problem works or this is how reader writer problem is solved using the semaphor I hope you like this uh I hope you liked it now let's move to the new problem that is dining philosophers problem it consists of some philosophers discussing on some topic and then when one philosopher become hungry he eats the meal in front of him using a knife and fork these knife and fork are shared okay so when philosopher 2 is eating he'll pick up the the knife pick up the fork and we start eating but in case if P1 and P3 also become hungry at the same time they won't be able to eat because they need fork and knife but when P3 will try to pick up the fork this Fork is already in use by P2 so P3 fails to pick up this Fork hence won't be able to eat when P1 will try to pick up this knife this knife is already in use by P2 so P1 also fails to eat so these knife and fork are shared between these philosophers if one philosopher is eating then these two philosopher can't eat okay so this is what I've written here n is greater than two that is number of philosophers should be greater than equal to two philosophers eating noodles and using a knife and fork is shared between these two when a Philosophers become hungry he'll pick up the left thing that is or the left fork and then the right if successful but why I have written if successful because in that case in this case P1 is unable to pick up the right thing that's why I written if successful and if not then P1 won't be able to eat so a philosopher start eating only when he pick ups the right successful picks up the left successful so left and right are both picked up and successful okay now you can see this problem suffers severely from deadlock how let's say a Philosophers picks up the left thing and get preempted picks up the left thing and get preed suppose this philosopher picks up the the left knife and get preempted picks up the left Fork get preempted picks up the left knife get preempted picks up the left Fork get preed picks up the left knife gets pred picks up the left Fork get preed now each of the knife and fork is acquired by some philosopher and other philosopher is waiting for other philosopher to release that knife so this is waiting for him this is waiting for him waiting for him waiting for him so there consist a cycle in which a philosopher is waiting on another to release that lock see p 0 is waiting on P1 P1 is waiting on P2 P2 is waiting on P3 P3 is waiting on P4 P4 is waiting on P5 and P5 is waiting on p 0 so this is how deadlock occurs in this ding philosopher problem so how in which case dead log occur all of are hungry all of them prevents uh preempts after picking one thing they all picks up the left thing and get preed fork0 is acquired by p 0 for is required by P1 2 by P3 and all of them p 0 is waiting on P1 P1 on P2 P3 on P3 P3 on P4 P4 on P5 and P5 again on p 0 so this is a case of Deadlock okay so how this dining philosopher problem is implemented let's see so we have defined six philosophers here let N equals to 6 void philosopher and I while one think this is the case when a philosopher is thinking think I now it gets hungry take Fork I take Fork I + 1 mod n why mod n for the circular thing for this for this that's why for the circular thing we have written mod n picks up the left Fork picks up the Right Fork if successful eat after eating put back left Fork put back the Right Fork this is it this is how a philosopher work you will think suppose now thinking he gets hungry he takes up the left Fork takes up the Right Fork if successful then eat put back the left Fork put back the Right Fork this is how a philosopher work now the question arises what is the maximum concurrency how many philosophers can eat at a time without deadlock let's say now we change the number for Nal to 5 what is the maximum number of philosophers that can be eating okay let's say philosopher zero tries to wait picks up the left four picks up the Right Fork P1 tries to it gets blogged because F Fork one is already acquired by p 0 now in this case we are ignoring the fact that knife and fork are different we are just taking into consideration that a a philosopher require two Fork we are saying that knife and fork are the same what I'm saying instead of segregating between knife and fork we are saying they are just forks and a process and philosopher require two Fork to eat two forks to eat okay so this is what we are doing suppose we are saying p 0 requires are Fork 0 and Fork 1 P1 requires now Fork 1 but it will get blocked because Fork 1 is already required by p 0 now P2 comes P2 acquires 42 and Fork 3 P3 comes get blocked because P3 has acquired it wants to go to the fork 3 but Fork 3 is already acquired with 42 P4 comes F4 and F0 but F4 F0 is already acquired with p 0 so at Max two philosophers can it you can also see here let me go back yeah you can also see here in this case how many philosopher can eat this can eat freely this can eat freely and this can eat freely in case of six philosophers but if let's say I remove this philosopher and this knife then how many can eat only this can eat and this can eat okay so this is not a hard question what you have to do what you have to do just allocate folks to the philosopher and if some other philosopher wants to acquire the same Fork then make it blocked this is it p 0 wants to get Fork 0 and Fork one give them give him P1 wants to get Fork one but it is required with uh p 0 block it P2 wants F2 and F3 give him P3 wants F3 block him because F3 is already with F2 P4 wants F4 and F0 block because F0 is already with p 0 so this is how you have to do for n = to 3 when when there are three philosophers the answer will be and the answer should be one C if there are three philosophers and oh for Three Philosophers can it be three knives yes for three Three Philosophers three folks will be there at a time only one philosopher can eat with using this so these two will wait I think I must have I must want to return six here you can see for six this philosopher can eat freely this philosopher can eat freely and this philosopher can eat freely so for Nal to six three of the philosophers can act can eat freely okay now the question arise how to prevent that deadlock case so the first answer is semaphor based and the second is non semaphor based okay let's discuss the first non semaphor based answer let's say there are two philosophers sitting on a table with two forks in between see the number of forks is equal to the number of philosopher and one philosopher require two forks for eating you have to remember this condition what I have said the number of forks is equal to number of philosophers and each Phil each philosopher require two forks for eating okay so now here two philosophers are sitting on a table and there are two folks present you can see these blue the blue ones are the folks so now what we have to do we have to make this veloc pher picks left first and then right and this philosopher should pick right first and then left see how this is going to solve the problem this philosopher what is the left of this philosopher this one so this will pick this what is the right of this philosopher this one so when this philosopher has already acquired this Fork this philosopher should also try to acquire the same Fork otherwise if this philosopher acquire this Blue Fork the deadlock will occur each of them has acquired a fork that is required by the other a cycle will be so this is a deadlock condition what we have to do he picks the left Fork first and then right make him pick the right Fork first and then left in that way deadlock won't occur let's see picks up the left Fork first he also tries to pick up the Right Fork first but this Fork is acquired by this one gets blocked now he can pick up that that one eat properly and then when after eating he will release them so when this will try now they can both eat one after another so first this it and then the other one so this is how non semop for solution work picks left first and then right picks right first and then left this Fork is right one to the P2 P1 left picks the left Fork P2 tries for the right one and get blocked because what the fork which is left to P2 is right for the P1 or you can say the other way the fork which is left to P1 1 and is right to P2 so both will try to pick up the same fork okay let's say P1 has acquired the lock first then P2 will get blocked this is how deadlock will be saved otherwise let's say this has picked this fork and this has picked this Fork now this philosopher is waiting on this philosopher to release the fork and this philosopher is waiting on this philosopher to release the fork this will be a case of Deadlock so what we have to do make one philosopher change the pattern let's say all philosophers are picking left first first and then right left first and then right left first and then right make one philosopher pick right first and then left in this case deadlock won't occur believe me deadlock won't occur make one philosopher choose the different way okay so n minus one philosophers let's say there are total n philosophers so n minus one philosophers will go first left and then right and N philosopher will choose first right and then left okay so let's say P1 be that n philosopher will first choose the right fork and then the left Fork so this is how P1 works okay now let's uh start the thing P4 picks up the left Fork first P5 picks up the left Fork first P1 tries to pick the right Fork first but Right Fork is already required will get blocked so P1 will is blocked here okay P2 picks up the left Fork first P3 picks up the left Fork first and now it's chance for P4 again P4 will pick the right Fork see here so after eating will be done off for P4 now P4 can eat see P4 has required both these folks so P4 can eat when P4 will eat after eating P4 will release them now P5 can eat after eating P5 can release them now P1 can eat so P1 tries to pick this get blocked P1 tries to pick this it can pick successfully but when tries to pick this gets blocked now what will happen chance for P2 P2 cannot pick this gets blocked chance for P3 P3 can pick this so P3 will eat P3 will eat after eating we release both of them now chance for P2 P2 can pick this now P2 will eat P2 will release both of them now it chance for P1 P1 can pick this again now P1 can eat and will successfully release them so this is how deadlock is pre prevented when one of the philosophers is has changed the path all of them were moving from left to right and one of them was odd so what he choose he chose left to right so this is how deadlock can be saved that's what I'm trying to tell here okay okay so this was the non semap 4 based solution it was semap for free it was deadlock free how it works out ofense n philosopher let N minus one go from left to right and then one philosopher will go from left right to left or you can do like that even number should pick first left then right and OD number should pick first right and then left you can do like both both the ways will save you from deadlock so this is how non semaphor based solution worked now comes to the semaphor based solution what are we what are we doing here put semaphore control on taking and releasing the fork how we'll discuss later in the chapters of monitor so there are some miscellaneous topic which I will discuss in the end like uh we have not discussed in detail about Fork system call we have not discussed about threading multithreading we have not discussed uh monitors in later part of the course we will learn when we will learn about memory management we will learn segmented paging and inverted paging in the last of the course that is the miscellaneous topics okay so we'll discuss that part in the later part of the course that is we'll discuss when we will study monitors okay so this was the dining philosophers problem let's start our lecture with the sleeping Barber problem this problem is from ten and bomb textbook if you want to have a reference you can visit the textbook okay so the problem is there is a barber shop okay there's one Barber and and chairs for in customers as you can see this in the picture if there are no customers then the barber sits on his chair and sleep as Illustrated in this way when a new customer arrives and the barber is sleeping then he'll wake up the barber suppose a customer arrives and the barber is sleeping he'll wake up the barber when a new customer arrives and the barber is busy then he'll just sit on the waiting chairs like this and if there are no chairs available then he'll just leave okay so now you have to tell me the possibility of Deadlock how deadlock can arise in this situation let me give you a hint when a customer doesn't vacate the only chair even after the haircut in that scenario deadlock may arise now you have to think how okay now let's move to the our last topic of this section current concurrency versus sequentiality okay so see this program begin statement one statement 2 statement 3 statement 4 a = B+ c d = to e CR F K = A+ d l = k CR D so this will execute sequentially okay now if we see this uh for this in operation if we see the micro instruction or micro operations which are instruction one load the value of B into register load the value of C into register add and store the value of R1 + R2 into register R1 and then store the value of register into a so after all these instructions this statement will be executed so this will go like sequential execution you all know but but I say if permissible if it is allowed then which statement can execute concurrently you know the meaning of concurrent execution parallely okay not not directly see there's a difference between concurr concurrency and parallelism but if you do not know the meaning of concurrency paral ISM can give you a hint okay so if permissible which statement can be executed concurrently so the statement which are not dependent on each other can be executed concurrently or concurrently you can say together okay see statement S1 a = to B+ C statement S2 d = e CR F these two statement are independent how can I say that which statements are dependent those statements are dependent for if one if the output of one statement becomes input for the other see like this S1 and S3 the output of one statement becomes input to the other C S3 and S4 the output of one statements become input for the other so these are dependent so these dependent instructions or these dependent statements cannot be executed together or concurrent ly okay now see this S1 and S2 they can be concurrently executed after this S1 and S2 you can execute S3 and after S3 you can execute S4 so this graph which I have made here is the Precedence graph it is also directed graph what does this show S1 and S2 should be executed first after that S3 after that S4 there is there is no order or there is no significance of order to be followed while executing these S1 and S2 so this is what concurrency means why because S1 and S2 are independent okay let's take another example let's see this presidence graph can you tell me which statements can be concurrent the statements which are independent which statements are independent those statements are independent in which the output of doesn't becomes the input for the other okay see this can I say S1 and S2 are independent no because the output of S1 will become independent the output of S1 will become input of S2 can I say S1 and S3 no the same thing is there also can I say S2 and S3 yes they are independent so they can be concurrent can I say S3 and S4 Yes because the output of S4 or output of S3 is not becoming input for the other I hope you're getting the point can I say S5 and S6 are independent or concurrent yes can I say S4 and S5 no because output of S4 is becoming input for the S5 can I say the same thing for S4 and S6 no can I say this S5 and S S6 can be concurrently executed with S3 yes can I say S3 and S7 can be conr executed no because the output of I hope you're getting the point okay so you have to see like this this if it is on the other Branch then I can say that they can be concurrent okay now let's understand the difference between concurrency and parallelism concurrency let me tell you directly let me tell you two words which will make it clear concurrency means multiprogramming and parallelism means multi processing let me repeat again concurrency means multiprogramming I hope you already remember what is multiprogramming we had this OS and there are multiple programs in the main memory and then CPU executes sometimes P1 and sometimes P2 and sometimes P3 so this is multiprogramming what is multiprocessing in one CPU P1 is being executed in another CPU P2 is being executed in another CPU P3 is being executed this is multiprocessing which include multiprocessors okay so let's read this a system is said to be concurrent if it can support two or more actions in progress at the same time okay same to multiprogramming a system is set to concurrent effec support support C support two or more actions in progress at the same time set analogy with that multiprogramming two or more process can be supported for Progress at the same time parallelism a system is said to be parallel if it can support two or more actions executing see this executing word is important executing simultaneously and here progress word is important concurrency is about dealing with a lot of things at once and parallelism about doing lots of things at once okay concurrency is dealing and parallelism is doing don't worry if you are not getting it I have plenty of examples to solve this confusion two or more actions can go along together together or progress together okay so take this example you sit at a chair eating snacks watching lectures and listening to lufy beats in the background this is you dealing with multiple things at a time and what is parallelism in that situation simultaneous execution one person is eating snack one person is watching lecture one person is listening to lfy beads and these are happening at the same time so this is the difference between concurrency and parallelism concurrency leads to parallelism or I can say parallelism can be derived through concurrency okay see this this is sequential execution first this one then this one then this one then this one then this then this then this first all blue ones get executed and then the red ones what happens here sometimes blue one sometimes red one like the CPU do with the processes sometime this process sometime this process this is concurrent we are dealing with the blue ones and the red ones at the same time and noce parallel execution blue ones and red ones are being executed at the same time okay so this is the progress this is the execution okay see this concurrency sometime the blue processor sometime the green sometime blue sometime green here green and blue are being executed together take another analogy concurrent means two cues at one coffee machine sometime this one go some this one go then this one then this one and what is parallelism two Q's on different coffee machines here this coffee machine is dealing with the two different cues and here is the doing I hope you're getting uh the idea okay interleaved execution in multiprogramming this is concurrency you know what is the meaning of intered execution the CPU sometimes execute P1 sometimes execute P2 but it is the same CPU parallelism is possible with multi multiple CPUs or multi code okay concurrency can be segregated into two parts pseudo and real the real concurrency is actual parallelism and the pseudo concurrencies one CPU we get an impression of concurrency see this this is sudo concurrency and this is real concurrence real parallelism actually doing two things simultaneously and here we are just getting an impression of concurrency we are just seeing suppose suppose this is in a black box both of them are in a black box you can't see what is in there so you can see that or you can from the output you can say that blue ones are also coming and red ones are also coming in the output I get an impression that both are being executed at the same time but is it so no sometime this one sometime this one sometime this one sometime this one in this black box when you see the output you can also say that same thing I can see blue ones and R ones coming out of the box so I can say the same thing for here also that both are being executed but the difference is clear here we are just getting an impression of the concurrency and here is the actual concurrency okay this is done when there is a single CPU and this is done when we have two core CPUs because this can be executed on one CPU and this on the other here there is one CPU sometime this is executed and sometime this is I hope now the difference is clear okay so that that thing which we call as sometimes P1 sometimes P2 that is called as that is called as interl execution among processes okay now let me ask you a question Suppose there are two statements SI and SJ SI is AAL to B plus C and SJ is d = e cross F now tell me can they be executed concurrently yes they can be executed because the output of one statement is not becoming the input for the other they all have different variables so yes they can be executed concurrently let's see another question tell this A = to B plus C D = to B CR C can they be executed sequen concurrently yes you can also guess this because the output of one is not becoming the input for the other is a becoming input for this D no we are just reading the values so yes they can also be executed concurrently even though they have shared resources but they are only reading the value of B and C okay so if the output of one becomes input for the other then those two statements won't be concurrent here so you have to remember this line okay for every statement two sets can be defined the reading set and the writing set see above these for this can you define the reading set and the writing set yes reading set will include reading set of Si will include B and C and the writing set of Si will include a because the value of a is overridden or or overwritten and the B and C are red only okay so this is read set set of all those variable whose values are R and right set is all those variables whose values are updated so for this a go to B plus C B and C variables are in the read set and a will be in the right set suppose this statement a + = to ++ B cross c so this can be simplified to this a = to a + Plus+ b into c now can you tell me what is the read set and what is the right set see for a b and c you can check that value of all the variables are updated see the value of a will be updated for sure the value of B will be updated but how this Plus+ B and b++ are different here we will first increase the value of B by one and then we'll use it we'll first decrease the value of C by 1 and then we'll use it but what happens in the case of b++ we'll first use the value of B and then we'll increase it so a = to a +++ b cross c first increase its value by one then use so the value of each of the variable is being updated so what will the read set a b and c and sorry what is the right set a b and c and read will be fine okay now let me ask you an amazing question can you guess this index S3 equals to is SC F perc D and X okay so what is the statement there is some variable index and you are taking the input for it okay now you have to tell me scan F now you have to tell me the read set and the right set think about it pause the video you think about it the read set and the right set okay I'm showing you the answers now so the read set will be five and the right set will be X how this is uh did you think of the opposite answer maybe possible see initially when you just declare a variable without assigning any value then there is some garbage value stored here garbage some garbage value initially and when you take input from the user that garbage value let's say I pressed five on the keyboard for this integer so that garbage value will be replaced by that five okay so the value of x was initially this some garbage value and now it is updated to five so I can say the value is updated so the read set will be X and what is the sorry I always see a so the right set will be X and what will the read set five because we have not read this value so why is it necessary for uh why is it necessary to read this garbage value no it is not necessary so the read set will be fine the right side will be X similarly for S print X for printing we just read the value we do not update that so for print the value will be X so the read value will be X and the right will be F these are just some uh practice question to boost you uh when you can how to find a read set and right set because from this read set and right set I can say if two statements are concurrent or not if if between the right set of the first statement and the read set of the second statement if there is nothing common then the statement SI and SJ are concurrent if the read set and the right the read set of first first statement and the right set of another statement if there's nothing common then SI and SJ can be concurrent if the read if the right set of first first statement and the right set of second statement if there's nothing common then the SI and SJ can be concurrent so this is called as burn steam concurrency condition for two statements you derive what is read set and what is the right set and then see if there is something common in between if yes then they are not concurrent and if no then they can be concurrent okay so this is Burnstein concurrency condition okay now let's see concurrency mechanism how this concurrency is actually implemented and this is not from any textbook okay so C C++ Java sequential language but how can concurrency be applied we can apply it using pair begin and parent so this pair refers to the parallel and this Co begin which is the same name for pair begin and parent co begin and co end is for concurrent okay so uh let me tell you how this works begin S1 S2 S3 and end when you write this sequential execution will happen first S1 then S2 and then S3 but if you write pair begin and pair end in that case we are allowing for concurrent execution see this firstly s0 s0 came as the root node pair begin S1 S2 and S3 so the they are the concurrent so I can put them on the same level on different branches and then after this block I had S4 so after this I had S4 so I hope you get the difference between how this pair begin and pair end are uh making the Precedence graph different for this only begin and end we did the sequential execution and for pair begin and Pa end we are allowing for concurrent execution okay okay see this S1 pair begin S2 S3 S4 begin so we are now using nested begin and pair begin and now you have to do the draw the Precedence graph we start with the S1 so this is the root node we start with the S1 pair begin PA and and then in the end S1 so whatever will come here and then in the end we will had S11 now pair begin S2 S3 S4 so S2 S3 and S4 will be concurrent statements okay begin S5 S6 and end see this here we are using begin so S5 and S6 will be sequential I can see S5 and S6 are sequential begin S7 S8 S9 so S7 S8 and S9 will be sequential S7 S8 and S9 are sequential and then in the end S10 in the end S10 see this S2 S3 S4 this one this one and this one will be concurrent and this one in this one S5 and S6 are sequential S7 S8 and S9 are sequential so this is how it's going to look if you're feeling difficulty don't worry I have plenty of examples write program now it's it's different now you have to go the opposite way write program for the graph see S1 so we'll write S1 here now S2 and S3 can be concurrently executed so I will apply pair begin S2 and S3 but see S2 had some more sequential executions like S2 after that S4 and then S5 and S6 so I'll first write S3 and then I will apply begin why begin because I need some sequential execution steps now I'll write S2 and then S4 so this part is covered and then I I should write S5 and S6 but they are sequential but they are concurrent so I can write S2 S4 and then this pair begin thing and then in the end end and then parent and then in the end S7 let me repeat again see S1 came here this part was related to concurrent execution so I'll write pair begin and pair end here okay now forget about this S3 and S2 are concurrent so I'll write S3 and S2 but you see S4 and S3 are also concurrent S5 S6 and S3 are also concurrent that's why we are keeping the S3 outside and this begin and end in the one part okay so S3 will be outside begin now we are talking about this tree okay begin S2 S2 will become the root node for this tree and then I need S4 S4 Here and Now I want concurrent execution for S5 and S6 that's why I've used pair begin here and then end now let's modify the question a little bit instead of S3 going straight to S7 why don't we make like this S3 going to S6 now it's a homework problem we have to write the program just as we did here okay in this graph we made a little bit of change instead of going like this we changed to this okay let us start our discussion of final part with the homework problem I've given you a homework problem in which I change the Edge from this to this okay this is The Edge now you have to tell what will be the code of this graph so I start with S1 I start with S1 and then I can see these two these two blocks are these two nodes are concurrent okay can I say these two are concurrent also no I cannot directly say because the statement the the section or I can say the node S3 is making S6 dependent on itself the output of S3 is the input of S6 so I cannot say S5 and S6 are concurrent always because this is from a different branch and this may be from a different branch that's why I cannot say S5 and S6 concurrent as always like I did in the last question in the last question S5 and S6 were indeed con current but now it is not so how we going to proceed with this let's see we have two cases we have two options we started with S1 here pair begin S3 and then this S2 S4 and also include S5 and S6 here I'm talking about of this block including here after s sport so what is the problem that may arise the problem is this Edge this pair begins is you can start with either S3 or this or this statement you can either start with both of them so I say why I can't start with this so I start with this begin S2 S4 and I said I'm including this block also here so S5 and then S6 but the problem is can you execute S6 before executing S3 no that's why we have to we cannot include this block here that's why we need to separate this block what we did in the last question in the in the previous lecture we included this block here but you cannot do this now why let me repeat again because the input of S6 is the output of S3 they are dependent on each other they cannot be in pair begin with different statements with this and this okay I hope you're getting the idea that's why I need to separate this block but separation also caused a problem this code says you need to First execute S1 then this block then this block and then S7 this block includes S3 in it this blocks include S5 in it so the code says you cannot execute S5 before executing S3 but the graph says yes you can the graph says you can so there is some kind of contradiction there is some kind of complication in the solution I had only two cases either to include that block here or to keep it separate by keeping that block here I'm volting this Edge this Edge and by keeping the blocks separate I'm including an additional age so this is creating a problem this is complicated now okay so can I say about S5 and S6 they are concurrent no sometimes they are and sometimes they are not because S6 depends on S3 and S4 both and these two belongs to different branches okay that's why I cannot say S5 and S6 are always concurrent so the program is you cannot complete S5 before completing S3 but the graph says yes the program would be okay if I put an edge from S3 to S5 but now the edge is not present so there is some kind of problem in the solution the answer is it is non implementable we cannot implement this with pair begin and pair end alone such graphs are implementable using semap for let's see how so we Define number of binary sem fores a b c d e FG and all of them are set to zero so what idea we are using here we are using that as we have defined all of the binary S4 to zero I cannot move to a statement directly see this forget about this graph forget about everything here okay just see this in pair begin I have several statements here okay can I jump directly to this statement and start executing no because I would be directly blocked away because the value of a is initially zero can I directly jump here yes I can jump here I can start executing S1 increased the value of a now can I go there yes now can I come here so what does this VA and Pa VA is increasing up operation on a and Pa is down operation on a so what are we doing we have initialized the value of binary S 4 all of them to zero and now we are making it like a condition that before you execute this statement before you execute the or I should say before you execute this statement you have to execute the above one because in the above one only you have a key to access this statement because if you do not do this this VA you are not able to go ahead with this statement you you won't be able to execute S2 you won't be ex able to execute S4 I hope you're getting the idea let me put it in a simple words v s p or I should say v s p a k suppose S and K are two statements so which statement are you going to execute first obviously VA because initially the value of a is zero if you try to directly go and execute a statement K you will fail you will be directly blocked away that's why it is necessary to execute a statement s first so VA a = to 1 s first will be executed now we comes to PA now the value of a is set to Z Z and now I can execute a statement K so this is how we are using the help of or we are taking the help of SEMA 4 to create a sequence here we have created sequence you need to execute first s and then K only here sequence is created so that's why we are using SEO to create a sequence let's see how are we going to use that sequence thing in in this our uh our question so we want S1 to be executed first then S2 and S3 that's why we we created a lock here and a key here so if someone directly try to execute S2 and S3 they will be directly blocked away so it has to First acquire the key where is the key here is the key so first execute S1 acquire the key for this statement acquire the key for this statement and then end now I have key for S2 and S3 both it's upon me it's or I can say it's my choice on which I should go I can either go to SD I can go to I can go to S2 or I can go to S3 it's my choice why I am given with a choice because these two statements are concurrent we were not given we were not given the choice for S1 we have to execute S1 first because by doing all these things we want to create a sequence we need to execute S1 first now you get a choice to execute S2 or S3 for S2 you after S2 you have to execute S4 see this after S2 you have to execute to S4 there's no other choice so in this this way we are we are planning to proceed or in this way we are going to solve this problem let's now see Again Begin S1 acquire key for this statement acquire key for this statement now let's say I begin with this PA we open the door for this path execute S2 S4 now now now now what happens before going to S5 or S6 before going to S5 or S6 I have to acquire key for S5 or S6 so I have to acquire key for S see this this is the key VC is the key for S5 so I acquired key for S5 and then I acquired key for S6 also see by executing S4 I acquired key for either S5 and then S6 and then we ended now I jumped to here I have key for S5 so I go to this statement executed S5 go got a key to execute the statement 7 got a key to execute the statement 7 so what I want I directly go there to execute the statement 7 but I what I found there is another lock here and what does this lock say this lock say man you need to execute S6 before going to before coming to me because S7 it is dependent on S6 also so what I was trying to do after executing S5 I was directly trying to jump to S7 but the S7 says I have another lock for you and this lock will be opened only when S6 will be executed see see here this lock will be opened this lock will be opened after when S6 is executed okay so what I did I executed this this this got a key for s for the first lock of S7 and then remember I had also key for S6 so I moved here completed uh open the first log for S6 see this S6 also has two logs one and second so the first I got for S4 and the second I need to get from S3 so the first loog I executed I I opened using the key which I got from which I got from executing S4 now I want second key from where I can get remember I had a key for S3 also by executing the first statement I key I got a key so I applied I or I used that key here opened the lock for S3 executed S3 and got the key for S6 now I can open the second lock for S6 executed the S6 got a key for the second lock of S7 opened the second lock executed the S7 and then end for the beginning it may seem complicated but it is not believe me it is not complicated it is just like a it is just like uh remember we used to in in in childhood we used to solve that maze problem you go there go there and then we finally get out of the maze so this is similar to that you just go with the flow execute s S1 first executed S1 first now I got a key for S2 and S3 I got a key for S2 and S3 it's upon me which uh way I I go so I decide to go on the S2 way I decide to go on the S2 Way open the log for S2 executed S2 then S4 got a key for S5 that this VC I got a key for S5 because why why I written like this because for S5 it is necessary to execute S4 first that's why we created lock there at the before S5 and then this lock key is available after S4 so I got a key for S5 and after executing S4 I also got a key for S6 because the output of S4 is input for S6 that's why a key should be given after executing S4 for S6 that's why I got a key here now what I got what I have with me I have the key for S3 which I got from EX this statement I got a key for S5 and I got a key for S6 so I decide to go with the S5 I go with the S5 open the door for S5 execute the statement S5 now you can see S7 is dependent on S5 so I will get a key of S7 after executing S5 now I give got a key for S7 what I decide I decide directly go to the S7 I decide to go to the7 open the first lock but what I see there there is another lock also for this Edge in this and say you have to first open S6 so I go to the S6 I have a I have a key for S6 which I got from this S4 I open the first door for S6 now I've got another lock and this lock will be opened by S3 this lock will be opened by S3 so I go to the S3 execute S3 see I had a key for S3 executed the S3 and I got a key for V which is the second loog of S6 so I've got the second loog of S6 executed S6 got the key for the second lock of S7 for the second lock of S7 exe open the lock and then executed S7 and then end okay so this is how we are going to solve this uh par begin and parent using semop fores okay let me tell you one last time this shortcut for S6 you need to have two keys for S7 you need to have two keys for S5 you need to have only one key for S4 you need to have only one key for S2 you need to have one key for S3 you need to have one key so based on the edges there will be that number of locks see for S6 we had two locks for S7 we had two locks okay so this is how we will proceed with it I hope you understood how are we solving using semap and to check that I have a homework for you the homework is try writing the same program with less than than seven semores try writing the program with less than sem4 see here we used 1 2 3 4 5 6 7 binary sem4 can you optimize it to use that in less than 7 774 try this let's discuss some more problems so we are given with a code and we have to draw the graph let's start S1 we made S1 in the starting pair begin and this pair begin ends here so I can say S9 will be the last S9 will be the last now what comes S2 and S4 so there is a edge for S2 and then S4 S2 and S4 are sequential then this part S3 S3 will be the in the beginning and that S3 and this pair begin PA end will be sequential so S3 and this will be sequential first S3 and then this pair begin S5 pair begin S5 see S5 and this part will be concurrent S5 and this part is concurrent and then S6 and S8 are sequential S6 and S8 are sequential and then par end this ends now what was in the par begin S2 S4 S3 in this part and S7 and S7 and then the end comes S9 so then in the end comes S9 so this is the graph easy question number two we are given with a function void p a b c void q d e Main pair begin p and Q and P and Q can be concurrently executed now we have to select the valid sequences okay I can either start with P I can start with Q I can go like this let me write all the possibility I can go like this first P then Q first Q then P for some time p and then for some time Q for some time q and then for some time P I can go with any of the way for sometime P for sometime Q for sometime P for sometime Q I can go this way also but in all of the sequences the order should be valid B cannot come before a e cannot come before D okay so based on this we have to select the valid sequences can this be valid a b c d e yes we execute first p and then q a b c and then d e so yes this is valid a d b e c is this valid a d b e c yes this is valid I have said we can execute P for some time then Q then again P then Q then again we can go like that there's no problem in that because PA begin d e a b c d e AB b c we can go like that first q and then p d c e b a d and then C no this cannot come because C cannot come before a see here you can see C cannot come before a so this is false this is wrong a e b d c a e no this is false after a even if you are going to Q then D should come see these are sequential these are sequential but these p and Q are concurrent okay so a cannot come or I can say C cannot come before a or E cannot come before D so you have to check that okay so out of these 1 2 and three are correct let's move to the next question this was a nice question in X 0 and Y is z co Co is same as PA begin so it ends here this is co begin begin x = 1 y = x so whenever you are given with the code for better understanding you should make the Precedence graph so we made a precedence graph we started and then this part and this part are concurrent that's why we made this part and this part concurrent this part included this x = 1 y = y + x and this part include Y = 2 and then x = x + 3 so we have to proceed in the same way in the same way now final values of X and Y which of the following values are possible let's check that is this possible is this possible x = 1 Y = 2 let's see so we started with X = 0 here is the start we started with X = 0 and Y = 0 so I go with this first 1 x = 1 and then 3 Y = 2 x = 1 y = 3 but wait the program is not over yet and then I come to two y = y + x what was y y was 2 y = y + x 2 + 1 = 3 so we got 3 here and then four x = x + 3 x = x + 3 what was x 1 3 so X is 4 the final values are 3 and 4 it is not 1 and two so I have not got it yet let's check for another sequence I started with this I go like this okay let's check 3 4 why would = 2 x = so Y = 2 2 x = to 3 now because initially the X was Z here now I go here x = 1 and y = 2 + 1 = 3 so the value which I got is 1 and 3 no it is not 1 2 3 4 if I go in another fashion like 1 2 3 and 4 in this way then does it go like that x = 1 y = y + x initially the Y was 0 so y will also be 1 now y becomes 2 Y = 2 now let's check for x x = 1 + 3 = 4 now the value which I got is 2 and 4 so this is not there so I can say x = 1 and y = 2 is not possible let's check for another x = 1 for this case x = 1 and y = 3 I should go like 3 4 1 and 2 in that case I got the value 3 4 and 1 and 2 in that case we got x = 1 because the value of x was last updated here and y = 3 how y = to the value of y was last updated here 2 + 1 = 3 so this is correct yes can I got x = 4 and y = 6 let's check for that can I get so this was this was not true this was true can I get x = 4 and y = 6 Let's see we start with we start with one and then we two and then three and four are here 1 and 2 okay so x = 1 so we go like that x = 1 okay and Y = 2 yes and then we move down here x = x + 3 which is 1 + 3 = 4 now I'll go here so this is this way I'm moving now I get here the value of y was last updated to 2 and the value of x is 4 so 2 + 4 = 6 so now I got 2 + 4 = 6 so this is also true so the answer was second and third let's move to the next question the question says int x = 0 y = to 20 so initial value was 0 and 20 we have two binary S4 MX and NY and they are both set to one MX = to 1 and m y = 1 we are given with two concurrent blocks this block and this block and so we made a graph PX x = x + 1 M VX MX see both MX are present here MX X = to y + 1 and vmx now what is the final possible values of X what is the possible values of X we have to get that so as we can see the value of MX is 1 I can say this is the critical section so I say we start with P1 first and then P2 so P1 first it comes here P = to MX now P MX so MX will be changed to Z x = x + what is the initial value of x 1 now V MX MX is changed back to 1 now this comes MX is changed back to zero X = to y + 1 so the value was X was what was the value of x initially it was set to one now what happens here x = y + 1 what is y 20 20 + 1 = 22 21 so in this way I can get the final value of x is 21 I get the final value of x is 21 if I go opposite if I go opposite first this way x = y + 1 what is the value of x initial it was 0 so 0 or so y + 1 = 21 I get the value of x is 21 now I go here x = x + 1 21 + 1 = 22 so 22 so if I say you directly you can solve this question without even lifting a pen how is it possible because you can see we are using binary SEMA 4 here binary SEMA 4 with value one can't you remember that this implies sequentiality there is no such concurrency if we are using Mutual exclusion concurrency means that we are not using Mutual exclusion binary sem 4 with value 1 implies sequentiality we have to first execute either this one and then this one or we can go like this one and then this one but we have to be sequential we have to be sequential we can execute either this block first and then this block or can do the opposite like this one and then this one so the final possible values are 21 22 now it's your homework question if P MX and vmx were not there then what will the value of x think on low level what is the meaning of low level break it onto the instructions like load increment store do like that and and then tell me the value of x if Mutual exclusion was not present okay so this is your homework try this let us start our last topic of the section process synchronization fork and join this is not that traditional Fork which we used to talk about it is not the system called and they are Atomic let's see the syntax of the fork is for l what does this fork in join do this the fork divides and the join joins let's see what does the fork divide execution of this Fork will result in starting of two competitions concurrently which will be the two competitions the first statement after fork and the statement at which label is pointing these two will be concurrently started being executed which two the statement right after fork and the statement which label is pointing so these two statement will be concurrently executed the execution of fork result in starting two computations concurrently the first one is which is immediately after the fork and the second one is which is at label L see this and you'll get more clarity int count equals to two why we have def defined count here for joining purposes this count signify how many edges are meeting at that point if I say count equals to three which which means three edges are meeting at the junction okay s one the root node now comes the division that's why we use Fork so Fork Fork l what does l points L points to the statement three S3 so S3 and what is the immediate next instruction after Fork S2 so S2 and S3 will be concurrently being started executing so S2 and S3 are concurrent here now I have to join I have to join how can I join after S2 the control should go to join after S3 the control should go to join so that's why after S2 to make the control flow go to the join we made the label of join as X and then we wrote go to x so after S2 the control should go to join after S3 the control should go to join for S2 the join was not the next immediate statement that's why we included go to statement but for S3 the join was the next immediate statement that's why there is no need to write go to here it will automatically go to statement X without writing the go to because it is the next statement okay so we write after statement X2 go to x and after statement S three the x is automatically here so join will join two statements so these two are joined and at and they are joined at which node the node which is written or the statement which is written right after the join which is as4 do not worry if you are feeling too much of information overload this is an easy concept and you'll get it believe me so what does join do join in count count equals to count minus one if count is not zero then exit else return forget about this this is not much important but I'm telling you okay let's solve some more question you'll get the idea we'll get back to it we'll see some more questions so S1 what we want we need to Fork so S1 Fork L and L should point to which S3 so the next immediately statement is S2 and L should point to S3 L should point to S3 okay now after S2 I want the control go to S4 control go to S4 now I want Fork here I want Fork here Fork K and K should be S6 and the next immediate statement is S5 so the control will be divided to S5 and S6 S5 and S6 here now after S5 S6 and S6 I want to join them so control should go to the join statement so after S5 the control should go to join so after S5 the control should go to join where is the join join is at Zed so I made the label Zed so after S5 control should go to label Zed after S3 after S3 control should go to label Zed control should go to label Zed and after S6 the label Zed itself here so we did not include it go to and then in the end join count S7 so after join whichever node is present at that node the merging will be there okay I hope you got the idea how it's working so road map is if you are dividing include Fork the next statement and l l is S2 okay and if you want to join join count and then in the end whichever node we are joining write that so this is how four can join work so let's see what was written here after S2 and S3 the control should come to join out of the one which complete at last going to make the count Z that will start as 4 easy same thing it's written here now let's see if if there are more questions yes there are more questions P1 P2 P3 and P4 okay so P1 I want to divide that into three parts see this is an interesting problem in Fork if I write Fork L then the immediate instruction after Fork let's say S1 I'll get S1 here and whichever instruction this level is pointing let's say S2 those two will start concurrently but how I'm going to branch that into three is there any way is there any way to Branch them into three so first of all if you are planning to join them into one node then you should make the count equals to three P1 Fork L Fork L we divided into P2 and L is pointing to another fork and that fork is pointing to another thing that is p Fork so we are using two forks so the first fork and the second Fork are you seeing this the first fork and the second Fork P2 P2 is executed and then label n is pointing to another Fork x n is pointing to another Fork X after X P3 is there after X P3 is there and the next statement that will be there is P4 so P4 is come here so these three will be concurrent and now we have to join them how are we going to join them after P2 the control should go to P5 the control should go to P5 and we have made a label join K so control should go to join K here this way after P3 the control should go to join after P3 the control should go to join X after P3 okay after P3 the control should go to there okay now after P4 the control should go to this join but it is already there that's why we did not include go to so we came here and these three will be joined to which node P5 which is immediately just just after the join let's move to another question this will clarify all your doubts n and M are set to two n is set to two and M is set to two two folks are there which which means right just after the start the program will be divided into three branches for two folks the program will be divided into three branches the first is S1 the first is S1 the second one is the label L3 where is label L3 the label L3 yes this is here the S2 the second one is S2 and the third one will be level L4 where is level L4 here S4 the third one will be here S4 so the program right after the star divided into three things three branches after s the label comes to join n the label comes to join n so we have to join we have to join we have to join and what is n n is the two which means two of the edges are going to join and come at where S3 so S3 will be the point where two edges are joining which two edges are there so the first one is after S1 the L1 which is joining statement comes so the first Edge will be of S1 and the second Edge will be of will be of the statement after which the control is shifted to the label one which statement after which control has been shifted to label one see is there any go to statement go to go to go to go to go to label one is here so after S2 I am finding a go to statement which is sending me back to join so after S2 join is going to happen see we did the same thing everywhere don't get confused whichever edges we want to join after that node we sent the control to the go to statement or the join statement see after P2 we want to join after P2 we want to join that's why we sent to joining statement after P3 we want to join after P3 we want to join that's why we sent to the joining statement after P4 the control will automatically go to join that's why P4 is here to join same thing is happening here after S1 control automatically get to join that's why join after S2 the control has been shifted to join I use the help of go to statement that's why S2 will be there and whichever node is after that join statement the edges will be merging there that's why S3 is here okay after S3 after S3 join M so some join operation will here happen also okay now I have to find the go to statement which is sending the control to this label to go to statement go to statement go to no go to this go to what is sending label to join n no I want the control to join M L4 L2 see here I have found so after S4 the control has been sent to this so from S4 The Edge will come because after S4 the control has been sent to this so after S4 The Edge will come now what will happen whatever be the node after that join statement join will happen there so the join will happen at S5 see in the previous case whichever node after coming join that is S3 join will happen there whichever node after coming the join join will happen there that why join happened here okay now what happens go to next what is next this has already been executed already been executed already been executed go to already been executed now this thing S6 that's why we xess so this is how we solve the questions of for and join just remember one thing or two things I should say for four Fork you should remember two things the control will be divided at two nodes the first which is immediately after the fork and the second will be the fork which is it labeling to see the fork is labeling to L which is S3 should come so S3 came here for fork you have to remember these two things for join which two things you have to remember for join you have to remember after join whichever node is coming join will happen at that node merging will happen at that node and whichever node after which the the control is sent to the join statement that node edges will be merged at the node which is coming after the joining statement let me repeat again see after S5 the control has been sent to join so S5 Edge will be merged at S7 after S6 the control has been sent to join so S6 Edge will be merged at S7 after S3 the control has been sent to join so S3 Edge will be joined at S7 okay so these things you have to remember for for so basically here our section of process synchronization is over but before just uh making it end like that let's see some revision questions the question says consider the following C code where s is a sem4 initialized to five in line two and counters a shared variable initialized to zero in line one assume that the increment operation in line 7 is not Atomic are saying the counter is set to zero the SEMA 4 is set to five there is some function which include two two weight operation one increment and two signal operation it says if five thre execute the function PA of concurrently which are the following program or behavior is are possible there's a deadlock involving all the threads is that possible yes it is possible let's say there are five threads T1 T2 T3 T4 T5 the first one come execute this weight on so this becomes four gets preempted second one come execute the first operation s becomes three now this one comes s becomes two now this one comes s becomes one now this one comes s z now now T1 comes again and start with this but s is zero will get blocked T2 come again and start with this s is zero T will get blocked will get blocked blocked blocked so all of them are blogged in this way deadlock is present so the question was asking which of the following are possible is deadlock possible yes preempt after one instruction and then execute all of them and then when they will come back again they'll get blocked okay so this is deadlock is possible the second question says the value of counter is five after all threads successfully complete the PA of instruction yes the value of counter will be five how let all threads execute sequentially in that case first T1 will execute and then T2 will execute and then T3 and then T4 and then T5 in this way if the sequential execution happen the value of counter is five the value of counter is one after all the threads successfully complete the execution of perrow can the value of counter be one yes when the counter will one okay see this process one P1 or the thread one load increment and it just get preempted before it can store let P2 P3 P4 and P5 complete make the changes so the initially it was Zero when it when P3 was about to make the changes it gets pred P2 P4 P3 and P5 comes makes the changes make it to 4 and now P1 is storing its value as one so this is how the counter is one see we have have done so much of questions like this don't uh feel confused if you are feeling confused just go back watch some lectures we have solved so much of difficult question on that this is an easy one you should uh this should be a cake for cake work for you okay P1 and then in the end we store load increment preemption make that that these process complete and then P1 is come to store so the final value will be one yes this is true the value of counter is zero after all threads execute or successfully complete the execution of per no the value of counter can never ever be zero in any case after the execution of all these threads okay the value of counter can be 1 2 3 4 5 depends on how process executes so so this was an this was uh uh brainstorming question how can the value be one this this way how can value be two these two store later and these two comes first so after P3 P4 and P5 have completed the execution now P1 and P2 comes and store their value so this is how value can be two value can be three when when P4 and P5 makes the change and then P1 P2 and P3 sequential execute and make the value three so this is way things will go on okay now there is another homework question for you if we initialize the sem 4 to one and remove one weight and Signal here so what is the question now the S 4 value is now one and vit s count Plus+ signal s signal s what is the possible value of the count now you have to tell me this see if you tell this wrong I'm going to come at your home and give you a nice beating because we have done this type of question so many times you can even in a blink of eye you can you should tell the answer of this let's move to the next question this is a homework question solve it yourself let's move to the next question int count equals to Z while test let's see another similar question it says int Counting equal to Z void test and then in test there are five times count Plus+ par begin and then two times test so this is like this I can segregate into two count Plus+ count Plus+ five times here also count Plus+ count Plus+ five times now it's asking what is the minimum and maximum value of the count see this is an amazing question this is a nice question you should give it a try for maximum you can directly say when the the value of count will be maximum when the execution is done sequentially first find time this and then five time this in that case the value will be 10 so the maximum value is 10 but can you guess the minimum value the minimum let me tell you something the minimum value is not five and the minimum value is not one now you have to tell me what will be the minimum value and this is a homework problem we will discuss it later okay so here we have officially completed our process synchronization section in the next section we will start Deadlock we have successfully completed our last section that is process synchronization in this section we are going to learn about deadlock what is deadlock how deadlock happen how we can prevent deadlock how we can recover if deadlock is already happened all these things we are going to cover in this section let's start with what is deadlock deadlock is when two or more processes are waiting for an event that is never going to happen or waiting for the happening of an event that is never going to happen Okay so let's say process P1 is waiting process P2 let's say there is a resource some resource R1 that is hold by process P1 and there is some resource R2 that is hold by process P2 now process P1 wanted resource R2 and process P2 want resource R1 they are both waiting that they can get resources but P1 is saying you first release then I'll complete my work and then you will get both resources and P2 is saying the same thing both are adant do you know the meaning of adant it is a stubborn so both are being stubborn I don't know spelling of stubborn is that the spelling anyway so in deadlock the process need to be stubborn otherwise deadlock will not happen and the process should be non preemptive otherwise what will happen suppose P1 is a high priority process so what it will do it will just snatch away the resource R2 from process to so this should not also happen in a deadlock so what is deadlock deadlock is P1 is waiting for P2 to release resource R2 and P2 is waiting for P1 to release resource R1 in this way they are waiting for such an event that is never going to happen why because processes are stubborn they are they will never ever release their resources okay so this is what deadlock is they waiting for an event that is never going to happen but you see they are not only just waiting they are also holding up the resources so this is the worst thing they do not only wait but they hold up the resources the consequences will be uh the throughput and efficiency drops ineffective utilization of resources therefore this deadlock thing is undesirable okay now we have to also understand the difference between what is deadlock and what is a starvation they seems similar in some way but they are not starvation is blocking for indefinite time you do not know the time when you'll get the chance and Deadlock is you have been blocked for infinite time you have been blocked forever and what is starvation blocking for indefinite time so you should know the difference between indefinite and infinite infinite means forever and indefinite means you just don't know okay so here are some examples of Deadlock this is Rachel and this is Ross Rachel wants to make omelette and Ross wants to make pancake so for omelette and pancake they both need a pan and an oil so what happens Rachel gets the oil to start cooking and Ross grabs the pan what happens now they are both stubborn Rachel won't release the oil till she get the pan and Rose won't leave the pan till he get the oil so in this way they are both both being stubborn so adamancy is required for deadlock Rachel is waiting for Ross to release the pen and Ross is waiting for Rachel to release the oil in this way they are both waiting and they will wait for forever so this is what deadlock is okay so we can say Ross uh Rachel is the process one and Ross is the process two let oil be the resource R1 and pan with the resource R2 okay so resource R1 that is uh this o has been assigned to process one that is Rachel so resource R1 is assigned to process one and process one is waiting for resource R2 that is the pan and resource R2 has been assigned to process two that is Ross and Ross is waiting for resource one that is the oil so in this way deadlock occurs so for deadlock cycle is required okay here is another meme from 3 D movie if you not watched that movie you should watch it's a great movie so this is a meme from that M so interviewer ask the candidate explain deadlock and we will hire you the candidate replies hire me and then I'll explain to you so this is exactly what deadlock is let's discuss the salary so now System model what kind of system we are assuming for the study of Deadlock so n depicts the number of process P1 P2 till PN m m depicts the resources R1 R2 RM they can be the hardware resource or software resource okay and the resource can be either single instance or multi instance resource what is multi instance copies of the single instance Source okay now this is the process process request the operating system to Grant the resource operating system can do two things it can grant or it can deny suppose the resources granted process will use the resource and it will release and give it back to the OS and suppose the OS denies the process request then what happens process get blocked and it will starve and suppose after some time operating system feel pity on the process he grants the resources what happens then process will reuse the resources and then after the completion of work it will release the resources back to the operating system but this is a case that that process get blocked and operating system never grants that process it's required re resources then what happens it will be blocked forever there's no one who will wake up the process and say hey your resources has been granted you can go and do your work now no this process has been blogged forever and this is what exactly deadlock is okay for example SEMA 4 in One S then single instance in multiple s then multiple instance it's just the thing that resource can be of two types single instance and multi instance multi instance is nothing but the copies of single instance this is what it's written here now comes the necessary condition for deadlock the first is there should be critical section some shared resource deadlock will never happen among independent processes see here if if Rachel if Rachel never wanted the pen and if Ross never wanted the oil do you think deadlock will happen no deadlock won't happen so deadlock never happens among independent process so there should be some critical section there should be some shared resources the second Point says process should hold some resource and should wait for another this is also the necessary condition for deadlock suppose Rael would have never hold the oil and is never asking for the pen do you think deadlock will happen no for deadlock hold and weight should be there processes holding some resources see here in this case also hold and weight is present so hold and weight is necessary condition for Deadlock process should be holding some resources and asking for another resource if holding weight is if hold and weight is there can I say it implies deadlock no it doesn't imply deadlock but if I say deadlock is there can I say hold and weight must be there yes hold and weight must be there see this suppose this is what this is uh process Pi process Pi has been holding resource R1 and requesting for R2 and R2 has been acquired by PJ do you think deadlock will happen in this case no deadlock will not happen see here here Pi is holding and waiting some of the resources but PJ is not there PJ is not waiting for the for R1 which has been called by pi so in this case deadlock won't happen why see this Pi is just requesting for resource R2 and is it has not get resource R2 delet it PJ has resource art so what it will do it will just use the resource and see here and when a process is granted with some resource it will use the resource and will release back to the operating system so when this PJ will release this this R2 it will be granted to Pi and Pi will do its work is there any case of infinite blocking present no so I cannot say if hold and weight is there see hold and weight is there but deadlock is present no deadlock is not present but but if I say dead log is present then hold and weight should be there yes this should be there see example of Deadlock py P1 is holding some resource and requesting for another P2 is holding some resource and requesting for the another if deadlock is present then hold and weight will be there so if I say hold and weight implies deadlock see this no it doesn't imply deadlock does deadlock implies hold and weight yes see this deadlock implies hold and weight okay third thing no forceful snatching of resource no preemption should be there take this scenario suppose Ross and Rachel are brother and sister and what happens this uh Ross is the big brother what happens he pushes the Rachel away and by force he snatches the this oil bottle do you think now Ross is going to wait for infinite time no this will not happen until she complain his father about his behavior this is one going to happen so if forceful snatching is allowed then deadlock will not happen I hope you are getting the point no forceful snatching of resource this is also a necessary condition and the fourth necessary condition is circular weight should be present circular weight should be there see P1 is waiting on P2 P2 is waiting on P3 and P3 is waiting on P1 in that case deadlock will happen see here no circular thing no deadlock circular thing is present Deadlock lock circle cycle is present deadlock cycle is present deadlock okay so cycle should be there for deadlock okay if these four condition are present then there is a possibility of Deadlock see see here if I say if there is critical section present then there will be deadlock can I go from necessary condition to deadlock no but can I go the opposite way yes if deadlock is present then these necessary condition must be fulfilled see if I say if I say critical section is present then will it lead to deadlock no is this a joke no critical section if critical section is present then there should be deadlock absolutely not and if deadlock is there there should be critical section yes it is necessary it must be there otherwise deadlock won't happen if I say hold and weight is present then deadlock should happen no it is not necessary but if I say Deadlock is there then Wen weight should be there yes this is must same thing for it if I say oh I can say for this thing circular weight if I say deadlock is there then circular weight must be present yes but if I say circular weight is there then deadlock will happen think about it if circular weight is there then deadlock will happen can I say for fourth condition that I can go both around ways can I say so if circular weight is present then deadlock will going to happen I cannot say this because circular weight is a necessary condition not the sufficient one consider this case uh John needs a screwdriver from Mar Mary needs pliers from Ken Ken needs a wrench from Lisa Lisa needs the screwdriver from John and now what happens John says hey Lisa take this screw driver which means they are not admin now so can I say circular weight implies that no what happens if one of them is not adment then deadlock won't be there so circular weight is not the sufficient condition for deadlock but the necessary one if I said deadlock is there then circular weight will be present yes that is must so if these four condition are present then there is a possibility of Deadlock and if deadlock is there then these four condition must be present I hope you got the point now okay in the next lecture we are going to see resource allocation graph let's start with the resource allocation graph the graph consist of vertices and edges in the same way resource allocation graph vertices of two different types processes and resources process is represented using this circular node with pi in between like P1 P2 in this way processes are represented and resources are represented using this square or rectangular node it can be of two different types single instance and and multi instance single instance has one dot in between and multi instance it has multiple dots in in this rectangular body but this dots represent number of instances suppose here are three dots which says there are three instances of resource RG okay now comes to the edge The Edge can be of three types claim Edge request Edge and assigned Edge so the claim says Pi is the process claiming the resource RI and RI is a single resource single instance resource request Edge PJ is a process requesting for multiple resources or two resources of or two instances of resource RG and assigned Edge is the opposite way resource RK has been assigned to the process PK okay let me repeat again so in resource allocation graph there are vertices and edges vertices can be divided into two process and resources resources can be of two types single instance and multi instance the number of dots in the representation that is the rectangle says the number of instance of that resource there are three dots which says there are three instance of resource RJ now comes the edge claim Edge request Edge and assigned Edge the dotted dotted Edge is the claim Edge which means process Pi is claiming the resource RI the single instance of resource RI request Ed says process PJ is requesting for two resource or two instance of resource RJ it's not two resource it's two instance of resource RJ and assigned Ed single instance resource RK has been assigned to process PK so request and assigned is clear what is the claim Ed claim is the process May request that resource in the future and request as says it is actually requested and assigned Ed is resource all allocated to that process claim says may request in future request says it has already requested and assigned says the resource has been already allocated to that process okay so this is resource allocation graph so here one more thing to notice see I have made two arrows here this two arrows signifies number of instances that PJ is requesting suppose if if in a case in which there should be there will be two two resource of RK and that two resources are already allocated to PK so I will add an additional edge here so the number of edges represent how many instances of that resource have been either requested or assigned okay so number of request or assignment is that many edges okay so this is how resource allocation graph looks like process P1 is requesting the resource R1 the single instance of resource R1 has been assigned to process P2 process P2 is requesting for R3 and single instance of R3 has been assigned to process P3 okay one instance of resource R2 has been assigned to P2 and another instance of of resource R2 has been assigned to process P1 okay and this uh one instance of resource R4 has been assigned to process P4 so this is how you have to read the resource allocation graph see this process P1 has got one instance of resource R2 and is requesting for R1 but R1 is not free or R1 is already assigned to process P2 so operating system is not able to give resource R1 directly to P1 so in that case P1 will move to the block State same case for P2 P2 is acquiring resource R2 and resource R1 but is requesting for resource R3 but resource R3 has been already assigned to process P3 so in that case P2 will get to block state P3 but p3s will be able to run on CPU because it has already required that resource which is necessary for it to run on CPU so P3 will is free to run on CPU P3 will run on CPU P3 will after completion of its work it will release the resource R3 and that R3 will be then granted to P2 and after P2 complete its work it will release resource R1 and resource R2 so that R1 will be assigned to P1 now and P1 From the Block state will be wake up by the operating system and that R1 resource will be granted to P1 so this is how it's going to work graph G2 P1 is requesting for resource R1 but is has acquired resource R2 P3 is requesting for resource R2 but has acquired resource R1 P2 is requesting or this is an allocated so R1 is allocated to P2 now see now see P1 is holding R2 and requesting for R1 P3 is holding R1 and requesting for R2 but R2 has been assigned to this P4 do you think deadlock will occur in this case no deadlock won't occur what I've have said if all the processes are blocked by the operating system because the resources were not available at that time to give to the process in that case only deadlock will occur I have said all the process even if one process is free to run on CPU then that process see here that process will release its resour and will prevent deadlock same case is going to happen here R4 see this P4 is going to release resource R2 that R2 will be given to P3 P3 will complete its work and that P3 is going to release resource R1 and that resource R1 will be eventually given to process P1 see here cycle is present but deadlock is not present so from necessary condition I cannot go to deadlock but from deadlock I can go to necessary Neary condition if you are getting confused just remember this line necessary condition are not the sufficient condition if deadlock is present it means that necessary condition must be fulf fulfilled then after deadlock can happen but necessary condition are not sufficient condition same case happened here cycle should be there for deadlock to happen if deadlock is present then cycle must have been there but if I say cycle is present will deadlock happen I cannot guarantee that see this case let's see an interesting case suppose if I add an edge here what can you tell about uh will deadlock occur in this resource allocation graph analyze and see P1 is holding R2 and requesting for R1 P2 is holding R1 and R2 and requesting for R3 P3 is holding R3 and requesting for R2 P1 will be blocked because R1 is not available as it is hold by P2 P2 will be blocked because R3 is not available and P3 will be blocked because R2 is not available in this way these three process will be blocked but see here P4 will run completely P4 even after running will release the resources R4 but can you think R4 is going to help in this matter no it is already isolated so for that case deadlock will be there in this resource allocation graph before was not blocked it was free but even after completing its work and releasing its resources R4 is not going to help in this matter for there I can see it is not required for all of the process to get blocked okay see firstly you have to check if all the process are blocked or not if yes then you can say directly deadlock is present if no then check those process which are not blocked after releasing their resources are are they going to help in the matter of solving deadlock if yes if they will help then deadlock won't OCC and if no then deadlock will occur as simple as that till now we have understand what is deadlock and what is a resource allocation graph how are you going to identify deadlock by seeing a resource allocation graph now we are going to see deadlock handling strategies the first one is deadlock prevention the second one is deadlock avoidance these two deal with the case when deadlock do not occur prevention and avoidance as the name suggest the third one is deadlock detection and Recovery the fourth one is deadlock ignorance so these two deal with the case when deadlock either have occurred already or will occur in future as the name such as deadlock detection can deadlock occur in future and Deadlock recovery if deadlock has already occurred then how are we going to recover from that the fourth one say is deadlock ignorance ostrich algorithm do you know what OST ostrich ostrich does it bury its head into the mud so this is what ostrich algorithm is that is no strategy if deadlock have occurred let it happen we will see the worst cases so this is what deadlock ignorance is okay in deadlock idence we are going to learn about Banker's algorithm this is a very famous algorithm by dter dter is the person who implemented SE 4 you have heard his name so many times in this computer science engineering so txra is a great man or was a great man I don't know dtra have done so many contribution in the field of CSC okay anyway deadlock detection in this we are going to see the doctor's algorithm and Deadlock ignorance or algorithm so we let start with the ignorance ofch algorithm which is no strategy algorithm so when system will go to the deadlock it will get hanged it will get hanged so in that case what we do we press the restart button and fortunately unfortunately what we say windows Unix Linux all uses a algorithm because deadlock occurs very rarely and the cost of prevention is high that's why they say if deadlock occurs just put your head into the mud just bu your head like ostrich do daytoday operating system the deadlock occur very rarely and the cost of prevention high so it doesn't require the deadlock prevention we have to what we have we have to use this deadlock prevention in those operating system in which data and time are critical for those operating system in which we can afford deadlock to happen we don't give much much attention because the cost of prevention is high but in those operating system in which we cannot afford deadlock to happen in which data and time are critical in that case we have to use deadlock prevention strategies you cannot lose one bite of data even for 1 millisecond system should not be down even for a 1 millisecond for example Air Traffic Control missile control satellite control system in these critical operating systems deadlock prevention should be acknowledged okay so now we are going to see deadlock prevention and how are we going to prevent deadlock by negating one or more necessary condition can you remember the necessary condition which we have studied for deadlock the first one was there should be a shared resource there should be critical section the second one was hold and waight the third one we did was no pre no pre preemption and the fourth one was circular weight so if I negate either of these four strategies either of these four conditions then deadlock will not happen see what I have said necessary condition as the name suggest these four condition all of these condition are necessary to happen at the same time for deadlock to occur and if I am able to negate even one of these four condition then deadlock will not happen Okay so this is what deadlock prevention does negating one or more of the necessary condition so let's see one by one which condition I can negate critical section can we remove a critical section well I cannot even imagine of a multiprogrammed operating system without a shared resource so critical section will be there it is almost practically impossible to remove critical section okay so this thing critical section condition is no dissatisfied viable now let's move to the second condition hold and weight instead of hold and weight can we adjust it to hold or weight can we do like that let's see so process must request and be allocated all resources prior to its start if we can do something like that in that case hold and wait thing can be avoided see this P1 for 30 minutes of phase 1 P1 wants R1 and R2 and for 20 minutes of phase 2 P2 P P1 bonds R2 and R3 so generally what process do after the phase 1 that is after 30 minutes process P1 will release R1 hold R2 and will request for R3 because process 1 knows that after after Phase 1 in Phase 2 P1 will going to need R2 so it releases R1 and hold R2 and request for R3 so this is the case of hold and weight but if r R3 is not available it's going to wait so this hold and weight we want to avoid how can we avoid this hold and weight so we have two protocols to avoid this hold and weight the first one is to avoid this case of hold and weight we can do like this process will ask for all R1 R2 and R3 before the beginning of phase 1 so for the whole time when process is going to run in the CPU process will prior request all the resources which is going to need for its whole phases for Phase 1 Phase 2 and even if in future it will go for some phase three then combining all these phases which resources process one will need that it should ask even before phase one so this is what protocol one says so if available hold these resources go on do the work and this will prevent the case of hold and vit because it has got all the resources which which is going to need so there is no waiting there so if available hold and if not wait see there is no hold and wait it's hold or wait if available then hold if not then wait so there is or between either of them will happen either available or not available but there no case of hold and wait but this protocol one gives some serious drawbacks the first one is starv Vision see this process one is waiting for that perfect chance in which R1 is also free R2 is also free and R3 is also free in that case P1 will request and will get these three suppose R1 and R2 P1 is acquired P1 is required R1 R2 but not R3 so what it will do it will release them wait for that time in which R3 is also free request for all these things but what happens R3 is free now R1 is free now but R2 has been acquired by some other process P2 because it is not holding them so for finding that perfect moment R1 R2 and R3 all of them are free this has to wait for a lot of time P1 has to starve so starvation is the obvious drawback the second one is inefficiency in Phase One why are we holding R3 for 30 minutes see why what protocol one says hold all the resources which you are going to need in future even before phase one so when phase one will start for these 30 minutes R3 will be holded by P1 so this is very inefficient utilization of resources so to recover that or to find a better algorithm we had moved to protocol 2 what protocol 2 says process must release all resources before making a fresh or new request suppose this thing happens P1 got resource R1 and R2 completed its phase for 30 minutes now phase one is completed after Phase 1 process will releasee R1 and R2 according to protocol 2 and will ask for R2 and R3 again see P1 has just released R2 and it asking for R2 again so there may be a chance in which when it has released R2 suddenly it got assigned to some other process so it has to wait again so starvation is still present but inefficiency has been renoved inefficiency has been removed see we are not holding R3 in the phase one so in this case hold and weight is not present so for both protocol one and protocol 2 hold and weight has been avoided so out of these four condition first one is non diss satisfiable hold and weight is this satisfiable but it comes with serious drawbacks now comes to the condition three no preemption can we preempt can we preempt let's see so preent preemption of resources from the process can be of two types either forceful preemption or self preemption forceful preemption says running process should not get blocked forceful preemption says running process should not get blocked and self preemption says adopt selfless attitude say this allow pi to forcefully take away RB without bothering what will happen to pjc this is CPU process Pi is running on the CPU ra is already located to process Pi now what happens Pi wants a new process a new request uh what I'm saying Pi wants a new resource RB so it's requesting for a new resource RB but see RB is already allocated to PJ but what my protocol says forceful preemption says running process is of utmost prity running process should not get locked so I will snatch away the resource RB from PJ and will give it to D without bothering what will happen to PG later so running process got the right to snatch away the resources from ready process so this is forceful preemption and what does self preemption says running process Pi founds out that RB is not available instead of snatching RB it will release its resources ra thinking that others might be in need of my resource why should I hold and wait up why should I hold the resource and wait for some other resource instead I should release my resources in order that someone might be present there who is hoping to get the resource which is present with me so both these strategies prevent deadlock let me revise no preemption can it be avoided yes we can do preemption based on two protocols the first is forceful and the other is self what does forceful forceful say running process should not get blocked Pi is Pi already has resource R and is requesting for a new resource RB which is already allocated to some other ready process so what happens Pi snatches away RV from PJ not thinking of PJ what will happen to PJ it snatches away its resources complete its work it's like a selfish attitude and it self self preemption it adopts a selfless attitude Pi is running on CPU ra is allocated to Pi but instead of snatching our resources of RB what happens Pi release away its resources by seeing the hey RB is already located to PJ I cannot get RB from PJ so should I or I should release away my resources because someone there might be someone there might be present who is requesting resource ra so Pi is adopting a selfless attitude by releasing away its resources okay now again comes the problem of starvation you can guess why fourth condition is circular fate circular fate prevented by total order relation among processes and resources so what is this total order relation we will see so the protocol says assign unique number to each resource and never allow a process to request a lower numbered resource than the last one allocated see this so what happen we assign a unique number to each resource there are this is the list of resources I have allocated I have allotted a unique number to each resource to Resource a IED 10 to Resource d i alled four so this is this is a resource ID a unique number okay and now never allow a process to request a lower numbered resource then the last one allocated see this PR PR has been allocated see the resource ID was three now PRI can only request for those resources which has a resource ID greater than three can it a request for B yes 8 8 is greater than three yes now it can only request for those resources which has a resource ID greater than 8 can it request for D no can it request for G no can it request for a yes because the resource ID of a is greater than the resource ID of B so what are we doing here basically we are removing the cycle and we are introducing linearity to avoid circularity okay so what does this algorithm say process I can only request for those resources which have ID greater than 10 now now it can only ask for those resources which have ID greater than 10 which means it can ask for either F or e that's it okay now say this if process I request for those resources which has a ID less than 10 then what happens suppose process I request for G then what will happen it has to go back and you can see the cycle is forming if request if it request for five then cycle condition what to do then resource preemption okay so you know what to do you have to preempt the resource and then Grant again how suppose after getting a after getting a resource with resource ID 10 the process wants to get resource with the resource ID of five which means process one to get resource G now what will we have to do we have to snatch away the resource with resource ID 10 we have to snatch away with the resource with resource ID 8 and now I can give the proc with resource id5 so now 3 5 8 and 10 now we are going to Grant it again so basically whatever we're doing we are just avoiding circularity we do not want circularity the first firstly the process got resource three then eight then 10 now it wants five so what I will do I will preempt 10 preempt eight assign five and then we'll Grant again 8 and 10 so in this way the linearity is maintained as circularity do not come the resource given plus linearity is there now starvation is obvious starvation may come because when I preempted these resources some other process May request for this so I can give process request I can give process the source id5 but when it will request for 8 and 10 Again these were already allocated to some different process so it has to starve so this granting again thing is dangerous it invites starvation so after these four condition which conditions which we can negate so the first one was can we remove critical section no we cannot remove critical section second one was hold and waight can we avoid hold hold and weight yes we can avoid hold and weight by two protocol the first one was ask for all resources in the beginning the second one says if you made a new request you should release all the previously assigned resources the third one says no preemption yes we can preempt the first one is forceful the second one was self and the fourth one says circular weight can circular or the cycle be avoided yes it can be avoided by this algorithm a process can request only those resources which has a resource ID greater than the previously allocated resource ID okay in this way the cycle is preed prevented in our previous lectures we have learned about resource allocation graph in this lecture we are going to see an interesting property of resource allocation graph so if RG is a resource of multi instance type then cycle is only a necessary condition focus on the word necessary if cycle is present there may or may not be deadlock but if deadlock is there then there must be cycle cycle must have been there okay but but if there are only single instance type resources in that particular area of a graph where cycle is forming then in that case cycle is necessary and sufficient also in that case I can see cycle leads to deadlock see for General cases I cannot see necessary condition leads to deadlock this is false but if deadlock is present then necessary condition must have been fulfilled but here in this case if only single instance type resources are present then I can say cycle leads to deadlock then I can say cycle leads to dead log is correct okay you have to remember this so let us summarize only multi instance cycle is necessary combination of multi and single instance cycle is necessary only single instance cycle is necessary and sufficient so in our last lecture we have learned about deadlock prevention in deadlock prevention what we try to do we try to negate one of the four necessary conditions in deadlock avoidance what are we going to learn let's see so deadlock avoidance can be divided into two parts are single instance and multi instance single instance in which resources have a single copy and multi instance combination of single and multi instance a resource can have multiple instances okay so in single instance we are going to learn about resource allocation graph algorithm and for multi instance we are going to learn about Bankers algorithm you must have heard the name before okay so both algorithm are based on a prior knowledge you know meaning of a prior beforeand and the operating system should know that with that the process is going to need which resources in future while executing so that is a prior knowledge every process need to tell which resources she needs before hand to the operating system okay that is a prior knowledge now let's learn about resource allocation graph algorithm which is based on single instance type okay so as I said it is based on a prior knowledge the process need to tell which resources she needs beforehand to the operating system and based on the request operating system will grant or deny its request so on what factors operating system grants or deny the request it will see if operating system grants that resource to that process where the system will lead to okay if it it will lead to save State then resource will be granted and if it will lead to the unsafe State then resource should be denied so operating system will see the is fulfilling that request will lead system where will it be safe will it be unsafe what does safe signify the S safe signify that there won't be any deadlock and what does unsafe implies it says there is boring there may be likelihood of Deadlock deadlock may be present okay there are chances of Deadlock okay so unsafe doesn't mean deadlock UNF says there are chances of Deadlock okay so there are three points which you have to uh focus upon while Learning Resource allocation graph algorithm the first thing is resources are claimed a prior in the operating system okay that I have explained what is a Priory if the process Pi start executing then all claim edges must appear in the resource allocation graph see I have told you what is claim Edge claim Edge is that edge that dotted Edge which go from process to Resource which signifies that that process May request that resource some in the future okay so what does claim ad says in future request may happen Okay suppose if Pi request some resource R let let me if process Pi request some resource R then request is granted only if when request Edge is converted into assigned Edge and that introduction of New Edge is not going to lead or is not going to introduce a cycle in the graph let me repeat when a claim edch is converted into assigned Edge then cycle should not come in the graph see firstly it was claim Edge the process May request somewhere in the future then process actually request and then when operating system grant that resources to the process then assigned Edge comes and introduction of this new Edge should not introduce a cycle in the graph see adding a new Edge May introduce a cycle in the graph that should not be there and if that is present then operating system will deny see this if in resource allocation graph algorithm when we are talking about single instance type then cycle will lead to a deadlock okay so no cycle then then safe State and cycle then unsafe State why I written unsafe State instead of Deadlock if I knew that resource allocation graph algorithm work on single instance resource and we have learned here that if there are only single instance resource then cycle is necessary as well as sufficient so why have written here cycle will lead to unsafe State not deadlock the reason will be clarified in the example which I have taken so the base objective of resource allocation graph is is to always operate the system into safe State and what does safe State means if request Edge is converted into assigned Edge then that edge does not lead to a cycle in the RG if you getting confused don't worry here's a perfect example it says the P1 is holding R1 and this as shows that it may request for R2 P2 is requesting R1 and may request for R2 in future so this is what this graph says okay here should be P2 you should correct that in your notes also now if I ask you is the current state is in safe State you will say absolutely it is in safe State because there is no possibility of cycle here see I cannot go this side because the arrow is in opposite direction so cycle is not present so I can say the system is in safe State when will system gets into unsafe State the system will get into unsafe State when a cycle is introduced okay so when a cycle will be introduced suppose R2 is granted to P2 now the arrow changes now cycle is introduced so I can say the system is in the system is in unsafe State why not deadlock because this Edge is not an actual Edge it is a claim Edge so for just saying we are saying that cycle is present but actually this is not an actual Edge this is a claim Edge it may request for R2 in future okay that's why we have written here that if cycle is present then it is unsafe state but if P actually request for R2 then it is surely a deadlock State not an unsafe State now it is surely in deadlock State how can I say it is in deadlock because first of all we are Learning Resource allocation graph algorithm and this algorithm is defined only for single instance resource and I have said that for single instance resource cycle is necessary as well as sufficient condition so when when P1 request for R2 deadlock will surely happen see this R1 is with R1 is granted to P1 so P1 is holding R1 and requesting for R2 P2 P2 is holding R2 and requesting for R1 you can see a cycle clearly that's why deadlock is is present so claim Ed is also a part of graph claim is not different that's why we have said that when in this case we have said that the system is in unsafe State because cycle is forming but it is not an actual cycle clay match is not an actual as but it is still part of the graph okay I hope the point is clear now so the first system was in safe state it wents to unsafe State and then finally to Deadlock and what is the basic purpose of resource allocation graph algorithm it operates to keep the system is in safe mode in above case when claim Edge when claim Edge becomes the request Edge then it is allowed see here when this claim Edge must have become become request Edge at some time that's why R2 is granted to P2 otherwise how will operating system know that P2 is requiring R2 so this clay Edge must have become request Edge at some moment so when this clim Edge become request Edge then also cycle was not present see here it is in the opposite direction but as soon as operating system fulfill its request and grants R2 to the P2 cycle is introduced well that will lead system to the unsafe State okay now you have to understand the difference between unsafe State and Deadlock unsafe state says there are chances of Deadlock not an actual deadlock so I can say this this is unsafe State and Deadlock is just a small part of it okay so System state there there can be they can be segregated into two safe and unsafe and Deadlock is a part of unsafe State okay and unsafe State just signifies the warning it is it say that deadlock may occur okay so this is what resource allocation graph algorithm in the next lecture we are going to see Bankers algorithm we were learning about deadlock avoidance we have already learned about resource allocation graph algorithm which was it was based for single instance resources now let's move to Banker's algorithm for multi instance it has two subart safety algorithm and resource request algorithm before directly jumping just to safety algorithm let me establish the foundation okay so the N is the number of processes m is the number of resources okay maximum this is an twodimensional array this is a 2d array which takes to parameter I and j i refers to the process and J refers to the resource so maximum of I comma J equals to K this says that process I requires maximum K copies of resource J I can say it as a demand what is the demand of process process I demands K copies of resource J and this demand is made a prior before execution okay let me repeat again process I demands K copies of resource let's move to allocation allocation says K copies were demanded but only a were allocated to process I let me repeat K copies of resource J were demanded but only a copies were allocated for now so allocation is always less than equal to demand and what is need need says how much more copies you want of resource J to fulfill your demand how much more copies this more is an important word so I say process I requires B more copies of resource J so need equals to demand minus location B = to K minus a be more copies required for satisfying the demand okay what is request request is time dependent request made by process I for C copies of J at time T at time T what the process is requesting and you can guess that request should always be less than need so the request made by process I at time T should always be less than need okay Total 1 to M this ISS that for resource J there are total Z copies present there are total Z instances of resource J available says that at time t e copies are available of resource J and I can say that available should always be less than total so e is less than equal to Z are you getting the point let me maximum was demanded process I demanded K copies of resource G okay and a copies were allocated so how much more copies it needed to satisfy the demand B more copies and at time T it request for C copies and that request should always be less than equal to the need the total Z copies of resource J are present and at time t e copies are present so I can say the available should always be less than equal to Total don't worry if you're getting confused when we will see the example you will get the clarity so if I say total 100 copies of a resources present I will say allocated R 70 then what is available available equals to Total minus allocation and this allocation is for all the process I have I had 100 chocolates I distributed 70 chocolates in the class how much chocolates is available to me 30 chocolates and I can say that number of chocolates available to me should always be less than the total chocolates okay now based on these parameters the operating system will Define that at a time the system is in safe state or unsafe State let's see this example there are total five process I will name them as P1 P2 P3 P4 and P5 these are the demands of that five process P1 demand 10 copies of resource R P2 demands eight copies of resource R in this in such in this way these are the demands of these processes respectively now based on this demand operating system allocated some of the resources to the processes and these more instances of that resource process need to satisfy their demand okay so I had total 21 copies of the resource R I have total I had total 21 chocolates okay now in this way I have allocated the chocolates to the processes so how much chocolates out of 21 I have allocated 19 how much I am remaining with two chocolates now can I satisfy the any process can I satisfy the need of any process no at least I should have three chocolates so in this case I can say the system is unsafe the safety algorithm says system is set to be set to be safe if the need of all process can be satisfied with the available resources otherwise unsafe can the need of all process be satisfied with the available resources absolutely not absolutely not so I can say the system is in unsafe state so if available uh were two then the system was in unsafe State let me say now the available are initially 22 so if initially 22 were available I have allocated 19 how much I'm remaining with I'm remaining with here now is three now can I satisfy the need of any process yes I can satisfy so let's say I satisfi I satisfy the need of this P4 I allocate this three resources to satisfy the need of P4 now P4 will get these three resources okay so now how much allocated five were allocated five was the demand P4 will complete its execution and will return five to me again now how much are available five are available are you getting the point see initially how much I had I had three I allocated three to P4 to satisfy demand P4 now had five resources two was initially given now three more so total it has five resources what was the demand five only so P4 has what it was demanded what it has demanded so P4 will complete its execution and will return those five resources back to the operating system now how much are available now five is available I will give out of five three to this P5 now P5 already had three Okay so P5 will complete its execution and will return these six resources to me again out of five I have all alloted three to it so how much I was remaining then two and this six will come again so now I have eight resources did you get the point I had five out of five I allotted three to it now three and three became six the need was the demand was satisfied now after the execution this six will come and join here 2 + 6 = 8 now how much I have I have eight okay so out of eight I allocate 7 to P3 remaining is 1 I located 7 7 and five was already there so 7 + 5 is 12 the demand is satisfied now these 12 after execution will be given back to the operating system so now I had 12 so initially I had 1 again 12 so now I have 13 13 is there with me now I satisfy the need of P2 so how much I have remaining nine 4 and four are eight after execution this eight will come and will be added here 9 and 8 is 17 okay now how much I had I had 17 now I satisfy the need of P5 so 12 is remaining with me satisfied the need of P5 5 and 5 is 10 the demand is satisfied after the execution this 10 this 10 copies of resources will be given back so now 22 the need of all the processes is satisfied and how much copies of resources are with me 22 resources that was the number of copies which I had initially so initially I had 22 after the after the uh satisfy satisfaction of all the uh demand of res of the demand of processes in the end how much I got again 22 so if you can see initially was 22 finally after satisfying all the demand I got 22 then and it means that it is a safe sequence to follow this it means that the system is in safe State based on the available resources I was able to satisfy the need of all the processes and the sequence which we follow which sequence we followed we followed firstly we satisfi the need of P4 then we satisfi the need of P5 then P3 then P2 then P1 then I satisfied the need of this P3 but it is not necessary I can satisfy the need of P1 also P4 also so the safe sequence need not to be unique it can be different okay there can be multiple safe sequences all process must be satisfied but in that safe sequences so if safe sequence is coming and all the processes demands are satisfied then I can say the system is in safe state in the last lecture we were learning about Banker algorithm we learned a question in which single resource with multiple instances was present multiple instances represent in this we are going to see multiple resource with multiple instances let's see how are we going to tackle this let's first understand the question the question says based on the given time T not can you tell me the system is in safe state or not these are the process ID their demands are written here P0 demands seven copies of resource a five copies of resource B three copies of resource a P3 demands two copies of resource a two copies of resource B and two copies of resource these are the demands and the allocation is how much of their demand is fulfilled now zero copies of resource a have been given one copy of resource B zero copies of resource C given to p 0 so these are the allocation how much of their demand is fulfilled at time t0 how much more should be given to satisfy the demand is need and how can we calculate that demand minus allocation so 7 0 is 7 5 1 is 4 3 0 is 3 so this is how we calculated the need need is how much more is needed to satisfy the demand this is the available the number of resources which we are available with this is the total resources how are we going to find the total resources the number of resources which we have allocated till now the number of resources which we are available with add them both and we will get total okay the question is can we satisfy the need of all processes with this scenario let's check we are available with three three and two copies of a b and c respectively can I satisfy the need of any process can I satisfy the need of this no the required are seven and I have three only can I satisfy of this yes yes and yes so I'm going to start with satisfying the need of P1 out of three I give one copy out of three I give two copies and out of two I give all the copies so what I'm remaining now I am remaining with two copies of resource a one copy of resource B and zero copies of resource C so I have completed the demand of P1 so now P1 will freely execute and after execution it has to return the resources so the resources when when they will be returned they will be added back to the available resources what is the available 2 1 and 0er so 2 + 3 is 5 1 + 2 is 3 and 0 + 2 is 2 so now I am available with these many resources 5 3 and 2 can I satisfy the need of this no required is seven I have five only can I satisfy the need of P2 no required is six I have five only can I satisfy the need of P3 yes I can so out of five zero is needed out of three 1 is needed so now out of three one is needed so I'm remaining with two out of two one is needed so I'm remaining with one so this is the remaining resources I have after satisfying the need of P3 so when P3 is execution will be completed it has to return the resources so it will return these resources 5 + 2 is 7 2 + 2 is 4 and 1 + 2 is 3 so now I'm available with these many resources 7 4 and 3 now which process need I can satisfy can I satisfy the need of this yes I can so I will allot 7 to p 0 four of resource B to p 0 and three 3 to P0 okay so now I'm remaining with 0 0 and 0 the already allocated was 01 0 I have allocated 743 now so need plus allocation is is what the demand is so I have satisfied the demand of p 0 so p 0 will fully execute now after execution it has to return the resources now what is the resources I'm left with I'm left with this 7 5 and 3 but I can see the number is different here it's like 7 4 and five but we are getting 7 5 and three it's just because I have chosen different path to show that there can be multiple CF sequences I am choosing a different path to complete if I able to get the same uh number of resources which I had in total then I can say the path was correct okay so let us prove that there can be multiple CF sequences so I am remaining with 7 5 and 3 let us satisfy the need of P2 P2 the number of required resources for a is six so now I remaining with 1 5 and three because B and C are not required p2's need is satisfied or demand is satisfied so I will say P2 will execute freely and then it will come back it has to return the all the resources so 9 + 1 is 10 five and five I can say like this okay now I have satisfied the need of P2 also now it's turn for P4 so for P4 how what if I satisfy the need of P4 then 10 4 is 6 5 3 is 2 and 5 1 is 4 I I am available with with these many resources okay now p4's demand is fulfilled so it will execute freely and when after execution it will return it has to return the resources so 6 + 4 is 10 now I am available with 10 3 + 2 is 5 4 + 3 is 7 isn't that the total number of resources yes so I can say multiple safe sequences are possible plus I can also say that this scenario is of safe State because I was able to satisfy the need of each and every process available with me okay so the safe sequence which was followed here was P1 P3 P4 P2 and p 0 but sh sequence that we followed was P3 no it was I think P1 P3 then uh p 0 P2 and P4 so the point is there can be multiple safe sequence it is no need that safe sequence should be unique so this is what Bankers algorithm in the next lecture we are going to see the resource request algorithm in the last lecture we have learned about safety algorithm of Banker's algorithm in this lecture it's time for the second part resource request algorithm they both work together to create the bankers algorithm okay so we are going to see how let's first understand resource request algorithm I hope you all remember the meaning of these uh variables Pi is the process requesting for some resource or the instance of resource at time T allocation is number of instances I have given to that process and need is how much more instances a process need to satisfy its demand and available means after location how many instances of the resources I'm left with that is available okay and we have also discussed that request should always be less than need and request should always be less than available resources okay I I cannot request more than my need I cannot request more than what is available okay now assume that we have satisfied the request process made some request and assume that we have satisfied now satisfying means we have already allocated that process those many number of instances of a resource that it is requesting so allocation will increase its need will decrease now it will need less number of uh instances than before to satisfy demand and number of available instances will decrease okay let me repeat after allocation the allocated number will increase the need will decrease because now the process needs less number of instances to satisfy demand and number of available instances will decrease okay so first things to check is is my request less than need the second thing to check is is my is the request less than available if both of them are true then assume that we have satisfied the request we are assuming so assuming we have satisfied the request what will be the new value of available need and allocated the value of available will decrease need will decrease and allocated will increase now we will run safety algorithm if the system is in safe State Grant the request I else deny request I and block the process so this is how resource request algorithm works with the help of safety algorithm let's see an example at time T1 P1 requests one copy of resource a zero copy of resource B and two copies of resource C this is the request made by P1 at time T1 and we are available with 3 3 and two we have taken just the same example of uh we have used before this one same example here okay so the request now is 1 0 and 2 how are we going to proceed so the first thing I told you to check is is my request less than need so what is the need of process P1 the need of process P1 is 1 1212 the demand is 322 the located is 20 and the need is 122 and at time T1 it request for 102 so is the request less than the need so I can say yes the request is less than equal to the need is my request less than equal to available what is available 3 3 and two and the requesting is 102 is then less than equal to available yes it is less than equal to available so after doing after checking both this I can say let's assume that request has been satisfied so if I have satisfied this request what will happen now out of available I will give one to process one this one resource to process one three copies of resource V to process one no not three it requires zero so for this time at time T1 process do not require for uh resource V so zero and two copies of C2 process one now now we have to update the need now we have to update the need so after the satisfaction of the request this available will decrease 230 because I have satisfied 102 I have I have allocated that so the number of allocation will increase 2 + 102 1 02 so 3 0 and 2 so this is the allocation number the need will decrease Now 1 02 0 2 and 0 so need will also decrease available and need will decrease and allocation will increase so this is my new values now what we are going to do we are going to run the safety algorithm what is the the number of available resources I have now I have 2 3 and 0 what is the need of process uh one now the need is 02 and 0 what is the allocation number 302 so 302 now based on the new values I will run safety algorithm okay so we are available with these many resources let's check whose need I can satisfy can I satisfy the need of P0 no can I satisfy the need of P1 yes I can satisfy out of two 0 will be given 3 two will be given so I will be remaining with 2 1 and then zero so these are the remaining resources after uh satisfying the demand of P1 these many resources will return back so I have to add them 3 + 2 is 5 2 1 2 + 1 is 3 and 2 + 0 is 2 so now I have these many resources 5 3 and 2 now now which whose needs I can satisfy can I satisfy the need of this no can I no can I yes I can satisfy the need of P3 so let's satisfy the need of P3 5 0 is 5 3 1 is 2 so now I have two copies of B available after satisfying the need of P3 then 2 1 is 1 so this is what I'm available with I have satisfied the demand of P3 now these resources with return back 5 + 2 is 7 2 + 2 is 4 2 + 1 is 3 so now I have 5 7 43 resources available with me whose need I can satisfy now let's satisfy the need of P4 4 3 and 1 okay so 7 4 is 3 3 4 3 is 1 and 3 1 is 2 these many resources I have after satisfying 3 1 and two after after satisfying the need of P4 now when P4 will execute after execution these many resources will come back so 7 + 4 is 3 7 + what I'm saying 4 + 3 is 7 3 + 1 is 4 and 3 + 2 is 5 7 4 5 I have now remaining resources now can I satisfy the need of P0 yes I can satisfy so out of seven I will I have zero remaining out of four I have zero remaining out of five I have two remaining so these many resources I have after completing the need of p 0 so after execution these many resources will return and add 7 + 0 is 7 5 + 0 is 5 and 3 + 2 is 5 so I have these many Resources with me 7 755 now can I satisfy the need of P2 yes I can so out of seven I have given 6 to P2 so one is remaining with me five so 0 0 5 so 1 5 5 is remaining with me so after P after execution of P2 these many resources will come back and add so 9 + 1 is 10 5 + 0 is 5 and 5 + 2 is 7 isn't that the same number which we have in the beginning this total yes so I can say that the system is in safe state so if the system is in safe State I have found a safe sequence then this request can be satisfied or this request can be granted okay so this is how we have to find out whether a process request should be granted or denied now let's solve an interesting question it says an operating system uses Bankers algorithm for deadlock avoidance when managing the allocation of three resour type X Y and Y and Zed three process p 0 P1 and P2 are there the table given below present the current system State here the allocation Matrix shows the current number of resources of each type allocated to each process and maximum Matrix shows the maximum number of resources of each type required by each process during its execution so maximum is the demand and allocation is the allocated till now there are three units of Type X so this is the available what we have 322 three units of Type X two units of type Y and two units of type Z is still available the system is currently in a safe State consider the following independent request for additional resource in the current state okay so the request says p 0 make a request of 002 and P1 makes a request of 20 now how how are we going to check whether this request will be fulfilled or not we are going to check using resource request algorithm this is the table which we are given with So based on this we will calculate the need need equals to demand minus allocation 8 0 is 8 4 0 is 4 3 1 is 2 so in this way we have calculated the need now the request says 0 0 and two first of all we have to check whether this request is valid or not the request is valid when it is less than equal to need is it yes it is the request is valid if it is less than equal to available is it yes it is now we have to check after satisfying this request whether the system will in safe state or not so let's say I'm satisfied uh what I'm going to do I'm going to decrease the value of need I'm going to decrease the value of available and increase the value of allocation now it will become three based on the updated values run safety algorithm and see whether the system Still Remains in the safe state or not okay so I have available 3 2 and0 I can satisfy the need of P1 okay so now after satisfying the need of P1 I'm available with 0 2 and 0 okay P1 after its execution will return these many resources so now I have 6 2 and 0 so 6 4 and 0 available I have is 6 4 and 0 now I can satisfy the request of P2 after satisfying the need of P2 how many resources I have now 5 2 and C here we cannot satisfy the need of P2 because we have zero instances of type Zed but here P2 is asking for t two so we have to first satisfy the need of this p 0 can I satisfy the need of p 0 no I cannot satisfy the need of p 0 because the number of instances of resource X needed is 8 but we have six only so I can say I cannot satisfy the need of either p 0 or P2 so I can say that system has now come into unsafe state so I will say this request will be denied let's check for request number two request number two says that P1 20 2 is request less than available I have available of 322 yes it is less than available is it less than need so the need was 3 yes it is less than need need is 3 request is 20 yes after satisfying the need will the system land into saf state or unsafe State how are we going to check that using using the safety algorithm so we will apply CFT algorithm on the updated values so now we have to update the values available resource how many available resource we have now 1 22 so 1 122 will be the available resource now and I have to decrease the need also so 3 was the need I have satisfied the need so now what is the need now or what is the updated need 1 0 0 see I have I have satisfied the need of 20 the initial need was 3 so what is the updated need 1 0 and allocation will be two more is allocated so three will be Chang to five so this is now the updated values now have to run safety algorithm on these values with 1 122 can I satisfy the request of P2 yes so now I have available 0 0 and 0 P2 after running will give me back these resources so now I have 333 can I satisfy the need of p 0 now no I cannot so I have to first satisfy the need of P1 so after satisfying the need of P1 how much I have remaining now 2 3 3 so P1 after running is going to give me these many resources back so 6 2 and 0 are we got back so 8 6 and 2 8 3 and 2 5 and 3 so 8 53 is now the available resources can I satisfy the need of p 0 now yes I can so now I'm remaining with 0 1 and 1 after running I will get 843 back back so I will get 843 back 843 8 5 and 4 8 5 and 4 so this we have in in this manner we have satisfied the need of each and every process we have satisfied the demand of each and every process so I can say the system is in safe state so this request will be granted in the next lecture we are going to learn deadlock detection and Recovery now we are going to learn deadlock detection and recovery so when are we planning to apply this detection and Recovery thing when you see something odd let me ask you a simple question when you go to the doctor when you are not feeling well so the based on the symptoms you tell to the doctor doctor estimates the problem and run the test okay in the same way operating system notices the symptoms like underutilization of CPU majority processes are getting block so by these symptoms by noticing these symptoms operating system runs some test and by the diagnosis operating system tells whether the deadlock is present or not okay so this is what detection is based on the symptoms we run test and then we get the idea whether deadlock is present or not so in the same way when we divided the deadlock avoidance on the basis of number of instances a a resource contain like deadlock avoidance was divided into two part resource allocation graph and bankers algorithm in the same way for single instance resources we have weight for graph method and for multiple instance of resources we have safety algorithm method so first let's learn about single instance that is wait for graph in wait for graph what we do we remove the resources and just keep the processes so R3 will be removed and the arrow will go like this in this way this R4 will be removed and arrow will go like this or I can directly say this this R3 R5 will be removed and arrow will go like this okay so I hope you are getting the point we are removing the resources and just keeping the processes okay so weight for graph contain only the process and after we have drawn weight for graph Run Cycle detection algorithm that is if cycle is present or not and we are talking about single instance so we can say that if cycle is present then deadlock will be there there because for single instance resources the cycle is not only just the necessary condition but it is sufficient as well okay so after detection of algorithm what are we going to do victim processes will be sent as input to the recovery module the recovery module will do something and it will recover what we did first based on the symptoms we are going to run some test so okay if the resources are single instance then we will make a weight for graph how weight for graph is made by removing the resources and just keeping the processes and if I see a cycle present in the weight for graph then I can say that deadlock will be there because in single instance cycle is not only the necessary condition but sufficient as well and that victim processes will be sent to the recovery module okay now comes the multi instance this is allocation this is the request made and this is available okay so I can see that based on the available resources how many process request won't be fulfilled so p 0 request will be fulfilled P1 failed P2 fulfilled P3 failed P4 failed so P1 P3 and P4 will be blocked see there are five processes and three of them are blocked majority process are getting blocked so there are chances of Deadlock system is safe if request of all processes satisfiable with the available copies in some order this is exactly like the safety algorithm but in safety algorithm what we used to say we say that the system if if the available resource are not able to satisfy the request of some processes then there we used to say uncf state has occurred but now here will say deadlock is there okay okay so let's see this can I satisfy the request of P0 yes so the location will come back the location will come back so 0 1 0 is now the available resources I have can I satisfy the request of P2 yes the location will come back now I have 3 1 and three this is the available resource now I have now can I satisfy the request of um P3 I can even satisfy for P1 also so okay let's P1 I satisfy the request of P1 now I am available with one one and one after P1 request is satisfied what is allocated now allocated now will be 4 0 and 2 so this will come back now I have 5 0 5 1 and 3 this will come back and added here now I will will satisfy the request of P4 so in this way I can say that the request of all process can be satisfied in some order here what we are seeing that available was not able to satisfy the request of P1 was not able to satisfy the request of P3 was not able to satisfy the request of P4 so P1 P3 and P4 were blocked but when available satisfies the request of P Z it got some of the resources back and when the resources available are enough to satisfy the request then those sleeping process or those blocked process will be brought back to the ricq okay so this is how safe state is achieved even though we got a symptom that out of five process three process are blocked but still we are saying that no problem because the result of the test is negative the result of the test says that dead log is not present okay now what happens P2 makes a new request P2 makes a new request 0 01 now what happens P2 makes a new request of 01 so let's see here P2 makes a new request of 0 0 0 and 1 okay okay let's run safety algorithm now request of p 0 will be fulfilled this will come back and add here now I have available resource this can I can I satisfy the need of P1 no can I satisfy the need of P2 no can I no no so all of these process will be blocked only p 0 was completed and it terminated so now these four process which I have with me are blocked all the process are blocked this is the case of Deadlock so these four processes will be sent back sent to the recovery module as an input okay so this is how it work let me repeat again what happens initially we saw that majority process are getting blocked so we should run safety algorithm we run safety algorithm and we successfully were able to satisfy the request of all the processes we can say the system is in safe State even though we got a symptom but no problem here because the test is negative but what happens now P2 makes a new request 001 so when P2 makes a new request of 001 I was only able to satisfy the request of p 0 and rest of the process were blocked so this is the case of Deadlock okay now what happens these victim process will be sent to the recovery module as an input okay so how does this recovery module work let's see in the next video in the last lecture we have seen the deadlock detection now what happens after detection recovery so the deadlocked process will be sent to the recovery module and it has two ways to work either it works on processes or resources for process let's say there are three process P1 P2 P3 each dependent on one another so the first thing it can do is abort one process at a time until the elimination of Deadlock cycle suppose I uh removed this P3 now what happens when P3 is removed the resources of P3 will be given to P2 now P2 will complete after the completion P2 will return back those resources and will help P1 to complete in this way the deadlocked will will be solved and the process will complete but in this Solution One process has to sacrifice the second solution says delete all the process about all the deadlock process okay now comes the resource the resource solution says do the preemption of resources let me say P1 P2 and P3 each depending on one another now what happens the P2 is a strong process strong in terms of priority so P2 is a strong process P2 will snatch away the resources of P3 now P3 don't have the resources P2 will get itself completed and will return back the resources and P1 will get those resources because P1 was dependent on P2 so P1 will get the resources and P1 will complete and when P1 will get completed it will return the resources to P3 because P3 was dependent on P1 in this way neither of the process has to get deleted and all of them was completed without any loss okay so preemption was a method and roll back what is roll back we will see in a minute okay so now the question arise for abortion of one process which process to have we have to kill the algorithm says the one who has just started that process you have to kill okay then apply the deadlock detection algorithm again and again now comes the roll back part what we do we will keep preempting the latest resource add them to the available pool and run the detection algorithm again after each preemption and we will keep preempting until the cycle is broken so this is how resource preemption works and process recovery based on the process and resources okay now let's see the difference between prevention avoidance detection and ignorance this prevention and avoidance is like a proactive attitude you already take the preventive measures you already try to avoid the deadlock in these cases deadlock do not occur and this detection detection and Recovery is like a reactive attitude deadlock has occurred now do what you can do and the ignorance is the inactive attitude let's read this prevention this approach is about taking proactive measure to stop problems before they occur it's a proactive attitude because it involves planning ahead and taking action to prevent issues and what about avoidance this is about steering clear of potential problems it is a reactive attitude because it involves responding to the possibility of issues avoiding them so avoidance can also be segregated into reactive attitude because it involves responding to the possibility we we try to avoid the deadlock detection deadlock has occurred now do what you can do deals with the issues after they have happened and it ignorance this is when no action is taken either to prevent or avoid and recover from problem it is an inactive attitude because it involves doing nothing in response to potential or actual issues now let's see some problems so the total process are n each process need two copies of resource R the total number of available copies are 1 2 3 4 5 and six now we have to tell now we have to tell minimum number of processes required to cause Deadlock let's take let's start with three process I have allotted both the process to two resources so they will all complete no possibility of Deadlock now let's go here we included five processes so what happens first one given to P1 second to P2 third one to P4 fourth one to P5 fourth one to P4 and 5 one to P5 now one copy of resource R is remaining so I have to assign it to some of the process some process out of the let's say I'm assigning that to P1 now what will happen when P1 will complete it will release its resources back and that resources are going to help other process to complete in this way P5 with P5 process with five process the deadlock is not there now let's say I increase one more process now what happens first one given to P1 second to P2 third to p 3 4 to P4 fifth to P5 6 to P6 now I have used all the available resources in this case each of the process is waiting on another to leave a copy of resource so that it can complete this is just like the case of dining philosopher in which each philosopher picks up the left Fork so minimum minimum number of process to cause deadlock is six and maximum number for deadlock freedom is five maximum of number of process for which deadlock won't occur is five let's see another question there are three process now you have to tell me the resources each process require two resources now tell me the number of resources such that the deadlock will occur maximum number of resources to cause deadlock so maximum number of resources to C cause deadlock will be three 1 2 3 see if I give one more deadlock won't occur so the maximum is three now minimum number to ensure deadlock Freedom will be four 1 2 3 deadlock is there if I give one more deadlock won't occur so I will say minimum four are required to ensure deadlock freedom is it clear see another see another problem end processes are there R has six copies each process require three copies now tell me the same so how much uh proc how many process are required to cause deadlock and maximum number of process for deadlock Freedom see this if I talk about P1 P2 and P3 each process now require three 1 2 3 4 5 6 I have used all of them and each process required three resources so I will say P1 will wait on P2 and P3 so that they will release their resources so that P1 can get one more to complete similarly the same case for P2 P2 is waiting on P1 and P3 so that it can get one Moree to complete so in this way I can say that minimum three resources minimum three process are enough to cause deadlock and maximum number of process to ensure deadlock freedom is two only 1 2 3 4 5 6 just two if I say three then the case of Deadlock may arise okay see this processes are there P1 P2 P3 P4 P5 the maximum demand they have made is 10 8 5 12 6 now you have five process now you to tell me the resource number of resource maximum resource to cause deadlock so for deadlock to occur I will give 9 to P1 7 to p8 7 to P2 4 to P3 11 to P4 and 5 to P5 now what will happen they will wait on each other to just get one more resources to complete this is the same case of dining philosopher so for maximum resource to cause deadlock you have to create the case of dining philosopher now they are waiting on each other to get just one more resource to complete so I will say 9 + 7 + 4 + 11 + 5 that is 36 so I will maximum number of resources to got deadlock is 36 and minimum to ensure deadlock freedom is see if I give one more resource to any of the process let's say I have given one more resource to this five P3 will complete and P3 will release five resources back to the pool now what will happen P2 will get one P1 will get one P4 will get one P5 will get one and one is still remaining in the pool all of them will complete so what I can say here if I just add one more resource then deadlock Freedom can be ensured so 37 resources minimum and 36 maximum to cause deadlock and 37 to cause dead Freedom okay to solve such questions you should you should always remember the dining philosopher case now these are some homework problems you have to solve them this is a question which of the following statement is true with respect to deadlock the first says circular way weight is necessary condition for the formation of Deadlock yes it yes it is true in a system where each resource has more than one instance a cycle in its weight for graph indicate the presence of a deadlock no because because for multi instance graph for multi instance resource cycle is just a necessary condition indicates the presence of Deadlock no for single instance graph in wait for for ining single instance resource for wait for graph I can see cycle is sufficient and necessary if the current allocation of resources to process processes leads the system to UNF State then deadlock will necessarily occur no I cannot say that what I have told you they will go into unsafe State not deadlock unsafe state is not necessarily deadlock unsafe state is just a warning that in future deadlock may occur in resource allocation graph of a system if every Edge is assignment Edge then the system is not in deadlock stage in resource allocation graph of a system if every Edge is an assignment Edge then yes that is also true how can I say that look at the diagram the case we discussed was this P1 was holding R1 and waiting for R2 P2 was granted R2 and waiting for R1 but you can see here cycle only forms when there are request edges if there is no request edges then cycle won't form and if cycle is not present then the deadlock will definitely won't occur okay so in resource allocation graph if every Edge in every Edge is a assignment Edge then this says that cycle is not present and if cycle is not present then I can say the system is not in deadlock State okay this is a homework question for you you should try okay this is also an homework question we'll discuss them in the next section SE okay so for now I can say deadlock is officially completed in the next section we will start memory management so let's first start with the homework discussion of the last lecture here we are given with consider the following snapshot of the system running and processes process I is holding XI instance of resource R so I can say xir is being acquired by pi for all I 1 to n for all I 1 to n currently all instances of R are occupied further for all I process I has placed a request for an additional Yi instance okay so process I has made a request for additional Yi instance of resource R while holding XI instance it already has it's it's already holding some XI instances there are exactly two process p and Q says that YP = to y = 0 YP = to yal to 0 this says that process p and process Q are not requesting anymore okay so which one of the following can serve as a necessary condition to guarantee that system is not approaching a deadlock see this here here I have written all of the P ID process IDs P1 P2 PN and somewhere in between there must be process p and Q and then the p and the last process or here are the allocated resources so P1 is holding X1 resources X1 instances of resource R P2 is holding X2 instances of resource r P3 is holding X3 and process p is holding XP resource and process Q is holding XP resource see whenever I say resource I mean instance of that resource okay and then PN is holding xn okay now comes the request part here here you can see Yi is being requested by process Pi so I can say P1 is requesting y1 P2 is requesting Y2 but here it is given that process p and process Q are not requesting anymore so process p will request zero instance and process Q will also request zero instance now comes the question which one of the following can serve as a necessary condition to guarantee that the system is not approaching a deadlock see we have zero available resources so and I have to satisfy the need of all these processes with that available equals to zero how can I satisfy I can satisfy the need of these two processes so when PQ and PP that is process p and process Q will start running and after execution they will release their resources back so how much available resources now I have I have XP plus X xq and with these available resources I must be able to satisfy the need of at least one process out of uh P1 to PN except P PP and PQ so with these Resources with these instances I should able to satisfy either of them at least one if I am able to satisfy the need of at least one so how can I write at least one minimum of Yi that is minimum of Yi I will be able to satisfy with these instances of resources and if it is then the system is not approaching datal log see if I say the xer xq that is number of available resources with me now is even not enough to satisfy the need of minimum of these uh request the least of or the minimum of that request I'm not able to satisfy with the resources I have available with that's that is the case of actual deadlock okay here I should write I is not equals to P or q and K is not equals to P because these processes have already completed that's why they have released their resources here and one more thing if I write XP plus xq is greater than maximum of Yi which means with with XP and XU they are well enough that I can satisfy the need of maximum of these I can satisfy the need of one whose request is maximum then I can say the system is totally safe there is no case of Deadlock okay I hope you got the idea how we did it with these available resources I should be able to satisfy the minimum amount of request or the least request made by the processor if yes then I can say system is not approaching Deadlock this was also a nice question it said consider the following resource allocation graph find if the system is in deadlock state so either you can try using that weight for graph but here you cannot use weight for graph directly because of multi instance resources so how are you going to solve this we are going to solve using the detection algorithm see this which of the following uh find the system is in deadlock state or not so we are using detection we are detecting if the system is in deadlock state or not so we are not using prevention we are not using avoidance we are using detection and in detection which algorithm single instance no we are use multi instance and how we use multi instance using Bankers algorithm so we need to convert this resource allocation graph into a matrix R1 R2 and R3 are the type of resources P1 is holding P1 is holding one instance of R2 request testing for one instance of R1 and holding one instance of R1 so it's holding see see it's holding one instance of R1 one instance of R2 so I can write 1 1 0 for P1 I can write 1 1 0 for P1 this is what P1 is allocated with if I have to write for p 0 then it's holding one instance of R1 and uh no nothing else it's just holding one instance of R1 yes it's holding one instance of R3 also so I will write 1 0 and 1 for p 0 I will write 10 1 so in this manner I will write the whole allocation thing now the request what's what's what it is requesting it's requesting see here it's requesting R1 and nothing else I will write 1 0 wait a minute yes it's I will write 1 0 0 for p 0 it's requesting R2 it's requesting R3 so I will write 0 1 1 I'll write 0 1 1 for P2 I will write for P2 it's requesting one instance of R2 uh sorry it's requesting one instance of R3 and nothing else so 0 0 and 1 0 0 and 1 it's just requesting one instance of R3 now P3 P3 where is P3 here is P3 so P3 is requesting one instance of R2 it's requesting one instance of R1 and see here it's requesting another instance of R2 so I'll write uh I'll write 1 2 0 1 12 0 so this is what is request this is allocation this is p ID now available resource which resource is available with me see here this R3 resource is not given to anyone this this is not allocated to anyone R1 is completely allocated R2 is completely allocated I have just R3 available with me so I'll write 0 01 now with the help of this 01 can I satisfy the need of all these and if yes then the system is not in dad log state so first we have to satisfy the need of P2 when p2's need will be satisfied then I'm I'll be available with this allocation Will Come Back to Me 0 1 0 so I'll have 0 1 1 now with this 011 can I satisfy the need of p 0 yes I can so this allocation will come to me again I'll have 1 0 and 1 which is one12 with this 112 can I satisfy the need of uh yes I can satisfy the need of P1 so I'll satisfy the need of P1 and this allocation will come back to me now I have 222 now I satisfy the need of P3 so yes the system is safe I can satisfy the need of all the processes with the resources I'm available with so I'll say this system is not in deadlock State okay so this was all about deadlock and we have also discussed the homework problems congratulations we have completed our deadlock section now we are starting the memory management section what is memory memory is a electronic holding Place uh for data and instructions data and instruction that computer want to or the CPU want to reach quickly to see what is the need of memory because CPU is very fast hard disk is very slow slow we want something in between to coordinate with both that's what memory does memory whenever I say memory I mean by primary memory that is the main memory that is Ram Rome cach registers this cash and resists are just like the memory buts way faster cash is faster than RAM and resistors are faster than cash cash is smaller in size than Ram a resistor is smaller in size than cash okay so the more fast we become the less size we got okay see hard disk has the largest size RAM has little bit low size then cach more low and then register has the least size okay so Ram is also known as main memory or read write memory it's also known as random access memory this is readon memory related to file systems so this is Ram connected with address bus data bus and control signals this chip select it's it's just like what power on and power off thing what does this address bus do let's say I want to access the memory location at 10 1 0 so this 10 1 0 will be brought by address bus and what does this data bus do it brings the content of 101 0 to CPU and sometime it also uh carries addresses in in of the case of indirect addressing don't worry if you are just getting confused uh just take a look at it and we will learn more that in detail in our computer organization architecture course what you have to focus on in this is this linear onedimensional view of memory how does memory look like this is what it is it is a linear array of words what is words what is word collection of bits uh if I say one word equals to one word equals to 8 bit 8 Bits or one bite then I can say that each cell in the memory consist of one byte one by see this memory is divided into lots of words lots of words memories divided into so what is this this this is address each word has a unique address if I say m of 1010 this is what address is each cell in the memory have a unique address and to and to access the content of a word we must have an address okay so let's say this is a cell or this is a word it has the address X and it has a length of M bits which means one word consist of M bits M bits M bits so if I say what is the size of memory number of words into M bits so n let's say n be the number of words M be the size of each word so this is the memory size n into M okay so M bits it is the word length and in word content is stored and what is content data and instruction okay so I have written that same thing here M width of a word word length xal to fixed length address in bits and total number of veres in let me discuss a small thing with you if you are not familiar with this let's say if I talk uh I have just one bit how many words I can address with uh let's say I make two blocks one block I can give address zero and another block I can give address one so if one bit I have I can address two blocks let's say I have two bits so how many blocks I can address I can address four blocks 0 0 0 1 1 Z and 1 one see what is the thing that I'm talking about with with let's say if I talk about two bits how many unique numbers you can generate with two bits that's what the number of words you can address with if I say I can generate four number with two bits that is 0 1 2 and 3 these are the four number that can be generated using two bits so I can say with two bits I can address four words so if I say I have three bits how many words I can address 0 0 1 0 0 0 0 0 1 0 1 0 0 1 1 101 in this way you go till 111 okay so you can address seven from 0 to 7 you can address you can generate eight unique numbers so you can address eight words with three bits with three bits you can address eight words so it's like 2 to^ 3 with two bits I can address four words it's like 2 power 2 with one bit I can address two words so like 2^ 1 so if I ask you if I ask you with n Bits let's say this is n Bits how many unique numbers I can generate you can generate two rais to power n numbers so how many words you can address with you can address 2 power n words so with nbit address you can have 2 to power n number of words okay so this mbit this mbit is the size of each word so this is the size of each word m bit and this is what the number of words are so M bits M into 2 ra to^ n is actually the size of my memory size of memory or I can say memory capacity I hope you are getting the point let me repeat again let me repeat again so that will clarify you from n Bits of address I can generate create 2 to power n unique numbers which can be helpful to address 2 power n words so the number of words I have is 2 power n and the size of each word is M bits so this is what my memory size is okay I I hope you got the point so this x this x is the fixed length address and it is in bits okay so memories is specified using number of words into width of a word n into M and let's say n is the size of address in bits so number of words can be 2^ n we have just discussed it now n is the word length n is the total number of words so I can write n = to 2^ n or I can say number of words equal to 2 to power address size in bits I hope now it's clear so total number of words equal to 2 to^ size of address okay now comes the relation between n and n we have already talked about this uh let's say if I have three bits then I can address I can generate uh I said I made a mistake here yes so if I have three bits I can generate eight unique numbers which can be helpful in addressing of eight words okay so this is what uh I want to clarify now one thing you have to remember in 10 bits for 10 bits I can for with 10 bits I can generate 2 to power 10 unique numbers and this 2 power 10 when we are talking about data is also known as K that is that th000 thing if I have 2 20 2 20 then this become 2 20 then it becomes M Mega if I say 30 bits then this is 2 30 that is giga so 10 bits can be useful to generate 1 kilow 20 bits can be useful to generate 1 Mews and 30 bits can be useful to generate 1 G vers so if I'm problem here if I say Nal to 500 G which mean I have 500 g words then what will be the address size see for 500 Words I need to have nine bits because with eight bits I can only generate 256 words or I can say only generate 256 address and one address for each word with nine bits I can generate 52 addresses so for this 500 I I need to have 9 bits and for this G I need to have 30 bits we have just discussed it here 30 bits for 1 gab so 30 + 9 is 39 why are we adding this because of this let me explain you in proper detail n equals to I can write it 2 power n into 2^ 30 so log 2 N will be 39 bits remember this that the address size is always in bits the address size is always in bits okay Nal to 1,000k so for 1,000 uh I need to have 10 bits because with 10 bits I can generate one2 for addresses if I just shift down to one bit from 9 bit I can only generate 51 so I can write 10 bits for this 1,000 and 10 for this kilo so in total I will have 20 bit address number of words number of bits in the address and word length suppose if I say n equals to 13 bits which mean 13 bit address 13 bits are needed to refer one world of memory see if I use if I say my address size is two bits which mean two bits are needed to refer one word in the memory similar in similar way if I say my address size is 13 bit which means 13 bits are needed to refer one word of memory okay m equal to 8 bit this is 1 byte so m equals to 1 by that is word length so this each cell of a memory consist of of 1 by n = to 2^ 13 we got it from here which means with 13 bits I can generate 2^ 13 words so n = to 2^ 13 words so I can write 2^ 13 as 2^ 3 into 2^ 10 and 2^ 10 can be written as K so I can write 8 K and what is the size of each word bite so I can write 8 KB is the size of memory so this is the capacity of memory in terms of bite and words now if I ask you what is the capacity of memory in terms of words then you write 8 kilow and if I ask you what is the capacity of memory in terms of bytes then you say 1 8 kilobyte because 1 Word equals to 1 by okay see this n equals to 18 bits which means I can generate 2^ 18 18 addresses which means I can have 2^ 18 Words which means I have 2 10 into 2^ 2^ 8 into 2^ 10 which is 256 kilow words I can have I can have 2^ kilow words and what is the size of each word the size of each word is 8 into 2 bits which means this is 1 bite which means I can the size of each word is 2 by so if I ask you the world view of a memory then it is of 256 kilow and if I just put the value of word here that is 2 byte then I get 512 kilobyte I just substituted the value of word then I get the bite view of a memory and by default you can take one word as one bite okay let's move down just for the same thing uh we just for the sake of Simplicity we say this n is the size of memory size of memory n = to 64 KB now it says that I have 64 KB of memory and what is the word length word length is is 4 byte so this question is important question you will feel the difference what is the meaning of world view and bite view world view says that each cell in the memory consist of word one word and bite view says each cell in the memory consist of one bite now the question is asked what will be the address length if I address the memory in terms of word and what will the address length if I address the memory in terms of bite so simple see here if I address the memory in terms of bite then I will have one bite of cell and there will be 2 to^ 16 this is 64 KB 2 to^ 16 number of words so number of words are given can I find the address bit yes it will require 16 bits of addresses so n equals to 16 bit for B View and if I ask you for the word view then each cell in the memory consist of four byte so how many words I will require to address the full memory let's say the number of word I require is X each word has 4 byte and what is the size of memory 64 KB from B to B I got it cancelled and this is 16k and 16 can be written as 2^ 4 and this K can be written as 2^ 10 which means 2^ 14 worlds are requir to address this uh to complete this whole memory so 2 to^ 14 how many bits I will require 14 bits okay so this is how it works let me repeat again how did I solve this so what does bite view say bite view says that one cell of a memory consist of one bite and what does word view say one cell of memory consist of one word and the word length is given to you word word length says the one word consist of four bytes so one cell of a memory consist of four bytes and you have 64 KB memory to complete or you have to 64 KB memory to address and each cell has 4 byte so how many blocks you will require see each block has a size of 4 byte let's say I require X block to access the 64 KB memory so from here I can find that I require 2 to power 14 blocks or 14 words and to address these two 14 words I should have 14 bits in my account so this 14 bits is required for word view now let's say I'm asking you for the bite view what does bite view says that one cell of a memory consist of one bite one cell of a memory consist of 1 bite and my memory size is 64 KB I have block size of 1 bite and let's say I I have X blocks to access 64 KB memory how much block I require what is the value of x it's so simple 2^ 6 into 2^ 10 it is 2^ 16 which means I should have 16 bits in my account to address these 2 power 16 blocks that's how I got 16 bits address for the bite View and 14 bit for the world view okay bite view means one word is one bite and word view means one word is given number of bytes I hope you got the point what does bite view say each word is one bite and what does word view say each word is given number of byes here each word is of four bytes okay so n is the total number of words and if I say one word equals to 8 byte then this each cell in the block consist of 8 byte so same question if I ask you that if I say the word length is changed to 8 by then what will be the answer how many block of size 8 by are required to access the whole memory of 64 KB I'll just cancel the B to B and then 88s are 64 so I'll write 8 K which is 2^ 3 into 2^ 10 2^ 13 so I should have 13 bits in my account to access 2^ 13 words or 2^ 13 blocks or 2^ 13 cells of a member okay let's solve some other questions n = to 23 bits which it says that the address or 23 bits are required to address one block of a memory so from this I can tell that there are two ra to^ 23 words present in the memory and the size of each word is four bytes four bytes so if I say how many number of words are present then 2^ 23 words are present and what is the size of memory the size of memory is 2^ 23 23 into 2^ 2 bytes which is 2 25 bytes which is two which is 2^ 5 into 2^ 20 byes this 2^ 20 can be written as M and this 2^ 5 is 32 so my memory size is 32 MB okay now this is a homework question for you you have to find if the number of words are or the memory size is 8 gabit and each word have 64bit length then what is the number of words in bite View and world view world view and bite View so whatever we have discussed till now I think we should revise that okay so this is what memory is it is prime memory RAM R cach registers Ram is connected with address bus control bus and uh datab bus address bus brings the address from the CPU databas helps to transfer the content from RAM and CPU for let's say if I'm reading then databas transfers the content from Ram to CPU if I'm writing then databas transfer the content from CPU to Ram read and write are the control signal and Chip select says power on or power off linear one dimensional view of memory memory consist of these cells or blocks which I a word each word can be of either one bite or more than one bite if it is of one bite then I can say the memory is byte addressable if it is of more than one bite then I can say memory is word addressable okay the size of each word is mbit so M bit is the word length and if I have X bit address with X bit I can generate 2 to^ x unique addresses so I can address 2 power x blocks or I can address 2 power x cells or words each are the same thing now memories is specified using number of words into width of word so if I have let's say n number of words and the width of each word is M so I have n into m is the size of memory if I have uh total number of words are n then to find the address I will have to take log to n okay what is the relation between n and M just take the log so see what I want to tell you is do not remember anything it is just common sense do not remember anything so we learned about bite View and worldview how the things work uh try to solve this these four questions how many questions 1 2 3 and four try to solve these four questions by your on your own and this homework question also memory management part two let's say the size of address is 18 bits and the world length is of 24 bits so I can say each cell in the memory is of six bytes so n equals to 18 bits the number of words will be 2 to^ 18 so I can say the memory size is 2^ 18 into 6 bytes for each word so this is the memory capacity any memory word you want to refer pass the address to address bus from address bus the address will be taken to the memory and that word the word with that memory location or that address will be activated and the content of that word will be taken from memory location to CPU with the help of databas these are control signals read and write are control signals so 01 is for the write operation and 1 Z is for the read operation there's nothing like one one or 0 0 what is bus bus is a group of wires and each wire can carry a bit so bus is nothing but a group of wire and what is the purpose of this chip select power on button that should be one and if chip select is zero which means the memory is powered off so what operation we can perform we can perform either read or write to perform any operation pass the address to address bus and that word in the memory will be activated pass the control signal either 1 0 or 01 1 Z is for read and 01 is for WR and then from databas content which may include data or instruction will reach the CPU send the address to address bus that word will activated and the that content will be sent from memory location to CPU with the help of data this these are the control signals one Z means read 0 1 means write chip select if zero then memory is powered off if one then power on okay so this is like an 7bit address to refer 128 words chip select one chip select two either you want to read or write address for address bus now what is this this is the capacity of memory 128 refers to 128 bit and this is the size of each word the size size of each word is 8 Bits which means 1 byte so I can see the memory size is 128 byte here one word equals to 1 by so this is a ram this is a Blog diagram of typical Ram chip what is included here chip select control signals address and datab bus address bus and datab bus now comes the part of loading and linking loading versus linking let's say I create a file named test.c compile it and compiler converts it into exe consist of instruction and data and where this ex is stored it is stored at the dis now it is the responsibility of loader to load that program from disk to main memory and from Main memory CPU will execute it so this is what we have learned already in our lecture one stored program concept one human architecture loading loading consist of or loading can be divided into two static and dynamic as the name suggest static which means the whole program is loaded in memory before execution and what is dynamic on demand loading let's take an example see this is our program okay and we start executing this main if do condition now we got a function and function is defined in some another program let's say now this program will also be loaded this program will get exec uted some G function is there defined in some other program now this program is getting loaded G is being executed now H comes defined in some other program now this program is being loaded so in this way when it is required then load this is what we call as Dynamic loading and loading the whole program this all four into main memory at once is called as static loading so by seeing you can say that what is the drawback of this uh static loading suppose if I write a condition here if condition and if condition is not fulfilled then we are not going to execute this F function so let's say the condition fails so this part will won't be executed and only this program will be executed but what we did in static loading we have loaded all three of all of them all of them into the main memory and these three are useless now they are just causing the wastage of a space so in that that case static loading is a bad choice because what is the drawback possible wastage of space ineffective utilization in case of condition or know at runtime because this condition will be run at runtime and at run time we are going to know if this function will be run or not that's where the static loading lags behind and what is the and what is the advantage of static loading the advantage is obviously faster execution let let say the condition is fulfilled now in Dynamic loading it take time to load the program from disk to memory it take time to load program for dis to memory so when all these program will be loaded it will cause time so Dynamic loading cause slower execution and static an static the whole program is loaded in memory before execution so if needed then every program is there at present there's no need to call them there's no need to bring them them from hard disk to memory all of them are actually present in the memory so this will cause faster execution so faster execution is the advantage so I can see this static loading is time efficient but space inefficient see here let's say for dynamic loading I only need just 10 KB of space to start and let's say if the condition fails then I will complete the whole program in just 10 KB but in static loading as I say you load the whole program at once so I need 10 + 5 15 15 and 15 30 30 and 20 50 KB of memory to start the program let's say the condition fails here also I did not require these three of them but they are still loaded into the memory so 40 KB of vage of SPAC is here okay now here should not be 40 KB it is 40 KB wastage as here you can see 10 + 5 15 15 and 15 30 30 and 20 50 so 40 KB is wastage and 50 KB we require for Sal so if you want to save memory then go for dynamic loading which me which says loading on demand and you can guess no wastage of memory but it cause slower execution as it require only 10 KB of memory to start so this is what static and dynamic loading is in static loading you load the whole program at once in Dynamic loading you load load at demand in the last lecture we have studied about static and dynamic loading in this lecture we'll see what is linking so linking is the process of resolving external references what is external references suppose in a program whenever a compile compiler confronts a function which has not been defined before then what is what it will do see every function call is like a branch and goto statement Branch or goto statement so what compiler will do compiler will generate a BSA address and to where it has to jump that address will be left blank because it doesn't know where it is defined see this function f is defined after main so the compiler now here doesn't know where this function f is defined so it will leave a blank here it doesn't know where the SCF is defined it will leave a blank here so these blanks are unresolved references okay now there is also one thing which I want to clarify some students have misconception that compilation is start from Main this is completely false compilation start from the first line of the program then what does it start from Main execution is start from Main execution is start from Main compilation is start from first time of the program okay so now when the compiler first time confronts this function f it will generate a BSA that and it will leave blank blank to that blank this blank address is the address of where f is actually defined so it doesn't know where the f is actually defined so it leaves blank jump to F so compiler doesn't know this so it will leave it blank this is what unresolved reference is see here if this F has been defined before main function then compiler would have known the address that it has to jump here so it will write address of this part here but now compiler doesn't know where it has to jump it doesn't know where f is defined so it we leave blank here these blank are unresolved references okay for example if I use extern int x what does this say this say this integer X is present externally in some other file so it will leave blank here also so whoever address is the compiler don't know it will leave blank there so compiler will leave so many blanks while compiling the code blank for functions blank for external variables or objects so we need a we need someone to fill that blanks so here comes the Linker Linker is the module of operating system who is going to fill up these blanks okay so these blanks are filled up by Linker I already told you if this was the case that function f is already defined above then main comes and in main I use function f then the compiler will automatically fill up the address where it has to jump okay but now here it doesn't know where if is defined it will leave blank now we need someone to fill up those blank now comes the Linker to save us so linking can be of two type as it was loading it can be static or dynamic static linking is done before execution okay so what happens the UNL file which means the compiled file with blanks is the DOT obj file object file that contains unresolved references and that unresolved references when filled up by Linker which means linking is done then it becomes the exe file which is the result references okay so this is how aexe files look like main function function f is defined here and then scan of comes so how does exe file looks main at BX at X this function X is defined here and then in f i this function scan F will be converted into BSA y now this y will be the address where scanf is defined in this way okay so INE file all the external or unresolved references are resolved which means their addresses are put at the BSA parameter so now compiler can jump easily okay now what is the draw drawback is space in efficiency see Linker acts like a tailor what it do it Stitches the links of different pieces of clothes and here we can say the code to make it a meaningful program see here if Linker was not present to tell the compiler that this function f is defined here would it be a meaningful program no so Linker X like a tailor with with who stitches different pieces of clothes to make a meaningful fabric similarly Linker links different pieces of code to create or make a meaningful program in the next lecture we'll see what is dynamic linking or linking at runtime in the last lecture we have learned about static linking in this we are going to learn Dynamic linking that is how linking is done at the time you all know what is the meaning of linking resolving unresolved references giving the address to the BSA so now how does dynamic linking work with the help of stub what is St stub stub is a piece of executable code so I can say every unresolved reference which mean every blank address will be associated with a small piece of code known as Stu and that stuff is executable so at run time when that step will be executed at at run time when step will be executed it will activate the link Linker now it is responsibility of linker to find the address of that function in the memory and if that function is not present in the memory Linker will look for it in the compiler libraries compiler libraries that is present in the libraries that is present in the disk and if found there Linker will tell loader to load that module into the main memory okay so when this address will be found it will give it to the stub and now stub will provide it to the branch and save address so now here we got the address so this is how it works St and step executed at run time activates the Linker Linker found the address of function f in the main memory now that address will be given to step and step gives to the BSA that's how it work and I've already told you if function is not present in memory then Linker will look for compiler libraries on disk if found there then loader will load the module in the memory searching for addresses is the work of linkter loading the modules from disk to memory is the work of loader okay all modern system nowadays uses Dynamic linking and dynamic loading which means at runtime because that is space efficient you don't have to load the whole program in the beginning and but it is time inefficient okay so everything is done at run time so it take time at uh so it takes time to execute the full code code reusability is also a factor example scanf no need to give each function its own copy of scanf unlike static linking okay so we will load a single copy of scanf into memory and different function can call it we will give just the address of it instead of giving each function its own separate copy of scanner so this also provide reusability okay so modules libraries which are linked at runtime by Dynamic linking are generally called as dll you must have seen somewhere this uh like error the DL file is missing this type of DL file is missing so that is linked during runtime so these are Dynamic link libraries used in Windows and an important role that this Dynamic linking plays is it gives us the flexibility to change because modules are separate see application and their libraries are separately written they are not linked statically statistic statically which means we can change the library implementation without affecting the application see just like scanf we just give the address of it so address Remains the Same here is the library I we can change the Library without changing the application because what we have given in the application just the address so address Remains the Same what we change is the content of those Library so I can say that the library implementation can be changed without affecting the application so this is the flexibility that this Dynamic linking provides and why is it so because they are not linked statically suppose if they are just merged statically suppose they are linked statically all in one then can I change this no if I give just the address of it and here is the implementation in different uh place then I can say that I can change this Library implementation without affecting the application okay so I hope point is clear now what is the drawback of dynamic linking as everything is done at runtime so time will be the factor time inefficiency is present less Security in static the thing is complete everything is already there and have to do nothing at the run time are you getting the point see in security the problem happens where at runtime and if already has been done before nothing is we have to do nothing at the time then there is no loophole or vulnerability Concept in a static linking there is no vulnerability because nothing is done at the run time that's why Dynamic linking has less security okay so this was Dynamic linking in now let's see address binding Association of program instruction and data unit to memory locations what are we doing here we are associating instructions and data to memory locations memory location and that thing is known as address binding we are binding the address to whom instruction and data unit so binding is Association of attributes with entity suppose I write int X then here x is the variable or entity so what is the attribute associated with it name type value address size so the name is X that is name binding the type is int type binding value what is the value here no value is given to it so I can say garbage value or junk value what is address now this will be the address binding if I say that 4,000 is the address of this variable X variable X got binded with the address location 4,000 this is what address binding is are you getting the point giving address to instructions or data units this is what address binding is and what is binding binding is just the association of attributes with the entity here what is the entity X is the entity now if I give address to this entity say that this address is stored variable X is stored at memory location 4,000 now what I have done I have binded the variable X or entity x with a location 4,000 so this is what address binding is so we were seeing the that job of linker is to find addresses of these external objects functions or variables what was address binding address binding was associ of Association of program instructions and data units to memory locations okay Association of program instructions and data units to memory locations okay now let's see an example here I declare int a b and c a is given value equals to 1 b equals to 2 and C is the sum of a and B so let's break it into low level instruction one says store the value or store the constant one into variable a store constant 2 into variable B now load the value of a into R1 and load the value of B into R2 add R1 + R2 and store the result in R1 and then store the value of R1 into C and now we got c as sum of A and B so this is how this program this high level program is broken into low level so let's say this A B and C are they're in the memory location let's say at a equals to0 B is at 2 C is at location 4 so this is what data units are and these instruction will also be stored somewhere so these instructions are are the program instructions so Association of data units and program instruction to memory location so these are the memory location this is what address binding is okay so I took an example to show you how data units and instructions are stored in memory and giving them addresses is what address binding is so binding instruction and data unit to memory location is address binding now Comes The Binding time time at which binding take place does The Binding take place at compile time load time or run time so depends on which type of binding we are doing for example name binding the name binding is done at compile time type binding I write int X so I assign a name X to this variable so this is what name binding is and is done at compile time I'm assigning a type of this I'm assigning a type to this variable so this is what type binding is this is also this is also a compile time now comes the address binding so address binding is done at load time variable X get associated with memory location at load time and what is value binding when this in Tex will get a new value when it will happen let's say I write X = to 1 so this instruction will be executed to get its value so one will be stored at memory location X when this will happen when it will be executed so for execution we need runtime so that's why value binding is done at runtime and size binding same as compile okay so you have to remember this name binding type binding size binding this is what it's done at compile time address binding is done at load time and value binding is done at run time okay types of binding static binding and dynamic binding static binding says Association cannot change Dynamic binding says Association can change okay let's say entity is a person entity is a person I assign a name to a person let's say your name is Rahul okay so from the birth to that to death your name will remain same or let's say let's take an example of your fingerprints your fingerprints will remain same they will they are unique and they will remain same this is what static binding is the attribute which remain same to the whole lifetime these are static attributes and static binding and the attributes which changes with time are Dynamic binding for example age binding that is dynamic so I can say name attribute is a static type is a static if I say int X then name X is a static int this will remain same address will remain same value can be changed if I say x = to 1 in the next line I can say x = to 2 then the value of x initially was 1 and it got change to two so value can change that's why it is dynamic and size can the size of X differ no it is defined at the compile time so this static size is also static so after of these attribute name type address value and size only value is dynamic okay now let's see the type of address binding based on time first is compile time address binding if addresses of data units and instructions are decided by the compiler then and it is compile time binding and that is purely static so compile time binding says the addresses of data unit and instructions are decided by compiler then it is compile time Bing what is load time compiler will not generate or associate the address loader will do so this is what load time binding here is a example so now what loader will do let's say there are three instructions with me so loader will generate let's say offsets now we'll see load time compile binding in this compiler does not generate or associate addresses loader will generate compiler will generate offsets which are not real addresses let's say the i1 is always at zero this is the first instruction now the instruction two will be stored at 0 plus size of i1 let me explain this is where the i1 is stored zero now now instruction two will be stored where after instruction one get completed so it will be stored at the size of I and where it does I3 will get stored I3 will get stored at here what is the address of this part size of i1 plus I2 so these are the offsets generated by compiler and it will be communicated to memory manager that is the OS module now memory manager will give the address of Base register base register says the instruction i1 is stored at 6,000 these are not the real addresses these are just offset so what I will do I will say that i1 will be stored at instruction 6,000 because this is what the value of base registor is now I2 will come at 604 this is what the size of i1 is okay now I3 will come at 6,8 this is what the size of i1 + I2 is are you getting the point now they are the real addresses let me repeat again what happens at compile time the addresses and data unit instructions are decided by compiler and it's compile time binding what what does load time binding say it says that offsets are generated by compiler and then loader will assign the real addresses based on communication with memory manager what is the base register value adding the offset to that base register value loader will find the real addresses this is how it's done so so this was compile time and load time binding now we will see what is runtime address binding and one more thing during execution instruction and data unit does not change at load time and compile time binding let's see an example suppose these were the instructions of a process in the memory now what happens the process is swept out it is sent to the disk so what happens in static address binding this will remain empty this will remain empty addresses cannot change here and when swed in it will be assigned to the same addresses so when the swapping swap they will be spped in where will instruction V in come here instruction to here instruction three instruction four this is how they will come they won't change the address from there from where they were swept out the exact same location they will be swept in and now you have gu guessed what what would have happened at runtime address binding it is also done by loader itself but when this when the instructions are spped in they can be loaded to a different place so addresses can change during execution so this is a kind of good thing because it gives relocation flexibility now let's revise what we have learned till now what is address bending assigning addresses to instructions and data unit of a program okay so what are data units and instructions suppose this was our program when it is broken down into low level these variables are the data units like a is stored at address Zer B is stored at address 2 C is stored at address 4 so these are the data units assigning addresses to them is address binding these are the instructions these i1 I2 I4 I5 I6 these are the instructions so assigning addresses to them is what address binding is okay now it is not just the address binding different attribute is associated with different kind of binding for example name binding type binding address binding value binding and size binding so now the question arises which type of binding happens at which time either it is compile time load time or run time so I can say name type and size name type and size happens at load time happens as compile time sorry and address binding address binding happens at load time and value binding happens at runtime why run time because for Value to be assigned this instruction should be executed and execution happen when when we run the program that's why values assigned at run time types of binding static and dynamic in static type of binding Association do not change in Dynamic binding they change for example we have seen that uh in compile time and loow time binding if the instructions of a process are swapped out then this place will remain empty and when it's time to bring them back then they will be brought back to the same exact location so this is what static binding is they cannot change the value of the addresses but what happens in the dynamic type of binding if you are swabbed out from some location then it is possible that you can be swabbed in at different memory location this is what relocation flexibility is so in in Dynamic binding Association can change okay so name static name binding is static type binding static address binding is generally static value binding is dynamic because value can change size binding is static now the question arises if we say address binding is static then what about run time address binding which we have just seen now there the address got changed that's what we generally talk about address binding can be static okay so here I can change it to static static or dynamic okay so this is what general thing is generally we talk about compile time and load time but if we are focusing on runtime address binding then that will be dynamic types of address binding we have seen compile time addresses of data units and instructions are decided by compiler load time loader will assign the addresses based on communication with memory manager memory manager will have given loader the base register and loader will add the offsets generated Ed by compiler to the value of Base register to get the real addresses okay now we have learned about runtime address bending let's see how a program is completely executed multistep processing of a user program okay let me okay multistep processing of a user program Here Comes The Source program do c do c compiled compiler assem assembler this is compile time here we get object module obj this is not linked this is connected with or this has unresolved references now it comes or it goes to the linkage editor the Linker here will fill up the blanks it will send to the load module exe will be loaded into the main memory and now this was the program till now now it becomes the process now this process will be executed by CPU okay so what's written here Library function other object module given to the linkage as I've told you if it is if the addresses are not found in memory then it will uh search for libraries at the disk okay so this is how a program is executed so if I say address binding then this is the compile time address binding this is load time binding and this is the runtime binding so when does runtime binding happens during the execution time okay so now in the next lecture we will actually start our memory management techniques the memory management techniques can be segregated into two part the first one is contiguous and the second one is noncontiguous noncontiguous means distributed and contigous means centralized let's take an example suppose in disk this is our program it's of 100 KB so when we have loaded the whole program at one place the whole program at one place that means all 100 KB at one place this is what centralized allocation and when we have loaded we have broken the program into three parts 40 KB 40 KB and 4 KB and stored them at different places this is what distributed or noncontiguous memory allocation is okay so we will learn about overlays partitions variable and fixed body systems paging segmentation segmented paging demand paging all these things we are going to cover in this memory management section so these are the old techniques which is overlays partitions Bud systems these are the old techniques this body system we are going to cover in our miscellaneous topics in the end okay overlays and partition we will cover in this lecture so these are the old techniques but we have to study them because memory management fundamentally started from these well we know that these are the new techniques but the memory management fundamentally started from this if you remember in our science classes when we used to study atomic structure we also studies the Thompson Plum ping model we studied that raford model in the end we knew that these were the wrong but we still studied because the final thing fundamentally rise from the old things or the old theories that's why we are studying overlays partitions and body system okay so this all thing is managed by a module of operating system which is memory manager so now we will study the function and goals of memory manager the first thing is allocation before loading the process you have to first allocate the memory so this is what the memory manager helps with it helps with the allocation of which color I should choose I think this would be better before loading the process the process you have to first allocate the memory so this memory allocation is managed by memory manager protection suppose this is what uh memory looks like this is the system area user area with different processes in between now a process should not interfere with the space of different process so area of memory where program is loaded is the program address space so this is what the address space of P3 this is what the address space of P2 address space of P1 so P3 is address space should get its instruction executed in its own address space only and should not interfere with the addresses space of some different process so there should be no trespassing who handles this the memory manager so it is the task of memory manager to allocate the memory it is the task of me memory manager to ensure that there is no trespassing of instruction between the processes address space Free Space Management as the name suggest managing the free space address translation I hope you remember the logical address and physical address thing so the address translation is managed by memory manager and deallocation when the process is completed deallocating the memory the process has to return the resources the return the memory so that is all managed by memory manager now what are the goals of memory manager it works to minimize wastage to utilize the memory effectively okay so this is what fragmentation is we call in in memory management term we don't call it wastage we call fragmentation internal fragmentation external fragmentation we'll see it later but the vage has a new term here that is fragmentation okay ability to manage large program in small memory areas yes this is important suppose our memory is just of uh let's say here is the example here's the example given this is dis I have a program of 100 KB but the free space I have only of 60 K so by stalled program concept what we have to do we have to load the program into the main memory but can we do this can we do can we load the whole program into main memory no by stored program concept we cannot but we can with the help of virtual memory and overlays we'll see what is virtual memory and overlays in few minutes so what is the goal again minimize fragmentation and secondly manage larger program in small memory areas okay so this means operating system can load more program in memory and this actually means degree of multiprogramming increases and you all know if multiprogramming increases which means efficiency and throughput increases so this memory management or memory manager is a critical module of operating system now let's understand what is overlays take an example this is a assembler architecture this is what assembler is okay it has a pass one pass two pass one of 70 KB pass two of 80 KB don't worry if you don't know what is pass they will learn that in detail in our compiler design course so pass one has 70 KB Pass 2 has 80 KB symbol table common routines and overlay loader these are of 30 KB 20 KB and 10 KB respectively now the whole size of this assembler is 210 KB so to to convert any program into Assembly Language using this assembler we need 210 KB memory but what happens we had some budget constraint and we can only have a 150 KB memory now can we somehow convert a pro convert a or can we somehow use this assembler on this 150 KB given that this is a two pass assembler that is two stage assembler and pass one and pass two are independent there's no relation between pass one and pass two we need one at a time so can we execute or can we use this assembler on this 150 KB yes we can so the main idea is complete pass one first and then replace it with the pass two as both are independent so what we have done this 3 4 5 which means uh the symbol table common routines and overload overlay loader this is necessary for everything this is necessary for every pass so what we have done we have kept it intact but as soon as pass one is executed what is the size of pass one it is 70 KB so the size of symbol table overlay and this complete size is 60 KB only so we have given at 60 KB now we are left with 90 KB so first we have loaded pass one into it pass one into it pass one will be executed because it has everything to execute pass as soon as pass one is executed we will replace pass one with pass to so this is what overlays overlay means replace and it is possible only if program is divisible into independent modules so what does overlay say overlay say if you are running short of memory and you have some uh parts of a program which can run independently then replace as soon as one part is completed so this is what overlay is let's solve an let's understand overlay more with the help of an example suppose this is a program EXP added as a overlay tree and the size of a program is 92 KV now tell me the minimum memory required to successfully execute this program using overlays you know what does overlay say search for the program units that are independent of each other so I can I can do like this root A and D this can be given as pass one root root A and E this can be assigned the name of pass two because when this is being executed there are there is no need of keeping b c f g h i j d in memory A and B are independent A and C are independent B and C are independent D and E are independent E and F are independent F and D are independent so I hope you getting the point when root A and D are there there is no need of keeping this whole tree in the main memory so what we are doing we are giving every from every path from root to node as a pass so we can say this is pass one this is pass two this is pass three pass 4 pass Five pass Six and pass seven and each pass can be executed independently so what we'll say first execute this how much memory we require 10 + 8 + 5 8 and 5 13 13 and 10 23 so we need 20 3 KV memory to execute pass 1 for pass two 10 18 and 8 which means 8 and6 so 26 KB memory required here 8 and 6 uh sorry 10 and 6 16 16 and 10 26 26 required here 10 and 7 17 17 + 12 29 29 K be required at pass 7 10 and 7 17 17 and 27 required at pass six 10 and 7 17 17 and 9 it is I think 26 so 26 can be required at pass five so I can say minimum memory required is maximum of memory required from pass 1 to pass 7 that will be the minimum memory so the maximum memory required was at pass 7 so I can say if I have 29 KB of memory then we can execute this whole program without any problem so the size of program you can see was 92 KB but but we we were able to execute the whole program in just 29 KB how were we able to achieve this using overlays replace replace replace which is not us used here so let me explain you again so if you are executing this there is no need to keep this part and this part in the main memory okay now comes the partitioning partitioning means breaking the user space into cells so partitioning says they can be different type of partitioning fixed partitioning and variable partitioning we are first going to study fixed partitioning multiprogramming with fixed task you will get the idea why we have said multiprogramming fixed task in few minutes so what we have done this is our system area this is our user area let's expand this user area so what we have done we have divided this user area into different blocks they can be have different size but what we have done we have divided the user area into different blocks or different segments so we will divide it into fixed number of partitions and in each partition we are going to store a program a bigger program will be stored in the bigger partition and smaller program will be stored in the smaller partition so partition may be of different size but the important thing which you have to remember is only a single program can be stored in a single partition so there is a kind of one to one relationship here okay uh one to one relationship here so the size of program size of partitions can be different as program size are different so what we have learned till now partitioning can be of different type fixed partition variable partition in fix partition the pro the user area can be divided into different partitions of different size and each partition can stored only a single program and size of partition can be different because program size are different limit resistors it's a kind of resistor and what is what is the purpose of limit registor let's see here the purpose of limit register is to basically Define the size or instruction range of that process let's take an example suppose CPU generates an address of 2800 process Pi is running and it generates an address of 2800 but in main memory we have instructions of process Pi defined till 2500 only from 2,000 to 2500 let me Zoom it so it generates an address of 2800 but the process address space is from 2,000 to 2500 only now it is the responsibility of memory manager to ensure that because this 2800 can be the address space of some different process this Pi is being mischievous and it is trying to access the private address space of some different process so now it's the memory manager job to stop stop it how it's going to stop so what we have done the starting address is the Base address and this 500 is the limit so this 500 will be stored in the limit register so what happens the address comes here the firstly it will check is is the address greater than the Base address or greater than equal to the Base address because if it is less than equal to Base address then also Pi is trying to access the address space of some different process so first it will check if the address is of this area only how it will check it will first check if it is greater than 2,000 which means it of this part or not if no then it is a trap to operating system monitor addressing error and if yes if it founds that the address generated by the process consist of this area then it goes to the next phase it says the address you generated is it less than the base plus limit the address you generated is it less than this part which means now the address is confined to this area only but here what we see the address is of 2800 so here here it will say no the address is not less than 2800 is not less than 2500 so it will go here trap interrupt will generate saying addressing error now let's take an example suppose the address which is generated was 2100 now what happens it goes here it first check is 2100 greater than equal to 2,000 yes now it comes here it ask is 2100 less than 2500 yes then it can access so this is what limit register do this 500 is the limit register it is the size of the process address space and what does base register do it gives the starting address so this limit register done at the O voting time it used for partitioning so this is instruction range base plus limit architecture to ensure protection okay as we have CPU scheduling techniques we have techniques for partition allocation to partition allocation to suppose a new process comes uh a new program has 80 KB size we have to bring that into main memory now the main memory has different available partitions it has a partition of 200 KB it has a partition of 120 KB 70 KB 81 KB now in which partition it should go this is what partition allocation algorithm or partition allocation policy that we'll learn in the next lecture okay so now let's revise what we have learned till now memory management techniques consist of two part contigous and noncontiguous contiguous is when we bring the whole program at one place and noncontiguous ISS that it is dist it's first broken down and it is distributed at different locations of the memory now we have memory management techniques the old techniques include overlays partitions and body systems we have studied overlay what does overlay say we will see when the topic will come so these are the old techniques and these are the new techniques functions and goals are allocation protection and Free Space Management address translation deallocation goals is to minimize fragmentation and ability to manage larger program into smaller memory areas what does overlay say overly says that you don't need to take the whole program into main memory complete unit one first and then replace it with unit two as both are independent we have seen an example now partitioning partitioning of fixed partition we divide the whole program or the whole user area into different partitions and can they can be of different size limit what does limit register do it helps in the ensuring protection and now in the next lecture we'll learn how partitions are allocated see in CPU scheding what we have learned we have learned how from Main memory the which process should go to the CPU now in Partition allocation we will learn from hard disk at which place the pro the program should go okay now let's learn about partition allocation policy as we have different algorithms for CPU scheding similar way we have different policies named as first fit best fit next fit and worst fit let's see what they all say the first fit says search for the first slot or the first partition big enough to accommodate the program suppose here in the case for the first slot is 200 big enough to accommodate my program yes then according to the first fit policy this 80kb program will be stored at partition number one okay so 80kb program will be at 200 KB partition so 120 KB remain as waste because I have told you in Partition and program there is one to one relationship a program can be stored at only one partition or a partition can hold only one program so there's a one to one relationship and if 0kb program is stored in 200 KB partition then 120 KB will go to waste that kind of wastage we call as internal fragmentation okay so in first fit what we do we search from the first partition in best fit what we do least internal fragmentation so here 80 KB can be stored at this part only 1 KB will be wasted here so which is the best fit here in such a way that the internal fragmentation or the wastage of memory will be least so least internal fragmentation smallest free partition big enough okay in first fit first free big enough in best fit smallest free big enough in next fit it works it works like the first fit search begins from the last location see in first fit we start from the first part in next fit we start from the last partition so next fit works like the first fit but here search begins from the last location and what does worst fit says largest big enough and what is the worst fit here the first fit is the 200 KB so let me revise again first free first fit says start from the first partition whichever partition is big enough to hold your program stored in that what does best fit say search all the partition and then calculate the internal fragmentation the partition with least internal fragmentation the program will be stored there now comes the next fit next fit says search from the last whichever partition is big enough to hold your program store there and the first F says search the all partitions whichever partition is maximizing the internal fragmentation that is the worst fit okay so in case of search in case of next fit search time can be saved and may work faster than first fit in some cases okay suppose uh here in this case first fit will be a bad choice next fit will be a good choice so doesn't matter much but here we say that the search time is less and it may F work faster than the first fit now we will learn about performance of fixed partition as we know fixed partition is static in nature so we can say internal fragmentation happens what is internal fragmentation suppose this is the partition size 1,00 KB and my program size is 1 KB only so the 999 will be wasted that is internal fragmentation what is external fragmentation then external fragmentation says wastage of memory outside the partition but here in this fig partition there is no there is no such memory outside the partition see here this is memory divided into partition can you see a memory outside these partitions no each memory space is divided into partition so there's no memory outside the partition so I can say there is no external fragmentation in in case of fixed partition internal fragmentation obviously exists suppose I have program size of this much only so this whole Space is wasted internally so what is internal fragmentation vage of memory in the partition external fragmentation vage of memory outside the partition the degree of multiprogramming here is limited because the degree of multiprogramming is limited why because it is equal to the number of partition it cannot change it is limited okay maximum process size is also limited it is equal to the maximum partition size partition allocation policy which we follow is best fit so this was fixed partition in fixed partition the partition is of fixed size and each partition can hold a single program now comes variable partition as the name suggest partitions can be of different size depending upon depending upon process size multiprogramming with variable task here we say fixed partition as multiprogramming with fixed task if you remember multiprogramming with fixed task now you may now you may have understood why we call it as fixed tasks okay because the degree of multi program in is limited here variable partition multiprogramming with variable task because we have Dynamic partitioning here this is let's say the process requirement P1 requires 35 kb of memory P2 requires 115 315 15 and 120 so initially no partition is there remember this point is important initially no partition is there the memory just like a free hole there is no partition now the partition is made ACC according to the process request when P1 comes 35 kb of partition is made when P2 comes 115 KB more of partition is made P3 comes so partitions are made depending upon the process request and in the end the remaining area is just like a free hole if some another process come then another partition is made P2 and P4 have all its instruction executed so leave they will leave the memory uh let me okay so this is a case in which this process and this process has completed or has executed all its instructions so what they will do now they will leave so this is a free hole now here generated so this is P1 free hole 1 P3 free hole 2 P5 free hole 3 now we have three free goals 115 KB 15 KB and 250 KB now a new process P6 comes with a request of 13 KB now a request of P6 come with a request of 13 KB what we will do we will make a partition of 13 KB here in the free hole one and the remaining free hole of 102 KB and a new free hole will be created of 102 KB so this is what dynamic partitioning is there and the allocation how allocation is done same policies first fit next fit best fit and worst fit if I talk about first fit then this 13 KB is sent here new Partition is made of 13 KB at the free hole one if I talk about next fit then you search from the big from the last and if this free hole is able to is big enough to occupy this 13 KB then you create a new Partition here of 13 KV so if I talk about next fit then free hole 3 is suitable if I talk about best fit then free hole 2 is suitable you check all the free holes and whichever free hole is causing least external fragmentation here in that case in that case this is the best fit so if I bring down this here 13 now how much how much space is is remaining 2 KB spaces remaining and we know that uh if these are the normal size of the processes and by seeing that we can assume that that having a process with Just 2 KB size is very rare So this 2 KB space will remain as it is this is what external fragmentation is memory space outside the partition which cannot be used is what externally fragmented memory okay so which free hole cause the least external fragmentation this freeold 2 so the best fit is freeold 2 now comes the worst fit it's of5 KB 15 K and 250 so this will be the worst fit now comes the performance issues internal fragmentation there's no internal fragmentation because partitions are made based on the process size so there can't be any inter internal fragmentation what is internal fragmentation in Partition when a process is able to occupy only this much space and you all know that a partition can hold hold only a single program so this space is wasted this is what internal fragmentation is and what is external fragmentation let's say this is the memory this is a partition or let's say this is the free hole I should say and these are the partitions already made here resides P1 here resides P2 here is P3 now this is the freeold a process comes and creates a new part partion of here let's say P4 comes now there is some another process P5 but it cannot be accommodate in the this this partition space so this partitioner space is being wasted here this is what external fragmentation is what is external fragmentation memory wasted outside the partitions so this is what external fragmentation is let's discuss the performance issues external fragmentation yes it will cause external fragmentation internal fragmentation no so yeah see let's take an example this is a free hole one of 115 KB free hole 2 of 15 KB and free hole 3 of 250 KB now a new process comes which is a size of 280 KB combining these these free holes have a much larger size is of 380 KB but what we are still telling this new process that memory is not available so the size of total free memory is greater than process request but it's still denied this is what external fragmentation is the size of total free memory is greater than the process request but we still deny the process that memory is not available this is what external fragmentation is degree of programming flexible maximum process size flexible partition allocation policy worst fit why worst fit because the worst fit will create the biggest free holes and if the freeh hole size is large in that case external fragmentation will be less best fit May create small free holes which may not accommodate new process so bu fit will create big free holes bigger free holes that accommodate the new processes now comes the question how are we going to solve this problem of external fragmentation so the answer is by Saving noncontinuously let's see this here what we had we had a 280 KB process and we have a free holes of 115 KB 15 KB and 250 KB we deny that memory is not available only if the case when process is requesting the whole content should be placed at placed at one area if I say process hey process is it will it be okay with you if I place 250 KB of your area here and the remaining 30 KB and the remaining 30 KB here will it be okay with you and if process is yes I am willing to be stored noncontinuously then external fragmentation issue will be resolved see here how to solve the problem of external fragmentation suppose this is the case 50k free hole 80k fre hole and 20K fre this is process one and process two now comes a new process of 85k traditionally it would be denied because continuously there is no space available to store 85k even if combining 150k is available but not continuously so what are we going to do we can make it either continuous by reallocating P1 and P2 to one end of the memory and creating a bigger freeold this is what we call compaction compaction we will shift this P1 and P2 to a 1 and of a memory and we will create a bigger fre hole see here P1 and P2 shifted to one end and now a bigger free hole of 150 KB is there and this merging of free holes is what we call competion but this competion is not very much desirable because it is a timec consuming operation so if you remember the address binding concept now this P1 and P2 are shifted to a different location so this must support runtime address binding if you remember if we Swip out a process from one location and Swip in the process to a different location this is we call runtime address binding the addresses changes so this is undesirable solution the second solution was noncontiguous allocation store the program into noncontiguous part this is what I was talking about competion is not automatic but if two free holes are adjacent then they are automatically merged well that's a common that's a thing which comes from common sense that this is free hole one free hole 2 free hole one and free hole 2 then they are just a single free hole shown with a boundary but actually they are single FS but in competion suppose this is a free hole one here freeh hole one a process comes in between and now here is the free hole two in this case I can say these free hole won't merge competion is not automatic but if free hole would have been here then these two free hole will merge automatically or by default we believe that these free holes are single free hole okay so let me discuss it again so how we are we going to solve the problem of external fragmentation the answer one was the better one the better answer was non continguous allocation the second answer was compaction in competion what we do we merge the free holes to create a bigger free hole okay in in noncontiguous location what we do we break the program into two parts or parts in different parts and store them at different memory locations this is example of variable partitioning there's a partition of 2 MB partition 2 of 6 MB partition 3 of 3 MB 4 MB and 6 MB this is the OS system area and this is the user area and in these partitions process resides so in Partition one process one is there process two in Partition two process three and so on now what happens P2 and P4 are completed so when process completes then they will leave the area and will cause a free hole here free hole here now what happens P6 and p7 arrives P6 is stored at this free hole the size of P6 is 4 MB so 4 MB is stored here and 2 MB free hole is created now here and p7 arrives p7 the size of p7 is 3 MB so what happens this 3 MB will be stored here and 1 MB of free will be created here now p8 comes the size of p8 is of 3 MB and we have a total memory available of 3 m also but we cannot load p8 why because continuous allocation because p8 demands continuous allocation and we don't have a memory at a single place we don't have 3 MB memory at a single place so p8 will be denied so this is what a basic example how variable partitioning Works let's solve some problems it says consider a memory system having six partitions of size 200 400 so these are the partition size given there are the four process of size the process requests are given using best fit allocation policy what partitions are not allocated or remains unallocated so what we will do we will allocate process in such a way that it will cause least fragmentation so P1 will be allocated to 400 will cost least fragmentation but it should be big big enough you cannot allocate to 200 okay you should know that so 357 will allocated to 400 if it would be allocated to 600 500 then it would cause more fragmentation so P1 will be allocated to 400 P22 this 250 210 will be allocated to 250 for this 468 will be allocated to 500 and this 49 this 49 will be allocated to 200 so in this way I can say that 600 and 300 was unallocated it was an easy question uh what it said you have to allocate using best fit and whichever partition was unallocated you have to tell me that so 600 and 300 is the answer second second question it says consider the following memory map in which blank regions are not in use and hedged regions are in use so these are in use and these blank ones are not in use use variable partition with no competion the sequence of request for blocks of size 300 25 125 50k can be satisfied if we use now we have to choose among these options let's see the request are 300 25 125 and 50 First we'll choose with first fit so the first fit says a lot your processes to those partitions which are big enough to accommodate and you will search from the first one I searched for the first first one is it big enough to accommodate no second one is it big enough yes so 300 will be accommodated here now comes 25k is it big enough yes 25k will be alled here is it yes 125 will be allocated now comes the 50k so in this manner first fit partition it is suitable check for the best fit we will allocate in such a way that it will cause least fragmentation 300K will be allocated here 300K now comes 25k 25k will be allocated here 125k here now comes the 50k so there's a 25 KB free space available here also 25 KB free space available but it is written in the question that we are not using competion so we will say that sorry process we won't accommodate you because we have no con 50k available with us so 50k can be accommodated so here best fit is a wrong choice first fit is actually a best choice now comes an interesting question consider a system with memory of size 1,000 kiloby it uses variable partition with no complection presently there are two partitions of 200k and 260k respectively so let's say P1 process resides in this partition P2 is in this what is the allocation request of the process which would always be denied so let's say this is the case this is the case P1 and P2 are continuously stored so these partitions are just one after another so the total size is of 460 and the remaining free hole is of 540 so I can say 541k request will all will always be denied clear now this is the good question the smallest allocation request which could be denied which could be denied is the smallest allocation request which could be denied so this 541 is denied in all cases but if we create free holes in such a way that out of these three one is denied can it be possible so what we do we shifted these two down and we created two free holes we created two free holes now the thing is the total value of these threee holes should be 540 and you divide 540 in any way you will have these three you will have these three accommodated so 131 will be stored 151 will be stored and 181 will also be stored now comes an interesting part now what we do we create an additional free hole here by shifting P2 a little bit down so P1 is here P2 is here now we have created three fre hes let's say we have created three free holes so free hole 1 plus free hole 2 plus free hole 3 should have total of 540 Let It Be 180 180 and 180 now 131 will be stored 151 will be stored but this 181 will be denied so the answer should of this question will be 181 I hope you got the idea so what we have done we have created free hes in such a way that 181 is denied let's see some another questions it says consider a system having memory size of 2^ 46 bytes it uses fixed partitioning divides into fixed size partitions each of size 2^ 24 bytes the OS maintains a process table with one entry per process each entry has two Fields the first is a pointer pointing to to partition in which the process is loaded and second field is process ID so let us draw what whatever has been given a memory has a size of 2 4 46 bytes okay fixed partitioning is used it means this memory has been divided into fixed partitions each of size each partition is of size 2^ 24 bytes so I can say the number of partitions are 2^ 46 divided by 2^ 24 and I can say it is 2^ 22 I can say and Os maintains a process table with one entry per process and always maintains a process table with one entry per process and each process has one entry in it each entry has two Fields the first is a pointer pointing to the partition the first is a pointer pointing to the partition and the second is the process ID let's say this is P1 so what it does it has divided the memory into several partitions and it is keeping a process table suppose suppose this P1 is being stored in Partition number 10 so the address of partition number 10 let's say 1 1 0 0 1 something like that in binary okay I'm just taking a random number so in process table the process ID and at which location this process is stored in the memory that is being maintained so what is the question it says the size of process side is 4 by the size of pointer to the nearest by so we have to calculate the size of pointer to calculate the size of pointer we have to first understand what does pointer contain pointer contains the address of the partition in the memory to so we have to assign each partition a unique address we have 2 what 22 number of partitions which means we need 22 bits we needs 22 bits to generate 2 22 unique addresses so the size of pointer will be of 22 bits now the question is calculate the size of pointer to the nearest bite how many bytes are able to contain 22 bits I can say three bytes can contain 22 bits each by contain 8 bit so 8 into 3 24 bits so the size of pointer to the nearest bite will be three bytes now the question arises why can't I take two bytes because with two bytes I can only generate 2 to^ 16 different kind of addresses but what we require 2 22 see if it is an extra then it is okay but it if it is less then that is not acceptable this is what we follow here the second question says size of process table in bites if system has 500 processes if system has 500 processes then there will be 500 entries the size of each entry is three bytes for the pointer and 4 bytes for the process ID so it is 7 bytes 7 FS are 3500 bytes so the size of process table should be 3500 that is the answer let us discuss it again what this problem is saying this is an important problem it says it says we have a memory of size 2 raed to^ 46 PES we have divided that memory into several partition the total number of partitions are 2^ 22 each with size 2^ 24 so each partition each partition has size 2 24 bytes and there are 2^ 22 such partitions that's how we got 2^ 46 bytes of memory now what OS has done OS has maintained a process table with one entry per process so OS has maintained a process table with one entry per process the first field of the entry contains a pointer to the partition in which that process is residing so the first entry contains the pointer and the second entry contains the process ID so what does pointer contain pointer has the address of that partition now we have to assign each partition a unique address how many partitions are there 2^ 22 partitions are there how many bits are we going to need to generate 2^ 22 unique numbers so that we can give 2^ 22 partitions unique addresses we need 22 bits that's why the size of pointer will be 22 bits now it is asked size of pointer to the nearest bite so the size of pointer will be 22 divided by 8 floor function why floor sorry it is not floor function it is seiling function why sealing function because if it is more then it is okay if it is less then it is unacceptable why so because if we take if we take two bytes then we are only going to have 16 bits we will able to generate only 2 16 different numbers but how many different numbers we require 2^ 22 with three bytes I can generate 2 24 different numbers how many different numbers we require 2 22 that's okay okay so the size of process table in bytes will be if system has 500 process three bytes for the pointer four bytes for the process ID each entry has seven bytes and the total number of entries are 500 so 7 into 500 that is 3500 this is what this question says is consider a system using variable partition with no competion we are not going to merge the free holes to create a bigger free hole free holes are given 4K 8K 20K 2K program sizes are given time for execution is given so what we have to do using best fit allocation policy and using fcfs CPU scheduling Technique we have to find the time of loading of each we have to find the time of completion of each and the first time we are given with here so firstly what we have to do we have to bring all these programs into memory to make them processes so we'll first bring so out of these we'll first start with this 2K where this 2K will be allocated at this free hole where this 14k will be allocated at this freeh hole at 20K where this 3K will be allocated 3K will be allocated at this 4K where this 6 K will be allocated see if you remember when 14k was allocated to 20K a free hole of 6K was remained there so we allocate that 6K here now now see here firstly 2K was allocated here and then 14k was allocated here 3K was allocated here and 20K was allocated here oh n 6K was allocated here to fill this free hole of 20K now what is the remaining we have 6K remaining as at 8K fre and 1K remaining at 4K fre okay now what we have done we have also you must have seen here this purple shade this purple shade is showing a a small Gap a gap to ensure that these are not adjacent otherwise they will go Le or merge automatically okay so what we have to do now we have to schedule them we have to schedule them see here only 10K and 20K will be at the disc this 2K will also be scheduled here so so which programs are in the disk now 10K and 20K are in the disk now we will first schedule these and after that and after that when we have free spaces then this 10K and 20K will also come in the memory so we will schedule them first how are we going to schedule we will schedule using fcfs ceding so which program came first 2K came first so we are going to schedule 2K first here is the let's say let's call them process the one who arrived let's call them process one the second one to arrive let's call them process two the third one to arrive process three okay so we have assigned the process ID based on the time they arrive okay this it's just a matter of representation it will not uh it will not matter actually okay so first 2K arrived for the time of 4 units so from 0 to 4 2K will run the next 14k ride for 10 units so from 4 to 14 this 14k will run from 4 to 14 this 14k run now you can see here this part has become empty now this part has become empty now so here at 14k free hole we can actually schedule 10K so here 10K will come so now this 14k fre is empty 10K has arrived here and and I have a free o of 4K also see here if this 14k has gone and I have now 10K here so I will also have a free hole of 4K remaining that's how it becomes a total sum of 20 so scheduled scheduled that's 10K have come now which process 3K so 3K will be scheduled for how much time it has a first time of 2 units so from 14 to 16 3K will be scheduled now 6K 6K has a time of 1 unit so from 16 to 17 6K will be scheduled now if you remember 2K was brought into memory so 2K will be scheduled for 8 unit of time 2K will be scheduled for 8 unit of time so from 17 to 25 from 17 to 25 2K will be shed now it's time for this 10K because after the 10K has come so 10K will be scheduled for 4 unit of time so from 25 to 29 10K will be scheduled so now if you see we have empty space for 20K this has been scheduled this has been scheduled this has been scheduled now 20K free is present here let me write like this schedu shedu now we have 20K freeold here so what are we going to do we are going to bring that 20K here in the memory now 20K will be sched what is the bu time of 20K 20K bu time is 1 only so from 29 to 30 this 20K will be scheduled so this is how we have we have uh done a question of partition allocation as well as CP scheding both okay so this is how it looks now load time P1 P2 P3 P4 P5 were loaded at 0er P6 was loaded at 14 here that was the 10K and p7 was loaded at 29 that was the 20K proc okay so this is how we have done this let me repeat again what we have done so firstly we have to allot using best fit allocation policy we have given the program into those free holes which causes least fragmentation so 2K was allocated here 14k was located here 3K was located here 6K was located here okay in this way we have allocated and 2K which was remaining was allocated here when 6K + 2K both were allocated at the slot of 8K now we will start scheduling because we have two more process two more programs in the disc and they are waiting as soon as the memory becomes empty for them or they have the memory have enough space to accommodate them they will come so when this 14k was when this 14k was executed it has left the memory so it made a free hole for for 10K 10K came there when this 10K was completely executed when this 10K when this 10K was completely executed and the remaining was uh what was the remaining the 6K so 6K and 10K when these were executed now it has created a free hole to commodate 20K also so there 20K comes and this way we have scheduled the processes okay now it's your homework to calculate the completion time from the G chart how are you going to do that when was p7 completed at time 30 when was P2 completed at time 14 P4 at time 17 in this way you have to calculate the completion time loading time I've already told you consider the allocation of memory to a new process assume that none of the existing holes in the memory will exactly fit the process memory requirement hence what happens a new holes a new hole of a smaller size will be created if a location is made in any of the existing holes which of the following statement is true the first says the whole cre by next fit is never larger than the hole created by best fit well this is false best fit Works in order to create the smallest holes the second option says the hole created by worst fit is always larger than the hole created by first fit well this is also false because worst fit and first fit can be same so this always is creating a problem here the hole created by first fit is always larger than the hole created by next fit well this is this is false also because they may be equal they may be equal so if here it is written always larger that's create the problem the whole created by Best Fit is never larger than the hole created by first fit well this is true in all cases how can I say that because best fit works or the motive of best fit is to create the smallest holes so yes this is true best fit is the hole created by Best Fit is never larger than the hole created by first fit memory management part four noncontinuous allocation what was noncontinuous allocation suppose your process size is 100 KB but you have free space available for here 40 KB here 40 KB and in the last somewhere 20 KB if you have used continuous allocation you won't be able to bring that process from dis to memory but if you have used nonous location what we will do we will break this process into parts of 40 KB 40 KB and 20 KB this 40 and 40 is 80 80 and 20 is 100 so that 40 will be stored here this 40 will be stored here and this 20 will be stored here this is what noncontinuous allocation means you are not storing continuously okay so this noncontinuous allocation is useful to prevent external fragmentation what was external fragmentation before that first understand what was internal fragmentation suppose this was your partition and your process took this much space only now this space will remain unused because in a partition only a single process can reside so this is what internal fragmentation was this internal fragmentation happens in the case of in the case of yes you remember fixed partitioning because partitions were fixed process size are different so in that case in some partition it is usual for some memory to get wasted so that is the drawback of fixed partitioning now what we have done we have introduced variable partitioning Vari variable partitioning create partitions based on the process size let's say the process size is 10 KB so initially the memory is nothing but the free hole so what happens when a 10 KB process comes it create a partition of 10 KB so this is what variable partitioning was so we have a partition somewhere here somewhere here now what happens this 10 KB process let me create a better diagram suppose these are the partitions based on the process size okay now what happens P1 has been executed and it wants to leave the memory so now this uh P1 will get empty here this is now a free hole P3 also became ex also became a dead process so it will also leave the memory two fre have been created now P6 has also left the memory three freees are there 20 KB or whatever was the size 20 KB 40 KB and 40 KB now a new process wants to enter into the memory let's say it size is 100 KB what we will respond to that process we will respond in two of the either way the first way is hey process we are so sorry that you cannot be accommodate continuously continuously so you should remain in the dis the second way is a process I have an idea we don't have a 100 KB space continuously but if you you are comfortable we'll break you into three pieces of 40 KB 40 KB and 20 KB each and we will store you at the different location the process says yes I'm comfortable so this is what noncontiguous allocation is if the if the location was not continuous this 20 KB space will not be used if some process of size greater than or greater than 20 KB comes let's say a size of 100 KB have come if we have used continuous allocation this 20K will never be used but now we have used noncontiguous allocation so this has prevented the external fragmentation or the external memory wastage of this 20K so this is how noncontiguous allocation prevents the external fragmentation we have another method named compaction compaction was actually undesirable because it was time consuming operation required program to execute runtime atress binding so what we did in competion in competion we have let's see some process P1 a free hole here process P2 and a free hole here what we did we swept out the process P2 and then swept in at the different location so that the two free holes become adjacent to each other and if two free holes are adjacent to each other they will automatically CES resulting into a creation of bigger free hole so this is what competion is but it is undesirable because first it is time consuming the second it requires program to execute runtime at B and and let's learn what is address space address space is nothing but a set of words binded with the addresses memory is nothing but an address space it is also known as physical address space memory has different words each word has a unique address this is what address space is address space can be divided into two logical address space and physical address space logical address space is also known as virtual address space why virtual we will see it later in some time so before understanding the Las and the Pas we need to First understand what is logical address and physical address take this example I have already given you uh let me give it again suppose this is me this is you you come to me and ask hey do you know where is the library I say yes or I should uh you should ask me some private information like where is your house I say my house is you you just go 100 m straight and then take a left the second house is mine you go there it's good now what happens this information is e dropped by some Intruder he tries to do the same thing from different location he tries to go 100 m straight and take the left did he reach at my house no he reached at a different location though this is what logical address does but suppose if you asked me the address of my house and I have told you my house is at coordinate 10 comma 10 then this robber would have directly jumped at my house 10 comma 10 because he's now available with the physical address and you were given with the this this go straight and take the left this was The Logical address okay so what is the need of creating this logical address and physical address can't we just create the physical address directly no suppose this process has created the physical address directly has generated the address to directly access the memory content the instruction or data who is stopping the process not to create the physical address or U the actual address of some different processes address space who is stopping this process to create the physical address or generate the physical address of some different instruction or data which it is not supposed to exess this is the security concern take an example uh it's little bit different but it will give you a feel what happens in the college suppose you are in examination Hall you write your role number iitv 44 this is your role number when this copy this answer sheet will be sent to a different department or when this answer sheet will be sent for copy checking what happens they change the actual role number with a D role number so this iitb 404 that's actual role number will be changed to this logical sequence of number which has no meaning why is it done so to ensure unbiased checking suppose I'm deer to some Professor so Professor when sees the copy IIT B 404 hey this role number I remember his is sh R number and he's a nice guy I should give I should check his copy little liberally or I should give him more marks that kind of thought may come into an examiner's mind or the the one who is checking the copies that kind of thought may come it's natural so what they do they change the address or I should say this they change the role number with a dummy role number which we call as logical role number this was our physical role number an actual role number to ensure unbias checking this is uh something similar is done here in the in the memory management part also process running in the CPU generates some logical address logical address is sent to memory management unit and it is converted into physical address that is the actual address that is the actual address of instruction and data which this process want to access so the process generate what it generates n bit logical address this nbit logical address is converted into nbit physical address or maybe different bit physical address not necessary of n Bits only the OS the OS has control on physical address so physical address is accessed only by the OS let me repeat what happens process generate logical address converted into physical address with the help of memory management unit and that physical address is the actual address where the data is stored this is how the conversion works okay now let us clarify this thing physical address thing suppose this is my memory and it contains several words each word associated with different address the width of the address or the number of bits in the physical address I say as physical address has n Bits how many words would have been there in the physical address space or in the main memory I can say 2 ra to power n Bits words should have been there so this is what the physical address space or the capacity of the memory 2 ra to power physical address 2 ra to power physical address and physical address is always in the bits suppose I have four bit physical address then I can say then that there are 16 words in the memory and if it is bite addressable then this 16 world or 16 by directly give me the capacity of the memory this is what happens in the physical address space physical address space equals to 2 power physical address now I have formul written why doesn't the process directly access the physical address space because of security if we allow P2 to access physical address directly then it can also access physical address of P1 and P2 who is stopping P2 access uh who is stopping P2 to access physical address of the OS well that's a that's a very very serious concern who is the stopping process to access the operating system well operating system is also in the memory operating system also have some physical address if we allow a process to directly generate physical address who is stopping this process to access operating system well that's a thing of concern that's why operating system say let the process generate whatever they want I have the mapping table I will map and make a space accessible so that you cannot directly interfere that's why the addresses the set of addresses generated by the process is what logical address space is so OS says you generate whatever you want I have the mapping table I have the mapping table I will map I will map this RO number to this role number this is how this uh memory management or the translation of physical address and logical address works okay so OS maintains a table here mapping of all the logical address a process can generate and the corresponding and the corresponding physical addresses this table is maintained by the operating system so this is The Logical address each logical address corresponds to a world in the main memory each logical address correspond to the world in the main memory if you are not getting this just think why a process generate a logical address to access a word that's why each logical address should have been generated to access a word in the memory that's why I can say each logical address correspond to a word in the main memory so each logical address correspond to a physical address now comes the function of memory management unit the function is address translation program assume that I am in a logical memory OS will give it an illusion okay if I say formally it is an abstraction layer so what does program assumes program assumes that I am I am here in The Logical address Space Program assumes in that I am here in The Logical address space this process thinks that I am in The Logical address space and I'll generate The Logical address and this logical address will access the data and instructions here the process this process doesn't even know what is in the what is how OS is working in the back to ensure security this process doesn't even know this process thinks that everything resides in this logical space I generate The Logical address I get the data and instruction section from The Logical address process doesn't even know there exist some physical address or physical address space or main memory process doesn't know that there exist some memory management unit this is what abstraction actually is let's learn the design and implementation of noncontinuous techniques we learn the organization of logical address space physical address space and memory management unit it will start with simple paging suppose The Logical address space is of 8 KB and The Logical address is of 13 bits physical addresses is of 4 KB and physical address is of 12 bits now what we do we divide The Logical address space or the virtual address space into equal sized unit call Pages that's why we have named paging here what we have done this whole logical address space has been divided into equal sized equal sized remember this word equal sized Pages page sizes of one KB page size is of 1 KB so how many pages will be there 8 KB divided by 1 KB here I got eight pages from p 0 to p7 okay so the number of pages we get by logical address space divided by Page size the number of pages we got are eight pages now we have to for each page number for each page number how many bits are required three bits will be required for this page number 0 we'll require 0 1 and for page number seven we require 111 so page number P we we Define it by or we have a variable named P equals to log to n what is n number of pages how many page number or how many bits in the page number is required log to number of pages suppose I have n Bits in the page number which means I can generate 2 ra to power n different pages I hope I have told you from the both ways now what happens we will learn about page offset see the whole logical address space can be divided let's say for to keep it simple is only divided into two pages now each page will contain more than one word so there can be more than one word in a page now which word from that page we want to access we call that as page offset we divided into two pages this is word one word two word three and word four 1 2 3 and 4 this is 0 0 this word is 0 0 0 1 1 Z and 1 one now we want to access the fourth word so that address or uh that is called page offset which word we want to access from a particular page is called as page offset and how many bits are required in a page offset depends on the page size if there are four words then I require log to four bits if there are eight words then I require three bits so it depend how many words are there in a page so page offset will be equals to log to page size if page size is of four words then there will be two bits in the page offset so till now what we have learned the number of pages let's let's go from the start logical address space is divided into equal sized unit called pages okay each page may contain number of words and number of pages will be equal to this whole logical address space divided by Page size this is what we will give we will get by dividing logical address Space by Page size we'll get number of pages and we have to give each page a number we have to give each page a number so how many bits are required to give n Pages a number log to n Bits will be required or we can say the other way suppose suppose I have n Bits then I can give 2 ra to power n Pages a unique number so the page number will be log to number of pages now comes to page offset what does page offset say a page may contain diff a page may contain many words out of these which word you want to access this is what page offset is this page offset is the size how many bits you require to uniquely identify a word in a page what is Page offset how many bits you require to uniquely identify a word in a page this page number says how many bits is required to uniquely identify a a page from the set of pages I hope you now understand what is the this what is the formula of M what is p and what is D okay so how many bits need to refer one bite from 1 KB page that is 10 bits which is called as page offset okay let's say let's say this is a word in a page this is this is a word in a page and this is the whole page I want to access this instruction so from a whole page from a whole page there are number of words how many bits I need to give address or to uniquely identify each word in the page well that will be equal to the number of words there so number of words or the page size I will do what log two page size or I can say number of words there in a page equal to page size that is Page offset okay so let's let's understand by a different analogy also what happens this is our classroom this is the teacher this is the student the student or the teacher want to call this student so what will teacher do teacher will call the bench number one and from this bench teacher will call the third student from the left so this so this statement third student from the left this is what page offset is first bench this is what page number is I hope now you're getting the idea let me summarize again so what happens this logical address space is divided into equal size unit call pages and we have to give each page a different name or different address so that is what page number will help us we'll have to find the number of pages log to n will be the page number now we have successfully identified let's say 1 this is 0 0 or this is 01 we have success successfully identified this page contains our instruction this page contains our instruction now this page have several words which word from this page contains our instruction to find that we require a page offset we require a page offset let's say 1 1 1 this is the page offset this says the seventh word or this is the eth so this is0 1 2 3 4 5 6 7 so this word contains my instruction I hope now you have a clear idea what this page offset page number and number of pages means okay so that third student is Page offset the first bench is the page number and this classroom is the main memory this is how exactly logical addressing works so in a logical address format what we have we have this logical address divided into two parts the first part is page number it is used to identify which page contains our instruction and the second part is the page offset it is used to identify in this page which word contain my instruction let me repeat again and then we'll end our lecture logical address format has two Fields the first field is page number the second field is Page offset the first field says which page contains my instruction and the second field says in this page which word contains my instruction that's how you reach to the final part that's how you reach to the instruction that you want first you identify the page then you identify ify the word in that page that's containing your instruction in the next lecture we will see some questions that will increase your Clarity see this question The Logical address space is of 32 MB so I can say for 32 it is 5 and for MB it is 20 so I can say 25 2 power 25 bytes for to address each by to address each by in total I would require a 25 bit address suppose my instruction is at some this by present here how I'm going to reach that instruction firstly I have to I have to find in which page this instruction is there and then I will find in which word of the page instruction is present so in total in total I would require 25 bit after of this some of the page bits and some of the offset bits so how are we going to find the page bits for that we need to know the page size it is given 4 KB so I can say this 2^ 25 bytes address space is divided into pages each of size 2^ 12 bytes so how many pages will be there 2^ 25 2^ 25 divid 2^ 12 that is 2^ 13 pages are there to uniquely identify these pages I have to assign them page number how many bits are required to generates 2^ 13 unique numbers I would require 13 bits so for page number 13 bits are required now 13 bits are given here how many bits I'm going to require for this offset 25 13 that will be 12 bits I hope you got the idea now okay see this question it ask let's say the total number of pages are 2K which means 2^ 11 pages The Logical address is of 32 bits can you give me the page size can you give me the page size if the logical address is of 32 bits I can say The Logical address space will be of 2^ 32 bytes I know this 2 32 bytes is divided into 2^ 11 pages so what will be the page size page size will be of logical address space divided by the number of pages so 2^ 32 divide 2^ 11 I get 2^ 21 I can write 2^ 21 like this 2 power 2 power 1 into 2^ 20 so I can say this is 2 MB so the page size is of 2 MB this is how you have to solve see don't mug up the things try to understand the concept if you just learn the formula you will believe me you will get stuck in the difficult questions but if you understand the concept no question will be difficult for you now we'll learn the organization of physical address space physical address space is divided into equal size units just like The Logical address space But Here we call them as frames and each frame hold on a one page so I can say the frame size will be equal to the page size let me repeat logical address space contain different pages and physical address space this is this is what the main memory is physical address space in the same way is divided into different frames and each frame contains one page see this Frame zero contains page number five frame one contains page number two frame two contains page number zero frame three contains page number seven so I can say this frame size should be equal to page size remember this this is an important concept so frame is meant for holding a page any page can be stored in any frame but remember only one page can be stored in one frame because the page size is equal to frame size so if I ask if I ask number of frames will be physical address space divided by frame size or I can also write physical address page divided by Page size what I have done this whole physical address has been divided into number of frames each frame is equal to one page or each frame size equal to a page size so I can write physical address space equals physical address spage divided by Page size equals to number of frames we denote number of frames with m and frame numbers depends on the number of frames log 2 number of frames this is what will be required to these many bits are required to give each frame a different number okay see I have if I have n Bits then I can generate 2 power n different numbers and these 2 power n different number can be assigned to these two power n frames so if I if I have to go other way around I can say if I have 2 power n frames then I would require n Bits we have done this concept so many times you should torrow with this okay and same frame offset page offset frame offset and Page offset are same frame size and Page size are same so physical address consist of frame number and offset frame number helps in finding in which frame our page is present and this offset is finding in that page in which world the instruction is present okay so let's see this logical address is of 2^ 31 bits physical address is of two uh physical address is of 20 bits page size is 4 KB page of 4 KB what can I tell from this logical address is 31 bits so I can say The Logical address space will be of 2^ 31 bytes and this logical address space is divided into pages each of size 4 KB I can write it as 2 and this K is 10 so 2 power 12 what is 2 31 12 it is 19 so I can say number of pages are 2^ 19 okay now anything more check and tell I can tell number of frames also physical address space is of 2^ 20 bytes and I have told you that each frame contain a single page so I can say frames size is equals to page size so this 2 ra^ 20 is the physical address space divided into different frames each of size 2^ 12 by this so I calculate 2^ 8 is the number of frames in the main memory 2^ 19 is the number of frames in The Logical address space number of pages in The Logical address space we don't call Pages as frames in The Logical letter space we call frames in physical letter space so Pages for l s and frames for PES okay now how many how many bits we require to uh give each frame a different number we require eight bits and how many for uh page we require 19 bits now we have to find the offset what will the offset see this physical address space consist of 20 bits and I have 8 Bits for frames so it require 12 bits for 12 bits for the offset can I go the other way from The Logical address yes The Logical address consist of 31 bits 19 bits is assigned to page number so I will require 12 bits for offset this the 19 came from here I hope now the whole concept is clear how are we uh doing this or how how are we solving this let me repeat for the last and the final time I know you all are bored but this is an important concept no misconception should remain what happens logical address space is divided into different units called as Pages how many bits we require to give each page a different number that's called the page number so page number will be log 2 N The Logical address consist of page number and offset what is page number used for to identify in which page instruction is present and what is this offset used for to identify in which word of that page my instruction is present okay now comes to the physical address part in physical address space what happens this whole main memory is divided into different units called as frames each frame is supposed to store a page each frame is supposed to store a page so I can say the page size will be equals to frame size this logical address is divided into different frames so I require F log to m m is the number of frames log to m is the number of bits for frame number and D will be the same now what is f will useful for f will tell you in which frame your page is present and D will tell you in which word of that page your instruction is present I hope the point is clear now let's see one more question and then we will learn organization of memory management unit in the next lecture the question says the system has 4K pages and 1K frames so the number of pages are 4K so I can say these are 2^ 12 and 1K frames number of frames are number of frames are 1K if I if I can find the frame size somehow so what I will do I will multiply the number of frames into frame size to get the size of main memory which is what the physical inter space that's what is asked so I have to find the frame size somehow but I know frame size equal to page size so how can I find the page size we are given with logical address that is 32 bit so The Logical address space is 2 32 and it is divided into 2^ 12 pages so what is the page size we got 2^ 20 so we have how many frames we have 2^ 10 frames each frame of size 2^ 20 so I'll get 2^ 30 that is 1 GB is the physical address space so this is what one method is we can go from a different way also we can find the physical address Space by finding the number of bits in physical address and then we will just do like this to find the bits in the physical address we need to find the this part frame number of uh bits in frame number and number of bits in offset how can you find the number of bits in offset with the help of frame size log two log to frame size or log to page size is what the offset is I hope you are not getting confused here let me give you a simple example we got the pay size is 2^ 20 our instruction is residing in one bit of this 2 20 bits to find the address of that particular bit we require we require 20 bits we require 20 bits to give a unique number to 2 20 bytes or a unique number to each word and nothing is given so we will see the memories world uh byte addressable so what what I can say the One World equal to 1 byte 2ed to power 20 bytes are there which means each instruction or uh instruction which we want is stored in somewhere in a bite or I want a bite address to access that instruction well that's a better line I I want a bite address to access that instruction how can I find that bite address with the help of these 20 bits these 20 bits will generate 2 20 different kind of addresses that 2 20 different kind of addresses will be assigned to these many bytes in a page in a page so if I want to access a specific bite I want a 2 20 bit address so that's what this D is if you're getting confused just remember the formula when you will solve more and more problem problem then this confusion will be eradicated and you will understand the concept for now if you are getting confused remember the formula what is the formula of D log to page size or log to frame size both are same so I got 20 bits here now I have to find the number of bits in frame number how many frames are with me there are total 2^ 10 frames here so I'll require 10 bits for giving a unique number to each frame so the total number of bits in the physical address is 30 bits so what will the physical address page 2^ 30 that is 1 GB we can also do like that okay so this is what we have done now logical address logical address space consist of logical address this logical address when raised to two ra to power logical address will give you the logical address space this n is the number of pages m is the number of frames p is the page number f is the f f is the frame number D is the offset okay how are you going to find the page number you will find the page number with the help of logical address Space by Page size how are you going to find the number of bits in page number log to n how are you going to find the number of bits in the soft set log to page size how are you going to find the physical address space log to physical address bits in the physical address how are you going to find the number of frames physical address space divided by frame size how are you going to find the number of bits in a frame log 2 m how are you going to find the offset bits you can find by log to either frame size or page size both are same I hope there is no confusion now in the next lecture we will learn organization of memory management unit so we were learning the address translation and we have already studied this analogy of physical address being translated to logical address for unbiased checking so our physical that is the actual role number is being translated to some dummy number that we call logical role number for checking to be unbiased so what the management does it translate this to this but while assigning some dummy number to the actual role number they must have maintained some kind of table so that when the result come they have to when the result come they have to upload the marksheet on uh regarding this role number they are not going to upload the marksheet of this dummy RO number how is the student going to check the marks he only knows his role number so what happens they have to translate it again back to the physical role number how are we going to how are they going to translate by using this table they maintain where there is the actual role number and there is the dummy number that is assigned so using this table they do the translation work same happens in the case of memory management unit let's go to that part so in this lecture we will learn about organization of memory management unit and this is an important thing so you have to pay more focus and attention memory management unit also maintain a table known as page table but you have to remember each process has its own page table each process has its own page table I should open that uh translation diagram in some other window so there is a process this process is going to generate a logical address and this logical address will be sent to memory management unit memory management unit will maintain a page table and from the help of that page table it is going to give the physical address you know what logical address consists of it consists of page number and offset and what does physical address consist of it consist of frame number and offset so in memory management unit in page table what is written or what are the entries of the page table page table contains page table contains the frame number page table contains the frame number where that page is stored suppose if I write p 0 P1 P2 so how many entries will be in the page table the number of entries will be equal to number of pages so I will write p 0 is stored in the frame 7 P1 isor in the frame two P2 is instored in the frame three so this is what this is what page table looks like now what happens now what happens I got this logical address so I will with the help of this page number I will go to that page number in the page table and I will find that this page number is stored in which frame of the memory that frame number will be sent to this Frame number that is logical that is the physical address and this offset will be copied as it is why because frame size is equals to page size so this is how page table works so let us understand the points regarding the organization of mmu each process has its own page table page table are stored in the memory and the important thing is this whole page table which I have made here this which will contain frames and P0 to all these numbers this will be stored here in the memory this will be stored in the memory only so the page table are instored in memory page table are organized as a set of entries known as page table entries and you already know what what is in the page table entries page table entries contains the frame number in which the indexed page numbers is stored page number page table entry would look like this this is P0 P2 P3 this is how the indexed page number are stored the first entry corresponding to the page zero the second entry correspond to the page One automatically well this is not the part of page table entry you should remember that if in page table looks like this only F0 F7 fs3 then the index automatically defines see this is the index of page 0 so the index automatically defin that page0 lies in frame zero this is the index of page two so the index automatically Define the frame where this page is stored so 0 1 2 3 4 if I if it is written somewhere 22 and here it is written f17 so this is page number 22 residing in frame number 17 this is what page table looks like okay so the number of entries in the page table will be equal to number of pages it contains the frame number in which the page is present you already know this and it is denoted at as e byes so this e will be the size of one page table entries page table size equals to the E is the size of one page table entry the total page table size will be number of pages because that many entries will be there and size of each entry let me rep page table size will be equal to number of entries will be equal to number of pages multiplied by size of each entry number of entries into size of each entry this is what page table size is here's a diagram of page table these are the index representing the page number and this binary number will represent the frame numbers see if it is written in the page table entry if it is written like if if it is written like 1 1 1 and 1 one so what does this represent this represent that page number 7 is at frame number three this is the index representing the page number and the actual entry represent the frame number so how does address translation work process will generate The Logical address in logical address you already know the page number and the offset this offset will be copied as it is to the physical address and this page number where this page number is residing this corresponding to the page number five it reside in the frame first frame that is the 00 frame so this 0 will be sent here this is how we get the physical address of 12bit and that from this 12bit address I can directly access the memory so this is how translation of address from logical address to physical address Works let's have a small revision let's say we have a logical address space of 8 KB and logical address of 13 bits how we got that 3 4 8 and 10 for K so 13 bits we have logical address physical address space of 4 KB then two for 4 and 10 for K hence we got 12 bits our page size is of 1 KB so I can directly say that offset will be of 10 bits this is how it will going to look this is our logical address space of 8 KB with a page size of 1 KB so there will be eight pages P from p 0 to p7 each of size 1 KB physical address space will be of 4 KB and each frame will have a size of 1 KB so there will be four frames F0 F1 FS2 and F3 okay now let's say the process generated the address of p7 so this p7 will be existed from here this will will be translate will be sent to the memory management unit which has access to page table this page table will tell that this page that is p7 is held at which frame it is at frame Zer so 0 will be 0 0 will be at this Frame number and this offset will be copied as it is hence we get a physical address and from this physical address we are going to access the physical address space or main memory so this how it work now now let's again discuss some of the formulas page number number of pages will be logical address page divided by Page size number of bits in page number will be log to number of pages number of bits and offset will be log to page size number of frames will be physical address space upon page size number of bits in frame number will be log to number of frames number of bits in offset will be same log to page size number of bits needed to refer a word within a page so this is what offset is for and each page table entry contains what it contains the frame number so this is what e is and the size of page table will be number of entries in the page table into page table entry one entry of a one size of a one page table entry this is e and this is number of page table entries now for the one last time let's understand again how paging works then we'll move to the problems so the CPU generate this logical address which which has P and D this P will be used to look for f f will be copied here and D will be copied here in this way we get the physical address space that will be used to access the physical memory or main memory directly see this CPU generates this logical address which has page number and offset this page number this page number will be sent to this unit and it also have an output from page table based register now you may ask what is Page table based register the address in the memory where the page table is stored how CPU or the process is going to know where my uh where my page table is stored this page table base register will tell so from here they will access the page table with this page number P1 so the entry of p uh entry of the page table with index P1 will contain this Frame number frame number will be copied here object will be copied here that's how we got the physical address which is the direct access to the main memory okay in the next lecture we are going to see some of the problems the a computer system using paging technique implements an 8 KB page so the page size I got from here is 8 KB with a page table size of pts I got is 24 MB the page table entry is of 24 bits so I can say e is of three bytes what is the length of virtual address in the system we can solve this question using two methods let us let me write here so method one is you can go from like this total virtual memory equals to number of pages into size of each page or page size you can either find the size of total virtual memory like this or the method two says find the length of logical address and then what are you going to do you are going to do like this this is also virtual memory size so whichever day you prefer you can go from this so the pace size given is 8 KB 8 KB is given I can directly find that this is p size so D will be of three bits from for8 and 10 bits for uh this case so D will be log to 8 KB equals to 13 bits and what I'm what else I'm given with I'm given with page size so now page table entry page table size page table size is 24 MB and the size of each entry is three bytes so I can write number of entries into e e is 3 bytes so from here I can write B to be canceled n is 8 m = to 2^ 3 into 2^ 20 = 2^ 23 so I got number of pages or number of entries are 2^ 23 so from here I can go with method one also the number of pages I got 2^ 23 the size of each page is 2^ 13 2^ 13 so from from here I can write the total virtual memory is 2 36 what method two says here we got the value of D is 13 bits and from here there is n = to 2^ 23 this is what number of pages are so how many bits are required to uniquely address these 20 is for 23 Pages obviously 23 bits so from here I can go like the P will be 23 bits the total is 36 bit La equal to 36 bit so I can draw from like 2 power la which means 2^ 36 is the virtual memory size 2^ 36 is 2^ 6 into 2^ 30 this is GB and this is 64 so our total memory is total main memory 64 GB well that is we are talking about Ram well it's a powerful CPU or powerful computer it is a powerful Ram well the main memory is 64 GB that's a pretty good my laptop has only 16 GB and initially I remember when I was in sixth class I got my first computer and that has 2 GB Ram we used to play GTA y City uh those days nice days but nowadays computer really have like 64 GB Ram so this was the question which we have solved another easy question consider a computer system with 40 bit virtual addressing and pay size of 16 kiloby so should I solve here or should just explain here this is an easy question I should just explain here only what does it say we have a 40 bit virtual addressing which means La is of 40 bits so I can say logical address space will be of 2 power 40 bytes and a pace size of 16 Koby Pace size is of 16 kiloby 16 kilobyte so I can write 2^ 14 bytes okay if the computer system has one level page table per process and each page table entry requires 48 bit so the E is of 66 bytes the size of per process page table is now we have to uh tell the size of page table we have been asked with pts so pts will be equals to number of pages into or the number of entries into size of each entry we are given with size of each entry is six B 6 by how can I find number of pages well L ided PS what is L 2^ 40 what is PS 2^ 14 I should change the color 2^ 4/ 2^ 14 this is what I think I think 2^ 26 so the answer will be pts = to 2^ 26 into 2^ or it is 6 I think 6 bytes so the answer is 384 MB this is the page table size okay so this question can also be solved using two ways now think about it the same the similar way which we have done with in the previous question let's move to question number three it says a computer system using paging technique has a virtual address of length l so this is virtual address now I can say that logical address space will be of 2 power L the number of pages in the address space are J N is Zed there are H frames there are m is H calculate the number of bits in the page offset and the size of physical address space so we have been asked with the physical address space size and we have been asked with d how can I find D we have to find the page size so we are been given with logical address space we know the number of we know the number of pages so we can directly find page size equals to logical address space logical address space divided by number of pages that is Z 2 to power L / Z this is what the pa size is so how can I find the offset from this log 2 2^ l/ Z this is what D is now physical address space for physical address space I need to know I need to know the number of frames number of frames into frame size but luckily I know that page size and frame size are same so I found that page size is 2 power L by Z and I also know the number of frames how many frames are G I have I have H frames so the physical address space we got is H into 2^ L by Z okay now let's see what I have written virtual address is of L bits number of pages are Zed number of frames are H how are we going to find D with the help of page number so log to page number is what the offset is how are we going to find physical address space with the help of number of frames into size of frame number of frames is given H how can I find the size of frame size of frame is same as size of page so how can I find the size of Page from here I know that logical address page is 2 power L the number of pages are Z the number of page into page size will be equals to total memory total logical address space so pay size equals to 2 power L by Z so that's what I have written here 2 power L now we got H into 2 L by Z and we also got the offset that is log log 2 2 power L by Z 2's power L by consider system using simple paging technique with a logical address of 32 bits so what we have we have logical address of 32 bits 32 bits so I can say logical address space is of 2^ 32 bytes page table entry of 32 bits so I can say e is of 4 bytes what must be the page size and bytes so I've been asked with page size such that page table of process exactly fit in one frame of memory what is asked page table of the process page table of process which means page table size should be equals to frame size that's what it is written page table Pro page table of the process exactly fit in one frame of the memory so page table size equals to frame size what is frame size frame size is nothing but the page size so this is written page table size should be equals to to page size and what is Page table size number of entries or number of number of processes which be equal to number of pages into e we are given with the value of e that is 4 by now page size this is what the main cor of this problem is now we have to find the number of pages how are you going to find the number of pages see in this equation we have only one equation and two variables we can't solve like that so what we have to do we have to substitute the value of n what is the value of n that can be substituted we know the logical address space is 2^ 32 so the N can be written as 2^ 32 divided by the page size this is what n is number of pages equals to total memory or total logical space divided by the paas size so what we have got two 2^ 32 divid P size this P size is sent here it will become P size Square now I have 2^ 32 into 2^ 2 which is 2^ 34 2^ 34 now what is the P size then we have to take under root of this so paas size will be equal to 2^ 17 bytes so this is the answer okay let's move to another question it says virtual addressal to 32 bits so I can say virtual address space is 2 32 bytes page size is given 4 KB physical address space is given 64 MB now we have to find page table size page table size formula is n into e we need to First find the value of number of pages so what is the number of pages here 2^ 32 this virtual address page divided by Page size that's how we can get the number of pages so 2^ 32 divid by by what is Page size 4 KB so 2 power 12 from here we get 2^ 20 these are the number of pages but how are we going to find this page table entry without this we cannot solve uh we cannot solve for the page table size we need to find the page table entry for this we should remember what is installed in a page table entry in a page table entry in a page table entry frame number are stored in a page table entry frame numbers are stored so how are we going to find the frame numbers we see here we are given with physical address space so the physical address space divided by Page size is equals to frame number physical address space is 64 MB so 2^ 6 into 2^ 20 divided by what is p size P size is 4 KB which is 2^ 2 into 2^ 10 so this is it got it become 10 and from here it becomes 4 so 2^ 14 2^ 14 so this is the number of frames we have 2^ 14 frames so the page table entry page table entry size will be 14 bits the p t entry size will be 14 bits we can approximately say it is it is of 2 bytes because we want to find the P table size in bytes so what we we did we said that page table entri is of 14 bits see you can also find the value in bits No One Is Stopping You E equals to so the page table size and bits will be 14 into 2^ 20 well that's also an answer but it looks good when it is written in the bytes so what we have done we have changed it to two bytes so now it become 2 MB now the page table size is approximately 2 MB now let's understand the performance of of paging so the first issue which arises is timing issue you all remember that page table is stored in memory suppose this is memory where instructions and data are stored and here below page table is stored so what happens process generates The Logical address logical address to be converted into physical address we need to access the page table also which is the work of memory management unit so page table is stored where it is stored in the main memory only how much time it will take firstly it will access the page table so it will take let's say the memory access time is M so firstly it will access the page Table after page table it will get the physical address so from physical address it will access the instruction or data again so how much time it is taken M for accessing the page table and M for accessing the data or instruction so let us just read what is written here it says timing issue page table is stored in memory main memory access time let's say m and it is in Nan seconds what is M the amount of time CPU takes to read or write the word from the memory so the whenever you access main memory the time taken is M and what is the effective memory access time effective memory access time is actually 2m why 2 m firstly m is required to access the page table and then you get the address so another M will be required to access the actual memory or the thing which you actually want to access so effectively you took 2 m time okay this is what I have written here process generates virtual address virtual address first will access the main memory for getting the physical address with the help of page table and then after physical address you will get the main you will get the address where you your data or instruction is stored so you'll access the memory again first time to access the memory for page table second time to get the actual address so where this increases the execution time suppose if the virtual address if the process would have directly generated the physical address then we would have done it in just m time but this concept of paging when we introduced this the execution time increased we we want to make this 2 m close to m while still keeping the paging concept can we do this we want to make this 2m the total time taken is M plus M so what we want to do we want to make this 2 m close to M can we do this so firstly let's focus on reducing page table M this this m we will try to reduce okay so how we going to reduce we will in introduce the cach memory we will introduce the cach memory what will cash memory give us or what will cash memory bring to the table it is faster it is well it is a little bit costly it is small and it allow parallel searching so what we do we allow some entries of the page table we store in the cach memory which has a shorter excess time what we do we we follow that there are some some pages that we frequently access so what we do for those entries we maintain another table that is that is in included in the cach memory and the access time of cash memory is is faster so the time taken to access cash memory is less than the time taken to access the main memory so what this is what we have done here some entries of the page table we store in the cash memory which has a shorter exess time that is C is less than M so now what is the procedure virtual address when we generate virtual address the memory management unit will look that the generated virtual address is that page present in the cache memory if yes then it will access directly from here and then we will get the address of we'll get the physical address then it will access the m so now what is the time taken we have taken C plus M time which is surely less than m + m which is equal to 2 m so what we have done we have made time lesser than 2m but in case in case we have created a cash table or we have introduced a cash memory we the generated virtual address that page is not found in the cash memory then what we have to do we have to visit the page table again that will cost even more time than 2m are you getting the point what I want to say see first we had a timing issue what timing issue we had that when we introduced this concept of paging the effective memory exess time had become 2m so in solution we want to decrease this 2 m time close to M to do in order to do so we introduce cache memory a kind of memory which has a faster access time say if the main memory access time is M then cash memory access time will be C so I can say cash memory access time is lesser than the main memory access time so now what we have have done for that virtual address the page which we want to look for we will first look in the cach memory if found then we will directly get the physical address and we will access the main memory directly so now what is the time taken the time taken is C and M so the time taken is C plus M which is surely less than 2 m as C is less than M so I can say C+ m is less than M plus M or I can do like that c is less than m add M both s side C plus m is less than 2 m this was the main memory exess time the actual the effective exess time without the use of cach memory this was the effective exess time M plus M where m is the main memory access time C plus m is the effective exess time if it is a hit what is hit what is the meaning of hit hit is the page which we are looking is found in the cach memory that is hit so if it is a hit then the effective exess time will be C plus M what is C excess time of cash memory excess time of main memory which is less than 2 m so we have we have tried to decrease the effective ACC exess time with the help of cash memory but what happens in the case of Miss what happens we want to access that page which we do not access frequently in that case that page won't be found in the cash memory so firstly we will look in the cash memory we didn't find it then we move move to the page table there well at page table every page is stor so there we will find the actual physical address from that we access the memory so now it is even more than 2m what is the total time now time to access cach memory time time to access page table time to access the main memory this is what it cost to introduce the cash memory okay so effective access time now I can write is this way if it is hit then c+m if it is missed then C+ m+m now we call this cash memory as tlb translation look aside buffer okay so what we have done till now we have introduced cash memory cash memory is faster costly small small and it includes parallel searching so what we have done some entries of the page table that we frequently visit we store in the cach memory which has a faster access time which has a shorter access time okay so C is less than M we first check in Cache if not available we will go to the page table and cach is also known as tlb translation look as head buffer this is how it looks like CPU generates The Logical address that is of page number and offset from page number what we will do we will make first a parallel search in the cach memory as we are doing parallel search that's why we are faster so C is the time taken for searching in the cach memory let's say it is a hit which means we have find the page which we were looking for we have found the page which we have were looking for so tlb hit from here I can directly know the frame number and this offset will be copied as it is and we got our physical address so what is the time taken here time taken to access this cash memory and time taken to access the physical memory so this this is C+ M now what happens we have looked all over the cache uh memory but we do not find the page which we were looking for now what we will do we will look for the that page in the page table we we had a tlb Miss now we will search that page in the page table as you all know page table contain all the pages so we will find the frame number of that page which we were looking for from here we got the frame number from here we got the offset now we got the physical address so let's compare the time which we took firstly if it is a tlb hit then time to access cash memory time to access main memory it is C plus M if it is a tlb Miss then we will first access the cach memory to check now it is a Miss then we will move to the main memory page table we have found the page now we'll access the main memory so the time taken in both the cases the first case the tlb is C plus M the tlb misses C plus M plus M okay so use of tlb is Justified only if the heat ratio is high what is the meaning of hit ratio is high generally we find the page in the cache we are looking for if this is the case which means in most of the cases the probability of finding the page is high then the use of tlb Justified otherwise what is the harm the first harm is this tlb is very costly the second harm is it is increasing it is increasing the memory it is increasing the access time even more firstly it was 2 m now it is C + m + m in case of tlb Miss so let me speak again tlb is only Justified when the heat ratio is high okay now another thing if you have noticed the entry of tlb the entry of cach memory is different from the entry of page table in the main memory let me repeat again the entry of cach memory is different from the entry of page table in the main memory in main memory we had indexes representing the pages and in the entries we only had frame number but here we had frame frame number and page number side by side frame number and page number side by side okay so the entry of tlb is p plus F what is p page number f is frame number so log to n Pages plus log to M frames if it is a tlb his then hit then C plus M Which is less than 2 m if it is a tlb Miss then C + 2 m which is greater than 2m okay now we defined hit ratio as the name suggest hits upon total number of searches and what is Miss ratio misses upon total number of searches so I call hit ratio as X and miss miss ratio as 1 x okay hits hits plus Miss equals to total so I can now Define the effective memory access time as time taken effective memory access time when it is a hit effective memory access time when it is a miss so this is the effective memory access time using tlb paging with tlb and physical address cach if you remember we had the effective memory access time of 2m what we did we first access the page table then from page table we get the physical address and from there we access the main memory instruction data so it took M here and M here we tried to reduce this m with the help of tlb with tlb we introduced a cach concept of parallel searching and this DLB reduced the address translation time we are applying the same concept here physical address cache this cache will reduce the the final access time this is the m that we are using to access the main memory let me give you the proper explanation here let's say x is the hit ratio C1 and C2 are the cach excess time C1 belongs to tlb and C2 belongs to PC X1 is the hit ratio of tlb and X2 is the hit ratio of PC hope you remember what is hit ratio the thing which we are looking for if found in that cach that is a hit and what is hit ratio Hit Upon total hits upon total searches and what is a miss miss upon total searches and Miss plus hit this should be one okay so now we are going to see how this thing this all tlb and PSC thing work this is pi process in the CPU this generates a virtual address this is p and this is d p is the page number and D is the off set you all know D will be copied as it is in the physical address we have to we have to find the frame which contains this page number so firstly we will look in the tlb cache this will do the parallel searching and tries to search if this page number is in which frame number this page number is in which frame number if it is available here if we found that if we found the frame number then we call it as tlb hit that frame number number will be passed on here D will be copied from here here we got our physical address the case two was the page number which we are looking for is not available in tlb in that case we will first search for the tlb we first searched for the tlb we failed now we are going to page table that is tlb Miss so the total time will be C plus M that you all know and from here f it will be F will come from here D will come from here and there we got our physical address till this part we have discussed in the last lecture now comes the interesting story what we do this is our physical address this process wants to access this instruction or data so this physical address we will search the corresponding instruction and data regarding a physical address in physical address cache this physical address will be searched here this physical address will be searched here parallel searching will happen and if found then that corresponding instruction and data will be accessed to that process we call that as pacc hit but what happens this physical address was not available in the P then we will move to the main memory and from Main memory we will find the physical address and that instruction and data will be accessible to the process so that's how that's how it work let me give you a full flowchart we first tried to look in the tlb that page if it is not available then we'll move to the page table from either from tlb or from page table depending on the hit or miss we will find the frame number in which frame number or page is stored and we will find the offset directly from the virtual address here we got our physical address now we will look for this physical address in PC if it is available then that corresponding instruction or data will be accessible to the process if not we will look that physical address in the main memory and now that instruction of data will be accessible to the process that's how it worked so this was tlb hit this was tlb Miss this was PS hit this was P Miss okay now it's time to understand the effective memory exess time of this tlb and Pac the case one is we had a tlb we had a tlb hit let me write here case one tlb hit phase two and then phase two case two is tlb Miss and then phase two what does phase two contain phase two contain PSC hit and P Miss okay so we are going to write according to that so the first is hit tlb hit we find the physical address here now from here it starts the phase two it is PSA hit we found the instruction of data here PS Miss we first searched in the PSC as it was a Miss then we came to the main memory this was the case for tlb hit now what happens we had a tlb Miss we first looked in the tlb then we looked in the page table now we have got our physical address we will start looking for the instruction of data in the first we will look in the PSC let's say it is a hit then we have exist from the P only if it is a Miss we will first look in the PC then in the main memory so this is how we have tried to reduce the excess time we have tried to solve the timing issue with tlb and physical address or basically we have used the cach memory let's solve some questions consider system using paging with tlb what hit ratio is required to reduce the effective memory exess time from D to Zed using TLP assume that TLP ex time is K second so initially the time was 2m finally the time was we had a tlb hit and then the accessing of C this is for the tlb hit this is for accessing the tlb or Cache memory this is for accessing the main memory we had a tlb miss this is for accessing the tlb this is for accessing the page table this is for accessing the memory now what are we doing here we are asked with this x what should be the X such that we will reduce our effective memory exis time from D to Z initially it was D now it is Zed so from here we can find the value of M what is m m will be equal to D by2 we put the value of M we are given with the tbx system that is we are given with the value of C we put the value of C also so we have put the value of M we have put the value of C so now we will find X so from here we got X as k + z k + D minus Z into 2 byd okay so this is the this is the uh schematic view of how paging in with tlb is done CPU generates The Logical address from here we will look if it is available in the cache if yes that is a tlb hit and then here we find our frame number this D will be copied as it is if it is a tlb Miss if it is not found then we will go to the page table from here we find our frame number and D will be copied as it is this is our physical address we will access the main memory now comes the second issue that is space consumption issue you know the page table size is number of processes or I should say number of pages is not each process has a separate page table so this is number of number of pages it was a slip of time equals to number of entries okay so number of entries into size of each entry what the page table size is let's say we have a logical address of 32 bits okay and Pace size is of 4 KB so The Logical address space will be of 2^ 32 bytes n that is number of entries will be 2^ 32 divided by 2^ 12 this is 2^ 12 bytes so we have around 1 million entries and if each entry has a size of four bytes then we have a page table of 4 MB for each process we have a 4 MB page table now Suppose there are 100 process then 400 MB of main memory is just to store the page tables can you can you imagine that 400 MB of main memory just to store the page table well that's a serious concern and we need to reduce the space consumption so how are we going to reduce the page table size look at it we know that page table size is equal to n into entry this entry is fixed this entry size is fixed what we can do we can draw a relation that page table size is directly dependent on the page on the number of entries and this number of entries is direct is directly or I should say this number of entries is directly dependent to one by Page size or indirectly dependent to indirectly dependent to page size so I can say page table size is indirect ly dependent to or indirectly proportional to page size so if I say if I increase the page size then page table size will decrease why page table size will decrease because if I increase the page size then number of entries will decrease in that manner pce table size will decrease so we can reduce the pce table size by increasing the paase size we can reduce the P table size by increasing the paas size but but but there are side effects too now this is your homework to find what what are the disadvantages of increasing the page size in the last lecture we were discussing about the performance of paging we have seen the timing issue the spacing issue to solve the timing issue we tried using cach memory and to solve the spacing issue we thought of that to decrease page table size what is the formula number of entries into size of each entry we cannot change this but we can change this so how are we going to make this n small so in order to decrease the page table size we can do that by increasing the page size if page size is large then the number of pages will be less to cover the entire logical space that is very obvious but increasing the page size directly comes with a several side effects the first one is internal fragmentation if you increase the page size more internal fragmentation will occur see this example suppose I have a program of 1026 bytes and we have a pages of size 1024 bytes only so what we will do 1024 of this 1026 will be stored in page one and only two bytes will be stored in page two so you can see one22 bytes are wasted you cannot store another program here in this 1022 Byes this is completely wastage so the internal fragmentation here is 1022 bytes but let's say we decrease our page size we have a pages of size 2 bytes only so in just 513 pages with 2 bytes 2 bytes 2 bytes each we will cover the whole 1026 byte program here you can see number of pages are obviously more but internal fragmentation is zero it's completely zero we won't waste a single bite here so here we can see if we increase the page size internal fragmentation will be more and if pay size is less internal fragmentation will be less that's what I have written now the question arises if we cannot increase the pay size so much then what should be the optimal pay size so let's say we have a virtual address space of s bytes page table entry consist of e bytes and Page sizes of P bytes we are finding the optimal P optimal p means in which page table size and internal fragmentation both are minimum see if we increase the page size page table size decreases but internal fragmentation increases we want such paas size in which internal fragmentation is also minimum and Page table size is also minimum so what is will be the page table size according to this s by P will give number of pages into e will be the page table size that's what I have written here internal fragmentation happens in the last page of every process let's say p by2 goes to the waste okay so in last page of every process internal fragmentation happens see here also internal fragmentation was where it was not in the first page it was in the last page so what it is saying it is saying that internal fragmentation happens in the last page of every process we are assuming that for for the purpose of solving this we are assuming that P by 2 goes to waste okay so the total overhead is of this paging thing the total overhead is px2 that is internal fragmentation and S by P that is the pce table size we want to minimize this and how are we going to minimize this we will differentiate this space table or we will differentiate this total overhead and make it equals to zero and differentiate in respect of what which variable we want to optimize we want to optimize this page table page size so we'll differentiate with respect to page size this s e are constant and 1 by P what is the differentiation of 1x P 1X p s what is the differentiation of P this 1X 2 will remain constant it is 1 so 1 by p s e + 1X 2 and we will equate it to zero and then we will solve for p we got the value of P equal to 2 s e we got the value equals to 2 s e now if we say p by n goes to the waste here here we have written if p by2 goes to the waste that is half of the page goes to waste then the answer will be root2 SC where s is the size of virtual address space and E is the size of each entry of the page table now I say if P by n goes to the vist which means nth part of the page of last or I I should properly say this nth part of the last page of the process nth part of the last page of the process if that an part goes to the waist then the optimal page size should be root NS e where nth part is the vage S is the virtual add space and E is the past table entry size so page size indeed impacts page table size and internal fragmentation so we want such page size in which page table size is also less and internal fragmentation is also less let's start with a nice question it says we have 2^ 32 byte of address space 2^ 13 byte of page size and the page table entry has four byte each page table entry has a size of 4 byte when a process starts the page table is copied to Hardware from memory so from memory it is copied to Hardware let's denote Hardware like this at one word every 100 nond so this is the speed of transfer one word is transferred in 100 nond if each process runs for 100 milliseconds including the time to load the page table what fraction of CPU time is devoted to loading the page okay so first we will first calculate the number of pages so the number of pages will be logical address page divided by Page size this will give me I think 19 so the number of pages will be 19 2^ 19 will be the number of pages each entry has 4 byte each entry has 4 byte so I can say the total page table size will be 2^ 19 into 2^ 2 this is 2^ 21 byte this is what the page table size is so it is nothing but 2 MB 2 MB is the page table size now it says if each process runs for 100 millisecond so this will include the burst time and here it is written including the time to load the p t so the process time will be burst time plus page table load time and that is given as 100 millisecond now the question is what fraction of CPU time is devoted to loading the page well that way we can get that by load time divided by process time load time divided by or I can say total time this will give me what the percentage of CPU devoted for loading or if someone asked me what is the percentage of CPU for just the burst time not for the loading then I will write burst Time divid by process time this process time is the total time and whichever percentage is being asked that will be kept in numerator so load time divide by process time into 100 because we are were asked in percentage or what fraction you can also solve like that if you are asked with fraction that remove this this 100 but if we are writing in percentage then we can multiply with 100 okay so it says load time we have to first calculate the load time how are we going to calculate the load time we know that the page table size is 2 21 by and one word is loaded in 100 nond one word is loaded in 100 nond now what is one word where it is written the of word see here I have told you that the page table is also a part of memory and in in each page table it is divided into entries so this entry is also equal to one word see what was one word the main memory is divided into several units several equal units this is what one word was so this page T is also a part of main memory and it is also divided into some equal units which is called word so this e will be equal to one word so what is the value of e here 4 by so I can say 4 byte is transferred in 100 nond how much this page table that is 2 21 byte will take so it will take 100 ID 2^ 2 into 2^ 19 I mean it will take 2^ 19 into 100 nond so the load time is 2^ 19 into 100 nond the process time is 100 millisecond so which what will the percentage CPU load time what will the percentage CPU load time it will be 2^ 19 into 100 nond divided by 100 where this 100 came from this 100 came from here 100 and millisecond this millisecond is converted into nanc so 1 millisecond contain 10 6 NS we were given that the load time is in Nan seconds see here 2^ 2 is transferred in 100 nond so we have to convert the unit that's why we have written here 10 to 10^ 6 nond so this 100 to 100 will be canceled this 10^ 6 is kept here 2^ 9 is here see this what are we doing here this 2^ 19 is divided into two part 2^ 9 and 2^ 10 what is 2^ 10 it is 1024 but for the sake of Simplicity we are keeping it as 1,000 just for the approximation thing so this 2^ 10 can be written as 10^ 3 so from here three 6 will be converted into three now what are we left with 2^ 9 upon 10^ 3 and if we are finding it in percentage then we will multiply it with 100 also and if not then just keep this what is 2^ 9 512 what is 10^ 3 it is th000 so 512 divid 1,000 it will give 100 0152 this is the fraction of CPU time devoted for loading did you got the solution let me repeat again let me summarize again so what we had we had a question in which what happened we are given with some data and it is is asked that how much fraction of CPU time is devoted to load the page table and the process runs for 100 millisecond this process time also include the page table load time so the percentage of CPU for loading will be load Time divid by total time into 100 so we have to find the load time and process time we were given with process time that's why we kept it as it is 100 millisecond here we have to find the load time how are we going to find the load time we were given that 4 byte is transferred in 100 nond then the whole page table will be transferred in how much time so you have to first find the size of page table how can we find the size of page table we know the formula number of entries into size of each entry we were given that size of each entry was 4 by we have to find number of entries we know that number of entries is equal to number of pages how can you find number of pages we were given with page size that is 2 13 by and we were given with the logical address space that is 2^ 32 so we can write it as 2^ 19 so the number of entries are 2^ 19 and 4 byte will be multiplied and this will give me the page table size that is 2^ 21 by now 4 by is transferred in 100 n 2^ 21 bytes will be transferred in how much Nan so this will be transferred into T 19 into 100 nond so we will put the value of load time here we know the process time here but what is the problem this is given in millisecond this is given in nanc so we have to convert this millisecond into Nan so this will be 10^ 6 nond how we converted that we know that 1 second involve 1,000 millisecond and 1 second involved 10 power 9 nond so 1 millisecond will involve 10^ 6 nond okay so that was put solved but we had made a little approximation here we have written 1024 equals to 1 0 just for the sake of Simplicity this will give me 10^ 3 so from a million this 1,000 will cut a million and will leave 1,000 now we have 52 divid 1,000 so this will give me the 0.512 but if we are finding in percentage then it will be around 50% let's see an interesting question it says consider a system using paging technique with a address space of 65536 bytes you should remember this number this is 2^ 16 okay the page size in this system is 4096 bytes what is this it is 1024 into 4 the program consist of Text data and stack sections as per the specification given below so the text is of this much bite data is of this much bite and stack is of this much bite the page of a program contains portion of only one section that is either text or data or stack does the program fit in the given address space so the first approach some of you might think is we can add all of them and see whether this is equal to 65536 or not if yes uh if it is equal to or less than 3 65536 if yes then the program fit if no then the program doesn't fit well this is the worst approach to follow because we are seeing page wise a page can contain only either text or data or text suppose this is our page and it has only this much text then this page will be wasted let me repeat again to divide this into Pages let's suppose in the last page we had this much text only so this part will be wasted so by just adding these we cannot tell that this program will fit or not because the program is divided page wise and each page can contain only text data or step if it was written that a page can contain text also it can contain some part of data also and stack also which means there is no kind of restriction then I can say if I just add off all of them and compare with the 65536 so how are we going to solve this question well it is easy we will divide it into pages so for text how many page are we going to require let's see what is the what is the text bytes it is 3 2 76 8 divided by 4096 so we are going to require eight pages so eight pages for text and then 16386 divid 4096 we have got 4.4 some pages so how many page we are going to require four page and that's where you have made the mistake this data section will require the five pages don't make the don't make the mistake of approximation why is this so let me tell you so this data section has some like 4. four pages required so four complete pages will be filled three and four and the fifth one will be minutely filled with that 04 and what I have told you that a page of a program contain the portion of either text data or stack so if this page is installed with data then you cannot use this space so if I do the approximation like this this is 2^ 14 bytes and 16 KB so what I did I I set it four this is where you will make the mistake and now for the stack section 15870 divided by 496 this is 3.87 so how much pages will it require three complete pages and 87 filled page so three complete pages and 87 filled page this page will be filled and this page will be wasted so four pages required for this five pages required for this and eight pages required for this 8 and 5 13 13 and 4 17 how many pages does we have in our program divide 655 36 with 4096 these much Pages we had what is 65536 it is the address bace and what is 4096 page size so address space upon page size will give you number of pages so we had 16 pages but this program will will consume 17 pages so I can say the program does the program fit in the given address space no the space of 2^ 16 we have base size we first calculated the number of pages and we we calculated how much Pages required for Text data and stack for text 8 Pages for data for data we will require five pages for this part okay so even if you do like this if you even if you take the log in like 2^ 14 thing then you won't have a complete 14 you have 14.1 and that is going to consume another page so we cannot write it as 4 14 so this will require five pages and in the last page lots of internal fragmentation will be there so total 17 Page required but we have only 16 so we'll say no instead of 4 kiloby if P sizes of 4 byte then what would happen we are going to follow the same approach we will find the number of pages we will find the number of pages in each of the text data in stack and number of pages the address space is divided into if the sum of the number of pages in these is less than or equal to the number of pages in the address space then I'll say it will be a fit so number of pages is 2^ 16 divid 2^ 2 which is 2^ 14 so I have 1 16 384 pages in the address space now we have to find the number of pages in Text data and step how are we going to find just divide it by 4 so just divide it by 4 by so we have 8192 4097 and 3968 pages in text Data stag respectively add them all we got 16257 which is definitely less than 16384 so I'll say instead of 4 kiloby if Pace size would have been 4 byte then the program would easily fit in the previous case why the program was not able to fit because of this much internal fragmentation okay maximum some page size for program profit so what we have done here we have reduced the page size so many times but what we want we had a page size of initially we had a page size of 4 kiloby when we reduced it to 4 byte that is multiple times reduction then the page then the program easily fit onto the address space but what we want we want the minimum reduction in this page size or we want that maximum page size such that program will fit so what we have done we the total is Pages 2^ 16 bytes n which means the number of pages will be 2^ 16 divid by let's say the page size is 2^ X = to 2^ 16 x so number of pages required for text is 2^ 15 x for data is 2^ 14. that four thing x and for stack is 2^ 13.95 x so what we'll do we have tried to compare the number of pages here and some of all these Pages here so that's what it is this is the equation but the problem is we cannot solve this like that solving the X from this equation is difficult thing so what is the solution then try this this is your homework now let's learn what is hashed paging I hope you all remember what is hashing simp similar thing we are going to implement here we are going to associate a smaller page table with a process what is the purpose of hashing the purpose is to organize data in such a way that searching becomes easy each element will be associated with an index so we will design a page page table using hashing table and that will be known as hashed page table don't worry if you're not getting it let's see with an help of an example suppose I have a virtual address of 32 bits page size is of 4 KB so 2^ 32 divid 2^ 12 this give me 2^ 20 these many number of pages will be there so I have 1 million Pages number of pages in page table will be number of pages in the memory and how many pages I have 1 million pages so in page table I would have 1 million entries but let me tell you a shocking fact out of these 1 million entries process generally use around 5 to six pages only but what conventional paging says even if process use only five to six pages but you have to store this whole page table in the memory that's what it is making space inefficient suppose I have a modulo 10 function so what does modulo 10 function do it gives me the last digit of a number take the example I have 1076 I hope you know what is modulo modulo gave me the the remainder when divided by 10 for this 1076 mod 10 the answer should be 6 which is the last digit how did I got it see here divide by 10 1 10 7 comes down 6 comes here 0o and then 7 7 0 6 this is how I got the answer as six so whatever be the number the last digit will be the answer so so how many possibilities of the answer are there for last dig for last digit I can have 0 1 2 till 9 so these 10 entries are possible if I have modular 10 function let me repeat if I have modular 10 function then the result will always be the last digit for that there will be only 10 entries in my has table suppose I have 1076 and 666 what will be the modulo 10 function result it will it will give six it will give six so both want to be at the same index but what happens only one entry can be present in one index well that will lead to Collision that will cause problem i1 and I2 these numbers are different but their last digit is same so what it will lead to it will lead to Collision so what are the Collision resolution technique probing and chaining here to resolve Collision we will use chaining and chaining is implemented using linked list by hearing this by hearing link list you must have a guessed what are we going to do with the CH this Collision problem suppose I have 1076 settled at index 6 now another number comes modul 10 the answer is six want to go at this index but what happens 1076 is already there so what I will do I am going to do like this I'm going to make it as a linked list suppose now another number come let's say 56 so I will make another node of 56 so this is how I am I will solve the Collision problem see here each of the desire of each of the number is satisfied what every number wanted these this all number wanted that their index should be six now their index is six and the Collision problem is also solved so this is how hased page table will work with Collision as with chaining as the Collision resolution technique suppose process generated this P and D logical address D will be copied as it is as you know and P is the element for hash function suppose page number five and 25 are there so what will be the mod 10 result of five it is five what will the mod 25 result of mod 10 uh result of 25 it will be five only so both have five index they both want to come at index five so what I will do I will make like this node for 25 node for five node for 25 and then I will link it using a pointer so what does the node contain the node contains the page number the frame number and pointer to the next node node contain the page number what is the page number page number five the frame number where this page number is stored in the main memory and pointer to the next number the page number the frame number where it is stored in memory and the pointer to the next number so this is how it's going to work now what happens this R will be copied as it is that's what we wanted we wanted the page number let's say this is assumed let's say we wanted the frame number where this page number 25 is stored we wanted R so here we got R and D will be copied from here that's how we get our physical address and we will access the memory but now the question arises let's say I have 100 nodes here and then I had some uh I have some node whose frame number I wanted so how can I reach there you have to first visit the head node then the next node then the next node then the next node obviously the space is optimized but the time it will be time inefficient and you all know the searching time in the link list is o n Big O of n so I have to keep searching until I reach the desired node okay so instead of 1 million entries we have a hash table with 10 entries only so from 1 million entry we reach to only 10 entries and linked linked list Associated to them so we have done space optimization but as you all know space and time optimization Works in a tradeoff if we have if we make it space optimized then it will become time inefficient like we like it happened in the case of static and dynamic linking loading from 1 million entries we reach to 10 entries space is optimized but time in efficiency Has Come O N Big O N will be the search time of Link list so if we want to jump to the 1003 we cannot do it directly we have to start from head and from one node to another we have to jump until our desired entry or desired node is reached so it's a tradeoff between space and time in vum architecture that's how it works it is a tradeoff between space and time between vum architecture so time for searching i1 and I2 is different but same in traditional here let's say let's say I want a page number five so what will be the time we jumped here directly absolutely no time but let's say I want the frame number of 1025 so I have to keep jumping from here to here here to here here to until I reach 1025 so searching time for i1 is different from searching time of I2 even though they have the same index but searching time will be different as they are in the linked list but traditionally but traditionally we have all entries in the same single page table in this page table only we have all entries so searching time of five and searching time of 1025 will be same so what we have tried to solve this spacing issue we have tried increasing the page size we have tried increasing the we have tried using hashing the next important thing which we are going to try will be multilevel paging or recursive paging or hierarchial paging as the name suggest paging on a page table let us start multilevel paging hierarchial paging recursive paging paging on a page table index of an index it has so many names this is an important topic you have to focus more on it let us start with the beginning paging on a page table why we why we required paging the first thing which comes to our mind is to overcome the problem of problem of external fragmentation paging solve external fragmentation by allowing processes to be divided into fixed size Pages this virtual address space is divided into fixed size pages and these pages are stored in the main memory wherever the frame is free so continuous allocation need was eliminated so this can be stored here this can be stored here this can be stored here so these Pages can be stored wherever the frame is empty can be loaded into any available memory frames avoiding the need for continuous memory allocation and making efficient use for scattered free memory blocks so this was the first use we see of simple paging now after studying paging we did some analysis performance analysis here we saw some two issues timing issue and spacing issue in timing issue we tried to solve using cach memory we tried using tlb we tried using PS that somehow helped for spacing issue we tried using we tried by increasing the pace size but increasing the page size causes or invites internal fragmentation then we tried HED paging for HED paging we indeed reduce the space overhead but at what cost we tried using increasing page size and then H paging H paging reduced this space overhead but at the cost of search time this is our third attempt for spacing issue that is multilevel paging we try to reduce the size of page table and how are we going to do that with the help of paging on page table what is paging as a concept what is paging as a concept divide the address space now forget about virtual address space and physical address just listen to this divide the address space into fixed units store these units into main memory and access these units through Page table this was paging let me repeat divide the address space into fixed units store those into main memory and access them with the help of page table this was paging okay but what happened when we saw that for like around 100 process we had around 400 MB of main memory used up just to store the page table so we saw that size of page table is increasing very much we want to solve that spacing issue but the question arise but the question arise when do we say that the page table is small or page table is large when do we say that so this is an important line you have to remember when page table fits in one frame of the memory then we say that the size of page table is acceptable when page table size is equals to frame size or your you know frame size equals to page size so when page table size is equals to page size then I can say that the page table size is acceptable okay so here it is written paging as a concept General involve three steps divide the address space into Pages store the pages into main memory and access those pages with the help of page table this is what it is written now let's see what are we attempting here we have address of 32 bits so virtual address space of 2 32 bytes we have a page size of 4 KB so how many pages will it have it will have around 2 20 1 million Pages it will have and you know in page table the number of entries equals to the number of pages so we'll have 1 million entries you remember the fact which I have told you in the HED paging video that out of these 1 million Pages process use around five to six pages only rest are unused out of these one million Pages process use around five to six pages and rest are unused suppose p 0 P1 some PX py and PN these are the pages which process use and rest this P2 and all other pages are unused take this an example okay now what does paging say paging say divide the address space into pages so we divide the address space into address space into Pages store these pages into main memory so stored p 0 somewhere at frame 3 P1 at where is P1 is stored at frame X PX is stored at frame p and p n is stored you know mean you know what I mean so these frames are stored somewhere in the memory at different frames and to access those pages what we need we want a mapping table that is the page table so this index represent the page and the entry represent the frame in which that p is stored see here p 0 is stored in frame three p 0 is stored in frame three PX is stored in frame two PX is stored in Frame 2 that's what it represent so you know out of these 1 million Pages only five are useful let's say this p 0 P1 PX P1 and PN is useful let's say this represent code this represent data and this represent stack so similarly in the page table these five entries will be useful and rest will be and rest will be the unuseful entries so I call them as chunks the entries which are useful or these useful entries are in one chunk this one chunk this another chunk another chunk so basically what we are doing we are trying to achieve here as this logical address space was divided into Pages this page table should also be divided into Pages because we are attempting to apply paging on a page table how we applied paging on this IAL address Space by dividing into Pages similarly we are trying to attempt paging on this page table and how are we going to do that by dividing this page table into pages but instead of calling pages of the page table we call them chunks of the page table so this page table will be divided into several chunks so let's say the size of a size of one chunk is 1 kilo bir so how many chunks it will be divided 2^ 20/ 2^ 10 to power 10 so there will be around thousand chunks and out of these thousand chunks only three are useful isn't that weird to reduce the size of page table we have to apply the concept of paging on a page table and process is associated with each of the page here when we use only a single page table but what will happen if I use paging on a page table you'll understand it what step one we follow page table is divided into chunks of 1 kilow so number of chunks will be 1 but out of this only three are useful that's what we have done till now the second is store chunks into the memory we are going to store these chunks into the memory so the c0 is stored somewhere here this C1 is stored somewhere here and the C2 is stored somewhere here now what are we doing here just try to grasp that how are we going to access those chunks see we don't want to access each and every entry of this page table that's what it was to increase the page size this was responsible the process the attitude attitude of the process to associate itself with these all entries of page table that was causing the space overhead but what we want we want process to Associated associate with these chunks only we don't want process to associate with each entry of the page table we want process to associate with these chunks only because these are the useful chunks rest is the Wast stage are you getting it so what are we doing we are creating another page table which is going to store these chunks so we'll write like that zero this will now represent the chunk here what it was representing the page but now when we apply paging on a page table what it will represent the chunk so this chunk that is zero c0 is stored there at K C1 is stored there at J okay so now you think is it is it wise of process to associate itself with these chunks and not these entries because initially the space overhead was try to calculate that what was the space overhead what is space overhead the extra space which we are using to apply the concept of paging what is that ex page this page table so what is the size of this page table the size of page table which we calculated was 4 MB let's say the entry was 4 by so the size of page table was 4 MB now what are we doing we are letting the process to associate with the outer page table what is the size of outer page table number of chunks number of chunks how many chunks are there 1K the size of each chunk was to 1 kilow there were this is how we calculated the number of chunks 1 million entri is divided into chunks of size 1 kilow so this is what the number of chunks are the process will be associated with a process will be associated with page table with have 1 Kil entries plus three chunks of inner page Table Three chunks of that page table which has this 1 million entries are you getting the point what have we done we with the help of another page table we allowed the process we allowed the process to access these chunks directly not wasting time here okay so process does not have to include that the the space overhead what will process do process will access the useful thing only see what have we done here we have included the 1 million entries we don't want the process to access associate itself with 1 million entries so what are we doing we are creating another page table in which only these chunks are present so what process has to do now access or associated with this page table and these chunks of inner page table so now initially the space overhead was 4 MD Now what is the space overhead the space overhead will be let's say this size is of 4 bytes so 4 KB plus three chunks of inner P table which means 3 K into 4 so this is be 12 KB so now it is associated with just 16 KB initially it was 4 MB now it is 16 KB only are you seeing how much reduction we have made here so earlier it was associated with 1 million entry page table now we have associated with it only 1 kilow past table let's say each word is of 4 by so one 4 KB past table here let's say word of four by then 4 MB here 4 KB plus we have to also access the three chunks of inner page table so 3 K into 4B that will be 12b so now 16 KB only so from 4 MB we have reached to 16 KB I hope you can see how much space overhead we have reduced now in the next lecture we are going to see how addressing will be done let us understand how multilevel paging actually helps us suppose this is our process in the CPU being executed it generates an address page number and in that page number which word to access this D will tell us so this is our virtual address space and it has it has been divided into various Pages this is p 0 this is P1 p 0 P1 okay now what happens this virtual address space this virtual address space cannot be stored in the one frame of the main memory this virtual address space is greater than the frame size of main memory as we all know that frame size equals to page size and this virtual address space contain lots of pages around we saw that it contained around 1 million pages so virtual address space is around 1 million times greater than the frame size we cannot store the whole virtual address space or the whole process we cannot store the whole process into main memory listen to this words these words we cannot store the whole process into main memory what we do we only store the important pages in The Frames this is our page table and this is the main memory it only contains some of the important pages of this virtual address space so what happens this page table will contain the entry so this p 0 index0 let's say it stored in some frame X so at this Frame at this Frame let's say this is the frame number X at this Frame p 0 will be stored so from here I got the frame number from here I got the frame number and this D will be copied as it is that's how I got our physical address and from physical address I can access the main memory that's how paging actually works but what paging is actually meant for so that if the virtual address space is million time greater than the frame size I cannot store the whole process in just one frame of the memory that's why we included that's why we introduced this paging such that we have to include only the important pages in The Frames we have to include only the important pages in The Frames so this page table will contain the entries of those important Pages only which are present in the main M let's say frame X frame Y and frame Zed this x y z contains the important Pages p 0 P1 and P2 rest all are not important this p 0 P1 and P2 these are important and rest all are not important so what will happen this page table will contain the entries of all the pages this page table will contain the see we had 1 million pages so this page table will contain 1 million entries if if the page is not stored in the frame then what will be present here some invalid information or some invalid frame number or whatever be the present but this this entry won't be empty some some in or some different information be written but this will consume space initially we were dealing with this initially let's say we had 2^ 32 bytes of virtual add space so we had initially this much weight on us but what now happened we have to access this page table and only the useful chunks of these virtual address space in the memory listen in main memory main memory is a critical memory we do not store unuseful or wastage in the main memory we store only the useful parts of the program in the main memory but this virtual address space was very large we cannot store this virtual address space in a one frame that's why we introduced paging with the help of page table I have to the process will be associated with each entry of the page table and let me write this the process will be associated with associated with two things the first whole page table and second is useful entries of useful entries which were actually present in main memory so the useful entries and the whole page table this is what process will be associated with okay now we understand what paging is now the similar problem which we had with virtual address space that we cannot store the whole process into the main memory we have to break it into pages and then we have to store the similar problem arised with this page table now I cannot store this page table into the frame of the main memory this page table size has become greater than the frame size so what we want to do we will apply the same concept here we will apply paging here now in this page table I had 1 million entries and out of these 1 million entries you know only some of the entries were useful and rest all of the entries were wastage and you also know that page table is stored in the main memory you also know that page table is stored in the main memory I don't want to store this Scrappy or wasteful information in the main memory that's why we are help taking the help of another page table so this page table this page table as we did with the virtual address space we divided into the pages so what we going to do we are going to divide this page table into chunks and the index represented the page number here the index represented the page number here what will this index represent this index will represent the chunk number here so I divided the page table into chunks let's say the chunk zero is stored the chunk zero is stored in some frame of the main memory let's say frame a this was a chunk one is stored in some frame of the main memory let's say B so or useful information was stored in these two chunks only and rest was wastage so the whole area this whole uh this whole entries of the uh second level page table this is the this was the first one this is let's say let's call this as the inner page table and we will call it as the outer page table so this whole area of the outer page table doesn't contain any information it will contain the invalid bit as it was in the case of page table when the page which was not useful in the which was the the case the page which was not useful for that case we stored invalid bit or invalid information here same thing we are going to apply here we will store some invalid information or invalid frame number here but this will but this will take the space now what happens we will associate the process now the process now will be associated with whole Outer page table whole Outer page table and the useful information of inner page table initially when we had a single level paging then the process was associated with this page table and the useful information of main memory now what happened when we had an another level of paging now the process will be associated with this full page table and the useful information of this page table and that's how we actually reduced the space overhead now let's move to the PDF let me open the PDF so this is what we have seen now when we have done the outer level uh we have done the two level paging then the process will be associated with outer page table the complete outer page table and the important information of inner page table which was the three chunks of inner page table these three chunks of the inner page table which were useful only that will be Associated initially we had a 4 MB initially we had a 4 MB of page table this was our space over but as we did the As we did the outer level paging or as we did the uh two level paging now what happened the process will be associated with outer page table it contains 4 1K entries each of four bytes so we have 4 KB and three chunks of inner page Table Three chunks of inner page table chunk one chunk two and chunk three and each chunk has a size of 1 Kil word each chunk has a size of 1 kilow Word and one word is of four 4 byte so total 12 KB so from 12 KB here and 4 KB here I got 16 KB so initially I had 4 MB of space overhead but now I have reduced this page to 16 KB what was the frame size remember the frame size the frame size was 4 KB only the frame size was 4 KB only and the page table size was 4 MB can I store a 4 KB 4 MB part in 4 KB that is impossible that's why we have to reduce this we have to we we want a page table which is of 4 KB size from here I got a page table which is a size of 4 KB so 1K entries with 4 by each so 4 KB is the size of page table now now I can store this page table into a single frame of main memory okay you got the point why we did paging because we cannot store the whole process into main memory only important part can be stored the whole process cannot be stored in the one frame of the main memory that's why we introduced a page table because that page table can be fit into one frame of the main memory but what happened unfortunately the page table size was so big that that we were not able to fit that page table also in the one frame of the main memory now what we did we did paging again we got another page table somehow luckily we were able to fit that new page table into one frame of the main memory that's where our mission was accomplished so what is the punch line that you have to remember the page table should be fit into a single frame of the main memory or the page table size should be equal to the page size okay in the next lecture we will see how addressing is done okay I I felt the need that this needs more clarification or this needs more explanation that's why I made another video now let's understand how addressing Works initially when we had only single page table we used to divide The Logical address into two parts one had a page number one part was the page number and other was the offset but but now we have two level paging so what we are going to divide now we are going to divide this page number into two let's say P1 and D1 that's how we are going to perform the addressing we had 32 bits of logical address 4 KB of page size so from page size I got 12 here and from for page number I had 1 million pages so from 1 million I will have 1 million page number and for that 1 mil in page number I would require 20 bits that's how I got 20 and 12 here okay these were the number of pages equal to number of entries in the inner page table so we applied paging on logical address and we got we got it divided into two parts page number and Page size this was a log to number of pages and this was log two page size now we applied paging on a page table so we need to divide this P so this P will be divided on P1 that is number of chunks and this D1 will be the chunk size as it was here this was number of pages and Page size this will be number of chunks and chunk size so this P will be divided into two parts P1 and D1 okay now comes the important part number of entries in inner page table were equal to number of pages in logical address space so number of entries in outer page table will be equal to number of chunks in the inner page table so how many entries in the outer page table will be equal to the number of entries in the outer page table if I do log two of number of entries that is number of chunks then I will get my P1 then I'll get my P1 so number of entries this p is the number of entries in the inner page table this P1 is the number of chunks of inner page table or entries in the outer page table and this D1 was the chunk size and this D was the page size this D1 was related to the chunk size and this D was related to the page size okay so number of chunks uh number of entries in a chunk so this is related to the number of entries in the chunk is Rel to the chunk size okay so let me repeat again what we did initially when we had a single level paging then we divided the logical address page into two parts page number and offset now we had multilevel paging now we have paging on a page table so we'll divide the page number previously we divide The Logical address now we'll divide the page number page number in two parts number of entries in the outer page table and the size of a chunk or chunk size and this will be the page size so this is how we did we divided the page number into two parts P1 and D1 and if we did this third level page table third level paging firstly one level paging divided into two page number and offset second level paging div this page number will be divided into two number of entries in the outer page table and chunk size if done the third level paging then number of entries in the outer to Outer page table which means the third page table and the chunk size of the outer page table we did paging because logical address page was too big to fit in one frame of the main memory but inner page table can easily fit in one frame of the main memory when inner page table became too big to fit in the one frame of the main memory we did paging creating outer page table which can easily fit into one frame of the main memory let me repeat again this will clarify the this will clarify the purpose of paging we did paging because logical address page was too big to fit in one frame of the main memory but inner page table can easily fit in one frame of the main memory but what happened when inner page table become too big 2 F in one frame of the memory we did paging on inner page table creating outer page table which can easily fit in one of the main memory this is the Crux of two level paging this is how it looks like now CPU generates this kind of address P1 D1 and D suppose P1 is 10 D1 is 10 total 20 and this D okay now what happened this P1 this P1 will give me this P1 will give me the chunk address this P1 will give me the chunk address from here I will get the chunk address I will reach to that chunk this D1 will tell me to which page to look for in that chunk focus on this line a page contain number of words and a chunk contain number of pages so this D tells me in in that page in this D tells me which word to look for in a page and this D1 tells me which page to look for in a chunk and this P1 tells me where to find that chunk okay so from P1 I got the address of the chunk I reached to that Chunk on that chunk with the help of D I found that page and from that page I found the frame number I copied the frame number here I copied the D here that's how I got the physical address space okay so this B is the address of one chunk of the inner page table let me repeat again it generated address this address consist of three parts P1 D1 and D firstly we need to see we want the frame number what we actually want the frame number in that frame our instruction is present so how are we going to find that instruction in the frame with the help of this D but firstly we have to reach to that frame how are we going to reach to that frame firstly we will look for that chunk which contain our frame after we have found the address of that Chunk we will look for that page which contain our frame we found the frame sent here and with the help of this D we will find that in which word of that frame our instruction or data is present I hope now the thing is clear P1 is the address of chunk of inner page table D1 is the address of frame of main memory and D is the address of data or instruction in the frame okay that's how multilevel paging works I have put lots of effort lots of retakes I hope you like it let's see these views of multilevel paging we had outer page table inner page table and memory in the last lecture we learned how logical addresses were generated okay so the outer level page table contains the frame where the chunks are stored the inner level page table contains the frame where the pages are restored okay and memory itself contains the frames now how logical address will be worked how how are we going to work with logical address this P1 will help us to reach the required chunk this D2 will help us to reach the required page in that chunk and this D will do this D will help us to reach the required word which contain our instructional data so from P1 we access the outer page table this is the frame where the chunk is stored we got to that frame now we had D2 now we have to reach to that page in the frame so we'll reach to that page here we got our page this is the actual frame this is the actual frame where instruction of data is St but it contains lot of word so in which world I have to look for this D will tell so I have to look at this one okay P will help us to read the chunk re reach to the chunk D will help us to reach to that page and this another D will help us to reach to the required word in the frame see this CPU generates this kind of logical address this page table base register will give me the address of outer page table as you know that outer page table is also stored in the memory all kind of page tables are stored in the memory so where I have to look for that page table this ptbr will give you page table based register it gives the index of outer page table so from here I got the index of outer page table from this 10 bit I got the address of that chunk where my required page is there so I reached to that page now this 10 bit will help me to search for that page in the chunk so I reach to that page in the chunk here I got the frame number where that page is stored so I I will copy the frame number here in the physical address and this will be copied here so now I got the complete physical address so from here I will go to directly to that word where my instruction of dat I okay see this multilevel page table what does it depicts it depicts that process is not using all the pages and we have to store only useful entries okay so now we have completely understood how multi level paging works so paging generally involves three step dividing the address page into Pages storing the pages into frames accessing the pages through Page table this is the paging as a concept what was the motive behind the paging we want to optimize space sacrificing time as you know that in volum architecture space and time works in a tradeoff if we are optimizing space we will be sacrificing time and if we are optimizing time we will be sacrificing space now time for the effective memory access time in one level paging we had 1 M for accessing the page table and 1 M for accessing the memory in two level paging we had 1 M for accessing the outer page table 1 M for accessing the inner page table and 1 m in accessing the memory as you know this outer page table inner page table both are stored in memory so M will be the time for both okay so in one level we need 2 m in two level we need 3 m so in N level we are going to need n+ 1 M so this is the effective memory ex Sy time now the question arises can we reduce them can we reduce this effective memory access time let's try with the help of tlb and Pac in two level so here is the CPU it generates this address so firstly we will look in the tlb with the help of this P that this page number is contained in which frame number if I get this this is a tlb hit I directly get the frame number this D will be copied here I will reach now I have physical address so from this physical address I'll first look at the PSC so corresponding to a physical address can I get my instruction of data if yes then this is a PSC hit you will get your instruction and data if no then you have to search in the physical address space now what about tlb Miss what happens we when we have to actually search in the page tables so firstly with the help of this P1 we will look in the outer page table we got the address of that chunk now x with the help of this D1 we will reach to that frame now this Frame will be copied here and this D will be copied here here I got the physical address now again the same thing either I will get PC hit so corresponding to that P physical address is that present in the PSC if yes then it is a PS I will get the instruction of data directly otherwise I have to search in the physical address space okay so this was a twole paging with tlb and Pac now let's see the effective memory access time were we able to reduce them let's say the main memory access time is M tlb access time is C1 tlb hit ratio is X1 PC access time is C2 P hit ratio is X2 now we have to find the effective memor system so we'll again take two cases the first case was we had a tlb hit the second case was we had a tlb miss so here I got our physical address X1 C1 1 X1 C1 + 2 m here I got our physical address after that this phase two part will come this will be same in both the cases initially I looked in the PC I got a hit X2 C2 will be the time taken but if I had a Miss then 1 X2 C2 + m why C2 plus M because first I looked in the PC then M same case here first I look then tlb and then in the page tables here X2 I got a hit I as I looked in the PC but here it was a miss so first I looked in the PC then in the main memory so that's how we calculated the effective memory effective memory access time in the next lecture we will some of we will see some numericals physical address space 256 M be given logical address space 4GB frame size 4 KB page table entry 2X we have to apply the concept of paging here we were given that logical address space is 4GB and we can see that the frame size is much smaller than the logical address space we cannot fit the whole process into a single frame that's why we have to apply paging here so we applied paging we divided this logical address page into several pages and stored each page in a frame that's what we thought of so we divide The Logical address logical address space into different pages each of size 4 KB so how many pages were there 1 million pages so we have to access those pages with the help of page table 1 million pages so we have how many entries in the page table 1 million entries what is the size of each entry two bytes so 1 million into 2 by will be 2 MB but another problem arised here what that 2 MB is again greater than frame size we have to do paging again so we applied level two paging we used another page table for the inner page table so divide we divided the inner page table into chunks we divided the inner page table into chunks and we want to store that chunk into 4 KB that is the frame size so what we did we took the chunk size as 4 KB see it is not necessary that you took the chunk size equal to frame size or page size it is not necessary chunk size can be different to frame size but here what we want we want to apply the concept of paging we want to store that chunk into one frame of the memory so we said that chunk size Let It Be 4 KB so this 2 MB this was the 2 MB page table divided into units we call them at chunks each of size 4 KB so how many entries will be there 2 mb/ 4 KB we will have 512 entries which is 2^ 9 entries so so we had 2^ 9 entries now we have to find the size of Entry of outer level page table see this e will remain independent of the level of paging what does this e represent it is the frame this the entry of the page table represent the frame in which either the page is stored or chunk is stored depending on which T page table we are talking about this e will represent the frame in which page is stored when we are talking about inner page table this e will represent the frame in which chunk is stored when we are talking about outer page table so this e will represent what basically it will represent the frame so how many or what will be the size of e will depends upon the number of frames in the main memory and the number of frames in the main memory is independent of the level of paging that we are applying so this e will remain same we will have 2K 2B only here so number of entries is 512 each entry is a size of 2 by so we will have 1 KB now you can see we can store that outer level page table into one frame of the main memory the one frame size is 4 KB and the outer level page size is 1 KB yes we can store we can store that outer level page into a single frame no need to apply more paging here okay now we learn how addressing will be done so we have let me erase all this extra part we have data or instruction in some word in the physical address space how are we going to access the address of that word firstly we will firstly we will go to the outer level page table to access the chunk see word lots of word are there in a page lots of pages are there in a chunk so we will first find the frame in which our chunk is stored we will find the frame in which our chunk is stored so how can I find the frame with the help of outer level page table how many entries we have in the outer level page table we have 512 entri so nine bits will be required to reach to that chunk after that we have to reach to the required page how many entries are there in the inner level page table we have 1 million entries but but these entries are divided into chunks so we have with with the help of this n bit we have reached to that chunk which contain our page okay now in that Chunk we have to find the page see this was our chunk it has several Pages this page we want to access so we have to first find how many entries are there in a chunk in a single chunk how many entries are there how are we going to uh solve that how many entries are there in a chunk see what is a chunk size the chunk size is 4 KB and what is the entry size the entry size is 2 by how many entries can be fit in this Chunk in this chunk two which which means 2^ 11 bytes so how many entries can be there oh not bytes by is canceled so twoed to 11 entries how many bits are required to reach that page 11 bits will be required to reach to that page now we have reached to that page which contain our word this is our page and it contains several words suppose I want this word to access how I'm how I'm going to access that word with the help of with the help of page offset so log to page size what is Page size 4 GB so I require 12 bit to access the word okay so this is how we did the addressing in this question see here we had an outer level page table the outer level page table index will represent the chunk number the entry will represent the frame in which that chunk is stored with the help of that we reach to that chunk now we want to find that page in the junk how are we going to find with the help of D1 what does D1 represent log two number of entries in the chunk how can we find number of entries what is chunk size chunk size is 4 KB what is the size of each entry it is two white so I can find the number of entries with the help of this so I got 2 power 11 entries in the chunk so to reach that page I will need 11 bit so 9 bit and 11 bit now I have reach to that frame or that page with the help of this 9 and 11 bit I have reached to that frame which contain my page these 12 bits that is the page offset will help me to reach to that word which contain my data instraction so this is how addressing is done 20 this was the 20 how I got 20 I had 1 million entries in the virtual address Space 1 million pages in the virtual address space that's why I got 1 million entries in the page table that's how I got this 20 here now this we have applied paging on that page table so you have to find number of chunks in the page table we got 512 chunks so number of chunks in the page table equal to number of entries in the outer page table we got 52 so 9 bits will be required now after we re reach to that junk we have to find the page which contain our word so to reach that word to reach that page we have to find the number of entries in the one chunk so we had 2^ 11 entries in one chunk so we will require 11 bits for that now we have reached to that frame we from here we got our frame number which has my page which has my page that contain that word which has my instruction so till here I have reached so from here I got the frame number and this D will be copied here so I got the physical address of that word which contain my instructional data okay let's see some more questions it says in the context of operating system which of the following statement are correct with respect to paging paging page size has no impact of internal fragmentation well this is completely false we have seen that when we increase the page size it invites internal fragmentation paging helps solve the issue of external fragmentation absolutely correct paging incurs memory overhead yes paging incurs memory overhead what is memory overhead this is the same as space overhead then what is space overhead space overhead is the extra space which we consumed to convert logical address into physical address what extra space is we did we consume we consume page tables so paging incurs memory over it yes multilevel paging is necessary to support pages of different size well we did not talk about this we only talked that multilevel paging why we use multi level paging to optimize overheads H Eads to optimize overheads so this will be the correct this will be the correct these two are false another question consider a system using two level paging architecture the top level the top level nine bits of the virtual address are used to index to the outer page table the next seven bits of the address are used to index into the next trevel page table the size of virtual address is 28 bits okay well this is an easy question how large are pages and how many there are in the virtual address space so easy see here we were given with two level paging architectures the top level nine bits of the virtual address are used to index the outer page table which means 9 bit is P1 the next bits of the seven used to index the next l so D1 is 7 the size of virtual address is 28 bit so P1 + d1+ D = to 28 how large are the pages and how many are there well firstly we have to find the page size how can I find the page size with the help of this D so D will be equals to this is 9 this is 9 this is 7 so 9 + 7 16 D = to 28 16 which is 12 so my page size is 2 12 which is 2^ 2 into 2^ 10 which is 4 KB this is my page size and how many pages are there I can find with the help of this P1 + D1 equals to P if you remember and what is this p 2 power P will give me the number of pages so I have how many pages I have 2^ 16 Pages 2^ 16 pages and Page size is this second question if page table entry both level is 32 bits in size which mean we have we have four byte of page table entry then what is the space overhead needed to translate what is space overhead the size of page tables only so to convert The Logical address to physical address how much space is needed size of outer pH table size of inner pH table what is the entry of outer pH Table 2^ 9 here I got and inner P table 2^ 7 and size of each entry is 4X 4 by add them this will be your space over it now the question is is p size equal to chunk size well that is not necessary chunk size can be different but pce size should be equal to frame size that is necessary let me write pce size should be equal to frame size not necessarily equal to chunk size is Page table entry same for outer page table and inner page table page table entry will be same for any level of paging because page table entry does not depend upon the level of paging it depends upon the frames in the main memory so yes it will be same consider a computer system using three level paging architecture now we have three levels outer page table middle page table let let us call with this and inner page table with uniform size at all levels of paging so here it is given that chunk size equals to page size equals to frame size here it is given okay so we call we call the units of virtual address space at Pages we calls the units of inner page page table at as chunks let us call the units of middle page table again at like Pages only I can't think of some another name another cool name so let us keep it simple and call it as page only page of middle page table okay the size of virtual address is 46 bit so we have a virtual address space of 2^ 46 bytes page table entries at all level is 4 by so we have equals to 4 by what must be the page size in bytes such that the outer page table exactly fits in one frame of the memory so what we have to do we have to find the page table size of outer page table and should be equal to frame size or page size assume that pay size is in power of two in bytes okay so let's say the pay size is 2 power 2 power D show the virtual address format indicating the number of bits required to access the three levels okay so we will solve it we had three level paging architecture so the virtual address is 46 bits virtual address will now be divided into how many parts 1 2 3 4 four parts now it will be divided when we had a single level paging then it was divided into two parts two level paging divided into three parts three level paging it will be divided into four parts this P2 this P2 will depict the number of entries in outer page table this D2 will depicts the number of entries in one page of middle level page table this and this D1 will depict number of entries in one chunk and this D will depict the number of words in a page did you get the point see now the process will be associated with outer page table and chunk of or the page of middle level page table and chunk of outer level page table useful pages of mid middle level page table and useful chunks of inner level page table so what we have to show we have to find the page size such that the number of entries in outer level page table into e should be equal to page size this is what we have to prove and given that page size equal to chunk size equal to page of outer page table so I can write D equal to D1 = to D2 okay it is given here okay uniform pay SI at all level of P page size in bites outer page table size should be equal to frame size so number of entries in the outer page table is I should write 2 power P2 and 4B here which is the size of each entry and it should be equal to page size that is 2 power D now let's see how are we going to solve this so this this was the page table one each entry is of 4 by and number of entries in the in inner level page table will be 2^ 46 that is virtual address space upon page size let us call that page size is X so 2 power x is the page size and this is the virtual address space this will give me the number of pages and the number of entries so how many entries we have take this up for 2^ 46 x so I have these many entries in the inner level base table now we have divided into chunks we have divided this space table into chunks and what is the chunk size again 2^ X so how many entries we will have in the page table two the size of total page table divided by the chunk size how many entries we had 2^ 46 divided by 2^ 46 divided by that is the number of entries divided by the page size okay so and this will give me this will give me the number of entries in the page table two and this will be the 4 by that is the page size now we got the page table size of page table two now we will divide this page table again into pages so we will write this here and it will be divided again with 2^ X this will give me the number of entries in the outer page table and this will give me the with multiplying with four by will give me the size of outer page table now we have found that size of outer page table should be equal to the page size so from here I can solve that xal to 13 so my page size will be 2^ 13 which is 8 KB don't worry if you didn't get it I'm going to tell it again I'm going to explain it again what we did we have to find the number of entries in the inner page table how can we find we had logical address space of 2^ 46 and the pay size is 2^ X so I have found the number of entries is 2^ 46 x I have divided these entries into chunks so I have divided these ENT is into chunks of size 2^ X so this is the number of entry in this page table two and this is the 4 by that is number of entry into size of each entry this is this total is the size of page table two now we have to find the size of page table 3 we we will divide it with 2^ X so this was the size of page table 2 divided with 2 power x now this will give me the number of entries in the outer page table and number of entries in the outer page table when multiplied with the size of each entry in the outer page table will give me the size of outer page table from here I got the size of outer page table this is the size of outer face table and in the question it is given that I have to equate with at one frame of the memory I have to equate that with the one frame of the memory and you know that one frame of the memory equal to frame size equal to page size so I equated with the page size and I got x = 13 so my pay size is 2^ 13 that is 88 KV so let us generalize to solve thing quickly we have a virtual address space of 2^ s bytes virtual address s bytes let's see e is of 2^ C bytes okay this is the what is this size of each ENT page size is 2^ X levels of paging is L we are going to generalize the thing so if it is asked the size of outer page table how are we going to solve we have to first we have to first find the number of entries in the inner level page table so n equals to Virtual address space upon page size so we got the number of entries in the inner page table into size of each entry so we got the size of table 1 is 2^ s + C x now what we have to do we have to find the number of entries in the outer page table so what are we going to do we are going to divide that again with 2 power x so what we have got number of entries in the outer page table into the size of each entry here we got so at L level the size of page table will be S + lcus LX if you are wondering how I got to this see here at level two what I got I got two here so at level L I will have L here so the size of outer page table at level L will be this okay let's solve another question we have virtual address of 46 bits so virtual address space will be of 2 46 bytes we have page table entry of 4 by we have page size of 2 power x we have three level of paging and outer level page table should be equal to page size are we attempting the same question with this formula are we trying to attempt the same question with this formula I think so yes it is also 46 and we have we have 32 bit in 4X but I think we are going to attempt the same question with this formula so what does method one says method one says this will give me the size of first level page table this will give me the number of entries in the second level page table this will give me the number of entries in the third level page table so P size has remained constant which means D = to x what is D well this is so P1 + P2 + P3 let's equals to Y because as P size is constant so number of entries will also be same so I will write 3 y for that y y y and x for this so 3 y + x = 46 so the outer page table should be equal to the page size so I will write 2^ Y into 4 by that should be equal to the PA size so I will write 2^ X = to 2^ Y into 2^ 2 so from here I will get 2^ x = 2^ y + 2 from here I got X = y + 2 so I will put that here in this equation so 3 y + what is x y + 2 3 y + y + 2 = 46 from here I got y = 11 and x = 13 that's what we have got here by solving through this we get the same answer that's an easy part or we have solved it with the help of equations here we have solved it with the help of logic how we moved from one p to another and then in the end we equated that with the page size okay consider a computer system with 57 bit virtual addressing so we have the virtual address of 57 bit using multilevel Tre structured page table with L levels for virtual to physical address translation so we have L levels of paging the page size is 4 KB and Page table entries of 8 by so we have e equal to 8 by and pay size is of 4 KB which means 12 bits for D the value of L is so we have to find the value of L so we can find by this part the size of outermost Bas table what was that S Plus lc LX should be equal to frame size and do we know the value of c and x yes we know the value of c c is 3 and X is 12 this can be written as 2^ 3 so from here I got c as 3 and X is 12 so by solving this I got L = to 5 so it we need five level of paging see remembering formulas is indeed going to help you to save time in the exam method 2 we had 45 and 12 see total was 57 from this page size we got 12 so 45 we got from here now page size we are given with 4 KB page table entries of 8 by number of entries that can be stored in one page will be number of entries that can be stored in one page will be total the page size divide by the size of each entry that is 2^ 9 and from here I can tell every page table will have 2^ 9 entries so nine bits to access so this will be uh 9 bit to xes each so how many levels will be there five to get it 45 see here this was really nice concept we were able to solve using this we were able to solve the problem with the help of this logic that we started with the page table we started with the page table size and then we moved it divided it into chunks multiplied it with the each entry and then find the size of another page table again divided it with the page size find the total number of entries again multiplied with the size of each entry got the size again and then equated with the page size got the answer that was the thing which we have do but now what we have done the first method which we used was we created a formula that the size of outer level page table is equal to S Plus LC minus LX where C is the C is the this word and this is the size of each entry so if we have eight by then C will become three and what is X x is the page size so the size of outer level page entry should be equal to the page size so we have to solve this s + L C X should be equal to X just solve this and you'll get the answer okay the another thing which we are doing is it is said that the page size is constant if page size is constant which means these entries will be same if these entries will be same I can name it as y y y and let us name it as X so 3 y + x should be equal to 46 that I know and another thing which I know is outer page table should be equal to page size so outer page table is outer page table is this 2 to^ y this is the size this is the outer page table so 2^ Y into what is the size of each entry we are given with 4 byes so 2^ 2 this should be equal to the base size we write is 2^ X so 2^ X should be equal to 2^ y + 2 here we got x = y + 2 we used it here and we find that y = to 11 which means each page table will have 2^ 11 entries in it so X = to 13 I got from here if Y is 11 then 11 into 3 is 33 x 46 from here I got x = 13 what is X now 2^ X will give me the page size that is 2^ 13 8 K will be the my base size that's how I solved so I solved this question using two methods again the first was the formula the second was that we know that page size is constant so how many how many levels of paging will require to consume this 45 bit of Address given that given that number of entries that can be stored in one page is 2^ 9 so each page table has power 9 entries so 9 + 9 + 9 plus how many times to get or to cover this 45 each page table has how many entries to rest power 9 so I will require nine bit for one page table how many entries I have to put so that I can cover 45 I have to put five entries so how many levels of page paging I will have five levels of paging so I hope with the help of this you may have understood how multi Lev ping works we have learned about paging in our previous lectures but there is a problem with paging that need to be discussed that is paging does not preserve the users view of memory location now what does this users view means the users view means see like this suppose I have a main program I have a main function of of 5 KB in a program I have a main function of 5 KB and the page size is of 1 KB now this main function will be distributed in five pages and these five pages can be stored anywhere in the memory wherever the frame is free so a single function is distributed all over the memory don't you find it weird a single main function a single main function is distributed in all over the frames in the memory because noncontiguous allocation is allowed in so a single function is distributed all over the memory that's why this users view of memory location is not preserved now what is users view see this main function in one segment we create a segment square root function in one segment so in users View program is divided into units called segment and by the time you have guessed that segment need not to be equal suppose main function is bigger than the square root function so this segment will be bigger than the segment one so this program is divided into units called segments this may include functions blocks procedure call data structure these segments are assumed to be stored at their entirely noncontiguous locations in the memory well we did the same with paging isn't it the pages were stored at noncontiguous locations then what is the difference between paging and segmentation in segmentation also we store the segments at different location we can wherever the wherever there is free space you can store a segment there see here we store segment zero here segment 3 segment 2 4 segment and segment one down there we can store wherever the the free spaces non continuous allocation is allowed then what is the difference between paging and segmentation in segmentation no matter how big this main function is you have to store this at one place but what happened in paging this main function was distributed all over the memory but here this main function no matter how big it is it will be stored at a single location now the question arise if this main function is bigger than the frame of the memory then what will happen the answer is there is no concept of frames in this segmentation physical memory was divided into frames in which case when we studied about paging and paging was related to fixed allocation here we have a kind of variable allocation for segment one for segment one we will allow some memory here free space is there for Segment zero we we allow fragment zero here for segment one there for Segment two there three four there so there is no concept of frames in the physical memory in segmentation we talk about variable partitioning here variable partitioning I hope you remember what is variable partitioning we create partitions based on the segment size okay so concept is similar to paging but Pages were of same size and segment is of different size the whole segment is in one place on the memory but segments are at noncontiguous location this view was not preserved by paging so the same example here we have taken main function of 5 KB page size of 1 KB then main function itself will be distributed noncontinuously but in segmentation no matter how big the segment this we will store entirely at one location and there is no concept of frames in segmentation wherever free hole is present store the segment it's like variable partitioning so there we had page tables here we'll have segment tables so the number of entries in segment table will be equal to number of segment now the question arises how are we going to do the addressing so this the entries in the page table was like that the index used to represent the page number and entry is used to represent that frame where the page where that page is stored here The Logical address will be generated like this segment number and offset segment number and offset and the entry will be of two Fields limit and base this limit will tell the size and the base will tell the starting address okay so this segment number will tell me in which segment I have to look and this offset will tell me how out of these let's say there are the sizes of thousand so out of these thousand word which word do you want to read and from this I can tell that offset must be less than 1,000 suppose The Base address is 1400 and the size is of 1,000 so from 1400 to, 1400 to 2400 no because Zer is included here so 2 3 99 so till this I can can access the words but what happened suppose my suppose the address generated was of 2699 can it be possible no because we have the address should be in the range of, 1400 to 2399 and the offset out of these thousand word in which word you have to look I cannot write or I cannot uh write offset as500 or some like 1100 because because we have only thousand work words to look for out of these thousand words we have to choose one so offset will tell out of these thousand word which word do you want to read okay and the address should be in this range okay so how are we going to check if address in this range and what will happen if address is not in this range it will go into the Trap suppose if process is mischievous and he and she tries to access the word beyond the segment then it will go into the Trap or addressing error will be generated so from this segment number I will reach to that segment okay now here we will check that if offset is less than the limit or not the limit was of th000 words the offet should be less than or equal to th000 and if it is not then we will send it to the addressing error or trap if yes if the offset is in allowed range then add the offset into the base or I add the offset into the base and then you will get the physical address let me show with the help of diagram suppose this was the segment and in that segment we want to access this word this was our base let's say the Base address is 1,000 and the address of this word is 500 so the address of this word let let it be500 so the offset will be offset will be 500 which means out of these, words let's say this the address of the last word is one9 so out of these th words I want to I want that word which has the address of 1500 so whenever when I will add the offset into the base I will get to this so offset will tell me out of these word which word you want to access and if you add if you add the offset into the base you will reach to that word so that's how addressing is done here so to convert logical to physical what we have to do we have to first check if offset is less than the limit or not if yes then add the base into the offset and you'll get the physical address of that word okay so what this segment number is used segment number is used to check the segment table for base and the trap okay and what is the use of this limit this limit is used to check if the offset is not generated Beyond the limits suppose this was the allowed segment to be accessed but what happened I generated the offset of let's say, 1600 so now when I will add the offset into the base it will go down to the next segment no from here I will not yeah suppose 1600 so I will go down to the next segment because the offset is greater than the limit let me draw another block here so the base was of th000 this the total words in the segment are let's say 1,000 the last address is of 1 tri9 okay now suppose the offset is generated of this word till this offset is generated so I will be able to access this word it is allowed but if I generate the offset greater than the limit then I will enter into the segment of then I will enter into the another segment which is not allowed so what we have to do if the process wants to access the segment which it is not allowed to access then we have to send it to the Trap so that's what segment table is used segment table is used first to check the limit whether this offset is not trying to exceed the limit and the second thing is we have to get the Base address so that we can add the offset to it and get the physical address so that's how addressing in segmentation is done let's see this let's see this example this will make you more clear consider the following segment table we have segment we have base and we have length length is limit it is just a different name length is the limit so what are the physical address of the following logical address segment Z and this is the offset so the offset is 4302 but it has a limit of 600 so what will happen now the Base address is zero the length is 600 so the last address will be 599 but which address does it want to access it wants to it wants to go till 4302 this segment has been over here only but it wants to access the data of some other segment which is not allowed so it will cause trap trap will be cost the second question segment number two segment number two where is the segment number two here is the segment number two the offset is 50 so this was the segment number two the Base address was 90 and the offset is 50 but what is the what is the length of the last word or what is the address of the last word here in the segment it is 1 8 9 so 50 here is allowed I can access this word so 90 + 50 will be the word or will be the physical address of that word which want to access from the main memory 1 and 15 1 C the offset is larger than the limit so this will also generate a trap third part base is 23 27 and the length is 580 but the offset is yes less than so what we will do we will add the offset into the base 2 3 2 7 + 400 so I'll get 7 2 7 this will be the physical address of that word which we want to access fourth the base is 1 1952 now if the offset is less than this length then it is allowed but here the offset is 112 112 it will not be added because the offset is greater so it will go into the Trap so this is how segmentation is done let me repeat whole thing again in paging the users's view of memory was not preserved the users view of memory location was not preserved but here in segmentation we semantically divide it main function in one segment square root in one segment sub rooting in one segment stag in one segment symbol table in one segment and how does symbol table look like it has this will represent the segment number this will represent the limit and this will represent the base what does this limit say it is the size of the segment and what does this base say it say it says the starting address of the segment starting address of the segment now the process generates the now the process generates The Logical address this is The Logical address it contains segment number and offset how are we going to convert this logical address into physical address from this segment number we will move to that index in the page in the segment table okay now we will check is the offset less than the limit if yes then we will add this base to the offset and the resultant will be the and the resultant which we get will be the physical address of that word okay so this is how segmentation is done we have seen all of these things and how trap is generated by trap is generated we we have also seen this thing because if the Trap wouldn't have been there then the process May access the word of the segment which it is not supposed to in the next lecture we will see its performance now let's see the performance of segmentation based on the two factors time and space how much time it will take M for the segment table and M for the main memory where m is the main memory access time segment table like the page table also resides in the main memory so firstly we have to access the segment table to get the address and then main memory to get the instruction of data the addition and the comparison will take the negligible time okay can we reduce this time can we reduce this to m we can with the help of tlb and PSC if we are using tlb only then tlb it look at the tlb we got the address access it tlb Miss look at the tlb we didn't get the address go at the segment table first and then at the memory so C plus 2m for that if we have used tlb plus PSC then tlb hit got the address first PS hit got the instruction of data PSM Miss first looked at the PSC and then to the memory tlb Miss first look at the tlb then segment table here I got the physical address looked at the PC got the instruction of data psms looked at the PSC first then in the memory and after that I got the instruction of data so this is how the effective memory access time is calculated if we have used tlb or PC it is exactly the same like we did in the paging okay now if we talk about space then if segment table becomes too large then apply paging on segment table how can we apply paging select some page size divide the segment table into Pages store the pages in frames access them through Page table see we are not applying paging on segments segments will be stored in one location only and the different segments can be stored noncontinuously that effect is undenied but what are we doing we are applying paging on this uh internet sex here this this table I'm talking if this table has become large than then we will apply paging on this table we will divide it into pages and we will store the pages into frames and then we will access those pages with the help of page table okay so this is what we called segmented paging we will look into segmented paging in detail in our miscellaneous topics okay paging versus segmentation now it comes which is better with respect to fragmentation in paging we have internal fragmentation at the last page in in segmentation we have external fragmentation at Main memory how paging we have SE internal fragmentation at last page suppose suppose the program is divided into pages and how much page it's going to require let's say going to require 4.1 pages so it will take four complete pages and the fifth page only 01 space will be used and rest will be unused so this is how internal fragmentation is present in the last page in case of paging and how external external fragmentation is there in case of segmentation suppose between two segments so so less free space is there that we cannot fit a different segment or a smaller segment M there this space is tool less so this is what external fragmentation is between two segments the free hole is not big enough to accommodate any new segment so in paging we have internal fragmentation at the last page and in segmentation we have external fragmentation at the main memory so in paging internal fragmentation no external fragmentation in segment we have no internal fragmentation because we follow variable partition and we have external fragmentation in main memory just like we organized we did in the variable partition okay and how are we going to solve this external fragmentation issue in segmentation the first method is compaction or defragmentation suppose we have segment stored like this S1 freeh hole S2 a bigger segment of size let's say this much wants to get accommodated here but we know that a segment either it will be completely stored or will not be stored so what we will do we will shift this segment here we'll create a bigger free hole now this segment can be stored here so this is what competion is as we did in the variable partitioning it is also known as def fragmentation but the problem with competion is it is less it is not diagram it is desirable it is less desirable why because firstly it is time consuming we have to swep out swep in all that things and the second is runtime address binding should should be supported we are changing the addresses of segments so runtime address binding is supported so that makes it less desirable the second option we have is of segmented paging segmented paging it reduces the size of segment table and also the external fragmentation we will study that segment paging part in detail in the last section so these are the topics we will study in the last section of miscellaneous topics okay in the next lecture we will see what is virtual memory virtual memory it gives an illusion to the programmer that huge amount of memory is available for executing that program which is larger than physical memory it gives an illusion to the programmer that there is enough memory available for executing a kind of program which is larger than physical memory larger than Ram how it works how it is implemented let's see suppose we have a virtual address space of 8 KB and Main memory of 4 KB page size of 1 KB so this virtual address space will be divided into pages of will be divided into pages of size 1 k each from p 0 to p7 we know that it is not possible to store all the pages into this main memory because main memory size is smaller than the virtual address space see this virtual address space is nothing but the program and this is the processing so it is not even feasible for bringing the whole program into the memory even if the space is available then also it is not feasible to bring the whole program into memory because as I've told you there may be several Pages there may be let's say 1 million pages but only few of them are useful that's why out of these eight pages let's say four of them are useful so p 0 P1 P1 is not present so p 0 P2 p7 and P5 were useful so I brought them here and or I can put it other way that the size was 4kb only so I have to select four important pages from these eight pages and put it there okay but what will happen in the case if I want to refer that page which is not actually present in the main memory let's say I want to refer P6 then how this will work so this virtual memory thing is implemented with the help of demand paging as the name suggest loading the pages on demand from disk to memory there is there are lots of pages in a program but few of them are loaded into the main memory creating the process this is a program in the disk this is a process in the memory so each and every page which I can or I want to refer is present in the disk only few of them are present in the memory now what will happen I have want to refer that page which is not present in the memory this is what demand paging is loading the pages on demand from disk to memory see this virtual memory is mapped on the disk what is virtual memory virtual memory is nothing but the program program is present on the disk this is the virtual address space this is the this is the virtual address this is the virtual address space mapped on the disk I mean all the program from p 0 to p7 or whatever naming you write P1 to p8 are present on the disk all the all the pages of that program are present on the dis but few of them are present on the memory so how this it will going to work let's see here suppose this is a process Pi running on CPU it generates an address P and D the page size was 1 kiloby so the D will be of 10 bits and number of pages were eight so P will be of three bits it's good now let's say I want to I want to refer to the page number two I want to refer to this page this entry will tell me in which frame my page number two is stored so this is 1 one is three in in binary we write three as 1 one so 1 one is three so in frame number three my page number two is there but what will happen if I want to refer to page number six what will happen if I want to refer to page number four or p page number one now I want to tell you some more thing which I have not told you before in this entry not only the not only the frame number are stored various other things are also stored one of them is this bit this bit will tell me if the page which I'm looking for is present in the memory or not suppose page zero is present in frame one so I will write one here one will represent that it is a page hit what is Page hit the page which I'm looking for is present in the memory this zero will tell me the page which I'm looking for is not present in the memory this is a page Miss so one will represent the Page hit and zero will represent the page miss or I can say the one will represent that the frame number which is written here is valid or 0o will represent that the entry here is invalid okay so from here I got the frame number and from here I got the offset I got physical address I will access the memory similar let's take another case suppose I wenter page number seven is St in frame Zero from here I got from here I got the frame number from offset I will get the word which I want to look and there I can get the physical address this one will tell that the frame is actually present in the memory but I am more focused upon that case where we are not finding the page which we are looking for suppose the address is generated of this page which is not present in the memory which is a page miss or we also call it as a page fault the page is not present on the memory but present on the disk you know that every page which I can refer or I want to refer is present on the disk every page because the whole program is present on the disk but whole program is not present in the main memory if I want to refer that page which is present on the disk but not on the main memory that phenomena is Page Miss okay so what will happen now if I want to refer that page which is causing a page Miss then process cing page fault will get blogged we have to read the page from the disk so this is what an iio operation is and why the process is blocked because I hope you remember the process transition diagram from ready it got to running and from running it has generated that address or it has generated the address of that page which is not present in the memory so what will happen we have to read that from the disk and reading or writing operation on the disk is I operation so this will go to the block State that's why the process is blogged now what will happen after the process is blogged how are we going to read the page we have to first perform the mode shifting we have to shift the mode from user to Kernel kernel virtual memory manager now process is blocked then who will come to the CPU virtual memory manager will be on CPU taking charge summoning the disk manager to find that required page and have hand over the copy to that page to virtual memory manager let us see the whole process what is going on suppose there's a process running on the CPU it generates an address of that page which is present to the memory then I'll get the physical address how here I will get the frame number here I'll get the offset I get the physical address I will access that word but now the process has generated the address of that page or process want to refer that page which is not actually present in the memory now what will happen process will get blogged why because that page which process want to refer is present in the disk reading the page from the dis is an IO operation and for I operation process has to get blocked after the process is blocked CPU is empty from running the process has went to the block state so no one is there at the CPU now who will come virtual memory manager will be on the CPU taking charge summoning the disc manager virtual me memory manager say hey disk manager I want this page so disk manager will look in the hard disk and hand over the copy of that page to virtual memory manager now virtual memory manager will try to save that copy of of that page to the main memory it has got the page which I which the process want to refer let's say P6 was the page let's say P6 was the page that uh process want to refer it was not present here so process will get blocked virtual memory memory manager will come summon the disk manager to hand over that copy of the page to virtual memory manager now virtual memory manager has the page B6 what will virtual memory manager do now it will try to fit that page into main memory so that process can refer to that page so here two cases will come the first case is we have an empty slot in the main memory if the frame is empty then the virtual memory manager will save that page unblock the process eye process will come to the ready State and it will continue its work from there but what will happen if the frame is not empty like in this case frame is not empty so we have to select a frame out of these swap that out and swap P6 in the case one was there was an empty frame present so I will put P6 there but the case two is there is no empty frame all the frame are already filled now what will happen I will select a page and I will select the page and I will swep that out from the main memory and swep in the P6 same thing is written here if the frame is not empty we need to swap we have to select a page as a victim now the question arise how are we going to select the page as a victim there are policies present to select the page so what we will do P5 P5 let's say P5 is the victim so we will swap out the P5 what is the meaning of spping Out means from Main memory I will put this P5 back to the disk and from disk I will put P6 here now this is what the main memory looks like it has page number seven page number zero page number six and page number two so we have replace or copy or replace if updated in the memory we will copy or replace if updated in the memory so this is how demand paging is done and all of the operating system which you know like Windows Mac Unix all of them follow this approach let us understand the types of demand paging the first is pure demand paging or the default one in pure demand paging we start the execution of the process with empty frames the whole M main memory is empty none of the page is present there but in prefetch as the name suggest we start with loaded Pages see this page fault is like an interupt which will result from mode which will result in mode shifting from user mode to Kernel mode okay this is the point I want to mention in the implementation of virtual memory three three types of address spaces are involved the first is the main memory which is physical address space the second is the virtual memory that is which is the virtual address space and third is the dis address space now can you tell me the relation between them physical address space is less or equal to the virtual address space because we need larger program this in this virtual letter space program is stored the program program is itself the virtual address space so what is physical address space in this processes are stored so larger program should be able to execute in smaller area that's why we have a physical address space and virtual address space virtual address space is greater than the physical address space now comes the disk address space size of virtual memory is limited by the size of disk see this is the program this is the process and this is the dis itself so in disk there are multiple programs okay and only some part of the program are loaded into the main memory that becomes the process so physical address space is the smallest then comes the virtual address space and then the disk address space virtual memory is mapped onto the disk mapped onto the disk so disk address space should be large enough okay look at these diagrams now CPU then cache memory then Ram then virtual memory hard memory comes this is what the conceptual view of main memory is let's see this memory hierarchy how data is transferred between memory hierarchy so from virtual memory it is transferred from virtual memory data or pages are transferred into main memory upon page P from Main memory the data is transferred into cach upon cach Miss and from cach we transfer data into register via load or store okay so this is the memory hierarchy this is the conceptual view these are the pages memory map either hit or miss if hit then it is okay if Miss then swap in swap out will happen this Miss is also known as page fault if page fault happens then what what happens the process is blocked virtual virtual memory manager will come into the CPU virtual memory manager will summon the disk manager to hand over the virtual memory manager that is hand over him the copy of that page so disk manager will look at that page enter the disk find that page copy that page into and copy the page and hand over to the virtual memory manager now what will virtual memory manager do it will try to put that page back into the main memory two cases may occur the first is there exist an empty slot for that page to be shifted there but if no empty frame is present then we have to select a victim page remove that page from that frame and place the newly copied frame uh newly copied page into that frame so this was the idea apps taken to serve the page fault firstly the program is loaded into the main memory and then page table is formed now process want to access that page which is not present in the memory then it will generate an interrupt mode shifting will happen virtual memory manager will become active and with the help of disk manager it will try to bring that page into main memory again if the free frame is present then it will put that page into that free frame and then we'll update the page table and restart the instruction okay so these are the steps page for service time pfst is the amount of time taken by operating system to serve the page for it is generally in the millisecond and memory access time is generally in the nanc in the next lecture we will see the performance of virtual memory let's analyze the virtual memory timing so instead of calculating effective memory excess time we are calculating here effective access time we will take effective memory access time as M only so let us take that effective memory access time is m page fault service time is s and Page fault rate is p and Page hit rate as 1 minus P here the structure of formula will little bit change change because in tlb or in caching we used to take hit rate as X and Miss rate as 1 x but here we have taken page fault that is the Miss rate as p and hit rate as 1 minus P now we will calculate effective excess time of demand paging as virtual memory is implemented using demand paging it will be equal to if I had a hit then 1us P into effective memory exess time plus if I had a Miss then first I have to serve the page fault so s will come and then I will access the memory but you know that page fault service time is in milliseconds and Main memory or effective memory access time is in Nan seconds so I can ignore M here I can write it as s so formula of effective exis time for demand paging will be demand paging will be 1 P into M plus P into s + m or I can WR write here P into s let us read performance calculation of demand paging system if there is no page fault effective access time is the effective memory access time okay effective access time equal to effective member access time if there is a page fault we have effective access time equals to firstly page for search time and then effective memory access time and we can approximate that is to page for search time because page for search time is very large in comparison to effective M ex time it is around like, and one so we can ignore one in front of thand where PFS is the page for service time since the emat that is effective mem system is very small compared to pfst it can be ignored now we had a page for rate of P then effective access time can be calculated as follows so effective access time equals to page fault into effective access time of page fault what is the effective access time of page fault this page fault service time and Page hit and then effective access time no page fault that is emat only so that's how we got our effective access time now you can look for this example effective memory access time for a given system is 1 microc and the average page for search time is at 10 millisecond you can see the difference let's say p is the page fault rate or the probability of page fault then effective exis time will be just put the values and you'll get the answer look at this amazing flowchart it will contain all of the cases which we have studied till now we will start from CPU it generated a virtual address then the first cases which Sayed in the tlb and the two cases which can arise is either it was a miss or it was a hit if if it was a hit then we generated the physical address if it was a Miss then we have went and searched to the search at the page table now again two cases May generate the first was in the in the page table we had a hit it means the page which we were looking for was present in the memory we had a hit and the second case which may arise is it may be a miss so let's look at the Miss first if it was a Miss then page fault will occur and we will serve that page fault we will get that page from the secondary memory that is the hard disk we'll update the main memory we'll update the cache and we'll update the page table entry and then we will go at the beginning again but if it was a hit then we will generate the physical address now we have included an additional concept here of updation in cash if we had a Miss then we will not let it be Miss always we will update it so that next time when when we will search for that page it will be easier for us so here what we have done we have updated the cashier we'll update the cashier when it was a Miss in the tlb we went to the page table we had a hit there then we'll update the tlb now okay tlb was updated so now it's time to go and access that word or instruction so we had physical address now we had here physical address now now let's say we went to the PC again two cases may arise either it may be a hit or it may be a Miss let's say if it is a hit that means we found the instruction or data corresponding to that physical address then we will return that value from cach to CPU if it was a Miss then what will happen we will update the cash we will update the cash from Main memory what we did in the case of page table or what we did in the the case of tlb we updated it using page table and here we will update the PSC using main memory so we will update the cach from Main memory and then I will return the value from cash either data or instruction to the CPU so that's how it work let us read it again for more clarity CPU generated the virtual address searched in the tlb two cases may arise either hit or miss if it is a Miss then I will look in the page table if it is a hit then I will generate the physical address update the tlv if it was a miss then I will look then I will uh serf the page fault update the main memory cach and Page table entry now we have got the physical address and then we will search for that physical address into cache whether that instruction or data corresponding to that physical address is available in the cach or not if yes then we'll return that and if no we'll update and then return so this was the virtual memory concept with the help of tlb and PSC plus we had an additional concept of updation I hope you liked it let us solve some problems and you know the drill you have to solve or attempt them first and then see the solution suppose the time to serve a phage fault is on an average 10 milliseconds while a memory exess time takes 1 microc then 99.99% hit ratio this is 1 minus P hit result in an average memory exess time and this is nothing but effective excess time so you have to just apply the formula page fault occurred page for service time page for did not occur and Main memory exess time here this is given 10 milliseconds this is given 1 microc this is given and you find this by 1 minus uh hit ratio so 99.99% was the hit ratio so 0.01% will be the Miss Ratio or the page fault rate so from here I got this now we can see that the units are different we have to bring them to the same unit 1 millisecond is 10 ra to^ 3 seconds 1 microc is 10^ 6 seconds so I can say 1 millisecond is 10 power 3 microc so I will write here 1,000 and we'll solve this and I got 1 micros and from there I got 0.9999 microc so adding them I got this 1. n999 microc as the answer question number two if an instruction takes I microc and with a page fall takes an additional J microc then effective exess time if on average a p page fa occurs after K instruction is so we have to find the effective instruction time instruction I if it is just the instruction then it takes I micros seconds if it is a page page forward then it will take additional see here see here additional J is written so additional J microc so I + J after every K so I can write for first instruction take I second take I and for K it will take I + J just find the average I + i+ and then in the end i+ j total are K so K in the denominator from here I got I + J by K I can do this with the formula also we know that page fault rate is K 1 by K so 1 by K into I + J + 1 upon 1 K into I only so this is Page fault occurred time with page fault so it will take I for instruction and J for additional page fault service so page fault occurred page for service time page for did not occur memory exess Time same formula question number three you should attempt this on your own now let's see the solution assume that we have a demand page memory it takes 8 millisecond to serve a page fault if empty frame is available or if replaced page is not modified so let me tell you a concept that this was our memory suppose this was the victim frame that is that will be replaced with some other page or let me start with the beginning suppose a process generated an address of that page which is not present in any of the frame on the memory so what happened page fault will occur now page fault will be served so that page which the process want to refer will be bring brought to the memory and no p no frame is available if no frame is available then one of the frames will be selected as victim and that frame will be replaced with the page which we have brought so the thing is if the victim page has been modified then we have to store that victim page into the disk first so that the updated data is not will not be lost and then that page will be restored so this is the concept so it it says if an empty frame is available or if a replaced page is not modified if it is not modified then just remove that from the uh memory just throw it somewhere somewhere in the free space and then store the page which you want to store that can only happen if either empty frame is available or the replaced page is not modified but the case is if that victim page is modified then you have to store that in this first and then store that page so this will take some additional time so this uh the victim page which is which has been modified has been given a term dirty so it says that page for service time will be different if the page is clean or the victim page is not modified or the empty frame is available then it will take 8 milliseconds and 20 milliseconds if the page is dirty or modified and it is also given that 70% of the time page is modified so for dirty I will write d as uh D equal to7 and from here 1 minus D will be3 which means 30% of the time the page is clean and for 70% of the time the page is dirty memory excess time we are given with 100 nond so we have to find the acceptable page for rate for an effective exess time no more than 2,000 nond so effective exess time less than 2,000 NS and Page fault rate we have to find just apply the formula effective access time equals to page fault has been occurred page fault service time now we cannot directly write 8 or 20 here we have to find the effective page for time so how can we find effective page for time 8 milliseconds when it is not dirty and 20 milliseconds when it is dirty so from here I will get it is 14 milliseconds and it is 2.4 milliseconds so from here I got 16.4 millisecs this is the effective page fault time page fault occurred effective page for service time page fault did not occur memory exess Time same formula we put the values and solved for the value of P because we want to know the acceptable page for rate for the case when the effective exess time is less than 2,000 NS so from here we solved how did we solve see here this this was in milliseconds and this was in nanc so you have to bring them to the same scale and we solve this and we find that the effective page fault rate uh no it is just the page fault rate not effective that was the effective page for service time so the page fault rate should be around 0.01% or 10^ minus 4 okay see another question consider a process executing on an operating system that uses demand paging the average time for a memory access in the system is M units if the corresponding memory page is available in memory and D units of the memory page causes a page f it has been experim Mally measured that the average time taken for memory access is X units so this is E8 given which of the following is the correct expression for the page fault rate experienced by the process so here x will be the effective exess Time 1 minus P will be the time when page fault has not occurred if page fault has not occurred then access the memory if page fault occurred then page fault service time so just we have to find P from this equation x = m mp+ DP so M will be sent here x M and P will be taken common from this and this D minus will be sent to the denominator so x M upon D minus M will be the answer that is B now comes an amazing question it says consider a paging system that uses one level page table resing in main memory okay so one level okay and a lb for address translation each main memory access time takes 100 NS and tlb lookup takes 20 n seconds each page transfer to and from disk takes 5,000 NS 5,000 NS assume that the tlb hit ratio is 95% so X is 95% or I can write point 95 if we are talking probability the page fault rate is 10% so page fault rate will be p is .1 assume that for 20% of the total page faults a dirty page has to be written back to the disk before required page is read in from the disc that concept I've told you so D will be02 okay tlb update time is negligible okay the average memory access time is so easy question let us take this case suppose a process Pi resting in CPO generates a logical address firstly we will look in the tlb if found then F frame will be copied here and this D will be copied here and we get our physical address but if not we will search first in the page table if page table if found in the page table this Frame will be copied here this D will be copied here and we found our physical address if not even found in page table then two things can arise the first is the victim page is dirty the second thing is victim page is clean if the victim page is clean then we have to just bring from the disc and if victim page is dirty then we have to first store and then bring that page into the disk so this time is given that 5,000 nond will be taken if we have to uh transfer a page to and from the dis so in case of clean only 5,000 nond will be taken and for the dirty 5,000 NS for storing the page back to the dis and 5,000 nond for bringing the new page to the memory so we have to just apply the formula now effective memory access time tlb hit tlb look up got the physical address access the memory tlb Miss first looked in the tlb but failed then I mve to the page table it was found in the page table here I got my physical address access the memory now what happened I had a tlv miss I had a page miss or page F now I am looking in the page table first but found that it was not present so chances are the page is dirty so if the page is dirty then 2T time will be taken that is 10,000 n seconds and if the page is not dirty just 5,000 NS put the values and you'll get your answer okay so the answer was 54.5 NS so if the page is clean then one dis operation if the page is dirty then to disc discover so simple in the next lecture we will learn about page replacement page replacement first we'll learn about what is reference string set of successfully unique Pages referred in the given list of virtual addresses this successfully unique is important because if one page is successfully not unique and the same page we are referring then it won't create a p it won't create a page fault don't worry if you don't get that line I'll explain it to you suppose virtual address are generated like this way 702 74 123 654 483 012 934 in this way let's say the virtual addresses are created now the page size is 100 bytes so this will belong to page 7even this will belong to page 7even this will belong to page 1 belong to Page 6 belong to page 4 belong to page 0o belong to page 9 I hope you are getting how I am getting the the page number I'm getting the page number by this virtual address mod page size this will give me the page number and what will be the offset here the the page number is seventh and the offset is two the offset is four the offset is 23 the offset is 54 the offset is 83 the offset is 12 the offset is 34 okay so this this tells me that I have to visit page number nine and word number 34 in that page that word will contain my instruction of data so this was the virtual address generated now the reference string will be 7 this seven won't be counted because we want successively unique focus on the word successively this seven won't be counted then 123 so 1 6 now let's suppose if seven comes again then we will take it 4 0 and 9 this is what the reference string is reference string is not about Pages uh is not about addresses it is about pages okay so this this was the virtual address generated and the reference will be reference string will be about pages okay so which page we want to refer that page will come and successively unique pages should be there like here this seven won't come I hope you got the idea so why successfully unique we referred a page page fault occurred we bought that page into the memory now we are referring that page again page fult cannot occur okay so create reference string from this virtual address 6 2 1 6 7 2 95 okay as they are all successfully unique successfully unique so we will take them reference string has two properties length and number of unique Pages this number of unique Pages tells us about the size of the process in terms of pages here let's calculate the number of unique Pages 71 6 409 so six unique pages are there and what is the length of the reference string the length of the reference string will be 6 only suppose in this case 7 1 7 1 7 6 in calculating the length we will calculate these 37 but in calculating the N that is the number of unit Pages referred we won't calculate the N again and again I hope that is clear frame allocation policies n represent number of process SI demand frames for process i d is the total demand m is the available frames AI is the allocated frames this is similar to the bankers algorithm number of processes frames demanded by process I or for process i d is the total Demand by all the processes m is the available frames AI is the allocated frame to that process I okay and you know that allocated will always be less than equal to demand we won't allocate more than the demand n equal to 5 which means five unique process 1 2 3 4 5 m equal to 40 which means total available frames are 40 okay these these were the demands P P1 demanded 10 frames P2 demanded five frames P3 demanded 35 P4 demanded 18 and P5 demanded 12 some of sum them all and you'll get the total demand that is D will be 0 now there are different allocation policies frame allocation policies the first allocation policy says that allocate them equally how many how many total available frames we have 40 so allocate them each allocate them each eight eight frames so 10 will be given eight frames five it demand of five but it got eight it demanded of 35 but it got 8 only it demanded of 18 it got eight only so this is absurd it should not be there because P2 demanded just five and it got eight more than its demand and P3 demanded 35 and it only got eight way less than its demand so when should we use this equal allocation policy this should be used when all the process have almost equal demand in this case demand is varing 10 5 35 18 12 if would be around 10 11 10 9 12 in that case this equal allocation policy will somehow satisfy that okay now there is a obvious point to be made that if available frames are way greater than the demand then there is no scene of allocation policy we create policies because the demand is more and available is less if the available is more and demand is less then what is the need of decision making the second policy comes of a proportionate allocation demand upon total into available so this will be allocated to each process demand upon total into demand upon total demand into total available so this will proportionately divide the total available frames so this is what proportionate is 50% rule says whatever the process ask give it half of that if it ask 100 give it 50 this is 50% R now the question arises minimum number of frames allocated to a process the the minimum number of frames allocated to that process what should be the minimum number of frames the first is that number of frames without them process cannot execute the second point is process should be able to execute minimum one instr instruction if minimum of one instruction is being executed then those are the minimum number of frames allocated to that process which which says at least these many frames should be given to the process for execution now if uh process should be able to execute minimum one instruction so if we have to execute one instruction only then what is the need of multiple frames because instruction can be stored in one frame so for one instruction shouldn't we need just one frame so that is the question but it is not that simple it depends upon the instruction architecture like uh we will discuss it with more detail in computer organization architecture course but just for the sake of explanation this is the op code and these are the operant this op code is like a code in binary which will tell which operation to perform and these are the oints which tells on which variables we have to perform that operation on or in which literals you have to perform that operation okay suppose add R1 B so in this R1 + b the result should be stored in R1 so this is what an instruction is and this add will be the op code let's say 0 1 1 0 this represent the op code for addition so this is the op code these are the oints now the the point is operant can be distributed in multiple pages so we cannot say that we only need one page or one frame for an instruction to be executed see instruction reside in a single frame but operants can be distributed or multiple pages so it depends upon the instruction architecture so for this question the minimum number of page uh frames that must be allocated to running process in a virtual memory environment is determined by the answer is instruction set architecture okay we are given with the reference string you remember what was reference string reference string was the number of successfully unique Pages referred or the string of successfully unique pages and the total number is 20 and unique R six this six represent that the process consist of six pages is St in the disk okay now what will happen naturally the process will ask for six frames in the memory so that it can bring its all the pages from dist memory process will naturally ask for six frames but what happens operatic system shows no mercy and gives only three frames to the process process requires six frames but it gives only three frames to the process okay so we will start with the pure demand paging remember what was pure demand paging that we will start with the free frames that there is no page present already in the memory process want to refer page number seven but unfortunately that was not present as we were starting with free memory so that will cause a page fault and seven will be brought from disk to memory now process want to refer page zero same case will happen here again a page fault and zero will be brought from disk to memory then page 1 and then same case with page so three page FS have occurred till now now what will happen all the frames allocated to the process is filled with the pages process want to refer page number two now but that is not present page fault will occur again what will happen now one of these Pages have to go from the main memory and let this page number two enter into the main memory but the question is who will become the victim so we will decide the victim on the fif basis the first to come will be the first to go out so when two will come the seven it is it is the uh turn of seven to go from Main memory to somewhere else it will go back to the disk so seven will go two will come now process want to refer page number zero page number Z is already present so no page fault it wanton to refer page number three a page fault will occur see here so who will go now after 7 0 came so 0 will go three will come after three process want to refer page number zero again what will happen this one will go zero will come now again a page fult process one to refer page number four not present in the memory now it is the chance for this two to go four will come again a page F two will come again a page F three will come now zero no zero page fault three will come present no page fault two present no page fault one wants to come but it is not present page fault two will go one will come now two wants process want to refer page number two not present page fault will occer Zero already present 1 already present 7even is it present no Z will go 7even will come zero is it present no one will go Z will come one is it present no two will go one will come so by this we will calculate the number of page falls so number of page falls are 1 2 3 4 5 6 7 8 9 10 11 12 13 14 and 15 so there are total 15 page FS when we alloted the process only three frames out of six and based on which policy FIFA policy so the number of page faults were 15 when we had three pages or three frames it so what will be the page fult rate total number of references 20 Page Fs in that 20 references were 15 so the page fault rate will be 75% now what will happen operating system shows some mercy and aot it four frames instead of three four frames are there now it is your homework to calculate how many page fa will occur so this is your homework we'll discuss in the next lecture and it is so obvious that rate will decrease why rate will decrease because we have four frames now suppose if we had another frame here then 70124 page for will occur now Z wants to come Z is already present three wants to come but not present so three will go here zero already present see there in the previous case it caused a page fault but now it is not a page fault zero is already present in this way the page fault rate will decrease so you have to calculate how many page fault will occur if we had a number of pages or number of frames allotted equal to 4 make sure before starting this lecture you have pen and paper along with you a reference string is given this was the reference string and in the last lecture we have seen that if the process has been allocated with three frames to bring six pages from this dis to memory then 15 page fault will occur this page fault rate was 75% now the homework was to check the number of page fault if the process had instead of three frames if the process has four frames then how many page fault will occur so the answer was 10 the page fault rate significantly decreased from 75% to 50% 15 by 20 is 75 and 10 x 20 is 50% let us take another question this is the reference string number of references are 12 and the unique pages are five calculate again for the three frames and four frames pause the video and calculate so for the three frames I got nine page fs and you will be surprised to know that when I increased the number of frames when I show when I showed some mercy on the process and I have given him extra frame so that it can easily bring those five pages from disk to memory so that it may have less page fault but what happened something unexpected has happened instead of decreasing instead of decreasing the rate the page fault rate actually increased against the natural characteristics when we had three frames there were nine page Parts when we had four frames then we had 10 page fors how is this possible so it in increased against the natural Char characteristic this is an anomaly anomaly or whatever you pronounce it anomaly so we call it as bad anomal so what happens generally page fault rate and this is the number of frames if I increase the number of frames then page for trate significantly decreased like happened in this case but what happens when the number of frames required is equals to number of pages then after that no matter how many frames I give to the process the page fault rate will be same let me explain you in this case there were six pages available to the process or I should say the process had six pages and number of frames available were three in that case 15 page F has occurred if I had increased the number of frames 10 page F will occurred let's say I have increased to six frames the number of pages has equal to the number of frames available s page fault occurred zero page fault occurred one page fault occurred two page fault occurred three page fault occurred and later in some point four page fault occurred Beyond this whatever may be the reference page fault will not occur because whichever page the process want to refer is present in my memory so after that page fault won't occur so that's why no matter how many frames I increased is the page for rate will remain same so this was the general idea which we thought of but what happened here in the case it increased against the natural characteristics it has gone somewhere like this the page fult rate increased instead of decreasing so this is an anomaly in case a if I took six frames then six page fault initially initial once due to the pure demand paging and then the page fault will remain same the above anomo was discovered by badi badi ano says as per the number of frames allocated to the process increases as the number of frames allocated the to the process increases if I increase the frame number then page fault also increase sometimes and it only happens in the case of fif or fif based algorithms and the reason for this is stack property of replacement you don't have to go deep into this just remember the reason the reason is stack property of replacement so let us revise what happened in the in the in the last lecture we have discussed a problem in which we had three frames available then 15 page pter cut then if we have four frames available then page for rate should obviously decrease this was the idea and if I have allocated that many frames which the which equals to the number of pages the process has then after that no page fault will occur the number of page fault was six or number of page fault was K here because of pure demand paging if we talk about the pre patch demand paging then in that case if I had allotted frames equal to the pages then the page fault will be zero but default one is pure demand paging so we were taking that taking into account that to load the pages like 7 0 1 2 3 4 this will cause a page fault every time because initially we started with zero initially we started with nothing it was a free memory so when process referred the seven it caused a page fault when process referred zero it caused a page fault so in that manner six page fault will occur and after that no matter how many frames I I allot to the process page fault will remain same due to Pure demand paging so this was the idea but what happened in this example when I increased the frame number the page fault actually increased against the natural characteristics so this was bad anomal and it happens in the fifo and fifo based algorithms or fifo based allocation policies and the reason behind this is stack property of replacement optimal page replacement will generate the minimum page Forge in fif we Cho we have chosen that page which was first to come in the memory as a victim in this optimal page replacement we will choose that page which has not been used or which will not be used for the longest duration of time in future let us take this case 701 CM reference string page fault page fault page fault why due to Pure demand paging now page fault will occur out of this 701 which will be the page to be selected as victim see that which page has not been used for the longest duration of time in future zero just used 1 used 7 7 will be selected because 7 is the page which will be used after so much time so we will remove seven so compare which will which page will be used after the longest time that page you will choose as a victim and remove that page so 7 will be removed 7 will be gone two will come now out of 207 we have these pages in the memory 207 is present zero no page fult three 0 just used two just used one will be used after the longest duration of time so out of 2011 one will be removed now three will be brought to the memory we had 203 now zero no page fault now process wish to refer page four not present page fault will occur two just used three just used and zero will be used after the longest this time so 0o will be gone and four will come here after that we have 2 43 in the memory 2 no page fault three no page fault zero page fault will occur because we have 2 43 no zero so which will be removed three just used two just used four is not used ever so four will be removed now we have 203 so here we have 203 three no page fault two no page fault one who will be removed now the one which has not been used for the longest duration of time so after 203 two used 0 used three has not been used ever so three will be removed one will come two present in the memory zero present in the memory one present in the memory seven page fault will occur who will go 0 just used one just used two has not been used for the longest time in the future hey I have noticed that I speaking the grammar wrong it should be two instead of two has not been used I should say two will not be used okay so two will not be used ever in the future so 701 will be the final Pages which will remain in our memory so how many page fault has occurred 1 2 3 4 5 6 7 8 9 so nine page fault will occur and now four frames how we will calculate for four frames we are we are using pure demand paging 1 2 3 4 these page fault will occur due to Pure demand paging now we have 7012 in our memory now out of this 7012 you know that 7 has been used directly here so 7 will be removed when this page fault will occur so at place of seven three will come after three zero already present four page fault will occur who will go now two used three used one is used at the after the so much time so one will be removed four will come now we have 3 0 42 two present 3 present 0 present 3 present 2 present 1 is not present so who will be gone four has not been used ever four or I should again correct it four will not be used ever so four will be gone but are you noticing that three has also not been used so out of three and four which should be gone we will at the tie breaker we always use F4 so the one who came first will be gone first three will be gone now are you noticing the difference if we have two pages which won't be used later see we had three and four this zero will be used and two will be used but this three and four will not be used later so out of them which we have to select as a victim the one who came first so three will be selected one will come now okay so now I have 1042 two present zero present one present now seven wants to come who will go we have four and two not used ever 1 and zero will be used so after four and two which came first two was already present so two will be gone see two has came here and has not been gone till now so two will go now so now seven will come now calculate the number of page for 1 2 3 4 5 6 7 and 8 page for really decreased from 9 to 8 when we increased one frame now check for this we had bad's anomaly in this question when we had three frames we got N9 page fault when we had four frames then we got 10 page fault which was against the natural characteristic so here we followed victim policy as fif now we have to follow optimal replacement and check does it suffer from the bades and this is your homework or you can do it now by pausing the video so for three frames we got seven as the answer and for four frames we got six as the answer so I can say when we increase the frame the page fault rise decreases so it is not against the natural characteristic so it does it does not suffer from bades anomo and I have already told you that fif and fifo based only those suffer from bades anomo but if you have observed there is a serious problem in the implementation of optimal replacement what will the serious problem it is similar to the sgf remember the fgf CPU scheduling algorithm in which the first time was already given but can you guess the bur time of the upcoming processes no in the similar way can you guess which pages will process want in the future no you cannot guess you cannot guess which Pages the process will want in the future it is purely dependent on the situations so how will you look into the future which pages are you going to refer like hgf it is non implementable then why do we study this we use this algorithm as a benchmark that by this are this is the least number of page faults possible and your algorithm let's say let's say in this case in this case the page faults were eight okay so I can say these are the least number of possible page faults and my algorithm is producing let's say 10 page FS so I can say yeah it is closed but there is a scope of improvement so it is it is used as a benchmark okay in the next lecture we will see an another policy that is least recently used it is just the 180 shift of the optimal policy in optimal policy what we did okay I think I should I should teach this in the same lecture so in optimal page replacement what we did we thought that whichever page page has not been used or whichever page will not be used for the longest duration of time in future that page will be removed or that page will be chosen as victim we have 180 shift the algorithm replace that page which has not been used for the longest duration of time in the past so here has will come and there will will come there we were choosing the page which will not been for the page which will not been used for the longest duration of time in future here we are choosing the page which has not been used for the longest duration of time in the past so here past is there and their future was there so reference string is given 7012 03 the same reference string page fault page fault page fault due to Pure demand paging now at this point which will go the one who has not been used for the longest duration of time in the past see one was recently used zero was recently used seven was the least recently used that is the name of the algorithm so 7 will go 2 1 will come now zero page fault will occur which was the mo least recently used one was the least recently used so 20 3 one was gone now zero page fault occurred least recently used after 203 two was the least recently used two will gone four will come 43 so in this manner you have to proceed so you will see the number of page SPS then you have three frames is 12 and you increase the number of pages or number of frames then you will get a pretty less page fault number so from 12 I reach to eight so this also does not suffer from Bad animal okay now let's see the most recently used replace that page which has just been used replace that page which has just been used if you are getting confused do not in fif we replace that page which came the first the first to come will be the first to go out in optimal we replace that page which will not be used for the longest duration of time in the future in the least recently used we replace that page which was least recently used or which has not been used for the longest duration of time in the past and then most recently used replace that page which has just been used so 7 01 page for due to Pure demand paging now two wants to come who will be gone one will be chosen as Victim Because one was recently used so in this manner you have to proceed so in this page fors are really high There are 16 page fors now comes the counting algorithm the criteria is a little bit different here the criteria is count of reference number of times a page is referred that is the count of reference and one special thing is when swep out and then swep in set count equals to one when swep out and then swep in set count equals to one and which page will be selected as victim the one which has the least count and here in the most frequently used the one which has the highest count will be selected as victim okay let's see this this is the reference string 71203 and so on page fault occur page fault occur page fault occurs due to Pure demand paging so now the 701 has a count of 1 1 1 the 7th page the zeroth page and the first page has been counted or has been referred one time now two wants to come so page fault will occur again which of them will be gone or which which of them will be selected as victim the one which has the least count but here all of them is the same count so we'll use fif the one who came first will be the first to go so seven will be replaced by two now two will come and it has been referred one time now zero Zer will be zero is being referred second time so 1 + 1 now three three wants to come who will be replaced or who will be selected as victim one will be selected as Victim Because two and one both has same count but two just came and one was already there so one will be the first to go so this will be selected and three will come at its place zero count will increase now zero has been referred three times four wants to come who will be gone out of two and three three just came and two was already there so two will be gone four will come again page fa who will be gone now four and three both have same count so three will be gone because four just came so three will be gone two will be there now three wants to come now who will be gone two just came so four will be gone three here with count one now zero zero has been referred again so the count will increase to four now three count will be increased to two so three as a count two 0 is Count four and two has been referred again so two will be the count of two will be two now one wants to come out of three and two will be gone two was already there three just came so two will be be gone so two will come go and one will come here now two wants to come again so who will be gone out of 2 4 and one the one which is the least count so one will be gone two will come now zero increase the reference count now one one wants to come so who will be replaced out of two five and one the wi one which is the lowest count so one this two will be replaced one will come seven wants to come now now who will be replaced the one will be replaced seven now zero wants to come Z is already there increase the count to six now one wants to come who will be replaced seven only because it has a least count so one will come so page for occurred in total least frequently used are 13 now you have to do the same the change is the one which has the highest count you have to replace that and if both the if both the pages have same count then use free4 the one who came first will be the first to go out okay so this is your homework and calculate the number of page for let's say it is 15 just for the sake most of the time it is found that lru is closer to Optimal in terms of performance so many operating system either implement lru or variations of lru and lru is implemented through stack how it is implemented say we have 701 in our frames so 7 will be pushed to the stack 0 will be pushed and one will be P one will be at top zero at the in the bottom or zero in the middle and seven in the bottom now this one is the most recently used and seven is the least recently used now what will happen pop one pop zero and when you pop 7even the seventh will be gone because we are removing the least recently used now push them back into this tag zero will be pushed one will be pushed now two wants to come at the place of seven so two will come here now who is the most recently used two is most recently used and Z is the least recently used so nothing happened just two came here okay now comes the laru approximations these algorithm are not really lru but they are approximate they approximate to the behavior of lru so here comes a new term that is reference bit the reference bit shows each page in the page table will be associated with a reference bit which which shows that has the page been referred so far if zero then it is not referred and it if it is one then it is referred at least once okay so each page in the page table will be associated with a reference bit if zero not referred so far if one referred at least once so page table entry contains many attribute like frame number valid or invalid time of loading time of reference count of reference and reference bit these are the attributes of the page okay now comes an important part what is epoch if you have uh learned about deep learning that Epoch is a cycle or Epoch is a duration of time it is time Quantum it is time Quantum so this is this is the time scale and the epoch is the just the duration of time say this is one Epoch this is another Epoch this is another Epoch and let's say this is the time in present so we will look into the pages that if this page has been referred in Epoch 3 or not if it is referred then we will set reference bit as one and if it is not referred than zero so we the reference bit is counted based on the epoch Epoch means that the current duration of time okay so the page table entry is associated with these many attributes like frame number valid or invalid time of loading time of reference count of reference and reference bit reference bit can be 0 or one zero suggest that page is not referred so far during the present Epoch and one says that at least once in the current Epoch so reference bit this reference bit we talk about in the current Epoch in the current duration of time so let's say these were the process or entries of the page table frame valid invalid time of loading and reference so this shows that page number zero has been referred at least once in the current e page number three is not present in the memory page number five has not been referred in the current Ok Okay so this is what reference bit is so now we have five pages 0 1 2 3 4 and 5 or it is six pages sorry 0 1 2 3 six pages so out of these six pages the time of loading shows shows that which page was loaded first in the memory so the page number two was loaded first in the memory and page number four was loaded last in the memory these are six is just a Sil mistake three okay so p 0 P2 and P4 has been referred in the current Epoch P0 P2 and P4 this is what reference bit is now if you remember the definition of lru what lru said select that page as the victim which has not been referred to the longest duration in the past which has not been referred to the longest duration in the past and this is what laru approximation we are studying so reference Bit Zero matches with the statement or reference bit one matches with the statement what does reference Bit Zero says page is not referred so far it somehow matches with the statement that page has not been refer to the longest duration of time in the past so R equals to zero so how are we going to select the victim page scan scan the page table right from the first entry and as soon as you got R equals to Z victimize that page so here which page will be victimized scan from the first entry reference bit not zero reference Bit Zero so page number one will be the page to become the victim okay now comes the question if all of the pages has been referred at least once say there is no reference bit which is zero all reference bit are one then what will happen then this reference bit algorithm fails okay now when one e box get completed set R equals to zero I have already told you that we talk about reference bit during the current Epoch during the current Epoch let's let's take this as an example suppose some parameter K tells that how many times your name was spoken by other people in the year let's say 2036 okay okay K tells that now what happens 2036 just got completed and 2037 has started this is the year now what will be the value of K zero because 2037 has just started okay so this is what reference bit is so as soon as the current eox get completed set R equals to Z because when the current eox has just completed none of the page will be referred when the time will pass then the reference start so as soon as the current epox get completed set R equals to Z so what was the loophole here if every page has been referred at least once then reference bit algorithm fails now how are we going to select the victim the second is additional reference bit each page is associated with more than one reference bit let's say eight and this is a static you cannot change it this is static this is not Dynamic let's say if we are we have selected that eight reference bit or eight previous history will be saved then it will be eight only it won't change when the time will pass suppose another epox get completed so you won't add here nine what will happen this will be lost and R8 will become zero why zero because if the current eox get completed set R equals to Z let me start again what happened we introduced a new term reference bet reference bit tells that if the page has been referred till now in the current oke then set it as one if it is not then set it as zero now we are approximating the lru what lru said select that page as the victim which has been referred which has not been referred to the longest duration in the past and Ral to0 matches with the statement now what we did in the reference bit we scann the page table from the first entry and as soon as we get R equals to Z we victimize that page but what happens when there is no such page there is no such page which has not been referred till now all of the page has been referred what will happen then reference bit algorithm fails then comes the additional reference reference bit what we do here we keeps the previous history so we will check here all once no problem get back or go in the previous in the previous Pi PG and PK all of them were referred don't worry go back in the previous to previous ook Pi was was referred PK was referred but PJ was not referred so when a new page let's say PL will come when page fault will occur so who will get victimized PJ will get victimized you getting the point so what we are doing we are maintaining the previous history in R8 all of them were referred so we cannot select which page to choose as a victim in R7 again the same thing but in R six PJ was not referred so we'll select PJ as the victim okay okay but what happens in the rare case when all of them here is also one all of them are one what will happen then in that case this algorithm will also F and when the current current EO gets completed do the left Shi left shift operation and select R8 equals to Z and R1 will be lost so left shift will occur this will be lost and select R8 as zero why zero because when epox get completed set R equals to Z now comes an interesting algorithm that is second chance or clock algorithm the criteria is time of loading plus reference bit see we are giving second chance to the pages let me explain so in this how are we going to select the victim based on the time of loading and reference bit so we will go with the time of loading which page was loaded first two was loaded first go there it was the time of loading was zero so two was loaded first now check the reference BD is it is it Z no it is not zero it is one change it to zero and then move to the next which was loaded next four was loaded next does it uh have a reference Bit Zero select that as victim what are we doing the page with which get loaded first see its r value if it is zero victimize it victimize it if it is not if it is one then set it to zero so P4 here will be victimized now if if you can observe that if all of the reference bit R1 then also this algorithm will not fail why we are because we are given second chance to the pages see here let's say all of them were one now what happened time of loading two was the first to get loaded so we will change it to zero now four came so we will change it to zero now who came this page number zero it has reference bit of one change it to zero move ahead three page number one came it has a reference bit of one change it to zero now page number five came it has a reference bit of one change it to zero so what we have done we have gone for the full cycle when all of the reference bit were one we have gone to the full cycle how based on the time of loading now we will after one cycle go again in the same order now who was loaded what was the order the P2 was loaded first now it is a reference bit of zero victimize it are you getting the point see in reference bit if all of the bits were one the algorithm fails so what we did we maintained the previous history okay I believe that in the previous or in the current Epoch all of the pages were referred let's talk about the previous Epoch where all of the pages were referred yes all of the pages were referred and previous to previous Epoch PJ was not referred okay victimize that now there is a rare case also here that all of the pages were referred even in the previous EPO also so what we will do we are giving a second chance to the pages we will go in the order of time of loading and see the reference bit if the reference bit is zero victimize that if it is one then change it to zero in order that when I will come again at this point then the reference bit would have been zero and I will select that page to become victim that's why second chance and the first chance we change that to zero and in the second chance this will be victimized so this has actually solved the problem when all of the pages were referred in the previous epox also okay so the page which get loaded first see its r value if it is zero victimize it if r value is 1 set it to zero so here P4 will be victimized and in this case P2 will be victimized okay so when all of the pages are Valu is one then fif page select fif page get selected that's what we have done here when all of them were one P2 was selected which came the earliest and as soon as you hear the the name of fif bades Ando should come to your mind so when in Second Chance algorithm when all of the reference bitar one then it is a possibility that bades Animo may occur we have seen the reference bit algorithm we have seen the additional reference bit we have seen the second chance algorithm in Second Chance fif follow fif order will be followed when all our values are one and it will suffer from Bad Anor now comes the enhanced second chance it is like not recently used so what does it say we will maintain RM what is RM R suggest referenced and M suggest modified or dirty bit so criteria is RM R is reference and M is or modified bit Dirty Bit so 0 0 0 1 1 0 and 1 1 this is the priority order 0 0 says page not referred and it is clean also 01 says page not referred but it has been modified one says page has been referred but it is clean 1 one says page has been referred and it is modified also so which page we will select as victim in this order we will select them victim if 0 is available that will be at the first priority to become victim so priority is 1 2 3 4 this will be at the least priority and this will be at the highest priority okay now let's solve some problem this is the page table structure we got entries frame number valid invalid time of loading reference and modified bit now according to fif which page will be selected as victim P3 will be selected as Victim Because it came first according to reference bit which page will be selected as victim scan from the first entry as soon as you get Ral to0 victimize that so P1 will be victimized according to Second Chance who will be victimized go with the time of loading Zer change it to zero so I will change it to zero now who came P1 p so P5 came and it has a reference bit of zero so P5 will be victimized according to enhanced Second Chance choose which is a RM of 00 so one will be victimized P1 will be the answer okay consider a system with v = to P = to 2^ 16 bytes P size is 512 bytes the size of P table entry is 4 bytes if the page table entry contains beside other information one valid invalid bit one reference bit one modified bit and three bits for page protection how many bits can be assigned for storing other attributes of the page also compute the page table size and bytes so we have V = to P = to 2^ 16 and Page size is 2 power 9 bytes so we'll get the number of entries it is 2^ 7 so how many how many bits for storing the frame number as we have seven entries so seven bits for frame number and the remaining 19 bits for rest of the other attributes where were six bits were stored or where were six bits six these six bits are used here three bits for page Protection One for modified one for reference and one for valid invalid so six were used here seven were used for frame number remaining 19 bits will be for the rest other attributes and what will be the page table size the size of each entry into number of entries we got 512 bytes of page table consider a virtual memory system with Fe for replacement policy for an arbitrary page access system increasing the number of page frames in the main memory will sometimes increase the page number or sometimes sometimes increase the number of page fault because this is what bad's ano is what does it say The General characteristic is if you increase the frame number then page board generally decrease but sometimes in the fifo based page replacement what happens when you increase the frame number the p page fault rate also increases a memory page containing a heavily used variable that was initialized very early and it is in constant use is removed when fif page replacement is used because here it is written initialized very early so it is brought first and if it is brought first see here here is in the constant use so lru won't be there Leo won't be there so fif will be the present fif will be the uh page replacement algorithm that is being used here because it is written initialized very early recalls that bad's anomo is that the page for rate may increase as the number of allocated frames increases now consider the following statement okay random page replacement algorithm suffers from Val ano where a page chosen at random is replaced the second says lru page replacement algorithm suffers from bad so this is false lru is never lru is laru never suffers from bad an the first statement is random page replacement algorithm suffers from bad's anomal well this can be true this can be true because let's say by coincidence it worked as fif and in fif bad Ando is present so the answer is S1 may be true and S2 is false S1 may be true and S2 is false S1 is true when by coincident that random page replacement algorithm worked as fif consider a process having reference string l in which n unique Pages occur Z frames are allocated to the process calculate the lower bound and upper bound of number of page fors so if maximum uh we have a reference string of L so what will be the maximum number of page f l how because every reference will cause a page fault in that case in that case the maximum which will be l number of page fault can occur and how can every every reference cause the page fault when we have allocated just one frame to the memory suppose three page brought to the memory CS page for now four wants to come so four will be the four will again cause a page for now let's say five wants to come five will again cause a page F so if we have just one frame then every reference will cause a page fault that's why the maximum number of page fault can occur will be the number of reference and minimum number of page fault is n when we are using pure demand paging then in this will happen in the case when we have allocated that number of frames which uh which equals to the number of pages in that case we have n number of page fault and that only the case of pure demand paging suppose the process has six pages and if I have allocated six frames then for the first time when the first time the pages are loaded then only six p page Port will occur and after that no page P will occur because we have every page required in the memory itself and in case of prefetch demand paging what will happen in case of prefetch it means all of the pages are already present in the memory so in that case no page F will occur so the minimum is either n or zero and the maximum is l l happens in the case when only one frame is allocated and minimum happens in the case when the number of frames allocated equals to the number of page of the process in the next lecture we will learn about threshing threshing just like deadlock it is undesirable feature of operating system what is threshing excessive or high paging activity which means High page fault rate and you know that when page fault occurs the loading and saving pages on the dis this kind of activities happens and these is consume time so the most of the time process will be spending time on their page F service and hence will get blocked you know that reading a page from the disk is an iio operation and iio operation in the when the pro when the I operation is being performed the process remains blocked we have learned that in our transition diagram now what happens we have learned that in uni programming operating system the percentage CP utilization is less so what we do in order to increase C percentage CP CP utilization we think that we should increase the degree of multiprogramming what is multiprogramming increases the number of processes in the memory so we increase the number of multiprogramming supposing that if some process has went for the io then some other process will be there on which CPU can work upon and hence increase the percentage utilization so thinking that we increase the degree of multiprogramming but at some point it reach to the saturation and after that the degree of multiprogramming kept on decreasing and decreasing this is the curve and the last part of the curve is threshing see this is logical if you have a limited memory and you want to you want to accommodate maximum number of processes we are increasing the degree of multiprogramming that's what it means so we want to increase the number of processes to a high number but what happened when there are so many processes in The Limited memory then each process will get less memory each process will get less number of frames so if number of frames are less then page fault rate will increase sign significantly if page fault rate will increase significantly then process will be spending most of their time in the blocked State because page for service during the page for service process remains blocked so the most of the time process will be blocked and hence the percentage CP utilization will decrease this process is blocked performing the page for service time or during the page for service time this process is also blogged blogged blogged because each process gets so much little frame to accommodate its pages and if number of frames are less then page fault will obviously occur more and the process will spend most of their time in just solving the page fault or serving the page fault and will get remains or will get blocked so this will significantly decreas the percentage subtilization okay so what is the reason of threshing High degree of multiprogramming less number of frames and high page fa rate so this is the same example here suppose Ram is of 4 GB limited size and can accommodate 50 process ideally but after 50 process we want to accommodate 55 and 60 then frames will decrease to each process and page for trade will increase and if operat system is not using good replacement technique then also page for rate will increase and it is obvious that if page size is small then there will be more pages and there will be high page for trade if page size is large then number of pages are less frames are same if number of pages are less then less page fault will occur are you getting the point see increasing the page size May decrease the page for but you know that it will invite internal fragmentation so we have to do everything in Balance now comes the threshing control strategies the first one is prevention and the second is deadlock or just like the deadlock the second one is detection and Recovery in prevention we want threshing to occur we want threshing to never occur and how can we do that by controlling the degree of multiprogramming and you know who controls the degree of multiprogramming long longterm scheder and for detection and Recovery how are we going to detect that threshing is occuring when we see symptoms like low SE utilization maximum number of process getting blocked High degree of multiprogramming high disk utilization so these are the symptoms for threshing and what will happen after threshing has occurred how are we going to recover process suspension we will remove the processes from memory put it in the dis bag who will do midterm scheduler let me repeat again what was threshing threshing is when we decrease when we increase the number of programming to a higher extent which means we are increasing the number of processes in the memory more than its limit then what will happen each process will be given less number of frames to accommodate less number of pages and if less number of pages are in there in the memory then page fault rate will increase if page fault rate is increased then process will remain blocked for most of the time because the time the most of the time will be uh will be spent on pageold service so this will significantly decrease the percentage CPU utilization this is what threshing is now comes the threshing control strategies the first is by controlling the degree of multiprogramming if we are not forcing the number of process to be more in the memory then no problem so who will Who will control that longterm scheder detection how are we going to detect that threshing may have been occurring if we find that low CPU utilization is present maximum number of process are getting blocked the degree of multiprogramming is high but CPU utilization is less the degree of multiprogramming is high but CP utilization is less which means threshing should be the reason behind it high disk utilization because uh we are utilizing dis and reading the pages again and again for different kind of processes during their page for service so disk utilization will increase CP utilization will decrease degree of multiprogramming will be high number of processes will be more to get blocked so these symptoms suggest that threshing should be the reason and recovery process suspension well the main reason was the high degree of multiprogramming with the help of midterm scheder we can swep out the processes from the memory and may decrease the degree of multiprogramming and who will control that midterm scheder so the process suspension is the uh is the solution for threshing in the next lecture we will learn about locality of references now comes the question how can our programming can affect threshing and here when I say V I mean by programmers not the OS developers programmers like the one who writes C program Java program these are the programmers and how can that programming can affect threshing is it possible let's see so we are given with an integer array let's name it as a it is not an ordinary array it is two dimensional array so let us create that uh I should use standard let us assume this is the array now what happens the size of arrays number of columns are 120 and number of rows are also 128 so I can write integer a the rows can go from 1 to 128 and the columns can go from 1 to 128 and it is an integer array so if I write it like this a 1A 1 till we have a 128 comma 1 till a 128a 128 this is our Matrix a now the question is suppose I write two programs the program one is for I 1 to 128 next Loop for J 1 to 128 set the value of a j first and then i j i = to 1 and if I write similarly here but what is the difference now I write IA J = to 1 you know that eventually both will work eventually they will set each and every element of Matrix to one but how it will affect threshing let's see that suppose I have a page size of 128 words and each word can store an integer so this is our Matrix and how are we going to store this Matrix into the memory we will store let's say using row major order what is row major order this row this row will be stored in one page this row will be stored in one page so how many pages will be there there will be total 128 Pages this is what row major order is we are storing in rows so the first page will contain the first page this is let's say this is the first page it will contain a 1 comma 1 a 1 comma 2 till a 1A 128 this will be stored in page 1 so how many page it will require it will require 128 Pages for the complete Matrix now what happens it will ask for 128 pages but what happens only 127 frames are available in the memory only 127 frames are available this was our memory and the total number of frames are just 127 so what will happen I will store page one here page two here page three here till page 127 and page 1 128 is still store in the disk okay now let's see the programs the program said for I to 128 and for J to 128 store A J comma I is 1 so I will I will refer I'll refer 1 comma 1 first I I will set it to one then I will refer see here J is first so column will come first so 2 comma 1 then I will set it to one then 3A 1 then I will set it to one in such manner I will go till a 128a 1 and then I will set it to 1 because J is written first so column will come first so here it is column so 1A 1 will be set to one it is okay this is presented page page one and we have that page one into the memory no problem but when it will move to a2a 1 then what will happen it has to access page number two which contains a2a 1 1 a 2A 2 till a 2A 228 128 this is is page two so in this manner it will access page 1 page 2 page three till page 127 now it is turned for a 128 comma 1 to be set as one but this page is not present in the memory so what will happen it will cause a page fault and when page fault will occur this page will be brought to memory but there is no free space available so which frame will be selected as victim let let us take fif so the one who came first will be gone first P1 is removed now p128 is present so how many page fault has occurred till now we were using pure demand paging so initially the memory was completely empty so 127 page fult initially and this new page fult that is 128 page for has occurred in one cycle from a 1A 1 to a 128a 1 one page for has occurred oh sorry 128 page for has occurred in this one cycle now how many cycles it will go it will go till 128 Cycles so a now now who will come a 1A 2 a 1 comma 3 till a 1A 128 and in the next who will come this will be the next cycle a 1 comma 3 a 2A 3 till a 128a 3 this will be the another next cycle so in one cycle we had 128 128 page parts so in 128 Cycles how many page for we will see 128 into 128 so this will be the total number of page FS when we have used this the first piece of code now let's see we are using the second piece of code now let me remove all of this now we are storing like this IA J = 1 in this this manner a 1A 1 then a 1A 2 a 1A 1 128 in this manner it will be stored now so for the first cycle how many page fault will occur only one page fault how this P1 will be brought only for the for all of this 1 to 128 only P1 will be brought from disk to memory why because P1 contained all of these frames see here P1 has all of them from 1 to 128 now it moved to the next cycle it requires P2 now then to the next cycle it requires P3 now and then to 127 so from till 127 how many page fault has occurred 127 page fault has occurred and for the last for the last which this one a 12812 a 128a 128 P 128 should be there in the memory but it is not so page Vault will occur it wants to come who will go one 20 128 will come at the place of P1 We are following fif so how many page fault are there now only 128 page faults let me repeat again what happened when we are storing like this AJ comma I = to 1 then we want we want to access page in this manner first this page then this page then this page so page fault will occur for one cycle 128 page faults will occur for another cycle another page fault will occur for another page cycle 128 another page fault will occur so how many page faults occur 128 into 128 128 in each cycle and there are 128 Cycles but when we stored like this a i comma gal to 1 then for the whole cycle I required only one page for only one page for and how many for one complete cycle only one page fault has occurred and how many cycles are there 128 Cycles so 128 page faults will be there so in this way just by swapping the variables from J comma I to I comma J we have saved so much we have reduced the number of Page fors by 128 times there it was 128 into 128 now it is just 128 we have reduced the number of page FS by 128 times just by spping the two variables this is all I have written here suppose these were the two program s the program size is 128 bits and we were storing row major orders in this way it is stored it will require 128 frames but only 127 looted so how many page fault will occur with program 1 and two 128 Square page fults when we were writing like this A J comma I and only 128 page falls when we are writing like this so when we stored in row major order but a j comma I is column major order then it will increase the page f are you getting the point see we stored in row measor order but accessing in column major order that is just the opposite so it will obviously increase the page F here in IA J we stored in row major order and we were accessing also in low major order this will create low page F so I can say program 1 is 128 times lower than program 2 because number of page Faults Are 128 times more in program one than in program two and why is it so because program 2 follows locality of reference okay so now you have idea what is locality of reference how does it work just by spping two variables we made the program 128 time slower okay if we have written I comma J then the program would have8 times faster here it is slower store we storing in row major order and accessing in column major order it will naturally increase the page for we are storing in row major order and also accessing in row maor order this will lower the page for okay now it is your homework what will happen if we have a page size of 256 words and 64 words see here we had a page size of 128 words that means 128 integers can be stored in a single page now your homework is what will happen if the pay sizes of 256 words and the pay sizes of 64 wordss solve it we have seen how program can change the threshing rate can data structure do so also can data structure do the same let's see suppose we have to choose between arrays and Link list let me check if it is recording yes so which is better in case of demand page environment arrays are better how much possibility that complete arrays in the single page because the possibility that the complete arrays in the single page is more so it will cause less page for and in link list each node will be in the different page that is possible it will cause higher page fault this is just me it may cause so if in general scenario someone ask which is better array or link list in the demand page environment say array and what is the reason because it is chances that there are chances that the array may be in the single page and Link list may be distributed over the pages so arrays are more preferable in case of demand page environment linear search versus binary search linear search works like an array will cause less page Fs in binary search each node may be in the different page maybe say I have said maybe in the different page so the number of page fors will be higher so I can say linear search is better in case of demand page environment a programming technology or data structure is said to be good in a demand page environment if and only if it satisfy the locality model it satisfies the locality model so what does locality of reference or locality model says it says that it should refer those pages only which are loaded in the memory it should refer those pages only which are loaded in the memory so this is what how the way we write the pro the program or how we use the data structure or the algorithms this can significantly change the rate of threshing see here we write a program we just swap two variables and the threshing rate changed in case of data structure if we use a data structure which is more suitable in the demand page environment threshing rate may change we used an algorithm which is more suitable threshing rate may change so this is the point which I want to make that how we write program that can really affect threshing now comes the working set strategy or model to minimize page for rate and also utilize the memory effectively it works on the principle of locality of references now you all know what is locality of references take this example suppose I have main function in that main function I have this another function f in this function f I have another function G in G I have another function H and H I have another function scan F the total program size is 55 KB okay the page size is 1 KB so I will say the number of pages required to load the whole program will be 55 so instead of a static demand of 55 frames see which locality and demand accordingly this this is what the working set strategy model is instead of a static demand of 55 frames instead of directed demanding 55 frames see the locality first and then demand accordingly so when in main when you are in main demand for 10 pages only when you are in F demand two pages and there we will not need the the old pages of main when you are in this locality demand 10 pages when you are in this locality demand two pages so in this way you have to go whatever be the size of locality ask for those many frames only so this will create less page fault rate and better memory utilization let me repeat again see in which locality you are and ask for that many page only this is the point it will lead to less page fault rate and better memory utilization it controls the page fault and utilize effectively uses locality of reference which is dynamic frame allocation estimate the size of locality in which the program is executing and demand and demand those many frames suppose this is the process this is the reference string 45 8245 the large reference string till 56 and it goes on now a new term comes that is working set window and this is defined at a particular time have you learned about sliding window window protocol in computer networks this is similar to that so we have a working set window at a time T what is working set window set of unique Pages referred in the reference string during the past Delta references and this Delta is some integer so during the past let's say Delta B5 so during the past five references set of unique Pages referred in that reference string that is working set window let's say three unique Pages refers to working set window sizes three at that time to okay did you get it check for the number of unique pages in the past Delta references in the reference string that will be the size of working set window at a particular time T and this working set window is a sliding window it slides working set window at time T at when I say Delta equals to 10 so how many unique pages are there so past 10 references 1 2 3 3 4 5 6 7 8 9 and 10 so from here to here how many unique Pages were referred that is what the working set window size is how many unique Pages 19 51 52 53 54 56 58 so these are the unique ones so I will say 1 2 3 4 5 6 7 so the working set window size is 7 so right now we are in the locality which is defined in terms of seven pages ask operating system to give seven frames this is how your going to estimate the size of the locality and we'll ask the number of frames accordingly so is the system threshing or Not by this framework if we are using this framework is the system threshing or not let's see so the number of process we have is n the total available frames let's say m and the demand for each process for frame SI the number of uh the size of working set window the total demand at time T will be add all the demands it will give you D the number of processes are n total available frames are M the total demand is D and the demand for each process for frames is determined by how by finding this working set window this that's how we demanded the number of frames so if demand is somehow equal or approximately same to the number of frames available then no threshing if demand is less than the available then no threshing we can still increase the degree of multiprogramming see demand is less available is more than no threshing here if we increase the multi now at that point we increase the degree of multiprogramming chances of threshing will rise at this point when available are greater than the demand then the system system is in ch State no threshing increase the degree of multiprogramming we are good but if demand is is more and the available frames are less then I will say the system is threshing okay the whole success of this working set strategy model depends on Delta let's say the ideal value of delta is 10 which means if you are taking 10 as the delta in which you are looking on to the past 10 references from Delta you are going to set the working set window or the sliding window size let's say the ideal value is 10 now you set the value of delta to 2 and in another case you set the value of delta to 10 it is not 10 it is greater than 10 ideal value is 10 so it should be greater than 10 suppose it is 16 okay now if Delta is two then it will leads to more page fault and if Delta is more then ineffective memory utilization because what does Delta says Delta says according to Delta only the working set window size is defined and that many pages or that many frames are demanded from the memory if Delta is more than wsw will also be more then demand will also be more ineffective memory memory utilization will happen if demand is more then the system may lead to threshing and if Delta is less if Delta is less then number of frames demanded will also be less the ne the necessary frames let's say are 15 but you selected so much less Delta that you want to get 15 frames but you ask asked for only three if the number of frames are less so much less then obviously this will lead to more page ports so the whole success depends how you choose the Delta value let's solve this question it says let the page reference and the Delta B this is the page reference and the Delta B4 respectively the initial working set at a time tal to0 contains the pages a d e where a was referred at time tal to 0 D was referred at time tal to minus1 and E was referred at the time tal to min2 determine the total number of page fault and the average number of page frames used by Computing the working set of each reference so with the end of this question you will get a complete idea how this working set model work so we have a reference string this c c d b c e c e a and d and Delta four the initial working set was e d and a this is the current time this is 1 second before the current time and 2 second before the current time this was the working set at time zero so you have to find the number of page fults we have what we have to find determine the total number of page fault when average number of page frames used by Computing the working set at each reference okay so we will find the working set window at every time initially we had e d a only initially we had EA only and the reference string is c c d the reference string is CCD so at Time 1 this is at the time zero at time let's say t = to 1 C is demanded what will happen page fault will occur so the wsw at time one will be look at the past four why four because of this Delta is four look at the past four reference and select the number of unique pages and include that in your wsw how many unique Pages EAC so edac will be included what is the size four is the size okay so we have to calculate the number of page Cs and average number of page frames so for average we will see for each and every reference and then we will calculate the average so for time equals to 1 we had four in our W WS W now at time equals to 2 C is again asked what will happen look at the past four look at the past four see this the working set window slided see at the past four now how many elements will be there C already there A and D so C A and D the duplicate won't come as I said unique number of uniqu here where I have defined this W and W set of unique pages so if repeative or multiple coming then take only one so the distinct will come here c c a d won't be there only c a d so the number of uh elements in wsw is three now for time three which means now we are asking for D is D present yes D present no page for so what will be the uh wsw size d c and a so d c and a at time four at time four who will be asked B is asked is B present no B is not present so who will come b d and c b d and c will be in the wsw now see here page fault has occurred here keep count of page fault also because we have been asked with total number of page fault and average number okay so at C this at here C already present D B so we have b d and c c already present that's why we didn't included it again now now here at time = to 5 this c b d already present no it won't come again so we have three in WS W tal to 5 in this way we will keep on going we'll keep shifting our window and we'll again shift our window to here now e c b d will come e CB D will come now we'll shift our window again c e c e b will come so we'll have three there now at T = to 8 c and e will there only so e and C are this this this and this how many are distinct only two are distinct so two will come here now at 9 a e c will be there a e c will be there 3 at time 10 d a e c four will be there four is there so now add all of them 4 3 3 3 3 4 3 2 3 4 and divide it by 10 you will get the answer the average one now the number of page faults first page fault second page fault third page fault fourth page fault and fifth page fault so the number of page fault occurred was five and average you you calculate I have given you the formula add all of them and divide it by 10 now we are starting our new section that is file system we have successfully completed our memory management and after file system the operating system is over we will take our miscellaneous topics The Leftovers okay if you notice one thing about file system it is the only visible part of operating system you want to know how file system looks let me show you this is the file system we have devices and drivers then we have so many files in there directory in there there are program files okay so this is what the file system is let me close it it is the only visible part of operating system so we have CPU we have disk CPU is an electronic device disk is an electromechanical device so there is surely an architectural difference to harmonize that we would require a interface card or interface chip then we have device driver which is a device specific software then comes the OS which contain file system and device manager which works interactively so this was just the theory now comes the important part that is disk physically structure look at this diagram first we have a spindle and then e the spindle is associated with four platters we call them as platters you can see the circular structure this is platter each platter has two surface the upper surface and the lower surface the upper surface and the lower surface the lower surface in this diagram you cannot see but suppose a dis type structure and the disc has the upper surface and lower surface okay see here this is the spindle and it is associated with platters the circular structure or oval structure whatever you call then each platter is associated with two surfaces the upper surface and the lower surface till now it's clear now each surface is divided into tracks you know the race tracks in the similar way so each surface is divided into tracks each track is divided into sectors see this each track is divided into sectors so this sector or block is the unit of data transfer generally measured in bytes so when we transfer data we we transfer the data in terms of sectors and this sector is the unit of data transfer so what we have learned till now there exist a spindle spindle is associated with platters each platter has two surface the upper surface and the lower surface each surface is divided into tracks each track is divided into sectors okay this spindle can rotate this spindle can rotate each surface is associated with a read right head the so for a letter I will say there is upper re right head for the upper surface and lower read right head for the lower surface and read right has is head is connected with arm assembly which can move forward and backward so this arm assembly can move forward and backward the spindle can rotate so this read right head can this readr head can move to any sector it want see the spindle can rotate and the arm assembly can move forward and backward so it can easily or freely move to any sector which it want okay now let look at this diagram this is our read right head this is the spindle this is the disc actual disk the saved file in sectors the actuator and then we have circuit board used for the on and off of the disk we have the ARM device configuration Port data cable Port power port Etc so this is what the device or the dis looks like look at this diagram we have arm assembly we have a spindle in spindle we have platters and each platter is connected each platters have two surface the upper surface and the lower surface each surface is divided into tracks and if I select the same track number from all the surfaces and join them with imaginary line then I got a cylinder so this is the cylinder consisting of same track number okay so this is a platter this whole dis is the platter it has this the circular part is the platter it has the upper surface and the lower surface each surface is associated with number of tracks each tracks is divided into number of sectors see this is one sector this small part this is one sector and the spindle can rotate the arm assembly can move forward and backward so that this read right head which is associated with each surface each surface will have its own read right head so that readed right head can move freely to whichever sector it wants to go okay so if we view the same track on platter we get a cylinder and number of tracks will be equal to number of cylinder this is the obvious thing now same sector on all the tracks we call it as dis sector see here this is this is the platter surface the surface is divided into number of tracks and if we select and track is divided into sectors and if we select the same sector number over all of the tracks this sector in track one in track two in track three in track for I chose the same sector number in all of the tracks then what I get I get the dis sector okay so this blue shade you can see is one track and if I select the same sector number over all of the tracks then I get the disk sector and if I select the adjacent sectors over over the track then I get a cluster a group of one or more adjacent sectors so uh let us see here in this diagram this was the track in which it divided into two sectors so if now I select this and this also then I get a cluster this will become one cluster okay now let's see the whole thing we had a disk disk has platters each platter have two surface surface is divided into tracks tracks are divided into sectors and each sector is associated with two attributes the sector number and the sector size the sector number will be in the bits 2 ra to power that number of bits will give him the total number number of sectors and the sector size will be each sector or the smallest unit of data transfer be will be that sector or how many bytes can be transferred at one go okay now comes the disk iio time what is the dis iio time the time taken for the data transfer but for data transfer the data is in the certain sector but it is possible that my read right head could be at a different track it is surely possible so what we have to do in dis IO time we have to select three things the first will be the seek time what is seek time my read WR head can be at a different location so from this track number one see this this is the track number zero this is track number one track number two track number three track number four and this is track number five and this is the sector which I want to read but my read write has is is in track number one so to move from track number one to track number five here this will be the seek time and how will I move there with the help of with the help of arm assembly so from one track to another I go then it will require one seek so head have to make four seeks from track number one to reach at track number five how many SS will be made from track 1 to track five four SS will be made okay okay now comes the track track time what is track track time the time taken by the read right head to move from one track to another it is same as the it is same as the one seek time so the time taken by read right head to move from one track to another just the adjacent one see if I moved from track number one to track number two then how much time will be taken that is track track time that will be the the time taken for one seek one track to another that is one seek time and here I have to make four seeks so four into I should say track track time or one seek time okay so if I have to the time of one seek is actually the track track time and the time taken to move from track 1 to track five or the track which you are in the source to destination track that is the seek time so here total number of seeks how many seeks we have to make 4 six and track track time so track to reach minus current track number so 5 1 will be 4 so we have to make four seeks into time of one seek that is track track time this will be the seek time see what was this Sky time the time taken to transfer the data but data can be in the different sector from the current position of R head rri head see here the read right head is present here but the data is here so what I'm going to do I'm going to firstly move this red right head to that current track it may be in the different track we have to reach to the different track in which of uh in which the sector is present which has our data so firstly we had a seek time we move to that sector so track to reach minus current track number into track track time now we are in that track which contains our sector now what will happen we have to rotate the spindle see here spindle can rotate the spindle can rotate and this arm assembly can move forward and backward so from in the SE time the time taken by arm assembly to make to move the read right head from the current track number to the desired track number that was the seek time now it is time for spindle to rotate and see here firstly it was here now the position has changed to here but still it is not on that sector we were on a different track we reach to the same track but now we are on the different sector we have to reach to that same sector so the time taken we need to rotate it so that the sector comes under the head we need to rotate this in this way so that this will move and will come under the re right head the time taken for this is what we call rotational latency and it is generally taken as R by2 what is r r is the time taken for full rotation and it is made measured in RPM so the rotational latency is taken as r by2 r is the time taken for full rotation so rotational Lance is time taken for half the rotation why we have taken the half because generally it takes around half the rotation for the sector to reach to that current head okay now this is the position firstly we were at a different track our sector was at a different track then we reach to the same track but not at the same sector now what we did we rotated it and the sector has come under the head now what will happen the transfer time will also be there see firstly we were not at the same track seek time was taken to reach at the same track then we were not at the same sector rotational latency was taken to reach to the same sector now transfer time will be the time taken to transfer the data amount of time taken by read right head and transfer the data to the disk buffer so what will be the transfer time it will be the sector size upon track size into R the sector size upon track size into R this is what the transfer time is so the dis IO time will be seek time rotational latency time plus transfer time remember this is it is an important Concept in the last lecture we have seen the seek time the rotational latency time and the transfer times when some sub gives the disio time we have seen the seek time was the time taken by read right head to go from current head to the desired head that is seek time rotational latency time was R by2 what was R the time taken for full complete rotation what was the transfer time sector size divided by track size into rotational time okay see rotational latency is different from rotational time rotational time is R rotational latency is R by2 okay now comes the data transfer rate disk transfer data from rate this much Zed by r k b one track is transferred in one rotation one track is transferred in one rotation so in 1 second how much data will be transferred Z by R KB why KB because we are keeping this rotational time in milliseconds okay now let's see this question consider the following disk specifications we are given with number of platter 16 so there is a dis in which there are 16 platters in such manner There are 16 platters and you know that each platter has two surfaces the upper and the lower one number of tracks per surface this is one track this is another track another one in such manner there are 512 tracks per surface number of sectors per track this is a track this is one sector another sector another sector another sector in this manner there are 2048 sectors in each track the sector offset is 12 bit which means the sector size is 2^ 12 bytes average seek time is 30 millisecond so the time taken by read right head to reach from the current to desired is 30 millisecond dis RPM is 3600 so I can write in one rotation or 3600 100 rotations are there in 1 minute or 60 seconds so in 1 second or one rotation will be in how much time 60 divid 3600 seconds this this will be uh this will be the time taken for one rotation so 60 divid 3600 seconds and if I want to calculate in milliseconds then multiply by 1,000 1 2 1 1 2 1 now there are 6 the 600 divid 36 6 100x 6 this will be the time taken for a single uh rotation this is 16.67 16.67 seconds are taken for one rotation then how much time for okay so we are asked with the first is unform capacity of disk we have one disk which has 16 platters each platter has two surface each surface has 512 tracks each track has 2048 sectors and each sector has a size of 2 12 bytes so this will be the unform capacity so when you multiply all of them you get 2^ 37 which is 128 GB the second question is IOS time per sector we'll have to add seek time rotational latency time and transfer time seek time is given as 30 Mond rotational latency time will be R by2 so we had R = to 16.67 so R by2 will be around 8.3 and now we have to calculate the transfer time what was transfer time sector size upon track size into R so I can write transfer time as this is 1 by K so K will be K will be sector size upon track size into R so in this manner you will get the transfer time from where you will get the sector size you have each and every data is with you from there you will get sector size the track size and then rotational is given with you now the next is data transfer rate what is data transfer rate track size upon rotational latency not latency rotational time rotational latency is 1x2 which is R by2 is rotational latencies R is the rotational time so what is data transfer it Z by R Zed is the track size and R is the rotational time kb per second so from there you will get5 GB per second as the data transfer it one track is transferred in one rotation then in 1 second how much track will be transferred or how much uh data will be transferred okay now the next is sector address so we have to find the sector address in bits how are we going to find log to number of sectors so we find that total number of sectors are 2 by 25 so there will be 25 bits for the sector address and 12 bits for the 12 bits for the sector offset so these 25 bits will take me to the correct sector and these 12 bits will take me to the correct word okay now let us divide this also four for the PLS we have 16 PLS one for the surface we have two surfaces nine for the track we have 512 tracks and number of sectors are 2048 so I can write this as 2 into 1024 which is nothing but 2 into 2^ 10 which is 2^ 11 so 11 bit for the sectors so this will be the total address and sector address will be this one this these 25 bits will take me to the correct sector and these 12 bits will take me to the correct word so sector address in bits are just 25 bits these are the sector offset this will be the total address okay next question consider dis with the following specifications number of surface we have 64 now the surface is directly given outer diameter is 16 cm so outer radius will be 8 cm inner diameter is 4 cm so the inner radius will be 2 cm inter TR distance is1 mm so we have a distance for track is this 6 cm which is 8 2 this is 6 cm and the inter track distance is1 mm so I can say 6 cm divided .1 will give me the number of tracks per surface maximum density is given as 8,000 bits per CM calculate the unform capacity of disk okay so the question is we have to calculate the capacity of the dis surfaces is already given we have find the total number of tracks per surface so these will be the total number of tracks all over the disk now if we can find the track size then I can tell the unform capacity of the dis but you know the track is of different sizes see this is the track innermost track and this is the outermost track innermost track is less than the outermost track you can see it but also we are keeping the size same how can we do that by using wearing density track length in centimeter into density but we had maximum density given is 6ou what was the maximum density I think 8,000 so 8,000 bits per CM 8,000 bits per CM so where will be the maximum density used in the innermost part because see this length into density will give me the size we have to use the maximum density when length is less and minimum density when length is maximum see this length into density should be constant density will be maximum when length is minimum and density will be minimum when length is maximum so where we will use this 8,000 we will use in the inner track so what is the inner track distance the radius is given 2 pi r is the circumference so 4 Pi cm is the inner track distance what will be the track capacity 4 Pi into 1 KB this is the 8,000 bits are 1 KB 1,000 will be 1K and and this 8 will be for byte bit to byte conversion so this is 1 kilo bits multiplying with 8 will give me 1 kilobytes so 8,000 bits are 1 kiloby so the track capacity is of 4 Pi kilobyte the surface capacity is 600 into 4i kilobytes which will give me 12.56 kiloby and the disc capacity will be surface capacity into number of surfaces which will give me 48 GB around five around half GB did you you get it let me repeat again so what we had in the question we have to find the capacity of the dis but we were not giving with the track size we find that total number of surface we have 64 number of tracks we have 600 but until we do not find the track size we cannot proceed so for track size we are given with maximum density but now the question is where we will use this maximum density in the innermost part or the outermost part because the track size is same that is undeniable and you can also see that innermost part innermost track will less than the outermost track and we are keeping the size also same and how can we achieve this by using weing density okay now we know that length into density will give me the size and this should be constant so and we are given with maximum density so where we will use the maximum density in the innermost rack because in the innermost track length is minimum that's why we are using the maximum density so from there we get in each track we have 12.56 KB of data and there are 600 tracks in the surface so we get the surface capacity from here and for this capacity we have 64 such surfaces so we'll multiply the 64 into surface capacity from there we get 48 GB how long does it take to load a 64 kiloby program from a dis so we have to load a 64 kilobyte program from disk to memory okay average seek time is 30 millisecond rotation time is 20 Mill so rotational latency will be 10 millisecond track size is 32 kiloby page size is 4 kiloby assume that Pages the pages of the program are distributed randomly around the disk okay so firstly we have to calculate the time which will take which it will take to transfer 64 kilobyte program from disk to memory okay how many pages does it have 64 / by 4 it has 16 pages and what will be the transfer time for one page so firstly we have to go to that page 30 millisecond and then rotational latency and then transfer time in one rotation one track is transferred so in one page will be transferred in how much time one rotation divide by track size into page size so Pace size divide by the track size into rotational time so from here we get the time taken to load one page from disk to memory is 42 millisecond so the time taken to load 16 pages will be 680 millisecond now comes to the part two what will be the percentage saving in time if 50% of the pages of pro program are contigous so if 50% of the pages of program are contigous which means out of 16 pages eight pages are continuous and eight pages are randomly distributed so for random distribution 42.5 will be multiplied with 8 to get uh 340 milliseconds so 340 milliseconds will be taken to load these random pages into memory now what will happen for these eight pages which are continuous see if these eight pages are which means all the page belong to same track so seek time will be 30 Mill 30 Mond which means the read right head is now on the track which has all the pages rotational latency will be R by2 now the readr head is on the first page plus transfer time of eight pages see here this is the time taken by read write head to go to the track which contain all the pages this is the time taken by read right head to reach to that uh to reach to that the position where first page is there now all of the pages are contigous so no need for another seek time or rotational latency we'll just transfer them back to back so this will be this will come just for one time and then transfer time for eight pages so this will cause me this is the how much time it took it took 60 and 340 for that eight random Pages 340 for 8 random pages and 60 millisecond for continuous pages so the total was 400 millisecond initially the total time taken was 680 in the case when when all pages were randomly distributed so the percentage saving is 480 6 680 mod divide by 680 here we get around 41% saving in time so what will the percentage saving in time 41% if 50% of the pages of program are continuous okay let us uh let let me read this question again and explain to you again what happened here we have to calculate the time taken to load the program from disk to memory and the program has 16 pages so we'll calculate the time taken to load one page and multiply it by 16 as it is said that pages are distributed randomly around the disk so for each each page seek time will come for each page rotational latency will come for each page transfer time will come as it is written there it is randomly distributed around the disk so for one page load time we found it to be 42.5 millisecond so the 16 page load time will be 680 MC the part two of the question says what if the eight pages are continuously there and eight pages are randomly distributed so we will multiply this 42.5 the time taken to load one page into eight pages for random distribution so we got 340 MC for transferring those pages which were randomly distributed now the pages which are Contin continuously distributed or continuously present continuously present then seek time will be there to for read right head to go to that track rotational rency will come for read WR had to go to that page where the contigous uh allocation has started or I can say the read WR had to go to the first page of those continuous Pages now eight pages are back to back so I will transfer them back to back no need for another seek time no need for another rotational latency from there I got 60 millisecond so the total is 400 millisecond only when eight pages are continuously there and eight pages are randomly distributed now we have to calculate the percentage Time Savings so this is how we calculated and we got 4 1% rotational Laten is taken into account only once when the pages are continuously distributed over one track because the read right head of the disc need to wait for dis to rotate to the correct position only at the beginning of read operation so in case of continuous allocation there will be only one rotational latency account once the first page on the track is being read the rest of the pages on the same track can be read in continuous sweep as the dis rotates this is because pages are laid out continuously on the disk so there is no need for disk to rotate multiple times to different position to read each page why because of discontinuous distribution therefore time taken for dis to rotate to the correct position is only occurred in Ur incurred once at the beginning of read operation that's why R by2 is taken only once at the for the beginning thing when the read R head will reach the first page after that read that head can continue reading the rest of the pages on the track without additional rotational delay okay an application require 100 libraries at startup each Library require one dis access seek time is 10 millisecond dis RPM is 6,000 all 100 libraries are at random locations 50% of the libraries require transfer time of half rotation while for remaining 50% it is negligible how long does it take to to load all the libraries see we have 100 libraries and each Library require one dis access so for 100 libraries we have 100 disc excess seek time is given as 10 Mond disc RPM is given as 6,000 so the rotational time we will calculate it 60 second is taken for 6,000 rotations so for one rotation how many seconds will be taken 10 milliseconds will be taken so one rotation can be incurred in 10 10 milliseconds only now it says for 50 libraries transfer time is of half rotation which is 5 millisecs and for another 50 libraries the transfer time is negligible it is close to zero so for set one for 50 libraries we have 5 millisecond and for set 2 we have zero so the time for set 1 will be 50 into 10 + 5 + 5 millisecond 1000 milliseconds and for set two we'll have 15 into SE time rotational latency and zero as it is written that transfer time is zero so the total time will be 1.75 second we will add both of them now here it is not written that they are contigous that's why we have taken into account every time for each dis access like in the previous question if contigous word would present then we will take the seek time and rotational latency only once okay in the next lecture we will learn about logical structure of disk we were learning file system it was the only visible part of operating system we have learned about disk physical structure we have learned what was arm what was platter sector track spindle spr right head all the all these terms we have learned we have learned that in one disk there are several patters each platter has two surfaces each surface has tracks track is divided into sectors sectors can be reached the firstly we have to to reach to the correct sector from where we will get the sector number so sector number will help us to reach to the correct sector and sector size that is the sector offset will help me to reach the correct word okay we have seen dis IO time which included seek time which included seek time rotational latency time and transfer time we have seen the data transfer rate was Z by R KB then we have send some numericals which included to calculate unform capacity IO time data transfer and sector addresses then we have seen that L into D remained constant so when I will use the maximum capacity for the innermost so this was the main concept in that in this question what we did we saw that if eight eight pages are contiguous then there is no need to include SE time and rotational time rotational latency again so if in case of contigous allocation rotational latency will be included only one time okay so this was all we have learned Now we move to The Logical structure of the disk or formatting process so for the to explain this I have a nice example take example of your College library that building of the library or the library place can be said as disk and books can be analogical to data now suppose if I just dump thousands of books in the Library without having proper bookshelves Etc I mean without any proper Furniture then searching becomes horrible suppose in library there are no bookshelves there is no such kind of furniture to store the books I just dump thousands of books or lcks of books in that place in the library building then searching a particular book will become horrible for you so Library without bookshelf is raw disc and library with furniture is formatted dis formatted dis has a benefit of effective storage and faster retrieval now whenever you visit computer labs so for different classes we have different operating system in the same computer for when we used to study C programming so in the same computer we used to study on ubben 2 and when we used to take the computer organization architecture class we used to open the windows software so the operating system first when we used to uh study the cyber security in our computer labs we used to work on K Linux so same computer has different different operating system how is that possible with the help of partitions in the disk so this is what we call multi boot computer it is generally done at the computer labs for teaching purposes so this here is the dis it is divided into several partitions which contain operating system 1 operating system two and operating system three each partition contain a different operating system but if you are thinking that you can load two of the operating system at the same time into the memory this is not possible at a time either one to will run or Windows will run or k Linux will run at a time only one will run so I can say at a time one will be loaded okay so dis is divided into partitions there is one primary partition and some extended or logical drives see when you use to open your this PC when you open this PC then you can see several drives in there like C drive or D drive e Drive F Drive G drive so the C is the primary which contains the bootable data which means our operating system it contains extra data on software also but basically why it is known as primary because it has the bootable part what is bootable part we will see later and this extended or logical drives this contain all the non bootable data like your songs video games or your softwares all these things is here in the extended logical drives here you can see in os1 MBR is the written what is MBR Master boot record this is generally on the first primary partition it contains partition table and boot loader partition table contains the information about the partition so don't worry here are just the steps how the or I can say how your computer starts these are the steps so firstly we switch on after switching on the power comes in so this PD is the power on self test which test that all are all the devices electronically active this is just the hardware test so you can see when you start your computer all the three lights or numb lock page scroll and those lights just blink or in the modern laptops the light over the cap loog or the light over the mute button blinks so this is the power on self test then comes the BIOS basic input output system initializes input output device including the disk so firstly when we switch on power on self test occurs what is power on self test it checks whether the devices are electronically active this is a hardware test then what happens bios happens it initializes the input input output devices including the disk now bootstrap what is bootstrap small booting program what it does it loads the master boot record into the RAM and hand over the control to boot loader so this MBR this MBR is loaded into where it is MBR loaded into RAM okay then what happens boot loader reads partition table and display options if available so if you remember when you start your computer uh or in the lab then you can see the different options which options you select two or k Linux or the windows these three options you can see so you can with the help of the arrow down you can select any of the operating system and choose that to start so boot loader will load the kernel program from the dis into the memory then execution of the kernel will load other operating system modules into the memory like dispatcher virtual memory manager all these things will be loaded firstly what happens power on when you power on then power on self test is occurred which checks are all the devices electronically active then bios test happens it check it initializes the input output device then bootstrap it is a small booting program which does what it brings the MV into the main memory and then what does MBR do MBR has boot loader and partition table so the boot loader reads the partition table and display the options like operating system one like Windows or k Linux or one2 which you want to select now you select K Linux then what will happen boot loader will load the kernel program from the dis into the memory of that operating system of K Linux and the execution of that kernel will load the other OS modules like dispatcher or virtual memory manager into the memory so this is how the operating system comes into the memory so this was the booting process firstly what happens you power on after power on the power on self test occurs then bios happens then bootstrap come when boot strap is executed it brings the MBR into the memory when MBR is brought then the boot loader from the partition table which which will let you choose which operating system you want to bring to the memory then the kernel will be loaded and the execution of Kernel will bring bring other programs like uh dispatcher and virtual memory manag into the into the memory and then finally the operating system which you want to choose will be brought from disk to the memory this is what booting is bringing the operating system from disk to memory now we will learn about the partition structure what infrastructure are embosed on the disk partition after formatting so we have here is the partition one the second part partion let's say this is hard disk so the first one this part is MBR the second part is first partition boot sector the third part is file system area of first partition and data area of first partition so the data area of the first partition is just this much and the rest of the space like is is taken up by MBR the first partition board sector and the file system area of first partition that's why you may see you may have seen that uh let me show you see my laptop has a specification of 512 GB SSD and 16 GB Ram so if I click on this uh this PC see here I get only 475 GB of free space but I have purchased a 52 GB SSD then where is all that remaining what is the remaining 512 minus 475 where is the 30 37 GB the 37 GB is used up here in the MBR in the first partition boot sector in the file system area of the first partition here is the more clear way of partitioning see we have these data blocks down there then we have directory structure partition control block and boot control block data blocks you all know will contain the applications and other operating system files these will include your GTA Y game this will include your Microsoft Word Google Chrome all these things will be included here this this is the directory structure what is directory structure let me show you which contains the files and folders that is what directory structure is these files and folders this is what the directory structure is there we click and I get this I get this this is what the directory structure is then PCB what is pcv partitioning partition control block it gives complete picture of partition just just like the administrative block and what is boot control block it is the sector of partition that contains the boot program the first OS program initial or uh initialization program or kernel the boot block will contain Unix or Linux and partition boot sector will conol Windows this is how the multi booting or multi boot computers are made okay let me repeat firstly we have in a disk we have partitions the primary partition contain the master boot record which contain partition table and boot loader so firstly when we switch down our computer we have power on self test after that we in power on self test we check are all the devices electronically active then we initialize the io devices then bootstrap this bootstrap when executed in the CPU this will load the MBR Master boot record from disk to the main memory which contains boot loader and partition table so boot loader will read partion table and display options to choose which operating system would you like to bring into the memory from disk then after the taking input from the user then boot loader will load the kernel of that program from disk to the memory and this is how and then execution of that kernel will bring the other modules into the memory then we see partition structure it contains it contains the boot control block partition control block directory structure and data blocks data blocks contain the application directory structure I have shown you what is directory structure partition control blocks give the complete picture of partition just like the administrative block and this boot control block it is the sector of partition that contain the boot program like the first OS program like the kernel the boot block will contain the Unix or Linux and the partition boot sector will contain the windows us this is just an example okay in the next lecture we will see the file versus directory let's learn about File versus directory what is the difference between file and directory let me clearly tell you directory contains the information about files not the actual data now comes the question what is file file is nothing but an abstract data type just like a process process has process was also abstract data type which has its own definition representation operations and attributes you remember that similarly file also have the all four it has definition what is the definition collection of logically related entities or records the representation it can be either flat or it can be either hierarchial flat means just the series of bytes and hierarchial means the higher level implementation like B trees or B minus trees B plus B minus trees in that manner operations like create modify open read truncate attributes name extension Owner Mode blocks in use blocks in use means in which block the file is present so these are this is what the file is and what is directory directory contains the information about files okay now let's see it formally representation representation or structure flat or record flat means series of bytes record means series of Records like in hierarchial tree it is the higher level implementation operations are create open read write seek truncate and attributes name extension type Owner Mode size date and time permissions Block in use which means in which block the file data is stored I'm talking about the data blocks in the partition structure attributes of the file are stored in file control Block in in Linux we call it as inode and in Windows we call it as directory entry so every partition contains directory structure here is the directory structure so every partition has its own directory structure what is directory special file which contains data about other files it contains the metadata what is metadata information about the data or data about data this is metadata so it contains metadata of files not the actual data the directory does not contain the actual data of the files it just contain the metadata so this is what a directory entry looks like it is a linear onedimensional array see this is the directory entry let's say these are the blocks in which the file is stored so it tells that file one is stored in this block file two is stored in this block file three in this one and four in this one in this manner let's now see directory structures the first one is single directory structure for for all users we have kept each and every file in the same folder it is simple to implement but as you know lots of searching time will be there secondly naming config problem in the same in the same directory you cannot have two files with the same name even if you try to store it it the one like here the one will be automatically added let's say you have a movie do mp4 file already present if you try to store the same file again then one will be automatically added you cannot store the two files with the same name in the same directory so this is what the naming conflict problem is and bad organization well that's the thing so the single directory for all users mean we have kept every file in the same folder okay so what is the uh Advantage the advantage is simple to implement and disadvantages it will take lots of searching time naming conflict problem plus bad organization two level director separate directory for each user for each user we have a separate directory this is what two level directory is efficient searching and path is involved now see for user one we have another directory which contain these files user two we have another directory user three another directory so what is two level directory separate directory for each user efficient searching and path is involved now we can have same file for different user you know that we can have this movie. MP4 in with same name we can store in store it in different folder this is possible that's what we are seeing we can have same file name for different users but there is no grouping capability which means if we wanted to keep some files separate that is not possible multilevel directory the more advanced version it is sub directories within the other directories sub directories within the other directories like we have the root directory then we have some other directories then in this directory we have other directories in this directory we have more other directories so directories within directories or sub directories within other directories is what multilevel director is it can be either in the tree structure or the general graph directory what is tree Str what is the difference between tree structure and graph directory in tree there is no kind of cycle present but here you can find the cycle from here you can go to this book to every and from a you can go again back to book so in general graph directory we have cycles and what is this directed directed a cyclic graph it is used for file sharing how many links are pointing to the shared file this is the file sharing suppose in this there are two links pointing to the same file so I will say link count of this file will be two and as you know this is a graph so for searching uh for searching a file we may have to Traverse the directory for that so we know that there are two famous algorithm depth for search and breadth for search directory has a file support operation a special operation on directory which is not performed on a regular files daverse in files we do not have such kind of operation if you go there and see the list of operations there is no such kind of operation in file you can either search uh wherever you want in directory so in directory there is a special kind of operation which means daverse daverse mean you can search in the whole directory for a specific kind of file so this is what it's written here so directory as a file support this Traverse operation it's special kind of operation which is not performed on regular files now comes this question the question is consider a list of linear list based directory implementation in a file system each directory is a list of nodes where each node contains the file name along with the metadata such as the list of pointers to the data Block in this manner consider a given directory Fu so we have a given directory Fu which of the following operation will necessarily require a full scan of f for successful completion the first is opening of an existing file info if I want to open a file let's say I want to open F2 do I need to scan the whole uh do I need to scan the whole directory f for just opening a file there is no need let's say I want to create a new file let's say I want to create F5 but I want to name it as F3 I don't know that there is F3 below somewhere I just coincidentally name it as F3 what will happen it will say there is a file with the name F3 already exist do you want to replace it or give it a new name so this error will generate how this error will generate because as I create a new file and name it the whole name of the file in that food directory will be scanned such that there is no there is no file present already with the same name so to ensure that there is no naming Conflict for creation of file yes the all the file will be scanned renaming of existing file same concept yes naming conflict may arise deletion of an existing file from F no there will be no uh need to scan the whole folder through for just deleting so for opening and deleting no need for creation and renaming yes we have to scan the whole folder in the next lecture we will learn about file system implementation now comes the file system implementation look this lecture is going to be way too theoretical so I'm just going to read it all okay the file system is implemented in the layered fashion we have application programs at the top the core file system and the io control and devices the applications this application this execute the input output statement and The Logical file system this one uses directory structure to provide the file organization module with all information this logical file system it uses the directory structure to provide the file organization module this is the file organization module with all the information so initially we have application programs which executes the input output statements this logical file system uses that directory structure so that it can give information to file organization module this handles the files and their logical blocks and physical blocks the file organization handles the logical and physical blocks physical file system issues IO command to the device driver to read and write physical blocks on the disk issues IO command to the device drivers this IO control consist of device drivers and hand and interrupt handlers and then comes the devices which perform the actual eye operation so let me read again application execute input output statements then comes the logical file system it uses directory structure to provide information to file organization this file organization handles the files and their logical and physical blocks logical and physical blocks and this physical file system IT issues IO command to device drivers to read and write physical blocks on the disk and and these devices are the are the one who actually performs the I operation okay these devices include Hardware dis or controller cards Etc the io control level it consists of device drivers and interrupt handlers to transfer information between main memory and disk system a device driver can be thought of a translator which has input of high level language like retrieve block 123 and the output consist of lowlevel Hardware specific instructions the instructions specific to Hardware that are used by the hardware controllers which interfaces the io device to the rest of the system okay so the iio control level consist of device drivers and interrupt handlers to transfer information between main memory and dis dis disk system this device driver is a kind of translator which takes the input as high level language like retrieve block 123 and the output consist of lowlevel Hardware Specific Instructions which interfaces the io device to the rest of the system those instruction are used by Hardware controller then comes the basic file system basic file system need only to issue generic commands to the appropriate device driver to read and write physical block on the disk each physical block is identified by its number by its numeric disk address for example drive 1 cylinder 73 track 2 and Sector 10 so each phys physical block what is a physical block sector it is identified by its numeric disk address as we have talked about it the sector address and the sector offset this will give me the address of the world so this is the sector address and it goes like drive 1 cylinder 73 track 2 Sector 10 this layer also manages the memory buffers and cash that hold various file system directory and data blocks okay now comes the file organization module I know it's both but I have to read it all file organization modules know about files and their logical blocks as well as physical blocks by knowing the type of file allocation used which type of file allocation is used and the location of the file this file organization module it translate The Logical block address to physical block address for the basic file system to transfer the file organization module knows about the files and their logical blocks as well as the physical blocks by knowing the type of file allocation used and the location of the file the file organization can translate The Logical I think the same thing has been copied again a translation is needed to locate each block the file organization module includes the free space manager which tracks unallocated blocks and provides these block to file organization module when requested so this is just the theory logical file system manages the metadata information the metadata include all of the file system structure except the actual data as you know metadata is just the data about data not the actual data logical file system manages the directory structure to provide the file organization module with the information of later needs given a symbolic file name it maintains a file structure via file control blocks a file control block FCB anode in Unix file system contains information about the file including ownership the permissions the locations of the file and the contents let me summarize so we have a layered file system implementation it includes application of the programs then comes logical file system file organization module and basic file system this is the core part you can uh read about it here in these paragraphs okay then comes the io control and devices application execute the input output statement logical file system uses directory structure to provide the information to file organization it handles their logical and physical block addresses then this physical file system issues IO command to the device drivers this IO control consist of device drivers and interrupt handlers and these devices are the one who performs the actual ey operations in the next lecture we will see allocation methods let's learn allocation methods methods for allocating disk space to files directories or any other data structure we had this kind of disk parage it included BCB the PCB directory structures and here it was the data blocks which contained the user data so the data blocks these are numbered like this there are two properties of data blocks their address and their size the size will be in bytes and the address will be in bits 2 to power DBA will give you the total number of dis blocks in the in this area so DBA equals to 16 bits so there will be 2 power 16 blocks DBS equal to 1 kilobyte so if someone ask you maximum possible size file size this will be equal to this area which means total blocks into block size block size is given here total blocks you can find by 2^ DBA and then multiplied by DBS this will give you the maximum possible file size of disc dis size now there are several methods for allocating the blocks to file like contiguous noncontiguous and index allocation in contiguous there will be internal fragmentation in the last block external fragmentation yes increasing file size that is inflexible let's see with the help of an example suppose this is my file this is another file this is another file this is another file so in this way the blocks are located to files okay now how internal fragmentation can be there suppose my file needed 2.1 blocks so the two blocks will be located and the third one has to be allocated although it will need only the point one of it in this manner internal fragmentation now how external fragmentation let's say let's say there are four blocks 1 2 3 and four or let's keep it to five now these two blocks are allocated these two blocks are allocated now there is another process which needs two block can it be given no this this block will be wasted external fragmentation increasing file size I want to increase the file size take the same case 1 2 3 4 5 I want to increase the file size these two blocks are allocated these two blocks were allocated I want to increase the file size of this file with two blocks can I no because the two blocks are not available that's why increasing file size is inflexible or not generally possible so plus two blocks may not be available and how can it be accessed using sequential or Random Access like an array and it is faster now comes the noncontiguous allocation or linked allocation wherever you find the block use it but you have to link it see this block allocated first see I find this block free all allowed then I find this block free alloted but you have to you have to create create a link list of it otherwise how are you going to find that after accessing this block which block I have to access so there will be a kind of linked list okay so this directory contains the file name Jeep start is at 9 and end it as 25 so this is the start here it goes first then here then here and there it ends so in this manner I hope you got the idea wherever block is free allot it and then link them with the link list internal fragmentation yes see the point is same suppose I need 2.1 blocks of the data then what will happen if I need to point one blocks for a file then two blocks will be allocated and third one will also be allocated although only point one will be used rest of the space will be wasted internal fragmentation is present but external fragmentation is removed how initially when we had the continuous allocation these two blocks were allocated to a file these two blocks were allocated to file suppose now a new file comes which need two blocks I can't allot it but here I can I allot a block somewhere else then I link to this block and allot it now in this manner external fragmentation is reduced increasing file size yes I can increase the file size suppose I want to increase the file size of this of this process firstly I will allot this block and the other block wherever free types of access here this is the problem here the types of access will be only sequential because how can I reach how can you reach to this block without going like this because you can't have address of this but in in contiguous it works like an array so it works like an array you can either have sequential access or direct access like an array it is faster in linked list you cannot access the seventh node directly you have to start from the head and hop to the next to next node and next node and then you will reach the node you desired so the type of access will be only sequential and slow performance pointers consume dis space there is another overhead here and vulnerability of pointer is suppose this was the first node and this pointer got broken the whole file is damaged now so if vulnerability of pointer is they can get broken and will truncate the file this will corrupt the whole file now comes the third one is indexed allocation of disk space what will happen in this each file will maintain an index block index block hold address of the data blocks of the file in this manner suppose 19 is the block which is containing the address of all the blocks which is present in the file so here is a file named Jeep the index block is present at Block 19 it contains the the address of those block which contain which contains the data uh data of the file the 9th one the 16th one the 25th one first block 10th block so in this manner they all will be connected now again a vulnerability if index block got damaged then the whole file will be gone but this index block does not contain the data it contains the array of the addresses of those block which has the data so there are no block to block links index itself is pointing to all blocks okay see this question have DB equal to 16 bits DBS which means size is 1 KB maximum file size with one index block easy question you just need to find the number of block addresses index block can you store these many blocks will be present in the file and then you multiply with the D the data block size and you will get your file size so you have to find the number of addresses these index block this index block and is stored let's say x number of addresses size of each address is 16 bits and the size of index block is 1 KB so here I got X = to 2^ 9 so this index block can store 512 addresses each of each address has 16 bits in it so this index block can point to 512 blocks each of size 1 K so what will be the file size5 MB see this another question a file system support the data block size to be 4 KB each block can hold 512 addresses the size of DBA in bits will be same question just the opposite way the size of the data block which is 2^ 2 into 2^ 10 into 2^ 3 for this bite to bit conversion because we want the address in bits so 2^ 15 bits is the size total size of a block and it is given that each block can store 512 addresses so how many addresses will be or what will be the size of each address let me repeat the size of a block which can store 5002 addresses so what will be the size of each address here I get X = to 64 bits this was the indexed allocation now the question is can I increase the file size yes take more than one index block then you can increase the file size performance internal fragmentation yes external fragmentation no because here also noncontiguous allocation is there can I increase the file size yes it is flexible type of access will be both sequential and random which means it is similar to array reliability more than linked as no pointers but if index block got damaged then the file will be gone space overhead some disk space will be consumed for index blocks because if the file size is more then there will be more index blocks and if more index blocks are present then the overhead to store those index blocks in the disk will also be there so this is the drawback case study Unix or Linux each file node is associated with I node let's say we have a file named gy. C associated with iode 23 or this is the Block in which the I node is stored it contains some general attributes like type owner date and time size Etc and then comes the Block in use it contains the 10 direct dis block addresses it contains the 10 direct dis block addresses so how much size will be contributed by this block or this area I can say 10 direct dis block addresses each of size let's say 1 KB so 10 KB will be contributed by this now what happens I need more so I will point to an index block which will point to several data blocks so in this manner here is the single indirect disk block address it points to an index block which points to the several data blocks let's say the index block can store 512 addresses so how many data blocks it is pointing 512 data blocks each of size 1 KB so how how much size this is contributing 512 into 1 KB which means 512 KB now comes the more the double indirect pointer here is the block which points to the index block can you imagine here we had the direct addresses here we have we are pointing to an index block which contains several dis block here we have a block which points to the several index block and each index block is pointing to the several data blocks or disk blocks whatever you want to call so this in this block is pointing to 512 index block each index block is pointing to 512 data blocks and the size of each data block is 1 KB so the total space contributed by this will be 256 MB you get it what it is written here we have mode owners time stem size block count we have direct blocks where we store the addresses of the blocks directly we have single indirect in single indirect what we do we store the index block address here the index block is pointed and then this will point to the later uh dis blocks or data blocks in this double indirect this block will point to several index blocks and these several index block will point to the more dis blocks and triple indir you can guess we have a block which is pointing to the index block this block is pointing to the more index blocks and this block is now pointing to the the data blocks so the level are increasing see if I if I ask you what will be the size contributed by triple indirect then 2^ 9 into 2^ 9 and then more 2^ 9 this will be the answer 2 power 27 KB see when we had a single indirect then only 1 * 2^ 9 when we have double then 2 * 2^ 9 we have when we have triple then three * 2^ 9 in this manner now comes the second case study which is dis operating system or Windows operating system we have a directory like this we have a file named jy. C we here we have other attributes and the block info is stored like this the first dis block address and the last dis block address but here the first and last is written only what about the middle ones so how to get information about other blocks here should be blocks not tables so how are we going to get information about other blocks with the fat file allocation table or we also call it as Master file table it is like this it contains the entries number of blocks but these contains the address of the next block see here this is the master file table here we have a starting block 217 this will contain the address of the next block we have to go to so we go to 68 now 618 contains the address of the next block we have to go to 339 this will contain minus1 which means end here so the starting block quiz 2117 and the last block is 339 so this is how it works so it is like the link allocation but it is array based so this will contain the information about all the blocks see here it is written the first block is five so we move to the first block then we know we have to move to three we move to three then here it is written seven so we move to seven one move to one then move to two we move to two then move to four four then move to six six here Eight Is the End okay if we move to 8 there then nothing is present so from 5 to 8 our uh this entry is written so it is like this first go to 537 1 2 4 6 8 so this is the first and this is the last with the help of Master file what was the full form Master file table we can get the information about the middle one blocks also okay consider a consider a uni I node structure that has has eight direct dis block addresses and three indirect dis block addresses namely single double and triple okay dis block size is 1 kiloby and each block can hold up to 128 disk block addresses calculate the maximum file size with this IOD structure so we had eight direct dis block three indirect dis block namely single double and triple okay so we have eight direct and three indirect single double and triple the size of one dis block is 1 KB and a block can hold one 28 dis block addresses okay so we have eight direct dis block address so from here I can get 8 KB directly from the direct dis block addresses like here from direct I got 8 KB from indirect now indirect has three single double and triple from indirect I'm going to get 128 into 1 KB because a single block can store 128 addresses of the blocks so it will point to 128 blocks each of size 1 KB so from this indirect single I got 128 KB from indirect double just two times for triple take three times and all add all of them you will get the maximum size should I repeat okay what we had we had eight direct dis block addresses and each of size 1 KB so 8 KB I directly got from here then I had three indirect dis block dis block addresses of single double and triple so I had the first one is single the second one is double and third third one is triple the single block is going to point to 128 blocks each of size 1 KB so this will point to 128 this will contribute to 128 KB space now the double one this will point to an index block this will point to 128 index blocks which can point to 128 blocks each index block is going to point 128 blocks and one single block is going to point 128 index blocks so 128 into 12 128 at this level and 128 this level here 1 KB for each so I'll get for double 128 Square KB for triple this will point to 128 index blocks and this will again point to 128 index blocks and this will here now will point to the 128 blocks each of size 1 KB 1 KB so 128 at this level 128 at this level 128 at this level and 1 KB here so I'll get 128 to^ 3 KB now when you add all of them you get the total size the maximum file size with this IOD structure size of dis block address each block is of size 1 KB it can store 128 dis blocks so each of size 1 KB so 8 K bytes equals to 128 into DBA you can just find it that DBA consist of 64 bytes is the file file size possible over the given dis the maximum file size we had was 2 GB and the maximum dis size will be you remember how we can find the maximum disc size 2 power DBA into DBS so what is DBA DBA is 2^ 6 bytes so it will be 2^ 2^ 6 which is 2^ 64 this is way higher than 2 GB which is just two uh 2^ 31 so yes this file is possible over the given disk okay yes so it is possible another question the index node I node of a Unix like file system has 12 Direct One 12 12 direct one single indirect and one double indirect pointers the dis block size is 4 KB and the disk block address is 32 bit long the maximum possible file size again the same pattern you can do this same pattern we are going to follow we get the answer as 4GB the data blocks of very large file in the Unix file system are allocated using see if it is a very large file you can see here you can see here if I allot continuously I will get very little memory I will get very little space when I when I directly given when I have directly pointed to the blocks I got 8 KB when I had indirect sing single extension then I had 128 KB when I had double extension then I had 2 power 14 KB triple extension I had 2 power 16 KB so I cannot uh I cannot allocate file of very large uh size with continuous allocation no index no this indexed allocation somewhat gives a hope but here it is written very large file so I would need like triple or uh quadruple indirect pointers I need like this as I increase this number of blocks here this 128 will keep on multiplying in this manner with see we are extending when we extend more I will get more memory I will this will contribute to the more space with with the help of an extension of index allocation the data blocks so very large file in the Unix file system can be allocated using large using a larger Block in a fixed block size file system needs to better disk throughput but poor dis space utilization why poor because we have internal fragmentation and why better disk throughput because number of bytes you can read with one dis XIs are more so if I use a larger block size then po dis utilization because of internal fragmentation and better disk throughput because we can read more bytes with just one dis access another question a file allocation table based file system is being used and a total overhead of of each entry in the file allocation table is 4 bytes in in size given a 100 into 10^ 6 bytes dis on which the file system is stored and data block sizes 10^ 3 bytes the maximum size of a file that can be stored on dis in units of 10^ 6 byte is so let's call 10^ 6 as Sheba entry size is given as 4 bytes here it is written four bytes now we have to find number of blocks in the file allocation table so we call this 10^ 6 as Shiba and so I will call this as the 100 shivba this 100 into 10^ 6 by is 100 Shiva so the number of blocks I get as dis size upon block size so the dis size is 100 shba and the block size is this 10^ 3 so I'll get .1 Shiba blocks in the file allocation table and you know what Shiva is 10^ six okay now maximum file size will be given dis dis size minus file allocation table size because see here this part is also going to consume some space this will cause overhead so the maximum file size will be the total dis size minus overhead so how how much size I have the total disc size is dis size is 100 shab bytes and the file allocation or the file allocation table what is the total size of this4 shba how I got this point4 see the each entry size is4 the each entry size is 4 byte and number of entries are .1 sheiba so I'll get4 sheiba bytes for this uh file allocation table size so the maximum file size can be 99.6 shab bytes easy question just to confuse you the main concept was the maximum file size will be given dis size minus overhead you have to also take account of this file allocation table size see this is not less if you if see I have written Shiva here which is creating an impression that it is so less this Shiva is 10^ 6 now you can just imagine how large this is in the next lecture we will move to the file management part three consider a file system that stores 128 dbas in the index table of the directory the block size is 4kb if the file size is less than 128 blocks then these addresses act as direct data block address however if the file size is more than 128 blocks then these 128 address in the index table point to the next level index block Each of which contain 256 data block address so this is what it is if the file size is more than 128 block then it will point to the block it will point to 128 block each block will point to 12 256 blocks each of size 4 KB so 128 into 256 into 4 KB you're getting the point these are these are 128 blocks each block will point to 256 blocks or I can say now here they are the direct data blocks so these 128 blocks will point to 128 into 256 data blocks each of size 4 KB so what is the maximum file size in the system if the file size is less than 512 KB then 128 address act as the direct data address if the file size is more than 512 KB then this way it will work so the maximum file size is 128 MB now don't wonder where I got this 512 just multiply them 2^ 7 into 2^ 2 by that is 512 KB this 512 is the limit for direct addressing if the file size exceeds this 512 then we need to move to the indirect and how the indirect will work here it is given so following that we find that the maximum file size is 128 into 256 into 4 KB now calculate we'll get 128 MB another question a file system system with a one level directory structure is implemented on a disc with a dis block size of 4 KB each block has a size of 4 KB the disk is used as follows dis block zero contains the boot control block so the boot control block will take up size 4 KB dis block one it contains file allocation table consisting of 10 bit entry per data block representing the data block address of the next data Block in the files so this file location also consumed 4 KB block two and three will contains the directory 32 32bit entry per file so this will consume 8 KB block four now here we have we have the actual data blocks so this was just the overhead and from now we got to the actual data blocks so the question is what is the maximum possible number of files this is what it looks like boot control block for dis block zero block one contains is the file allocation table each entry is of 10 bits directory of 8 KB because we are using two blocks here and the entry is the entry size is 32bit from here we got the data blocks so the maximum number of files and maximum file size we have to calculate the directory is taking 8 KB and what is the entry size the entry size is 4 bytes so the number of files directory points to to what the file each the entry is taking 4 byte and the total size is 8 KB so how many addresses are there 2K addresses which means how many entries are there 2K entries which mean how many files are there 2K files and the file allocation table contains 10 bit which is nothing but the data block address because in file allocation one this block will point to the block which we have to go to the next my English is so bad in file allocation table this block will point to the the block which we have to go next so this will be the F entry of 10 bit it is nothing but the data block address so what will be the maximum file size we have done this kind of question what is maximum file size the dis size minus overhead what is dis disk size the total number of blocks into block into block size how many blocks are present 2 power DBA so one24 blocks are present each of size 4 KB now control overhead we have four blocks for this each block is of size 4 KB so 16 16 KB is used up here so 2^ 12 minus 16 KB is around 480 KB so this is the maximum file size and number of files is 2K see this was an super easy question nothing extra was there you just have to calculate the number of files and maximum file size where can I get the number number of files I got the number of files from directory because directory in directory the entries point to the files and from we know the size of the directory and size of each entry from there we will get the number of entries number of entries will tell me the number of files so easy and the second was maximum file size how can how can I calculate the maximum file size total dis size minus overhead we know what is overhead this is overhead these four blocks are overhead each of size 4 KB so overhead is 16 KB now what is the dis size the total blocks total blocks into size of each block how many total blocks are there how I'm going to get that with this we know that f8 contains the block addresses and the block address is of 10 bits so DBA we are given with 10 bits so I can find the total number of blocks are 2 10 each of size 4 KB so from here I got the disk size and then when I subtracted the disk size minus control overhead I get the maximum file size in the next lecture we will see disk Free Space Management algorithms disk Free Space Management algorithm I'm given that the dis size is of 20 bit 20 bytes DBS is of 1 KB and DBA is of 16 bits what will be the number number of blocks so you may proceed with the two ways either you divide the disk size with the block size and you get 20K blocks or you can directly go there and do like this this will also give you the number of blocks so which is correct this 20K is correct or 64k is correct I'll speak again I have dis size of 20 MB and the block size is 1 KB now if someone ask me the number of blocks it will be dis size upon block size which will give me 20K blocks but I'm also given with the dis block address which is 16 bits you will say you taught me that 2^ 16 will also give me the number of blocks so which one is correct thises 20K is correct and or 64 is correct that's what I'm asking is 20K correct or 64k correct the answer is 20K is correct this is the maximum possible so this 64k is the maximum possible number of blocks I have told you so many time what is the maximum size of the disc the maximum size of the disc is 2^ DBA into this this is the maximum size and this is the given size DBA equals to 16 bit so the maximum number of blocks that that can be there is 64k and this 20K are the the number of blocks which are there this is can and this is R okay to refer 20K blocks how many bits are needed five bits for that 20 and 10 for this scale so I'll get 15 bits is needed so we need 15 bits but are using 16 bits so the maximum possible disc size is 64 MB that is maximum possible number of blocks into block size but what is the given dis size is 20 MB so the given dis size will always less than the maximum possible now you may wonder what is the what is the difference between given and maximum what is this I'm talking about the free space available I'm talking about the free space available what can be the maximum amount of free space and what is the available free space this is so now the thing is clear to you this is the available disk size and this will give me the maximum disk size so these are the available number of blocks which are free these is the maximum number of blocks which can be free okay now I think the point is clear so there are 20K blocks which are free so I can store these 20K in form of Link list link list of free blocks so initially the chain of of 20K free blocks will be present suppose out of these out of these 20K blocks I want to allot some block to the file let's say I want to allot these 20 out of these 20K I want to allot 10 blocks to the to some file what I will do I will delete 10 blocks from this 20K linked list and allot to the file and allocate initially a chain of 20K free blocks if I want to allocate some blocks to the file let's say 10 blocks then delete those 10 blocks from the linked list and allocate as simple as that this is what or this is what is the linked list of free blocks if I allocate some file to that block then that block won't remain free that's why we are deleting the blocks which I allowed to a file now comes the free list this is list linked list of blocks containing address of the free blocks this is what the free list is we are not maintaining the linked list of the blocks we are maintaining linked list of those blocks which contain address of the blocks we are not containing the we are not maintaining the linked list of the data blocks we are maintaining the linked list of the address blocks which contain the address of those free data blocks the point is clear how many blocks of the free list are needed to store 20K free data blocks so let's say the entry of or how many bits we are using we are using 16 bits and let's say x are the number of entries what is the block size 1 KB so I can store 512 addresses in one block so I can store 512 addresses in one block so how many blocks I need to store these 20K block I can store 512 addresses in one block let's say I need y blocks to store the 20K so I got y = to 40 so I need 40 address block which contain each of those address block which contain 512 addresses off block this will sums up to 20K blocks the third is bit map or vector it keep track of all the block unlike free list see free list only kept or linked list only kept the track of those blocks which are free but this bit map is going to keep track of all the blocks ass associate a binary bit to each block we are associating a binary bit to each block doesn't matter whether it is free or some file f file why am I staming so much or some file is allocated to that block doesn't matter zero will be for the free and one will be for inuse what does this suggest that first block is free what does this suggest the second block is in use in this manner you go so how many how many bits will be there the number of bits will be equal to the number of blocks how many blocks are there 20K blocks so I will have 20K bits so how many blocks are needed to store our bit map see the total number of bits we needed are 20K and in one block how many bits are stored these many bits so I'm going to need three blocks to store the bit map free list is faster as it keep track of free blocks only no need to search but here we need to search for some block let's say I want to allocate 10 blocks to some file I want to allocate 10 blocks to some file here what we did we just deleted the 10 blocks from the chain of Link list and given to them here what we did we just deleted those 10 addresses from some block and here what we did we need to search for the 10 blocks which are free here searching time will be extra okay so free list or the linked list is faster as it keep track of only free blocks no need to search it keep track of the binary map the bit map or vector keep track of all the blocks unlike free list so we need to search which blocks are free the fourth is counter method when we have continuous free blocks then what we did we just write the starting free dis block address and the number of continuous free dis blocks so from block five to 45 more blocks till this the memory is free from this from disk block address 85 to 200 more blocks the memory is free so this is how we write let's say we have a file of 20 blocks now which block we need to allocate similar to what we did in the partitioning we will follow the same policy first bit worst fit and the best fit first bit is Select from the first entry if the number of free blocks are greater than the number of the blocks which file require alloted what does best fit say choose the least difference the number of free blocks minus the blocks which file require choose that block which has this least difference so here the difference is just five here the difference is 25 here the difference is 180 here the difference is 105 so I will choose the block which has the least difference between the block which are available and the block file needs okay and after allocation we need to update the tle also see if I allocated let's say I allocated 20 block to this now how much are free only five are free so I have to update that tle also you know what is tle the record so we have to update the record also consider a disk with B blocks F of which are free disk block address is dbits disk block size is X bytes we have to calculate the given dis size maximum possible disk size and relation between B and D okay so this is simple and straightforward question number of blocks which we have is B what is the size of each block X so this is the given dis size dis size some of you make a mistake of writing F into X see here nowhere is written give me the dis size which is free or give me the amount of total space available for the files to be allocated or nothing like that is written there's nowhere asked the free disk size it is written that given disk size so the answer will be given dis blocks into size of each block simple maximum possible dis size maximum possible blocks are 2^ D and size of each block is X this is the answer the relation between B and D you know the relation between these two that the given dis size is always less than equal to maximum I can write BX is less than equal to 2^ DX I cancel X from both side I got B should be less than equal to 2^ D this is the relation what is the condition in which free list uses less space than bitmap firstly we have to calculate what we have to calculate the size of free list what was free list fre list contain blocks which contain addresses of the data blocks and these these blocks which contain addresses of the data blocks are connected in form of linked list so this was free list now what will be the size of free list see each block contain the addresses so if I have to find the total size of free list then I have to find the total number of free blocks into addresses of each block address size of each block total number of free blocks into address size of each block what is the address size the address size of each block is d so F into D will be the size of free list see don't complicate it we have blocks in which addresses are there if I see you okay let's keep it simple if I see you this is the complete free list it contained it contained addresses of the free blocks what will be the size of this free list address size of one data block into number of data blocks or I can write address size of one entry into number of entries and how many entries will be there number of entries will be number of free blocks so what is the address size d what is the number of entries F so F into D will be the size of free list what will be the size of bit map the size of bitmap will be number of blocks in bits if you remember what was bit map let's say I have 20K blocks so I will have 20K bits here how many blocks I have B blocks so I'll have B bits so the condition in which free list uses less space than bit map will be F into D should be less than b that's it this is the space used by free list and this is the space used by bitmap it's simple question number two the beginning of free space bit map looks like this after the disk partition is first formated we have this the first block is used by the root directory the system always searches for free blocks starting at the lowest numbered block so after writing file a which uses six blocks the bit map looks like this so for six blocks we'll have six ones 1 2 3 4 5 six the first one is always there for the root the root directory so the system always searches for free blocks starting at the lowest numbered block so after writing file a which uses six blocks the bit map looks like this this is for the root and this six ones are for this file a map after each of the following additional actions as hex code what is hex code in the hexagonal file B is written Now using five blocks okay so this was was just the example okay so if I have written file B then what will happen so this a was the example but here it is written additional actions see this a will be counted and then these actions are performed here it is written already that additional actions initially we have let me Zoom it initially we have this one for the root and rest all zero so I will write this is 8 and this is 0 0 and 0 so XX will be 8 ,000 then what happened file a is allocated six blocks so one was for the root 1 2 3 4 5 6 this is for a so this is 0o this is z what is this triple 1 0 this is e in hexagonal and what is 1 1 1 1 this is 15 so F represent 15 in hexagonal this is what this is 14 this is 15 this is 0 this is 0 so I have written F e0 0 so file B is written using five blocks okay now file a is deleted file B is written using five blocks so this was till a then 1 2 3 4 5 these five blocks are given to file B so f f f for this this is 15 this is 15 this is 15 and then zero f f F0 for this file B is written using five blocks now what happens file a is deleted when file a is deleted so this was for the file B this was for the root and all the ones which we have made for a which means these ones will be made to zero because the file a is deleted so those block will be free now and for free what we write we write zero now we have 81 fo this is 8 this is 1 this is f and this is zero file C is written using eight blocks now file C is written so where we will write file file c 1 2 3 4 5 6 the blocks which we which were initially given to a which are now freed will be given to C so six for six here and two here two additional now what is the uh hex 15 15 15 and C now what happened file B is deleted so what were the ones for file B these were the ones so delete them these ones are gone so I have f e that is 14 0 and C this way this will be the answer it was easy one nothing special was there a file system uses an inmemory cache to cash dis blocks the Mis rate of the cash is shown in the figure so here is the Mis rate this is the cash size and this is the Mis rate when we have when we have let's say 30 MB of cash then the Miss rate is 40% when we have 20 MB of cash then the Miss rate is 60% when we have 50 mb of cash then the Miss rate is 30% as we increase the cash size it is obvious that Mis rate will decrease the read the latency to read a block from the cach is 1 millisecond and to read a block from the dis is 10 millisecond assume that the cost of checking whether a block exist in the cash is negligible available cash size are in multiples of 10 MB so the question is the smallest cache required to ensure that the average read latency of less than 6 milliseconds so what will be the read read latency suppose p is the Mis rate so I can write p and when it is a Miss then I'll have to read from memory plus when it is a Miss then I can read from cach should be less than 6 millisecond so it is 10 p + 1 minus P should be less than 6 so it is 9 P less than 5 so P should be less than 5 by 9 it's around 55% so the Mis rate Mis rate should be less than 55% so where is 55% 55% is somewhere here see now the cash can be either 20 or 30 I have written that Mis rate should be less than 55% if I choose 30 so if I choose 20 then the Mis rate will be greater than uh greater than 55% it will be 60 and if I choose 30 then it will be less than 55% that is 40 so either 60 or 40 what I have to choose the Lesser one that is 40 so where I will get the Lesser one 30 so the smallest cash smallest cach which is required to ensure that average read Laten is less than 6 millisecond or I can say the smallest cash required to ensure that Miss rate is less than 55% is 30 see smallest I can either choose 20 or 30 but P should be less than 55% here the p is greater than 55% see 20 is smaller than 30 but I am also increasing the Mis rate I don't want to increase the Miss rate so the smallest cash will be 30 to ensure that the average read latency is less than 6 millisecond okay so this is what I have written latency of cash is 1 millisecond latency of dis is 10 millisecond so the read latency should be less than 6 millisecond I write the latency formula here less than 6 9 p is less than 5 I got 55% and the Mis rate is p so cash is in size of alpha into 10 MB which means the multiple of 10 MB so according to the graph I can choose 30 only if I choose the smaller one if I choose the smaller one that is 20 then the average average read latency will exceed the 6 millisecond if I choose 30 then it is perfect 30 is the smallest one if I choose 40 yes it is less than in 40 p is less than uh 55% but 40 is not the smallest the smallest is asked so 30 will be the answer 30 MB is the answer the amount of disk space that must be available for page storage is related to maximum number of processes n the number of bytes in the virtual address space is B and the number of bytes in Ram is R give an expression of the worst case disk space required let us read the question again the amount of dis space that must be available for page storage is related to maximum number of process n okay the number of bytes in the virtual address space is B and the number of bytes in the ram is R give an expression of the worst case dis space required see for the dis space there is no relation of or there is no need of this Ram thing to be given I can ignore this ram ram thing because the RAM and the disk space no relation because we want to allocate the dis space see in case of uh let me explain with the help of this diagram suppose I have a process Pi where is this mapped where this virtual address piece is mapped it is mapped onto the disk not on the physical address space physical address space is going to be much lesser than the virtual address space this virtual address space is mapped onto the disk suppose now comes another process then this virtual address space will also going to be maed on the disk so the worst case the worst case disk space required will be number of process into size of each process which is this virtual address space so n into B will be the answer there is no need of R being given so n into B is the answer in the next lecture we will start with the dis scheduling algorithms dis scheduling just like CPU can serve one process at a time similarly the disk can only serve one IO request at a time just like shortterm scheder disk scheder also exist let's move directly to the dis scheduling techniques suppose the process request this track or cylinder number cylinder number 98 then the process want to process want the read right head to go on 183 then on 37 then on 122 14 124 65 and then in the end 67 suppose the read right head is at 53 so total there are from 0 to 199 200 tracks are dist distributed evenly on the surface on the surface there are 200 tracks in such a way and read right head is currently on track number 53 and what requests are made 98 183 37 in such manner requests are made the first algorithm that is fcfs what does this say as as the request comes serve them in that order only first come first sir so from 53 it will first go to 98 from 98 it will go to 183 from 183 it will go to 37 as the request order came 9 98 183 37 from 37 it will go to 122 from 122 to I think 14 yes and then 14 after 14 then to 124 and then to 65 and then to 67 so in this manner the request will be served first first come first serve as the request comes or the order in which the request is made serve in that order only this is what the fcfs says so total six how many are made see from 53 to 98 from 98 to 183 from 183 to 37 in this manner you have to calculate the total se you will get the total seeks are 640 average seek per request will be total number of six upon number of requests so I have around 86 per request which is a high number now comes the shortest seek time first you have this this you have this request order suppose the read right head is now 53 serve those request first in which there will be least seek time nearest closest track next this is the another name nearest or closest track next so from 53 I will go to 65 from 65 to 67 67 to 37 then 14 then 998 then 120 you have to choose the closest one on when on 53 what was the closest track you can go on the 65 then 67 on 67 which is the closest track you can go to 37 so in this manner you have to proceed and here the total number of ss were 640 and now see the total number of six it has reduced drastically it is now just the 236 so the first first one was fcfs algorithm serve in the order as the request order comes serve in that order only B part was go to the nearest or serve the nearest or closest track next this will give you the least amount of seeks then comes the scan algorithm top to bottom and bottom to top serving for scan apart from knowing the position of read right head should also know the direction so from here what are you going to do see here from 53 let's say the direction is in this manner so I will go like this till 99 and whichever request comes in the middle I'm going to serve them see from I have started from 53 53 to 65 65 to 667 then 98 then 122 then4 then 183 now remember 183 was the last request made but what happens it has to do the complete round and then then turn at 199 so from 183 it has to go to 199 to complete the to complete the round or to change the direction it can change direction on the extreme points only what will happen so I'll go start with 53 and then I should also know the direction in which I'm going I'm going in this direction so from 53 to 65 from 53 go till 199 which is the end and whichever request comes in the middle serve them and then take the turn so when you will take the turn then comes what then you have two requests remaining the 37 and the 14 so 37 will come first and then the 14 now you don't have to take the turn again that's why you are not going to the extreme end you just completed where the your last request was that is 14 got the point in fcfs we served in the order which in which the request was made okay so first uh at 53 the first request first request was 98 so from 53 I will go to 9 8 then the second request was 183 so from 98 I'll go to 183 in this manner I served all the request and the total number of seeks I got was 640 the second algorithm is shortest seek time first and this serve the nearest or closest track next so from 53 the nearest track to which I can serve is 65 from 65 the near nearest track is 67 in this manner I proceeded and completed or the served all the request the then comes the scan algorithm top to bottom and bottom to top serving so it is just like the direction you can start from 53 to 199 so this is what bottom to top from less to more and you should remember this point that in a scan algorithm to take the backward turn or to take any turn you need to go to the last you can take turns on the extreme only so from 183 to 199 this was actually not useful but to take the Le we need to go to the extremes okay so the what is the drawback extra seeks plus starvation to the process in opposite direction let's say from 53 to this 199 it took so many time that it it takes so many so much time that this 37 and 14 are being starved suppose the read right head is at let's say 12 the read right head is at 12 and the last uh track can is at 1,000 and one request is at 6 one one uh one process request the sixth track number so from I will first serve from 12 to 13 14 till th000 and then I will turn back and will reach to the six so this this six will be starred for star for so much time so what was the drawback extra six plus star with equation to the process in opposite direction because you have to go till the end to take the turn this was scan the first was fcfs serve in the order of the request the second was shortest seek time serve the nearest track first then scan go in One Direction and then in that direction whichever request process made keeps on keep on serving it and then when you have to take the turn you have to go to the extreme this was a scan now comes the look in instead of going to the last take the turn at the last request exactly rest exactly like this SC so what will happen same manner I will go till 183 now the look algorithm gives an extra Edge that I have I do not have to go to the extreme to take the turn I can take the turn at the last request only also I can take the turn at the last request also no need to go to the extreme this is what the benefit of L algorithm and the rest is exactly like this scan what does look say wherever your read right head is go into the direction whichever is specified keep on serving the uh request made and at the last request of that direction you can take the turn in a scan I have to go beyond the last request so that I can take turn on the extremes here no need to go to the extremes now comes the C scan the circular scan in circular scan you can go in One Direction only so you started from 53 you keep on serving and at 19 199 you have to take the turn but remember you cannot serve while going in this direction you can serve in One Direction only so from 53 you need to go to 199 and after 199 you have to travel back to zero and then move in this direction again to serve the 14 and 37 you got the point in C scan the circular scan you can serve in One Direction only so from 53 to 199 you made the six and then from 199 to Zer back so that you can move again in this direction to serve the remaining 14 and 13 so how many six will be made from 53 to 199 and 199 to 0 and then 0 to 37 remember that these six will also be counted when you are coming back this will also be counted okay now comes the C look similar what does the look algorithm gives facility or what facility does the look algorithm gives the look algorithm says you need not to go to the extreme to take the turn you can take the turn at the last request also so if I ask you what is circular look similar from 53 to 183 and then when you come back no need to go to the extreme from 14 you can uh go to the 307 but remember it can serve in One Direction only now let us summarize again all the algorithms the first was the fcfs in fcfs what we did we served in the request order the order in which the request was made I served in that order only then comes the shortest seek time first serve the closest track then comes the scan go in One Direction keep on serving the request in that direction and then in the end after going to the extreme you can take the turn and when you are coming back whichever process whichever process requests are made in that direction you can make but no need to go again to zero because I do not have to take turn again see from 53 to 99 I moved in One Direction now I have to take turn that's why I have to go to the 199 otherwise if the request were only from 53 to 183 then I will just go in this direction but now what happens I have two other request waiting for me on the other side so I have to go beyond 183 to the extreme take the turn and serve in that order now there is no request on or there is no request which demand the Uturn again so I will not go to the extreme I just end at the 14 okay this was scan then comes the look similar to scan but what facility it gives no need to go to the extreme to take the turn you can take the turn at the last request also so I'll go from 53 to 183 and then from 183 I will go back to 37 and 14 end C scan you can serve in a single Direction only and you have to count when you are coming back you have to count those six also so from 53 to 199 I will go and then from 199 to 0 and 0 to 37 the see look the look algorithm always gives the facility do not go to the extremes 53 to 183 from 183 back to 14 and then 37 so instead of going to 199 and 0 it goes to 183 and 14 only okay in the next lecture we will see some problems on it then our file management section will be over after that we will start our miscellaneous topics consider a dis que with a request for io2 blocks on cylinders same as trct number 47 38 121 191 87 11 9210 the cook scheduling algorithm is used the head is initially at a cylinder number 63 moving towards largest cylinder number on its serving path so we are given with a current head location and the direction in which it will move the cylinders are numbered from 0 to 199 so these are the extremes the total head moment incurred while serving these request is we have to calculate the number of sixs and and which algorithm we are using cook algorithm what does cook say this is circular look you can serve in One Direction only but no need to go to the extremes so from 63 I'll move to 191 from 191 to 10 and from 10 to 47 sum them sum them all and you will get 346 as the number of head movements or number of seeks made another question given the requests and you have to solve using the first fcfs and the second one is s test seek next you can solve this an easy question consider a storage disc with four platters numbered as 0 1 2 3 so we have four platters and 200 cylinders number from 0 to 199 so we have four platters and on each surface we have 200 cylinders and 256 sectors per track and we have 256 sectors per track these are the track these are the surfaces uh not surface the sectors sorry there will be two surface on each platter there are four platters there will be 200 tracks on each surface and 256 sectors on each track the following six request of the form sector number cylinder number platter number are received by the disc controller at the same time so these are the request received this is what this is the sector number this is the cylinder number and this this is the platter number so on platter 2 go to the track 72 and or read sector number 120 this is what this say a b c this says on platter C go to the sector number or go to the cylinder number B and at that track go to the sector number a the first represent the sector the second one the track and the third one is the platter so these request I have received currently the head is positioned at sector number 100 of cylinder 80 and it is moving toward higher cylinder numbers the average power dissipation in moving the head over 100 cylinder is 200 M and for reversing the direction of the head moment once the power used is 15 Ms see these are these are the kind of question meant to scare you like the big big things are given so that you may get confused no need to get scared from this question just write the things down which are written power dissipation associ ated with rotational latency and switching of head between different PL is negligible so there is no power dissipated for rotational latency and switching the head between platters okay so here it is written that we have to switch the head between platters for this question assume that there is only one read right head okay there is only one read right head and there is one surface only at each platter because there is no concept of surface here and only one redite head is present and for each surface for each request I have to move this redite head for let's say here is the platter two so I will I will be at the platter two then the request is from platter one then this read at H will move to the platter one assume for this question the total power consumption in mwatts to satisfy all the about dis request using shortest seek time first dis scheduling algorithm is easy question no need to get scared what is given we are given with the platters that there are four platters 200 tracks on each flatter and 256 sectors on each track so these are the request made the sector number the track number and the platter number if you notice clearly there is no need for this platter number as you know that moving to a certain platter moving to a certain platter needs moving to a certain platter dissipates no power and moving to a certain sector also dissipates no power because it is written here that power or dissipation associated with rotational latency and switching off head between different plers is negligible this will cause the rotational latency see when we are on a certain track and when we have to reach to a certain sector then rotational latency is accounted but here it is written that rotational latency is negligible so we just have to reach to the correct track on the correct platter but here it is also written that there is no need for going to the correct platter also see this is just a way of saying here assume that all of them are on the same platter with no uh read latency rotational latency getting the point see you can do this older way uh you can take account of all these things and drag them all the way to the question to the end of the question but there is a smart move you can make here it is written that power dissipation associated with rotational latency and switching of head between different plers is negligible so I have to reach just to the current track just to the correct track when I'm on the correct track then everything is sorted because known power disspation for this no power dissipation for this so the actual request we have to consider is this only okay so here single Rite head for multiple patterns that I already told now extra things are given what is that given the current head is positioned at sector number 100 of cylinder 80 so the current head is at track number 80 moving toward the higher cylinder numbers okay so from 80 it will go to I think 199 this will be the direction to move the average power dissipation in moving the head over 100 cylinders is 20 MW so from for 100 track seeks 20 M Power will be gone for one track seek 1x5 M Power will be gone I just divided 20 by 100 for reversing the direction 15 Ms is needed power dissipation the two two of the things are dissipating the power switching the heads and the the rotational L switching the head is causing zero power dissipation transferring the track transferring the re right head from one track to another that is causing the main power dissipation and the second reason behind the power dissipation is reversing the direction see we are not using the scan or look algorithm here we are using the shortest shortest seek time first so this will going to cause a lot of Direction changes see here these many Direction changes are made so I have to take account of this reversing the direction uh Power dissipation also so these were the request made where I am I am at the 80th track number so from 80 where I have to move I have to move to 86 for then I have to move to 76 then 116 then 134 then 20 and then 16 in this manner I have to move based on this shortest seat time first dis Shing algorithm so the power dissipation will be from 80 to 86 firstly I will calculate the power disspation of seek only from 80 to 86 6 from 86 to 70 to 14 14 SS are made from 72 to 116 44 SS are made from 116 to 134 18 SE are made and then from 134 to 20 114 SE are made from 20 to 16 46 are so total number of ss are 200 and what is the power dissipation uh caused by one seek 1X 5 m so what will the power dissipation just by the seek it will be 40 m just by the seeks now for the Now power disp caused when read right head changes its direction the the first Direction Change made is here it was going here and then it changed the direction the second Direction change was made here it was going here and it made it changed the direction and the third was made here here here and here so three Direction changes are made so 45 + 40 gives me 85 M you get the question what was it see whenever you see a such kind of big question remember most of them are meant to scare you these it it the question has so many irrelevant information that was not even needed that was not even needed if I instead of giving this this whole thing if I just give you hey look I have this request you have to you have to solve this using shortest seek time and remember for one seek time 1X 5 m is needed or the power is dissipated and for reversing the direction 15 M power is dissipated can you give me the total power dissip it was an easy question it was so easy you have to just apply the shortest seek algorithm and calculate the number of SE the total sixs made were 200 multip it by 1X 5 you got 40 and calculate the total number of Direction changes first Direction Change here second was here and third was here so the total Direction change caused the power dissipation to be 45 40 was due to six so I got 85 this was an easy question but as soon as I have given this I have uh Twisted the question and added some irrelevant information there this may have Disturbed some of you what was given consider the dis stage let let me tell you which of the following information was just to uh distract you the four platter information was just to distract you this number from 0 to 123 200 cylinder this was useful information was this useful see this 200 cylinders was this useful we are using shortest seek time first we did not even use this 200 cylinder this was also the irrelevant information 256 sectors irrelevant information the following six request was made this was Irrelevant this was irrelevant no cylinder number was required pler number was irrelevant so irrelevant irrelevant needed and then currently the position sector number 100 this was needed uh sector number 100 no need the track number 80 yes it was needed moving toward higher cylinder number was it needed yes it was needed the average power dissipation yes it was needed to calculate the power dissipation for one seek and then reversing the head yes this was needed the power disp Associated see this was the gamechanging line the power disp associated with rotational latency and switching off head between different players is negligible this was the game changing line the total power cons so you can see how much information was just to distract you okay what would have happened if what would have happened if it was not written that the rotational latency is not negligible and the switching the head power is also present then this information would be useful okay so for every request I have to add I have to add the rotational latency and the time to switch the heads so this was a this was I can say a nice question let's move to another one suppose a dis has 2001 cylinders numbered from 0 to 200 at some time the dis arm is at cylinder number 100 and there is a q of dis AIS request 3 to 145 if the shortest seek time first is being used for the scheduling dis dis access the request for cylinder 90 is serviced after how many number of request or service serviced after number of request easy question you can do it yourself so from from 100 I will go to 105 first then2 then 90 so after how many request it was served see first this request was served then this request and then this request so after three request 90 will be served do not make a mistake to calculate the jump instead of request do not make a mistake to ignore this 100 see this is also a request this will also be served after the serving of this request you go to the 105 and then to 110 and then to 90 okay another question consider a consider an operating system capable of loading and executing a single sequential user process at a time this is just another name of uni programming operating system the dis head scheduling algorithm used is first come first serf if fcfs is replaced by shortest seek time first claimed by the vendor to give 50% better Benchmark result what is the expected Improvement in the io performance of the user think about it and read the question again what was it saying the operating system is uni programming if the operating system is uni programming the scheduling topic is insignificant for uni programming operating system so it doesn't matter whether you use fcfs or sstf it will it will not matter for uni programming operating system there is no such kind of uh there is no significance I can say of the scheduling so what is the expected Improvement in the io performance 0% did you get it see what happens just like the CPU scheduling topic what happens in the disk scheding there are multiple request at a given time now the disk scheduler has to choose which request it has to uh serve just like the CP Shing technique there were multiple process available in the ready CU ready to be run on CPU so the CPU Scher has to choose which process out of these I have to uh take to the CPU in the similar way for the dis Sher there are multiple IO request now it is on the dis scheduler which I request it will serve but what happens there is only a single process in the memory so this will generate a single this single IO request only no multiple IO request case no dis scheduling thing the pro the request which is made just serve it because there is only one request the scheduling topic was significant when there are multiple things at the time and you have to choose one just like in the CP Shing when there are multiple process in the readyq you choose out of those multiple you choose one process in dis scheduling out of the multiple I request you choose to serve one but if the IU request is only one then there is no concept of being of dis schuling so there's no concept of using uh fcfs or sstf whether you use any of one of them you will get the same result so what is the expected Improvement in the io performance of the user user program 0% another question consider a disk with the following pertinent details is the track track time is 1 millisecond or I can say one seek time is 1 millisecond current head position is 65 and the direction it will move will be for the higher tracks the current clock time is 160 millisecond okay consider the following data set we are given with the request serial number track number and arrival of the request time or the time of arrival of the request calculate the time of decision at which time we have to take the decision the requests which are pending the head position the selected request to be served seek time using fcfs all these things I will solve using fcfs and for rest of them it is homework to you so what happens we are at the time the present is at the time 160 millisecond these request request one request two request three and request four has already been made so at time 160 what are the pending request 1 2 3 4 at which time we have to take the decision current time we have to take the decision immediately to choose which of the following request I will serve what is the head position 65 the selected request will be the one which came first I'm using fcfs so who came first 12 uh the request for track number 12 came first what will be the seek time from 65 to 12 53 seeks into 1 millisecond as I am given the track track time is 1 millisec so after the request one is served what is the time now 160 was already there and 53 millisecond was also taken to serve the process the serve the request one I'm sorry if I say these as process these are the request so 160 + 53 23 will be the current time of the decision when I have to serve the these request which request one was already served 2 3 4 was already present and at time 23 this five would also have came at it came at 175 millisecond so the request which are pending now 2 3 4 5 the head position is at now 12 which request I'm going to serve next who came next this 85 the track number 85 so request to for track number 85 so from position 12 I'll move to 85 the total number of seeks made are 73 the seek time will be 73 millisecond now after the request two is served after 213 and then 73 will be added 3 and 36 718 286 this is the current time any new request made no the pending request are 345 what is the current time 286 and we have to make decision here at 286 which head position I will go the one I at the head position 85 now where I will go the one who came next who came next at 140 so from 80 85 I'll move to 40 how many SE are made 25 SE are made not 25 I think I moved to from 85 I moved to 40 45 SS are made so 45 milliseconds will be the seek time so in this manner you have to proceed and complete till the end so this was for the fcfs you have to solve for ssf scan look C scan and C look algorithm to get hold of these uh dis scheduling algorithms you will get Mastery over this we have successfully completed our whole file management section and in the next lecture we are going to or in the next section we will complete our miscellaneous topics The Leftovers topics I know this file file management was a little bit of uh theoretical topic but it also contained some of the algorithms and numericals hope you liked it threads and multithreading this will be our first miscellaneous topic let's start what is a thread thread is a lightweight process now you must be wondering why I call it as lightweight we will see it in sometime you know what is process programming execution State let's first understand this example of client server environment we have clients 1 2 3 4 5 6 7 these are all clients and this is our server which has a big hard disk and this is our server process we also call it as Damon initially we used to serve in iterative mode process uh request one was made request one served request three was made request three served request six was made request six served in this manner we used to serve but what happened instead of sequential request some of the clients requested at the same time so what will happen these requested will be queued up in a buffer this sequential serving of the request causes start ation or DeLay So what is the solution for this multiprocess approach or the concurrent servers the concurrent servers or the multiprocess approach now you must remember the difference between concurrency and parallelism okay we are creating the concurrent server not the parallel servers see this this was the server and we have three request cued up here so what it did there were three request pending so it creates three child process independent of each other and request one was assigned to child process one request two was assigned to child process two and request three was assigned to child process 3 so these child process are exact replica of the parent process server so now we have three processes now we have three process in the ricu C1 C2 and C3 we will execute them in the round robin fashion and it will create an impression that their request is being served at the same time what is going on firstly I'm serving for some time request one and then for some time request two and then for some time request three then I again back to request one and then again back to request and again back to request three so instead of sequential serving I created the child processes and each request is assigned to a process and and run those process in round robin fashion it created an impression that their request is being served concurrently but there is a s severe drawback of this uh of this method it is the redundancy of code it is a severe drawback why because code of the server process will be copied as it is in the child process see functionality of all the children will be same we can't we have an architecture in which I will have one section of the code and the resources which are separately needed should be given to each process see the functionalities or the functions are defined in the code and the functionality of these child process are exactly same but the resources are different so instead of giving instead of having different code and different resources for all of the process can't we have an architecture in which the code section remains same I mean functionalities remain same and and the resources which are separately needed should be given to each process in this manner I will avoid the memory and resource wastage this is what the idea of a thread is thread is nothing but a subprocess which will share all the common resources thread is nothing but a subprocess or lightweight process that's why it is lightweight process it is not a full process it is a sub process see this let's say this is the process with code section and resources this is another process with code section and resources another process with code section and resources and in thread what happens this is the shared code section and the resources are given to this is thread one this is thread 2 and this is thread the resources which are separately needed are separately given to the threads and the code section or the functionalities which needed to be same are shared by these threads so all these threads have some shared thing in common and the resources which are separately needed are separately given this is what thread is that's why it's called lightweight process so if someone ask you what is the main reason for multithreading economy the resource sharing okay in this manner it goes see this is the single threaded process and this is the multithreaded process this is the address space it contains code Heap data files registers stack or you can say this single threaded process is nothing but a process only the single threaded process is nothing but a process only each process will have its own code data files register stack Heap but what happens now when we move to the multithreaded process what happens the code data and file are shared but each thread will have its own set of registers and stack each thread will have its own set of register and stack so these are the resources which I was talking about that need to be separately given to each thread and these were the these are the shared thing or common thing okay so this is the default process the single threaded process nothing but the default process and there we it is the thread now the question is is why we throw why we show thread with a curvy line what is the reason behind this because the thread uh when the thread is put like randomly it it is curvy when you put a thread it is curvy so uh the thread is a lightweight and that's why we have given this a lightweight uh process and the thread when kept on something it becomes Curry that's why the line is curry no no not this is not the reason there is a more logical reason behind this so why we are using a curvy line because during the execution of instruction there may be a branch or jump instruction like see here if there is a no Branch or jump instruction I can just put a straight line there but what happens let's say I executed instruction one instruction two and suddenly I have to jump to next instruction then some next instruction that's why there is a curvy line here to represent the branch instructions okay each thread will have its own stack its own function and register okay so each thread will have its own stack and resistors this is single threaded this is multi thread now concurrent servers may be proceeded with two approach the first was the multithreaded approach and the second was the first was the multiprocess approach and the second was the multithreaded approach see here this was the multiprocess approach when we used fork and created the three child processes this was the multiprocess approach and this was the multithreaded approach what we did we kept the functionality part the same and or the code part is the is kept same and the resources which each the thread needed is given separately to them so the request one will be assigned to this thread the request two will be assigned to this thread and request three will be assigned to this thread okay so client will request the server server will create a new thread to serve the request suppose this is a client it requested a server server created a new thread to to serve that request and it will assign that thread the responsibility to fulfill the request of the client and it will resume listening for additional client's request whenever a request clients make whenever a request client make the the server will create a new thread and it will resume listening for the additional client request here are the benefits of the multithread program let's read it the first is the responsiveness multithreading and interactive application may allow a program to continue running even if a part of it is blocked or performing a lengthy operation thereby increasing responsiveness to the user this quality is especially useful in designing user interfaces for instance consider what happens when a user clicks a button that result in the performance of time consuming operation a single threaded application would be unresponsive to the user until the operation had completed but what happens in the case of multithreaded in contrast if the time consumer operation is performed in separate thread then the application remains responsiveness to the user for the remaining threads so what what it is saying that if it is a single threaded process and we assign This Thread some lengthy task then this application will be unresponsive until this task becomes complete so this was the single threaded process now what happens in the multithreaded process what I do I assign This Thread the leny task and these two thread will be still working so multithread process bring or multithreaded program brings responsiveness okay the second is resource sharing process can only share resources through techniques such as shared memory and message passing such techniques must be explicitly arranged by the programmers however thread share the memory and the resource of the process to which they belong by default default the benefits of sharing code and data is that it allows an application to have several different threads of activity within the same address space obviously this is also a point that when process Shar resources it has to use techniques like shared memory and and message passing Etc but when thread share resources it happens in the same process threads belongs to same process and when the process share suppose these are the two process and when they sh share some resources they had to do by shared memory and message but the thing or the case with the threads is they belong to the same process they share the memory and resources of the process to which they belong by default the benefit of sharing code and data is that it allows an application to have several different threads of activity within the same address space Okay the third is economy allocating memory and resources for process creation is costly well when you uh give all the resources to all the processes that is going to uh harm your economy because threat share the resource of the process to which they belong this it is more economical to create in context which threads yes yes that that is the point contact switching of process is way more costlier than the contact switching of threads EMP EMP empirically gauging the difference in overhead can be difficult but in general it is significantly more timec consuming to create and manage process than threats in Solaris for example creating a process is about 30 times more costlier than creating a thread scalability the B benefits of multithreading can be even greater in multiprocessor architecture multiprocessor means when we have more than one CPU so the benefits of multithreading can be even greater in multiprocessor architecture where thread may be running in parallel on different processing CES a single threaded process can run only on one processor regardless of how many are available we can explore this issue further in the following section okay so the scalability economy resource sharing respons as all of them tells that multithreading is better than multiprocessing again improved performance due to less contact switch each thread will have its own control block just like PCB of it's just like the PCB of the process as we have PCB for the process we'll have TCB thread control block for Threads and you know threads are called as lightweight process so it is General thing that or it is obvious thing that size of TCB should be less than the size of PCB if the size is less then contact switching or the thread switching time will be faster than process switching time well what we switch while contact switching of the process and threads TCB and the pcbs and if size of one is smaller than the later then obviously the thread switching time will be faster than the or thread switching will be faster than the the process switching so these are the benefits of using a multithreaded program in instead of multiprocessing the sixth is it can utilize the multicore architecture and Achieve parallelism see what it is saying suppose I have a single I have a single threaded program or I will say I will have a process in which there is only one thread this process can be assigned to a single CPU here we have multiple CPUs I'm talking about multiple processor architecture so what happens this is a single process it is assigned to let's say C1 CPU the rest C2 and C3 are empty or C idle but what happens in the multithreaded process I can assign each thread to a different CPU hence utilizing properly the M multicore architecture or multiprocessor architecture and it achieves parallelism this is the actual parallelism see what we are doing there wait it will load yes here we are not using parallelism here we are here we are using a concurrent approach you remember the difference between concurrency and parallelism in concurrency we deal with different things at a time first we are uh first we are uh executing the child process C1 then child process C2 then C3 in round robin fashion but at a time only one is being executed this is concurrency we are dealing with different things at a time but what was parallelism parallelism is we are doing the different things at a time so at a time this thread will also being executed This Thread is also being executed and this thread is also being executed this is parallelism okay let's summarize what we have what we have discussed thread is like a lightweight copy of process that executes independently threads share the same address space each thread has a separate program counter and may run over different parts of the program each thread has a separate stack for independent function calls so these this is the summary here more information threads versus process a thread has no data segment or Heap a thread cannot live on its own it need to be attached to a process there can be more than one thread in a process each thread has its own stack if a thread dies it stack is reclaimed a process has code Heap stack and other segments a process has at least one thread well you know the single threaded process are by default or a process is by default a single threaded process heads within a process share the same code files if a process dies all thread dies well threads lives inside the process if a process dies all threads will die if one thread die then other thread may live but if a process die then all threads will die now comes the fork thing parent P Fork a child c p and C does not share any memory this C is exact replica of the process P the child C or the process C is exact replica of process B all the resources which were allocated to process B will also be allocated to process C it need complicated IPC mechanisms to communicate you remember when we have discussed a full full section that how process synchronized how process coordinate how process communicate and you know how complex this was that was but in thread there is no such thing we do not need a complicated IPC mechanism they all reside in the same process so for for communication between two process we need comp complicated IPC mechanisms to communicate extra copies of code data in memory redundancy is present now let's see parent P execute two threads T1 and T2 T1 and T2 share parts of the address space Global variables can be used for communication see this simple instead of using complicated or complex IPC mechanisms which we have leared learned about set and lock or thread uh the Peterson solution Decker solution all this all the that complicated stuff we do not need here just the simple Global variables can solve our purpose and smaller memory footprint so simple so it says multithreading is much more economical than multiprocessing parallelism a single process can effectively utilize multiple CPU CES understand that difference between concurrent and parallelism well I have discussed it already that a single process here is a single process with multiple threads can utilize the multicore architecture I will assign This Thread to C1 This Thread to here this thread to C3 these are the CPUs each thread will be assigned to a different CPU and therefore I can utilize the multicore or multiprocess architecture effectively but if there are multiple process if there are multiple process and a sing CPU then what will happen I will use concurrency see in concurrency you remember the example of that coffee machine in a single coffee machine with two lines first it serve let's say of males and then of females first male comes then females then females and male in such manner it serves sometime this process sometime this process sometime this process sometime this process but what happens when we have two coffee machines mail line here the female line here okay so when we are talking about the case of two coffee machines that is parallelism when one coffee machine serving two lines that is concurrency types of thread so there are two types of thread the user level thread and the kernel level thread user level thread is threads that are created and managed at user level without any operating system support flexibility given to users and here in the kernel level threads are directly created and managed by operating system kernel level threads are the part of process but managed independently by the process so here operating system has the complete control here operating system gives the flexibility to users to create threads so these These are the user level threads we manage the creation at user level with the help of some package or Library okay let's see the benefits operating system is not able to see those threads it will see it as a process it is good as well as bad we call this as transparency well it seems something opposite but that's how it's called I have checked on every platform when operating system is not able to see those threads it will see it as a process when this happens well actually the meaning of transparency is everything is clear but here when operating system is not able to see those threads then we call it as transparency flexibility is given scheduling and assigning the threads all is at the user level see why this is good as well as bad because operating system has now no control over the you or operating system doesn't give uh much Focus to those user Level Threats so each and every responsibility will come to a user now it will create complication while writing the program when user is managing all the threats then the program will become complicated flexibility is scheduling assigning threads all will be at the hand in the hands of user faster contact switching as you know no need of mode shifting well this is the point which I forgot to make there less overhead in user level threads there is no need of mode shifting it is if if there is no need of mode shifting and the threads are lightweight then less overhead and faster contact switching portability can run on different operating system well then that is the actual benefit when these user level threads are independent of operating system which means I can run those on Unix I can run the same user level thread at Mac and windows well that will give me the actual portability and what is the drawback lack of true parallelism even if multi multiple processors are available scheduling and management is the responsibility of user now this is going to increase the the complexity blocking issues if one thread needs IO OS will block the process well that's well that's the point I want to make see user these user level threads are managed at the user level operating system will see it as the process now what happened this thread wants some IO Services by operating system or this wants the operating system to perform some IO service this wants to read some data from the disk now what OS will do OS as OS see them as the process OS is going to block all of them if one thread makes some IO request as you know whenever process makes IO request operating system blocks that process look put that in the block CU similarly if some thread makes an IO request operating system see all these threads as the process so it's going to block them whole all of them as a process that is the series drawback blocking issues if one thread needs IO OS will block all of the threads okay and this will be solved if operate OS kernel is multithreaded now what is the meaning of this how blocking issues will be solved if OS kernel is multithreaded see here suppose This Thread This Thread makes an IO request so instead of blocking them all this thread of the kernel level is going to serve this user level thread will serve the io and rest of the threads will keep on working these these kernel level threads will keep on serving those user level threads are you getting the point so this thread make a request instead of blocking the whole these all of threads if the kernel level thread if the kernel is multithreaded this thread is going to serve the io and rest of them will keep on working okay see this diagram here we have the user space this is the kernel space so this is a process which contains several threads a process which contains several threads now you know that kernel maintains the process table similar way process will maintains the thread table okay so this was all about user level thread now we'll learn about kernel level thread direct operating system management direct operating system management it will show True parallelism kernel level threads can be executed on multiple processor parall see at this diagram initially what we had the operating system as I as I told you there is transparency operating system will see them as the process instead of threads so it will maintain a process table only and the process will maintain the thread table now this was the user level thread now we comes to the kernel level thread this is the kernel space so in the kernal level threads you know these the the operating system knows that the threads are created here operating system doesn't know that in process threads are present that's why it has only maintained the process table here these threads are directly uh supervised by the operating system so operating system with process table also maintains the thread table because the these threads are acknowledged by kernels or operating system so with process table it will also maintain the threat table oper operating system is managing the process and threats both okay blocking handling unlike user level threads if one kernel level threads get blocked other keep running managed completely by the oper see when in the user level thread operating system see them as a process if one thread will be blocked operating system doesn't know that there are some threads inside the process so to block the operating system will block the whole process uh the process as a whole okay but in kernel level the operating operating system knows that there are different threads present so instead of blocking the uh the whole process it will block a thread only so in kernal level threads if one is blocked then others keep running and it is managed completely by the OS so less responsibility on the user but slower contact switching than user level thread you know that why is it slower because it involves complex data structur more scheduling overhead and due to Kernel level involvement the Contex switching time is more in the kernel level threads and in user level threads maintained at user level simpler data structures this will create or this will cause faster contact switching let's compare user level threads faster contact switching custom scheduling as it is maintained by the user less overhead but blocking issues or no true parallelism because the belong to a single process by the operat as what operating system know that this is a process this is a just a process it doesn't know that in that process there are threads living kernal Level Threats better blocking handling true parallelism better OS integration but higher overhead or slower contact switching let's read again and then we will close the lecture user level threads faster contact switching custom scheduling less overhead but blocking issues no true parallelism and in Cal Level Threats better block better blocking headling true parallelism better OS integration as managed by OS only but higher overhead and slower Contex switching system call and Fork this is our miscellaneous topic part two you know what is a system call this is our C program print f is in a standard C library want to use the system call right so we have to shift the mode from user to Kernel and after the work is done shift it back from kernel to user you know all these things uh we have learned in detail in our section one now the question is How are parameters passed from user to Kernel mode there are three methods the first one is register the second one is memory and the third one is stack if the number of parameters are less we can directly pass those parameters to operating system by placing them onto resistors and then resistors uh the operating system will access those parameters with those resistors if number of parameters are more than the resistors then we will store them in form of a table or in a block in memory and the block address will be passed to the resistors and with the help of that resistor operating system will access those parameters and the third one is stack we will place the parameters onto the stack and operating system will pop them off the stack and will use them this is used when number of parameters are less and these are used when number of parameters are more the same thing is written here three methods used to pass parameter to the the first or the simplest one is pass the parameters and resistor but what happens when the parameters are more than resistors store the parameters in a block or a table in memory and address of the block is passed as a parameter in a register this approach is followed by Linux or Solaris Linux and Solaris parameters placed or pushed onto the stack by program and popped off the stack by operating system block and stack method do not limit the number of number or length of the parameters being used okay so what we did this is X is the parameters for the call we stored the address of that block in the resistor and passed it onto the passed it to the operating system so address of the block of memory containing parameters this is X and it is passed to the operating system with the help of a resistor and operating system will access the system calls or the parameters now we should know some basic system call related to the process management file management and directory management here it is written you can read them all for Process Management file management for directory management and these are some of the miscellaneous system calls folk system call as you have already heard about it execution of FK system call results in the creation of child process the code of child process will be an exact replica of parent process everything will be copied just the duplicacy of process will occur execution in child will start from the next statement after Fork till the end of a program okay suppose this is my parent process here somewhere comes fork and some other lines of code then when this Fork will be executed the same code will be present in the child but the execution will start from this statement after the fork the above four lines before Fork will also be there in the child process but they won't be executed the execution will begin from the next statement after fork and as I've told you process is duplicated so there will be separate area for memory child and parent are independent no Master Slave relationship there is just the duplicacy of process and and one relation between child and parent is the code of both child and parent are same okay let's see here we have this is the parent process okay these two these two statements are of parent process now if I ask you the output of this code then firstly will the execution begin from Main this Fork Fork will be executed as soon as this Fork is executed creation of child process will occur but the execution in child will begin from the next statement after Fork so what will be the order firstly the fork of parent will be executed then print F that is print statement of child will be executed and then it will go back and then the print of parent will be executed and this child will will have will be exact replica but execution will start from the next statement after Fork so if I ask you the output then Fork this print statement and this then this printing statement they will print hello two times so hello and hello will be the output see this print F High fork and print hello so firstly this print F high will be executed so high will be printed then Fork execution of fork will result in the creation of child process so this process will this child process will be there code will be exact same but execution will start from the next statement so firstly this will be executed then this then this and then the meaning it will the control flow will go back to parent and then execution will start after the fork so here print F will be printed or or hello will be printed which is hello so what will be the final output hi this is printed Fork execution of child execution will result in the creation of child process then hello from child will be printed and then hello from parent will be printed so hi hello and hello will be the output see this we have three folks now and and in the end I have print F hello look it carefully how the control flow goes this is the parent process and 1 2 3 4 these are the statement numbers first for executed creation of child process code will exact same which means these four statement will be same in all of them so 1 2 3 4 here also but execution will begin from next statement after four which mean from two what is the next statement again for so execution of this will will result in creation of another child process execution will start from next statement after Fork what is the next statement again Fork the execution of fork will result in the creation of child process execution will begin from begin from next statement after for what is the next statement hello hello will be printed control flow goes back see three was already executed now again hello will be printed control flow goes back now three what is three Fork execution of fork will result in the creation of child process now in child process execution start after Fork so hello will be printed again control flow goes back now four which is hello hello will be printed again control flow goes back now this is statement what's this Fork execution will result in the creation of child process execution will start after four which is from statement three execution of three will result in the creation of another child process execution will start from next statement that is four hello will be printed control flow goes back hello will be printed control flow goes back now three what is three four will result in the creation of another child process execution start from next that is four hello will be printed so how many times hello will be printed 1 2 3 4 5 6 7 and 8 so in the exact same order hello will be printed okay so firstly this hell printed control flow goes back this hell printed control flow goes back but here this statement control flow now goes back this will be executed control flow goes back here down there this will be executed goes back this will be executed here this will be executed and then in the last this four will be executed okay see if you are losing somewhere don't worry create create on your own when you will create this tree on your own then you will get the idea how this is executed just remember two points what I have told you execution of fork will result in the creation of child process and the execution in the child process will start after the fork statement and all of the code will be copied in the child process also but the difference is execution will begin from the statement after the fork okay let's move to this I have main print one fork print two Fork print three so what will happen these are the five statements I have 1 2 3 4 five statements in the parent process one will be printed now Fork execution of fork will result in the creation of child process 1 2 3 4 5 all will be there but what will be printed execution start after Fork so three third statement that is which is two two will be printed and then four this four will be executed which will result in the creation of another child process execution will start after this for so three will be printed okay so how does it goes one is printed and then two is printed and then three is printed and then it goes back it goes back three is printed it goes back this four Fork result in the creation of child process three is printed goes back three is printed so 1 2 1 2 3 3 2 3 3 this will be the order 1 2 3 3 2 3 3 let me show you again 1 then it goes here two then it goes here three then it comes back three it comes back two and then it goes down here three and then it comes back three so this will be the order okay now you may have guessed from this that when I was using when I was using a single Fork hello was printed two times when I was using Three Forks hello was printed eight times so if I have used one fork then two process will be created two forks four process will be created Three Forks eight process will be created if I used n Forks then 2 power n process will be there but remember remember remember this will these also include the parent process see here when I had one fork when I had one fork then there were two process this process and this process which also included the parent process so if someone ask I have n number of folks what will be the ch process 2^ n and then minus one why minus one because of this 2^ n also include the parent process but we are asked with the child process that's why 2^ n minus 1 return value of for if I write something like this int a equals to Fork this when this statement will be executed when this statement will be executed then there will be a new child process with the same code but the value of fork will be different in both of them for parent process the value of fork will be positive but for the child the value of fork will be zero who maintains that the O Fork routine see here I have a code like this main int return return equals to fork and if the return value equals to equals to zero then this will be the child process code and if else then this will the parent process code and rest when no condition is present then it will be executed by both child and parent what is the use of the return value the four can return three value it can return either negative zero or positive if it returns positive then it represent the parent process if it returns zero then it represent the child process and if it returns negative then the execution of fork was a failure okay so let's say this was our program this was the parent process so the value of fork for parent process will be something positive so we have written here one who will maintain this Fork routine of the operating system so one is present here return equals to Fork if return equals to equals to zero well this is not zero so this part will not be executed lse part will be executed and the part which is not conditioned will be executed did you get it I have defined or I have declared the return variable okay so there is a return variable return equals to Fork as soon as this Fork will be executed because this is a parent process so some positive value come here and a child process will be created with return value zero did you get it here I have declared the return value return variable is declared here with some garbage value in it return equals to Fork as soon as this line is executed return equals to Fork this one will come here or any positive value will be stored in the return and the execution of fork will result in the creation of child process so the child process same thing are present same variable is declared here also but the value of return will be different the value of return will be zero here this zero will represent that this process is the child process and the positive number will represent that this process is the parent process and who will maintain these numbers of return os4 routine okay so what happens here if return is one or any positive value then this part will not be executed this part and this part will be executed and if return is zero then see this will this will not be executed because I've told you that execution in child will start after the 4 key statement so execution will begin from here is the return value zero yes go inside the block else part will not be executed this will be executed why because this is not conditioned so this the part of the code which is not condition is executed by both child and parent okay see this question I have main int AAL to 5 b = to 3 and C C = to ++ a mtii b ++ okay print f a b c if Fork = toal to0 then a = to a + 5 b = to B + 3 print F ab and C = to cus 1 otherwise which means this will be the parent process code b + a b + = to a plus = to 2 C I have also included some uh I have also made this question trickier by including the concept of c c language print f a comma b c = to C minus1 and then print f c so if you see clearly this part this if block will be executed only by fork and will be ignored only by child and will be ignored by the parent this part will be executed only by the parent and will be ignored by the child and this part will be executed by both try to solve this question okay so I have initially five 3 and let's say Zer is present in the C now what happened C equals to Plus+ a * b++ this Plus+ a says increase the value first and then use so I increase the value first 5 to six and then used here and the value of a is also updated this b++ says use the value of B+ and then update so I've used the value of B that is three here and then updated it to four now what is c c is 18 so from here I got C is 18 print a b c we printed a BC a is 6 B is 4 and C is 18 this will be printed now this part will be executed by child only this part will be executed by parent only and this part by both so let's see the child part first the value of a is the value of a is a + 5 so value of a will be 6 + 5 which is 11 now the value of B will be what is the value of B 4 4 + 3 = 7 print AB so we have print 11 and 7 and then C = to C 1 what was C 18 17 will be there then then what is there this part part will be executed by both so print C which is 17 will be printed also now comes the parent part in parent part what is written b + B+ = to a plus = to 2 so what will happen we have to solve from here AAL to a + 2 what was a here the value of a what value of a will you use will you use 11 or will you use 6 obviously I will use six only why see you may get confused by by seeing this code you may see that this is the block and this is the part of same code so when I have updated the value of a here and then when this else block will be executed then updated value should be used because it is the part of same code then you are making a mistake because let me let me write clearly what is the part of or or I can say how parents see the code the parents see the code as this part this part and this part how child see the code this part this part this part and this part for child this part is not present and for parent this part is not present you must remember that parent and child are different process with different piece of code do not try to think that there are some there are some uh same process with same piece of code no for child this is not present in its code section and for parent this is not present in its code section so what will the value of a which I use for this parent I will use the updated value which is six so I will use six here so 6 + 2 is 8 6 + 2 is 8 and B = to B + a so what was b b was 4 so 4 + 8 = 12 now print AB this part will be executed print AB 8 and 12 will be printed and then C = to C minus 1 C equals to C that is 17 and then in the end this 17 so this is how it works do not try to think that they belongs to they belong to some same piece of code or same process no I have told you the only relation between child and parent is their code is same otherwise they are two different processes with different piece of code did you get it so I will not use the value of a which was updated here at the parent section because for parent this piece of code is not present in its code section and for child this piece of code is not present in its code section okay let's solve some more interesting problems we have a main function int Inn for I = to 1 I less than = to n++ I if 4 = to = to 0 Print Star see this is in the for Loop and how many times for Loop is Run 1 to n so this will be executed n times so when during the time of condition checking this system call will be made and what will happen creation of child process so this four could be executed how many times n times as the four Loop has run n times so this four could be executed n times how many times or how many total processes will be there 2 power n but in child process only this code will be there if for equals to equals to Z then Print Star this Print Star is present in the code for child process only for parent process the parent process will just ignore this code so out of 2^ n one process is the parent process and 2^ N minus 1 is are the number of child process this one process which is the parent process will ignore this code and rest of them will print star so how many times the star will be printed 2^ n minus one by during the solving during solving this question a confusion may arise that is this node is the parent of this node so so here should be one and here should be zero isn't it no this is wrong there's only one parent and rest are child it doesn't matter where child produces another baby but they'll both remain a child to a parent so there will be only one parent and rest are child for that parent okay so the child of a child is also a child to a parent okay let's see some more interesting problems we have int I and N for I = to 1 I is less than equal to n Plus+ I so this Loop will also run for n times if I mod 2 = to equal to0 it says from 1 to n from 1 to n n by2 will be the even numbers so this will run for n by2 times so this represent the even numbers so for all those even numbers run the fork from 1 to n the number of times even number come run this Fork so how many times Fork will be run n by two times so how many child processes will be there 2 ra to Power number of time number of times four qu run minus one so how many times four n by two times so the total number of child processes will be this much let's see another question but now here is the change int I comma n for this Loop will run for end times if 4 equals to Z here is the end and you know we have no brackets after the for Loop or we have no brackets like that here when we do not apply brackets then the next line the next line will be considered in the loop when we do not apply bracket then the next line only will be considered in the loop so for this for Loop this line was considered and here also we did not apply bracket so this line will be also considered so these two line will be considered in the for Loop but here what happened here we have applied a semicolon here which means this will not be in the for Loop now so this will be printed or this will be executed how many times n times so how many child processes will be there this Fork was executed n times so this will create 2^ n minus one child processes and child process has not to do any specific work see here what I've told you if Fork equals to equals to zero and some body is there then this these line of code will be executed only by child process but here there are no specific such lines so child process will not execute any specific code that parent will not execute this is outside the loop so this will be executed by both child and parent so how many times the star will be printed 2^ n minus 1 times by the parent and One Time by child also so 2^ n * the star will be printed did you get it see if Fork equals to Z and some if some bracket will be there and some lines of code then these will be executed only by child process and rest will be executed by both child and parent but here child has nothing specific to do so both child and parent will execute this line how many times the number of process how many total process are there 2^ n so this will be executed 2^ n times okay so the number of times will be 2^ n see this Main in a if Fork equal toal to 0 a = to a + 5 and print a else a = to a 5 and then print a what is the relation between U and X so a is not initialized here so what we are doing we are just taking for the sake of Simplicity a equals to Z remember when the values are not initialized garbage value is present but for the sake of Simplicity now we are taking a equals to 0 if Fork equals to equals to0 here Fork has come so creation of child process will be there now there are two process a child and a parent both child and parent both child and parent has has nothing common child will execute this code and the parent will execute this code and there is nothing outside the fs so there is no common thing that the both child and parent will execute initially we have taken AAL to 0 so for child a = to a + 5 so value of a will be 5 and then it will print five see like this I'll give the statement one the statement two and the statement three int a executed two two now this is the parent process so for parent process which piece of code is present this piece of code we have taken initially the value of a is zero so value of a will be minus5 and it will print minus5 and at the same time the child process is also present and the execution will start from the next line after the fork what is the next line a = to a + 5 so a = to A+ 5 a was initially zero now a equals to 5 print five okay print five and this part is not present in the this part is not present in the child and this part is not present in the parent so what is the relation between U and X let's say the U it is U is 5 and X is 5 so what is the relation I can say u = x + 10 well u = x + 10 okay note what is the note physical address will be different virtual virual address will be same physical address of variable in child and parent will be different but virtual address will be same because what is virtual address virtual address is related to the code both code in child and parent is same so the generation of virtual address will also be same but as they are to different process so the physical address will be different see if uh you can try this at your home also try to create a child process and try to print the virtual address of a variable you will see that virtual address uh you will see that both address of parent and child of that variable will be same both the address will be same then how can I say physical address are different see on printing we get virtual address so those virtual address will be same but physical address where the variables are or the data are actually stored in the memory will be different for the different process okay and child and parent are actually two different process so for the physical address will be different but virtual address of the variables will be same till now we have completed the fork system call threads and multithreading now it's time to learn about inverted page table or reverse paging you know that page table also consume space so this is a technique to reduce space overhead of page table in page each process will have its own virtual address space and Page table so this is the virtual address space it generates the virtual address or logical address this is page number here we will see the frame in which that page is stored this Frame number will be copied here and D will be copied here there we got our physical address space okay so this was the concept of paging but you remember that each process will have its own virtual address space suppose this is process I and this is process J process I will have its own virtual address space and its own page table process J will have its own virtual address and its own page table okay so the pages of this process J and the pages of this process I are mapped onto the same physical memory see here the pages of let's say process I and process J are present in the same main memory suppose this is this p 0 and this p 0 both have same name so this p 0 is present here and p 0 is present here so what happens in the frame table in the frame table so this is the frame number and this is the page number of the process we also include the process ID because otherwise it will cause confusion that this page number one is of which process page it may be page number one of process I it may be page number one of process J and there are so many process it could be page number one of any process that's why we have another section which will uh store the process ID with the page number so this is the frame number this index will tell that at frame number four at frame number four process I process I page process one is stored so this will be copied here and D will be copied here and you know when process will generate The Logical address with page number it will also tell the ID so we call this page number and ID combination as key so this is the key so we will search with this key in the frame table and number of entries will be equal to number of frames the point is Pages all the processes are being mapped on the same physical address space pages of all process are being mapped on the same PS can't we design a page table based on the the PS some kind of global page table for each process see what are we doing here we know that each process will have its own page table so instead of keeping page table instead of uh having page table for every process why can't we just create a global page table see you know that the pages of this process and the pages of this process are both at the same place can't we generate a global page table from the help of this we will access the pages you getting the point let me repeat both the pages of this virtual address and this virtual address space are being stored at the same place can we generate a global page table for all the processes can we generate that kind of architecture this will going to significantly reduce the page table overhead so we are trying to create some CL some kind of global page table so in inverted paging one Global page table is used used by all the process in traditional approach let's say we have 100 process then we will have 100 Pace tables so to save his spce sacrifice time to save space sacrifice time but the search will increase in in traditional the search time was constant but here the search time will depend on the number of entries so the search time will increase but space will be significantly saved when we'll see some problems then you will going to realize how much how much drastic change has come by using this Global page table and you know page table size is not less and if we somehow are able to combine all those pages all those page table characteristic into one page table then it will going to revolutionize let's see this we have a virtual address of 34 bits page size is of 8 KB physical address is of 29 bit page table entries of 32bit what is the size of page table traditional versus inverted virtual addresses space will be 2^ 34 page size we know 8 KB so number of pages or number of entries in the traditional page table will be 2 21 and the size of each entry is 4 by so here it will be 8 MB the total the page table size per process will be 8 MB and how many processes are there no we are talking about just one process so the total page table size will be of 8 MB number of entries in the we are talking now about inverted page table so number of entries will be equals to number of frames how many frames are there 2^ 29 and what is the uh page size 2^ 13 so we'll have 2^ 16 entries the table size here will be 2^ 16 into 2^ 2 as each entry will have four bytes so we will have 256 KB only see in the traditional case in the traditional case we have P pce table uh size per process 8 MB and here we have the global page table of 256 KB now let's say there are 100 process then traditionally it will it will require 800 MB of memory to store the page table only and in inverted no matter how many processes are there all of them are going to use a global page table 256 KB only did you get it let me repeat again the problem was each table will have its own virtual address space and and will have its own page table this virtual address space won't create a problem because it is mapped on the hard disk and hard disk has enough size but the page table is stored in the memory and each when each process will have its own page table then what are we doing traditionally we are storing each page table into the memory but we know what that the pages of the virtual address space are stored in the frames of the memory so these pages are also stored in the memory these pages are also stored in the memory all of them are mapped on the same physical address pages of all process are being mapped on the same physical address can't we design a page table which is global page table through which we can address or we can uniquely identify the page or we can uniquely identify the frame in which the desired page of the desired process is present that's what this Frame table has helped us to achieve let's say CPU generated The Logical address here with the logical address there is a little bit difference in page number we also have the ID of the process so this page number and the ID will create a key and with this key we are going to search in this Frame table and what does frame table contain the index contains the frame number and the entries contain the page number and the ID so this P1 is present here also P1 is present here also if ID won't be there then how I'm going to identify this P1 is of which process it may be of process Pi it may be of process PG so ID is also present now search with this key in the frame table in the traditional approach what we were doing we were searching based on the based on the index number see what are we doing in the traditional we were searching based on the index number this P was searched at this that's why the time taken to access that particular uh access the particular frame number or the time taken to acquire that particular frame number was constant why because we can directly jump to that index we can directly jump to that index but here we have to search we are not searching through frame number or the index we are not searching through index we are searching based on this key we will search for each and every entry in the list suppose the CPU want to or the process want to access the frame in which page number one of process I is present so it will generate an address like P1 and I okay so P1 and I now it is going to search is P1 and I is present P1 I P1 I P1 I no I got P1 I which index has or which index has a stored this P1 I index 4 is a stored so this will be copied here and D will be copied here and that's how I got my physical address now each of them each of the process is going to use this single frame table instead of having own each instead of having its own table own page table every time we are using a global page table or we call it as frame table index contain the frame number and with the help of this key we search each and every entry wherever we get the entry that index will be our answer and we are going to take that index forward as the frame number and D will be copied here that's how I got my physical address traditionally what we were doing with the help of this page number we were directly jumping to the index and the entry was our answer here the entry is not the answer the index is the answer the index is what we want so index will be copied here this D is present here that's how we get the physical address okay so what we did the all the pages of the process are mapped on the same main memory so why can't we generate a global page table that's what we have tried to achieve here with the help of this Frame table so inverted paging one Global page table is used by all the process in traditional approach 100 process will have 100 page tables but in uh inverted page table process no matter how many processes are there there will be only a single page table which is global page table or we also call it as frame table but the drawback is here we can directly jump to the index and find the frame number quick quickly but here we have to search each and every entry so what will be the search time o n and what will the search time the constant okay so this question we have tried remember one thing that number of entries will be equals to number of frames here the number of pages were being used as index and here the frame is used as index so how many indexes will be there the number of frames so how many entries will be there equals to the number of frames okay so here the page table size the traditional page table size we got was 8 MB and and here we got the page table sizes as 256 KV now if there are 100 process then the traditional approach will consume around 800 MB and the inverted page table approach will consume just 256 KB if it were th000 process then it will consume 8,000 MB and inverted will just consume 256 KB did you get it how simple this is can you compare the size this is nothing in front of 800 MB