Learn how to build projects using Remix and Strapi. In this course you'll discover how to harness the power of Remix, a modern React framework to create dynamic, userfriendly frontend interfaces. And you'll learn how to integrate Strapi, a flexible, opensource, headless CMS, to efficiently manage and deliver your content. Paul Brett Slofsky developed this course. He'll teach you essential concepts, best practices, and practical tips to help you create seamless, scalable web applications. Hello, you wonderful people at Free Code Camp. I'm excited for this new tutorial that I am going to share with you. We're going to learn about Remix, Strapi, and how to combine both of them together to build things quickly. We're first going to start by learning about what Remix is, getting started with the basics. Then we're going to add Strapi to our Remix applications to see how you can use Remix and Strapi together. So what is Remix? Remix is a fullstack web development framework created by the same team that brought us React Router. It is also backed by Spotify, so you know it'll be around for a long time. More importantly, it allows you to build amazing user experiences while embracing the web standards. Since it's a fullstack framework, you're able to build both your frontend and backend together. But as a new developer or someone who's just starting out or you just don't have a lot of time and you want to build applications even faster, this is where Strapi comes in. Strapi is a headless CMS that allows you to create API in minutes. It gives you this amazing admin panel area to manage your data, and more importantly, you have a functional API that comes in with authentication, user management, and other great functionality. So to empower us to build cool things for our clients, we're going to leverage Remix and Strapi together. So let's take a look on what we're going to build during this tutorial. We're going to cover the basics of Remix, everything you need to know to get started with Remix quickly. Once we learn the basics of Remix, we're going to jump in and add our Strapi backend to our Remix application. We're going to cover full crowd functionality from creating, deleting, updating, and getting our data. And you'll be able to visually see your data within your Strapi application, which is pretty cool. So let's take a look at all the things we are going to learn about. We're going to cover Remix routing. We're going to take a look at nested routes and outlets. We're going to also look at how to create dynamic routes. We're going to cover how to use loader and action functions to get data from our Strapi API, which will cover full crowd functionality, including create, read, update, and delete. We're also going to take a look at form validation with ZOD, which is pretty cool. And we're going to learn how to submit forms using Remix, including useFetcher function, as well as how to handle errors via error boundaries, and few additional things as well. I hope you're excited about this tutorial, as I'm as much teaching it to you. So with that being said, let's jump right into it. And finally, before we start, how can you get help? Well, one of the main ways that you could ask me questions is actually go to the project repo that I'm going to have in the description of the video. And you could click on issues and you could create a new issue with your question. And then I will be able to see it and give you any help that you need. Also, if you're looking for the code snippet that we reference in the course, you will find them all below here in the readme file. We just have a couple of snippets that you will want to have access to while doing this course. And more importantly, while doing this tutorial, you'll be able to ask questions in the comments for the video on FreeCodeCamp channel, as well as I'm going to create a thread on the forum to be able to answer questions there as well. So let's jump to it and build cool things. Before we get started, let's go over some of the prerequisites. Although I made this course with beginners in mind, you should have some basic understanding of basic programming, like HTML, CSS, and JavaScript. Also, you should feel comfortable around your computer, like opening a terminal and being able to install basic packages. You should have Node installed, and that should be enough. With that being said, the focus of this course is to really improve our understanding of remix and Strapi. And that's what we're going to do. With that out of the way, let's get started. Let's navigate to remix.run and click the Get Started button. We're going to navigate to this tutorial. We're going to start here because I want everybody to start with the basics of remix. We're going to do this tutorial together, and then I'll show you how to hook up Strapi to this project. The reason why I'm using documentation is because I want everybody to feel comfortable that documentation is your friend. And whenever you get stuck, these are the resources that you have available for you to help you get unstuck. So we're going to work through this together. But if you run into any issues, you can always reference the documentation. It is amazing. But with that being said, back in our remix tutorial, let's navigate to the bottom here where we could see this Generate Basic Template command. And this is what we're going to use to get started. So I'm going to go ahead and copy it. Inside my terminal, I already created a folder for my project. I'm going to go ahead and paste that command and click enter. This is going to go ahead and start creating our project. I'm just going to keep this the same, click enter, and it's going to go ahead and create your project. It's going to ask you if you want to initialize a new Git repository. You could say yes, install dependencies 1NPM, click yes, and it's going to go ahead and create your project. Once your project is installed, you could type LS to see the newly created folder. We could CD into that folder, and we could open our project inside VS Code by running code, period. And here you are. You have your remix project. The most important part to keep in mind is that we're going to be working inside this app directory. We have our basic app CSS. We have our data file that came with this template to allow us to simulate that we are connected to the database when we're making our basic requests. And our project starts from this root. And here you see all the basic JSX that will render our pages. And this is just a starting point, and we'll learn more about this as we continue. And we could run our project by running NPM run dev. This is going to start our project in development and environment. So let's take a look and see what we have so far. So what do we have here? Not much, because this is just the beginning of our project, but we have our basic input form and a button to submit our form with a list of few items. And this is coming from our root.dsx file, which is the entry point to our application. And we'll talk more on this later. But right now, as you could see inside our body element, we have our input and we have our button as well as our list items. So now that our app is set up, let's take a look at the root route and adding our link to link to our style sheet. Root.dsx is our root route, and it's typically what is rendered first. And this is where you would put your layout if you wanted to. So here's our root route, and this is where we have our sidebar. We could add additional elements such as a header or a footer and an outlet component that would render all other routes, which we'll talk a little bit more about it. But for now, let's take a look how we could add CSS to our project. To import our CSS into our remix application, we're going to use the links tag. You could read more about it in the documentation. We're also going to need to get its types. And then finally, we want to import our style sheet that we want to use. And we're going to use our links function to inject it inside our HTML. So now let's add these changes in our app. We are already importing our links. So in the top, let's import our links function types. Now let's import our style sheet. That's found in the app under app.css file. This is where you could find all the styles used in this application. And finally, let's use our links function to import our styles. Now let's refresh your application. Beautiful. And now you could see our style sheet is being applied. Now that our application is taking shape, we probably want to navigate to other pages. So let's give it a try. Let's click on your name. Oh my gosh, it is throwing a 404. But notice that we're going to a URL context slash one. So inside our application, if you scroll down, we see our anchor tags. When we click on the anchor tag, it changes our URL to context slash one. The reason why it's not found is because we don't have any routes that represent that. So let's go ahead inside our app folder, create a new folder called routes. And inside our routes, let's create a new file. And we're going to call it contacts dot TSX. And now let's create a very basic component here. I'm going to call it contacts route. And now let's go back to our application. And notice when I go to slash contacts, I don't see anything. Well, the reason that we don't see anything is because we don't have a way to tell remix. Hey, go ahead and show that route. So the way you would fix this is by using outlet. So in order to make this work, we're going to go ahead and import outlet from remix. Then we're going to use our outlet by creating a div where we're going to pass all of our children routes. So now let's make these changes in the code and see if we could see our newly generated route. So within our route dot TSX file, let's go ahead and import our outlet. And finally, let's scroll to the bottom. And after the sidebar div, we're going to add another div with ID of detail. And inside here, we're going to add our outlet. Let's refresh your application. And notice you're now able to see our contact route. We are making some excellent progress. Why don't you go make yourself some cup of coffee, take a little break or tea or water, whatever it is you like to drink. And then when you're back, we're going to take a look at how to create dynamic routes and use the link component to navigate. See you in a bit. All right, let's jump back into it. Currently in our application, we have two anchor tags, which are our links. So when we look at our application, we have your name, your friend. These are the links that we just saw in code. When I click them, we still fail because we don't have a route that matches the URL route that we're looking to get. So to fix this in our code, we're going to create two additional routes. So here I'm going to create a new file called contacts dot one. We'll use number one dot TSX. And then we're going to create another one new file called contacts dot two dot TSX. So looking at our link, we are navigating to context slash one, context slash two. And that's exactly what we did here. We define our routes whenever we use the dot separator in the routes. That basically means context slash one. So that's what you want to go. And let's go ahead, add some basic JSX here so we could see it here. So I'm going to say contact one route. And then I'm going to copy this same example. I'm going to go here and I'm going to say contact to route. So now when we go back into our example and we click your name, we get contact route, contact to route, it doesn't fail anymore. But notice that we only see the contact route here. And so the way we could fix this is two ways. So we could either remove it and then we'll either match contact one contact two, or we could use this as a layout route. And to make this a layout route, I'm just going to say lay out contact route. And in order for us to render the items from our children routes, we would need to use an outlet. And let's put this under age one, just like so. So now when we go back, notice we have our layout route. And then we see both our your name, contact one, and your friend contact two. So notice when we are matching contacts and one, we are matching the contacts. That's why we're able to render this layout. And then we're also matching one. And that's why we would see contact one route inside there. Now, for instance, if you did not want to have a layout route, you could just remove this. And this is what we're going to do for now. So now when we go to your name, we're just going to see just those routes for contact one and contact two. But the issue is that this could be contact one. This could be contact 32. This could be 57. And so the idea is like we don't want to continue to make routes from one to 50 or 70, however many items you might have. So in this case, we want to use a dynamic route. And the way we create a dynamic route is that we, instead of passing a one, we could signify a dynamic parameter by using dollar sign. And we're going to say contact ID. And now when we do this, we could remove this one and delete. And I'm going to refactor this to say contact dynamic route, just so we could clearly know what route we're in. And I'm going to say contact dynamic route. And so now when we go back to our application, regardless if we go to your name, your friend, they're both going to render. Now that we know how dynamic routes work in Remix, let's go ahead and set up our contacts ID TSX file by importing this existing code. Now, if you're following via this documentation, you could paste it from here. But I'm also going to create these gist just with the code snippets that you need. And I'll make sure to have them in the link in the description below. So make sure you copy the code. And let's inside VS code in our contact ID.TSX file. And now let's go ahead and paste that boiler code here. And we'll go through it in a little bit. But first, let's check it out and see if it worked. So now if we refresh our application, notice for our dynamic route, we now see this boiler plate that we will update as necessary. But before we could update it, we need to learn how to load data. So let's first review how you can use a loader function to add data to your Remix application that you could get from either external API or from making a direct call to your database, or in our case, in this example application, our dummy data. In Remix, we have a loader function that allows you to load your data. So let's take a look at a basic implementation before we continue with this tutorial. We can access a loader function by exporting it in our application. So for instance, here, we're going to export a sync function, call it loader. And inside the return, we could return the data that we want. And right now we are returning this dummy data, but this loader function runs on the server and we could make an API call or call to the database to retrieve the data that we need. Once we declare our loader function, next we're going to import our use loader data hook that allows us to get our data from the loader. So notice how we are using use loader data hook and saving it to a data variable which will have our data. So let's see how this is going to look in our code. So inside our root.tsx file, we're going to first import use loader data from remix. Then we're going to define our basic loader function. And in order for us to get that data, we are going to use our use loader data hook and we're going to give it a type of loader. So TypeScript doesn't complain. And now let's go ahead and console.log our data. And notice we get our data that we are passing from our loader function. So now let's see how we could load all of our users to populate our left sidebar here. So inside our root.tsx file, first we're going to import get contacts from that data. This is available in your application. If you go inside that data and you search for get contacts, you're going to see this function. And what it's doing, it's getting our data to populate our users. And currently this data is stored in our application. But as we continue, we'll show you how to get this data from our Strapi API. So now inside our loader function, let's go ahead and use our get contacts function. So we're going to say const contacts and we're going to await our get contacts. And we're going to go ahead and return. Now whenever you're returning items from the loader function, it actually returns as a response. So remix has a helpful function for us that allows us to return this response with all the appropriate headers within. So that's what we're going to do. We're going to say return contacts. Now when we take a look at our console.log, notice we get an array of all of our users. So now let's update our return code to allow us to visualize the data that we just received. You can find the code snippet inside the remix tutorial here. And we're going to copy the contacts code snippet here and we're going to paste inside of our application. Now if you're not following this tutorial, which you should use it as reference, I'm also going to have these jists that I'm going to put in the description below as well, just so you could find the code snippets. If for some reason you can't find them. So inside my application, I am going to scroll down to our navigation here and I'm going to replace the code within the UL. And I'm going to paste it in. And we just have to rename our use loaded data that we're getting here. Instead of data, we're going to call it contacts and we could remove this console.log. And now when we navigate back to our application, notice we have all of the items coming from our fake database, which is pretty awesome. So let's do a quick recap before we move on. So to recap, we imported our loader function that allows us to call a method that either connects your database or makes an API request to get our data. Then we return our data using the JSON method, which allows us to return it as a response with all the appropriate headers. You could learn more about it on the remix documentation, but it is being imported from at remixrunnode package. Once we get that data back, we're using the use loaded data hook to save that data into contacts and then we're iterating through those contacts, mapping through them and rendering our links. And this is what we see here. So next, we're going to take a look how we could click on any one of these individual links. And notice as we click them, the URL changes. So in order to be able to display the items here in our details page, which we're going to create to, we need to figure out how we could access the URL params to allow us to do that. And that's exactly what we're going to do in the next section. So from our root.tsx file, let's go ahead and copy our loader function inside our contact ID.tsx file, which is our dynamic route after line five. Let's go ahead and import our loader. Now, if you take a look inside our data.ts file, you're going to see that we have get contact method that expects an ID, which is a string, which will return one item for based on the ID that we pass. So inside our contacts.id.tsx, let's first go ahead and import our get contact from data. Now let's refactor this to reflect that we're only getting one item. Now it's complaining that we did not import our JSON method. So let's go ahead and import it from remix. And now we need to provide an ID. So you're wondering, where do we find the ID? So the ID is based on this dynamic attribute that we have. So in the loader, we have access to the params and TypeScript is going to complain because we need to import the params and you could import them from remix. So we say we need type of loader function arcs and let's make sure that we add it here. Perfect. So now TypeScript is not complaining. And finally, if we take a look at our params, I'm just going to console log for now. Notice that we have an object and the key is contact ID and then it has the name of the item that we are searching for. And if you're wondering where that name was defined, it was defined here. So any time in our application, when our URL params change, notice how they're changing here. For instance, I'm going to go to me, Paul Bratislavski, right here. If we take a look in our code, notice the param that we get is Paul Bratislavski. So now I'm able to access that. So we're going to go ahead and here, just going to do const contact ID equals params and we're pulling that contact ID and we're going to pass that contact ID to our method to get our data. Now, right now it's complaining. What if contact ID is not defined? So we probably should do a check to see if it exists first. You could find this package on npm and read more about what it does. But it makes it an easy way for us to check if an item is false or not. And if so, it will throw an error. So let's go ahead, copy the install script in my terminal. I'm going to paste the script in and install. Once the script install, I'm going to restart my project by running yarn dev. And now we could add a check to see if the params exist. So we're going to use the invariant method. We're going to pass the params that contact ID. If it doesn't exist, we're going to return an error message. And if so, we're going to continue and notice how the error goes away. Whenever we return our contact, maybe we don't have any contacts. So we should do a check. So we're going to do if no contact found. Let's throw a new response with not found and return 404. Some people like to do the if statement with the brackets. But for me, it just makes my brain feel much easier when I remove the brackets for oneliners. And in my mind, it's just easier to read. Should you do this? I don't know. But this is what I'm going to do here. And now that we are getting our contacts, we're going to import our use loader data. And inside our component, we're going to go ahead and say const contact equals use loader data type of data loader. And we're going to remove this dummy text that we have here. So now let's do a quick recap. We are using our loader. We're calling our get contact method where we're passing our ID that comes from our params. If we don't have a contact, we're going to throw a not found. And if we do have a contact, we're going to return it here inside our contact that we're going to pass to our code below. So now let's navigate to a browser and see if it worked. Great. Look at this. This works. We are able to get all of our data coming from our phony data API. So in the next video, before continuing with this tutorial, let's actually go ahead and set up Strapi to show us how we could get data from an actual API endpoint. This way, you're going to have your front end with remix, and you're going to have Strapi as your backend. So before we install Strapi, go ahead and grab another cup of coffee or tea or whatever you like to consume. Take a little breather, take a little break, think about all the things that we've done, and then come back and we'll be ready to set up Strapi to set up our API. And you'll see it's going to go so quick, because Strapi allows you to create your API in minutes, and I'm really, really excited to show you how to do that. All right, and welcome back. Today, we're going to take a look on how to set up Strapi. Strapi allows you to create an API in minutes, but what's awesome, it's easy to get started. But also, if you need additional customization, if you want to dive deep, add additional functionality, add extra middleware controllers policies, you are able to do that. But what's awesome for beginners, you could get started with it right as it is to create an amazing backend for your project that's going to have this amazing admin area. So just like we've been using our remix documentation, Strapi has amazing documentation as well. So you could always reference it when you get stuck, but we're going to jump right into it. So it's very easy to get started. We're going to use the NPX Create Strapi app at latest to get our project going. So inside my terminal, currently I'm in my Remix folder. So I'm going to move one level down into the root of my project. And notice how we have our My Remix app. So now I'm going to use NPX Create Strapi app at latest. And we're going to call it my Strapi app just to stay consistent with our naming. Are there good names? I don't know. And you could choose Quick Start, but I'm not going to do it just to show you some of the options that you'll see. So this is going to ask, do you want to get started? Yeah, sure. Yes. Let's download the following packages and install them. Once the process is all set, you have the Quick Start option, but you also have the custom options. So let's take a look. Custom options allow you to choose if you're on use JavaScript or TypeScript. In that case, we're going to stick with JavaScript for the moment. And here you have your options of different databases. You can use SQLite, Postgres, or MySQL. I'm going to stick with SQLite. Yes, that sounds good for the database, where to save the files locally. And it's going to go ahead and create our Strapi application. Now that our application has installed, I'm going to cd into my Strapi project, and I'm going to run yarn develop. So because this is our first time starting our Strapi application, we have to create our first admin user. So I'm going to do Paul Bratz from coding after 30 at gmail.com. Let's do password monkey1234. Since this is running locally, that sounds secure enough. No one's going to guess monkey1234 ever. Let's click Start. And now we set up our Strapi application on the dashboard. So let's do a quick tour on the Content Manager. This is where you want to see all your content types and collection types that you have created. Currently, we have just the user collection type that has no users yet. And if we take a look at the content type builder, this is where you actually are able to create new collection types, content types, which we'll learn more as we continue through this tutorial. You could see that our user collection type, here's some of the fields that it has, username, text, email, and so on. And we will create a new collection shortly. But first, let's just finish up this quick little exploration of Strapi admin area. Here, we have our media library. All your files that are stored in Strapi will show up here. Afterwards, we have our plugins. If you have any additional plugins installed, you're going to see them here. And an example of a plugin, for instance, if you want to extend function on Strapi and store your files in Cloudinary, you could install Strapi Cloudinary plugin that allows you to do that. And if you're trying to figure out where to find these awesome plugins, you could always check out the marketplace. And if I say search for Cloudinary, and it's going to be a provider. And here, you could see the Cloudinary provider. And if you want to install it, you could copy the command and install it. And then we're going to take a look under settings. We have our general overview, all the details about our application, a couple of different options, the ones that we're going to use most. This tutorial is on the roles. On the roles, you are able to define which endpoints have permissions. And you could either say they're publicly, meaning there's no authentication required, or you could make them authenticate it. And this is something we'll dive into deeper. With that being said, let's go ahead and create our first collection type. So in our current application, if we go into apps, and we take a look at our data.ts file, we're going to see our types for our contacts. So we know that we need to have an ID, a first name, which is a string, last name is a string, we have an avatar, which is a string, which represents the URL for where we're going to store the image. Then we have Twitter and notes and favorites is a Boolean. So what we could do is we could actually create our Strapi collection type for our users. So within Strapi application, let's navigate to content type builder. And we're going to create a new collection. If you have like many users, many products, you would create a collection type. If you have, let's say, a single item, like a settings page, or what have you, you could use create new single types. But we're going to start here, click create new collection type, and we're going to call it contact and click continue. And now you'll see all these different fields that you have available to structure your data. For instance, you have your text, which is a string, you have your Boolean, you have your different editors available to you. We have your JSON data, you could represent emails, passwords, numbers, dates, media, enums, UI ID, different relationships. And we have a markdown text editor, as well as you could create components that dynamic cells, which we will talk much later when we work on our Cornerstorm project after we're done with this remix of Strapi introduction. So for this, we're going to use text. And for our first name, we're going to say first, and let's click another, do another text field, it's going to be last for the last name. Add another field, let's take a look at what we have here. So we did first, we did last, we have avatar, which is going to be for our image URL. So let's do text, say avatar, add another field. We need Twitter, let's copy Twitter text, also going to be for the Twitter feed. And then we have notes. So we're going to do text, we're going to call it note. I think it's notes or note, we have notes. Okay, let's say we call it notes, and it's going to be long text. And let's see, do we need anything else? And yes, we do. So add another field, and we're going to have a Boolean to signify that this is something that we favored it. And I think that is all we need. So check this out. We're going to click finish, click save. And now when we take a look at our content manager, we now see our newly created collection type content. So if I click on it, create a new entry, I'm able to add my information. I'm going to say Paul, Bratz, I have a URL here for my image. And I'm going to go ahead and say hello from Strapi. And we'll say true for our Boolean, click save and publish. So now if we want to give permission to users to be able to get this data, we are going to go into settings on the roles. And we're going to say it's publicly available. And now you're going to see all the different available API endpoints that we have. And this is our newly created contact endpoint. So if I click on it, we're able to give permission for create, delete, find, find one and update. So we're going to go for both find and find one and click save. And notice now that if we navigate to our Strapi application endpoint slash API contacts, because we gave the permission, we are going to see our API response. So we literally created our backend and we now have a working endpoint that allows us to get our data. So now let's see how we could get this data inside our remix application. Inside our data.ts file, we're going to make all the changes. By the way, in remix, you could define if your files run on the server or on the client. For our data fetching file, we want it to all run on the server. So I could be specific by renaming this file data.server.ts. And this is going to go ahead and it's going to run all this code server side, which is awesome. So now within our data.server.ts file, let's refactor it a little bit. We're going to delete this top part. We're going to keep the type definition here for now. And then let's scroll down to get contacts. And let's delete everything from get contacts to the export type here. And now within all of these functions that are getting that fake data, we're actually going to delete all the code inside and just leave them as placement functions to make our changes to reflect getting data from Strapi. And I'm going to do it for update contacts as well. And we're going to do it for delete as well. And this array here, we're going to save to a variable, which we'll use later as reference. And if you scroll all the way down to the end, you're going to see that we have this dot for each. We don't need it, just remove it. Nice. Now that we have refactored our data.server.ts file, we could start implementing our new code. So within get contacts function, we're going to go ahead and create a try catch block. And if there's an error, we're just going to console log that error. Nice. And within the try block, we're going to do const response. And it's going to equal to await. And we're going to use fetch. Once we fetch the data, we're going to get the JSON. So you're going to do data equals await response dot JSON. And inside our fetch, we're going to pass our Strapi app URL. And to that, we're going to append our endpoint, which is going to be API slash contacts to get our data. Now let's add our URL variable. Basically, I'll check, do we have a Strap URL in the parameter? If we do use that, if not default to local host, which is perfectly fine. And when we get this data from Strapi, if you look at the structure, we have data ID attributes and so on. But what I want to do is I want to flatten this response. So we have the data object. And instead of attributes, we just have the attributes. And this is helpful that if we were getting nested data, it would also have data attribute, data attribute, and so on. And so by flattening it, it makes it a little bit much more easier to use in our response. I also like this idea of having an intermediary function that allows us to define the structure of our return. So that way, when we make changes in our API, instead of having to redo our whole frontend, we could just rewrite our transform function. And I already have this flatten attribute function that I wrote that I'm going to share either in this gist or in our accompanying blog post, which you could use when doing this tutorial, as well as the final project. And let's go ahead and paste this function above our URL here. And we're going to minimize it so it doesn't act like a big eyesore. And now here, we're going to do another variable called const flatten attributes data. And that's going to come from our flattened attributes function that we imported. And it's going to get our data. And this data object is going to have our data and our meta information. So we just want the data. And finally, we're going to return our flattened attributes data response. Now, because we updated this file to be called data.server, we need to navigate to root.tsx and make sure that we make that change. We also did the same thing inside our contact ID TSX file. So make sure that we rename the imports accordingly. So server and same thing that server. So now let's see if we're able to get our Strapi data. I'm going to restart my Strapi application by running yarn develop. Once your Strapi instance is running, go ahead and restart your remix app by running yarn dev. Great. Now we're getting our data. And where is this data coming from? It's coming from our Strapi application. So check this out. If I go to my Strapi instance on the contacts, I click Paul and I'm going to change to my full last name. And we're going to take the star way by setting this to false. Click save. And when we go back to our application and refresh, notice we have our changes. So next let's fix us being able to get our single entry. Because right now if we click Paul Wyslowski, we get not found because currently we broke our application. Because instead of getting our dummy data, we are now looking to pull data from Strapi. So let's go into the code and fix this first. But first inside our Strapi application, let's go under settings, roles, public, and click on contact. Whenever we found all of our items, we use the find endpoint. And that's found by going to API slash contacts. Whenever we pass a parameter like one, the ID of our contact, it's going to look for that single entry. And notice that instead of returning an array, it returns an object. So that's the endpoint we're going to look to use. So if we could take a look here, we need to go to API slash contacts and provide the ID. So let's click save and within our code editor. And navigate to data.server.ts file. Our endpoint code is going to be similar to this code that we have here. So I'm going to copy it. Let's go to the get contacts by ID here. I'm going to open this code block and I'm going to paste in our code. And I must have missed the closing bracket there. So let's go and add that. We are going to be making a request to contacts. And the only difference is we now have to append our ID. Which we're going to get from this parameter. Everything else should be the same. So now let's go ahead and navigate to our single contact ID page here. And we're still getting our params using our param attribute in our loader function and repassing that ID to get contact. So that should have been an easy fix. We should now see the data. Now let's see if it worked. So back in our app, which originally was throwing a 404. Let's refresh. And Norris, now we are able to get our data. So now before handling edit, delete, or star our user, we want to have the ability to add the users. So let's connect the behavior to our new button. If we currently click our new button, we get four or five method not allowed. That's because we are going to use strappy to allows create users and save them to our database. So let's get started. Inside our code, inside the app folder, under root, navigate to the submit button here. Instead of using a button here, we're just going to have a link to a new form that we're going to create. So we're going to say link to and we're going to link to contacts slash create. And we're going to say create. Currently this route doesn't exist. So let's go ahead and make it inside our routes folder. Let's create a new file and we're going to call it contacts dot create dot TSX. We're going to create a very simple placeholder component. And we're going to call it create route. We could remove this react import since we're not using it. And now that we have this placeholder route, we could test it. So let's go back. So in our application, if I click new now, we'll fix the styling in a little bit, but let's check it out. If we click create Norris, now it takes us to a create route. So let's add a class to our link here. We're going to say class name equals button link. And we're going to navigate to our app that CSS file found inside the app folder. And we're going to copy some of the stylings for our new button link class. So I'm going to say button link and we're going to copy all of this button code, as well as this color and font weight. Now that we have our new button link class, this should apply these changes to our new link component. So Norris, that I create button looks pretty good. It's almost done. The last thing we need to do is remove the styling. And under font weight, let's do text decoration and it will be none. And Norris, our button now looks normal. And whenever we click create again, it takes us to our create page. So in our project, let's navigate to our routes context that create that TSX file. Here's where we had our placeholder text. What we're going to do now, just to make it easier for ourselves, we're going to paste a snippet. All the snippets I will make sure to link in the description of the video to all the gist that I'm using. And in this case, it is our remix create form starter. I'm going to click raw, do control A copy all to select all the code and control C to copy. And then let's navigate back to our code editor and paste it in. All this does is paste our basic boilerplate that we need for this form. I created a form input component and basically is just a flexible component to allow us to quickly define our input elements. But the part that you want to focus on is the our input is using the name attribute. That's very important. If you notice, we don't have any use state or use effect or any react ways to create a controlled form where we pass an unchanged. So you're wondering where well, how are we getting our form data? Well, we're using standard web form API. So whenever you submit a form is going to pass the values in the URL. So we'll have the name plus the value that we have in the form. So let me just show you what I mean before implementing the code. Remix handles form submission similar the way it is done traditionally using the form tag. This may be unfamiliar to some newer developers, but HTML form causes navigation similar to a link. The only difference is that you have the ability to change the request method get via or post. So let's take a look at what this means. Here's a simple form example, and this is using the classical way of just submitting the form and the action refers to an endpoint which is going to do something with the data. In this case, they're using get. The form data can be sent either as a URL variable when using method get or as a HTTP post transaction when using method post. When using the get request, and this is the example we're going to take a look at, the form data will be appended to the URL. If we were to make a post request, that form data would be appended to the body of the HTTP request. So if we take a look at this example, when I put Paul Bratz and click submit, notice that in the URL, our form data is being passed inside our code. If I do action equals test and method equals get, let's try submitting our form. So within our application, we're going to do Paul Bratz and click create. Since this test standpoint doesn't exist, we see 404 not found, but you could see that we have our first name Paul and last name Bratz. Remix has a form component that basically does the same thing. The only difference is, except of sending the request to the server, it uses the client side routing and sends it to the routes action function, which we're going to talk about in a little bit. So let's take a look at this quick remix example. Whenever you want to create, delete, or update data on your website, we will be making a post request. So we have our basic form already set up. So the next thing we need to do is create an action. In this case, they're defining an action in a separate file, but we're actually going to define our action inside the same file that we're working. So in order to create a function, we just need to export a sync function called action. So let's go ahead and do that. Inside my code, I'm going to type export sync function, and it's going to be called action. And we have the request available to us, and we do need to import action function arcs type. So let's go ahead and do that. We're going to say request, and let's import type action function arcs. Now we're able to access our form data from our request object. So we're going to say await request dot form data. There's multiple ways to get the data, but we're going to use the simplest one. We're going to say const data equals, and we're going to use object dot from entries. And we're going to pass in our form data. And all we're going to do is just return our data. In order to see the response from our action, we need to use a hook. And the hook is called use action data. So under navigate, I could do const form data equals use action data. And let's console log it. So currently, it's going to be undefined, because we don't have any submissions to our form. So let's import form. And here we're going to replace the HTML element with the remix form method is going to be post. And we're not going to define an action. Whenever you don't define an action, wherever the form is submitted, it's going to go ahead and look for the nearest declared action that we have in the same file. So now let's give this a test. So my application, I'm going to say Paul bratz at Twitter, HTTP, some image that JPEG. And hey, so now that we click create, we don't visually see anything here. But let's check out our console log noise that we have the output for our data. First name Paul last name bratz, Twitter avatar, and our note. And that's all coming from our form. And so the recap quickly before we continue, whenever submitting forms and remix, we're literally using the traditional method of submitting forms. We define what type of requests we want. In this case is post when we're using the post request. As we learn that data will be appended to our body of the HTTP request, and we have access to it in our request. So in remix, when we were submitting the form, we were able to get the data using the form data method on the request and save it. So now that we're able to get our form data to our action, we will be able to make an API call to save the data to DB using strappy. And that's exactly what we're going to do next. So taking a look at a strappy application, if we go to settings under roles, take a look under public permissions, we're going to look at contacts, and we're going to enable create. And basically, in order to post data to strappy, we just need to make a post request to this API endpoint. So let's save to enable our ability to create posts. And before we add the code, let's check the strappy docs. You could navigate to strappy website, click get started, and it's going to take you to the docs. We're going to scroll down to APIs and click on REST API introduction. And here you could get more information on how all the different endpoints work. For instance, if you want to make a get request post request to create an item, that's what we're going to look at now, how to make get requests, put requests, and delete. So let's create create entry. Here's going to take us to an example to take a look what we need to do. And basically, we need to make a post request to the endpoint that we specified, in our case is going to be API contacts. And notice how we need to wrap it in data object and pass our attributes inside there. And that's exactly what we're going to do. And when the data is submitted correctly, you are going to get a response. Then we could check if we successfully submitted the form or return some errors that we're going to take a look in a little bit. So now let's go back into our code and let's navigate to our data.server.ts file. And the good news, we're going to follow a very similar pattern here. So I'm going to go to the get contacts. And I'm going to copy this whole try and catch block, because it's going to be very similar. And we're going to navigate to create empty contact. And this is actually going to be renamed to create contact, because we're not going to create an empty contact, we're going to create actual contact. And so what we're going to pass inside here is our data. And our data is going to be any right now. We'll come back and add typing later. But for now, let's just get stuff to work. And it's going to be a post request to our API contact. So if you don't pass any second parameters on fetch, it will automatically make a get request. But we want to make a post request. So we're going to add an additional object where we're going to pass the information that we need. So we're going to say method is going to be post. Then we have to define headers. It's going to be an object. So now let's define the content type. I can't speak and type at the same time. It's okay. And it's going to be application JSON. And finally, the last thing we need to do is pass our body. And we're going to wrap our data within a data object, just like we saw in the docs. And we're going to destructure our data that we're passing to our form. And then the most important thing, we need to wrap this in JSON.stringify to stringify our data being sent. And then this is complaining here. No big deal. We're going to change it to response data. And then we're going to change this to response data. Perfect. And then everything else should be all set. So basically what we're going to do, we're going to make a post request to our API slash contacts endpoint to allow us to send data that we get from our form to make a new entry. So now let's go ahead and add it to our contact create form. So we're going to remove our const log here. And we're going to say const new entry is going to await create contact. And into our create contact, we're going to pass our data object. And now let's import create contact. Import create contact from our data.server.js file. And finally, we're going to just return new entry. And we're going to const log the response after our data is created. And currently right now, there's a couple of things we do need to add. For instance, we should probably have form validation, which we'll do next. And probably if there's a successful entry creation, we should probably redirect. But for now, we're just going to test that it works to see that we are posting data to our Strapi endpoint and just make sure that we are able to get the const log in the response. So let's go ahead to our frontend application. We're going to navigate to our create form. I'm going to say test, test, test. And that's fine for now. We'll leave the other one blank. It's no big deal right now. We click create. So notice it posted our data because we were able to create it. And let's just check inside our Strapi instance. Navigate to content manager to contacts and notice that we are able to post. And what I hope that you really appreciate it is the fact that when we added a new item without doing anything, remix was smart enough to be able to automatically refresh your sidebar. We didn't have to store anything in context or state. It's just smart enough to do it. So if we create a new entry, let's say test two, we say create, boom, it's right there. So notice that we're able to get our data. And so notice we didn't pass an image. Maybe we should check that passing image is required. So we run into errors like this. So next we're going to take a look on form validation to improve our create form form. All right. We're making amazing progress. So next let's add some form validation to our form. And to do this, we're going to simplify the process by using ZOD. ZOD is a library that allows you to add form validation very, very easily or object validation. So we're going to go ahead and first install it. So I'm going to click on copy and paste the command. In my terminal inside our remix app, we're going to run the command and install it. Then let's restart our application by running yarn dev. Next inside our application, let's go ahead and import ZOD. Fantastic. And now we're able to use it. So let's navigate to ZOD homepage from our NPM. And let me make this bigger. And then we're going to get to basic usage here. And here just shows you kind of like the basic thing that we're going to do here. We import ZOD and then we're going to create a basic schema that's going to define our structure for our form data. And here we could take a look all the different checks we could do. We could check if it's a string, if it's a number, if it's a big end, if it's undefined, and so on. And you could read more about it on there. But right now, let's just jump into our example and get started. So one ZOD is important here inside our form. And right after our data, we're going to create const. And we're going to say form schema where we're going to define the structure of our schema. It's going to equal to using ZOD object and we're going to pass in an object. And here we're going to define all the things that we want to check. So let's scroll down. Our form has a first name, last name, Twitter, and avatar and notes. So we're going to write very basic checks here. So we're going to say avatar, it needs to be a string. It needs to be a URL and minimum of two characters. So it can't be blank. Then we're going to check our first name. And we're going to say, again, it has to be a string. And again, we're just going to say minimum of two. But you could add whatever values to make sense for your application. And we're going to do the same thing for our last name, last. And don't forget your comments, everyone. And then finally, we're going to add Twitter. And again, it's going to be Z string and minimum of two. And again, I'm doing very basic checks here just to kind of show you how ZOD works. But you could decide and look more into it to kind of see how you can create custom checks for your items. And notes you're going to leave out because it's going to be optional. We're not going to worry too much about it right now. So now that we have our form schema, let's create a new variable called validated fields. And it's going to be equal to form schema dot save parse. And inside here, we're going to add the items that we want to check. So we want to check our avatar. And then we basically specify where that's coming from. And we're getting our avatar from our form data here. So we're going to say data dot avatar. Next, we want to check our first name data dot first. We're going to do the same thing for last equals data dot last. And finally, we're going to check Twitter. And it's going to be data dot Twitter. Fantastic. Now we could check for our validated fields. So we're going to do an if statement. And we're going to say if validated fields dot not successful, we're going to return our error. So we're going to say return. And we're going to use our JSON object here. If we have errors, we're going to get them from validated fields dot error. And we're going to flatten the response just to make it more consumable. And all we want to get is field errors. Then we're also going to return a message. And we're going to keep this message generic, which is going to say, please fill out all missing fields. And for data, we're going to return null because we weren't able to successfully submit the form. And then make sure you import JSON at the top here. And that's coming from remix run node. And we're just going to update this so we could have one line here. So I'm just going to say type here instead. Otherwise, I would have had to do it in two lines. Perfect. Now that our form is all set, we should be able to see our errors coming back when we make a mistake. So let's going to do here data from action just so we could see it. And so now let's try to submit our form without passing any of our params. And this should be caught by our ZOD validator. And because we're not going to pass all the items, it should return an error. It should return message that we have here. And also all the fields where the error has occurred, which we'll be able to visually show in our input in just a minute. But first, let's just check it out. So inside our application, I'm going to open my inspector here, go to console lock, and we're going to go to create. And I'm not going to fill anything out. I'm just going to click create. So Norris, when we click create, we now get all of our validation. And again, this is all happening on the server because actions and loaders run on the server, which is pretty cool. And when we fail our validation is going to show us, hey, here's the places where the errors have occurred. And it's going to give us the message errors that we want to show to our users. And so now that we know that we're getting our errors, let's show these errors to our users in our form. And so if you navigate, notice how we have an error prop that we could pass. So now instead of false, let's do form data. And we're going to check if it's undefined or doesn't have errors, just return false. And we're going to say errors. And this is probably complaining. So let's go here and under use action data, let's do type of action. And this should stop our complaint. And notice, boom, we fixed it. So now let's go ahead and add this to the rest of the form inputs. And I'll show you what is doing inside the input component in just a second that we have here. But once we have all the validation, we could go ahead and scroll down now. So let's take a look at our form input. So notice we are getting the errors prop. And what we're doing is we are iterating through the errors. And if the error matches the field name, we return the message. So let's take a look and see if this works. So now when I try to submit the form by clicking create, notice that we have all the basic errors showing up to us. And so we want to make sure that we fix the error. And if I fix one and click create, notice the error goes away, but I still have all the other ones. So let's go bratz at Twitter. Let's find a nice pixel image. Pexels.com. This looks great. Copy image address. Let's go back to our application. Let's throw in that URL and say, hey there. And now we're going to create submit and notice that it went ahead and created our form. And right now the experience is still kind of terrible because although we created our form, the form didn't clear. We didn't navigate to the item that we created. So it wouldn't be nice after the thing that's created, it navigates to that thing. So let's see how to do that next in the next part of this video. So looking in the remix docs, we're going to look for redirect and click enter. And here we have an example of redirecting from form action. And it's going to give us some example, but basically we want to use redirect and we want to import redirect from remix run node. And basically once we have the user ID, we could redirect to that newly created item. So let's go ahead and implement that in our code. So let's import redirect after Jason here. And we're going to use it right after our new entry. And for now, we're just going to return our redirect and we're going to pass. Where do you want to redirect it to? And we're going to redirect it to contacts slash and we're going to append new entry dot ID. So whenever we create a new entry, we have an ID and we're going to redirect our form to that new screen. So let's go ahead and check if it works. So let's give it a try. We're going to say new test at Twitter and we're going to paste the URL of an image and say hello. And now when we create the new item, it should redirect us, which it did. And boom, that is a great experience. Nice. We're making progress through learning remix basics with Strapi, which is pretty cool. So now it'd be really awesome if we could now select an entry, click the edit button and be able to update our entry. So that's exactly what we're going to do next. To get started, we're going to use a code snippet from remix tutorial here in their documentation. And so the next route we're going to create, it's to be able to add a form where we are able to update our items. So I'm going to copy contacts dot contact ID slash dot edit that TSX. And that's going to be a route we're going to create. And typically the reason why we're doing a dash afterwards, if you look here at the note, by default in remix, if a route matches with the same prefix name, it will be considered as a child route and be nested inside the parent. We don't want to do that. And the way you prevent that behavior is adding the dash. And that's exactly what we're doing here. And so now let's go in our code inside our app, inside our routes, we're going to create a new file and we're going to add our route endpoint. So whenever we navigate to contacts slash an ID of our item slash edit, it's going to bring us to this page. So let's add the code snippet. I'm going to scroll down and I'm going to click here on copy. And inside our code editor, let's paste it in. Just remember, we did update the tutorial instead of using dummy data that we had, but actually using our strappy API. So we're getting our contacts from our strappy endpoint, where we did update the data file to be data that server file and get contacts is found on that file. It's just a quick refresher. If we go to data that server, we see that we have, I get contacts and create contact and get contact functions that get the data. So now that our memory is refreshed, let's go back. So we won't need to change too much except just to point to our function that we refactored to use strappy. And the last update I'm going to do here, I like to have this throw on one line just because it mentally makes my brain happy. And if you scroll down, when we use this loader to get our strappy data, we get the data through this contacts using use loader data. And we are setting it as the initial value using the default value prop. So we're getting contact object and we have items there for the first name, the last name, our Twitter handle, our avatar URL, as well as our notes, our contact notes. So now everything should work in terms of showing our data. So back in our application, now if I hit edit, Norris, it takes us to our contact slash ID slash edit page with all of our data already prefilled. And we don't see a Twitter handle here. Let me just check. That's because I didn't add a Twitter handle here. Let's try another entry. Here we go. Let's click edit. So Norris again, our form is prefilled and we're able to now make our updates. So to make our updates, we're going to do something similar to when we created the form. So all we have to do is connect that logic to the save button. So inside our edit.tsx file, we're going to scroll to the bottom and we're going to find our submit button. Because our submit button has type of submit, we don't really have to do anything because whenever you click a button, which has a type of submit, it's automatically going to fire the form action. So all we have to do is we have to define our action function and our action function is going to expect a post request to handle updating our contact. So we're going to do export const action equals a sync. And inside this function, we're going to pass our params and our request. And this is coming from action function arcs. And we're going to do our error function. I realized that in other examples, I was not using error function. I prefer not using error functions, but I just want to show you that this works as well. And let's import our action function arc types. So let's do here action function arcs. And we're going to check with the invariant function like you did in our loader to see that our contact ID exists from our params. Next, we need to get our form data. And that's coming from our request.form data. And if you're just trying to remember how we get this data, it is passed automatically to us from our forms using the name attribute. So we're going to get name first, name last, we're going to get our name Twitter. And that's all going to be in our form data object that we get from our form. So we're going to destructure our data from our form using object.from entries. And we're going to pass our form data. So before we get too far, let's console.log our data. And let's return null for now. So it doesn't complain that we don't have a return in our form action. And I'm just going to go ahead and restart my project. Yarn develop to start my Strapi application. And then the front end of our application, we're going to do yarn dev. So back in our project, we're going to go to any entry, we're going to click edit, and it takes us to a form. So I'm just going to see if we're getting this data passed to our action. Can we see this in the action? And let's click save. When we click save, nothing happens. But let's look at our console.log here. And notice how we're getting our console.log that says, can we see this in the action? So I know that it's working. We know that it's updating our form data. So now that we know we're getting our data in our action, let's go ahead and write a function to handle our update. So I'm going to do const update response equals await. And we're going to call this update contact by ID. And this is going to get our data. And we're going to do a very basic check here. If update.responseError, we're going to return JSON object. And inside here, we're going to say data equals null. We're going to say error equals update response.error. And then if nothing terrible happens, we're going to redirect to contacts slash. And we're going to pass our params contact ID. Nice. So we could do additional error handling here. But for now, we're just going to keep it super simple. And if we wanted to get this response here, just remember, we would use action data. So we could do const form response. And it's going to use action data. And it's going to be type of action. And for now, we're just going to console.log for response. Then we're going to say from action. And so anytime this if statement gets triggered, it's going to return data null and our error that we'll be able to see in the front end. And we could show that error to our user. But we'll come back to this. Let's just make sure that we could actually update our data on our back end. So I'm going to now go to our data.server file. So we're going to update our update contacts. We're going to rename it to be update contact by ID. And here instead of updates, we could keep it updates. That makes perfect sense. And this is actually going to be very similar to our create method. So let's go here. And I'm just going to copy this whole try and catch block here. And we're going to paste it in. And the only difference is going to be we're making a call to API contacts slash and we're going to be passing our ID. And then instead of post, we're going to be making a put requests. And we're going to rename this to updates, because that's what we want to be passing. And then finally, once we get the response, we're going to return the response. If not, it's going to throw an error here. And if something goes wrong, the cache block will console log the error. So if you're wondering, how do I know that we need to make a request to API contacts while passing the ID? So let's take a look in our strappy application. If we go into settings and we go on the roles public and we look at contacts, we could see that we have this update. And it's great that I remember to do this because we do need to enable this. So if I click on update and click the checkbox, you're going to see that we need to make a put request to our API contacts endpoint and pass the ID. And that's exactly what we're doing. So I'm going to save this back in my code. Notice that's exactly what we're doing. And we're passing our data and our updates. And let's now import this inside our edit. And so we could import it from our data that server. And so now, and there's a typo here. That's why it's complaining. Boom. Thank goodness for our TypeScript. And so now everything I think looks pretty good. So let's give it a test. So I'm going to go to new test. I'm going to click edit. And I'm going to say Joe Mary at Joe Mary Twitter. And then did this work? And let's click save. You define an action route in contact but it did not return anything. So let's take a look here. So we want to return the redirect. That's why I was complaining. So let's try this again. Let's go back. Refresh. Notice the update still worked. But let's try to go to Paul Bratz. Let's go edit. I'm going to put my, I'm going to say Kyle Bratz. Sounds good. Hey, did this work? And we're going to do question mark and click save. Nice. So we know that our edit works. Let's try it again. To do the final sanity check. Paul is cool but not as cool as you all. And at coding 30. And I'm just typing random text because whatever. Hello from remix and strappy and save. And perfect. Look at this. Paul school but not as cool as you. Coding 30. And so our update works. So before we move on to the next step, which is write our delete functionality and then write our star functionality. Let's kind of quickly review what we did. So inside our edit.tsx file, we created our loader and our action and our form. Now to populate our form with initial data, we used our loader function to get that data based on the params. So whenever someone clicks edit, you see that there's a param of one here. That's that's the parameter that we are getting here. And we're passing it to our get contact method, which makes a call to strappy passing that ID returning that data. Once we get that data, we are using use loader data hook and be destructuring that data. And we're using it to populate our form with that initial data using default values. Now, once that's done, whenever someone hits the submit button after making the changes, that's going to fire our action. Our action is going to get the data from our form using the request form data method. Then we are passing that data to our update contact by ID method. And that expects our ID that we use to pass to our call and our data that we want to update. We're making a basic fetch put request to our strappy endpoint. Once we get the data back and if everything is successful, it's going to go ahead and redirect. If there is an error, we're going to return the error to our front end within this form response. And for now, I'm just console logging. And the reason why it's undefined is because we didn't submit the form yet or return any errors. You could challenge yourself to use this response and create a error block here that if you do get our error back, you could display it to the user. So with that being said, let's move on to the next step. It's Friday night, so I needed some mood lighting, but let's continue with this tutorial. So one thing that I do want to show you when we go to edit, we have the delete button, which is kind of cool. So we could press the lead to delete our entry. But if you go back to edit, we do have a cancel button that doesn't really do anything right now. So let's go fix it. And the fix for this is really easy because we want when someone hits the cancel button, it just goes back to the original view that we had. So let's implement it now. So inside our code inside edit.tsx file, we're going to import use navigate hook here from remix react. So let's do use navigate, and we're going to scroll all the way down to the bottom. Now, this could be a link, and that would probably make more sense. But I want to show you that you could do programmatic navigation through putting a on click event onto a button. So that's what we're going to do. So we're going to say on click, and we're just going to fire a function that's going to use a use navigate hook. And let's just scroll up to the top here because the first thing we need to do, we imported our hook. That's right. And so now what I want to do inside my edit contact component, we'll do it right below here. We're going to say const navigate equals use navigate. And what's cool, right where we're going to use navigate, you can pass, let's say a URL endpoint that you want to go to either home or contacts, or if you want to go back, you could just pass negative one. So very simple fix here. So now when we go back into our application, if I click edit, and I click cancel, it takes me back. So one more time, if I click edit, and I click cancel, it takes me back to where I was. Okay, awesome. Now we are going to implement the delete button. Now before we do that, let's go into settings. And we're going to enable delete and Strapi. And this is going to show us the endpoint that we want to hit. So let's go ahead first and create this function that will delete an item from Strapi. So in our code editor, let's navigate to apps, data.server.ts file, and just quickly review, let's look at the pattern that we've been following when creating these functions. Notice that we always start with a try catch block. And we're basically making a fetch request. And if we take a close look to all of our different API calls, we're following that same pattern. And so what I'm going to do is I'm going to use get contacts here as an example. And I'm going to copy the snippet, and we're going to use it to create our delete contacts. So under delete contacts, let's paste that try and catch here. And we know that in order to delete, we're going to this API slash contact slash, and then passing the ID endpoint. And we know that because we saw it here in Strapi. And the only difference is, instead of making a post or get request, we want to make a delete request. So we're going to say method is going to be delete. Excellent. And I believe that's all we need to do here. And now before we call this function and use it, let's kind of go and look at one example here in our routes. Let's go to edit. So notice whenever we were making a form submission, we were defining an action inside that same file. But you could actually define this action as a standalone route. So what we're going to do, we're going to create what we call a resource route. And a resource route is a route that does not default export a UI component. So for instance, I'm going to go into routes, and we're going to create a new file. And we're going to say contacts that we're going to want to get the ID through the program. So we're going to say contact ID, and we're going to say dot delete dot TS. I copied and paste this example action, and we're going to use it here as well. So I'm going to paste my example action. One thing we want to make sure we import is our types. So import type and its action function arcs, action function arcs from remix node. And we want to import invariant, import invariant from tiny invariant. And we don't need the form data or the data. All we're going to do here is await our delete method. And we're going to import from our data.service. We're going to import delete contacts here. So let's do import delete contacts. And the reason why I'm copying and pasting sometimes from our existing code is so you could see that a lot of the things that we create once, it's a pattern on that variation. And so a lot of times, when you create one basic functionality, you could use it as a pattern moving forward. And there's obviously other ways that you could optimize your code so you don't have to repeat yourself. But I just wanted to show you that there's a lot of patterns that once you establish them, you could reuse in your code. And basically what we're going to do here, we're going to check if the param exists. If so, we're going to go ahead and call our delete contact function by passing the ID of the item that we want to delete. And then if it's successful, it's going to redirect. And let's import redirect here from node redirect. And I guess let's adjust this. We'll say type in front so I don't have to put it on two lines. And if it's successful, it's going to redirect. And by the way, if there's an error, it's going to be caught by our try and catch here. But for now, we're going to keep it super simple. So now that we have our route defined, so basically, if we remember, contacts.contactid.delete actually stands for contact slash id slash delete. So if I wanted to delete an entry, and I guess I'm not using the request here so we could delete it, I would just make a post request to the delete action. And we're going to take a look at that next. So inside our code, we're going to navigate to our contact.contactid.tsx file. If we scroll down, we're going to have a form with an action called destroy. And this correlates to what we called the route. And notice that because we're in contacts slash contact id, we don't need to put the full URL here. We just put the endpoint that we want, which is delete. So notice contacts slash id slash delete, contacts slash id, the first two parts match. So we only want to show delete. And when we click delete, it's going to make a post request to our resource route that we have created. But before we could test our functionality, inside your strappy admin panel, go to settings, go to user's permission plugin on the roles, on the public, and on the contacts, make sure you click delete, and click the checkbox and click save to activate this endpoint for strappy. Because in our code, when we click the delete button, it's going to call our delete action that we defined in this file here that is going to call our strappy endpoint delete contact, which is making a request to our strappy endpoint here. So that's why we want to make sure that it's activated. Now that it is activated, let's see if it works. So I'm going to delete test user and I'm going to click delete. It's going to ask us to confirm. I'm going to say okay. And oh my gosh, we're at not found. What is going on? So we going to take a look at it. I think I know where we made a mistake. So inside your code, inside our delete action, notice here that we are passing an id. So what is happening, we are passing an id that no longer exists because we delete it. So all we have to do is just erase this and keep it this way. And now this is going to work. But we're still going to have an interesting problem. So let's try this again. I'm going to create a new entry test data at Twitter. For the dummy image, click create. So now when we delete the entry, notice right now we are contacts are 12 that exist. If I click delete, we are again going to show not found. So two things we need to do. Number one, we need to figure out how to handle an error such as 404 to not break our app like it's breaking right now. And number two, it's how do we render this empty page? For instance, if we have items or how to handle not found when there's items that are not found. Notice how putting IDs of items that don't exist and our application is just not working. So notice that we have one entry with ID of nine because it exists. We don't have an issue. If we do 10, it's going to complain. And if we just go to contacts, it's going to complain. So first thing, let's fix this contacts route. So let's take a look what is happening. So inside our application, let's go to our browser here and look at our routes. Notice how we have contacts slash ID slash added, contacts slash ID slash delete, contacts slash ID, contacts slash create, but we don't have just a contacts route. And that's why we're returning not found because this route doesn't exist. So let's go ahead and create it. And it's going to be very similar to what we did here. We are going to create a standalone route, so not a parent route. So for instance, if I create a new file called contacts.tsx is going to be a parent route. That's not what we want because TSX, this is going to be a parent route and everything underneath here, like all these items, they're going to be nested children of that route. That's not what we want. So the way we make it a standalone route, we put this dash. So here, I'm just going to create a very basic component and we're going to call it contact route. So this will show up when no items are selected. So let's see if that works and we don't need to import the react here. So now when we refresh, notice how this now doesn't fail, this works. But if I do navigate to anything here, notice how we still get 404. So next, let's take a look at how to handle errors in remix. Before we handle errors, by the way, you could also throw not found errors. And here's an example, you could do a response past the code and it could be for any type of response that you want. And we actually kind of use this already. So inside our code, if we look at contacts, contact ID, and we scroll up here, notice here we are, if there's no contacts available, we are throwing that new error. And that's what is actually causing our 404 that we see on our page. But notice how that breaks our whole app. Wouldn't be nice if we could somehow catch errors and only encapsulate those errors to the routes where that error occurred. So that means that the rest of the application is going to work. So let's take a look at our root error boundaries found in remix. Root error boundaries allow you to throw errors within a specific route. So what we're going to do, we're going to use this example. And if you're following along with this tutorial, you could look up root error boundaries and you could find this example. And I'm going to copy it. And right now we're just going to paste it in the root of our project. So I'm going to navigate to the root of my project. And right above the app component, I'm going to paste in our error boundary here. And so there's a couple of things we need to import. So use router error hook allows you to get access to the errors and you import it from react. Use router error. And then we also need to do a type check. So remix gives us this amazing utility function. So let's also import that as well from react. And now our error boundary will stop complaining. This is just a warning. I have this freaking insane this extension called, if you want to hate yourself, error lens. Install this extension. You're going to you're going to hate yourself. And so it just complains all the time. And this is just a warning. So it's nothing, no big deal. But anyway, and so now that we have our error and just to kind of give us a visual representation of this, I'm going to say class name. I'm going to say root error. And this is the error that's going to be in the root of our project. And we could actually update just a little bit. I'm going to move this to a paragraph tag here. And then here we're going to say, oops. I don't know how to spell oops, but is it oops like this? Yeah, sounds good. It's game over. Okay, so we have our root error boundary in the root of our project. So no matter where we have the error is going to default to this boundary here. And let me just go to the app CSS and add some basic styling so we could visually see it. And so in app.css right here, I'm going to do my class root error. And we're going to keep it simple. We're going to say background red and then color white. So now in our application, if we go and everything is fine, this is great. But if I go to a different route or some sort of error cures, it is going to go ahead and fire that root error boundary. But notice how application is actually kind of broken because there's nothing I could do now. Let's kind of see how we could improve this. But before, let me add some padding because that looks kind of ridiculous. So we're going to say padding, we're going to do 6 RAM. That sounds good. And refresh. Nice. And so we have our oopses game over, but my application, there's nothing I could do. So let's see how we could do this better. So we know this is happening on our contacts. So if I want to catch an error in our contacts, what we're going to do, we're going to use the same pattern. So let me copy this here. And we're going to go to our routes, contact ID TSX. And so this is where we're having an issue when there's not found because this is where we're throwing this error. So by throwing the error in our loader, we could actually catch it here with our error boundary. And we're going to simplify this error boundary. We're going to instead of a body, make this div. And then we're going to delete all this unnecessary stuff here. We don't need the script. And let's going to do contact error just so we could style it differently. Let's import use router error. And then is router error response. Perfect. And now that we have our error, let's say your contact has left the building. And we're going to adjust this in our CSS. So it's not scary looking like our first error. So let's go to app.cs. And we're just going to add that class. And all we're going to do is keep it friendly. We're just going to give it 6, 6 RAM. So check this out. Going to our project. Now, whenever we have an error in a specific route, it is actually just going to throw that error in that route. But notice how the rest of the functionality still is there. So that's the benefit of having error boundaries that you could define in specific routes. So that way, whenever your application breaks, it is not going to be your whole app, but just that part. And if we wanted to improve the experience, we could kind of create a back to safety button, if you will. For instance, inside our contact ID here, we could add another div. And inside this div, we're going to put a button. And we're going to say back to safety. And we're going to add an unclick. And this could be a link, by the way. But I'm going to show you, just to review, the programmatic way of navigating in Remix. So we just want to have a back button. So we're going to use navigate. And to go back to the previous URL, we're just going to do negative 1. And for this to work, we need to import, use navigate. So let's navigate. And it's going to use navigate. And let's just double check. Make sure that got imported here. Perfect. So now our error boundary has a button. So let's see how that looks. So if somebody goes to a wrong URL, you now have this error boundary. Our application didn't fail. And we have this button that will take us back to previous URL, which was working. So this is a great way for you to maintain great usability in your application. So now that we know how to throw our errors, we are able to update, delete. Before we implement the search button and do final tweaks to our app, let's finally make this like button work. So we have this star. And what we want when we click the star, we want it to favor this. Or if we unclick it, we want it to unfavor this. So let's see how to do this in the next video. Believe it or not, implementing this update is going to be easy. Because we already have the foundation. If we go into apps, go into data.server, you'll notice that we have our update contact ID. And this is basically what we're going to use to update the like or dislike or star and unstar functionality. So let's go in our application into routes. And that's found in contacts.contactsid. And we scroll all the way down. We're going to have our favorite function. Which is a form. And if you had to guess, how can we get this? Of course, that's using our action function. We will be able to get the data based on the name in our action and update it accordingly. So let's scroll to the top. And right after our loader, we're going to export a sync function. And it's going to be action. We're going to need the params and response. And that's coming from action function args. We're going to use our invariant function to double check if we do have the ID. And if that's the case, we're going to get our form data. Which is going to await response. And I made a mistake here. That should be a request, silly. It's going to be request.formData. And this is going to give us access to our elements in our form. Now we're going to call our update content by ID. We're going to pass our first argument, which is our ID of the item that we want to update. And then the item we want to update, if we take a look in our strappy application, our content type builder, we have favorite. So this is what we're going to update. And it takes a boolean. So let's do favorite. And we're going to get it from form data.get. And we are able to reference the item we want to get here, which is favorite. And if you want to know where that's coming from, that's coming from here on the bottom. Our name of the button is favorite. And this is where we're getting that value. So back in our action, after we get favorite, we're going to check if it's equal to true. And if it's true, it's going to return true. And if it's not, it's going to return false. And that's really all we had to do. So now let's go check it out. In our local host, now I'm able to favorite. And notice by magic, remix updates the state here as well. And this is the power of remix, is that you don't have to worry too much about crazy state updating and nesting. Remix like magic just does it. Look at that. Change the state, change the state. This lives in two places. This is in our side menu. And this is in our contacts slash contacts ID route, which is pretty cool. And that's the superpower remix. So we're almost IT end here. We got our edit working. We got our delete working. We're able to add new items. We're able to update, meaning like or dislike or star on star. And now finally, let's implement our search to be able to search our items. So I went ahead and added the rest of the folks here into our application. And all of these users you could see are found in our Strapi instance. And let's do 50 so we could see all of our users. Fantastic. So this is pretty awesome. We have our data that is stored in Strapi being consumed by our remix application. So now let's go ahead and implement this search feature. And there's one thing that I want to show you before we do that. So I'm going to create a test user. And we're going to do test, test, test for everything. I'm going to add my image and click create noise that a user has been created. And I'm going to start a user. But when we take a look here, we don't see our user. And the reason is Strapi has pagination by default. And you could learn more about it by going to our doc. So in Google, you could just search Strapi pagination docs, click enter. It's going to find the search in Google, go to sort and pagination, and you could read more about it. But if I scroll down here a little bit, we'll see that by default, we set the page size limit to 25 because the idea is if you have a thousand, a million items, you don't want to get them all at once. And because we have more than 25 users in our application, the reason we don't see the newly generated user because we're only returning 25 of those. So the way you would handle this, you would implement a whole pagination where you would be able to navigate from page one to page two. And based on the page you select, you would get those items. That's slightly beyond the scope of this tutorial. I will make some future tutorials that will cover that. But for today, the easy fix will be for us to change this from 25 to 50. So if I just navigate to API slash contacts, and we take a look at the response, if I scroll all the way to the bottom, we'll notice that our pagination is set to 25 items. But in total, we have 31. So this is going to be easy fix that we'll do first, and then we'll cover how to hook up our search block here. So let's do this. So now within our project, let's navigate into apps and all the way to our root.tsx file. This is where we're getting our initial contacts to populate our left navigation. So notice we're calling the get contacts method. If we navigate to get contacts, you could either right click and click go to definition, or you could click and go to our data.server.ts because that's where that file is defined. I just wanted to show you that you could find it in both ways. And here we have our get contacts function. And we have this query param that I said we were going to come back to. And just like we alluded in our documentation here, notice how we're able to pass a query to our response here in order to pass additional query params. For instance, define the size of the page. Of course, you could use the documentation, but I just want to share with you this blog post that is found on strappy.io in blogs. And it's called demystifying strappy populate and filtering, which covers all you need to know to quickly get started. Because for beginners, this might be a little bit complex if you've never done this before. But this shows you how to populate and filter and query all the different items that you need. And the reason why we have populate and filter, because when you're working on an application, you might have a lot of data that you need to return. But the best practice when returning data from your API is only get the data that you need instead of getting everything because it might be too much for your front end. So the idea by using populate and filtering, you're able to tell strappy what items you want to get back that is required to populate your front end. And another resource that is great. And again, I always like to use Google because if you're not sure how to find something, Google is your friend. So if you type strappy query builder, it will bring up this nice interactive query builder and explain to you how to construct queries. So here's an example of our complex query that it's sorting in ascending order based on title. It is filtering. So it will only get the items where the title equals to hello. And it's restricting to populate certain data. For instance, author field may have a lot of items, but they're saying, hey, I don't need all the items. I just need the last name and the first name. And here, as you could see, they're defining the pagination, the page size, and so on, which we're going to use in just a moment. And so in order to use this human readable object notation, we do need to install a library called QS. You could accomplish the same thing using LHS syntax. But as you could see, this is not really human readable and it's a pain in the butt to use. You could find NPMQS to find the QS library and you could learn more about it. But basically what it allows you to do, it allows you to write your queries in a object notation similar to what we're doing here, which makes it much easier to manage and more human readable. So in my application, I'm going to stop the front end and I'm going to do yarn add QS. If you're using yarn, you could do NPM install QS. Also, because we're using TypeScript, it's going to ask us to install the types as well. It's not going to complain here, but it will complain in VS Code. So we're just going to do that right now. So once this is finished, I'm going to do yarn add types QS. Perfect. And then I'm going to restart my application by running yarn dev. Now, inside our code, we're going to add a question mark and we're going to append our query params here that we are going to use. So now let's navigate to our root.tsx file and add the appropriate changes. So the first thing I'm going to do is I'm going to import the QS library. So let's do import QS from QS. Now we're going to scroll down a little bit and here we're just going to define a simple variable called query and it's going to use our QS library that we just installed and the method is stringify which will take an object. And this object is going to take the query that we're going to use this object notation and we only want to for now fetch more data in our page donation. So I'm just going to copy this and definitely read the docs to learn more. Or if you have any questions, just ask them all in the comments. I'm going to make sure to be as supportive as possible in the comments below to answer questions and also start a separate thread on free code camp forum just specifically to answer questions for this tutorial. So now that we have our query, instead of page size being 10, we're going to set it to 50 and we're going to pass our query to our loader. And I noticed that our loader is defined above so let's go and move this above our loader so we have this accessible. Nice, now that we have our query and I get contacts here, we are going to pass our query. And notice that our TypeScript wasn't complaining because if you take a look at get top texts, we did make query optional which is perfectly fine and it said either as a string or a null which is not an issue. If you want to make sure that query is always required, you could take out the question mark and in the root if you don't pass in the query, TypeScript is going to complain. So I'm just going to keep it like this for now. And there's many ways of doing things, you're just going to stick to the most simplest way. So now that we're setting the page size, the previous issue that we had where I added a new item and it wasn't being returned, now that we are limiting instead of 25 items to 50 items, we should see all the items. So if I scroll down now, you see that we have our last item test which is fantastic. So now let's take a look how we could modify our query and this form to allow us filter our users. When we created our create form, we learned about form submissions in remix. So now let's take a look what happens if I put a search term in here and click enter. We notice that we get a form submission with a query program that is sent via the get request. So if we take a look at our form in its current state in our code here, let's scroll down to our form. Here we have our input. Whenever we type any text and click enter, it gets submitted in our URL just like you see here. So now scrolling up to our loader, what we could do is we could get our URL param so we could utilize it in our search. So in our loader, we're going to get our request object and the type is loader function args. And now through the request object, we are able to get our URL. So we're going to save it to our variable called URL and we're going to say new equals URL and we're going to use the request.url. So let's console log it first to see what we get. Console log URL. And because this is in our loader, we're going to see the console log in our terminal. And let me just say from loader. And you're probably saying, wait a second, well, how come we're using the loader? Because in the past when we submitted the form, we used an action. So whenever you're submitting a form and using post, that would be using the action. But in our case, we are just submitting the form. And if we don't provide any method, it's going to go ahead and just use get. And whenever you use get, that request is caught by the loader. And that's where we're able to look for the URL so we could take out the URL query param that we want to pass to get contacts. But before we get that far, let's see what we get. So here one more time, I'm going to click enter. And again, it's going to pass our form params as a query param in the URL. And let's check our console log. And notice we have the whole URL path with the query param. We also have our search params with the search params. So if we wanted to get the params out of the URL, we could use the search params. And so that's accessible to us through this search param value. So let's go ahead and do that now. So in our loader, under the URL, we're going to say const query equals our URL dot search params. And we use the dot get method. And we'll pass the key that we want to get, which is a queue. So now let's say I say Joe and click enter. Notice we see Q, which is a key. And Joe is our value. And this is where we see here under our search params, we see Q as the key. And Joe is the value. So that's one way to do it. So now we know that we're getting the value. Now what we're going to do, we're going to pass that value into our get contacts. Now I know earlier in the example I showed you setting up this query here inside the root.tsx file. But we're actually going to move it inside the get contacts method here. So let me just erase the import that we no longer need here. And what is this complaining about? Loader function is only used as a type. That's right. So when it auto imported, it didn't do it the correct way. So I just set a type here. So now let's navigate to our get contact function. And inside here, this is where we're going to put our query. And we need to import our QS. And this we're going to just call Q. And we need to import QS in the top. So let's do import QS from QS to get access to the library. So now in our get contacts, we're going to be passing our query value, like whatever we want to query on, which is going to be the value that comes from a search box. And we're going to pass it into our query object here where we use QS. And you're probably wondering, well, how are we going to use this to be able to tell Strapi to find items with a specific search parameter? So in Strapi, we have this concept of filters. So again, if we go to Strapi documentation, and we say filtering, and we take a look, here we have all the different params, equals, not equals. And we could use these params to construct filtering options. For instance, here's one example using QS. So here we use filters. And we say we want username. If a username is equal to John or a query that we pass, please return that item. And that's exactly what we're going to do in our code. So inside our query string here, right above the pagination, let's add another object. And it's going to call filters. Let me make sure we put a comma at the end here. So JavaScript stops complaining. And we want to filter on couple of things. So in our app, we have our user's first name, last name. We also have their Twitter. And so let's give our app the ability to either search people by their first name, last name, or search via the Twitter. If you take a look at the data that our Strapi API returns, we have all these different things we could search on. So we're going to select to search on first or last or Twitter. So if any of those things match our query param that we pass, then go ahead and return any of the matching items. And the way we're going to do that is we're going to use our filters. And we could use the or because we're going to have a couple of different terms. So we're going to say, or, and it's an array. And it's going to be an array of objects of the items we want to check. So we want to check first. And so we're going to say, if first name, and we're going to use contains. And if you're like, where are you getting all this stuff? I'll show you again in just a second. But for instance, we're going to check, does the first name contain our query param that we set? So whatever we type here, and we click Enter. And notice how we just returned one entry with Paul because it found an exact match. And so the way it works is because we're taking this query term, and we're passing it from our form, recatching it in our loader. And we're taking that query term, and we're passing it into get contacts. And inside get contacts, within this filters object that is used by Strapi, we're saying, hey, check all the items. Check in the field first and see if it contains that query term. And we're actually going to also check for last name, last. And we're going to use this contains our query string. And then we're also going to check at Twitter. So we want to also match for Twitter items. We're going to say contains queue, perfect. And so now when we're sending our request, we're checking via our filter params to check does the first name contain the query string, or does the last name contain the query string, or does a Twitter handle contain that query string. And so now if we go back in our application, and let's say we go back to regular where we're not using any. So for instance, let's say I want to find Monica Powell's. I should be able to type Monica and click enter and boom. It will go ahead and show her if I remove the query. Let's say I want to find someone by last name. Let's say Lee. I could do Lee enter and then let's back. Or if I want to find someone by the Twitter handle, I could do at coding 30. That's my Twitter handle. So when I click enter, go, here you go. It goes and finds me. So you could see that we're able to search either by first name, last name, or the Twitter. But the experience is still terrible. I still have to type in my search, right? Like John and hit enter. Wouldn't be awesome if we could just start typing and it will automatically search and make a request to find that item. So let's go ahead and see how to do that next. And the coolest part about this right now, I went ahead and I disabled JavaScript. So right now, our JavaScript is disabled. And I'm going to continue blocking JavaScript because I want to show you something cool here. So our application will still work because it doesn't rely on JavaScript. And that is the cool part about Remix, this whole concept of progressive enhancement. So you could get majority of each of your functionality to work without JavaScript. And then you use progressive enhancement to improve the user experience. And I think it's kind of cool. And you could definitely look up more about this through reading on Remix documentation or just Googling progressive enhancement. But that is pretty, pretty awesome and pretty ecstatic. So now let's synchronize our search value inside our search box to our URL param. And what I mean here, if I type Paul right now, for instance, and click enter, it's going to go ahead and find Paul, of course, and we have this query string. And if I type John, it's going to go ahead and look for anything matching John. But what if I type a value here, let's say Lee and click enter. Notice we're able to find Lee, but we don't see this value inside our search box. So let's go ahead and add that first. So inside our root.tsx file, inside of our loader function, we're going to return our contacts, but we're also going to return our query param, which will be available to us. And let me rename this to Q just to make it much simpler here. And we will have to adjust this by the structuring our contacts and our query. And now inside our form, we're going to say the fault value, it's going to be either Q or an empty string. And let's see if that worked. We could type Paul, click enter, great, we found Paul. Now let's say if I type Lee here, Lee, enter, notice that it updates our UI. So there's still one issue we have, notice how we're on John. And if I switch back, the URL changes, but the search param inside the search box doesn't change. It only changes when I hard refresh, but we don't want to do that. We want this to be done automatically. So let's fix this by using a use effect. Let's import our use effect. So let's say import use effect, and that's from react. And we're going to scroll down here inside our app. After contacts, we're going to say use effect, which is going to take another function. And what's cool in remix, we could make this form be a controlled form or keep it uncontrolled form the way it is. If we were to make this a controlled form in order to get this value, we would have to use state and do something value equal set value and then do it this way. But you could actually just stick to JavaScript. So one way to get the data or the value of this form is just by using JavaScript and getting it based off this ID. And that's exactly what we're going to do in our use effect. So we're going to say const search field equals document dot get element by ID. And that ID is going to be Q. So that's going to give us access to our form element or I should say our input element that we have here, we're going to do a little type check here, we're going to say if search field is instance of HTML input element, then let's use it. And so we're going to get the value or set the value I should say by saying search field dot value, and it's going to be equal to either our query param or an empty string. Perfect. And let's set our dependency, which is going to be our query param. And this should fix that issue. So let's go back and check it out. So now in our app, when I use the back button before when our search field wasn't being updated with our current selected data, now it does so, which is pretty cool. So now let's finally add the ability to submit our form when we are typing, which currently is not what happening. So now in our root.tsx file, let's go down back to the form. And currently, if we take a look at our form, the only way we're able to submit it is by by hitting the enter button. But what we want to do is submit our form programmatically when values in the form change. And so what we're going to do, we're going to use on change prop. This is going to take a function that's going to currently be blank right now. And remix has a use submit hook that allows you to programmatically submit a form. So let's go ahead and import it. So here we're going to say use submit and scrolling down inside our app component. Let's do const submit equals use submit. And now we could use our submit method here inside our form in the on change. We're going to say submit and inside we're going to get our event. And let me move this down to another line so it's easier to see. And from our event, we're going to get current target. So this is going to get the value from our form. So let me refactor that a little bit. So perfect. So now anytime our form changes, we are going to fire this submit method that's going to go ahead and programmatically submit our form. So let's see if that works. So in our application, I'm going to type Paul and notice how now every time our form changes, we're able to query our search, which is pretty awesome. So currently when I am typing things to search, we don't have any visual representation that something is happening. So if we had a slower network, so let's go ahead here into network and say we have a very slow 3G network. And so any type I type something, notice how it takes a while to search for the item. So let's go ahead and improve the experience by adding a loading spinner. And we're going to reference the documentation to see how to do this. And in the remix, we have the use navigation hook, which gives us some feedback. So let's go ahead and use it. So what we're going to do is first import the use navigation hook. So after submit, we're going to say use navigation. And then inside our app component, we're going to do const navigation is equal to use navigation. And then we can also do navigation dot to kind of see all the things that we have access to. For instance, we have form action form data for methods and so on. And then we also have this access of state, which tells us if we are submitting, if it's idle or loading. So we have all these useful methods that we could use. So for the particular example here, we're going to use navigation location. And we're going to check if the query has a query parameter to identify if we are currently in searching state. So when there's nothing's happening, as you could see here, navigation location will be undefined. But when the user navigates, it will be populated with the next location while data loads. So let's go ahead and implement this. So we're going to say const searching is equal to navigation location. And we're going to create new URL search params, nav location search. And then we're going to check if it has our query. So now let's go ahead and utilize this in our form. So we're going to scroll down to input and we already have the CSS set up. So here we're going to say class name, and we're going to say if searching, then we're going to append the class loading. And if we're not loading, just have an empty string. And here currently our spinner is hidden. But now let's only make it hidden if we're not searching. Nice. So this should do the trick. So just quick review in the searching variable, we're able to use navigation location to check if we're currently in searching state. If so, we're going to use it here in our input. So if we are searching, we're going to change our class to loading, which is going to style our input appropriately. And same thing here for our spinner, which is currently hidden if we're not searching. But if we are searching, it's going to show. So let's go ahead and test it in our application. So now when I start typing, so notice how you could see the spinner happening when we're loading. This is pretty cool. So now let's see how we could improve our search functionality. And referring to remix documentation, they have a bit here called managing the history stack. And what is happening since the form is submitted on every keystroke, typing each character and then deleting it will create a huge history stack, as we could see in this example. So to prevent this, let's see the changes that we could do. So here we could use replace in submit. So let's search replace us props. And as you can see here, what replaced us, it replaces the current entry in history stack instead of pushing a new entry, which is exactly what we need in this use case. So let's go ahead and implement this in the code. So let's scroll down and make the following changes in our function that we're passing to our on change. So the first thing we're going to do, we're going to put it in the brackets. And above the submit, we're going to create a const. And we're going to call it is first search. And we're going to say if query is equals to null, then it is first search. Then inside of our submit method here, we're going to pass a second argument. And we're going to say replace. And we're going to say exclamation point is first search. Fantastic. So now that should fix our history stack issue and everything else should work accordingly. So now when we start using our search, instead of creating a new item and pushing it to our history stack, instead, it's going to replace it, which is awesome. So pretty much we're done with all of our basic implementation. So let's review what we've done quickly and then see some of the basic improvements we could add before finishing this tutorial. So we implemented full CRUD functionality using remix and Strapi. Our front end is built with remix and our back end is built with Strapi, where we're able to manage our user's database and information. Inside of our front end application, we're able to create a new user free code camp. If I try to create the form without validating required fields, we get our validation, which we use zod for, which is pretty awesome. So let's add our image and our Twitter handle and be able to create a new item. We're also able to like or unlike our item. We're going to like it. We are also able to edit. You are all awesome and safe, which will update our message. And we have our search functionality where we're able to search the items, which is great. And we could also delete, but we'll leave free code camp here. So let's take a look at some of the improvements. So one improvement we're able to do is notice when we select an item, the matching navigation item is not highlighted. Wouldn't be nice that we could show what link is active once it's selected. For instance, if I go out Paul Braslowski, this should stay selected. So let's take a look how we could fix this. So in our code, if you navigate to our root.tsx file and we scroll down to our link, we have a couple of different classes that we're able to add. So inside our CSS that was provided with this project, we have a class called active. If we take a look at what that looks like. And again, because right now we're not checking to see which link path is matching. So it's going to highlight all of them, but you could see that we have a highlighted active class. And we also have a pending class, meaning it's pending to load. So if we take a look, you see this nice pulsing animation. So what we could actually do in remix, we have a component called Nevelink. And Nevelink allows you to pass a function to your class name, which is going to have two states. And the function is going to have a state is active and another state called is pending. So what we could do is return. If the item is active, let's show the active class. And if it's not active and it is pending, let's show the pending class. Otherwise it's going to be an empty string. Now, the reason why this is complaining because we need to import our Nevelink at the top. So let's navigate to the top. And after use navigation, we're going to say nav link. So now if we scroll back down, notice how we're no longer having issues. So now let's take a look at our UI. So notice, since I'm on Paul Baslavsky, the route matches, it's active. So it's highlighted. If I switch to Shane Walker, notice how it's highlighted. And because we're loading things fairly quickly, we don't see the pending state. So let me go ahead and throttle down by going to network and say throttling and use slow 3G. Notice when I switch, now we have that pending state until the item loads, which is pretty awesome. So another improvement we want to make is for this star and on star function. Currently we implemented it using regular remix form submission, which is okay. But because we're not navigating and just want to change the data, instead of using just the regular form, we could use use fetcher. So let's take a look at remix documentation to kind of see what this means. So we could actually have forms without navigations. And this is where use fetcher comes in. It allows you to communicate with the action and the loader without causing navigation, which happens automatically when just using form. And since we're remaining on the same page and we don't want to change pages and just want to get the data, use fetcher is the perfect fit. Let's go ahead and use fetcher in our code. So in our project, let's go to apps and routes and let's navigate to our contact id.tsx route. And first thing we're going to do is we're going to import fetcher up. And I missed it the first time. So action function arcs, this should be a type if we didn't make that change before. But now let's go ahead and here import use fetcher. And now let's scroll all the way down to the bottom until we get to our favorite component here. And inside here, let's do const fetcher equals use fetcher. And the only change we need to do is instead of saying form, we are going to say fetcher form. And that's the only change we have to make. So now the form will no longer cause navigation, but simply fetch the action and fire the logic required to update our star state in the database. So if we go back to our application, notice how everything still works the same. And next, finally, let's take a look how we could throw errors if something happens to our backend. So in our application, let's go to data.server. And we're going to look at get contacts and notice how we have a try and catch. And if everything goes well and smoothly from Strapi, we will return our data, including Strapi errors. But if this try and catch block fails, we want to return an error here. And we know whenever we throw an error, it is going to be caught by our error boundary. And we have a couple of them in our application, but we're going to take a look at the one inside our root.tsx file. And here we have our error boundary. And whenever there's an error that's thrown, we have an error. What I'm going to do just simplifies this a little bit, I'm going to delete this h1. So instead, we only get the messages that are delivered from our error. And I'm going to make this an h1. So before we throw an error, just want to make a note here. And you could search error, sanitization in the remix stocks within production mode, any error that happens to be on the server are automatically sanitized to prevent leaking any sensitive information, such as stack traces to the client. This means when we use and throw a new error, the instance of an error that we receive using use router error hook will be a generic message and no stack trace. So one way we could throw errors is by just doing throw a new error with some message. So let's check this out. So in our application, in our root.tsx file, we are calling the loader where we get in context. So let's go to get context within our data.server.ts file. And here in our try and catch blocks, right after the console log, we're going to throw a new error. Oh, no, something went wrong. So if there's a server error or something is wrong, this will be caught in this catch block, which will throw an error. And depending which route this error occurred, we'll use the appropriate error boundary. And in this case, this is going to happen inside the loader in our root.tsx file, which is going to use this error boundary. So now let's say if we go to our data.server file, and let's say we don't pass a URL, and boom, oh, no, something went wrong. And where is that text coming from? It's coming from our data.server from this thrown new error. Another way you could throw errors is using the response object. So we take a look at the documentation, you could throw a new response, including the message that you want with the status code. So I'm going to go ahead and replace it here, just so you could see another variation. So now not only are we sending the response message, but we're also returning the status. If I refresh, notice how we're getting the 500 error. One thing you may notice when we had our error, we just showed the status of 500, but how do we display the text? So going back to our root.tsx inside our error boundary, we are getting the error using the response and passing the 500, and we are able to see the status. Let's take a look at what the error object looks like before we see the changes that we need to make. So before we figure out what's going on, let's go ahead and console log the error object. So now I'm going to refresh, and we get our error object. If you look, we take a look that our status text is blank, but we get our message within the data. So two ways to fix this. One thing you could do is inside the error boundary here, you could do an or statement, which will basically say if status text is an empty string, return error.data, and that's going to fix the issue. So if we go back here and I refresh, notice we're getting our message. Another thing that you could do is inside the data.server file after status, you could do status text, and you could add a custom message. This is custom error, and that would work as well. So let's take a look if I refresh, and notice we get this is my custom error. So now you have two ways to throw errors. You could either use throw new error or use throw new response. And now that we finally know how to throw our errors, this bring us to the end of our amazing journey. You did it. Thank you on embarking this journey with me of learning, remix basics and Strapi. And the most important part, what we learned today about remix, about basic usage of Strapi, you could now start building cool things. My biggest goal for myself is to build things quickly as easily as possible. And I hope you could see how combining remix and Strapi allows you to do that. This was just the beginning tutorial, so there's definitely a lot more to learn. You could check out my channel Coding After 30. I have a great Strapi crash course that you could take for absolutely free. And if you really like this tutorial here on Free Code Camp, and you want me to make more tutorials, just smash the like button. Let me know in the comments if you want me to make tutorials here on Free Code Camp. I really believe in free education, and I am more than willing to share everything I know about web development as someone who switched careers late in their 30s. Into development to share here on this channel. And if you have any questions, let them know in the comments. Also, you could go to the GitHub of this project, where I shared the link at the beginning of this video. And you could create an issue with your question, and I'll make sure to help and answer. And I'll also, once this goes live on Free Code Camp, I'm going to make sure to create a thread on their forum, so that way I could talk with you and help you with this course. Because I'm not AIgenerated, and I am a human, I might have made a mistake here or there. And so if you find one, please let me know, and I'll fix it as soon as possible. But with that being said, thank you so much for coming on this amazing ride with me and learning Remix and Strapi. With that being said, I'll see you in the comments section. Take care.