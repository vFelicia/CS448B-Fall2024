this talk is titled how not to become a senior developer not to be confused with how to not become a senior developer which is don't just don't do it this suggests that there are several approaches and that some might be better than than the others so when i was when i was writing this presentation it came out as a sort of stream of consciousness thing and it didn't want to conform any other format because the ideas inside are a bit interconnected so i just try to make it as coherent as possible and what i want to do is reveal a little bit uh about how i reason about my work as a vp engineering and the work of our programmers and our field in general and some of these ideas might not apply to you directly and that is fine the point is not in the the details of the ideas really it's in the reasoning about the ideas and i'm hoping to help you get a bigger picture of uh whatever context you're working in right now and your journey to becoming a senior developer so the talk might be slightly mislabeled because i will only talk very briefly about how i think you should not become a senior developers so one of the most popular and according to me probably the most incorrect way is just list out a number of technologies that you should learn and then once you reach the bottom of the list you are a senior developer so i understand that the idea is extremely compelling because it becomes a journey that is bitesized and gamified and it's just about memorizing new tools and because we are developers we tend to have high learning capacity and a keen interest in what we're doing so the the prospect of just learning some new frameworks or tools is very compelling and i'm not saying you shouldn't learn any technologies of course you need to know something to be able to do work but i think about it as a prerequisite so i like to say that it's required to know these things but it's not sufficient to do a good job and i don't place too much confidence in better tools history has shown that better tools tend to allow us to be bigger and more complex software just as poorly as we were able to build smaller and more more simple software previously and the only thing that's that creates better software is improving the people so as a disclaimer this is some repo that has a developer roadmap and i don't know the person who created it and it's a great thing because it works as a reference for um sort of what the ecosystem looks like right now in terms of technologies so you can use this to get an overview but i wouldn't treat it as a roadmap to becoming a senior developer it's probably a road map to something else if you follow it blindly and that is a trap and that trap is called expert beginnership so if you are if you've been in teaching or education this is the bottom part is a dreyfus model of skill acquisition and when we reach the advanced beginner stage and this is a stage of just accumulating facts and putting them inside us we sort of see a fork in the road and one of the paths leads on to be more competent and beyond uh to become an actual expert and that path involves getting the big picture of what we're doing but is also another path which is the trap into expert beginnership and that is treating it as ourselves as sort of a bucket that just needs to be filled with more and more lowlevel implementation details and i i think that this simple accumulation of facts is not really enough it has been talked about in the terms of just more and more content but just letting the ideas pass through us without interacting with any of like our reactive parts isn't that hard and we need to let the ideas sort of transform our understanding of what it is we're doing so i show hands who knows about continuous integration okay who does continuous integration at work okay so continuous integration is is the act of bringing the team's systems together and making sure they work together but what is it we're actually integrating it's not really code because that's just making the characters work together we could argue that we're integrating our systems but when we do continuous integration i like to think of it also as an integration of ideas and i i extend this concept to myself as well i constantly to integrate the ideas of others with my current lattice work of ideas and i like to think of this as laying a latticework or weaving a sort of a web of ideas and i think as a junior developer you have an advantage here because you can look at your seniors and you can look at this web and you can see these are the really nice part i'm just going to take that and integrate it into my own but you can also see the thorny parts where the ends don't really meet in in my understanding and in my integration of ideas so you can use that as a counter example and say oh ted is really contradicting himself on these things so i'm going to avoid ending up there whereas for me who has been doing this integration over this for a very long time changing that part might take a lot of work so just be critical and by critical i don't mean being closeminded i come across junior developers who tend to reject everything uh until they have sort of experienced it themselves or inferred the things from first principles but i think this is a bit of a waste of the potential of having mentors and having seniors around you who have experienced things and who can warn you about certain certain mistakes and then of course pick up the ideas that's that are the best ideas you have heard of so far knowing that he will come across something better and then be ready to drop it so that is actually everything i will say about what not to do so the rest of the talk i will be dedicated to talking about things we can do instead how we can reason about our work and i think reasoning about our work is how we can get better at it and this will hopefully eventually allow juniors who are at the advanced beginner stage to graduate the competent stage and i like to start this part by asking a question the question is how long is a string and if you have if you think that this question is nonsensical that is on purpose this particular question is a rhetorical device that's used in my home country which is sweden and we use it as a retort when someone asks us a question that doesn't have enough information or enough context to be answered in any meaningful way and it's often paired with another saying which is the way you ask the question is the way i will answer it and although we all can seem to agree that this question without any supplementary information is quite absurd we see people ask questions like this seriously and people trying to answer them seriously but this question is equally absurd we could we could approach it with sort of an empirical mindset and say that well if there was a best programming language everyone would be using it and there would only be one right which is not true or we can approach it with a rational mindset and see that programming languages seem to necessitate certain tradeoffs and how we value those tradeoffs determines how good it is or not that is to say it is a subjective evaluation and the third and absolute the worst option is that we can approach it with sort of an emotional mindset where we value our own attachments or affiliations with certain programming programming languages and to me it seems like the first option is is the best one having the empirical mindset we can look at outcomes which is a very powerful manual model to have to reason about the outcomes that we're looking for and a lot of times we don't really have enough data to make an empirical judgment and we need to resort to the the rational the rational mode of reasoning about things but reasoning about things is very thorny place to be because human reasoning is is fundamentally very flawed and especially when the emotional part comes in as well so be very careful that rationalism can very easily turn into sort of religious dogma as well but if we're given the choice i prefer to never have feelings about code or feelings about ideas because it it seems to be a dead end to me it sort of locks my locks me in so whenever i find myself typing in a code review i feel i just tend to stop myself and say why am i feeling anything about this very objective piece of the system uh because it probably means i have some unexplored things there so be candid and question things objectively whenever you can uh i'm i'm going on with the questions here is javascript a bad language who has ever proclaimed that javascript is a terrible language or made jokes about it or used it as an icebreaker okay so most likely the the reason for that was emotional we had some bad experience either first hand or we had heard a story from someone else about how bad their experience was but if we tried the other mindsets empirically javascript is a great language because tons and tons of people are using it successfully for tons and tons of things if we try the rational mindset we can sort of start to articulate what what what our gripes with javascript so we can look at what it's used for we use it for ui so it's invented that's cool we have events in ui but it's general purpose and ui is sort of a specific applications we could probably do with something more specialized uh it's imperative which is not so nice because your eyes tend to lend themselves to a declarative approach so then we can we can revise our judgment that it's a bad language into it's probably a bad philosophical fit for you eyes for the web but it could be a great language if you are building a heavily evented and streaming system for example and this sort of unlocks the trap of that emotion where we look at a word or a name and we have a negative emotion and then we just try to avoid it and i think abandoning these emotional evaluations and resorting to reasoning or empiricism is can yield some very important insights so if we look at this question and we start exploring it it leads to a very important insight that programming is not really one single homogeneous discipline and just because the different disciplines share the common denominator that we write code doesn't mean that they have the same challenges and constraints and i think we should consider them different disciplines as a whole and if you're a games programmer maybe you need to know uh linear algebra by heart if you're a web developer maybe you don't need to know any linear algebra but you need to understand the business domain and you need to be intimately familiar with user behavior if you are building embedded applications maybe you need to be on top of memory management and cpu cycles which is wasted effort in other applications and i like to even say that programming is not about code that much and that might be heresy you'll be like what who is this guy saying that programming is not about code there's this tshirt that says that programmers are people who turn coffee into code and all true wisdom is found on tshirts right but i think programming is about code in the same sense that writing is about words it's just a means that we use to express our ideas and what is important are those ideas themselves and i think program is about systems in the same sense that writing is about stories so so just uh when we are while we're at it uh this this is not really a junior developer question this is like i want to be a developer question so which which language should you learn first any takers it depends on question it could be yes who said that okay just send me your estimate after them okay you should learn english because really we're we're translating problems and ideas from natural language into code and if we cannot articulate those problems or ideas in natural language then we have a really bad starting point it doesn't matter how good we are at rating code so after you learn your first language english and your first programming language what should you learn next maybe maybe if if you are into like 3d programming then that might be a good good idea uh but as well pointed out it's the might be the wrong question we need to ask what i want to do what problems am i solving what kind of programming do i want to get into and don't accept runofthemill universal answers to questions like this because there there tend to be none uh okay so to explore this a bit further we do a show of hands again who here would say they work in a technology company okay and who would say they work in a product company okay i have no idea what the rest of you are doing uh no there are no more options uh but i like to differentiate between the two and by technology company i i tend to mean a company where new technology is invented and where the primary constraint is the technology and by product company i tend to mean companies where we take existing technology and we assemble it into products that solves particular problems for some fields yes so some large companies do both so google is the most google is the most prominent example right they create the technology but they also build products from it because they are large enough to be able to do everything but because the constraints and the challenges are different what's required from you as a senior developer is is different so there's no one path to to senior developership and anecdotally i think this misconception the programming is a single discipline can lead to a sort of lack of work satisfaction so i met a lot of programmers who are quite unhappy and they're jumping from product company to product company and they they they are very into deep technology and they don't realize that uh these companies that they are joining are not like gated playgrounds where you can work with deep tech they are doing something else they are solving other other problems and these product companies tend to be rather open business almost arenas that have human context that might not be interesting to to those purely interested in tech so i'm going to go on and talk about product companies so if you work in a technology company feel free to to follow along uh so i like to think that all product development is is integrated and that is because products have many interfaces so our product interfaces at least with different markets and with different users and with technology which is why we have different teams dealing with those different interfaces so we can have a product owner who interfaces with the market we can have engineering team that interfaces with technology and design team that interfaces with users and these tend to answer different questions so the product owner the designer can answer what should it look like and the developer says how what is the best approach to building this and that work is sort of done in in isolation but i tend to think that the real magic happens in the intersections or what i call the arenas so for example if you have product and development come together product knows how valuable something is and development knows how hard something is to build and then suddenly we know what is the return on investment for building a certain thing which informs when we should build it in what order but this requires us to understand the objectives and and constraints of the other functions as well because if we don't understand their objectives then we cannot make the right compromises or we cannot negotiate when it's appropriate but of course we should obsess about our own objectives the most because those are the ones we need to to defend so what then is the objective of the the development team we could be misled to think that it is value because value is our deliverable what products are already obsessing about value so that seems wrong if our objectives are the same there wouldn't be any need for negotiation in the first place i tend to think the objective of the development team is flow that is we develop we deliver value today and we deliver it continuously and indefinitely and i think we should obsess about that and the biggest threat to flow and the greatest enemy of the development team is complexity and i think all complexity added to our code base needs to be thoroughly examined and tested for necessity before we commit to it this means that solutions to four problems are a big nono and that applies even if it means adding our own favorite technology or or pattern to to the problem uh because we all have pet solutions and technologies but as professionals we need to sort of stuff them into a drawer and wait until the right problem calls for it because all solutions also come with their own problems and they're no such thing as a free feature or a free framework so i use this chart with business people to illustrate the typical trajectories for flow the red line sort of illustrates what happens if we cut a lot of corners early on in order to achieve some shortterm delivery maybe we're not writing any tests we're not really doing any modeling we're just focusing on grinding out features but if we ask the product owner in one month from now would you like eight units of value or one unit they're gonna say eight units uh and it's important for us to protect our objective of flow and explain to the product owner that if we do that we're screwed already which brings us to another question i'm doing these questions just to make sure you're you're awake so assuming we took the red pill and now we're knee deep into the complexity depth and everyone is miserable is it better to rebuild the project or to salvage it so we can do a show of hands how many think it's better to rebuild okay how many think it's better to salvage okay so i've tried both several times and i will tell you the answer so the answer to the question is it better to rebuild or to salvage is no i can tell you that both are extremely miserable experiences and they are demoralizing and soul crushing and it's not something you want to go through so the answer is for us to to sort of maintain our professional integrity and defend our objective before it can happen and this this is extremely hard uh and it can't protect us from legacy code bases that came in like from from elsewhere but i think it's the only way to be part of the solution so in practice this involves deciding on some what is our maximum tolerable death level and make sure we don't exceed it and i think this is mostly done by making good decisions in in our daytoday work and i'm a strong believer in like the compounding effects of small improvements and the compounding effects of small regressions is equally powerful in the other direction and there might be short stints or cleanup but don't buy into the don't buy into the myth of the big bang refactoring because it never works because refactoring requires very deep contextual knowledge of the parts of the app you're working on so you can't do like breadth refactoring you have to go depth wise and it requires you to have all the details loaded into your working memory which takes time we need to ask ourselves when we accrue that why are we doing it and this is martin fowler's blog so it's it subdivides death into reckless or prudent and inadvertent and deliberate so you can see reckless deliberate is saying things like we don't have time for design which is this is abandoning our object in favor of some other other objective there might be reckless inadvertent uh as june she said you this is where we need to ask questions to our senior developers because we don't know what we're doing really it can be prudent and and deliberate thing we must ship now and deal with the consequences and the key word there there is deal with the consequences which means we need to negotiate with the product owner yes we can deliver next week but then we need some time to recover from the depth that we incur uh there's prudent inadvertent like we didn't know that it was gonna go so bad to this approach uh and as i as i mentioned product development has a an acutely human context and at some end of the chain humans will interact with the product and even if those humans are other developers they are still humans as well so if you look outside your own product team there's a sea of stakeholders that usually your product owner will protect you from by being the the authority on what's to build one and these stakeholders they provide their candidates problems for us to solve it doesn't mean that we'll solve all of them but what they do have in common is that they are human problems so they tend to be unconstrained by any form of logic or reason because that's the nature of human problems they tend to be fussy uh and this matters a lot because getting the problem right is the hardest and most important part of of the job and getting it's wrong often means imminent defeat regardless of how beautiful the the solution is or how flawless the the execution because we were not solving the right problem in the first place so no i don't think you need to think like a computer so there was this trend in like computational thinking and algorithmic thinking i think mostly you need to think like a human and define them and frame them properly so we can solve them and it's to take take ideas from the natural language that you use and turn those ideas into code mostly we need strong conceptual thinkers so so focus on that and because we are solving human problems which are fussy and not well isolated and defined like the problems we receive in school there's no magic formula really to follow and it doesn't really help to learn algorithmic thinking and in a way this is very nice because if programming was deterministic it would be a paradox in itself because programmers tend to automate things so if programming was deterministic we will be able to automate it and we would have automated it sorry and we would be out of jobs so i'd like to show you this mental model which i use to make sure that we're solving the right problems which is the most important part so i consider three parts of any effort i consider the diagnosis the definition and the framing of the problem the prescription how it intends to solve that problem and the execution which is just typing on the keyboard and i leave them in order of importance this is like orders of magnitude from the left to the right and i think it again it shows the relative insignificance of code it's just committing the ideas that we already generated in the previous steps into into code and it's those ideas that matter but you should be fluent with your programming language which is not really not that hard compared to all the other things we do so it just means read up on the standard library and on the language syntax so that you can use it fluently to express ideas just like you would uh english but don't be tricked into thinking that is what makes you a good developer so just like learning the entire english dictionary doesn't make you hemingway learning ruby's standard library does not make you brilliant at coding and execution is still important and this has to do with partly with credibility so ken talked a bit about spelling errors in the newspaper and it doesn't kind of doesn't matter how relevant the story is if it's all with spelling errors the credibility is already already hurt so don't abandon it try to improve your execution with every with every task and this is usually people can get a bit annoyed with sometimes i'll say oh it's just an implementation detail and what i mean by that is we have already gone through the process of diagnosis and prescription which are the interesting parts how we type out the code is not that interesting to me in the interest of time my own guidelines as we i've just discussed i think better humans beats better tools every time and i think technical competence is required but it's not sufficient and i think what lies beyond technical competency is what sets you apart as a developer always think about constraints if you do web applications and you're thinking should i do this language level optimization to my ruby code the answer is no because the constraint of performance is io and the constraint of your team is developer resources you're trading very valuable developer resources for very nonvaluable work but also think about constraints in in your organization and your team if especially if your team is the bottleneck because then we need to utilize the our effort wisely obsessed about flow make sure you're solving real problems this is probably the most important one and don't have feelings about code so these are just my guidelines you should probably develop your own guidelines as you go along so whenever you come across an idea that is especially that integrates especially well with your understanding of our work then make it your own i think finally we need to beat the stereotype so programming is not manufacturing and you are not part of any manufacturing economy and there is the stereotype of the code monkey and we don't want to be cold monkeys and being the big monkey does not mean knowing the most tricks and i think the best antithesis to the the code monkey is is credible discerning and reflecting professionals and professionals who holds and protects their own objectives and who know when to negotiate and went to compromise and one who can tell conceptual issues from implementation issues and re reframe the problem and propose other solutions and i think it's it's developers who know what they know and what's what they don't so we need bold developers as involved not not both and of course for everything else there's always taco that's all