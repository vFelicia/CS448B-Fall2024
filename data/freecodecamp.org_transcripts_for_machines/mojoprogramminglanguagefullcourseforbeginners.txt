the Mojo programming language combines the usability of python with the performance of C it's basically an enhanced version of python specifically designed for artificial intelligence developers in this course Elliott Arledge will teach you how to use Mojo Ellie has created many popular courses related to Ai and he's the perfect person to teach this course let's start learning welcome to intro to the Mojo programming language course you're going to learn the fundamentals of using Mojo you're going to learn some of the intermediate and advanced features of it as well but before I touch on those I should cover some Basics first so you might be wondering who the heck is this guy on your screen well my name is Elliot I'm a computer science student a computer science student undergraduate and I like to mess around with code I like to train language models in my free time and I build awesome content like this so if you end up enjoying this feel free to subscribe my YouTube channel is just in the link in the description so you can totally check that out if you want uh a little disclaimer Mojo's a very new programming language it was actually released a week or two ago and by the time you're seeing this this course may actually be out of date so a little disclaimer there uh there there might be some new features there might be some weird syntactical things that don't work the same but this is to cover right now there may be some new tutorials that come out in the next you know little few months here or maybe even the upcoming years so just a little disclaimer this may be out of day by the time you're watching this this video is uploaded in September of 2023 so a little discommer there the docs specifically the Mojo docs the Mojo documentation says that this language is actually designed for experience systems programmers but the point of this course is to provide you with the fundamentals of getting using Mojo and being able to easily bounce off the documentation when needed so it assumes some fundamental knowledge of simple languages like python uh if you don't have any programming experience I recommend you touch on python a little bit or you could even just chat GPT your way through it that's what a lot of people do in fact that's what I did to learn a lot of what I know now uh understanding a programming language in depth will help you adapt to other languages as well so if you have some knowledge from ABC or C plus plus or JavaScript or python this course will just be even more easy for you to understand uh we're not going to be doing any intensive projects we're just going to explain how the language and the Mojo command line interface works so we're going to be building some simple scripts we're going to be building Jupiter notebooks using the Mojo language and we're going to be doing some command line stuff too this materials only backtested on Windows all you really need is a Linux terminal like Ubuntu and everything is the same so this means if you're on a Macbook for example you could search up a little tutorial on YouTube for how to install Ubuntu and get that set up but anyways as long as you have Ubuntu and that little Linux environment everything should be the same we will be using visual studio code to edit things here jupyter notebooks will be in the browser you'll you'll see that later if you're not familiar with Jupiter notebooks yet but um just the premises that we'll be using vs code as our text editor and lastly before we jump into what Mojo is I want to say that for those AI enthusiasts I'll begin with some simple sequential cpubased processing and then later in the course we'll jump into some still CPU processing but in parallel so parallel is essentially or at least sequential is when you do things one by one you wait for one to complete and you start the next and then parallel would mean you do a bunch of tasks at the same time so we're going to start off with some simple sequential based processing just to understand the language because we don't really need anything else to understand the language we don't need super high computational speeds we're just going to need yeah just some simple sequential we'll jump into parallel processing later so you might be wondering what the heck is this whole Mojo thing maybe maybe you clicked on it because Mojo is kind of the hype right now but we're just assuming you know you're completely new to Mojo you don't even know what the language is about what does it do um so essentially Mojo is kind of like a it quite literally is a superset of python so you can use all the same python syntax which a little bit of limitations of course since it's a brand new language uh and you can get the the scale and performance of a language like C plus so you can use very simple syntax to write the language and you can get insane performance out of it so why the heck do we need insane performance well the thing with python is that python is quite slow actually python is not a compiled language so python takes a long time and all of AI research right now or most of it is actually built and deployed with python so all of the models that you'll see a lot of the machine learning courses that you'll see on YouTube and in other places are purely based on python so what is mojo exactly doing well it's it's like python except you're getting that speed where you're able to train models or do renders way quicker so imagine it taking you you know four hours to get your model to a certain prediction accuracy than with Mojo if you were if you were able to optimize around that and you know put a little bit more effort into it you know some key features that Mojo uses will allow you to speed up the process and you will essentially be able to train the model in a fraction of the time so instead of taking say four hours it would take you maybe a few minutes if you do it right uh so as advertised Mojo has insane speedups over Python Meaning up to I think 77 000 times greater uh 70 77 000 times faster than python in some cases and that's we're actually going to prove that in this video we're going to actually walk through and show how it speeds up and I'm going to walk you through how that all works but anyways this is a language to sort of revolutionize the whole AI space to make AI way faster to make training quicker to make just computation in general quicker through language and the lower level optimizations what I mean by lower level is just closer to machine code essentially higher level is like more abstract closer to English and then lower level would be closer to Binary machine code so in case you haven't seen the actual speed up that Mojo provides we're just going to go into the docs.modular.com I'll actually go back here modular.com Mojo and then you just click on the Mojo docs here and then we can go to Mojo notebooks matrix multiplication and then just roll all the way down I'm going to cover this material later in the course but just pretty much scroll all the way down and you can see that after a bunch of optimizations they end up with a 77 000 X speed up over python which is insane like that's almost taking an entire day of python code running and compressing it down into just a little over a second that's crazy there are 86 400 seconds in a day and if we divide that by 77 000 that means it's about one one or or sorry 77 000 divided by eighty six thousand four hundred gives us that's zero that's 89 of a day so before I even begin setting up I want to emphasize that Mojo is a completely new programming language was released not even a few weeks ago with minimal support on anywhere but the GitHub or Discord so as for the Discord server I'm just going to go to the the modular Discord server you should be able to find it through the the website here and essentially you sign up do your verification or whatever and then you can actually search errors so be like you know uh error for example and then it would give you you know a bunch of a bunch of results so just search up like specific keywords be smart about it uh if you're encountering like certain types of errors that are like really long don't copy and paste the entire error into the search bar uh rather just look at like what are the keywords that this that this error throws and then just paste those in and just experiment and see if anybody else has encountered that because there are actually a lot of people in this community if I scroll down 2000 members so there are there's over two thousand people in this community a lot of which are actually offline right now but the point is there's a lot of people that can definitely help you out and some people that have already encountered errors so you can totally use the Discord to search for answers or even ask answer or ask ask questions and the other feature that you have through Discord is if you navigate down to this Mojo section and then go to Mojo bot help they actually have an AI That's trained on all of the Mojo documentation so if you go at Kappa Ai and you say um you know what are some basics of Mojo I could say absolute beginner and then it'll create a new little thread here and it'll say stand by for 20 seconds or so and in the meantime I'll actually show you the GitHub so we go to github.com modular ml and this is everything really you have the Mojo programming language here you have a bunch of you know issues and whatnot that you can submit to it what I would recommend though is that you absolutely make sure that if you're going to be posting issues on this Mojo GitHub that you make sure it's on fault of Mojo because if it's your fault then that doesn't really help out Mojo at all because that was just how the language was intended to work but if you were able to verify and you can verify through asking the Kappa AI about your issues and even looking in the Discord and if you happen to come across errors that are on fault of Mojo then you can just go on the issues here and later in the course I'll show you how to actually uh post these errors and properly ask questions so anyways those are some of your sources for now there's a little bit of stack Overflow but not that much so your main sources are going to be a little code issues searching for answers using this Discord search bar and asking the Kappa Ai and the Mojo bot help so if I scroll up says Mojo is a powerful language designed for high performance systems programming I'm sure similarities with system languages like rust and C plus but also designed to become a super set of python this means that many language features and Concepts from python translate nicely to Mojo Etc and it'll give you a nice little summary it tells you how to print stuff you can actually copy code directly from it it tells you how to make functions uh yeah essentially it you could just ask it anything about Mojo and it'll probably give you the best answer and as soon as summarized form and yes you can ask it to summarize things for you if you don't understand a systems program and concept uh you can definitely just say hey Kappa AI summarize this for me modular and Mojo only exist on Linux machines or at least you can only download them on Linux machines this is a Windows machine but I'm going to use a terminal and a Linux environment called Ubuntu so in order to download that go to Microsoft store wait for that to load move on to awesome search up Ubuntu app and then should be able to just install it there when we open it I'm not going to set up Ubuntu all over again because I already have it so just make up a username whatever and do that whole process um I'm going to go ahead and open mine here so this is the current Ubuntu that I have it's all signed in for me you can do clear to get rid of things uh you could do it LS to list it all the directories that you have uh you can go CD and then space dot dot to go back a directory and then CD and then type in the name of the directory you want to go into and let's just look at what we have so I'll CD into the Elliott directory and you can just press tab to uh autofill that awesome so this is our Ubuntu terminal so what exactly are we going to do next well we have to make sure that we have vs code installed that's also really important so if you don't have vs code go ahead and do that right now now before we We Begin developing in the Mojo programming language you're going to pop over to extensions in vs code here and then just simply go to Mojo like that and you should see this verified modular Creator and just going to go ahead and install this this is essentially the language support so it'll be able to read Mojo files Mojo files mean you can have this fire Emoji which I'll try to copy here and uh yeah essentially this this fire Emoji I don't know where I can paste it into maybe here no that didn't work uh anyways you can have your file extensions as this fire Emoji or the dot Mojo extension both of them work so that's pretty cool uh Unicode characters for file extensions gotta love it anyways I'm gonna go ahead and close vs code here and I'm going to make a new directory I'm going to call it uh intro to I'll jump and I can CD into that so you're going to go ahead and pop over to developer.modular.com download and this is just how you essentially get to downloading Mojo So Go download now and then says Mojo SDK is now available awesome and here it says setup on Windows Linux Mac Mac Intel well you might be wondering why the heck did he just tell us to only use a Linux terminal Linux environment well the thing is if we go to Windows it's not available for Windows yet but you can use it on the Linux container remote system you can use that with wsl2 we're just going to use Ubuntu for a Linux environment same thing with Mac right not available for Apple silicon yet but you can use Linux system and then to install Linux there's no warning there so awesome to install the modular CLI you essentially just copy this code here I don't know if the code is different for different people but you're just going to go ahead and copy this and paste it into the terminal here oh okay awesome so it's newly installed and then what do we do after this well we've been let's actually check our modular version so make sure it actually exists so we have modular here and actually another way of installing a modular is to Simply go sudo apt install modular that's a different way of doing it if you'd like to do that um but this way is more guaranteed I know some people get errors with the authentication key so just just be explicit and put this curl command next up we're just going to need to install Mojo So we go modular install Mojo we found a release let's install it cool and then we don't need the rest of this this is um already done so I'm just going to close this out and I'll come back when this is done so to begin to run our first Mojo script we're going to go ahead and open this in Visual Studio code or vs code for short and all you do is you just go code dot period the period just says open in the local directory so I go enter and we get it to open up in vs code right here so I'm not going to use this terminal anymore I'm going to use the one built into Visual Studio code so it'll do that if you're on Windows you just go control and then the grave symbol it's right below the uh Escape key so awesome we have this terminal opened up let's go ahead and make a new a new file so we go main dot Mojo and uh I'm just going to zoom in on here hopefully that's good enough all right I can it's cutting me off a little bit awesome we fixed it cool so in order to actually print hello world you might be saying you know can we just do can we just print out this way and we get an error it says to do expressions are not yet supported at paloscope so file scope just means that it's not inside of a function or a class so this is not inside of anything except for the file hence it being file scope level so this is global and Mojo doesn't like that right now so to counteract this all we need to do is just go FN main FN is short for function that's what functions is what functions look like in Mojo you just go colon like that and then print hello world and then if you really wanted to you could just do a variable here you could go let X or let's hello equal hello world and then you go in a print hello like that Mojo Main and so variables do work at file scope but we're going to dive more into that later but anyways we're able to print hello world this is great so some of you who use Jupiter notebooks might be wondering well how the heck do I get a Jupiter notebook running on my machine and for those of you who don't know what a jupyter notebook is it's essentially just a giant notebook it's like a white HTML notebook of a bunch of code that you can paste into code blocks and just run it in any order you want so anyways you're going to see what that looks like in a second and to do that you're going to make sure python is installed so make sure you go python3 version awesome and then to install Jupiter just go pip install Jupiter just like that so collecting Jupiter as you can see I already have a lot of the dependencies or requirements installed so now we can simply just go oh shoot there notebook just like that and should be able to open it up right there so as you can see this is what the Jupiter notebooks look like and I can actually create a new file make sure that it's in the Mojo kernel so you do Mojo and then you'll see it in the top right here if you try to open it up in the python the Python 3 kernel then it will not work so we could simply just go for example let x equals three and then go ahead and print X run that awesome we get three and then if you wanted to you could you could say print X down here as well and you would also get three so essentially everything carries down from the bottom from the top all the way to the bottom so you can store some variables up here and then just run them later down here as well this is used for a lot of tools in data science because or at least in data science and training models you'll have some you know trained model or something you'll have spend a lot of compute power on training a model and you don't just want to throw it away you don't just want to run a single script and then just not be able to use it ever again so you can either save model files which is a bit slower and you would do that with scripting or you could use jupyter notebooks and just save model parameters from a previous code block and then reference it again so that's essentially what this allows you to do and then I'm just going to delete all of these awesome so this is our uh notebook right now this is what it looks like so you can choose to code along with the notebook or not I will be using vs code so I'm going to go ahead and close this here uh I'm going to exit in order to cancel it you just go Ctrl C like that so that's how your Jupiter notebooks work I'm just going to right click delete enter awesome so that's Jupiter notebooks for you now we're actually going to jump into how the Mojo language itself actually works so now let's actually begin with some variables so what are the different types of variable declarations that exist right now so there's let which essentially is declaring the variable a constant it cannot change in in programming terms it is immutable immutable cannot mutate it cannot change it VAR means it's it can change so let is constant VAR is not constant so varlets allows variables to be changed hence it being VAR for variable meaning it can vary uh and then we have Alias which essentially just uh compiles it stores the variable at compile time so compile time is when it's converting your code to Binary form and runtime is when it's actually just like running code itself so if you have variables that are sort of compile time you might save yourself you know some some nanoseconds or milliseconds whatever it ends up being so most commonly you would end up storing what we call libraries with Alias but we'll go into libraries more later so we have let Varan alias so if we go you know let x equal three and then we were to print out X go Mojo like that and we get a A3 here awesome what if we were to change X to 2. we can already see a red underline there it says expression must be mutable in assignment so this x must be mutable meaning it must be able to be changed when we declare it with let that means it's a constant it cannot be changed so if we change the slides to a bar then boom we get a two so awesome and then if we were to just go uh alias it must be mutable in assignment so alias is essentially the equivalent of let but for compile time rather than run time so far is specifically for runtime and it allows the argument to be it deems the argument mutable and uh let deems the argument immutable but it goes at runtime whereas Alias would be immutable at compile time so awesome that's essentially just all the variable declarations and information you're going to need so next up let's go ahead and jump into data types so I'm just going to specifically use the let declaration here we're going to go let X and then you put a colon after and there are a bunch of different data types that currently exist so you can go you can use a string you can use an integer you can use a floating Point number or a float you can use a Bool you can use a unsigned integer and we'll go over what that means and that's that's pretty much it you have these These are the five uh common data types that we're going to be using there's one more that we're going to introduce later uh but these are the basic data types that you're going to be using so what is a string well a string good so we want to declare it explicitly a string and we let that equal and all we would do is we would put either some single quotes or double quotes around it or even these ones but I don't think it likes these ones very much so we're just going to stick with single and double quotes I like to use single quotes because you don't have to press shift when you're pressing the quote button just it's just easier that way and you don't have too extra quotes to see through anyways uh that's that's enough about quotes but essentially you could just put whatever you want in here any word I could literally put one two three and it would just say one two three but it's in a string form so it wouldn't actually be like the number one two three it would just be like I guess the word One Two Three or the string one two three if you will uh so that's strings for you you could put you know you could put alphanumeric symbols in it like like a question mark or like like a Pam symbol or a percent whatever you want uh so that's what strings look like next up we have integers so integers are any counting numbers I guess I guess you could say that so accounting number would be like pretty much negative one to infinity or negative 1 0 1 3 462 or something right um so integers are any counting number they don't have decimal places and you can either say int equals and then say like six thousand or you could be explicit and say you know int 8 equals six thousand and eight means it occupies uh eight bits on your memory so if you actually want to calculate what the highest number is that it could store it would be two since it's binary bits right and you do 2 to the power of 8 which is 256. so this could essentially store uh 256 different numbers on it or 256 combinations if you will that goes all the way from 0 up to it goes from zero all the way up to 255. so instead of 1 to 256 it would be 0 to 255 so just shift it over one but it's still the same amount of numbers so if I were to do 6000 in here it would actually uh it would not print that out it would it would actually overload our into Data quite a lot so if we were to lower this number to say you know 60 then we would get that to properly print out some other uh int bits I like bit occupying I guess you could use is n16 there's an n32 and an n64. there is no int 128 though so you just have 8 16 32 and 64. awesome and then if you don't want to put any any number after it it'll just default to N64 for for safety purposes uh so next up we have the I'm going to go over actually this this uint next because it's very close to the integer so U ins if I can type you end we'll just go eight for example I don't think you can leave it just like that unknown declaration must require an explicit variable declarations so that just means we have to put a number after it we can go either eight uh 16 32 and 64. so same as int and essentially U and what does the u mean well the u means unsigned so if we have a variable say so we have an integer it could be you know negative one zero one right that would be an integer can be negative numbers or positive and a uint would just be an unsigned so it cannot have a negative or positive sign and when we normally write out an and without a sign say like 60 we assume that this is positive if we go 60 you know plus 30 we're assuming that both of these numbers are positives because they just don't have a sign on them um so that's what unit means it just Only One Direction it can only go positive whereas the int just int without the u could also go negative so so do your range for like an INT 8 for example would be uh 255 to negative 255. uh we can actually type that out here 255 and we could print this out oh it's going to go to negative one if we go 254 Maybe 256 there we go okay so yeah 256 different ones I got a little bit messed up there but if we were to put say negative 256. you would also get a zero as well so that kind of just shows the range there and you go uint and uh I just don't think that would work so if you were to go like maybe negative one I wouldn't like that so I just default to a positive number so that's what antonuent are just signed an unsite enters and then next we have the floating Point number so a float is just a decimal number just imagine like 60 is an integer and then 60.01 would be a floating Point number just a float and to declare these we just go we have to actually write a little number after it how many bits it occupies if we're going to be explicit about it uh if you weren't explicit you would just go let x equal you know 3.14 3.14 and uh if you want it to be explicit about it you would just go colon float and then you would put however however many bits you want so you can't go eight but you can go 16 32 and 64. so if float 16 is just a essentially uh like a half Precision number if you will just lower Precision it's commonly used in machine learning for training models with like less numbers in them so float 16 is quite useful and a lot of Mojo cases but anyways don't worry about that too much that's just what these variables look like or these data types rather and then the last one that I like to show here go ahead and print that go to 3.14 and then some little error there I don't know why that is but that's that's something on the Mojo end that we don't have to worry about um but yeah now we have Bool which is the last one so we just do ol just like that and we assign it to a pool is either a true or false variable so just go true we have to make sure we have a capital first letter so it's case sensitive or we can go false if we were to type like 3.14 it would say oh cannot convert float literal to Bull so it's thinking that this is uh it's thinking that you're trying to put a float here and it's like we don't allow that we only allow for true or false so a pool can either be true or cross if we were to say print that out you get false so awesome that is all of the basic data types let's move on so a lot of people that come from languages like python JavaScript or C plus or just any other language really you might be asking why the heck aren't you covering arrays or lists or dictionaries so the reason is because they simply don't exist yet in Mojo I'll show you kind of a little bit of a cheat way to make an array but it's not quite the same but simply arrays just don't exist yet in Mojo that's something that they're working on right now so I can't really go over that because it doesn't exist but anyways uh what we're going to jump into next is how to get a user input and then just print that out for example because that's what a lot of you learned in Python an introductory python course is how to get a user input and then print it out So currently the simplest way to do that is to go we're going to import the python Library you could say go python from python uh import python just like that make sure the p is capital and then inside of this FN Main or outside of it rather you have to type a raises I'll go into more of why raises is needed later on but you just need that to be there for now don't worry about it and then we're going to go let's we're going to go let's pi equals python dot import module and then we would go builtins just like that so essentially we're just importing the builtins module with which comes default in Python if you were writing a python script you wouldn't actually need to import builtins because it's already done for you it just exists as a part of python so you don't really need that but in Mojo we need to explicitly import this and we're just going to give it a variable name py awesome so now we can go let some say user input equals Pi Dot input just like that so inputs exist as a part of the builtins module inside of python so we could just call input directly on that and then we could say um you know what is your favorite color let me go ahead and print out user input say it your favorite color is go Mojo what is your favorite color let's say I like green your favorite color is green cool so that's how you get user inputs in Mojo use the assistance of python which is a little bit funny but that's currently how you do it right now in Mojo so that's pretty cool so now we're going to jump into if else statements so what the heck is an if out statement well it's simply if a condition is met then you execute some code and if it is not met then you default to some other code and I'll show you exactly what that looks like right now so inside of our FN main I'm just going to set a variable X we're going to make it let's just say an INT we're going to make it an INT 16 and we're going to set that to maybe 100 okay so now we can we can actually do the if statement we could say if X which is what the variable name is and then double equals you might ask why are we doing a double equals well double equals because we're doing a comparison so if we do a single equals up here we are assigning uh the value 100 as an integer 16 2X we're assigning the value 100 to integer 16 data type 2x to the X variable if you will and all we're checking is that if the value of this x is equal to a hundred so this should actually just should go through so any code that you actually put under this you have to make sure that it's indented same thing for like functions I didn't cover that explicitly before but you do need to make sure that you have indents so that Mojo knows what to uh essentially how to interpret your script so we could print out huh true that wait wait get true awesome so if we were to change X to say 101 we just wouldn't get anything it would simply just say oh this condition is not met uh this this little block inside of here is not equal to true so in other words essentially all if looks for is if whatever this little block of code or that whatever this comparison is if it does not evaluate to true then just skip it and and if it does evaluate to true then we just print whatever is indented inside of the if statement so if you were to say to else this would be the defaulting that would occur so you would print uh failed and you would get failed because it says this isn't true so we're just going to default to else if this is true and then else if it's not then just default to whatever is indented inside of this else little block here and the last one which you may or may not use is called alif let's go LF just like this and we could do another comparison if x equals 102. then we would print same X is 102. so it's still a hundred it's not a hundred and one it's not 102 so it's still going to go to failed but if we change it to say 101 then we would get true if we change it to 102 we would get X is 102 and then of course if you wanted to add more of these lfs you would only have an if and then an out at the bottom but if you wanted to have like a bunch of alifs in between you could totally do that so go L if x equals say 103. X is 103 like you could totally do that you can have as many LS as you want in here but it does start to get redundant after a while so that's that's essentially how if L if and out statements work if you're wondering like what the heck does LF mean that's just like a blending of the word if and else so it's like taking the first two letters of L and then you know the word if so LF um awesome so that's your if statements let's go ahead and jump into Loops next so next up we have loops so what the heck are Loops well there's two types of Loops so there's there's a for Loop and a while loop a for Loop will typically execute iteration by iteration until something is met until an end goal is met whereas while would just go on forever until something is met so 4 would typically stop somewhere whereas while would just go on forever until some conditions are met uh so let's actually start off with a for Loop and a lot of you python people have probably seen this exact sort of form before but essentially we go for index or four uh iteration for iteration and in short we could just say 4i because it's less characters to type and we'll just go 4i in and we would go range and you could put any number here I'm just going to put 10. and then you put your colon indent and we're just going to go ahead and print out I so this is what a basic for Loop will look like shouldn't it clear this and we get numbers printed out from 0 through 10 or 0 through 9 sorry because it starts it actually starts at zero and then goes you know one by one until it until it satisfies you know a range of ten so ten different numbers there's a zero all the way through nine so if you were to shift that over one through ten um so anyways that's what for Loops look like and I'm going to go more into how we can like play around with these later I actually might do it after this Loop part but anyways next up you have while loops so what do while Loops look like well it's sort of the same thing as an if statement it looks for a condition being true so we could say you know while or while X is say less than 10 we could go X plus equals one and we would just maybe declare X since it doesn't exist yet let's say Lex or let X and then we would say maybe an integer say being into eight uh and eight equals zero uh must be mutable so we have to change that to VAR good catch uh while X is less than 10 we would do this and then just to you know make sure it's working properly but just print out X if I run that uh it'll print out I just oh it would print out one through ten so it'll start at zero it'll add one two x so plus equals you could also do you know minus equals or multiply equals or divide equals uh we're just going to do plus equals for this instance and that'll essentially just add one to this current value here so it'll add One X will become one then it'll print at X and then we see that's why we see the one first so it looks for until this condition is met until or while X is less than 10 once it becomes equal to 10 then we stop so uh X is therefore equal to 10 then we do this last editor and then it cuts off and then also what you could do is you could just put it true in here and then go uh you put a little if statement inside of it saying you know if x if x is say greater than or equal to 10. we would break so what does break do break is essentially like extremely simple it'll just stop the loop so if you put break inside of any Loop it'll just stop it and we can actually print this out over time so we go print X and we would get the same behavior so Loops are a little bit more complex but that's essentially what you have is you have your for loops and your while loops so I'm actually going to show a little like array I guess thing you could say with loops and all we're going to do is we're going to let X we're going to make it equal a python object so in order to do that we're going to need to actually import python up here so from python import python object and we're going to set this equal to say an array so we go 2 4 6 8 10. an array is just a list of numbers wrapped in square brackets and then each of these numbers here is assigned to an index so 2 would be index 0. everything starts at zero in arrays so to be at index 0 4 would be at the next one six would be at index two eight would be uh three and then ten would be four so if we were to say you know print X at position three uh oh why are we getting this cannot call function that would raise okay so we're gonna have to add braces in here again ignore the raises for now but uh essentially this this is a python array and we're just printing out the third index of it so zero one two three zero one two three and then it a three is equal to eight so we get eight the third index is eight so we get eight sorry um so that's what that's what arrays look like and we can iterate over these using a for Loop because we go four I in range and then we could just say I'm going to say 4i in X for example because X is actually the array itself so we go 4i and x and then just print out I oh I guess we can't do that we can maybe go range and then length go x dot underscore length and then under Splinter score maybe that'll work okay yeah so we could go uh X at position I and then we would be able to print all those out don't worry about this too much this is just me taking some Python and transferring it over to Mojo this little length thing this Len uh is just a short short form for length and then you put these around it because that's the that's the method that it calls but don't worry about this at all this is just porting some python stuff over to Mojo and it it's still being like mostly python so don't worry about this at all this is like not part of the course this is just me playing around with stuff but anyways now we can actually jump into functions so you might be wondering about functions and if you've done Python Programming before you've probably seen this def uh this def function so for example def add numbers you pass in two function arguments uh A and B you let c equal to and that the sum of A and B and then you return whatever C is so if a were to equal 2 and B would equal five you would say uh C is equal to a which is 2 and B which is five so C would be seven and then you would return seven which is C so uh that's what python functions or defs look like and in Mojo they're actually quite close so be an FN short for function and then you would put whatever your function name is you would wrap it in these round brackets you would pass in your function arguments and we'll go over these in a second here and how you can put function arguments into it from like actually calling the function uh and then you would put whatever you're going to return inside of uh like outside of these uh round brackets so you put an arrow and then whatever The Returned data type should be so in this example we go you know let c equal to uh an integer and that's equal to a plus b assuming these are both integers from here and then we would return C which would be again an integer because that's what the specified data type was and then since we know it integer we would return as an integer data type so sort of a that's that's the main difference between Mojo and python is uh FNS or FN functions are more explicit whereas defs are less explicit and they would take a little bit more time because um that computer actually has to like understand what you're doing rather than just having you know the rules just like hard to find and just like full steam ahead so that's kind of the difference there and uh so what we could do is actually go ahead and call this function so I'm going to go FN Main well passion no function arguments in here and I'll just go add numbers same let's X will that be an INT we'll say add numbers and we'll go ahead and pass in say two and five and then if we were to go ahead and print out what x is we should get seven just like that so let's actually walk through step by step what's happening here because to an inch like newer programmers this might be actually quite scary to look at so the reason we put add numbers above here actually if I were to put it below you might see that uh does it still work I should actually double check that okay I guess it does still work so you can have your functions in any order top or bottom and Mojo will be aware of where they are so you won't need to have something above it for Mojo to recognize that it exists um we'll just go ahead and put it back there though because that looks better so you have this you have this function add numbers you have a parameter a which is an integer type it just defaults to N64 because we don't tell it how many bits to occupy and then you have a b as well which is also an INT we say that this this function is going to return an integer type or an N64 type and we say let's see let C be an integer data type meaning this is a constant C is a constant integer 64 and it's going to be equal to whatever the integer A and B are equal to and then we would return C whatever the value is that's what you would return from the function so you call a function it does some operations and then the function returns a value to its caller so the caller in this case would be in our F and it would be on our main function so this add numbers is the caller here we pass in two integers two and five we make sure that this is a constant X integer 64. uh and then we would we would essentially just have the output of that so X would be equal to whatever this function returns which would be seven and then we could just print that out so that's essentially how functions work on the explicit level when you're explicit about what variables you're using then that's how that works so we could actually like replace all these ins with int 8. and then here as well you could go int 8 and everything be the same we're going to jump into a concept called object oriented programming so object oriented programming is concerned with these things called objects or classes or structs whatever they happen to be called in the programming language and anyways I I'm not going to philosophize about it I'm just going to jump right into it so uh the best way to really compare this is to look at what do they look like in Python and what do they look like in Mojo so I'm going to create a new file called main.py and this is what an object would look like in Python so just clear this drag it down so what's happening here we have a class called a banana um actually I'm not going to go through the class first so initially we have if name equals main it'll essentially just run this main function just it's just it's the way that Mojo works when you call this main by default it's the same thing going on here it just calls the main by default so this this main function is going to create a banana instance it's going to pass in a a bunch of arguments here and then we're going to print some attribute about this banana so what does this banana look like well we have an init so in it it you could think of it as a Constructor it makes it actually initializes the banana clasp so what are we actually passing in here well we have self is required we have a ripe attribute which would be Boolean so true or false a length which would be a float in Python and a color so a string and these are these are just things that I picked out sweet ripe could be like you know a floating Point number if you want to put on a scale for example but these are this is just what I'm working with um so in the in your init or in your Constructor you would say uh self you would say self Dot and then all the attributes for example self.ripe would be equal to this this ripe argument self.length these are just the variables of the actual class itself that's what the self dot whatever it looks like and then you have length and color so these are all the variables that we're initializing for our Banana class and then if we were to say call The Ripe attribute on on banana like we do here it would essentially just return whatever ripe is so we have a def ripe um we pass in self as a function as a function argument because it's a def it's a def function and then we're returning the Bool value so we return self.ripe which happens to be a Bool so we return Bool here uh and then we also have say a length as well I'm actually going to add the color in because I didn't add that in yet so we go uh def go color self and then we would return color which is a string so go Str and then we go return self dot color awesome if I were to print you know banana which is our we've created an instance of this object so you can have as many objects as you want and they have a bunch of different attributes and you can just call those attributes um so we go banana dot open out dot save like color for example and we would just go python3 main.py it's going to print out banana.ripe which is false as we passed in and then yellow because the typically the color of bananas are yellow I don't know what type bananas you eat maybe you eat red bananas but uh anyways that's that all works out nice and smoothly so uh if you want like feel free to pause the video and just try to like conceptually make sense of what this class looks like because these are very important classes and objects and structs are essentially the basis of all languages except for languages like C which don't have them but uh so in in Python this is what your object would look like and this is just a banana object for example so now we're going to jump over to what does this look like in Mojo So let's compare this side by side here so in Python we have a class banana in Mojo we have a struck banana in Python we initialize our variables with an init method uh self and a bunch of arguments in here with their corresponding data types and then here we initialize our variables with self Dot and then whatever the variable is equals whatever the parameter goes passed in there you could also do like lowercase that's fine too but I just find uppercase to be more consistent and it's like easier to read especially for classes I I don't know some people like to do it differently but that's just what I'm doing in this case so in Mojo you would actually Define your variables here you would say you know what the variable name is and you would say what data type it is you don't have to declare uh really what it's equal to but just that it exists it has a name and what data type it has and then you would have your init method here as well I'll go into this in out little piece here in a little bit but this is not in the basics of the chords this is a little bit after so uh you you get the idea it's sort of the same arguments in here uh you have yourself ripe length color uh selfripe length color uh awesome and then they're declared literally the same way as python in this like this block of code is equal to the same as this block of code um and then for our little methods here so you have or rather functions inside of the class you have a you have your FNS instead of defs ripe and then you would pass itself because that's self is essentially the object itself so self is needed in objects and then we say rhs because rhs is equal to right hand side and this is on the right hand side just it's just kind of a common practice you could say like value or or something else but it's commonly just seen as like rhs that's that's typically what it ends up being someone in in our death ripe we pass in a self and we return a pool uh and then we actually return the bull here so this is like what type we're going to be returning and then we return the actual ripe um variable if you will here we'd we also have this right hand side so we we pass in uh the banana itself and then we say we're gonna return a bull type and then we return this this ripe which is up we'll type hence returning pool here uh and then it's just kind of the same same thing it's a pattern for the rest of it so as long as this one makes sense as long as this init method makes sense and these variables make sense everything else below here should as well and in order to actually create an instance of this banana yes you can create multiple instances you would essentially just give it a variable you say VAR or let a banana equals and you would call this struct and you would pass in what variables or what arguments are required so you have a ripe which is a bull so we'll just say false let's say the banana isn't ripe um and we give it a length maybe it's 4.7 centimeters long the float 32. and then yellow which is a string so we have a banana that isn't ripe 4.7 centimeters long and is yellow so cool that's how you create an instance so you can actually go like you know for our I can't type banana two and then you would just you would you would essentially call this banana struct and you would pass in whatever arguments are required so hopefully that all makes sense and if we want it to say return the ripeness of this particular banana instance then you would just go called banana dot ripe so this particular banana then you would call The Ripe function on it the right method and you would pass in banana to it so this would ultimately return uh oh let me try this up banana was declared as a VAR but was never mutated consider switching to a lead so it's just giving us a warning and saying oh you're never really changing this instance so you may as well just set it to a constant because variable is is a mutable or not constant so we could save let and that would resolve that warning so awesome we return banana.ripe and we get false so cool that's what objects look like in Mojo versus python so hopefully that hopefully that is super clear now if something didn't make sense totally feel free to uh pause the video look back play it on half speed even chat gbt your way through it because that's honestly how a lot of people learn nowadays and it is a pretty good way to learn as to at least with these basic concepts is to just plug it into gpd4 and say hey I don't understand this or if you you have a particular question about maybe the init method like why is it called why does it have two of these underscores around it right you could pass that into chat CPT and say hey why why is this why is this a thing and then I would hopefully be able to help you but as for Mojo specifically uh chat gbt isn't really trained on it because its cut off was 2021 so your best bet would just be to go to the Kappa AI in the modular Discord and just ask it that way so that's what I would recommend if you don't understand something is to just ask the Kappa AI um anyways let's move on so before we actually jump into importing libraries modules just other people's code in general uh I should let you guys know that inheritance uh inheritance exists in Python uh essentially if you don't know what inheritance is essentially it's imagine you have a a class and it's an animal you have an animal class and you have like a dog cat or a dog class and maybe a cat class maybe a giraffe class okay you have a bunch of animals and then you have this one main animal class so typically what you would do is instead of writing all of the dog cat and maybe giraffe classes from scratch you would inherit some of the attributes from the animal class so you'd have some like General variables and some general things to find in the animal class and then you would inherit those uh in the uh in those other animal classes so like the dog cat and giraffe so that way you wouldn't have to write a bunch of code that way so you would just inherit and it would be less work for you and essentially this is actually how a lot of games work so if you have like you know different enemies uh typically you would have like an enemy class and the enemy would have some attributes like when you touch it or when you get hit by it then you take damage or you can do damage to it or they you know they they only spawn in uh danger zones or whatever it is and you would have you know a bunch of subclasses that inherit from that initial enemy class that would say oh these are some things that are describing uh each different unique enemy but it also has these General attributes that all enemies have so that's just what inheritance is and a general overview but it does not exist in Mojo yet unfortunately so we are able to create classes like these and pass in attributes to them but we cannot actually use inheritance we cannot inherit from other classes yet in Mojo that does not exist so anyways let me get rid of this here and we can actually begin to import some libraries we're just going to import one so we're going to import from python a lot of the libraries here we're going to just import them from python so we could go from python uh oh not capital I import python just like that and then we record an uh F and Main and we would need raises here and I figure this is a good time to tell you exactly what raises does so raises essentially you need to include it in functions that could potentially raise errors so if you were importing a library from python say like numpy for example uh some of you might be familiar with numpy and sometimes you might get errors importing that or at least you might get little underlined saying oh what if this messes up what if the library doesn't exist but we're still trying to import it well then you would just say you know the function raises what raises means because it can raise an error the function is capable of raising its own error aside of Just The Interpreter and compiler so uh this is just super useful I'm going to go more into depth into raises and all of these errors and exception handling a little bit later on but essentially it's just to say we might get errored out but don't worry about it too much because we're sort of expecting it in a way um so we can go ahead and uh you could just create we could just import numpy here so we go let's numpy and then oh not that python import module and instead of builtins like we did before we can go uh numpy just like that and then we can essentially create arrays with numpy so we go let's array ARR for short for array numpy Dot array and then we would put our array in it so maybe you know one four nine 16. a bunch of squared numbers uh and then we could just say print square roots uh now we don't have to do that we could just say print array times two and then we're just going to Mojo Main dot Mojo and 1 times 2 2 4 times 2 is 8. 9 times 2 is 18. 16 times 2 is 32. so we actually get that returned in the numpy array form so that's essentially just how you import modules in libraries as you would you would do from whatever and then import a certain you know sub object or whatever and it's it's very similar to python as a matter of fact it's like the syntax is the exact same except your the libraries just look different when you're importing them uh and then to actually import it from python you would do this python.import module and then whatever it's called so if you're going to import tensorflow you would put you would put tensorflow here if you were to put numpy you would do just as we did before and Etc so uh later on in the course I'm actually going to show you how to create your own packages so uh so instead of just importing them from somewhere else on the Internet or somewhere else that's like downloaded a part of your mojo but you didn't create it I'm going to show you how to create once and then use them so that's a cool little feature that modular has been uh super you know easy going about I guess it's it's just really easy to make your own packages in this language and in this whole modular framework thing so I'm going to show you how to do that a little bit later but for now let's just jump a little bit more into what exactly does raises do so in Mojo we use four error four words for error handling so as you've seen before we use raises and raises is uh essentially in any function that may raise an error needs to be explicitly marked with this as we went over before it's part of Mojo's error handling semantics uh so oftentimes you're going to use this when you're importing other libraries because it may or may not work right you may have an error there um but most of your errors will be raised automatically by the compiler and interpreter so don't go like out of your way to just include raises in every single function if if you are getting little underlines like red underlines like errors uh just try to include raises and then see if that changes anything but you shouldn't need to explicitly include raises in every single function um so that that's what raises does you put that after the round brackets of a function to essentially say this might raise an error um and then this try try accept and finally all go together so I'm actually going to paste in some code here that I've gotten from before so we have a function main raises so it might may or may not raise an error and we just explicitly declare that and then we have this try so what does try do try will attempt to run some code for example open a file so let's say we have some input.txt file over here and we're trying to open it and maybe like read the contents inside what try will do is it'll maybe we'll try to open that open that file we'll try to open it we'll create like a new resource for example and then open that file with the resource and then accept will look for an error say a file encoding issue say our file is like has some corrupt data in it the encoding is messy for example uh and accept will essentially just catch that error and say hey uh we found something and then here's a little error reporting on what it was about if this code fails so it'll attempt to run it if it's successful it'll just go all the way through in this except block will not be triggered but if there is an error then this will still finish and we'll get a we'll get an A little uh what we can essentially raise an error so we can do raise instead of raises we just do raise and then error because we're raising an error right it kind of converts to English easily that way uh and then you would just in round brackets put whatever your error reporting is so you have an error number you would go like error number one zero three nine or or whatever you do um awesome and then this finally is very important in some cases not as important in other cases but I'm just going to use an analogy for this so imagine you're trying to say uh open you're you're trying to open a microphone resource here so this microphone that I have right here let's say I want to just use it with like Mojo or something even though it's not supported yet um imagine we're trying to open this microphone and we're trying to record something so we attempt we attempt to open the microphone resource and then say we get an error with like maybe there's something wrong with the microphone who knows um so we get an error it says something's wrong with your microphone fix it but what this finally does is instead of just stopping at this error and then terminating the code finally we'll instead uh still follow through whatever is inside of it whatever this indented code is inside of the finally block so if we were opening a microphone we probably don't just want to leave it hanging we probably don't just want to have it you know go on forever and just essentially leak the microphone right we don't want to be leaking that resource at least to other errors that you don't want to deal with and essentially finally just says I got you covered man we're gonna we're gonna take care of that so typically and finally you would just essentially close that resource so we oh we attempt to open a resource we say it fails instead of stopping there we stead we instead guarantee finally guarantees that we actually follow through with whatever this code is and there we could close the file instead of having memory leaks or resource leaks so finally is really useful there if you're taking advantage of resources but if you're just trying to you know attempt some block of code and then you see if you get an error see if it faults then you wouldn't really need to finally block for that finally it would just be you know when you need to run something even though there's an error that happens so that's kind of how that works that's that's pretty cool uh very good for debugging of course if you're trying to if you if you think your error is in you know some piece of code then you would put try around it and then if it errors out be like oh so that there's some like specific thing wrong with my code it's in that section and then you can debug further um but yeah if we were to Instead try to close the file after it errors out if we were to Instead try to close it down here uh that wouldn't work because this code isn't guaranteed to run once you uh once you post it once you raise this error uh essentially nothing else other than finally is allowed to execute code so you raise this error and then immediately it says we have an error we cannot execute whatever this is but finally says we're guaranteed to execute this no matter what so hopefully that clarifies the whole uh error handling exception thing uh what we're going to do now is we're going to go ahead and move on to some of these function arguments like in outs and some other ones that you may or may not have seen before so what the heck are these function arguments you speak of well function arguments could be one of many there's like quite a few I'm meaning like three or four in this language and the first one I'm going to cover is called in out so what this means we we already went over function so I'm not going to go over that again but essentially when you mark a function argument within out it means that that argument is mutable or changeable and changes made inside of the function so meaning changes made to for example a we pass it in as a equals 4 and then we mark it with n Out um and we change it to three then that change would also be visible to everything outside the function so I highlight the words inside and outside because that's what in out comes from in and out changes made inside the function are visible outside and out and then the next one is called borrowed so let me go ahead and copy I've borrowed code in here not really borrowed I created it but we use this label or called borrowed and this essentially just labels these explicitly immutable meaning you cannot change them so if we were to say to Mojo Main dot Mojo um we initialize a a and b so we have a four and a five we call add nums on those uh and let's say we were to try to change it to uh let's see if we're to change you know a equals three and then b equals two well why are we getting underlines expression must be mutable in assignment okay so what if we change it to in out for example and out because argument zero must be mutable in order so argument zero is essentially the first one it's catching the error on the first little function argument here uh in order to essentially run our code so uh notice that we've declared with let so if we change this to VAR then everything works so we set a to 3 and b to 2 we get five um but if we were to say set these two borrowed then this wouldn't work because these these initially are variable meaning they can change they are mutable and then we explicitly label them as immutable meaning you cannot change them and inside of the function so Express expression must be mutable in assignment so essentially that's what borrow does it says this belongs to the other function and we're not allowed to change it even if in the other function you say that it's a VAR or variable um so yeah that's that's uh in out and borrowed for you and the next one I'd like to cover is uh owned owned is an interesting one Owen will essentially say with with whatever variables we've labeled here that those variables now belong to this current function so for example even though we uh initialized uh these variables as immutable using the let declaration uh when we pass them into here using owned it says okay now this function owns them so we can do whatever we want so this essentially takes off that little immutability feature and says we can do whatever we want to them and if I go ahead and run this code uh you'll see that so now these actually belong to this function and they are now mutable so uh if I were to say you know something else like if borrowed then that wouldn't work because we're taking it we're taking it from this function here if I were to even go like that it would say expression must be mutable because we're initializing it as let over here which is immutable we're trying to change it even though it cannot be changed so essentially own says um it's just explicitly saying that this this current function which owned is in uh we can do whatever we want with that variable this function now owns it so the next statement that I want to cover is called with so the with statement you may have seen this in Python before but like especially in Python width is typically used to open a file so in Python you would go um so with open here we go input.txt and you would go right or read sorry and then as F you would go say text equals F dot read and then we would print out some text if I were to create an input.txt say you know peekaboo maybe we go in run this main file and it would open this in read mode as F or file and we would read the file put that in a variable and then print that variable out so essentially What's Happening Here is with is acquiring a resource meaning files right we're acquiring a file read maybe a write resource and we want to make sure that after we're done with the resource that we dump it so we're going to open it we're going to use we're going to use some file reading and writing resource we're going to do some code we're going to do something with it and then we're going to close the resource afterwards um this isn't this isn't too common with Mojo yet it doesn't really doesn't really exist doesn't there's essentially nothing you can really do with it right now um so I'm not going to worry about that at all you might be asking what is the difference between with and like a try except finally block well the thing is is that with uh by default isn't really going to uh run some code no matter what so typically in the try except finally you would attempt some code you would potentially throw an error and then you wouldn't do some stuff after so um I'm not my awareness of the whole with statement isn't like too indepth but uh I know there's there's definitely some differences there in terms of how it compares to try except finally versus just with so you could actually look into that on your free time but we're not really going to be using with in this course at all so don't worry about it so next up I want to cover something called variable scope so in Mojo you would typically see like you know let's say x equals three and then you have a FN Main and you would say maybe y equals say let y equals four so this is a concern with something called variable scope so variable scope is like you just have a variable and then what is the scope of it so this one would be file scope since it's in the file everything else in the file can access it if we were to go ahead and print X we would get uh we will get an output there so we this uh this is included in all the functions so all the functions can access like file scope or interchangeably Global variables file scope and Global scope variables are pretty much the same thing and whereas this let y would be specifically in the function so if I tried to uh you know if I had a different function to I don't know who I would show this but essentially this is specifically only accessible to this function only so there can't be any other functions that can access y so if I if I said um if we had another function say FN print y uh and then I work to you know say print y we return that uh come on let me just keep that all right move this up and then we were to say Maybe print y will return whatever Y is whatever Y is equal to so it'll say unknown Declaration of Y uh require explicit variable so essentially saying that y cannot access this y because this Y is specifically in the main function so therefore other functions cannot access it so this is what we call local scope so local scope just means it's like defined to a specific function or a specific struct or something um and that's essentially what variable variable scope is so if you've worked with python before you've probably experienced some errors with variable scope um but anyways that's just essentially saying you can't make a variable in a function and then call it in another function without like passing in the argument of it so that's what that is now let's move on to some of the tools with the Mojo Mojo command line interface or the Mojo CLI so if you pop over to the Mojo modular documentation here and just scroll down to the Mojo CLI and go to yep you could just essentially click on maybe just click on Mojo and you'll see that essentially this Mojo thing is actually a command line interface in and of itself so we've seen that we can call Mojo files or we can run Mojo files with just the Mojo keyword and then pass in whatever file you're running very similar to python you can use modular to of course update Mojo but modular is not really the focus of this it's more like Mojo command uh commands so Mojo run built and executes a Mojo file I won't be really using this much because it's not as important but what is important is this little build command here and this will actually accelerate your speed by quite a bit not by like 5 10x I mean it might but it honestly depends on what you're doing anyways let's just cut to the Chase and I'm going to show you what build does let's actually use this Mojo build command so I've I've just ported some code that I've written to essentially test uh Pi torch on both CPU and GPU so we went over sequential processing and parallel processing uh this is essentially just doing that and we're just comparing speeds so uh you don't this this is probably scary to look at at first but essentially if I do uh Mojo Main dot Mojo give it a second Cuda okay and we get a CPU time a lot of this time is spent actually importing the packages itself so now some of this is going to be spent you know so some of it is going to be spent on Cuda time as well so CPU actually performed almost 5x better than the Cuda time which is insane and if I wanted instead build if I want to instead build this into a binary form and then run it which should be faster I would just go Mojo build and then main dot Mojo just like that and we should see main binary file popup in order to run this we would just go uh dot slash dot slash main we can say we get a Cuda 1.2 seconds or sorry CPU 1.2 seconds and Cuda is sped up by quite a bit so this sort of just proves that normally running Mojo in this way is less efficient or less less quick rather than making a bill uh making a binary file using the build command so if you're just testing around and playing with things in Mojo you shouldn't really need to build it but once you're ready to push it and like really like see what the limits are of of that file and just see like how fast can this possibly go then you would want to use the build so if you're pushing something to production or you just want to you know say in the future you're able to train some neural network and you want it to go as fast as possible you might want to use the build command rather than just running it normally so anyways that's how that works it's fairly simple you just build this and then you do dot slash and then whenever the name is in this case it's main so uh awesome that's how that works now we're actually going to go into how you can build your own package so for example python is we're able to import it it counts as its own module or library or package whatever you want to call it and we're just going to create our own we're going to create some object or class or struct and we're going to import it into a different script even though it exists on a completely different place on the computer so I want to build a package just to use to maybe use later and so first of all we're gonna have to go to the docs I skipped ahead a little bit there but essentially you go to Mojo uh and then I might full screen this for a second or just CLI and we go to Mojo package and then uh so there's a whole description here about just like some extra options you can pass into it but what we really care about is this see more about modules and packages so let's go ahead and click on this I'm going to drag this over to uh like a split screen and we're just going to follow the instructions so provide the packaging system that allows you to organize and compile code libraries into importable files so when you like import python for instance you go from python import Python and then you can use some of the builtin libraries it's essentially like that except we're big we're making our own libraries uh introduces necessary Concepts blah blah blah and to understand you don't understand motion modules so single source file that includes code suitable for use by other files that import it so you can create a module to define a struct such as this one so let's go ahead and follow along I'm going to go ahead and uh actually we're going to scroll down just to make sure we have this structure correct because there's a structure down here that we're supposed to follow uh so we go make a new directory we call it maybe uh my package and then we make a new file inside of it we go init .mojo and then we make a my module dot Mojo awesome and then we have our main here it's awesome these are all empty what do we put in them next so we have this my module.mojo here so we'll just pop this in and let's let's first look at what this does this is a struct uh we have some we have some variables uh two integers essentially we're just making a pair hence it being called my pair uh you those those are essentially just the the instance arguments that we're going to pass in when we call this with our package so awesome now what now we have a main dot Mojo so we're going to have to actually import from this we're gonna have to go my package you're going to see this a crash happen in the Mojo parser so I can actually go ahead and run this main dot Mojo and it we're getting aborted this is currently still something that Mojo was figuring out right now I was running into this error quite a little bit and we're just gonna sort of Go full steam ahead and we're gonna go to the end result that we actually want we're not going to be concerned about this for too long so for example import something that's in the same directory so so essentially what's happening when we import this we have from so it's going to come from somewhere else so it's going to come from the my package directory dot my module so it's going to come from my package dot my module and we're going to import my pair so that's exactly what this like quite literally what this says from my Mac from my my package.my module import my pair and so this should work fine and really all we have to do to fill in the blanks here is essentially just create we're going to create a package out of this and you can leave the init.mojo you don't have to edit this at all so essentially uh how this goes is we just go Mojo package and then we look at whatever the name of this package is called save my package we're going to do Dash o and then whatever name we want it to be just be like maybe test pack oh testpack dot Mojo package and you have a nice little Unicode character here as well which is really cute so just a DOT Mojo package file extension and we can go ahead and create that and we see that it shows up here so in order to actually import this into our main dot Mojo now we see that it's in the same directory it's in the same local directory as main dot Mojo So these are together so we don't need to like import from something you know far out all we can do is essentially just go from testpack.my module because keep in mind it's still going into this my module instead of my pack but this is just compressed into like a shorter form so if we go ahead and run main dot Mojo now we should see uh main dot Mojo we get two and four we passed in the pair two and four and we get that output so that's that's really it that's that's honestly how you make packages just uh you make sure that you create a directory in the local folder and then you put an init Mojo it has to have two underscores on both sides and then whatever your module name is called and then you do whatever you need to in here maybe a struct maybe a few of maybe a few structs if you want and uh that's that's pretty much it so that's how you create packages so we just covered two of the command line tools that Mojo uses so Mojo build and Mojo package so uh if we want to actually look at some others you could just go down to Mojo here and we we can see that we have we have run build which we already did uh repl that's not something I'm going to cover in this video we just did package formats I don't think this is as important uh docs I haven't seen a lot of usage with like deem angle dot format a little bit of Rebel but uh just just for like the basics and creating your own packages and building a binary executable files build and package are going to be your Best Bets if you want to you could totally dive into other commands but those are the only that I feel like are very necessary for the basics uh anyways you should give yourself a pat on the back you made it really far and there's actually only a few more Concepts we have to cover there's there's not that much you're like almost done so give yourself a pat on the back grab some coffee or whatever you do and let's jump right back into it so I want to introduce the coolest data type ever it's called a simdi so what does simd stand for what is this Cindy what does it mean well simdi is short for single instruction multiple data so that means you can have say an array and instead of doing an operation on each element in the array you just do one on everything so it's only one operation so what does this actually look like if we were to say use python so in Python you'd have like an array say maybe you know two four six eight or two four and essentially you would have to Loop through this entire array and do an operation date element let's just say we're multiplying by two so you have to go through each element you'd go to the first index you would you would set the new you set a new array to equal uh what is this times two and then what does this times 2 and then what is 6 times 2 and then what is 8 times 2 you would do all of this sequentially but Sim d is different so you can just do times two one time you multiply the entire thing by two and it's done just like that in one operation it's essentially a CPU instruction so it's it's a it's an easy way to write it but essentially CPUs accept a certain type of instruction or the CPUs will accept some instructions that will allow them to take like shortcuts and loopholes around things so 70 is an example of that where you don't have to iteratively multiply or add things together you could just do it all at once in one operation so for example if I were to print say x which is the 70 and then I multiply by 2. I could run this and we would get essentially everything multiplied by two and this all happened in a singular operation so next up there's a there's an interesting uh I guess method you could say we could call on the 70 type which is len so Len is equivalent to essentially length of x in Python that's what it would look like but in Mojo we would do x dot when and then so just some round brackets so this will print out four because we made the length of it four and this is a good time to actually delve into what each of these parameters are so first of all you initialize a variable say let x equals and then we could just say it's equal to a single instruction multiple data data type and then we have some square brackets here and inside of these square brackets you're going to pass in the data type that you desire it to be and the length of this multiple data if you will and so to do that we use D type and then dot whatever you want it has a this this data this data type needs to have a lowercase letter so you can't just do like float 16 it has to be a lowercase letter um and then this uh this four is essentially just how long it's going to be because it's one dimensional it's just like one dimension so after these square brackets you just have these round brackets here and this is the contents of what you want and there's an interesting thing we can do with these because consider these this is four elements here and we explicitly declare that this is going to be four elements long so what happens if we add a fifth in say 25. and then we print out what is X multiplied by two we get uh this number we get this Sim d uh returned back so this essentially means that we're going to take the first four numbers of whatever you put in here and then everything else we're just going to splice It Off so that's a cool little feature I don't know if that's a feature or a bug but I think that's pretty cool how you don't get errors for doing that so anyways there's a lot of operations you can do with these uh you can there's certain ways to make like a really long uh what we call Vector that's just the same exact number all the way through um and this actually leads me into a little bit more Deep dive of what this Sim D type is so let me go ahead and just uh get rid of this and I'm going to copy some code in oh so we have a function add and we have a function main no no don't get scared by this too early so what does this function main going to call well we're going to let x equal the same D type float float 16. it's literally the same one we just used and we're gonna we're gonna pass it into a function called add so x and x so what's actually happening in this add function well first of all we have some uh we have some square brackets here this is going to determine uh what the data type is and what the length is so these are the two uh essentially needed function Arguments for operating with simd types so you would essentially give a name for what the data type is so D type we would give that data type and then the lengths we would just set that to the data type int we could it could be like an in 32 and 64. it doesn't really matter we're just saying that's going to be an end here so this is like converting your data types to names that we can use later now we have these round brackets and notice how oh notice how these actually stretch out quite far so in here we specify the actual function arguments themselves what is this first X going to be that's going to be a that's going to be this piece right here so a is going to be a Sim D type with data type D type and length of type integer and then same thing for B here except we can't just we simply can't have a twice because that would that would give us errors so we're just going to do a and b so next up we have uh we're essentially just returning what this is what this entire function is going to return which of course has to be a simdi type with a data type D type and integer so that's that that's a lot of content but essentially all that really happens is we just add them together it's a single single operation that we do and if I go ahead and run this here we will get uh this we could even we could even multiply them together can even multiply them one times one four times four nine times nine and sixteen times sixteen we could even divide them if you want since they're a float float 16. so everything divides by itself or if something divides by itself it's equal to one so that's why we have ones there but anyways these instructions are super cool I'm not going to dive like an insanely amount I'm more into them but we're going to use sim D types A little bit later on to do some speed tests but before we jump into that I want to cover some other uh Concepts and topics the next one being decorators and meta programming so I've just kind of implemented it it doesn't really do anything but this is what it looks like this is called a decorator and decorators come from a practice called meta programming where meta programming implementations look at the code architecture you've attached the implementations to and have the code optimize itself based on the specific meta programming feature you're using so uh in the context of unroll essentially what this does is it unrolls the loop you have some Loop and it unrolls it into a bunch of individual uh iterations if you will so if we have if We're looping over this 10 times if we're doing I 10 times instead of going sequentially it'll split it out into 10 different uh individual Loops that it'll uh individual iterations that it'll do um and so we can even pass parameters into unroll we could go for example uh two and what two would do is it would split it into iterations of two and loop over five times so there's a bunch of ways that you can mess around with these meta programming features they make everything super hackable hence the word meta programming it's it's a beautiful word and this essentially allows you to take advantage of maybe parallelizing some operations maybe you have a loop where instead of sequentially running it you want to split it into a bunch of individual iterations and then plug you know say a fraction of them into each processor that you have and have it done in a fraction of the time so little optimizations like optimizations like this will greatly help performance but meta programming has always been sort of an advanced feature so I thought I'd share with you uh what exactly they look like and an example of what one of them does meaning unroll but they are an advanced feature so I'm not going to go super into it this video however if you are interested and wanted to dive deeper into decorators and meta programming I would highly recommend that you refer to the documentation so let me now show you the case for an up to 77 000 X beat up over python it's blown a lot of people's minds in the past little bit but so if we just go to the modular documentation here uh just docs and then Mojo notebooks matrix multiplication and Mojo just scroll to the top I'm not going to walk through like the actual Matrix multiplications going on the algorithm here isn't important a fact of the matter is is that we just need to plug these code blocks in and see how it progresses based on what features we add to it and what optimizations we add so what I've done is I've ported all of this code block by block all N2 and you can see they have a 77 000x speed up and I've ported all of this into my own notebook here so I've already run everything and as you can see uh initially we get you know 0.001 gigaflops and then after an optimization we get a 0.01 gigaflops which is an 8X speed up and then like everything here is uh compared to the original by the way so everything is compared to the first three code blocks so we get an 8X beat up and a 3000x speed up and I'll go into what exactly well what exactly is making it go up to 3000x and then a 13 000 X a little bit more and then at 22 000x and then 19 000 just due to some Hardware stuff it could go up or down depending on your Hardware um and then it just kind of settles around a 20 000 X beat up and this is just for my machine again mode uh the modular team probably tested it on a machine that was favoring this code that they used so there might be other ways to optimize around your own Machinery but that's not something you should worry about as a beginner all you should worry about is what are the fundamental uh what are the fundamental concepts and practices you can use to get the most significant speed up without over complicating your entire thing so if you can get like a 5000x speed up and it takes you five minutes to implement it maybe just stick with that maybe you don't even have to go to you know a 10 000 X beat up because that's just that's just making it twice as efficient it's not as big as a uh a 5000 x jump so anyways I'm gonna walk through this uh sort of what's Happening Here so initially uh we're using python to do a matrix multiplication and the thing with python is that it's not very good at running code on multiple CPU processors so if we actually look I can check my current CPU processors if I go to uh performance we go to CPU and it'll just say logical processors here or your threads logical processors and threads are used interchangeably so you can see what your number is there and that's essentially how many processors can do computations in parallel so initially python is only using one of those 12 threads and then what we do afterwards through uh through this next jump let's take a look and see what it's doing so what this appears to be is instead of using all python we're actually jumping over to some Mojo syntax so we're using FNS and we're being uh more explicit about what types we're giving things we're being more explicit we're getting more to the point about what exactly the code is time to accomplish and then I'll just navigate back here because it's hard to follow along when everything is black and white so initially we use One processor and then we use some modules from Mojo and we use some Mojo based kind of syntax we do some importations here uh then what then we add types okay so yeah just just adding types in is going to give us significant speed up and then and then we have a benchmark function which is built into Mojo and it's used to just sort of do speed tests like these do benchmarks so now we get into the the cooler stuff that I actually enjoy talking about so one is vectorizing what the heck is vectorizing so imagine you have uh you're you're in a I mean some of you have probably taken introductory physics before or something close maybe a science class and so when you think of a vector you think of a direction and a magnitude a scalar is just a magnitude but Vector has a Direction with it as well so for example um if you were if you were say had a velocity maybe you'd be going you know 10 meters per second at this you know amount of this this amount of degrees right so you'd have some direction and a speed at which you're going in that direction so that'd be a vector so some ways to actually store that would be maybe an X attribute so if you have a you have your little hypotenuse here you have an X attribute and a y attribute so you have your X as one in your in your zero with index and then you have your y attribute in the first index and then you have maybe your um maybe your direction in the uh in the second index and if you wanted to increase the dimensionality of this meaning if you wanted to instead of just have two Dimensions you would go to three so you're having vectors in 3D space or you could just increase it up to like 10d or 100d whatever you wanted to and essentially vectors are ways to describe uh essentially Direction and magnitudes in it any dimensional space so with vectorizing we essentially convert things to the Sim D type and this allows us to do these Matrix multiplications with far less operations so I was talking about the simdi types before and we're essentially just treating our vectors as some D types and then working with those so that's what vectorizing is converting to something that you can do one operation on that's going to scale up computationally wise and we can see that we get an insane speed up there so 1600 all the way to 7000 so we've just sped up this a ton just by using vectors then what's next so parallelizing so you might think parallelizing has to do with the GPU but in this case it doesn't actually what parallelizing does is instead of just using one thread we're going to be using maybe not all 12 but pretty close like maybe 10 or maybe eight of them or maybe 11 who knows we'll be using a lot more of these threads or logical processors essentially in parallel so imagine you have a giant piece of data and you have you know four processors that can go through it so instead of having one processor or each of them go through the same amount of data just from from the start all the way to the end what you do instead is you give them each little jobs so the first processor can do the first quarter second processor second quarter third processor third quarter and Etc you split it into jobs and what ends up happening is everything is run at the same time all the processors are run at the same time and each of them complete uh their jobs at the same time because these lists are or these pieces of data you have to sort through are now a quarter in size in comparison to the entire length so now you've just essentially decreased your total run time by a quarter just by having four processors that you're running things on So based on the number of processors that Mojo is allowed to access this is governed by the operating system and some other features I'm not going to get into but essentially that's what parallelizing is is splitting a task among a bunch of processors instead of doing the entire thing on one so with parallelizing we go from 6800 all the way up to 62 000. so in this case they probably had a lot of processors that were being utilized to get this 10x speed up compared to uh about 6000 x beat up uh and then the last and then the last one that's quite interesting is called tiling so tiling and tiling is an interesting one uh the best way to sort of conceptualize this is to think of a giant grid of numbers like a giant two by two like a times table if you will a giant two by two times table and instead of calculating everything all at once and this this might not be like a 10 by 10 times table this might be like a a 500 by 500 times table or even way way uh larger than that so what piling allows you to do is instead of uh doing everything at once and drawing it from your RAM your slow memory it will cache it in your CPU your CPU has little RAM chips that are way higher bandwidth and they allow uh information to be transferred almost instantaneously so what this allows you to do is essentially load in little bits of this times table at a time so you can do computations on them so say you want the first you know five numbers one two three four five one two three four five so you've got a you've got five times five there you've got essentially 25 boxes that you're gonna do instead of say 2 million or 2.5 million or there's some crazy number and you can load these into your caches your CPU caches preemptively so you don't have to do this right away or else that would that would essentially degrade away at your runtime constantly having to move things into your cache and then use them that just adds on to extra time so the compiler could be smart and instead of move over what it knows it's going to need before it has to use it and then once it's actually asked to do those computations it can like very quickly draw from that little cache uh and then get the next one in so that's it's ready to do the next computation so this way you're saving time uh from avoiding that giant delay and drawing all of that information from your RAM and rather just having it ready in your CPU caches and to look at those we can see our CPU caches we have an L1 L2 L3 so your L3 would be the slowest L3 would be or sorry L2 would be a little bit faster than L3 and then your L1 is like extreme speed like this is almost incomprehensibly fast and so probably a lot of these uh this tiling operations are going to be stored on your L1 L2 maybe L3 cache so that's kind of just what what what's happening with uh tiling when we do matrix multiplication it's like storing times tables in little uh tiles essentially hence it being called tiling and that way you're saving the memory uh draw time the transfer time so that's vectorizing parallelizing and tiling for you so hopefully that all made sense if it didn't totally chat GPT your way through it man I totally encourage you guys to use generative AI to help understand the stuff better it's such an amazing tool but anyways that pretty much sums up uh everything that's this course covers so bear with me I'm going to do a little uh outro here with some more little facts and stuff that you may want to know about the language and so next up I'm going to walk through how to report errors and actually before you actually report any errors there's a lot of things you have to check over first so one uh actually just go to the Mojo bot help and then type you know Kappa AI I have a problem and then it'll open up a new thread and you can ask it questions just by tagging it through the at symbol so Kappa AI is essentially memorized all of the Mojo docs and knows everything about modular so you can just bombard your questions with it it's not a human so there's that and then also being able to search through errors through this search bar this is a huge help so what if I uh say like environment variable and then I get a bunch of uh I can go new old or relevant and get a bunch of data about how do I read environment variables in Mojo right like there's a bunch of comments here so you might be able to find your error maybe someone else has already ran into it and they've gotten an answer or you can collaborate with somebody else in this Discord server so this will be in the GitHub repository and also you want to make sure I'm going to go to github.com go to Mojo and if you're actually looking at an error what you want to make sure is that you check issues because there's a lot of errors that have been asked here there's actually like a lot of pages of errors so what you might want to do is just take a quick scroll through these and just look for any keywords say you know maybe I can't access environment variables and you go to the next page and then nothing is found here right and you keep going through your pages and just look for your keyword essentially to see if that and if anybody has ran into this problem before and to see if it has been answered so that way you're not just bombarding this whole issues issues page with the same error twice because if you have the same error twice then that means they have to you know it's that's a little bit of a hassle for the modular team and you don't want that because you want a good programming language faster so just be cautious about that it shouldn't be too hard to look through and just see if errors have existed yet just look through the GitHub look through stack Overflow look to the Discord server ask the Kappa AI and then your last resort is probably going to be if it's at fault of Mojo So if it's not your fault it might be Mojo's fault and it's something that nobody has asked yet and you actually need to propose an error or a question so a few key points that are very important when you're asking a question so you need to be specific so clearly State what you're trying to achieve uh where you're facing issues secondly you want to show effort indicate what you've already tried so include some relevant code or error messages so you want to have full information be respectful so you want to be polite and appreciative because these are other people that are taking time out of their day to potentially help you so you want to just be respectful and sure that you care and aren't just trying to care only about yourself you also want to use descriptive titles because when these developers and debuggers are going through and they're they're looking at all the titles they want to be something that's easy to read something that they can make sense of if it's like you know just a bunch of random characters it's like hmm maybe that person doesn't quite know how to ask about errors and so that's going to be harder for them to approach because they don't know what's going on uh so you want to address the issue or question within your title you want to keep it relevant so stick to the main topic and avoid any unnecessary details make sure everything is formatted properly I'm going to show you how to do that in a second here how to make sure your code and logs are formatted properly you want to also include some system and platform details so since this is closer to a systems programming language you want to include some information about your system such as maybe your RAM maybe just some other aspects that might that might affect the reason you're getting an error so anything it could be remotely close to that you want to make sure you have full information once again and lastly avoid emotional language don't get mad don't don't swear uh so just just be super polite about it and don't get like mad or anything I mean we're all developers here we're all on the same page we're trying to Make a Better Community for the development of artificial intelligence systems so uh don't get mad just take a chill pill if you can and uh yeah so anyways I'm going to walk you through how to actually submit errors so here are some examples of both good and bad examples so if you're on GitHub and you're trying to propose an issue you go new issue you say title a bat a bad example would be software keeps crashing dot dot dot and then your software sucks fix it am getting compiler getting compiler error so first of all the title is misleading it doesn't really give any information about it uh it's a little bit disrespectful because you're not considering uh what it looks like from their perspective your software sucks that's like you don't need that fix it it's hard to know what to fix if you don't give any details and getting compiler error well you need to spell things correctly first of all and uh just getting compiler error could mean anything there's like billions of compiler errors that probably exist so uh don't go down that route instead uh what a good example would be would be um unable to save settings in version at 2.1.4 so it's showing like a version specifically that you're getting errors in um and then just something around saving settings and then maybe your body would look something like hello first of all thanks for the great software so you're like oh this software's great you're being polite I recently updated to you know version one two three or two one four and notice I can't save my settings anymore every time I click save the software crashes and then maybe you would provide um maybe you would provide some steps to reproduce so uh you know open software go to settings change any setting click on save so this way that developers can reproduce the error if other developers are able to reproduce your error then it's easier for them to pinpoint where it's going wrong because if it's working normally for everybody else and not you then if you can show a way where they could get the same thing as you then they can compare what's working to what's not working and try to mess with things in between to get to a breaking point where it works and then doesn't work because of maybe one line or something so that's really useful and then what your expected result maybe it was right to I mean expected result you don't always need to put it there but it's still a good practice then your actual result is you know whatever error you get some system information as well like maybe your operating system for example if you tried to install mojo on a MacBook and you didn't have the Linux terminal if you just use the Mac terminal of course you're going to get errors because it doesn't support Mac OS yet so system system information is always good to have um and then just you know be polite any help would be appreciated thanks so that's a wonderful example and even if you wanted to you could also consider uh maybe just putting some quotes around things so let's say steps we produce um you put three quotes around it like that and uh we should we should when we submit this issue I'll actually go just to show you guys what that looks like so when you put the three quotes both on the top and bottom of something then you get this and then if you put single single quotes we're talking about uh these things by the way not these not these just the the grave and essentially those those quotes are going to allow you to make little code blocks in here that people can copy and paste from um so this takes a little bit of practice you can create your own GitHub repositories and practice it on your own but this is generally what it's supposed to look like it's supposed to be very clear you would probably include your logs in the form of this and then maybe some code that you have in the form of this like where your line is uh erroring out so since Mojo is kind of an AI derived language it's used for accelerating a lot of these artificial intelligence systems through just faster Computing so a big question is is since it's so early a lot of people are wondering if you can actually build and train neural networks in Mojo so I can't really say yes or no to this but if you were to use something like say tensorflow um that wouldn't work quite or tensorflow or Pi torch that wouldn't work quite as well because uh you depend on a lot of things like file read and writing inheritance maybe Lambda functions arrays whatever which just doesn't exist yet um so technically if you want to go the easy route and use a lot of the Python libraries that wouldn't work however there are still some people uh building some pretty cool projects right now that are more like a lower level uh like they kind of look like C plus plus code a little bit so they're not as pythonic if you will and I'll actually leave a project like that into the in the description somebody actually was able to uh build or at least attempt building the lamma2 model using Mojo so that's cool that's just going to be in the GitHub repo in the description so feel free to check that out uh the other point is that since we cannot read and write uh to files uh there there would be no point in actually doing a lot of this training so we would have to rely on third parties like python to do this read in writing and saving the actual model files for us or else what's the point of even training right if you have a script that trains a model and then just dumps all the parameters after then I mean you've maybe used it one time maybe you prompt the model once but that's just a lot of wasted computation so we want to be able to save the model files so that we can use them again and that's just not super compatible with uh plain Mojo right now so my answer right now is like no for beginners you should not attempt to build any neural networks from scratch or anything or even use pythonic Frameworks so for now my answer is no um and I should probably add to that meaning like what doesn't exist in the Mojo language if neural networks don't really exist they they kind of do but they also kind of don't um what doesn't exist yet so you have list comprehensions like arrays dictionaries Etc you have Lambda functions from python those don't exist yet struck inheritance uh you would see something like this with pi torch and inheriting an N dot module if any of you have worked with pi torch before so you can't really keep track of your gradients that way and then again file read and write does not exist yet so uh there might be a few other things that I maybe didn't cover but those are kind of the the the huge ones the outliers that are uh really important that you should know about and then lastly if you are really curious uh I would honestly just consider reviewing the roadmap which you can find at uh the modular website if we actually head over to the modular docs here you can go to roadmap and sharp edges and you have some priorities here so CNC plus plus interop protocols traits just just a bunch of uh cool things here to look over and stay up to date with so now you should have all the tools in your belts to actually get started with you know reading Mojo documentation building your own projects playing around with the language and all that fun stuff so I hope you enjoyed the video this tutorial was designed as a sort of beginner uh emphasizing for beginners people transferring from Python and trying out mojo as well as just some you know Concepts that you should be aware of when you're doing more advanced systems programming so hopefully this tutorial was informative to you hopefully it helped my YouTube channel is in the description below so if you didn't want to check me out and maybe even subscribe that's I mean it's totally free you can unsubscribe later but I make pretty good content on there so uh you might want to go subscribe uh that's just in the description so anyways that's all I got have fun my fellow magicians