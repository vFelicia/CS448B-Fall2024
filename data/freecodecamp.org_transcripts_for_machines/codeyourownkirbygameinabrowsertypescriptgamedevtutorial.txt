improve your typescript skills by building a fun Kirby game clone JS Legend teaches this game dep course and he'll teach you how to use Kaboom JS to create a 2d platformer game based on the classic video game hi everyone welcome to this new tutorial today we will be building a Kirby like platformer using typescript and the Kaboom Jaz Library so Kaboom Jaz is a library for making games and it can be used with typescript and here I'm just showcasing the project we're going to build so here it's a Kirby like character that can swallow enemies and shoot stars on once uh it is swallowed and then here you have a beautiful level layout by the way I made all the assets myself and then when you get hit like three times you respond to the original position and that's basically it so let's jump right into making a game like that what you're going to need for this tutorial is first of all I assume a basic understanding of typescript so maybe brush up on typescript you know just watch a tutorial or something before following this tutorial and I'm going to also use node so you need to be familiar with node so here I'm going to open up a terminal window and I'm going to set up the project differently than what you're used to if you're watching my if you have watched my previous tutorial tutorials sorry is that usually I would need to use index.html Etc and then paste the links to the libraries or use JavaScript modules here we're going to use a bundler it's called vit so I'm going to do npm run uh not npm npm create at vit uh not create vit at latest and then dot so that we we specify that we want the project to be scaffolded inside the current folder so by the way I'm using VSS code for this tutorial I recommend that you use it as well you can install it Etc now if you're familiar with typescript you're probably using uh vs code already so I'm just going to go over so after having done npm create V at latest we're going to select the vanilla template and then the typescript template and then you should have the following files now we're going to delete v.svg we don't need that also we're going to delete everything that is within the Source folder but we're going to keep the source folder and then here I think yep here it doesn't matter really you can just leave it as is it doesn't matter at all so let's get our assets so you will find the Assets in the description and yeah so it's basically just one file this file contains everything we need by the way during the tutorial we will be drawing our map using an an external editor called child and then we will uh basically pass this and for the this export to our JavaScript to take care of drawing so I see that the The Source folder is gone so we going to have to recreate it here we go so now what I'm going to do here is I'm going to create all the files we're going to need for this project right from the getgo so that it's going to be easy to follow so we're going to need a constant. TS file this for a constant we're going to need a entities. TS file this is going to be the file used to um contain the logic for our players our mobs enemies Etc we're going to also have a kaboom cx. TS which is where we're going to initialize the Kaboom library and export its context and then use that elsewhere we're going to also have a main.ts of course that's the entry point of our project we're going to need a state. TS to hold uh General Global state of the game so this is useful to know when to move on to the next scene for example and then finally we have the utils um UIL is just going to contain one thing I think just related to making the map basically all right so let's go to Main and before doing all of that I forgot we need to do npm install which is going to install the dependencies but we actually I should have done any npm install Kaboom as well so do this and this is going to put Kaboom accessible in your project so once you have this we can basically uh going to need the terminal to start a server in a moment but yeah that's basically it now here let's import Kaboom from Kaboom this how you import Kaboom here and then uh actually it's not here at all we're going to use the going to go to the Kaboom context and do this here so import Kaboom from Kaboom once this is done we're going to go to going to create our context so basically it's a way to initialize Kaboom so I'm going to export K which is going to be the Kaboom context we're going to use this constant everywhere when we need to use kabooma related functions and functionality Okay so to initialize Kaboom you just call the Kaboom function and pass in an object which going to have a bunch of um how do I say options so first let's specify a width let's start with 256 pixels and a height of 144 uh later on going to this is the resolution of the Game Boy but wider so it fits within a 16 by9 ratio we're going to set the letter box option to being true that means that uh basically our canvas is going to scale regardless of the um of the uh of the screen size basically and while keeping the aspect ratio and we're also going to set the global property to being false the reason we want to set the global property to being false is that we want to only be able to use Kaboom related functions from this constant that's why you need to set it to false now in our constants TS file here we're going to create one constant reles the scale of the game because the current resolution is too small and it's also going going to act as a workaround because in kabon Jaz there is a bug an issue where pixels sometimes they don't get drawn right so you will have let's say we have a Sprite uh maybe to illustrate I'm just going to pull this out so here our Kirby like character for example you will have it drawn where you will have the image the Sprite will draw all right but one pixel is wider or smaller than other pixel and to fix this the workaround I've found is to set a scale to a value and then go to the Kaboom context and then first of all add the scale property and here first of uh let's import import let's import the scale constant and then by JavaScript you know that you can if you have a property that has the same name you don't have to do scale scale like that so you can just do it like this it's a short hand so the scale is the constant set to four this is what looked good but also you need to multiply by four here this is a a weird workaround I found but it works so yeah and so I recommend just using it for now if you found a way to get around this issue then feel free to add uh a comment in the comment section and share it with us okay so now we have our context that's great now let's go back to main and in main we're going to have our I'm going to import first our context import k from the Kaboom context we just created and then here we're going to have to load our Sprites okay so the way we're going to load our assets going to be a bit different from other projects we've made on the channel I'm going to create an async function I'm going to call it game setup now for now let's me let me reduce this let me remove that okay so we have the game set up and in there we're going to call all all over our logic and afterwards we call game setup here the reason we're going to do this is because we want going to want to load the asset assets once and when the player dies we don't need to refetch the map data we don't need to refetch the the the assets or something like that so to avoid actually this is really to avoid having to refetch the map data coming from tiled which is going to be the editor we're going to use to draw our maps and it exports to a Json file and we don't want to every time the player dies to redo the fetch logic to get the level layout and then redisplay it Etc so by just having everything done within a a a sync function where we can use the await keyword to wait for the map to be map layout to be extracted before moving on this is going to be really helpful in not having to repeat this logic so for importing the Sprites really I'm just going to copy and paste because this is logic that you just have to to I'm going to expl it of course but it's a bit tedious and not no new Concepts or anything like that is really present so I'm just going to do um explain what everything is first so here by using the K which contains all Kaboom functions and methods we can use we can use the load Sprite method this is how you load Sprites in Kaboom and by the way because you're using a bundler like V or or any other bundler you're going to have this uh some info on how to use the functions you're using and examples so that's pretty handy so the first key the first Pam is the name of the Sprite how you want it to be referenced in your project the second one is of course the path to the the project and here the path is just do/ Cirby like PNG even though we're putting our Assets in the public folder and the reason for this is simply because the vit is going to make sure that if you put this uh the the the path here is going to append or make sure that it it reference the public what's outside as well so this is something specific to V I don't know if other bundlers do this so you don't have to do dot SLU Cirby like PNG and then we have a slice n and slice 10 and the way to explain this is how to slice your image because our image our Sprite has much more than a single spritey within it so it's a tile set basically and here you can see that we we have one uh every every Sprite is drawn as a 16 by 16 has a resolution of 16 x 16 that means that we have 1 2 3 4 5 6 7 8 nine different Sprites on the x axis and that's why if I go to main.ts uh yeah slice X is going to be nine because we have nine Sprites nine yeah in the image and then here for the uh vertical axis we have 10 so you can just count them manually but I think it's obvious and now here is where we Define the various animations basically you're telling Kaboom wh which key corresponds to which uh thing you want to display in this image so for example for curb Idol so the the main character is called curb so it's just a it's a Cirby like it's not that original of a name but you know it's just for a tutorial in the end so curb in the idol is a name I've decided to name this animation which only contains one frame and the first frame remember that it starts from zero so 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Etc so at frame zero we have this idle Sprite so this is the idol Sprite we're going to use and we're going to use this name to refer to it for Kirby inhaling so as you know Kirby can inhale enemies well it's the same thing it's just a single Sprite and it's the Sprite at index one 01 and then curb full is when yeah so I I guess you get the point and then here when you want to have an animation that has more than just a single frame you use an object like this where you specify a couple of keys the first one is the from Key and you you basically telling Kaboom at which frame to start the animation here from frame three it's going to be this inhale effect so this thing and just to put it in action just to show it to you all right so just to so show you the Kirby the curb inhale animation it's this thing when you're inhaling you have a couple of pixels that just seems to give the effect that there is some inhaling going on here we go so now if I go back and go back to main.ts so from frame 3 to 8 and then at a speed of 15 frames per second this what looked good and I want this animation to Loop so you can decide if you want the animation to just play once or to Loop forever and we want we want it to Loop until we just decide to stop it so that's why I used the loop property as being true shooting star it's the the star here that you that the player shoots once they are full and basically it's the same thing the same logic for the various other entities so copy the code if you haven't already or you can pause here so this uh software is called tiled and it's used to draw maps and here is a map I've drawn for the um the first level and I have another one for the second level so the way I'm going to go about it is I'm going to to teach you how to use til for the first level and then for the second level we're just going to use what I've already had and this time around it's going to be different uh we're going to export the way we're going to use tile is going to be slightly different from the previous tutorials so let's let's jump right into it so first of all install tiled if not already a link should be in the description now there's one thing you need to do because if you're using a wide a big monitor then everything should probably look very small so to fix this you go to edit preferences and then to themes and then you click you check mark the use custom interface font and then you can here select the font size you want and this way it's going to make everything much more visible now uh I'm I'm going to keep this as a reference as I draw the level because otherwise it's going to be complicated so I'm going to create a new map by going to file new map and then you decide how many tiles you want and the width and height of each tiles so here let's start with I think 30 by 30 um you know what I'm just going to look at the current map and see how many tiles we have it's a 27 by 20 tile so let's keep this so here new new map 27 by 20 so we can have exactly the same layout and of course every tile is going to be a 16 by 16 pixels and here don't touch anything it's on necessary all right we have our tiles here or actually we have our our map not the tiles we need to draw to draw in so first of all we need to import a new tile set and the way I'm going to do this is you specify the source so basically browse to where you put the Kirby like PNG in the uh public folder okay so I have done this so this is the path for me yours should be the same starting from here and now 16 by 16 pixels everything is all right and then click okay now once you have this you can use the control and mouse wheel to zoom in and zoom out so the only thing left is to start creating our V various layers and placing things so that's uh of course save so the way you save you you do save as I named it level. Json and I've S I saved it as a level devil 1. Json in the public folder of our project so I just go here and I click so yeah this was a mistake for me I just uh put it twice so I'm just going to delete this but you should have it here so once you have it here H we're ready to start working all right so now it's time for drawing so if I look at my reference we have the background as the lowest layer so background and what this is going to contain so just make things easy for me I'm going going to make everything nonvisible and here we can see the layout so basically one two and then okay so three 3 by two okay so I go here I'm going to select this three by two so they should be here yep and then one 2 three one two and three I'm just going to zoom in with the control and the mouse wheel so you can see what I'm drawing so basically you select tiles like this and if you do control and select you can Al and click you can select more than once more than one tile you can have something like that and then here for this I'm just going to copy so two to the side here we go and then just try till the end doesn't matter really all that much by the way always save while doing while doing this and then another Hill so I'm just going to copy those two by the way you don't need to do control you can just click and drag and you can select more than one and here you going to have it have a big map so you know what I'm just I'm not going to worry about having it exactly anyway so this is just to show you after afterwards I'm probably just going to I'm going to probably use the same map that you have here but for the level two as I said I'm just going to use what I already had so here um okay so this looks like this doesn't have to be exactly the same otherwise we're just wasting time then you have like that then maybe this like that and a final one here all right so this is our background layer we're also going to need to add to the background layer some tiles like this you're going to see what they serve what's their purpose but this is really something optional so I'm just going to create a new layer so by the way by the way in Til There are multiple types of layer you have the image layer if you want to put an image as a full thing but you have the tile layer for tiles the object layers object type layers are for uh boundaries and spawn points so where to put your characters away for you to know this and let's create another tile layer and this second one is going to be the clouds so clouds here we go and then once you have the clouds I'm just going to select the full Cloud Sprites and just start putting them here as you can see they can overlay on top so just put to a random amount it doesn't matter save of course as you do this now the next layer is going to be the platforms so it's a tile layer as well platforms or platform did I call it platforms all right so for the platforms let's not stray a lot from the layout so that's the level okay so I'm going to use this these two oops these two uh wait a minute no that's that doesn't work so oops where should I put this okay okay here and then I'm going to expand this like that I'm going to put this like that here we go so really not much to explain here just draw draw whatever layout you want then you we're going to need certain structures though just so we can have the same thing but this is not something I plan uh I draw it on paper but I don't think it's worth you know copying exactly what I'm doing just use the proper tiles explore around Etc and then here I'm just going to have a platform here we go and I'm going to expand that further and then like this I think that's it and we need another structure that is similar so let's have this here expand it downward and then couple tiles here uh how many tiles is there five tiles 1 two 3 four and file five and I think that's uh basically it we're almost done oops doesn't matter because you can just draw over it and it will replace the tile okay so we have this let's put a sign post here to signify the beginning of a level let's um put the exit door whoops here and I think a couple of grass here uh we need to extend the background so in the background I'm going to need this fix and this make sure to change the layer of course all right so I think we have our level and then of course in still in the background layer we can add this down uh for the rest of the the color the the full background going to add this using Kaboom instead it's going to be more performant actually it doesn't really matter in the end but I think it's better to do it this way because the way I'm going to use tile today is going to be very different and basically just going to take the image and just draw use the Json to draw the boundaries on top so we still instead of drawing each tiles in Kaboom we're just going to take a PNG so here you can convert as a PNG it's going to be very simple okay so now we have this it's time to place our various colliders so I'm going to create a new layer on top an object layer this time around I'm going to call it colliders and now here uh the way you draw colliders by using this Square this rectangle on top here and then here's an example you drag Ah that's a that's a mistake you drag ah come on what's so basically just draw like that so you drag and drop various squares rectangles sorry and this is going to Define what is collidable and what isn't and then here we go so once you have done this we're done with the collider layer and now it's time for the um the spawn points so for the spawn points it's also going to be an object layer and I think I call it spawn points okay so I'm just going to rename by the way you can rename by just double clicking on the layer name so spawn points and now what's going to happen here is I'm going to use a pin instead so you see the pin icon use that and let's put our kir like character here so let's put it here where the sign Point sign post is and here you select a name and I'm going to call it uh player this is how we're going to differentiate between all the different mobs Etc so player spawns here the flame type mob are going to spawn spawn here so flame oops I created two pins be careful not to create pins by accident because you can so to select one you use this button here then you click and then you if you do if you have the pin selected and then you try to select another one it's just going to add another one we don't want that so A Flame character is going to be here and here flame here we go and then I think that's it and uh we have our birds so let's put two I wonder yeah it doesn't matter the position you know so I'm going to select here C bird and then bird and I think we missed the guy enemy so the guy enemy is this one I'm going to uh let's put it let's put him here I'm going to call it guy all right you have everything done so save and now we're ready uh whoops I created a unnecessary spawn point so we have our spawn points which DET terms where the player spawns where the flame spawn where the guy spawns where where the birds spawn I think the birds are spawning a bit too far so let's bring them down a bit so they can have a chance to hit the player at at all so here here it is like that all right so we have everything ready so for the exporting process you can just use the Json as is but for the image we need to hide the spawn points hide the colliders and then go to file and then export as image and then it's going to tell you the path and only include visible layers and everything else should be unchecked so now export now you could have drawn decided on the background color and included it but let's not worry about this so export that and then now if we go back to our editor you should have the level displayed like this so you can have the level as a single image and this is more performant or Kaboom to only have a single image to display that is relatively small and then scaled up than having to draw each tiles using Game objects there are ways around it so you could use a UV quad texture but this is more advanced so I recommend using this method it seems very simple and can have bigger much more bigger Maps than you could previously with boom Jazz all right now that we have this uh let's go back to main and import the the Sprite so k. load Sprite we need the level going to call it level one and it's going to refer to the level one.png Sprite uh image that we had okay let's create our scenes we're going to have a uh the way you create scenes in kaboom J is by using the scene function you decide on a name and you pass this as a first param level one and you can have here we're going to use an async function going to explain later on why and then actually do we need an async function here I don't think we need it uh we actually don't let's just have a a normal error function that is going to contain the logic that is going to be executed when we go to this scene so by default uh you have to specify a default scene and you can do this by simply calling K.O and the name of the scene level one to go to the that scene okay once we have done that we can write our logic from within so first of all let's set the gravity to being of 2,100 this is what looked good it felt good to play and then here we're going to create a background for a game now here I think we could just um put that logic outside actually we're going to have to repeat it because each time for each scene the background changes um because there is actually a set background function in Kaboom J just set the background for all everything the issue with it is that instead of having white bars here it's going to just use the same color of the background and we don't want that we really really don't so that's why um yeah otherwise we will confuse the the player on where is the actual limit of the the level for example so here let's create a our first game object in this tutorial so a game object in Kaboom jazz is everything that can be a Sprite player Etc so you in Kaboom JZ you create game objects that use certain components those components come from Kaboom JS you can Define your own components as well and depending on which components you add in to this array uh your game object will have different uh properties and methods that are usable on it so I think this design is really interesting and I haven't seen it elsewhere I think that's what is called an entity component system but I haven't had experience with any other one if uh so if you know uh if this is actually the entity component system and if other um libraries in other languages use it feel free to talk to say it in the comments I'm curious I want to explore it more so we're going to use the rect component allows us to draw a rectangle by we passing the width and the height we can get the width and the height by calling the width and the height method of the canvas so this we want the rectangle to actually fill the full canvas so that uh it acts basically as a background then for the color I'm going to use the color component and in there we're going to call the color class I guess and use the uh from hex method so it's probably an abstract class and pass in the value for the background color and here I just gone into a Sprite where I've drawn the Sprite and just took the color palette so the color for the background is this and uh wait wait a minute I need to add another component I'm going to add fixed component this is useful later on uh it's going to make sure that this game object is not affected by the camera and we want we don't want it to be affected by the camera otherwise if the camera removes then the the the rectangle will no longer faill the whole screen because it's going to be positioned to the left as the player goes to the right and the camera follows the player to the right all right we have everything we needed so just uh to run the project you do npm runev and then click on the link and then you have just an empty uh background all right so now let's write the logic for making the maps so for loading the maps and displaying them so what I'm going to do is I'm going to write this code in the utils.py let's go over it so first of all we're going to need the actually don't need the context here uh what we're going to need is to import the scale constant it's we're going to need to have this everywhere basically uh as I explained is to prevent pixeling the pixels to have two pixels that aren't drawn that don't take the same space it's very weird a very weird effect but it seems to be happening in Kaboom Jaz if you don't for some reason sometimes so that's the only fix I found for it so I'm going to export a function an S sync function it's a it's kind of required because we're going to use Fetch and we're going to call this make map it's going to take as the first Pam the Kaboom context so the typing is provided by Kaboom so all these things are going to also come from Kaboom and that's great and the name of the map is it's going to be a string it's also going to be the the path so it's going to be used to find the path of the level so the first thing we need is to have a constant that will hold the maybe I should increase the font size by the way here we go uh okay so we going to need the um to hold the map data within the map data constant here and we're going to use await await and then fetch which is going to fetch the the Json so here we're going to use a template string so dollar name which is the name of the map. Json and then at the outside. Json to have it as a Json so you could have written this line in multiple um in multiple lines I assume that you know what fetch is and how to use it with syn we so I'm not going to spend some times some time here if you aren't familiar look at my previous tutorials or just search online I think it's going to make a better explanation so here we're going to use the key uh the Kaboom function to make a game object so in Kaboom JZ you can add a game object to the scene which uh basically implies that you have to create it or you can make it and then you can pass what you have made into the ad function later on and this is going to add it to the scene and basically draw it so here because we're making this a utility function we're going to first make the map once the map is made we're going to pass it to the main which is going to call the ad function on it so make really works the same way as ADD it's just that it creates the game object but does not display it so here we're going to use the Sprite component and this is where you can Define what Sprite you want and here because remember in main.ts we defined this Sprite as being level1 which is going to correspond to level.png and here we have the Json file for it level1 Json which we get from here is going to give us the map data so if I look at the Json export you can see that you have layers and each layers has a data property if it's a a tile layer or an objects property if it's a um if it's a object layer which gives us X and Y coordinates you can use all right so here kme K Sprite Etc and K scale it's the scale component we're we going to use the scale so the scale of the the map so the Sprite uh accordingly we're going to also use the positional component so this is when you want to set the position of a character you can use or a game object you use a position component it it takes in two values but you can pass in only one if if it's this same value for both X and Y and here for now we just use the positional value and put it at 0 0 so that the map is drawn from the from 0 0 so x coordinate 0 y coordinate Z okay and now we're going to have to get the spawn points so here the spawn points are going to be uh X and Y coordinates they're going to the find what we need uh where to place the various enemies players and Etc and for now it's going to be an empty object because we're going to get this data from the map data but just get what we need and store it here so the typing for this is going to be an object of course but first we need to Define what the type of the key is going to be so the key is going to be a string and the value associated with it is going to be another object which is of the type number and Y also of the type number this is going to make sense in a moment all right so now let's iterate through the map itself map data so for that I'm going to create a for Loop const layer of map data. layers and if you've seen earlier on in the level one export you can see that we have this layer property that contains an array that contains all of our layers okay now what now that we have this done we're going to Simply have an if statement that checks the name of the layer so if the name of the layer is colliders we're going to Simply have another full loop cons collider of layer. objects so here basically as I told you if the type of the layer is a tile layer it's going to have the data property which is an array that tells us which tile to draw Etc we don't need this for this project because we have already everything drawn as a single PNG we just need to display that Sprite but for colliders for object type you have this objects property instead of the data property which is an array containing the list of objects that is in this layer which contains also the X and Y coordinates for each of those objects okay so now here for collider of so by using layer. name each layer has a name and this how we can differentiate them really easily so for objects which is going to be an array so for each element of that array so here the I'm just going to call it Collider we're going to add to the map so map was created as a game object by using the make it it isn't displayed yet but one thing in Kaboom J you can have children game objects and this is going to be handy here because we want to add to the map the the various colliders so the colliders are going to be game objects as well here you canot use the make function you can cannot do I don't think you can do this so you need to use the add function to add it as a child to the map and then once map is going to be called with the ad function from Kaboom then it's going to also draw the children of that game object so to create a hitbox we going to use the area component that defines a hitbox for you automatically but you can specify a sh a specific shape so here the shape I'm going to use new K rect Constructor and it takes in as the first pram the position relative to the game object it's a vector to and here it's just going to be 0 0 so a single value is enough now then you need to specify the collider the width and the height of that rectangle and this is provided in the uh tile Port if you look at the export here you can see that for this object we have the width and the height properties that's very handy because we can now really know where to put those boundaries okay so we also want to add another property inside of the uh area component there's this thing called Collision ignore and we want basically you pass in a tag and uh is going to know if if Collision should be ignored with a specific type of game objects so game objects can contain tags we haven't covered this yet but let's add them those are arbitrary names that I have defined that there is this platform tag and the exit tag which is for the exit door it doesn't really for now it's not created anywhere but it's going to allow us to differentiate our Behavior so just to explain here we're going to have a Turner restatement which is a basically condensed if statement if the collider name is not the actually I forgot to do this in til so let's go back to til so here in the our collider I forgot the collider for the exit so here I'm going to draw whoops not here so here select the collider you can make everything visible it doesn't matter and then draw this add at its name the exit which is going to allow us to know that this boundary corresponds to the exit of the level save and then if you go back to til if the collider name so now if I go here I can see that there is one of them that is going to contain the exit name so if the collider name is the exit is the exit uh is not the exit basically is not the exit we're going to add the component called B body and in Kaboom JZ this component allows us to have collisions affected by yeah collisions and if you specify within it that it is a static body is static and you set it to true then the the current game object here the child game object is going to be remain static and so that means that once the player uh collides with them it's not going to move so it's really useful for platforms and then here I put it null the reason I'm doing null here uh oops it's a question mark so the way it works is that if this condition is uh true then you go here if it's not true it's null that means we add nothing no components to our list it's going to add no basic and which does nothing here regardless of the situation we Define the the position and it's just going to be collider X collider y nothing fancy and uh that's uh basically it right and finally a last thing this is where we add the tag actually so if the collider name is not equal to exit then this current game object that is being this collider that is being being added to the map is going to have the tag platform so the way you create tags in Kaboom is just a string that you attach that you add to your array of components and the way it's useful is it's useful because later on you can have event handlers and you just listen on a tag to know if this game object has collided or a class of g a group of game object game objects have collided with another otherwise we okay so if the collider name is not equal to exit and don't forget the comma here we give the game object the platform property uh not property tag so okay just to recap if the collider name is not the exit that means that we can give the tag the platform tag to the current game object Cur current collider we created as as a game object otherwise we can give exit tag and this is going to be y later on really handy okay now that we have this I think we have everything we need and uh yeah so we can continue here so if after doing all of that so it was the collider actually continue can be outside of the for Loop and otherwise it's useless so here continue so if the four Loop okay so if the first if statement is true there's no point in going further we just move to the next iteration the next uh uh layer and now here if the layer. name is the spawn points this is where we're going to have a for Loop const spawn point of layer doobs for that specific layer and then and we're simply going to have another if statement if the spawn point if the spawn points um object we created here has has a spawn point. name okay so basically the way we're doing this is that if the the the property the spawn point name is already defined so the spawn point name is going to be the name here so player we're going to have an object that is going to have all the keys so this point points you can use the key for example player and it's going to give you the position of the player can you use the key guy is going to be the the position of the guy mob and we're making this and here this first if statement checks if it already exists in case it already exists we're going to Simply add to the the spawn points so spawn point so that assumes that there is an array we're going to create we going to write the condition below of if the spawn points uh for the specific key does so if the key doesn't exist in the specific uh in in the spawn points object then we're going to just create an empty going to create an array and then in that array we're going to put the uh the position because we can have more than a single flame guy a single guy mob or a single bird this allows us to be flexible so if spawn point dot uh things going to make make sense hopefully in a moment I'm going to push to that array that we assume that there is an array with X spawn point dox Y is going to be spawn point doy and then we're going to continue to the next iteration because there is no point in going further now if if the the key did not exist that mean it's the first time we going to have to create it so we're going to do this spawn point spawn point sorry and then spawn point. name equal an array X is going to be spawn point dox Y is going to be spawn point doy and here here it makes all the difference it's because we created a what's the issue ah we need to um uh what did I miss did I miss something um um okay so we have spawn point. name and then we push and then push does not exist on the type I messed up I messed up in the typing gear it's an array okay so so it's an array of objects like this you need to add this bracket so now the typing should work okay we have everything we need so just to recap again sorry if it's getting repetitive if the key exists already in the SP points object then we just add to the currently existing array that we assume exist if it wasn't the case then we create that array and P pass in the first uh the first uh member of that uh spawn point name so yeah okay we have everything uh we need and then finally at the end so right below here we're going to return two things we're going to return return the map and the spawn points object those two things are very important and that's it so we can go back to main.ts and right before we enter the scene so after having loaded the Sprite we're going to call um yeah I'm going to call map so the map here is going to be called level layout and the spawn point spawn points going to be the level one spawn point and it's going to be getting this from await that's why a sync was needed and then make map it's going to import this automatically we need to pass in the context and the name which is level1 now one thing I want to cover is this uh you might not be familiar with this notation what it does is it renames the map and spawn points properties to being level one layout and level one spawn points this is going to be handy because when we're going to have to have two levels we're going to have level two layout level two spawn points and because it always the make map function always returns a map and spawn point properties if we were to keep the same names it would make things uh difficult for us so that's a a JavaScript syntax I don't think it's very common I haven't seen this much beforehand so in case you were like me and and you didn't know what this me meant yeah you now you know all right so let's draw our map so right below in the scene you can do k. add and just pass in the level one layout as I explained and this should draw the map the the image so let's look at the result voila you can see it drawn but um you know you can't see the can't see it fully for now but it works all right so before moving on let's uh actually write everything we need for the player the mobs Etc and then then we're going to come back here to main.ts and add them with the spawn points Etc so to do something like that go to entities. TS and let's write the logic so let's first write a function that is going to be responsible for creating our game object for the player to do something like that same pattern first we pass in the context it's going to be a kaboom context so Kaboom Kaboom context so the typing comes from Kaboom as well that's pretty handy then what we're going to need is to specify a position X which is going to be a number a position Y which is also going to be a number once we have all of this oh well my my my L uh yeah so now we're going to create a constant within call it player and call the K make function that I explained earlier on and here we're going to have a couple of components just to make things fast I'm going to copy and paste it copy and paste everything we need here and then go over line by line so of course we need the scale so import this from from this uh constants like that okay so what do we have here we have the Sprite component that uses the asset Sprites if we go here we named all of these assets and then here optionally the Sprite component can take a second param which is an object and you can in that object specify the anim property and specify which animation you want to play by default and we want to play the curb idle which is you know the name of the character it's frame zero then we create an area component uh we use the area component to create a hitbox with the following shape it's a rectangle with a width of eight and a height of 10 and here it's going to be positioned at x value 4 and Y value 5.9 relative to the Sprite this is so the character doesn't look like it's sinking in the platform you we you need to um put the hitbox in such a way that it's going to make the the character look all right as if it's on the platform normally uh this is a bit hard to explain uh without uh visuals so let's first write this out and then while you're going to open the debug mode you're going to see everything everything is going to make sense k. body here component so that uh the player can be collide with others other game objects and and be affected by gravity uh the position is going to be the position X past here but we need to multiply by the scale and the position y as well we need to also multiply it by the scale so that it is placed at the right position a scale component that calls the scale constant uh this is to scale the Sprite and uh yeah so scale the Sprite so the the the the character takes the correct amount of space uh the double jump um component is something from Kaboom that you can specify a double jump and how much jumps you want to allow so 10 jumps so that it looks like the the floating from Kirby but it's not unlimited and it's very easy you just use that component it's for free so we don't have to write extra code to implement the feature of floating so that's really great the health component allows us to specify some health value and then you can use the HP function method and the HT function to know and the heel function as well to heal the life points Etc so this is something that is handy in Kaboom JZ and the opacity is going to be set to one we use the opacity component uh setting it to one means that it's fully visible this is going to be useful when the player is going to get hit we're going to temporarily reduce the opacity to zero so that it looks like it's flashing and here this is some A New Concept whoops is that in Kaboom JS you can pass objects as uh as well as your components so objects going to contain properties that going to be accessible immediately from within the game object so if you do player dot you can access the speed direction is inhaling and is full those are arbitrary properties that I needed for the game so the speed is to really control the speed the direction for where the the Sprite is looking it's going to be used for that is inhaling is going to be a Boolean and is full as well that are going to be used to know when to allow for uh certain uh for the enemy to be swallow swallowed or not or inhaled Etc and finally the player tag is going to be useful I think I'm using it later on to to do the on collision logic to know if it collides with an enemy what to do what we need to do though right after I'm going to use player.on Collide method that is available if you use the body component in the I think the area component and then as the first param you specify the tag of the other game object you want to test collisions with or listen to collisions with and it's going to be the enemy we haven't created any enemies yet that's normal and when we're going to do it we're going to add the uh the enemy basically uh the enemy tag to the to th those game objects now here the assing function we're going to need an async function for multiple reasons uh mainly I think uh actually do we actually need a sync function here yeah we're going to need it because we're going need to F to make the player Flash and back and forth and we going to use a tween for that and it's much it gives us much more cleaner code if you we use the tween the await uh syntax and here what's handy with the on Collide is that you can have the enemy game object passed into to your function here so the second function is what runs when there is an actual collisions With the Enemy so if you have here I think enemy and then here we're going to type it as a game object and here we need to import a quick fix import this type from Kaboom and yeah so we are ready to write the the content of it so if so here again I'm just going to go faster so here is the first if statement if the player is inhaling and the enemy is inhalable you're going to see this is going to be a property we're going to create later on when we going to create the enemies then what we do is we set the inhaling to being false we destroy the enemy that means that the player inhaled the enemy so much that they it collided with the player and that means that means it's swallowed so we can destroy the Enemy by calling the destroy Kaboom function where you pass in a game object to be destroyed and then player is full is going to be true and this is going to allow us to play another animation and the one where the the Kirby Kirby like character is seen as full and also is going to allow us to know if the player can now shoot a star the second if statement we're going to need comes right after and it's going to be this thing um now here Global game State we haven't created this for now so let's replace this with level go to level two for now we haven't even like put I created the level two as well I'm going to use the original what I've already had in the original code base to go faster because I think you get the point so if the player HP so HP is a method that is available since we have used the health component in when creating the player object and if it's zero that means the the player is dead so in the case we it was inhaling or the enemy was and the enemy was inhalable we would return early here so the the enemy would be destroyed but this is when the character the player hits the Enemy by accident or the enemy jumps on the player or something like that then if the HP is zero then we destroy the player and then we go back to actually we should go back to level one because we respawn so we go back to the current level and then we return early and then regardless uh so if if this continues that means that the player HP isn't uh equal to zero that means we need to hurt give damage to the player so by using the hurt function it's going to reduce one HP by default and then you can specify a number if you want to reduce more or less and then here is the logic that we're going to use for uh making the player flash uh blink we're going to use a first a tween so a tween allows you to change gradually a value from one value to another and here we're going to use await because we want the tween to be completed before we move on to the next tween so here what this tween is going to do is it's going to take the opacity of the player the initial opacity and the target value is going to be zero and the time we want to give to the tween to basically transition the player opacity from one to Z so because currently it's one it's going to be done in 0.5 seconds and this is the function that does the job basically of grad so every I think frame it gives you a new value and this value is set as the opacity so for example it's going to go from one uh 0.9 0.7 0.8 uh no 0.7 0.5 Etc until zero and this is where you assign it this value to the new value of opacity can do this do opacity and then finally the last progam is what is the rate of change so it's going to follow a linear function so it's going to be done linearly and here once this is done because we have an await because this is asynchronous by default so if you were to not use the await you could call this and then the code is going to continue to execute while this is still running so to avoid this we first await that the tween is done so we have our opacity that goes from one to zero and then once this is done we have our opacity going from zero to one so this is going to give you the blinking effect so that's basically it now we have finished the on Collide logic here for now we're going to have to come back here later on to change uh here to not hardcode this but for now it's fine now what comes next is another uncollided but this time around with the exit and this is the exit door we have created the exit collider and here it's going to again I'm going to replace this it's going to go to the next scene so on collide with the exit we just use the go function from Kaboom to go to another scene and by passing it the name and then now it's time to do the whole inhaling mechanic so to uh do this what we need to do is create our inhaling effect so this is the the sprite animation that you saw earlier on that gives the impression that the Kirby character is swallowing something and inhaling something and it's a game object that uses the AET Sprite but the specific curb inhale effect animation as default it has a position a scale the same scale and the opacity initially is zero and we give it a tag what we're going to do is that this animation is always playing but we just tweak when it is visible or not depending on the situation depending on the player input and then here what comes after is the inhale Zone the inhale zone is a hit box that is not visible it just contains an area component with a given shape which is going to be a rectangle and what this inhale Zone does it will allow us to know U when the player can actually swallow an enemy and here again we give it a tag those are going to come uh later on we keep an empty position here because we're going to decide on the position depending on the direction of the player and this is what this next bit of logic does so here so here we have an inhale Zone onupdate function so you can use the onupdate method on every game object and it's even a function that is can can be called independently what it does it it runs it registered an event that runs every frame as long as the game object exists in this particular form and what it does is that if the if the player direction is to the left we need to place the inhale Zone to be Min 4 to 8 and because remember that the inhale Zone and the yeah just the inhale zone is a CH is a child yeah is a child so because the inhale zone is a child of the player that means the position here that is specified here is relative to the player to the parent that's that's why it's going to be minus 14 plus the position of the of the the player which is the parent but we don't need to worry about that and here we can specify the position we can replace the position by doing equal and then passing in a vector 2 which is just an X and Y a a data structure for having X and Y values and a single structure yeah this is offered by Kaboom but it's a pretty standard in game development here the inhale effect position we're also going to Mo modify it but because the reason here is that the the inhale effect is not a child of the player and the reason for this is simply because uh we need to be able to make it to hide it or not and it seems that in kabum Jaz you cannot hide a child so reduce the opacity of the child without reducing the opacity of the parent so that's why I need to manually do a player position x minus a certain Val value and player position y plus a certain value to get the actual position I want the inhale effect to be in when the player is facing left and it y say yeah uh in inhale effect uh we need to flip X so the animation by default is drawn a from the right side so if you look at it here from the actually it's from the left side but we need to specify wait a minute so it's it's bit hard to explain but basically we need to flip the animation so if it's uh on the left side we need to flip it to being true and on the other end which is basically logic that comes after here we just do false so so that it goes to the the other direction or the default Direction which is the from the right the swallowing is from the right or the left I don't remember actually and then finally those are the last portion of code we need for the player here again I'm going to avoid this for now let's put level respawn at level one so here an on another on update but this time for the player specifically uh if the player position. Y is superior to 2,000 that means uh in the canvas the more you go down the higher the value of y so here what it essentially is doing is that if the player Falls and exceeds this value then we respond the player so basically it is considered dead we respond the player by just going back to the scene which resets everything the state of everything so we don't have to worry about resetting Val uh Health Etc so it does this automatically and then finally we return the player in the the function make player so this is how we get a player and I think we're ready to just test it out to see if uh what happens so in the main right below here right below the ad let's create our curb character here's the code for it so here we call this I'm going to import don't forget to import it and then you pass in the K and then level one point points player use the player key and then there's only one player so it's going to be at index zero because if you remember uh the spawn points are for each key it's an array even if there is only one because there is the case where there is more than one so instead of having to check when it's an array or not we just assume that it's an array all the way and if you know that there's only one player you just do a zero uh pass the index zero and it's going to give you just the the single player position X and Y now for the actually we should have set the controls but let's do that later now here let's add the curb corrector to the scene because remember in make player we just use the make Kaboom function not the ADD and let's write some Logic for the camera so the camera is really automatic in Kaboom J you there's only a few things you can do uh so you don't have to write a lot of logic in the sense that sense so here you can specify the scaling of the camera so we want to have it at 0.7 this is what looked good for both X and Y coordinates so here it's either either you repeat actually in the end it's the same so you could have decided to write 0.7 by 0.7 which is actually shorter to write and then for the on update function this is an on update that is General so if you see here register an events that runs every frame not until the the object is destroyed because it's not attached to any object and here we're just going to make the charact the camera follow the player in a certain way so if the the position of the curb character the player curb. p.x this is how you access the position is inferior to the level one layout. p.x so the um basically where the level start plus 432 pixels this is what look good as long as it's inferior to that we want the camera so by using the Campa method uh function to be set at the camera the curb pos. X plus 500 and then at the height of 800 so the the y coordinate of 800 this is going to allow the camera to follow the player along a certain point and not exceed that point uh because if it exceeds that point then you're going to see the end of the level or basically way for you to avoid having to show more than what you want to show in the level so if you're at the end of the level you don't want to the player to to look very far to the right for example and here we add the position of the player plus 500 so that the camera is really the player is going to find themselves to the left side of the screen and they're going to be more space available on the right side so that the player can see further along this is something that uh it's really handy especially if you're making a Sonic type game because you want the player to be able to see uh as as far as possible for this type of platform it's not that necessary but I thought it looked better so now let's look at the result I'm curious to see if there's anything is anything going to change all right we can see our level but now we don't have the movement control uh movement controls and this is what we're going to deal with in an instant okay so now that we have the camera working and the character being displayed I think it's best to just uh start working on implementing the player controls so that we can truly see if the camera is actually working so by player controls I mean all the mechanics of the Kirby so moving swallowing floating Etc to do something like that I'm going to go to the entities folder uh file sorry not folder and in there we're going to create a function right below so this function is going to be called export function set controls and it's going to take two things the context as always but it will also talk uh take the player object now here I could have simply gone with the game object here as the typing but we want it to be specifically for the player so this is where a new type we're going to create a new type so the way you can go about creating types is either you create them all in a folder in a specific file and then you pull them out from there or you create them where we need them and really here in this project the the current state of the project I might expand the game later on but on my own but for the tutorial uh really we're not going to export any typing really there's only this type and you could have decided not to use it but I think it's it's best pra like it's a best practice to create a specific type for the player because there are some behaviors like you're expecting that the game object past here in the set controls function is going to have some components uh some some necessary components so the way you type uh a game object in Kaboom Jaz you can take the default game object type and then add to it here the various components you need so we want the following so I'm just going to copy and paste it and then talk over the content so this is going to go much F faster so here is the typing definition now all of these need to be imported from Kaboom so update import from kboom uh I should have just clicked here and I'll add all missing Imports all right so to explain so the player game object is a is a type that is a game object that has the Sprite comp component the area component the body component the positional component the scale component the double jump component the health component and the opacity component and it has the following properties the speed the direction is inhaling and is full Boolean and this in make player you can see that those are were the properties here so the goal of this is that if so somehow you were to use this set controls on a mob for example which is just a regular game object then you would have squiggly lines and typescript will tell you that hey you're not entering the correct type so I'm just going to put player game object here and now let's write the body of this set controls function so let's do that give me a second okay so first of all what we need is actually um I need a reference to the inhale effect that we had so I'm going to create a constant called inhale effect ref which is this uh here in the original code base that we had and this is a way to to neatly get any game object you need is you pass in the tag to the get function from Kaboom here inhale effect and it will return an array containing all the game objects that have this tag so here we only have we're expecting one so I'm just going to take the one at index zero this is going to be useful because here in the controls in the input is where we're going to decide whatever or not to show the inhale effect of the Kirby like character so really we need to start coding the player movement the way you do this in Kaboom is by using the Onkey down function and it passes to you the key that is being pressed so here I could just have a switch case statement so switch K here key here you could have left it as an if but it's more concise to use a switch case statement it's a matter of preference so also sometimes it's clearer to just use if statements so for the left case we're going to first set the direction of the player like this since we uh previously decided that those are the properties we we needed and because we created them we added them here they are available to be modified in red here and as long as you have access to the game object for the player so here we're going to change it to left or set it to left regardless of what the previous Direction was we're going to flip the player horizontally by using the flip X property this is offered by Kaboom if your game object has a Sprite uh users the Sprite component so we're going to have true set it to True here regardless and then finally to move the player it's in kabj it's really simple you call the move function and passes in a velocity an x velocity or a y velocity here we just pass in the player speed and Y velocity is zero so the player is going to move here to the right but you have to do minus to get to the left this is very simple and then you of course you have to break otherwise the other cases are going to run this is something like in JavaScript I don't think in other programming language it's the case now we have the right case and it's basically going to be the same thing so I'm just going to copy and paste but just different values here and then after that we have the Zed case uh the the case z when the player presses the Z key this is where we're going to uh basically make the character inhale so simply within this we're going to have an if statement if the player is full then we need to play the the curb full animation curb full animation once this is played or is playing we can show the inhale effect uh no actually hide the inhale effect by setting the opacity of the inhale effect ref to zero if it were visible and then we break here and then in here and then right below we we are still in the Z case if that was not true so the player was not full that means it's time to let the player inhale so is inhaling is going to be set to true and then we're going to play by calling the play function the curb oops curb inhaling that's the name of the animation and we're going to show the opacity so uh we're going to set the opacity to one so that we can show the inhale effect so now that we have this we simp we can break for real as well here and then we need to when using a switch case statement to have the default which is going to be empty in this case so now we should be able to move left and right let's let's look at it so if I use if I maybe should refresh the page oh I haven't called it so so it's it's not going to work so if I go to main.ts and I go right be before adding it to the scene that's called the set controls function it should be imported automatically and pass in the curb character uh of course the context first as well now if we look at the result I should be able to move and then when I press uh Zed I'm making the sound effect but but for now you see that even if I left um I stopped pressing the key Zed key the animation is still going on because we need to have a Handler that checks when we release a key as well and by the way if you press F1 you can see the various collisions here so yeah let's go back to the code base let's go back to the entities code and here I'm just going to collapse the Onkey down function now Onkey press this let's implement the jumping first I think and then we'll go we'll go with the the Onkey release so here same logic we pass in the key oops not page transition you know what I'm just going to copy the code just to be fast and then talk over it maybe I should start just doing that for all tutorials so key on key press we have the key here here uh this feels like unnecessary code you could have just have a simple if statement I'm going to leave it though in case you want to make multiple allow multiple characters to be used for jumping and here we can use the double job double jump method and the reason we can use that is because we used when defining the player game object the double jump component so this is what allows the Kirby like character to float to jump 10 times basically okay now here it's time to do the on key release so on key release here we go and then again here it's a switch statement I don't remember if it's going to be that much useful it's a single case you know what just to make the code better you know if key equal equal x let's remove all this unnecessary stuff let's not over optimize or yeah and even this is not necessary and then I of course need to remove that for the the linting the the formatting sorry to work so here if the key you do this actually um yeah anyway yeah there could be say that the switch case statement syntax is not that uh concise so yeah okay so on the on key release we have the key and then here I'm going to use a if statement instead of a a switch ke again and here if the Z key is pressed we're going to do a bunch of stuff so here if the Z key is pressed and we have another if statement usually I don't like that having a multiple ifs within let's keep it as is for now and I'm going to see if if it makes the code any more difficult to understand or if it can be improved later on so if the player is full we do something so we need to play the curb curb inhaling so the reason we're playing the curb inhaling animation when the key Z the Z key is released if the player if the player was full that mean they swallowed an enemy is because the animation so the image for both uh swallowing inhaling and um say shooting or spitting out the enemy the the star is going to be the same I thought it would work for both cases so that's why it's playing this animation here okay now let's do a const here and call it shooting star and this is going to be a game object that basically the projectile the star we're going to create it it's a disposable game object we just created here and we write everything we need for it here no need for mod rizing though uh if you if you were to expand this game and maybe make you know what what a good exercise you could do with this is try to make the C implement the copy abilities of Kirby so Kirby in except for the first game not only can he inhale enemies and throw stars and stuff like that but can inhale enemies and then use their powers so become a fire Kirby Etc okay so for shooting stars uh yeah we just going to need a to use the Sprite component and here the animation we're going to specify is shooting star I think we already defined it earlier on and we can also set the flip value so the direction from which you want the animation to play Within the second param because this is very disposable and we want need to change the direction afterwards because what happens is the projectile is uh shot and then it just goes to the and as soon as it either hits an enemy or a wall it will destroy itself so here we can do a simple depending on the player direction if the player direction is equal to right then this expression will evaluate to true and if it evaluates to true that means we need to flip X so that mean we're going to flip the start to be at the right direction because by default it is uh to the left like that and that's basically it I think yep now we can continue on so k. area here going to have a shape now here you can tweak these values so I'm just going to copy over the code that we need uh if it's at all possible uh let me just copy the whole thing so I'm going to copy the just the rest of the the code for this game object and I'm just going to go over it so here we have a specific shape which is a rectangle with this offset and then 6X six Etc by the way if we look at the the output and I press the F1 key you can see the the Box the hit box for the Cur Kirby like character so here and uh depending on how you position the Sprite I made sure to position the Sprite a bit above that's why the offset here was a certain value I think it was where it was where it was 4X 5.9 play with those values and you're going to see what happens and get a better understanding than me trying to explain it to you with words okay so we have the shap the the shape of the hitbox defined here then for the position it depends if the player direction is to the left then the player position. X is going to be minus um yeah we're going to take the player position to the we're going to take the X position of the player and do minus 80 otherwise if it's to the right plus 80 and this is so that uh when you shoot from the left and the right it corresponds you know because the the star is mirrored and it's going to go in a different direction so play with those values you're going to understand here for the Y there isn't much difference between either right or left Direction so it basically this what looked good taking the player position the white position of the player and then adding it five to it uh you can play with those values if you'd like and then of course we need the scale component as I started this game uh because as I said the pixels aren't going to be drawn properly where one pixel takes one pixel space but a second pixel can take uh 1.5 and this Distortion is a bug in Kaboom JS and the way to fix it I found is this it doesn't happen always so I think it depends on your resolution so if you were to make a game that is of a higher resolution you wouldn't have this issue I didn't have this issue very much before so it really depends on the resolution you pick it seems and then here depending on the direction we can use the move component the move component will just move the Sprite the the game object towards a Direction so that's the first paramet if you hover over it you can have a direction it's either a number or a vector to and here I'm just using the constants provided by Kaboom which is the left and right direction so if the player direction is to the left that means we need to make the star the shooting star move to the left otherwise we need to make the shooting star move to the right and then we add the shooting star tag here so that we can later on have a not later on just right now basically I'm just going to copy and paste it as well so right outside of this definition I'm going to have this on cied event listener uh that um actually yeah this this tag is going to be useful I think later on for other other things other event listeners because we don't need the tag because we already have a reference to the shooting star here so if the shooting star un collide with the platform tag so with any game object that has the platform tag then k. destroy is using the Kaboom function to destroy the shooting star so that's basically it and then here it's done and then finally what is needed is simply to put the player is full back to being false since we since the Kirby like character has just shooted the star so that they should be able now to uh swallow someone else another enemy and then you we're going to use the wait function from Kaboom that is going to wait one second before um making the player play the idol uh the curb Idol animation curb idle animation here we go here in case you didn't see it here it is so this is a kaboom JS function to do that and then we return early the reason we return early is that if we don't do this we can just go here and just set the inhale effect ref of the opacity to zero the reason we're going set it to zero is because now the Kirby like corrector has done inhaling so we don't want to show the inhale effect and then we set player is inhaling to being false as well because they're no longer inhaling anything and then we put the player back to idle that was the case if the um that was the case if the player was not full initially so can we can we make this better by removing this if statement I think we could have this as a second condition and then no I think it's best to just keep it as is by the way the source code is dis is available in the comment SE um not in the description so feel free to refer to that if you want okay uh I think our code is done for this so let's try it out let's try the output so I can jump I can inhale and then when I stop pressing it stops and then you can see the inhale Zone in the headbox so looks nice and then if I just go here there's no level two for now okay our game is is working and one thing about the camera I said that it follows you up until a certain point and then it stops here oops okay and then one thing I noticed is that we don't see the little thing here at the bottom so if I go back to main.ts and maybe instead of this I put 900 here uh you see this I wanted to see that so maybe 850 is going to be a good value but then again this is due to the specific map we we drew together instead of the original map from the the uh the original source code I made yeah maybe a bit more 70 should be fine does it work okay it seems to look good okay now it's time to work on making the enemies inhalable but before doing any of that we should uh probably probably write the code for the enemies so I'm going to go back to entities I'm going to collapse this as well let's write another function for making the flame enemies and to go fast this time around I'm going to just copy and and talk over it I think it's going to be better so here it is ah but it expect the anyway yeah let's forget this for now okay so we have this function called make flame enemy and it's going to be the flame NPC here uh enemy so to make this we need the context we need the a position X and Y position then we use the same thing but this time around I um I use the add function that might be uh because we just created immediately I don't think it's that big of a deal anyway uh doesn't matter for this game it doesn't matter if you use make or add just that if you use make you have to use add later in main.ts so here we have a flame character basically we set the animation we set the scale we set the position which needs to be according to the scale so that's why we multiply by the scale then we have the area which is the headbox for it and then the Collision ignore which is it needs to ignore collisions with other enemies the reason for that is and we use the enemy tag here the the reason for that is that for example the bird is flying on top and then the the flame is going to jump and we don't want both to collide we want both to continue doing their thing without any collisions so that's why we ignore the Collision if it does occur so it has no effect on the game we use the body component and then the state this is something new because we're going to define the AI from for this little Flame character and the way you do that is using a state machine and a state machine contains basically different states and then for each States you for each state you need to define the behavior and the what happens what makes it go to another state and what happens when it enters the state and what happens when it remains within the state so here the state component kabon JZ takes a default State and the list of all possible States here I've have the my state machine as being two states Idol and jump and we start with the idol and here finally we have the just add the the enemy tag and this is going to be useful for both this so that the enemy can ignore collisions with other enemies so for example two Flame character if they were to collide together we don't want them to have any effect so we don't have we don't want them to push it push uh to push each each other and it could be fun and weird to not have to have enemies being able to collide with each other Etc but it creates too much unpredictability all right so how do we Define the state so here once you have used the state component you use the on State under function to Define for this state what happens what is run when we enter the idol State and here I just use the Kaboom weight function but this time using the await keyword this is just so we have it as uh we have it sequentially so the weight is asynchronous by default that means if you don't put the await keyword it's going to run and the code the rest of the JavaScript code is going to run after it as well while by using the await keyword what it means is that we wait one second before moving on here so that's why I wanted this await here so that I don't I don't want the to move on to another state before we have waited 1 second so once we wait 1 second we enter the jump State once we arrive in the jump State we Define here what we do in that case so on state enter jump we just make the player uh the not the player the flame jump and we can use the jump function provided by Kaboom if your game object uses the body component and here we specify a jump Force this is just how how so like the name it's the force of the jump and it can it can be tweaked and I think 1,000 was the value that looked best and then finally once this is done there is another thing you can Define for a same state it's called on state update and here as it says register an event that runs every frame when in a specific state so while we are in the jump State we want to run the following so if the flame is grounded this this is a function method provided by Kaboom if you use the body component so want uh yeah so it basically checks for you if the flame is on the ground on a platform and if it's the case then we can just enter the state Idol again and basically this is a simple AI so just to make things clear uh what what this AI does is just it waits one second it jumps once it hits back the ground it enters back into the idle State Waits one second and then jump again Etc so it's not something fancy but yeah it it's a it's an obstacle I guess and then we return of course the flame and then we return of course the flame game object now let's make this make inhalable function that is going to be applied to All Enemies so right below set controls I'm going to again copy and paste the code for it and then go and explain it I think it's going to make much better explanation so I don't have to focus on typing while explaining and I don't waste time typing while while I could be explaining okay so here make inhalable this is the function takes the Kaboom context and a enemy which is just a game object so here we specify a bunch of on Collide event listener so when the enemy collides with the inhale Zone by using it stag we make the enemy is inhalable equal to true now here didn't exist before so not only you can create properties so you can create properties on the Fly for a game object and maybe it would have been better if here in the game object you want to create you create the property first instead of just relying on this but for this tutorial I think it's fine so if the UN Collide yeah so if if the enemy collides with the inhale Zone then we said is inhalable inhalable true so the inhale zone is this in the game when I press F1 it's this this part and by the way the debug the debug mode tells you the position of each game object and also the uh the tag for for example this is a platform this is the exit and I think that's it and this is the inhale Zone this is the player Etc okay now that we have something like that we have the uncollided end which also exists so as soon as the Collision is over maybe because the enemy moved away or the player moved away then we said the is inhalable to false so that the player could not inhale someone not in inside of the inhale Zone finally we have also the enemy on collide with a shooting star this is where the shooting star becomes useful and we run the following function what is really handy with oncolite is that it provides you the game object that is the tagged here so it it pulls it out for you and you can have access to it so here I can just do destroy the enemy and then destroy the shooting star um one thing I want to make sure though is in set controls maybe I wrote destruction logic here uh where is it where is it here okay I wrote for the platform here so if the platform collides with the shooting star then the shooting star is destroyed but this is a different k that we have here in make inhalable is if the enemy hits collides with the shooting star we need to destroy both the enemy and the shooting star that is here provided here and then here I use the player ref to get the player so the same way I did it earlier on with uh some another game object I don't remember and then here on update runs every run register an event that runs every frame as long as the game object exists if the player ref so if the player is inhaling and the enemy is inhalable that means we can actually do the the inhaling and then here if the the direction is to the right that means we're going to make the enemy move towards minus 800 so to the left with a a velocity a x velocity of 800 and if it's not the case then we do that we assume that it is to the left side and then we make the character the the the enemy inhaled a move to the actually it's the contrary so if the if the direction of the players to the right we move to the left the enemy mooved to the left otherwise it's the reverse and that's basically it and then now here when I commented out make inhalable I can just comment this back in and then yep that's it now let's write in main.ts the logic for that so right below where we wrote the logic for the player let's do it let's do the same for the flame enemy and it's going to be very simple we just need a for Loop and here I'm just going to import here and save of course so now const flame of level one spawn points. flame and then it gives you all the flame characters uh mobs and then you can just display them like that create them and that's it okay now if I look at the result make flame enemies is not defined really maybe I did not uh make flame enemy is defined maybe the import wasn't right what do you mean it's not defined um did I use the proper tag let's look at here we have flame if I look at level one we have flame flame flame flame everything seems to be correct so why it's not working let's look at okay it's working it's just uh it didn't refresh soon enough all right so as you can see I can swallow and then I can shoot I can swallow oops I took damage and then I can shoot and that's basically the game everything from this point now is just Improvement and increasing the scope so here in entities let's write the code for the guy enemy I'm just going to copy and paste it so yeah so let me just uh there's still some explaining to do it's not exact the same thing but it's going to be mostly similar so here I paste it and then let's go through it together so we have the make guy enemy function takes in the same params as make flame enemy uh basically the same components just the different animations and for the state it's okay here I used is an inhalable I added it to make flame enemy uh to the guy but not here so what we could do is just um let's add let's add it you know just to make things correct so I'm going to add is inhalable going I set it to True uh to false by default and here we go okay so the state machine here is going to contain more States it's going to take um actually this jump I did not implement it I wanted to the character to jump after moving left to right you can do that on your own but that's it has three states idle left and right and it start at idle so at the idle State same thing we wait and then we go to the left State we flip X false we set it to false in case it were flipped to the right which does occur when the right here using right when going to the right and then we wait 2 seconds before going going to the opposite State and while it's doing this while we're currently in the left State then we move to the left at a certain speed defined here and this is the same logic but duplicated and just tweaked so that it's the same for the right now we flip X to to being true because you know the the Sprite here the guy is is U facing left and Toad the right and then here here we move with a positive value instead of a negative value now if I go back to main.ts and I go back here we it's another for Loop same logic import this if not already save and that's it now The Last Enemy is going to be a bit different the bird enemy it's not going to have an AI really it's just going to move into a direction and that's it and it's going to spawn on continuously so I'm going to remove this not remove it I mean collapse it and let's write the last function for the enemies and then we're basically done with this so here I forgot to have the closing function uh the closing bracket the function sorry okay so we have make bird enemy takes this time around four perams instead of three only difference is the speed because it's going to vary each time we create a bird so here we have a bird in me basically the same thing and then is static being true now this it isn't necessary to have it to be static so let's remove that and it's going to move to the left by default at a certain speed that is defined by here and then we have the offscreen component and this is something very interesting if you're making planning on making a more uh more expanded game is that you want things to not render when they're offc screen at a certain point of course here if the distance from the the viewport is higher than 400 or equal then we destroy the bird because we just want birds that comes from the right and goes to the left indefinitely and for all those birds that were go were to the left then at some point we want to destroy them to free space I guess so as to our game not to coll have a frame rate that collapse and overwhelm our our our web browser I guess okay so we make it inhalable the the bird of course and then we return the bird and now what changes is here instead of having a simple for Loop we're going to have a a for loop as well and then here of course import make bird enemy and here we're going to use the loop function so here for bird in level one spawn Birds we have here a constant that defines the possible speeds we want to have 100 200 300 and then we use the loop function from Kaboom to basically Loop every 10 second it this will run so it's a clean Syntax for set interval if you're familiar with the JavaScript function for that now make bird and me is going to take in a random element from here so it's going to randomly pick either 100 200 or 300 by by using this logic so this is a very a common piece of code you see online where you do the math random times the length of the array then you floor it and this gives you an element within the array Is Random and that's it I think we have finished so if I go back to the browser you can see the guy is walking and if I were to just shoot now you see that they didn't appear okay now I understand why I had the his body static because it's affected by gravity so if I come here so if you're far enough away you're going to see the star otherwise if you're too close close to an enemy and you shoot the star it's going to disappear the star is both the star and the and the enem is going to disappear too fast I think and if you are to do if you want more better feedback a better feedback loop for the player I think it's be best to change this so as you saw the birds are just falling down and that's because we remove the is static and we don't want that after all so it makes sense to have here is static so that it's not affected by gravity the the birds now if I go and I look at the birds you can see they're coming in and I can shoot them and here we go now here it is and then of course there's no level two for now and you know what I think I'm not going to implement the level two I think try it out on your own try to create a second layout use the thing i' I've explained here and do the transition between yeah I think it's best and of course you can reference the the original source code I have the Gib Hub repo feel free to download it look into it Etc so yeah I think I'm going to end the tutorial here just not to make it too long and of course the concepts I I don't want to rehash the same Concepts all the time but I hope this tutorial really was clear that you understood how to make games using typescript and Kaboom JS so yeah thanks for watching And subscribe for more content so is it running at 60 FPS it is all right thanks for watching bye all right so I forgot a very important part of the tutorial which is how can you actually publish your game so when you're using a tool like vit like we did in the Kirby tutorial you need to use uh you need to create a vit vit V vitc config.inc from vit and then export default this and then here you need to specify those three Pro uh those two properties so the base need to be do slash otherwise when you're going to do npm run build uh you're going to get some that won't work H so if you open this using for example live server what's in the this folder then it's going to be um how how do I say it you you're going to get an error now you need also to disable the minification in vit uh this is an issue with Kaboom ja specifically I don't know in the future if it's going to still be an issue so try it without and with so once you have done this configuration in V.C config.sys at the root level of your project what you should do is just run npm run build so npm run run build and then it's going to run your compile your typescript code Etc so if you then you should see a disc folder appearing and this is the folder you need to zip you need to zip this and then you can put it on itch.io for example so here if I right click and open it with live server just to test out that things are working you can see that the game is actually working all right that was a little bonus that I forgot to include uh so hope you're still watching at this point thanks for watching bye