hello my name is utab Saha I'm a teacher for free code Camp the goal of this tutorial series is to learn the skills of a senior software developer in this tutorial we're going to chat with a senior developer we'll walk through a specific challenge that he faced and get into the nittygritty of how he thought about it what was a stop process and then we're going to do something new that I haven't done before we're going to walk through some code that he wrote One caveat it did get a little complicated don't worry about understanding every single line of code that he wrote instead pay attention to what comes afterwards the key takeway or the Insight that you can then apply to your own code finally there will be a call to action where I'll explain how you can build something for your portfolio that demonstrates the skills you see in this video today we're here with Mike triten who previously worked at Google and within Google he worked on on the search engine itself which uh you can imagine Google might be pretty protective of that code more recently he cofounded a company called WorkFlowy which is a way of organizing your thoughts plans todo lists and um it's pretty cool last time I asked it had around 1 million users I myself use it for a few things and this is me udab so today Mike is going to talk about a specific skill that he believes separates senior developers from Junior developers and that is a skill of knowing how to organize your code so uh that could mean for example organizing it so that it's flexible to change in case the requirements of your project change and it could mean a lot of other things too and let's hear how Mike thinks about it you said flexible to change I think that's a good that's a good point and and I guess flexible to change partly means understandable by other people or understandable by yourself three months from now um because I would I would say that that is a big thing I've noticed among less experienced programmers is is um the tendency to write code in kind of an ad hoc way where it makes sense like in a particular frame of mind at a particular time but then even for that developer three months later I've seen people have a lot of trouble making changes to their own code because it wasn't it wasn't kind of structured in a way which at a like maybe each function made sense but at a more high level um there wasn't some sort of overarching thought process regarding the structure and the uh the code and the data structures used and such so it doesn't it doesn't have kind of like a logical Simplicity to it um and it's hard hard for anyone else to make changes to or or even the same person who wrote it later down the road to me okay great so Mike I'm hearing that you have a particular passion for this skill writing welldesigned code that's flexible to change I'm wondering if we could drill into that a little bit more and I'm wondering if there's a specific example from your history maybe a challenging situation that you've dealt with that could maybe demonstrate how you approached this uh this issue of of how to design your code well sure so um I mean we can talk about this VR side project that I've been having which is like pretty early stages um and doesn't do a whole lot yet but I've definitely had to uh think a lot about I I'll just kind of describe the general idea of it so partly to kind of like get started on on doing this development I'm not sure how serious I am about this project in terms of like making it into a real professional thing but the thing I'm starting out with is a VR music visualizer so um I don't know if everyone is familiar with music visualizer but like you can see them in like iTunes and this older program called Winamp uh where you know you can play your MP3s or whatever kind of audio you have and um you'll see often kind of Tri psychedelic visuals that are you know will move around in response to like what's going on in the music um so you know I thought this would be a cool thing to experiment with in VR where you are kind of inside the visualization instead of just looking at it on your screen um sure so um this has been a project which I keep keeps ending up being more complicated than I originally thought it was going to be which I think is pretty typical of software projects I think it's especially typical of projects when you're going into a new area you don't have that much experience with maybe it would be helpful just to know at a high level what are even the how do you even approach something like this what's like the overall strategy for building this right so I think I I like to design things in a top down way at the beginning so I think you know first of all what am I trying to do here I'm trying to make computer Graphics do stuff and resp response to music so I mean that suggests I would say three components at the very least those three components being one capturing the music and and I guess I would say that I wanted to be able to capture the music the operating system is playing um as opposed to making like an MP3 player within my software um partly because I wanted to avoid having to write that code and partly to allow people to like play Spotify or whatever and View and use that audio um so so that suggests step one capture the audio step two process the audio for information that can be used to drive a visualization um because without any processing all you have is this time ordered list of audio samples which are just numbers and all you really know from that is like what the average amplitude of the sound is at a particular time you don't really have any more interesting information about it so um so you need to process audio and then the third step would be generate Graphics based on the processed audio okay um so those are those are sort of like the the bare minimum possible things so I knew I was going to have to do those three things um but then then I then I but then that doesn't necessarily suggest how the code is organized um so for so so what I decided to do was I basically have one component that captures the music and um and that component is a C++ class um that uh it that class encapsulates A lot of platform specific code and by that I mean Windows operating system code because this is running on Windows um so that that's one thing I generally try to do is if I'm writing platform specific code I try to isolate it into as small of an area as possible um because one one alternative would be to be you know like intermingling the audio capturing code with the audio processing code um the problem with that being that if if you wanted to Port the application to another operating system you would have a a much larger chunk of code where you were making changes as opposed to just swapping out the windows audio capturing class with the Mac audio capturing class basically to have all of that code and nothing else in a single module with a generic interface that didn't assume that it was for Windows right um and and so that was one decision I made was to decouple the audio capturing from the audio processing code okay we've thrown around a bunch of Concepts here platform specific code the capsulation generic interfaces decoupling what do all these things mean let's take a look at a quick example so here I have this function extract audio that's going to read in the audio data in a Json file here and it's just going to print out that data notice here that the C colon in the file path means that it only works on Windows this is an example of platform specific code if I were to run this on my Mac it wouldn't work to make this code more portable to other platforms we'll put all the platform specific code inside of a separate module here we have a module Windows code notice that the file path is now stored in a very variable called audio location now I'll import the module and call it platform specific code and I'll refer to its audio location variable in this way the extract audio function no longer needs to know the exact file path that detail is hidden away inside the module behind this generic variable name called audio location this process of hiding details about your data inside of a module is called encapsulation now how do we make this code run on a Mac we can create a new Mac code module and paste in a different file name that's valid on maaps then back in our extract audio function we can simply swap in the Mac module for the windows module and this will just work because the variable name is the same in both the windows code and the Mac code is both it's called audio location in both cases this this is what Mike meant by a generic interface notice that we had to change very little code when switching between Mac and windows uh this that means we can say that the extract audio function and the platform specific code are decoupled okay so you just saw me walk through a very simple example next we'll start getting into the code that m wrote and we'll start with a high level overview of how we organize this code one second here I I want to find a way to draw that somehow um do you have any recommendations I mean you could just have two circles audio capture process or something I don't know okay audio capture and the C I mean the capture is like sending information to the processor something like that with an arrow or whatever okay cool I like that and then uh processing and then you were saying that uh that the platform specific stuff was mainly here in the audio capture land right um yeah well it's it's in terms of audio it's all there no there's no platform specific code in the processing section right and that's that's to make it so in the future if I want to Port this which I may very well want to do I can literally swap in a new audio capture class versus if they were which which will duplicate virtually zero code with the old audio capture class um whereas if I if I had them combined then I would be either duplicating code or be doing a bunch of uh I don't know things would get ugly basically if I didn't decouple them and wanted to extend to another platform so I think that's just a general principle I would say is if if you're doing platform specific code try to have it in as small of a have it as small of an area as possible and with no nonplatform specific code so we're about to walk through the code that Mike wrote for his project one warning about this it's written in C++ it's complicated it might be hard to follow I don't expect anyone to be able to follow along with all the details here the most important thing look for the key takeaway at the end of this walkthrough where I'll explain what are the main principles here that you can apply to code that you write whether it's C++ or JavaScript or any other language okay so I'm gonna I'm going to briefly show the classes that I was discussing earlier so um we have the first one which is the audio capturing class and uh this um so right now it has has a very simple interface um so it has down here in the bottom it has a bunch of really um because one unfortunate thing about C++ is you have to Define in your header file all the member variables of the class so so I mean they're private so nothing else can actually access them but it does create this kind of massive indecipherable stuff anyway on the bottom we have indecipherable Windows specific stuff but then on the top in the public section we can see there's this Constructor um which is it it basically takes no arguments you can take one argument to write the captured audio to an output file and then it has two methods um one to get the sampling rate um of the audio like you know CD quality audio would be 44.1 khz um and then this call back or or this function process new frames so a frame is a collection of audio samples captured from the operating system and then that takes a call back and um I uh if I remember correctly I think I used a callback um to avoid having to do unnecessary data copying um basically it's kind of like a a optimization type thing but it's done in a way where it doesn't really add much additional complexity so basically you call Process new frames to get the most recent audio that the operating system is outputting um and you give it a call back which takes a pointer to the uh the audio samples and how many of them there are um so uh you can see that I I'll just briefly look at the implementation of that just to show how incredibly long winded and ugly it is so we have like cocreate instance uuid all this I mean basically there's just like pages of of like I mean it's kind of crazy how much code needs to be involved just to capture audio anyway that is why in its own classes so all that stuff is not elsewhere um so then we have um so I think well briefly there's I separated I have the application which the way I view the application is it's it's the thing which is actually um visualizing music it's not it's not capturing the audio it's not processing the audio it's not like setting up the windows the window it's not like talking to the VR device it's just like generating a scene and then rendering it um so what is this application class in relation to the two decoupled modules we talked about earlier there's a capture and the processor where does application fit into this um okay so the application so if I remember correctly the application is instantiating the processor so the application actually owns the uh the application owns an audio processor object which is defined right here and um but but the uh so I have another section of code which is the platform specific non application code which is the code which is like you know like capturing keyboard input and on Windows and like opening up the window on Windows setting like initializing the VR headset so and also initializing the autoc capturing code so basically the the application is getting sense uh audio frames from the audio capturer using this method I'm highlighting and then it's passing those on to the oh sorry to the audio processor which it instantiates um I could I could have had the audio processor be something which is owned outside of the application module but I decided that I think I basically decided that all I was going to have the application own all not nonplatform specific code all right so I want to emphasize an important principle that came up in how Mike organized his code he paid special attention to managing dependencies in his code so first of all what is a dependency a dependency occurs when one piece of your software relies on another piece now in Mike's Music visualizer the music visualization logic depends on audio captured from the operating system so the app depends on the operating system now Mike Mike was concerned about the this dependency and here is a cue that he noticed that let him know that hey there's something dangerous about this there are two factors one how is How likely is the dependency to change significantly in the future and two how many parts of the code touch this dependency if both of these numbers are high this can create problems because then you may find yourself having to rewrite many parts of your code base over time so in Mike's Music visualizer the operating system could change in a very big way let's say he moved from a Windows platform to a Mac well Mac could have a very different way of capturing audio so it could change in a pretty big way this number was high now what about number two how many parts of the code touch this dependency well it turns out that the music visualizer needs to interact with the operating system in a few different ways and it required a lot of ugly code as Mike put it so this number is high too okay so this was concerning to Mike because if the operating system ever changed well he would need to rewrite a bunch of code many every part of his music visualizer logic that interacted with the operating system so he designed his code in such a way to make it flexible to changing the operating system now the solution for this situation that he came up with was well since this number is high let's try to reduce this number and reduce the number basically reduce a number of parts of his code that interacted with the dependency and he did this by introducing an audio capture class now all of the operating system interactions are now handled in here you could say he took all of the operating system logic and isolated them in one place meanwhile the music visualization Cod code only interacts with the audio capture class with this one function process new frames this process is called decoupling or you can say that these two things the music visualizer logic and the operating system dependency are now Loosely coupled the advantage of this is this allows Mike to swap in a totally different operating system in the future and none of this music visualization code which is the core business logic of his app would have to change okay I want to address some of the nuances around this topic of dependencies you saw one example here how the dependency was concerning to Mike and so he put that dependency in a small part of the code base and minimized how often other parts of the code touched it that's definitely a pattern that you can learn from and apply to your own code but I want to emphasize the dependencies are not always bad uh remember the key cue here was the dependency changed a lot and many parts of the code base touched the dependency there are other situations like the dependency might not change a l or it could be somewhere in between and uh there's there's a lot of nuances here so um in fact these nuances were covered in the original case study I did with Mike but it was just too much information to put in one video so all release another video covering some of those nuances from the original uh interview I did with Mike okay you've seen Mike demonstrate the skill of how he organizes his code and I've shown you a key takeaway that you can start applying in your own code that you write now I want to make sure that you do actually write some code that demonstrates the skill I want you all to have a solid portfolio project that you can showcase at your next job interview in front of your future employer where you can explain the nuances of why you organized the code the way that you did one powerful way to build your portfolio is to contribute to an open source project now free code Camp happens to be the most starred project on GitHub it's a respected open source project and I've put together a guide which will help you get up to speed on the codebase and start contributing you can go over to arena.com freecamp to get that for free look down in the description below the video for a link to that and um as an extra bonus if you go through the guide I'll personally help you find a feature that you can build for free code camp and I'll help you get started I'll even give you some pointers on how to think about organizing your code for the feature that you buil all right now I have another call to action specifically for folks who are from minority groups that are underrepresented in Tech like racial minorities and women this goes back to the reason that I teach people to code and the reason that I make these videos I personally enjoy a lot of mentorship growing up and I believe this is the main reason I was able to even have a career as a software developer I believe that if everyone enjoyed as much mentorship as I did then everyone could also find their dream Tech job just like I did I believe this so much that I bet my future on this I left my job as a software developer two years ago to help develop a system of mentorship that won't cost you any to enter in fact you can even get paid as you as you're going through the program you can find out more about this at arena.com freecamp all right thanks everyone for watching stay tuned for more videos if you have feedback on what you liked about these videos or what I can do to make them better please leave comments down below or reach me at utab arena.com I got some great feedback from a few of you last time so please keep doing that