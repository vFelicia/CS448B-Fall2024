a try that's how this is pronounced right here a try sometimes called a prefix tree is a special type of tree used to store associative data structures a try stores data in steps each step is a node in the try this is often used to store words since there are a finite number of letters that can be put together to make a string a possible use case would be to validate that a word is in a dictionary each step or node would represent one letter of of a word so if you can see over here this is an example of a try this word right here will be b a l l ball the steps begin to Branch off when the order of the letters diverge from the other words in the try or when a word ends so you got the word b a l l but you also have b a t bat so the first two letters ba a are part of the word ball and part of the word bat and then down here you can have doll do dork and dorm if you look at the red stars that just means it's at the end of the word so the word do you can see it's the end of a word even though there are still letters in other words after the O so let's look at the information in each node from the code here each node is going to have keys which is just a new map and this is the es6 m map structure it's kind of like an object it has just key value Pairs and in the in these Keys the key value pairs are kind of like the name of a folder and a folder in a directory structure so if you can imagine these all folders in the root node there is uh the keys map that's going to have B D and S and each of the the key value pairs are the B the name of this folder is the key in the map and the value of that key is the folder B the actual contents of the folder B and so the D is the key in the map and the value the key value pair the value is going to be the actual contents of the folder each node is going to have a list of keys which is just a list of all the other letters that are inside that folder or in that inside that node and then we're going to have an end data just means is this the end letter in a word so in this picture all of the nodes with a star have end set to true and all of the nodes without a star have end set to false now we just have a Setter function set end end is equals true is end so it's just going to return true or false if it's the end of the word so now that we've looked at each node in the try let's look at how the code to the actual try set up so we're going to only going to have three functions we're going to have add to add a word to a try we're going to have is word to see if a word is a word in the try and then print this is more of kind of like a helper function just to print all the words that are in the try so before I go through the code let me show you how it would be used or we're going to create a new try and then we're you can add the words like this and then after you add all these words and these are the same words that are in this picture over here you can check if it is a word is doll a word well do doll is going to be a word is Dora word see we have the word d o r in the picture but there's no star on R because door is not a an actual word even though those letters are in the try and then dorf well check d o r and then there's no F so that's not a word and then you can just print the whole thing like that so if I run that you're going to see in the console down down here true false false and then you can see the whole list here so let's go back up to here first of all we're going to create the root node a new node and then let's look at the add function so this add function is a recursive function so when you call it for the first time you're going to put the entire word you want to add to the try and that becomes the input and here it says node equals this. root that means if you pass in a node it will use that node but if you don't pass in a node it will just use this. root as the the default node so if input. length equals equals z that means if we're at the end of the word that we passed in we're just going to do no do set end and then return and we're done with the add function else if that means if there's more than zero letters that we've passed into this add function we're not at the end of the word so first we're going to check if there's already a node with that letter that we're looking at so this says if not node. keys. has so let's say we're in the root node node. Keys is a list of all the letters that that root node points to so if it does not has if it does not have a letter input zero would just mean the first character of the string we passed in so if we pass in ball it would this is just saying if there is not a node with the letter B here then we are going to create a node with the letter B no. keys. set set is how we're going to create a new key value pair in the keys map we're going to set it with the key to be the letter input zero so input with zero in Brackets just means the first letter of the input we passed in so if we pass in ball the first letter is g to be B and so remember each key value pair is the name is kind of like the name of a folder and the contents of the folder the name of the folder is B the contents of the folder are a new node so then this is where becomes recursive we're going to call this. add and we're going to pass in input do. substra one which takes the input and takes every letter after the first letter and passes it into the add function again so if the word was ball every letter after the first letter is a l so we're going to just pass in the letters all and we're also going to pass in a node before I remember we start with the with the root node now we're going to pass in this node which is also the node we just created here so we're going to set a node with the letter B that would be the input zero so now we're going to get the node with the input zero that's the the first character so so now we're going to run the add function but instead of at the being at the root node we're going to be at the the node B and then the else is just if there's already a letter by that name so remember here we added a node with the letter B but if there already is a letter B like for instance let's say we already have the word doll and we're going to add the word dork if we're at the D and the word doll is already in the try and we want to add dork well o is already going to be in the try so if o is already in the try we're not going to create the O node we're just going to add the the new substring which in this case would be o RK we're going to add that to the nodes that node. keys thatg at input zero which would be the O node so we're going to keep running through that until we've added the word to the try and then down here we're going to check if the word is in the try so this is where the try really perform forms you can check if a word is in the dictionary much quicker in the try than other data structures because we don't have to check through every word we're just checking one letter at at a time so we're passing in the word we're setting the the node to the root node at first and then this is the loop that we're going to keep running through until we find the word so while word. length is more than one while there's more characters to search in the the word that we passed in so if not no. keys. has word this is saying we're going to check the first character in the word so let's say we're on the the root node so if there is no key with the first character in the word like let's say we pass the word tree well there's no T there's no key with the letter t here so we can return false we quickly determine that that word tree is not in this try because there's no word that starts with t else that just means there must be a word that starts with that letter so let's say we're looking for the word send well if it does have the letter s then we're going to do these two things we're going to set the node remember which used to be the root node but now we're going to set the node to the the node s because if we're going to look for the word send we're setting the the node to the S node and we're going to change the word into the word minus the first character so now we're just going to be looking for the word in instead of send so we're going to go back up here now we're we're going to keep running through this now we're on the S node but we're looking for the word end and yeah we'll find the E we'll find the n and we'll find the D and now we go to this very last line if node. key. has word which would just be a single letter because remember we we keep taking the letters off and so if it has the last letter of the word that we passed in and it is the end so is end then we're going to return true that word is in the try else we're going to return false yeah so this last one was just the the print function this just kind of a helper function and so we're going to create an array of every word but right now it's just going to be empty then we're going to search we're going to pass in we going to search if we don't pass anything here it's going to set this to the root node um actually I bet we don't even need this let me just run that just to see if it does the same thing in the console yep we don't even need to set the node to the root node uh because when we first call The Search Command down here we already pass in this. root so we're just going to pass in a node and we're going to pass in a string here if node that keys that size does not equal zero that means there's still still more letters to look through so for each letters in the keys here let's say we're on the the root node so the letters in the key would be B D and S so for each of those letters we're going to run the Search Command again and then we're going to pass in node. keys. letter that means we're going to pass in the the node at that letter so we would pass in the B node and then we're going to add that letter to the string at the beginning the string would be empty so do string. con concat that means we're going to add one letter we're going to add the letter b and basically since this is recursive it's going to keep going and keep adding each letter it's going to keep concat each letter to the string until it's formed the whole word and then see if node. is end if we've gone to the last node in the word it's going to do word. push string so that's our words arrayed if we've gone to the last letter in the word we're going to push the word onto the words array now else that's else to this if statement if the no. keys that size does equal zero then we're at the last letter of a branch if string. length is is more than zero where we're just going to push that word on to to the words array or else returned undefined and here's where we call that search function for the first time so here's the search function um and then we call it for the first time and it's just going to go over and over until it gets every word in the try if words. length is more than zero it's going to return that word the words the words array or it's going to return null if there's no words in the array so that's a try thanks for watching my name is Bo KS don't forget to sub subscribe and remember use your code for good