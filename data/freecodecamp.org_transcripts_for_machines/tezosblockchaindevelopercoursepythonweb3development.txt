if you're interested in blockchain development this indepth course will teach you about the tasos ecosystem and how to develop distributed applications for it the only prerequisite for it is a little python knowledge this course was made possible through a grant from the tasos foundation back in 2022 in this module we will do a quick overview of the different applications the blockchain like tesos already makes possible the first type of application is to help the building of communities around brands or teams and to make it possible to own an internal and unique piece of History nfts make it possible for fans or customers to own and collect a token specific to their favorite team or to their favorite brand then marketplaces exchanges or Dows make it possible to build communities around them and help give fans a sense of belonging tesos is used for this in all kinds of fields for example fashion soccer Formula 1 Esports or even Spring Water another application of tesos is in the field of games where it can be used to add new features that help extend the life of games and provide a better experience for gamers it can be used to eternally preserve a player's achievements it can also be used to create multigame challenges and it also lets users collect and trade in game assets tesos is also used a lot in the field of art it helps give artists A much wider and International audience and it brings new ways for artists to make a living thanks to direct sales or royalties it also enables the production and sale of new forms of art such as generative art a very strong field for blockchains is decentralized finance that brings new Financial products and make them available to anyone some examples on tesos include projects like lug a stable coin ped to the Euro or real estate tokenization projects that make it easy to own a piece of a property and decentralized lending markets that make it easy to borrow different types of tokens tesos can also help people develop initiatives around causes for example around protecting the environment it can be used to raise funds for nature preservation and to build communities around nature awareness these are only a few examples of what's possible with tasos and it is only the beginning by following this course and learning to develop your own smart contracts you will be able to invent your own applications in one of these fields or in other fields in this short module we'll do a quick overview of what you will learn during this course we'll start by showing you the different key components of a blockchain and it's ecosystem so we'll talk about accounts about wallets about blogs Etc so that you can understand all of these different elements and their names then you will practice by creating an account and performing a fut transactions calling smart contracts Etc in The Next Step we'll have a video that shows you all the different steps that a transaction takes from the moment you decide for example to purchase an nft to the moment that this transaction is final on the blockchain so that will help you understand what really happens internally and how things work in the blockchain then we'll focus on the heart of this course which is for you to learn to develop your own smart contracts using the smart P language one of the several languages that are available to write smart contracts on tesos while you learn to write your smart contracts you will also learn how to develop your own test scenarios for your smart contract to make sure that everything works and to avoid the main bugs you will practice all this on a variety of concrete exercises an example this will be a very practice oriented training and we ask you to play along and really try to solve each exercise because we really believe that this is by practicing that you really learn the best so you will learn smart contract Concepts from the very basic types like basic numbers and strings all the way to very Advanced smart contract Concepts such as inter contract calls or upgradable contracts and you'll realize that smart contracts are usually small projects so it's not very hard to write smart contracts but the hard part is to avoid flaws so to help you with that we will spend quite a bit of time teaching you how to detect protect flaws how to avoid them and how to fix them because a flaw in a smart contract can mean potentially losing Millions you will be creating smart contracts in all kinds of areas you will create nft smart contract marketplaces auctions yield farming smart contracts you will learn to build oracles decentralized autonomous organizations or will play with Randomness through a lottery smart contract then you will work on decentralized finance contracts so will talk about how flash loans work how fungible tokens can be created and how to exchange currencies using liquidity pools and take advantage of Arbitrage opportunities Etc so this will give you a good idea of what real smart contracts look like and put you on a path to write your own there are very few prerequisites for this course and what you really need is some basic experience with programming we don't expect you to be a very good developer but you do need some programming experience to be able to follow this course what you don't need is specific knowledge about python it may be helpful if you already know python because smart py is based on python but you'll be okay if you're not familiar with python and you also don't need prior blockchain experience we'll teach you the basics that you will need for this course in this module will give an overview of tesos and its different components and get an idea of what a blockchain is tesos is a public opensource blockchain protocol this means anybody can read the code of all the elements of the blockchain and anybody can access the data of the blockchain and even join the blockchain by setting up their own node we also say that tesos is a smart contracts platform this means it's a kind of blockchain where you can deploy and execute smart contracts when one of the key aspects of tesos is that it relies on an energy efficient proof of stake consensus algorithm that makes it very environmentally friendly compared to some other blockchains tesos has a self amending governance that makes it easy for the protocol to evolve without the need for hard Forks Community itself decides through rules defined by the protocol on evolutions of the protocols that we call amendments tesos has been designed to facilate code safety through a number of design choices and application of formal verification to the protocol so let's talk quickly about the history of tizzel when creating tizzel the creators wanted to address the weakness of the first blockchains there was a weakness in the governance the way that blockchain could evolve and how the community to decide and how to evolve the protocol it appears that the first blockchains didn't evolve as much as they could because they liked a governance mechanism another weakness was the high energy consumption of blockchains due to the use of proof of work as a consensus algorithm finally there were a number of security issues with existing blockchains that the creators of tesos wanted to address the first step in the creation of tesos was the publication of a white paper in 2014 that described its principles from 2014 to 2017 a prototype of the tsos protocol was developed then in July 2017 232 million USD were raised in Bitcoins and E to help develop the ecosystem and the tesos main net was launched in July 2018 after it's launched between 2018 and so far 20123 the tesos protocol was upgraded 14 times through the on chain governance system so when we talk about tesos we're talking about the tesos blockchain or the tesos network if we talk about the underlying cryptocurrency we will talk about the tees and when you talk about mounts you talk about how many Tes you have or for example Alice transfers tentes to Bob the ticker used when you want to check the conversion rates between different cryptocurrencies on exchanges is xtz and T has a logo that you can see here now we will describe the different key elements of tesos we'll talk about accounts transactions smart contracts the blockchain itself and its blocks we'll also talk about wallets nodes and Bakers tesos is based on a system of accounts where every account has its own balance in t but there are two types of accounts on tesos implicit accounts are the accounts directly held by users they have addresses that start with TZ then a digit typically tz1 but also tz2 or tz3 are possible then we have originated accounts those are smart contracts that are a special kind of account that also holds data and code originated account addresses start with KT usually kt1 we'll talk a lot about transactions a transaction is a transfer of TZ from one account to another or it can be a call to a Smart contract and it can be both you can call a smart contract while transferring TZ to the account of that smart contract and transactions are digitally signed by the caller to authenticate that they are the ones really wanting to do that transaction but transactions are one of many types of operations that can be applied on the blockchain we can have other types of operations such as creating accounts deploying smart contracts voting for an amendment to the protocol Etc smart contracts are a special type of account that like every account has a balance of TZ and an address but it also has some data that we call the storage of this smart contract and it has some executable code so a piece of code in the melon language that is executed whenever someone calls the smart contract so when you call a smart contract you may send some test to the smart contract and pass parameters for the code and the code will be executed and it may change the data the storage of the smart contract or generate new transactions and new operations that will be executed after the end of the execution once you deploy a smart contract its code is immutable you cannot change it anymore so that people who call the smart contract can know for sure what code will be executed we can take a small example of a smart contract let's imagine that we have a contract that tracks the ownership of tickets for a conert each ticket will have an owner and the owner of a ticket can transfer it to someone else or change the ownership of a ticket so in the storage we will store all of the different tickets and for each ticket we could have a row a seat number and the address of the current owner and then in the code of the smart contract you could have a entry point a function that can update the owner of a given ticket so you indicate the row the seat and what new owner you want then we will fetch the corresponding data from the storage verify that the caller is actually the current owner of the ticket and then replace this owner with a new owner the tesos blockchain stores its data in a chain of blocks of data so that's why you call it a blockchain and the blockchain is is maintained by a decentralized network of nodes every 15 seconds at the moment at least a new block is added to the chain and each block will contain a sequence of operations and since we have a sequence of blocks the blockchain a blockchain is basically a very long sequence of operations split into blocks that are generated every 15 seconds and the state of the blockchain is the result of the execution of all the operations for example let's say that after the block number 1427 Bob's account has a balance of a th000 t if in Block 1428 Alice adds the transaction Alice transfers 100 T to Bob and this transaction is validated then in the state of the tizel blockchain after block 1428 Bob's balance will be 1100 T in the blog we have two parts we have the header that that contains the block number or the level basically how many blocks we have since the beginning of the blockchain then we have the hash of the previous block a timestamp and we also have the hash of all of the data in the block and the data consists in the list of all the operations of the Block in a certain order the fact that we store the hash of the previous block means that we are creating a chain of block each block references the previous Block in the chain that's why we call it the blockchain and you can check what a block looks like at this address that uses a block Explorer to analyze the block that has this number this level so here we can see this block we can even move to the next block or the previous block we can see the Tim stamp Etc and most of all we can see all the operations in that block so different transactions and in particular smart contract calls to interact with the blockchain we will use a wallet it's a piece of software or Hardware device that keeps your private Keys safe we saw earlier that transactions need to be signed so to sign your transaction you will need your private key that you will sign using your wallet so whenever you want to transfer some TZ or call a smart contract you will need to create a transaction and then sign it with your wallet the wallet doesn't store your TZ or any other asset it only stores the key keys to control these assets if you ever lose your private Keys you basically lose all access to your assets so make sure you keep your private Keys really safe as an example if we have this transaction transfer 100 test from Alice to Bob this transaction has to be signed by Alice using her wallet for it to be valid on tsos we have a number of wallets that you can use for example Temple kukai Umami and more under the hood the tesos network consists of hundreds of nodes run by the community each node is a computer that runs the tesos protocol and communicates with other nodes together these nodes form a peertopeer decentralized Network that we call the gossip Network these nodes share the responsibility of maintaining the blockchain and all the operations and blocks are propagated through this network of nodes and when your wallet interacts with a blockchain in practice is communicates with one of the nodes in this network all of the nodes execute every single transaction in every block and store the associated mate data update the state but only one entity can create the next block and decide which operations to include but as we want to keep tesos decentralized the responsibility of creating the next block has to be shared so the hard part of the design of a blockchain is to decide who gets to create this next block and do it in a fair way and then making sure that this block is valid and legitimate on tesos the entities that create new blocks are called Bakers anyone as long as they have at least 6,000 T at the moment can volunteer to be a baker and the baker for each block is randomly selected to make it fair the chance to be selected is proportional to the amount they staged that's what we call proof of stake and proof of stake is ecofriendly because we just need to pick randomly proportionally to some value this cost a lot less energy than proof of work where you need to do a lot of computations to determine who the next minor will be for example as it's done on Bitcoin in proof of work the chance of selection is actually proportional to how much energy and computational resources you waste when a new block is proposed by a baker it has to be validated so we have to check that it includes the correct hashes of the pre block and its own that all operations have a valid signature that the execution of transactions don't fail due to some limits or errors that the maximum size of a block is not exceeded Etc a block is officially added to the chain once it receives enough attestations from other Bakers the baker of a block is rewarded they receive 10 new T and and sometimes a bonus they also receive the fees of all the transactions in the block each transaction comes with some fees that the user can change a kind of a tip that is transferred to the Baker and to maximize their gains Bakers select among all of the transactions the most profitable ones so the ones that have the highest fees compared to their execution time if you're not a baker you can delegate your test to a baker and get a share of the rewards that the baker gets and there's also some test that I use as rewards for the bakers that attest the validity of the blocks if a baker propagates fake data in particular if a baker creates two blocks instead of one when it's their turn they lose some of their stake we say that their stake is slashed but if you delicated your test to a baker you have no risk of being slashed you cannot be punished so this was a key overview of the different elements of tzel we talked about accounts that can be either user accounts or smart contract accounts we described what transactions are our transfer of Tes or calls to Smart contracts we described what a smart contract is a special type of account with not only a balance but also storage and some code that can be executed we describe the blockchain as a sequence of operations grouped in into blocks we talked about interacting with the blockchain through a wallet that keeps your private Keys safe and is used to sign all the transactions you want to send to the blockchain we describe the blockchain itself as a peertopeer network of nodes that each execute the tesos protocol and execute every single transaction in the blocks they receive and finally we talked about bakers that share the responsibility of creating new blocks in this video you will learn how to set up your own Wallet create your private keys and then with that you will then be able to get some test create and sign transactions call Smart contracts Etc so using a wallet means creating an account and the first step to create an account is to generate a pair of keys most importantly you will generate your private key that is what you will use to digitally signed all of your transactions and prove your identity a private key has a corresponding public key that you make available to everyone so that they can verify your signatures and verify your identity so you sign your transactions with your private key and other people or software can verify that the transactions are signed by you by matching the signature with your public key so a wallet can generate a private key as a random sequence of bytes if it's extremely important that you never lose your private key but as a sequence of bites is hard to write down or remember the wallet will first generate a seed phrase It's a sequence of random English words that represent a random value but that are easy for you to write down and keep safely for example on a piece of paper then the wallet uses this sequence as a seed for the random generator to produce the private key it then stores this private key local encrypt it using a password of your choice and will'll then use it to sign your transactions on tles there are a number of different wallets available some of the main ones include Kai Umami temple in this presentation we'll be using the kai wallet it is available on kai. apppp but for our test we'll be using the ghostnet test Network so we will be using ghost net. kai. so the Tes will will manipulate with this wallet will be fake TZ in a sense not TZ from the main Network so if you go to ghost net. ci. apppp this is what you will see as the wallet will be directly in your browser you have two ways to create a wallet you can collect with one of several social networks for example Google Facebook Reddit Etc in which case it will use your o o cred credentials as a way to safeguard your keys that's the easiest way to do it if you simply connect for example click continue with Google your wallet will be instantly created and available we will use a way that is slightly longer you click on create new wallet here and then it will generate this seat phrase composed of a sequence of English word and the idea here is that you should write down these words on a piece of paper to keep them safe I avoid storing them in a file because this file could be accessed if anyone ever gets access to your computer so it's safer to Simply use a piece of paper and keep that piece of paper safe and make maybe copies of it that you keep safely because if you ever lose them then you're at risk of completely losing access to your private key therefore to your assets once you have written down these words you can click next and then it will check did you indeed save these words and it will tell you okay did you write down the second work the one that was between traffic and sustain and so on our piece of paper we see yes indeed we had the word Arrow then it asks what's the third word one that was between arrow and midnight and so that was sustain Etc then we have pause and we're done so it checked that we really did store or passphrase then it asks you to provide a password so that they can store an encrypted version of your key store file so that's a password that you remember so that your wallet can locally save your private key and public keyan Etc and then decrypt it anytime you provide your password so whenever you will need to sign a transaction it will use your password to decrypt the key and then sign the transaction with the key so you input a password confirm your password and then click next then your wallet is ready and you have here your public account address so that starts with tz1 and then something's based on the hash of your public key you can also download the encrypted key store file so that you can import it into this wallet or another wallet and it will be as safe as the password you pick to encrypt it so here you copy your public account address we download our file and then we can now open our wallet in the wallet we can see the balance of our account we can see our address here and of course we have no activity because we just created the account for real wallet on the main net you could get TZ using one of several providers and for example convert from dollars or euros and buy some Tes and then have them into your account through coinbase or other places for a test account on ghostnet there's an easier way to get some test you go to this website that we call a faucet and from this website you will be able to request some test so let's give it a try so this is a tesos costet foret that is a website that can give free fake Tes on a ghostnet account you can paste your address here and then select how many Tes you would like let's say A th000 tes and then you can request you need to wait a bit the more test you request the longer the competition will be because the challenge needs to be solved some proof of work and if you request a th000 t it can take a while so we'll maybe request a bit less let's say we only need 200 T and after a couple minutes all the proof of cor challenges are solved and then 200 T are transferred to our account another way would have been to connect our wallet to automatically obtain the tz1 address but that would be the same result then we can check on the Block explorer that indeed our tz1 address has 200 T we can also go back to our wallet and we can see here that the 200 Tes are there after reling the page and we can see that we received them from this address it may take a little bit of time before we see it because we need a couple blocks to be validated but eventually we see the 200 test there from this you can already sign some transactions for example if you want to try to send a few test back to the facet we can take this address that's the address that sent us some test and you can send some Tes let's say two Tes to the address which just copied then we can preview the transaction we can see that there's a fee of 369 micr Tes and we can use our password to decrit our private key and sign a transaction and send it to the blockchain so we confirm and we can now see this transaction has been confirmed and we now have almost 198 T again you can see the same thing in the block chain Explorer and we see this transaction where we send two Tes to this address and that's said your wallet is set up in this module I will give you an overview of the tesos layer one architecture and we will do that by following the path of a transaction from the moment it is created to the moment it is integrated forever in the tesos blockchain imagine you want to buy an nft a unique digital artwork on tesos The Cutting Edge blockchain platform you use adap a decentralized application that lets you browse and bid for nfts when you find the one you love you click on the buy button but what happens next how does your transaction get processed and recorded on the blockchain let's take a look behind the scenes tesos is powered by a network of nodes computers that run the tesos software and communicate with each other through a peertopeer Network these modes are operated by the tesos community a diverse and Global Group of enthusiasts developers and organizations your transaction will travel through this network undergo various checks and validations and eventually be included in a block by a baker a special node that creates new blocks once your block is added to the tsos blockchain your transaction is final and irreversible but how does this work exactly the T you use an nft Marketplace has a user interface a web page that you can access from your browser it lets you interact with the blockchain and the smart contract the programs that run on blockchain and Define the rules and logic of the nft marketplace when you click on the buy button the DB creates a transaction a message that tells the smart contract to transfer the nft to you and the TZ the native cryptocurrency of tezos to the seller the transaction is sent to your wallet a piece of software or a Hardware device that connects to your browser and the blockchain your wallet securely stores your private Keys the secret codes that prove your identity and ownership of your T and nfts your wallet is your gateway to the blockchain and the protector of your assets before asking you to confirm the transaction the wallet needs to test it check that it's valid and figure out how much it will cost you to do that it sends the transaction to one of the nodes of the network and asks this node to simulate what would happen if you sent it for real this node has a copy of the blockchain the history of all the transactions that have ever happened on tesos it also has the context the current state of the blockchain which includes the balance of every account and the code and data of every smart contract the node simulates your transaction by running the code of the corresponding smart contract it checks that the code doesn't cause errors for example that the nft you want to buy is indeed for sale at the price you indicate and that you have enough Tes on your account to pay for it it then computes the amount of resources running this code will consume on one side the amount of gas an estimation of how much Computing time your transaction requires on the other side the amount of storage how much extra data will need to be stored the node computes the cost for this gas and storage adds some fees then calculates how much you will need to spend to get a baker to add your transaction to a block all the this information like a quote for your order is sent back to the wallet the wallet then displays that information for you to check and lets you decide how much extra fee you want to add this extra fee is like a tip you pay to the baker to increase the chances that a baker will pick your transaction and add it to the blockchain once you check everything and agree to sign the transaction the wallet uses your secret private key to digitally sign your transaction using cryptography then sends it to a node from then on all you can do is wait and see if your transaction gets added to the chain the node sends a hash of the operation back to the wallet so that the wallet can keep track of it and ask for updates on its status before sharing your transaction with the whole network the node needs to check that it's legitimate to protect against attx that would saturate the network it checks that the signature is valid that the fees are not too low and that you have enough Tes on your account to pay for everything the node then stores your transaction in its M Pool a memory space that stores all the transactions that are waiting to get included in a block the mol also stores other types of operations that the nodes has received such as block attestations or votes for amendments to the protocol the Noe also sends your transaction to its neighbors which in turn check that your transaction is legitimate add it to their own M Pools and send it to their neighbors propagating it through the whole network every node needs to do these checks itself to make sure some bad nodes don't propagate malicious transactions while all this takes place one lucky Baker is getting ready to take charge of creating the next block it is lucky because it has randomly being assigned the first pot in the list of bakers that are responsible for making sure a block is created the next Baker in that list will wait a little longer ready to take over in case the first Baker doesn't do its job in time this time our first Baker is up and running and is ready to do its job and get rewarded for it it is carefully listening to all the transactions that arrive in the men poool of its node when it's time to create the block it sorts these transactions to decide which ones will end up in this block before it selects transactions it needs to pick the other types of operations such as attestations of the previous blocks or votes the baker is trying to make money by collecting all the fees so it selects transactions that have the highest fees compared to their cost in gas and storage but before adding them to the new block it does its own checks to make sure they are valid especially when they are executed in that specific order it adds the good ones to a new block until it's full or it runs out of transactions it wants to include it then executes all the transactions by applying them to the context produced by the produ block the storage of contracts and balances of accounts are updated in the context after each transaction as the validity of the next transactions depend on them once the block is full the baker comput is hash and sends the block with all its transactions to its node the node sends it to its neighbors and the block propagates through the network the node adds this block to the end of its copy of the blockchain in an unconfirmed state for now it also executes all the transactions and updates its own context other nodes do exactly the same as they receive the block a subset of the Bakers have been randomly selected to form a consensus committee for this block when the node that one of these Bakers is attached to receives the block this Baker starts checking all the operations it contains to make sure everything is valid if it's all good it creates a pre attestation message along with a hash of the block and sends it to the node other Bakers from the consensus committee do the same and create their own pre attestation these are propagated through the whole network the same Bakers then start receiving all these prorations check them and count them once enough are received a quorum is reached and the baker considers that this block is attested we creates an attestation message and send it to its node nodes propagate them and add them to their me pool as these attestations will be added to the next block while all this is happening your wallet is still checking with with its node what the status of your transaction is when the block that contains your transaction reaches this node the wallet will update the status of the transaction and show it to you when another block arrives and is added at the end of the chain after the block that contains your transaction this new block contains attestations for that previous one having another block added in front of it brings it closer to a final State once a second block arrives and is added to the chain then your block is definitely final you can now be 100% sure that your transaction is permanently part of the tizel blockchain the wallet shows that the transaction is final tells the DB about it and the DB confirms to you that you now own this amazing nft congratulations you have just experienced the power and beauty of tesos in this module we'll talk about some of the reasons why it's a good idea to develop your DS on tesos there are many benefits that come with developing on tesos one of the key benefits of tesos is the unchain automated governance anyone who holds 6,000 TZ or more can vote for protocol amendments proposal there's already been 14 successful upgrades of the protocol since the beginning of tesos this onchain government makes tesos very Innovative with frequent new capabilities that are added to the network and the system reduces the need for hard work there's always a single official branch of the network another benefit of tesos is that it's energy efficient thanks to its use of proof of stake it was one of the first blockchains that uses proof of stake as part of its consensus mechanism tesos is focused on scaling with a lot of work going on right now scaling with smart rollups data availability layer and more and that is done without compromising decentralization or security a lot of work has been done to make sure that the security of tesos is of top quality and the tesos ecosystem itself is very decentralized and benefits from a friendly and diverse community that focuses on longterm Innovation and it has a great ecosystem from blockchain Enthusiast artists but also multinational companies it also benefits from great tooling and funding opportunities to help developers build their projects in 2017 a large amount was raised to fund the development of the tesos Network and this amount is managed by the tesos foundation the mission of the tesos foundation is to grow the tesos ecosystem through a system of grants in areas such as developer experience Education and Training security and privacy and and re users application for more information about how to apply for Grants and what the foundation does visit tesos foundation in this module you will learn how to write your first smart contract on tesos using smart pie it will be a very basic smart contract but a useful one what is a smart contract it's a type of account that like any account on tesos has an address and has a balance in TZ but on top of that it will have some executable code the program of the smart contract that says what it can do and it will have its own storage some data that the smart contract can store to interact with the smart contract we will use used two new types of transactions the first one consists in deploying the smart contract it means putting it out on the blockchain once it deployed its code cannot be changed we say that it is immutable the second type of transaction is to call a smart contract you call it like a function with some parameters that you pass and you may send to the contract as you call it now let's look at our first smart contract this is the smallest useful smart contract we can think of all it does is to store value on the blockchain forever or at least as long as the blockchain exists so here we will store this value in the blockchain forever when we deploy the smart contract and that's all it does we can see that to create a smart contract we have to create a class we give it a name and we said that it inherits from sp. contract here SP stands for smart p and that's the name we gave to the smart by Library when we imported we need to create this class inside a module that we call Main like this and inside the class we create a Constructor that is named in it with two underscores before and after and within this Constructor we can initialize the storage with an attribute that we decide to call value and the attributes are stored in self. data Dot and the name of the attribute so here the contract doesn't execute anything on blockchain WE simply Define its initial value of the storage that will be stored forever once it's deployed it won't be doing anything else if we want to test the smart contract in the smart P IDE we will need to add tests and you always want to add test to any contract you write and in smart P you can add them in the same file as the contract itself here we create a test by adding this test function with the ad test decorator and within this test we create a scenario that basically will contain the sequence of tests calls to Smart contract Etc we give it a name by calling the function test scenario and we declare what module it uses so here it will be using the main module then we create an instance of our store value contract like this we store it in a variable and then we add it to the scenario when we run the test it will simulate deploying the smart contract and show us the output one thing you should keep in mind especially if you're not a python developer is that every time in your code that you create a block the content of this block should be indented compared to the parent so for example here we have a class and inside the class we create a block that's the content of the class all the content of this block should be indented here it's indented by four spaces it could be more it could be tabulations but it has to be the same number for the whole block and then here we can see that inside the Constructor we create another block with a content of the Constructor and again it is indented by four spaces as soon as we reduce the number of indentation so for example here when we have this decorator it indicates that we Clos the previous opened block so here we close this block we also close this one and close this one let's test our contract inside the smart P IDE in this online IDE you can write your contract and an editor and then on the side panel you will be able to test it and see the output so here I put our original smart contract we see that if I just run it nothing happens because I needed a test for anything to happen so I'll add our test now I can run it and I can see that on the side panel I have this origination that is simulated and I Can See For example the address of my contract and I can see the storage value so here we can see that originated a contract that has this value and will store it in the blockchain we can check a few things for example we can see what the code of the smart contract in melon looks like it doesn't really do anything we can also check the content of the storage or the size of the storage Etc we could even deploy the contract directly from the smart by ID now it's your turn write your first smart contract you can name it store value it should store the value 42 and of course you need to add a test scenario and run it to simulate the deployment of this contract once you're done validate it on open Tel let's pause the video and give it a try before we continue so far our smart contract wasn't really doing anything except storing a value if we want the smart contract to do something we need to add entry points they are like methods or functions that we can add to our smart contract when you call an entry point they cannot do much they can only read the parameters that you pass to the function the current value of the storage of the smart contract a few special values like the balance of the contract or the amount that the color sent to the contract or the address of that color and a few more it will also have access to a global table of constants that all smart contracts have access to it also cannot do much it can only have two effects the first one is to modify the content of its own storage and the second one is to generate new transactions such as transfer t or CS to other smart contracts that will be executed at the end of the execution of the entry point itself and that's it now let's see how we can add an entry point to a Smart contract so we here created a contract called flipcoin that will store the curent ins side of a coin and then we will have a flip entry point that can be used to switch this side from 0o to one and then from 1 to zero Etc we can see here how we created an enter point we created a function with a s sp. entry point decorator and then inside that function well we change the value of the side attribute of our storage to one minus this value so if you start with zero you get 1 0 equal 1 and then if you call it again it goes back to 1 1 = 0 Etc every time you call it it will flip the value of the coin to add test to our entry point we can simply add calls to this entry point in our test function so after we added the contract to the scenario we can call contract. Flip so that's the name of our Tre Point as many time as we like let's give it a try in the smartp IDE so here we have our contract and N test let's run it we can see again the origination with the initial value of side set to zero and then we have here our first call to our flip entry point and if we click on show details we can see that the new value of the storage is now one then we have the second call and here we can see that the value is zero and then one again Etc now the issue with this is that if we make a change to this contract we don't want to have to check again and click on show details Etc to see that all the value of the storage are still correct we would like to automate this and have Smart P tell us immediately if what we get is what we expected we can do that by automating those tests so to check the outcome automatically all we have to do is add this to our scenario after or before a call to an entry point scenario. verify and then some conditions so here for example we can check that the value of this field from the storage of our contract is equal to a specific value let's give it a try here after flip we can write scenario dot verify construct. data. side equals so after the first flip it should be equal to one then I can add it here should be equals to zero again and then to one again let's give it a try all good we get the same output if we had here written one then smart P would tell us hey this comparision is incorrect as an error so of course here that's just because the test is invalid but we put zero and then we run it and then we can make some changes and make sure that we never break this condition now it's your turn write your own smart contract call it count the calls and the goal of the smart contract is to count how many times we will call it so we will have a attribute NB calls in the storage that you initialize with zero and then every time we call the contract it should increment by one so to do so you will create an entry point make call and then increment by one the value of NB calls and then of course add a test scenario and run it let's give it a try and when you're done you can validate it on open tizel so please pause the video and give it a try let's take a look at the solution we created a class come the calls that inates from sp. contract we have a Constructor that initializes the value NB calls to zero then we create an entry point make call and every time we call it NB calls will be incremented by one you could also write NB call equals and equals + one but this is a shorthand operator that makes it easier to increment in our test we instant shed the cond the calls contract in the contract variable we can verify immediately that the value is zero we can use H2 to display a title that says what we're going to do next we call the entry point make call verify that the value is one then call it again verify that the value is two let's check if it works and it's all good we start with zero then we make the first call it's now one second call is not two everything is good and again I had change it to three it would let me know that this condition is invalid testing a smart contract is really important smart contracts manipulate tokens and other digital assets that can have very large economic values we can talk about millions of dollars in some cases or tens of millions of dollars in a single smart contract and the environment where you execute the code is what we call adversarial that means other people can attack it anyone in the world could look at your contract try to find a bug and if there's a bug someone will try to attack it and try to either steal some funds in it or make them stuck in the contract and people have very strong incentive to exploit bugs that you may leave in the contract and since once you deploy the contract it cannot be changed anymore it's immutable then bugs cannot be fixed as soon as you see them so that makes it even more dangerous there are unfortunately many examples of cases where people lost millions of dollars collectively as a consequence of small bugs in smart contract so it's very important when you write a smart contract to spend a lot of time testing it proofreading it Etc in general it's actually relatively simple to write a smart contract smart contracts are small projects compared to to other types of software projects but it's actually quite hard to make sure there are no bugs in those smart contracts so testing them and avoiding bugs is the hardest part in later modules we will study different flaws and best practice on how to avoid typical kinds of bugs in this module you will learn how to add entry points to your smart contracts so that you can create contracts that do something so far our smart contract wasn't really doing anything except storing a value if we want the smart contract to do something we need to add entry points they are like methods or functions that we can add to our smart contract when you call an entry point they cannot do much they can only read the parameters that you pass to the function the current value of the storage of the smart contract a few special values like the balance of the contract or the amount that the caller sent to the contract or the address of that color and a few more it will also have access to a global table of constants that all smart contracts have access to it also cannot do much it can only have two effects the first one is to modify the content of its own storage and the second one is to generate new transactions such as transfer t or calls to other smart contracts that will be executed at the end of the execution of the entry point itself and that's it now let's see how we can add an entry point to a Smart contract so we here created a contract called flipcoin that will store the current side of a coin and then we will have a flip entry point that can be used to switch this side from 0er to one and then from one to zero Etc we can see here how we created an entry point we created a function with a sp. entrypoint decorator and then inside that function well we change the value of the side attribute of our our storage to one minus this value so if you start with zero you get 1 0 = 1 and then if you call it again it goes back to 1 1al 0 Etc every time you call it it will flip the value of the coin to add test to our entry point we can simply add calls to this entry point in our test function so after we added the contract to the scenario we can call contract. Flip so that's the name of our Treo as many time as we like let's give it a try in the smart P IDE so here we have our contract and N test let's run it we can see again the origination with the initial value of side set to zero and then we have here our first call to our flip entry point and if we click on show details we can see that the new value of the storage is now one then we have the second call and here we can see that the value is zero and then one again Etc now the issue with this is that if we make a change to this contract we don't want to have to check again and click on show details Etc to see that all the value of the storage are still correct we would like to automate this and have Smart P tell us immediately if what we get is what we expected we can do that by automating those tests so to check the outcome automatically all we have to do is add this to our scenario after or before a call to an entry point scenario. verify and then some conditions so here for example we can check that the value of this field from the storage of our contract is equal to a specific value let's give it a try here after flip we can write scenario dot verify construct. dat. side equals so after the first flip it should be equal to one then I can add it here it should be equals to zero again and then to one again let's give it a try all good we get the same output if we had here written one then smart P would tell us hey this uh comparison is incorrect as an error so of course here that's just because the test is invalid but we put zero and then we run it and then we can make some changes and make sure that we never break these conditions now it's your turn write your own smart contract call it count the calls and the goal of the smart contract is to count how many times we will call it so we will have a attribute NB calls in the storage that you initialize with zero and then every time we call the contract it should increment by one so to do so you will create an entry point make call and then increment by one the value of n calls and then of course add a test scenario and run it let's give it a try and when you're done you can validate it on open tsos so please pause the video and give it a try let's take a look at the solution we created a class come the calls and inates from sp. contract we have a Constructor that initializes the value NB calls to zero then we create an entry point make call and every time we call it and me call call will be incremented by one you could also write NB call equals n + one but this is a shorthand operator that makes it easier to increment in our test we instantiate the cond the Call's contract in the contract variable we can verify immediately that the value is zero we can use H2 to display a title that says what we're going to do next we call the entry point make call verify that the value is one then call it again verify that the value is two let's check if it works and it's all good we start with zero then we make the first call is now one second call is now two everything is good and again I had change it to three it would let me know that this condition is invalid testing a smart contract is really important smart contracts manipulate tokens and other digital assets that can have very large economic values we can talk about millions of dollars in some cases but tens of millions of dollars in a single smart contract and the environment where you execute the code is what we call adversarial that means other people can attack it anyone in the world could look at your contract try to find a bug and if there's a bug someone will try to attack it and try to either steal some funds in it or make them stuck in the contract and people have very strong incentive to exploit bugs that you may leave in the contract and since once you deploy the contract it cannot be changed anymore it's immutable then bugs cannot be fixed as soon as you see them so that makes it even more dangerous there are unfortunately many examples of cases where people lost millions of dollars collectively as a consequence of small bugs in smart contracts so it's very important when you write a smart contract to spend a lot of time testing it proof reading it Etc in general it's actually relatively simple to write a smart contract smart contracts are small projects compared to other types of software projects but it's actually quite hard to make sure there are no bugs in those smart contracts so testing them and avoiding bugs is the hardest part in later modules we will study different flaws and best practice on how to avoid typical kinds of bugs in this module you will learn how to deploy your contracts so that they are available on the chain for everyone to use well will deploy our contracts on a test Network so that you don't need to spend any test to do the deployment but the same approach will work on the main Network so the test network is called ghost net and it is very similar to the main Network so to originate or we can say deploy your contract you need to do two steps the first step is to produce the makerson contract so compile your smart pie contract into melon melson is the lowlevel language of every tesos smart contract and smart py is a highlevel language that makes contract easier to write but when you run smart py you compile the smart P code into mikelson so you generate the mikelson contract so that's the first step before you can deploy your contract and the Second Step will be to create and sign a transaction to deploy that contract the smart py IDE will help you prepare the transaction and we will be able to use our wallet to sign this transaction and then we'll send to ghost net this operation is what we call the origination of the contract so we start from the IDE with our contract and to deploy it we first need to run the code and on the right side in the top part we have the origination and here we can view the mikon version of the contract and then you can see at the bottom right deploy contract button so let's click on that and here it will prepare everything everything you need to originate your contract so here we'll select what network we use we can use ghost net or main net here you can provide the address of the node that you will be using to deploy the contract so for example by default it's the smartp node but I could use a node from another infrastructure then I can select my account and here I have a choice of a number of wallets if I wanted to use my Kai wallet I could select Bon and then Kai but smartp also offers its own system to manage accounts so here you can create accounts and here have created a couple so let's just use this one so we can see that this account has almost 100 t in it and it's revealed already on ghost net so I simply validate that account here I can provide any origination parameters I can say how many Tes I put in the contract as I deploy it and I can also set a delegate to indicate if I have test in the contract which Baker should I be delegated to then I have the estimates of the deployment cost that I obtain from RPC so that's contacting the node doing our RPC remote procedure call to the node I can check and it tells me okay this is how much the node expects that it will cost to deploy it so it's very cheap to deploy this tiny contract this is how much gas I will spend how much storage I will spend Etc and then I can simply click deploy contract it shows me all the information about the contract I'm going to deploy so it shows me the hash of the transaction the parameter so what account I use to originate it what's the counter what's the fee I'm going to be paying the gas limit the storage limit Etc and the balance initial balance for my contract in the full version I also have the full code of the contract in meason plus the initial value of the storage and then I can see the by encoded version of that so once I'm sure that this is the transaction I want to run I can accept it and then it contacts node originates the account and I have the address here if I copy this address and go to for example better call Dev I can search that contract and I can see here that better called Dev sees my contract on ghostnet and we can see that the operation was done just now here it says a few seconds ago so my contract is deployed I can check the contract on ghost net see the current value of the storage see the melson code and I can even interact with it directly from ghostnet so now that we have deployed it our contract and the associated data are now public so as we could see through better called Dev anyone can read the code and the storage without asking for permission the contract is immutable it can never be changed and it's Eternal so as long as a few nodes are running the tesos blockchain my contract will be available for anyone to use this is because tesos is run by hundreds of independent nodes that each maintain a copy of my contract and its data and changes to the contract may only be made if a super majority of participants with agreed to make changes which is something that doesn't actually happen people don't really change contracts when they have been deployed we will see later that we can integrate features in a contract to enable upgradability features of our contract and so due to this decentralized structure of the blockchain no single entity can cause my contract to fail and the network as a whole to fail so my contract is pretty much available for anyone to use forever and we'll keep counting how many times people call it I could try directly from baral Dev execute and directly using my wallet here it's sending to my Kai wallet so here it says I'm waiting for confirmation my Kai wallet is here so I just need to accept the transaction and I go back CA successfully submitted the operation transaction has been successful and now I if I see the storage I can see well this contract has been called once I can try it again execute confirm successfully executed I see this storage not updated yet and that's it now it's two so my contract is available forever and you could call it to using this address in this module you will learn that every value variable or parent parameter in smart Pi has a type but most of the time you won't need to tell smart Pi what the type of your variables are thanks to a very powerful tool called type inference but first let's talk about parameters we have already presented entry points since an entry point is a kind of method of your smart contract they can take parameters if you want to write an entry point with one parameter here is how you do it so when you define your entry point next to self you add a comma and the name of your parameter and then within the code of your entry point you can simply use the name of your parameter wherever you want to use this value in your test when you want to call an entry point with a parameter if it's a single parameter all you have to do is put the value of this parameter between the parenthesis when you call the entry point of your contract let's take a look at an example here we modified our store value contract by adding two entry points one entry point with a parameter called added value that we can call to add this value pass as a parameter to the stored value and then we can compare it to another entry point that doesn't have any parameter reset that simply resets the value to zero and then in our test scenario here here we call contract. add with a parameter five saying that we want to add five to the initial value 42 and then after the call we can verify that the new value of stored value is 47 and then to really make sure that the entry point works well if we call it several times we have a second test where we this time add two and then we verify that the result is 49 let's give it a try so we can see that it was successful we start with the origination with the value 42 then we call our entry point we see that the argument so the value passed for the parameter added value was five and then if you look at the detail we can see that the new stored value is changed to 47 and then we have another call with the argument two and the new stored value is 49 in smart Pi everything has a type whether it's a value or for a variable that always has the same type and can only contain values of the same type and the same with the parameter all of them have to have a type so far we have manipulated whole numbers but just for whole numbers we actually have two different types available the first one is int for integer and a value of type hint can hold a whole number that can be either positive or negative but there is a second type for whole number called nut for natural natural numbers that can also hold a whole number but this time only non negative values so values starting at 0 1 2 3 Etc but not negative values when we want to use the whole numbers if we want to specify which one of those two we want we can either write sp. in of five for the integer five or sp. not of five for the natural five so those are two values of different types whenever we want to express the type itself in smart pile we will simply use sp. in and sp. notot in short when I talk about it I will just say int and net in smart Pi you cannot directly combine nut and int so for example if you have a variable of type int you can add assign a nut to it and vice versa so if we take this example of a contract that has a value where we assign a type int and then has an increment variable to which we assigned three then we cannot have an entry point that adds those two together because they are of different types but we can convert a nut into an INT for example using sp. 2 in of the value so if this value is an N we can con convert it to an integer with this function most of the time if you feel like you need to convert a value from one type to another it may be because you chose the wrong type to begin with so most of the time if you feel the need to convert try to think first if there's a way you can change the initial type of the variable rather than converting it to another type if every variable has a type you may wonder why we never had to to provide the type so far and the idea is that smartp uses a very powerful tool called type inference to automatically determine the types of many variables and parameters if you don't specify it it can deduce it from other Clues and there's a number of information that you can use for that the main one is the initial value you assign to the storage so for example if you have a variable in your storage and you say I sign it to sp. int of five then smart P can deduce that the variable is of type int if you combine operation in an operation for example if you add two values and one of them is of type nut then that means the other one and the results both have to be of type net and sometimes you can provide explicit information about the type of a value so for example if we have a parameter factor and we want to say we know and we want this parameter to be up type int then we can use sp. cast of factor and the type that we want to assign to this parameter not that this is not converting the type of this variable whatever value it contains to an NT it is simply saying that the type of this parameter or variable is an INT and should always be an INT it uses those information that it finds here and there in your contract and it propagates it to the rest of the contract whenever it can one thing that you should know is that sometimes smart P cannot determine if a value is of type int or of type not so it temporarily propagates a value that has an intermediate type int or not and then only at the end it will determine which one of the two it is and sometimes you may see error messages that tell you that it's expecting into not it's because so far it doesn't know yet if a variable containing a number will be of type int or of Type n so it is propagating this intermediate type but eventually it will have to pick between it and N if we look at our smart contract as an example here we saw that we didn't provide any type information and that means when I look at the type of the storage here we can see that the stored value is of type int or not because it doesn't know if this 42 is an INT or or not same thing with this parameter or this value it could be both but eventually since it has to pick when we look at the melson code we see that it picked an INT so if there's choice between in and nut at the end it will pick an INT but we could force it to be a nut by here initializing the value with sp. nut of 42 so type inference will be used to deduce that the type of this variable is net here since we add the value of this parameter to the stored value this means this parameter is also an out and here since we assign another value to store value then it knows that zero should be actually sp. nut of zero so here if we run it we can see that store value is now S as a n and then melon contract we see that we have nut everywhere as well the type inference could be used starting from any point so for example could use the reset entry point to say hey this zero is a nut and the result would be the same because it will deduce from this that stored value is a nut therefore 42 is a nut therefore the parameter added value is a nut so from this single information that this value is a nut it will propagate it to stored value then to added value then to other places like for example the value 42 it knows that it is n this is what we call type inference using a set of Clues to determine for sure what the type of each value is let's look at a different version of this contract that I prepared for an exercise here we have this add entry point and we say that we don't want to allow negative numbers to be added to the value and the reason is that we also have a sub entry point that substract a given value from the stored value and so since we have this entry point let's say we don't want add to be able to be used to add negative value which would be the same as subtracting so it's just a rule that we set for the purpose of this exercise so for this reason as a way to say I don't want negative value I say that this parameter should be of type net so I use sp. cast to say added value is of type net let's see what happens when I run so here we have a type issue on line 18 it's telling us that it's trying to combine an INT and a nut and as we said we cannot combine those two types in the same operation for most operations so here we have an issue because it deduced that stored value is a n from adding an N to it here but it also deduces that stored value is an integer because well we subtracted a value to it therefore it could become negative therefore it can hold negative values and should be of type int so your goal for this exercise is to try to find a way to fix this mod contract and make it compile while keeping this constraint of having added value B of Type n you will find the content of this smart contract either in the git Repository associated with this course or in the type inference section on open tzel please pause the video and give it a try Okay so let's see how we can fix this here the issue is that when we add a nut to this value it will deduce that this value should be a nut but we want this value to be an INT because we want to be able to subtract values to it and we want it to be potentially negative so this has to be an INT but this has to be a nut but we cannot combine the two together so what we do is we convert this value to an INT by writing SP do 2 int of this value let's give it a try so I still have an error but a different one line 30 and again it says entry point expect parameter of type SP sp. unknown but it got int and it tells us that there is an int sln mismatch so the error message is not very clear on where the problem is but let's look at what we have on line 30 and we can see the content of this line here here we see that inest we called add but we passed an INT as a parameter so of course if we pass an INT as a parameter and then it tells us no this parameter should be of type nut then there's the discrepancy we cannot pass an in when it expects a n so all we have to do here is change this to nut let's give it a try and it works so now the type inference doesn't have any conflict it doesn't end up with a place where from one set of deductions it deduces that a value should be of a type in and then from another set of deductions it deduces that it should be a nut everything is coherent so it all works when particularity of tesos is that it cannot have bugs related to overflows so if you not familiar with overflows the idea is that in most languages values of different types have a minimum and a maximum value they can hold so for example in C++ if you use the type short you can only store values between those two numbers included if you use an operation that adds one for example to the maximum value that it can have it will loop back to the minimum negative value that you can have so from this number if you add one you go all the way back to the negative value 32,768 and this can cause very dangerous bugs right if you add a number to a value you expect it to increase you don't expect it to become a very negative value on tesos we cannot have this kind of bugs contrary to many blockchains and the reason is that on tesos most types don't have any limit there is no upper limit to the value that an in can hold hold and there is no negative limit to the value that an in can hold basically that means the value of an INT can be between minus infinity and plus infinity there's only one type the TZ that has a limit but in this case if there's an overflow if you try to add one to the maximum value for the type Tes you will trigger an error instead of getting an invalid result so you avoid very dangerous situations so you may wonder is there really no limit to values does it make any sense to talk about in being able to hold infinite values well of course not in practice the types of value you can hold in an INT are limited by the storage needed to hold these values so you may wonder how much storage is used by a value and we can say that it's roughly proportional to the number of digits so if you have a number with 100 digits it will use about 50 bytes of memory so it's about one bite for every two digits approximately so the next question will be to wonder if uh the limit is the amount of storage and there's no limit to how much you can put in a value how do we prevent abuse how do we prevent people from storing numbers with billions of digits for example and the idea is that users have to pay whenever they increase the size of the storage of a smart contract so when you uh deploy a smart contract or when you call a smart contract in some cases the result of that is that you will change the value in the storage of the contract and therefore you may increase the amount of storage needed to store these values so whenever that happens you have to pay for that storage so now we may wonder who gets paid if we pay who do we pay to and the answer is no one we actually burn those tests and that's because there's really no easy way to determine who should deserve that amount and in a way by burning the test we pay everyone in the community because if you burn test you destroy them you make them unavailable you reduce the total amount of test available for everyone so by doing that indirectly you increase the value of the Tes so it's basically value that is shared with a community when do you pay well when you call a smart contract you're doing through a transaction that you will need to sign with your wallet and your wallet will simulate the transaction compute how much extra storage will be needed due to your transaction calling smart contracts and increasing their storage and so compute how many bytes you may increase the storage and then uh lets you know basically how by how much how many Tes you may burn and you can specify the maximum amount of Tes that you are willing to burn for this transaction to happen and when the transaction happen the exact amount will be burned okay now let's work on an exercise so you will take the smart contract store value that we have used so far and add a multiply entry point to the contract this multiply entry point should take a parameter called factor that should have type int and the multiply entry point should multiply the value of the storage by this parameter and of course we ask for you to add the Cor corresonding test to your scenario so please pause the video and give it a try and you can validate your Solution on open Tel let's take a look at the solution here we added this entry point multiply that takes a factor parameter and we multiply stored value by this factor and then of course we call it in our scenario to verify let's give it a try and we can see see here that when we call multiply by 10 we started with the storage that was five multiply by 10 and we can see the result is indeed 50 in this module you will learn to manipulate text on tesos using the type string tesos supports a string type that you can use to manipulate text but it is limited to non accented characters so what you can use is the set of characters from the nonextended S key standard composed of 128 different possible characters when you want to express a string literal you write it between double quotes like this example so double quote your text and then double quote again and just like for INT and nut there is no limit to how long this text can be you can write a string as long as you like the only limitation is the storage and how much it costs to store this string on the blockchain the most common operation we can do on strings is to concate Different Strings so you can concate different elements like this using the plus operator so here we Show an example where we create a URL by conting this bit with this parameter with this text with this parameter let's directly try it on an exercise so you will create a contract that will illustrate the concept of Eternity and immutability of the blockchain so for that you create a smart contract called edness wall and the idea is that it will store a string that we will call Wall text and anyone will be able to call an entry point called write message that will take a message as a parameter and will add it to this text basically it's a very long string of text that anyone will be able to add to so people like to leave their name U maybe carve their name on a rock for tunity or on a tree for a long time Etc there often a need for people to leave a trace so this is a contract that will let people leave a trace forever without destroying the environment in any way so the right message entry point should add a comma to the text to worldex then a space and a message then the string forever so for example if you call write message of tesos it will add a comma space and then tesos forever to wall texts and so if we start with hello and then we call WR message then we end up with hello tesos forever and of course once you're done writing the contract you should create the corresponding test scenario and you can validate your contract on open tizel let's pause the video and give it a try okay let's look at this solution so we created this endless wall contract we initialize the storage with a wall text variable that takes the parameter initial text that sets the initial value we will initialize this value with hello in our test then we have this entry point write message it takes the message as a parameter and it adds to World text a comma and the space then the message then forever and we use the plus operator to concatenate them and then plus equal to add them to W text in our test again we initialize the contract with the initial text hello then we create our scenario we add the contract to the scenario we call write message a first time with Anna and Jack we then verify that everything went well and W text contains hello comma and I inject forever then we call it again with tesos as the message and we verify that what text contains hello and inject forever then Tes us forever let's give it a try so it works we see that at the origination the content is hello then after the first call with the argument and un Jack and the result is hello and unj forever and then with another call with the argument tsos the new storage is hello un inject forever comma tsos forever all good in this very short module we will talk a little bit about the history of smart contracts the concept itself of smart contract was first proposed in 1996 by Nick Zabo in the first blockchains you only have a few types of transactions but some of them could run very basic scripts but those scripts are very limited on purpose you couldn't do any Loops for example for security reasons ethereum was the first blockchain with support for smart contracts and it was launched in 2015 tesos was launched in 200 18 as a new smart contract blockchain that was built from scratch it focuses on the security of smart contracts along with unchain governance in a way the whole point of a smart contract is to say if you do that this will happen no matter what no one can stop it in this module you will learn how to write smart contract that do that through performing verifications the code of an entry point of have the same structure and should have the same structure first it checks that the call is allowed that you should be able to call at this time with this address with these parameters Etc then after checking that everything is good do stuff computations changing the content of the storage sending tests to people do all kinds of transactions and maybe check all the things to do the first part checking that things should be allowed we use the assert command and we give it the condition that should be checked so basically write assert then the condition so for example we could write assert this parameter should be lower than some Maximum value we can also provide an error message so that when the contract fails we know why it failed so we just write assert the condition comma and the string containing the error message if the assert fail so if the condition is not met everything that was done since the beginning of the transaction is cancelled it's just as if nothing had happened so if we take this example we assign the value for it to to some attribute of the storage and then we check assert that this value is lower than 10 so of course this assert will fail so that means if you put this in a smart contract the whole smart contract will fail and the value will never be set to 42 and this is no matter what the cause of the failure is so if you cause a failure of the contract because of a false condition of an asset or if you for example try to send more test from the contract then the contract has in its balance or if you call another contract and this other contract ends up failing for similar reasons whatever the reason why the contract fails or one of the transactions it's try to do fails then everything this contract was doing is cancelled and it's as if nothing at all had happened so basically it's all or nothing either everything works or nothing happens when you do verifications you can use the regular python comparison operators so for example if we have a variable C that contains an integer four we can check if it's greater than three lower than three greater or equal than four equal to four are different from five let's look at this example where we take our store value contract and we have simply an add entry point that takes a parameter and adds it to the store value we don't specify any constraint it could be a positive negative value anything you like we can try it and we see that we start with zero if we add one we end up with one and then at nine we end up with 10 as we verify here now let's say we want to make sure whoever it calls it doesn't add more than 10 for example so we could have an assertion assert added value is lower than 10 say and otherwise we display message too much okay now if we run it again it just works because we only try to add one nine but now let's try to add 10 here we see that it fails and it displays the unexpected error too much we could also add an aerion that is a positive for example and again we can add minus 5 and then check and we will have the error needs to be positive we can also use Smart Pi's Boolean conditions so we introduce a type boan where value can be true or false and then we can create an Expression A and B that is true if and only if both A and B are true and then we can have the or operator that is true if either a or b or both are true and we can even use the exclusive or using the binary python operator um this side that means exclusive or that will be true if a is true or B is true but not both so exactly one of them has to be true for the whole expression to be true otherwise it's false and of course we have the not operator that text the opposite of the value of a so in our example instead of having two values we could just write here let's put this here the value is greater than zero and added value below 10 and let's say uh had a message not between Zer and let's say nine included so now if we write it we still have the error with the value minus 5 that is not between 0 and 9 and if we come in this ver this line and try with 10 then we have the same value for OD 10 then this message appears so the issue here is that we do want to check that this fails when we add 10 but if we do that then it just stops our test right if I want to check that both Min 5 and 10 return an error well when I run it it stops at minus5 so I don't know for sure that um adding 10 also causes an error so to help with that we can add code in the scenario that will check when something should be failed so we actually test that the failures work so basically when we test a smart contract we need to both check that the contract doesn't fail when it should succeed so by testing with valid parameters making sure that it works but we should also check that if we pass the wrong parameters or call it the wrong time Etc the smart contract actually fails it's very important to test it so to test that without having the whole scenario completely stop we can make a call to a Smart contract entry point by passing invalid parameters but then we say we know that this is invalid and that's what we want to check so to do that you add an extra parameter with underscore valid equals false to say I know that this is false and this should fail and I expect it to fail so when you run it if it actually succeeds you will get an error message if it fails then all good it's going to continue to the rest of your scenario and of course if you put true here it will be the other way around true will means I expect this to be valid so it should work but true it's a default value so you don't need to put it when you expect it to work and you can also check what message is output by the error so you can add underscore exception equals and then the exact string that should be produced when this entry point fails with this parameters so let's give it a try here my fire should fail so we can write valid equals false so now it will run minus F will work and we only have the add 10 that doesn't do what is expected so we change the expectation by adding valid equals false then everything works so now you can see here this transfer failed but this is expected so it doesn't cause an error so it's displayed in the output of smart Pi you even have the value of the expression here not between zero and five so you can still check everything but it is tested automatically in your scenario if we want to check the error message we can add exception equals not between 0 and 9 so let's say I do the wrong exception and it's going to tell me no that's not the exception I expected I expect 09 and you sent 08 and of course I can put the same right here for this call and everything works I don't have to use strings when I generate exceptions exceptions can actually be of any type so for example if I want to send two values I cannot easily build a string using Python's F strings F strings if you no pythons are not supported so I cannot concatenate a piece of string with a number that was a smart contract there's no easy way to convert a number into a strings for example so you can create a mixed message that has text and numbers but what you can do is generate an error that is not a string but for example that is a pair I can use this syntax I put two values between parentheses and with a comma between them that is a pair we'll talk about it later and so instead of returning just this string I return a pair that contains this string and then this value let's give it a try so here instead of putting not between zero and five I can create a pair and add added value comma not between Z and nine and then here if I run it of course it will tell me I was expecting the string but I got a pair conents minus 5 and not between 0 and 9 so here I just change it to 5 and then same here 10 okay so I can check here what the exact error was and including a value not it's your turn to give it a try I'm asking you to change the endless to contract to add verifications to it so the idea is to add verification so that people only add strings that have a length between three and three characters included this seems like a reasonable size for a message that will stay on the Chain forever and once you do that in your scenario please add test that make sure your contract does this very well you will need to get the length of a string so for that you can use this syntax sp. Len and then your string between parentheses and then you can validate the whole thing on open tiesos please pause the video and give it a try let's look at the solution so we still have our endless wall contract with the wall text that we initialize to this parameter and then in the right message entry point we add this line where we assert that the length of the message is lower or equal to 30 and the length of the message is greater or equal to three if not we simply produce the error in valid length if everything is good then we add the message and forever to the text in or test here we have to test both sides of each limit so here we have it limited 30 so 30 should be allowed but 31 should be rejected same here three should be allowed but two should be rejected so we test here with a message that contains 31 letters and we make sure it is failing then we test with two characters and we test that it is failing then we check that when the message is right above the limit so three characters should be the smallest text that works so we check that it works and same thing with this 30 character text we check that it works as well here would be good to check that the message is invalid length so let's add this exception equals invalid length and same here let's give it a try all good you can see here those two errors but it's just as expected Lo explorers like Bal Dev provide a user interface to explore contracts and accounts so we can find data about accounts their balance Etc find information about contracts what operations there have been on this contract was the current storage and you can even interact with the contract there's other kinds of explorers like TZ KT and TZ stats that have different types of features the contract that we just saw has already been deployed on ghostnet with this address so we can paste this address here and we will find this contract and we can explore so we can see that has been originated a long time ago and it's been used just a few times to call the right message entry point we can see the melon code we can see the current value of the storage so we can see a few messages and we can even interact with it so here I can interact with the default entry point so there's only one entry point called write message in this contract so the name is not kept it's just the default the only entry point and here I can put the value let's say smart pi and then I don't need any options I can simply execute it and I can use my wallet on ghostnet let's take Kai so it's asking me to confirm the transaction where I send zero TZ to this contract to call the default entry point so I confirm so the call was made it's confirmed I can go back to Bar Dev and I can check that a few seconds ago this right message was called I can check to see the details I can view the raw message you can see that the value of the parameter was smart pi and and I can see that it changes in added smart pie forever if I go back here and go to storage I can see smart P forever can see that each oper operation has a hash that I can use if I want to track this operation check that it's been added to the block and check that it's final before I do anything else so you can play around with baral Dev call this contract and see what happens now let's say we try to call it with an invalid value for example two characters let's give it a try I'll use my wallet then we can see here parameters invalid some of the parameters you provided are invalid and the request could not be completed please check your inputs and try again so we can see that I cannot call it with go and the same thing if I try to put let's say 31 characters can do it like that 10 20 31 execute using my wallet again it tells me parameters are invalid so if I go back to the operation I can see that this operation has never been run I don't have this new operation the last two that failed are not appearing I didn't pay for them the wallet just didn't let me run it because it simulated it realized this is not going to work don't even try don't even send it to the blockchain and so it was stopped before it was propagated and added to a block so to recap so far we have learned how to create our first smart contract we have learned how to create and deploy a smart contract to store a value in the contract using the types net int and string and we have learned to create one or more entry points each with a single parameter that checked the value of the parameter and then changed the value of the storage of the smart contract and finally we have learned to do test scenario that could check that everything was as EXP expected so far our smart contracts only stored one value and we only had entry points with one parameter it's pretty straightforward to add multiple parameters but there's a few important things to pay attention to if we want to put multiple values in the storage it's pretty basic we just need to have one line to assign a value to each value in the storage and we give them different names and we just have multiple parameters to the constructure so Min value will be stored in the minan value variable the storage and same thing with max value if we want to have multiple parameters for an entry point it's the same we just add another parameter with a comma behind the first parameter and we just give it another name and then we can use them for example to replace the values in the storage the part where you should be really careful is that when you call a smart contract entry point from your test scenario if the entry point has multiple parameters you need to name them so instead of just putting the two values separated by a comma I give the name of the first value equals the value I want to pass comma the name of the second parameter equals the value I want to the syntax doesn't work if I only have one parameter so if I only have one parameter I simply put the value if I add the name it it will not work the reason is that entry points actually only have one one parameter behind the scenes in the melon language so when we do this what we send is a single parameter in the form of a record so we create a record that contains those two values those two attributes and we send that record as the single parameter of the smart contract but we have a simplified syntax when we declare the entry point instead of saying we use a record that has multiple values Etc we just simply give the list of the attributes of the record and we will talk later about exactly how we use record but here records are used implicitly anyway all you have to remember is that when you call an entry point from a test scenario use the names if there's more than one parameter and don't put the name if there's only one parameter we can use an example we will change our store value contract to store a range of value with two numbers minan value and max value then we will have an true Point set that will change these values and we will also have an entry point add number that would add the same value to both the num minm and the maximum value of our wrench and of course we'll create a test scenario to check everything and again remember in a test scenario when we pass multiple parameters we have to name them let's look at our example so here we have our constructure and as parameters we have the two initial values that we want to set in the storage Min value and max value we want to set that those are integers using sp. cast of minan value s sp. in then we just assign them to the storage then we have an entry point set that takes again two parameters actually it's just one in the form of a record but we see them as two parameters new Min value and new max value we assign them to the two variables in the storage then we have ADD number where we have one value that we will add to both minan value and max value and we have a test where we create an instance with minan value equals zero max value equal to five then we call set again naming the parameters new minan value and new max value we verify that they have been set and here I can show that if instead of calling this I simply call this directly with the value then I get an error because it says entry point expects paramet of type of Nots but it got in or not and it says expected a record with two attributes new max value and new my value Etc but instead we got one number so that's because it's just checking the first parameter it sees that it's not a record it's just a number and it's checking that against the rec cord that contains both parameters and it doesn't like it because it doesn't look the same so if you see this kind of error message that talks about records then remember that it may be because you forgot to give names to your parameters in your scenario okay so then we add a number check the result add a number again everything so here you may wonder why uh explicitly said that Min value was an integer and the reason is that if I don't do that smart P tells me that there is an unresolved constraint so basically it says here those cannot be added and basically that's because it doesn't really know the type of minan value so when I add something to minan Value it doesn't really know what to type we had no hint other than this to tell us if Min value is a nut an INT a string or something else so we have to give some information about what type it is but if we only give the type of Min value the type inference system can infer that since Min value is of type int the parameter Min value is of type in therefore the storage is of type int therefore a has to be of type int therefore max value also has to be of type int therefore this max value has to be of type int this one has to be of type int this one has to be of type int so just by adding this single information that says Min values and int everything else can be determined by the type inference so we're starting to write contracts are a little bit more complex and that means sooner or later we will have bugs so it's important to learn how you can debug smart contracts one way to debug smart contracts is to cut them into pieces for example if I have an error that I don't understand I could try to see well let's see in which entry point causes the error so I could easily delete this entry point delete the calls to this entry point and check do I still have my error if I'm completely lost I can just use binary search basically by deleting half of the contract to see if that helps but another tool to help me debug is to get some information about what's going on inside of an entry point and for that I can use the trace function to print any value that I use in my entry point if I'm using the smart Pi IDE the output will be in the browser console and if I run it on the common line it will be simply sent to the uh standard output so for example I have this entry point make call after I increment and because Trace so output on the console or on the stand output the value that number call has now let's give it a try here if right after and because plus equals one I use Trace to put a string and then Trace to Output this value I run it I don't see anything special here but if I open the browser console so on Google Chrome it's control shift J I can see here the output and we call 1 and equals 2 so I can clear it with contrl L to make sure I only see what's the output of the execution I run it I see okay n equals one n equals 2 I could also use pairs so for example I put parenthesis here comma here I'll do contrl L and if I run it I can see n equals 1 n equals 2 it's a bit easier to read that can help me understand what's going on in my contract and fix bugs let's practice on an exercise I will ask you to modify the endless wall contract so that it now counts the number of times it's been called so the number of times that messages have been added to the text in a new variable in the storage and then please change the right message entry point so that it takes two parameters both a name and a message it should check that the length of the name is between three and 10 letters you should still check the length of the message itself is between three and 30 letters but you just add this new check on the name and then with these parameters it will add a comma then the name a column a space then the message and finally forever to the text so we'll have the name and then the message and then forever and of course please check everything in your test scenario and use this as an opportunity to practice using trays and print internal values and see how it works so please pause the video and give it a try let's take a look at a solution so in the storage we added this variable NB calls that we initialize at zero then we modified the right message entry point to add a name parameter we still have our assertions on the length of the message we change the error message to clarify that it's an invalid message length then we added a second assertion this time on the length of the name with a message that says invalid name length and then we change W text to add comma the name column message and forever then finally we increment the value of NB calls at every call in our test scenario whenever we call write message we need to give the name of the first parameter message equals the value we want to send and same thing with the second parameter the name equals and the value we want to send so we make a couple calls that are valid we verify that the output is what we expect we verify that the number of calls is what we expect and finally we try a few calls that would fail we try to send message that is 31 letters long and so this is false and should generate an invalid message length error same thing with a message that is too short a name that is too short a name that is too long and then finally we write some messages that are exactly the minimum we need so three letters in the message three letters in the name and then the maximum so 30 letters in the message and then 10 letters in the name this is exactly 10 letters and we check again that the number of calls is correct we can give it a try and we see that it worked we start with hello then we call it with a message an Jack and the name Anna we can see that we now have Hello Anna Colin Anna and Ja forever and after another call from Joe we have Joe Tes us forever and then two calls we have those four test that didn't work and then finally another two that worked all good in this module you will learn how to manipulate addresses in a smart contract which will make your smart contracts a lot more powerful as tesos is a public blockchain it is permissionless that means anyone can participate in the network anyone can emit transactions anyone can create accounts Etc however when they do so they are authenticated based on their address so their address is attached to their balance and their transactions are attached to their balance and whenever we execute a transaction we can know for sure that this transaction has been emitted by whoever owns the private key of this address so they are directly attached to a specific address and when you use addresses in smart contract that makes it very powerful you can authenticate users that call the smart contract so you can basically Implement fine grain access control and you can also use these addresses to assign ownership to any digital asset you have already manipulated addresses you know that TZ addresses correspond to user accounts and KT addresses correspond to the address of smart contracts you deploy and each of these addresses uniquely identify either a user or a contract and the TZ addresses are based on the hash of the public key of the users also include a check sum so you cannot just write a random sequence of numbers after TZ the checkm has to be valid from a smart contract you can manipulate addresses for example you can obtain the address of the direct Coler of the contract it could be a user or it could be another smart contract you can also compare two addresses so you can check if the address of the color is equal to some expected address so that enables Access Control you can also send TZ to a given address or you could call another smart contract based on its address on the other hand there's a few things you cannot do you cannot check the test balance of some address whether it's a user or of a contract from a smart contract you only have access to your own balance and you cannot read the storage of another contract either you can only read the storage of the cont cont ract that you're executing let's look at some syntax to manipulate addresses so if you want to create an address value you simply write sp. address and then between parenthesis and between double quotes you just give the actual value of the address so a tz1 address or a kt1 address if you want to express the type of an address you simply write sp. address you have access to the address of the direct color of the smart contract through sp. sender and if you want to know the address of the contract itself that you are currently running you can use sp. self address So that's its own address in your test scenario you can create test accounts for fake accounts just for the purpose of the test using sp. test account and then a name that you can give so you can store it in in a variable then when you call Smart contract and need to send the address of one of these accounts as a parameter of your smart contract you can simply use the name of the variable where you store the account do address so this will send tz1 address of that user and finally if you want to call a smart contract and say this call has been made by this user so the sender of this transaction is this specific user you can add a parameter when you call a smart contract entry point underscore cender equals then the variable that contains the account so here you're saying I'm calling the increment entry point with the parameter five as Alice using Alice as the center of this entry point so from the smart contract sp. Center will be the address of Alice let's work on an example we will change the store value cont contract so that only the owner of the contract is able to call the reset entry point and then of course we will add test to this new version of the store value contract here is our modified store value contract so on top of storing the value 42 initially the Constructor takes a parameter owner that we assigned to another variable in the storage then in the reset entry point we add an assertion we checked the sender so whoever is calling that entry point we check that is actually the owner that we stored here so we check that this address is equal to this address so that only the owner can reset in our test scenario we create a couple of account Alice and Bob and then when we instantiate our contract we say that the owner is Alis and finally when we call reset we first try with a sender being Bob so we call it with an address that's different from the owner that we defined here so of course we say valid equals false because we expect this to fail and then we try a call that should work by calling reset as alist so this is not sending in a parameter this is just saying that we simulate this call to reset with no parameter but where the transaction is emitted by Alice finally we verify that reset was correct and we check that is equal to zero let's give it a try here we can see that when we insten the contract the value of the owner is tz1 WXR so this is Alice's address then we call the add entry point we see that here the sender is not defined because we didn't specify any sender here when we try to reset as Bob we can see that the sender here is a different address so not Alice Alice was tz1 WX Etc here we call it as tz1 RP Etc so it doesn't work only owner can reset then we do another transfer this time as alist tz1 WX Etc and this one works and of course we reset the value to zero now it's your turn modify the endless wall contract so that the same user can't add text twice in a row basically we want to do a very basic spam prevention so we don't want the same user to send two messages in a row which means between two calls from a given user at least one other user should have added text otherwise we reject the call please pause the video and give it a try let's take a look at a solution here in the constructure we take two parameters the initial value of the text and the address of the owner so we initialize well text to this initial value we initialize the number of calls to zero and then we initialize the last sender as the owner so this address this is an address where we will store who is the last person who called right message but we have to initialize it with some address so we decided that we would use some address that is the owner of the smart contract so we say the owner deploys their contract they shouldn't be the one sending the first mess message and if they want to be the one sending the first message they can just send a different address here then in the right message entry point so we have this version where we only send a message we add an assertion that the value of the sender so whoever is calling this entry point should be different from whoever we have stored in last sender then we add the message to the wall we increment the number of calls and then we update last sender to whoever is calling this entry point so this means that once we have a first call the next call cannot be by the same person because the next call shouldn't have sp. sender equal to last sender we can have our test scenario where we again create a few accounts and then we first write a message using Eve as the sender then we write a second message where we use Bob as sender this should be fine but then we add another message where it's Bob again try to send some messages so this should fail and then the next one we send it at Alice again so it works and in between we tried with Alice but with a wrong length of the message so this entry point was never executed and it's cancelled so now Alice can send a message again because the previous person to send a message successfully was Bob let's give it a try okay we can see here that initially we have last sender that's the address of Alice tz1 WX Etc then we have write message sent by Eve tz1 NW then we have write message sent by Bob so a different address tz1 RP and every time we can see that the last sender has been updated to whoever is calling this message so I'm here now send her update to Eve so now again we have Bob train to call but L sender is set to this value so this is rejected we can try again then we send a message that's too long then we have another person try to send it Etc all good in this module you will learn how to create your own nft smart contract and you will find out that the few features we have presented in the previous modules already make smart contracts very powerful and useful the few Concepts we have presented so far integers Naturals strings addresses entry points storage and verifications already give smart contracts a lot of power you can use them to store data forever you can attach users to data through their address which can enable ownership and with verifications access control and smart contracts are unique thanks to their address on a unique blockchain finally they can execute code that will change this data and perform transactions based on pretty fine and most importantly unalterable rules all this makes it possible to create any type of digital asset with two properties scarcity and ownership anyone can create their own unique digital assets on tizel you probably already have heard about nft so nft stands for nonfungible tokens and an nft is a digital asset that is unique uniquely identifiable it contains some information it's metadata that could be anything an image for example or some text it has an owner and it can be transferred and that's it that's what defines an nft non Venable token so a token that cannot be split that is unique and that can be transferred because they clearly identify the ownership of an item nfts can identify the ownership of any digital or physical art or collectible such as paintings music or ingame assets they can also represent real estate or any other physical assets or they could be used to represent more temporary assets such as tickets for a concert or any event passes and if you also provide a number of benefits like everything on a blockchain when used well they don't depend on a third party so for example you could transfer an nft without having a third party authorize or be the intermediate for this transfer they also provide a temper proof record of the ownership of the Em which makes it easier to track if you're really buying the right thing if basically it prevents counterfeiting you know that what you're buying is the original nft and you can see who sold it first Etc they make it possible to trade on new marketplaces that are available worldwide without restrictions so this increases accessibility as well as liquidity and can increase the value of these assets and finally they offer the possibility to add a number of features such as automatically paying royalties to artists when you transfer the nfts there's actually nothing new to learn for you to be able to create your own nft contract so based on what we just described you can already write your first nft contract so the idea is to create a contract that will represent a single nft to do that you have to keep in mind that the nft needs to be uniquely identifiable that it will contain some information that we call metadata that it has an owner and that it can be transferred so give it a try pause the video and try to create your own NFD contract if you're stuck come back and we'll give you some hints okay let's talk about some hints on how to create an nft smart contract when you create your smart contracts the most important thing is to determine what you will store in your smart contract and what the different entry points will be then it gets easier to write the code of each entry point so if we think about what the contract would store we need to think about its different properties we said that the nft contract has to be unique but every contract is already unique as it is identified by its address so it makes it unique on a given blockchain so we actually don't need to do anything about that we just rely on the uniqueness of our smart contract the nft has to have an owner we can simply store it as an address in our contract same thing for metadata we can have metadata in the storage of our contract for example as a string it could simply be your names first nft finally it has to be transferable so for that we need to be able to change the owner so that means we need an entry point that will update the address of owner but of course only the current owner should be able to initiate this transfer with those hints in mind pause the video give it a try make sure everything's good in your smart contract and don't forget to test it well let's look at a solution so we can see here this single basic nft smart contract and we can see that it's very lightweight in the storage as we described in the hints we have the owner that we initialize with the first owner so whoever is deploying this contract can set this value to their own address then we have the metadata here we uh simply hardcode it in the Constructor we could also pass it as a parameter but the same thing is when you deploy your contract you define what the value of the storage is initial as we already described the uniqueness of the enf is already given by the unique address of the smart contract so there's nothing you need to do about that and finally we create this transfer entry point where we pass the address of the new owner then the entry point checks that the current owner is indeed the one who's trying to do the transfer so we check that the sender is equal to the owner otherwise we have this exception and if that's the case we assign the new owner to the storage that's it and of course we need to test it well so we create a few accounts we instantiate our nft we say Alice is the original owner we keep this metadata as the original metadata then we can create our test scenario and we try a few transfers here we transfer to Bob we check that indeed it was transferred to Bob we check the metad data is what we think then Bob can transfer to Eve so we check that the new owner is inde the eve then Bob can transfer the nft to Eve and we check that Eve is indeed a new owner and finally Eve can transfer to Alis and we check that this is good so here we missed something right our test is not complete it's important to keep in mind that you should always test the case where everything goes well but also test cases where people try to do things that are not allowed so of course here we have this assertion that checks that whoever is trying to do the transfer is the current owner we need to make sure we check this assersion in our test so we need to add this verification of trying to transfer for example to Bob but as someone who's not the current owner so Alice is the current owner so let's try transfer to Bob as Eve and and we expect this to be failing so we write valid equals false and the exception equals not your property let's give it a try all good so we start with this owner this is Alis tz1 H4 Etc metadata first nft we have this unique address that identifies contract therefore nft so Alice transfers to this person that's Bob and so we can show that the owner has changed then we transfer to Eve we can see that the owner has changed Etc and finally we tried transfer to Bob by Eve but we have the exception as expected not your property so everything is good and now we have our first nft smart contract if we deploy this smart contract we are creating an nft that will be on the blockchain forever that we can transfer and that has its own metadata of course you want to create nfts with maybe more interesting metadata than this but this is actually really an nft of course it's still a very lightweight nft and it's missing some features that we really expect to make nfts convenient the main one is that doesn't make it easy to securely trade it against currency or other nfts in particular you can transfer it but there's no secure way to sell it without taking a risk that's really the main issue with this smart contract the next one is having one contract for each nft is not very convenient it makes it expensive because you have to pay for each deployment T us the fees are reasonable enough but still you have to pay for the storage of each contract that's not ideal and finally it doesn't follow any standards there are nft standards that make it easy for nfts to interact with different tools with wallets with uh marketplaces Etc so if you use this very simple nftd contract you really won't be able to trade it much and benefit from all the possibilities of nfts but in the next modules you will learn how to address these issues and add these possibilities and more to your nft control on blockchains everything is about trust on one side it's about not having to rely and trust a third party for things to happen as expected and on the other side it's about trusting that things will happen exactly as they are supposed to exactly as a smart contract announced things would happen and blockchain is also about the underlying cryptocurrency in the case of tesos it's all about TZ in this module we will see that both complement each other that TZ can increase the trust you have and its trust that gives the value to the cryptocurrency a public blockchain is a system that anyone can use without necessarily revealing their identity and it's also a system that has a lot of value at stake so if anyone can use it without revealing who they are and if there's a lot of value at sck what could possibly go wrong all this can only work if most participants behave well so the question is how can we make sure they do pause the video and think about it for a moment before you continue if we take our previous example of a contract that allows people to post text on a wall forever how can we prevent someone from flooding or wall with all kinds of messages we tried preventing the same user from calling twice in a row as an example on how to use addresses but this doesn't really protect from anything it's very easy for a user to create many different addresses and in our case we only needed to create two addresses and switch back and forth between the two addresses to post as many messages as we wanted another approach could be to restrict access to a set of trusted people but that would really defeat the purpose of the contract and the whole idea of blockchains where anyone can can join so it would be too limiting and complicated to use it's possible but it's not really the goal of this contract it also wouldn't be 100% safe just because you think you trust someone doesn't mean they're going to behave well still focusing on this endless wall contract can you think of an approach that could work to prevent people from spamming the wall with tons of messages give it a moment and pause the video before you continue one way to prevent excess iive use of a smart contract is to rely on a financial incentive all you have to do is charge one Tes every time someone wants to add a message to the wall if you really want to post a message and keep it forever one test is not much but if all you're trying to do is to spam the wall with all kinds of junk then one test for every message is starting to be expensive so by charging one t for each message you make sure that people don't abuse it at the same time you can use this test as a way to fund the development of our nice app that showcases this wall contract and makes it easier for users to post their messages on it as we're starting to see cryptocurrency is useful for much more than speculation or simply storing value you can use it as part of the blockchain security you can use it as a punishment for bad behavior that's what we do to prevent double baking through the slashing of the baker deposits you can use it as a reward for behaving well so for Bakers it's about a reward for baking or denting bad behavior and you can also use it as a way to prevent excessive use that's what we do when we have this system of gas to prevent people from using excessive computation from the network or storage fees to prevent people from using excessive data on the network so we can see that cryptocurrency is is used to increase the trust that we have in the blockchain and the fact that it behaves well and reliaable the same can be said about smart contract and you can use cryptocurrency as a way to increase the security of smart contracts you can use it as punishment by asking people to deposit some Tes that may not be returned if they don't behave correctly you can use it as rewards that users can obtain for providing a service or maybe dening bad behavior and you can use it in your smart contract to prevent excessive abuse by charging fees as we discussed instead of setting strict limits and rules that may limit legitimate use of your smart contract how do we do that when you call a smart contract the caller may send some Tes to this contract these ts are added to the balance of the contract and they also may be sent to to another address by the contract so that's how we can have a contract that charges a fee for example let's look at the syntax we have Type M TZ that can be used to express amounts of Tes that we manipulate in the contract we can create values for example if we want to have a variable that stores 12 TZ we can write sp. TZ of 12 or we can write it in the actual unit that's underneath that is the mutes a millions of Tes and so we can write sp. mes of 12 million this is the same as this so sp. T of 12 is a shortcut when you want to manipulate a whole number of Tes but the actual type is the mess of Tes the mutas within a smart contract you can check how much the color of the smart contract transferred to this contract by using sp. amount you can also check how much is currently in the balance of the contract with sp. balance that includes the amount that has just been sent by the caller but finally you can send some Tes to an address by using sp. send the address and then the amount that you want to send not that this is generating a transaction that is not immediately executed it's added to a list of transactions that will happen after the end of your entry point in your test you can test the transfers of Tes so for example when you call an entry point you can specify who is calling it and how much they're sending to the entry point by adding underscore amount equals and the amount you want to send from this user to the contract within your test you can also check the balance of the contract just simply by writing contract. balance on the other hand it's not currently possible and smart P to check the current balance of a test account so after here Alice sends some test to the entry point you cannot check that the amount Alice has on her balance has indeed decreased by five you could do it by using a smart contract instead of a regular account we'll see later how we can do that so it's really important to understand that on tesos at least on the L1 that we're working on with smart py when a contract charges a fee for a ser Serv the contract doesn't take the test from the account it's the caller of the contract who is the one who sends the right amount of test to the contract all the contract does is to check if it's happy with the amount that the caller sent and if it's not happy with it it can fail and basically reject the call but by default any Tes that are sent during a call are automatically added to the contract's balance so the contract does doesn't have anything to do to accept the Tes all it can do is potentially reject it if the amount is not what it wants so this is important in particular because this is not the case for all blockchain but that's how it works on tesos let's look at a version for Endless W contract where we charge one Tes every time someone calls right message all we had to change was to add this line where we check that the amount of Tes sent by the sender is one test if not we generate an error incorrect amount and everything is cancelled that's all we need to make sure people pay one test whenever they want to write a message in our test scenario we can check that if we indeed do send one test everything works but to check that it's really exactly one t we can check a little bit less and this should fail and cause the exception incorrect amount and same thing if we send a little bit more it will cause the same error and it's always good to have a second call to check that we can indeed call twice by paying the right amount let's give it a try everything worked so we can check towards the end this is the first call where we send one t with we can see that it added the text testing the right amount and then here we tried with a tiny bit less and generate the error same here with a tiny bit more and then if we send one test again everything works this contract actually has a very terrible flaw and things would end sadly for the author of the contract and it's a real flaw that people have made in the past and have lost large amounts of fund so it's very important to have this flaw in mind and avoid having it in your own contract so the question is can you figure out what that flaw is and then can you fix it take a good look at the contract pause the video and try to find the flaw as we stated earlier the test sent to a contract or added to its balance and by default that means these T are stuck forever in the contract there is no notion of owner or author of a contract on tesos unless you specifically assign a value to an oral variable in the smart contract so that means by default no one can get these Tes out of the contract that means the Tes in the balance of the contract are wasted if we want to avoid wasting them we need to specify an owner of the smart contract that will receive this T and make it possible for this owner to collect the tests to do that one way is every time someone writes a message to send the corresponding Tes to the owner so we can send the amount received and that's it and we see here that after a call where the caller sends one test to the contract then the contract generates a transaction that sends one test to the owner unfortunately this is not enough there's another big flaw can you figure out why pause the video and think about it for a moment I'll give you a hint the idea is that this version of the contract doesn't really enjoy all of the benefits of the centralization so I'll recap Main benefits the centralization provides relability it gets rids of the dependence on the third party and it prevents censorship so one of these aspects has been lost in this version of our smart contract can you figure out which one and why and how to fix it take a look at our contract and think about what could go wrong pause the video and think about it for a moment to find out what the flaw is you have to remember that a smart contract is a kind of account and like any account its address can be the destination of some transfer so instead of using a user account address as the owner you could use a contract address as the own and so when you send some test you can send them to a contract address if the address isn't that of a contract in practice sending test to a contract address will call the default entry point of that contract it's simply an entry point called default that takes no parameter and if you want to create a default entry point that accepts TZ as TZ or by default accepted all you need to do is to do nothing and as a way to show that we write pass as the only instruction in the contract to indicate that yes we know we don't want to do anything in this entry point so we write pass to say do nothing this will be an entry point that accepts simple transfers of TZ to the contract now the issue is that if the owner of a contract is a smart contract this smart contract could change change the behavior of its default entry point and reject the Tes if as the owner of the contract you can reject the test you can reject calls to write messages that means users have to trust you they have to trust the owner of the contract that this owner will not disable the smart contract or prevent someone from posting their messages the whole idea of decentralization and not relying on the third party is that you don't want to have to trust that the owner of the contract will not stop the service for any reason so here if whoever deployed the contract made the owner another smart contract and that smart contract can prevent transfer of test then they have full control on whether Our Endless World contract works or not and that's a problem we don't want that to better understand this let's look at an example so we have our endless World contract here that whenever we call right message checks that the user sent one test and then sends that one test to the owner so let's see how we can make this owner a smart contract that will then have full control on whether it's possible to call right message or not the idea is that we can create this owner contract that will store the owner of this contract and we'll have a Boolean called blocked that says where whether it's accepting or blocking transactions so we set it as false initially everything works then we have an entry point set block where the owner can change the value of blocked to true or false finally we have our default entry point if blocked is false then this condition will be true and then the contract will not only receive the test but send the balance back to the owner owner of this contract but if blocked is set to true then it will reject any transfer to it so if this contract is the owner of this contract then whoever owns this contract can decide to block any call to write message we can write the corresponding test scenario here we create a scenario we create an instance of our owner contract and Alice is the owner of that owner contract we added to the scenario then we create an instance of Our Endless World contract and we say that the owner is actually this contract's address we add that to the scenario as well then we can check that if we simply write a message and send one t everything works but if we then call set block of that contract as Alice who's in charge of this contract then the next call the same call is going to fail with the exception wall is blocked returned by this contract when we call the default entry point let's give it a try so it worked and we can see that indeed when we did the second right message call it's call the the default entry point of our owner contract and raise the exception wall is blocked so the transfer didn't happen and Eve was not able to write on the wall this is not something we want we don't want some unique person some third party to have full control on the contract and prevent other people from using this service so how do we prevent that well the issue here and that you should always be careful about is that this entry point called by any regular person is sending T to another address and this is the dangerous part because this could fail and prevent any call from right bling so the solution is to avoid calling send to another address as part of the entry point that the first person is calling to do that we just split it into a separate entry point that this owner will have to call to get their money back so we create a separate entry point that we call claim that can be used by the owner to request the balance to be sent to them here we checked that it was actually the owner calling this but we don't really need to if someone else calls it then it's going to send test to the owner and that's fine that's what we want in the end we just didn't want it to happen as we write message because this call could be blocked so we don't actually need this assertion so now we don't have an exception anymore so expected exception but not occurred so we can change that and say yes now this works but for Alice to get her money she would have to call the claim entry point so now that we know a little bit about transferring TZ to and from a smart contract let's see how we can use it as a way to add a feature to our nft smart contract so that the current owner of an nft can sell it with the transfer entry point that we already had in our basic nft smart contract we could imagine a sell that would take two steps two transactions the first transaction would be for the buyer to send a certain amount of t to the owner of the nft to pay for that nft and then in a second transaction the owner could say okay you paid me now I will call transfer on that nft with the address of the buyer so that's a typical transaction right if you go to the bakery and you want to buy some bread you give 1 to the Baker and then the baker gives you your bread so the question is what could go wrong with such a system and how could we change our basic nft smart contract to fix this issue here was the contract so pause the video and think about it for a moment so the issue when you use two transactions is that it relies on the two parties to trust each other that's the case no matter in which order the two steps are performed if it's the buyer who sends the money first then they have to trust that the seller will indeed transfer the item to them on the other hand if it's the seller who transfers the item first then the seller needs to trust that the buyer will then send the money without the blockchain so for example in our Bakery the same thing can happen you could pay 1 EUR for your bread and the baker could take your the Euro and not give you your bread or if the baker gives the bread first you could take it run away without paying the one Euro in this sitation we can rely on the police we can Ry on the justice system Etc as a way to handle conflicts or more generally we can involve a third party for example an online shop as an intermediate between the buyer and the seller but again you need to trust that the police will care about your bread or your one Euro that you lost that the justice system will be effective Etc it's really a hassle and can be actually very expensive and time consuming and you have to trust that the police police or the justice system will do their job well but thanks to decentralization blockchains can provide this kind of trust without a third party within a smart contract you can perform what we call an atomic exchange where either the two steps of a transaction succeed or neither of them will happen so either you both transfer the item and get the money or nothing happens simply by having the two steps within the same entry point since any step that fails cancels the whole entry point let's put this in practice with an exercise where your goal is to change the basic nft contract so that users can buy or sell their nfts so your goal is to add a buy feature such that the following can happen the owner of the contract should be able to set a selling price price for their nft the buyer should then send the corresponding amount of Tes the seller should be able to get these T and finally the ownership of the nft should be transferred to the buyer when everything goes well the contract should make sure that the buyer only gets the nft if they sent the right amount and the seller should only receive the paid amount if the nft ownership was transferred so how can we we do that pause the video and try to work on it so to help you we can think of what entry points we will need we will need two different entry points one for the current owner of the nft to be able to set the price at which they want to sell that nft and the second entry point will be the buy entry point that the buyer can call to purchase the nft will have to check that the buyer transfer the correct amount using sp. amount it will need to send that amount to the seller's address from the balance of the contract and then it will have to transfer the ownership of the nft to the buyer so please implement this you can then validate it on Open tizel let's take a look at the solution in our Constructor we added this new value the price that we need to store then we have an entry point set price that takes the new price as parameter we make sure only the owner of the nft can call this entry point and once we've done that we simply replace the current value of price with the value of the parameter finally we can have a buy entry point that doesn't need to take any parameter the buyer don't need to say how much they send they simply send it as they call the buy entry point and it's the contract that checks that the amount sent is equal to the price cuz if if it was a parameter the buyer could just claim whatever amount without actually sending the test so the amount to send is available from sp. amount and that's the value you want to check so once you check that the buyer sent the right amount you can send that amount to the owner so here as we have seen this could fail but if that fails that means the owner doesn't really want to sell it so that's fine we don't need to separate that into a claim entry point here finally once we have created the transfer of price to the owner we can change the owner to the address of the caller who's the buyer and that's it then we can test this here we call set price with a price of seven from Alice who's the original owner of the nft we check that if someone else like Bob tries to change the price this will cause an exception you cannot update the price and finally we try to buy the nft as Bob paying the right price 710 and we check that if we try to buy it at the wrong price this will cause an exception saying wrong price let's give it a try all good we Chang the price here we can see that the price has changed we can see that this failed then we actually purchase and we can see that the amount was sent back to Alis then we can try to purchase with the wrong amount and we get an exception all good so just by doing this we made our nftd contract a lot more convenient so now you can buy and sell nfts in this module we'll give you the answer to a question you may already have asked yourself what if I don't want to put any value for example what if I don't want to set a price for my nft it's not for sale for that we can use options but we also see that in many cases you probably shouldn't use them so far our variables always had a value but sometimes you simply want to say that there is no value for example when you initialize the endless wall and we keep track of who called the right message entry point for the last time initially you want to set this last caller value to nothing right nobody has called it yet so how could we support this possibility pause the video and think about how you would support this possibility if it was up to you so how can we allow variables of some type to have no value at all one possibility could be to use a special null value but this could be quite risky if an INT variable is new then any arithmetic operation you apply to it would fail if you want to avoid bugs you want to make sure that if there's Theos possibility of a Nal case your code always handles it but you don't want to have to handle the newal case even for variables that actually always have a value how can we solve this dilemma again pause the video and think about it for a minute if we want to both Force the code to always handle the possibility that a variable has no value but at the same time avoid having to write such code for variables that will always have a value then we would need to use a different type for both situations right so for any type int not TZ address Etc we would have a version that always has a value and then another variation of that type that sometimes may not have a value how can we avoid having to support two versions of every type a steel handle both cases so instead of having two versions of every type the int that always has a value and then it that may have no value we use a special type that wraps around all the types and we call it options an option is like a box that may or may not contain a value of a given type so for example an option on an INT may contain either nothing or an INT all you can do with an option is create the option with or without a value check if an option has value compare two options unwrap the options that basically means is getting the value that it contains out of the option and any other operation can't be done without first unwrapping the option so for example if you want to add two values of two options so two options on the NIT you need to unwrap both options and then add the actual values so here is how you create an option you simply write SP do sum and then between parentheses the value that you want to put inside an option but of course you also want to be able to create an option with no value for that we simply write none two options are equal if they contain the same value so we can compare sp. sum 42 to sp. sum of 42 and those would be equal or if they both contain nothing so none equals none any other case they are different so for example you could do assert my option equals sp. sum of 42 or S my option equals n you could also use the other type of comparison operators lower than greater than Etc if the two options contain a value it will compare these values if at least one of the options is none it will return false so for example sp. sum of 33 is lower than sp. sum of 42 but none is not not lower than sp. sum of 42 and it's not greater either or equal to sp. sum of 42 so those two will return false if you want to extract the value out of an option you can write your option do unrap sum and this will trigger an error if the value of the option is none because there is no value to get out of it the Box doesn't contain anything if you want to check if an option has a value you can see simply write assert my option different from none it's usually a bad idea to use unwrap sum to compare an option to a value for example if you do if my option do unrap sum equals my value then this will fail if the option doesn't contain any value which is probably not what you want you just want to do something if it's exactly this value and not fail if it's not so what you would rather do is compare to an option so if my option equals sp. sum of the value you want to compare it to so instead of unwrapping your option you wrap the value that you want to compare it to this will never fail whenever you need to describe the type of an option you can write SP do option and between square brackets you put the type of the value inside the option so for example for a n the type would be sp. option and square brackets sp. n for for none type inference is used to determine the correct type let's check an example in Our Endless wall contract when we wanted to check that the same address was not used to call right message twice in a row we used last sender and before we initialize it to the address of the owner but instead we could say the initial value of SL sender is none right we haven't made any call yet then when we want to update it instead of assigning it to sp. Sender we assign it to sp. sum of sp. sender when we want to check if it's the same color as last time we compare last sender to sp. sum of sp. Senter again you ripe the value you want to compare it to rather than unwrap your option does this would fail if the value was none so if we make that change and run it everything works and we can see that the initial value of L sender is none and then sum and the address Etc my recommendation is actually to avoid options when there is an alternative the reason is that when you use an option you need to add code every time you manipulate its value you need to add code to verify if it's none you need to add code to extract the value you need to add code code to compare it to a special value Etc every time there's something extra you need to do to handle the fact that it's an option this overall makes the code longer harder to read slower and more expensive so if there's an alternative that works we recommend using that alternative what would an alternative be well as we have done before we introduce option we can simply use a default value if there is one that can do the job so for an address we can initialize the value with an invalid address and give it a name so for example this is a contract address that is correct the check some works but it doesn't correspond to any actual contract and so you could use this address but most of the time using the address of the owner also works so that's what we had done for Our Endless World contract and the last sender value here if instead of using option we simply initialize with owner then we remove code right we don't need to do this we just directly compare to the sender and here we remove code again we directly compare to the sender so it makes the code easier to write and to read the only issue with this is that owner cannot be the one who makes the first call but if we want owner to be able to make the force go to write message we can just initialize with a different value that that we know for sure will not be the one writing the first message such as an invalid value of course sometimes it's necessary to use options because there is no better choice so for example if you need to call another contract that has an entry point that takes an option as a parameter of course you need to use an option but sometimes you need to create your own entry point that has an optional parameter maybe because you want to be compatible with a standard that uses options if no matter what you need to have some specific code to handle the case where there is no value then you definitely want to use an option it's a lot nicer to compare to none than to compare to some arbitrary value that you use instead of N and finally if there's no default value that would work nicely then you should use an option for example for the nft contract if you want to make sure that nobody can buy your nft putting a very huge price on an nft would Weir would be a weird way to handle it it would mean like you're pretending that your nft is extremely expensive so it's a lot better to say my nft is not for sale the current price is none finally there's a number of cases where you need to access return values from Instructions that may cause errors and such instructions often return an option here are a few examples if you use the function is n to check if a value is a nut this will return none if the the value is negative and it will return an option on the value if it is zero or positive another example is sp. slice that extracts a substring of a given string but it will return none if for example the offset or the length are invalid there is no such extract and it's beyond the bounds of the string for example but if it is valid then it returns an option on the result another case is when you want to interact with another contract you use sp. contract and provide the type of the contract the address and the entry point and it will return none if there is no such tree point for the contract at this address otherwise it will return an option on the contract let's put it in practice with an exercise change your nft orell contract so that it uses an option to indicate that the nft is not for sale so if you want to say it's not for sale you will use the set price entry point but pass none as a parameter to say I don't want it to be on sale and similarly right after somebody buys it you want to set the price back to none so that it cannot be bought again immediately by someone at the same price here is a smart contract that we asking you to change pause the video and give it a try so here when we initialize the contract we don't need to put any initial value value so we can remove the price and initialize It To None when we set the price well we need to pass an option anyway so we just save it as is it's already an option and when we buy then we need to compare the amount sent to the price so we don't unwrap the price we wrap the amount using sp. sum and finally we need to set the price back to none you know test here we need to wrap this into an option same here and line 21 we need to unwrap this because we need to send the value but since we already compareed the amount to the price instead of unwrapping this we can simply send the amount received and so when we initialize the contract we decided not to put any price so all good but now if we want to say it is not on sale all we have to do is C1 do set price none and so we can see that end we put the price Back To None So options are pretty easy to use but remember that when you can it's better to avoid using them to simplify your code in this module we will talk about blockchains and time blockchains have a deep relationship with time you could say that a blockchain has a pulse it's like a heartbeat ticking very regularly from the Genesis block towards eternity every few seconds we have a new block another connection between blockchain and time is that a blockchain can be used by anyone to safely store information forever to send information far in the future it also has a relationship with the past as a blockchain can be used to certifiably timestamp information and prove interiority basically prove that at some time in the past you already had this information and you can prove it finally it is possible to use a blockchain to lock assets until a specific time in the future in a way use it as a Time cap capsule the only issue is that a smart contract actually can't tell time when you execute the smart contract you cannot read the current time from the computer that executes it the reason is that a smart contract should always produce the exact same result no matter which node execut it no matter when it executes it so if you run the same program on different nodes and at different times the current time will be different right so the code cannot depend on the actual current time of the computer that runs it however you really often need to manipulate time within a smart contract you want a smart contract to be able to check if it's been called before or after a deadline you want to be able to check how much time has passed between two given events and you also want to be able to store and saveguard the date of specific events so the question is how can we solve this dilemma we cannot access to a time of the computer the contract is running on but you do need to know the time pause the video and take a minute to think about it so the solution is that every block includes its own timestamp and a smart contract can access this timestamp using sp. now and every smart contract call within the same block will read the exact same Tim stamp and it doesn't matter which node executed or when we execute it the time stamp of a block is always the same so whenever you execute a contract from a block the value of the time stamp is always the same and then of course for the next block it will be a different value corresponding to when this block was created but the time stamp of a block is actually predictable the value of sp. now is predetermined by a time stamp stored in the previous Block in practice there's two time stamps in the block the one that can be read through sp. now and the actual creation time of the block that will only be used by the next block to compute value of sp. now in the next block so the time stamp of a block is predictable based on the content on the previous block but more than that in practice blocks are created very regularly at the time of recording there is a block being created every 15 seconds and if you look at the ual time the difference between two block creation is really precisely 15 seconds most of the time there's very little variation that's something important to keep in mind in smart Pi we have a type dedicated to time stamps s. timestamp and it represents a number of seconds relative to January 1st 1970 at midnight internally it's like an integer it can be infinitely positive so it can correspond to any date as far as you like in the future but it can also be infinitely negative so represent any time as far as you like in the past if you want to create a time stamp you can use sp. timestamp and provide the number of seconds since January 1st 1970 again it could be a negative number if you want to access the time stamp of the current block you can use sp. now if you want to add some time to a time stamp you can use SP do add seconds your time stamp and number of seconds or if you want to add a number of days you can use sp. add days your time stamp and the number of days finally if you want to compute the difference between two time stamps you can subtract them and the result will be a number of seconds so that's very convenient to measure how much time has elapsed since a given event finally there's a way to create a time stamp using a list of parameters where you provide the year the month the day the hours minutes and second this is using sp. timestamp from UTC so it's a time in the UTC time zone when you test a smart contract time doesn't pass between your different calls doesn't matter how long the computation takes you can make as many calls to your smart contracts in your test the time is not going to pass automatically SP do now will always be Zero by default but you can specify what value of sp. now you want to use by adding a parameter to your entry point calls underscore now equals and then the value of your time stamp this way you can simulate time passing without actually having to wait if you have a contract that has to wait 10 days for some event to happen you don't have to test it by waiting 10 days you can just simulate time passing by changing the value of now let's work on an example we'll take or unless we count contract and add a deadline the idea is that we will change a contract so that people only have until the end of 2025 to write a message on it from then on the wall won't change ever again so how do we do that well for one we we need to change our storage and add a deadline that we can initialize in the Constructor then in the right message entry point we will add a check is this before the deadline so we check if sp. now is lower or equal to our deadline otherwise we have an exception after dead line and that's it that's all we need to have this feature that the endless wall expires after a given deadline in or test to check that it does work right before the deadline but stops working after that line we call write message with a date that is just before the end of 2025 December 31st at 1159 and 58 seconds this one should pass but then a couple seconds later on January 1st 2026 after 1 second this should fail so we add valid equals F we use underscore now to specify the time we can initialize using time stamp from UTC let's give it a try it works we can see here that this call was met at this time so something that ends with 598 and it worked but a little bit later 3 seconds later 601 this one failed because it's after the deadline now it's your turn to practice on an exercise this time you will change your nft contract to add some notion of time in it and the idea is to make it so that you cannot sell on nft less than 5 days after the last time it was bought pause the video and give it a try let's look at our solution in the storage we will need to add a date that is the last time that somebody bought this nft so we initialize it in the constructure and then in the buy entry point we will store the new value so assign it to sp. now but before we allow the user to buy this nft we check that the current time is more than 5 days after the last date so here we have the last date that it was bought and we use sp. add days to add five days to it if this fails then we have an exception that says you need at least 5 days so here you may want Wonder should we use options so that initially The Bu date should be set to none and the answer is no as I said earlier when you have a way to avoid using options I recommend avoiding it here there's a very simple date that we can use as a default value and that could be sp. timestamp of zero so January 1st 1970 so there's no need to use an option any call we could make of course will be more than 5 days after that date so there's really no need for an option in this situation now let's look at our test so here we have the test that check the deadline when we initialize a smart contract we initialize with sp. time stamp of zero and then when we try to buy it the first time at the right price we set a value for the current date that is four days so so that's four times the number of seconds in a day after the time stem zero so that's of course way in the past but what matters is the difference and so this one should fail because it's less than 5 days after the initial value of BU date but then if we do a second call this time six days after the time St zero then it should work let's give it a try and it's all good we can see that this attempt was done at this time and in and a bit later this attempt was done and it passed well good so this is a good time for a recap of all the benefits of a smart contract that we have seen so far we have seen that smart contracts add trust in a sense that they allow us to eliminate the need for trusted third parties when we perform transactions by eliminating these intermediaries they also allow us to reduce cost they also have the benefit of transparency the code of a smart contract is public on a public blockchain so it's possible to check everything that will happen before you call a smart contract and use its service there is no surprise you should take the time to check the code we also saw that smart contracts are immutable and even the owner may not change the code at least by default so you are guaranteed that those rules will not change after you decide decided to use the service finally one of the benefits of decentralization is that there can be no censorship so nobody in particular can be stopped from calling a smart contract finally there is no single point of failure thanks to decentralization you can be certain that the service will always be available in this module you will learn to manipulate arithmetic operators and we will take as an example our first decentralized Finance contract a yield forming contract you have already manipulated some arithmetic operators but let's take a look at all of the ones that are available we already manipulated the addition using the plus operator subtraction and multiplication using the usual python operators as you would expect and we also have the negation to take the opposite of a value the integer Division and that's the only division we have and the single slash actually does an integer division on tesos because we don't have any floating Point operations those would be dangerous as they can lead to approximation issues maybe a different result depending on the architecture you're running it on Etc so to keep it safe we only manipulate whole numbers on tesos you can do modulo using the sp. mod function that takes two values and Returns the remainder of the division of the first one by the second one and you already manipulated some shorthand operators so we can use plus equals to add a value to this so Value Plus equals x adds X to Value same with minus equals or multiply it equal instead of having to write self data. Val equals self data. Val plus X Etc so this can keep things short for all these arithmetic operators both operants have to be of the same type this is because smartp is using Python and overloads the python operators and you can only overload operators if the two operant have the same type if you need to do arithmetic operations that combine two different types for example if you want to mix int and N operant you have two choices you can convert the nut value into an INT using SP do two int of the N value or you could convert the int value to a nut using SP do as int if you know for sure that the value is positive or zero or you could use dedicated functions for multiplication addition or division sp. add sp. Mo and sp. ediv that work even if the two types are different now the type of the result it's usually what you would guess based on what the result result can be so for the addition multiplication and division if both operants are Naturals the result will be a natural as well right you can never end up with a negative result if you add multiply or divide positive numbers but if at least one operant is int therefore could be negative then the result could be negative therefore it has to be of type int so if you multiply an INT with a n the result will be an INT same with addition and division for subtraction and negation the result can always be negative if you subtract two positive numbers if the second number is bigger than the first one and the result will be negative so the result will always be of type int whether the operant are Nots or inss for the module it's always a nut so the remainder of a division is always the positive remainder for the EDF function it returns an option on a pair of values q and R where Q is the quo so the result of the division and R is the remainder the reason why it's an option is because you divide by zero it could fail and in this case instead of raising an exception it returns none and if it doesn't fail then it returns an option on this pair we already discussed pairs a bit before let's look at it in more detail so to create a pair of values you put them between parenthesis and with a comma in between so A1 comma A2 between parenthesis and they can be of different types so for example you could have a pair where the first element is 42 an INT and the second element is a string and there the type would be sp. pair and between square brackets sp. in comma sp. string if you want to extract values from the pair you can extract the first element by using sp. FST for first the this would get you 42 here and for the second element you use sp. snd D this would give you ABC it's also possible to extract both components at once into two variables so here if on the right hand side of the equal operator you have some pair on the left hand side you can put the name of two variables between parentheses this will extract the first value of the pair in a and the second value of the pair in B and of course here it could simply be a variable that contains a pair or anything else it doesn't have to be the actual values so that's a good way to obtain a Content a pair into two variables in one single instruction this actually works for topples so so values that have more than two elements you could write a tole with three elements like this and you could extract all these three elements into three variables a b and c like this if you want to do arithmetic operations on mutes for the addition addition and subtraction if you add or subtract mutes the result will be a mutes if you subtract and the result is negative you will get an exception if you want to multiply mes you have to multiply them with a n if you have five T you can have twice that so five T times the natural two or you could do 2 * 5 T and the result will be a number of t 10 t for that you use sp. null since the two operant are of different types and so you multiply X by your natural value where X is of type mutes if you want to divide mutes by on that we have a special instruction for that to do computations we will see in a little bit that we call sp. split tokens that can do divisions and more on mutes if you want to do any other type of operations with mutes you will need to convert the values into other kinds of types when manipulating mutes you you need to be careful about overflows for inut we already saw that there is no upper limit or negative limit on how big or small a value can be except for the storage and the cost of storing these values but for mutes it's different mutes are currently stored using 64 bits integers and as mutes is a very small unit it's a million of AES that means you pretty quickly end up with big value so for example if we take 5,000 T that's 5,000 time a million mes so the actual value you store is 5 billion so if you need to square 5,000 test for example if you want to do some Financial computation that involves the square of the price Etc you may end up squaring a number of tests but you only need to square 5,000 T to get a result that won't fit in 64 bits because you're squaring 5 billion new TZ and 5 billion squared doesn't fit in 64 bits of course you cannot multiply 5,000 TZ by 5,000 Tes so you would have to use a type conversion to multiply a number of Tes with a number of nut and that get this result but it's really important to keep in mind because if you end up with a value that causes an overflow then the call to the smart contract will fail so you won't get the wrong result but the call Will Fail therefore you could be stuck and the funs would be stuck in your contract so be really careful when multiplying Tes with big values talking about type conversions we already said that if you can avoid it it's better to avoid any kind of type conversions usually it's a bad sign if you need to convert a type into another but sometimes you really do need to convert type so when you do need to convert types here is how you do it first for some of them you will need a special module the sp. utils module to make it available in your contract you need to declare it in your test scenario so in the test scenario after the name of the test we before had just made the only module that contain your smart contract but now we need a list of modules to have sp. UTS and then still main so between square brackets you put the list of the modules separated by a comma so now that you have the utils module available in your contract you can do some conversions you can convert a mutes value to a natural so for example if you convert one mutes you will get the number one as a nut and in the other direction you can convert any nut to a number of mutes or to a number of Tes so if you use not two mes and then you pass one you will get one mes but if you want to avoid having to put big numbers you can directly convert to T so if you call not toes with the value one you will get one TZ which is a million mutes if you want to convert a nut to an INT you simply write SP do2 int of the natural you don't need the SP doils module and then of course you will get an in to convert an in to a nut if you know for sure that the int is positive you can use SP do as n of your int value if the number is negative this will fail and make your contract fail let's play with an example in the storage we will store an integer value that we initialize with the int one and a n value that we initialize with a n zero the values don't really matter and I created one entry point per basic operation so one for add subtraction multiplication negation Division and the module and some with a shorthand operators that you can play with and then we have some test where we just call each of them if I simply run it it doesn't work it tells me I cannot subtract unknown and unknown for the subtraction operator so here that's because when we do the subtraction the result is an INT but the result of our subtraction is always an NT so we don't know what those are they could be Naturals they could be integers there's no way to know for sure what the type of X and the type of Y are just by knowing that the result is an integer so we have to help the type inference system so we simply say that X let's say is a nut and Y we could say it's um in maybe but now if we do that it will say no there's a problem the subtraction operators must have two arguments of the same type and I put an INT and a n so of course I could simply put a nut here and it would work now I have an issue with division so similarly it doesn't know what I'm dividing by so I need to say what the types are so I'll just say I'm dividing two Naturals so not works so here since the result is an end it deduces that X and Y are ends let's say X is a nut now if I run this it's telling me nope you cannot mismatch int and nut because the result is an INT if one is a nut maybe the other one may be an INT but we cannot add n an INT and if it's if the other one isn't n then the result wouldn't be an INT so here what I could do is either use SP do add X and Y but then it tells me I don't know what Y is so let's say Y is a NT and it would work or we could say well we first convert X to an in so let's say SP do 2 N of x plus Y and this would work as well so what I recommend you do is take this ample and play with it change the types of different values and see what happens and find ways to fix it and look at what the error messages look like Etc so for example one thing we could do is try to put the result of the subtraction as a n so this up course would fail because the result is an in I try to store it in the nut but I could try to do sp do as nut of the result which would work but that's only because I'm subtracting three from five so if I subtract seven here then it would tell me nope it doesn't work the result fails but here the message is not very clear because it's internally it's using options to manipulate the result because the underlying op operation returns an option and is none if the result is invalid so if before I use asut I need to make sure I know for sure that X is greater than y so play around with it now we can have a similar example where we play around with mutes here we have this financial value that's of type Tes and then we have operators to add subtract multiply and divide if I simp run it like that it's going to tell me it doesn't like multiplying two mutas and that's because my example multiply I did T time T so this doesn't work I can only multiply a mutes with a nut so let's say I want to do five T * three but it still doesn't work because again The Operators expect the two values to be of the same type and that's not the case here so before I even tries to run my test is just inferring from the type of financial value that those two values should be of the same type and type T so here I need to use sp. M then again for the subtraction it tells me I don't know what those are so I need to cast them and if I cast the first one it's going to deduct that the second one is the same type and now it's telling me that the multiplication it doesn't know what I'm trying to multiply because with sp. Mo can mully all kinds of things and obtain all kinds of types so I should say that X is of type mutas and Y is of type not for division same thing I need to provide the types let's say x is a mutas why let's try with not doesn't like it I need to use ediv of X comma y so this will return an option on a pair so I can do do unwrap sum and if I want to get the result I can do sp. FS of that pair and here it's telling me it's expected a nut but got mes so that's because when I call it I want to divide by but I simply put it as here and now it works so again play around with it and see what happens one operation we really often want to do when manipulating money is compute percentages but because there is no floating Point type on tesos um to avoid bugs related to approximations Etc we cannot compute 20% of a value by simply multiplying by 0.2 so we have to multiply by 20 then divide by 100 to make that easier especially when it comes to the types we have a special operation that we can use to compute any kind of percentages it's called split tokens and split tokens will take three parameters an amount a quantity and a total quantity and they will do the computation amount times quantity divided by the total quantity Where amount is a number of T and quantity and total quantity are of Type n and so this can be used to compute percentages so if we want to compute 20% of some amount we can call sp. split tokens of that amount comma 20 comma 100 of course we could also do the same with one and five as long as the ratio between this number and this number is what we want 20% it's not always 100 because we can consider having other kinds of percentages that are maybe smaller than 1% for example 0.1% so here all we would have to do is do one per thousand so we use quantity one total quantity 1,000 and this will compute 0.1% of 5,000 T okay let's use all this in an example and for an example we'll create our first decentralized Finance contract I'm definitely not an expert in finance and this is not a contract that we audited Etc it's really for educational purposes but we can show you how you can create a contract that people can lend money to for the purpose of gaining some interest over time we already presented the idea of baking and the fact that while baking ERS put some Tes at stake to get the rewards people who don't want to be Bakers by themselves can delegate their own TZ to the baker of their choice to get a share of the rewards when you pick a baker you can pick them based on multiple criteria you can check how much of the rewards they will share with you different bakers will share different percentages you can also check if they do their job well so if they ever miss the opportunity to create a blog because that's when they do create a blog that they get their reward and then share them with you so check how often this happens and of course you also want to check how they vote when there's a call for a vote for a new Amendment usually the reward you get when delegating your TZ is around 5% a year but there is no guarantee of that there's always a risk that after you delegate your test to a baker this Baker doesn't do their job well and misses a lot of blocks or doesn't pay you your Rewards or simply disappears and stop being a baker or changes address for example so when you delegate your Tes if you want to make sure that you get your share of the rewards you need to regularly check what your Baker is doing so you cannot just sit down wait a year and then get your profit there's a risk you wouldn't get anything your test themselves are not at risk because even if the baker behaves badly and gets slashed your own test that you delegate don't get slashed but the risk is that you won't get your rewards so the example we work on is a smart contract that offers the service for anyone who doesn't want to worry about that still want to delegate their test to some Baker They Don't Really necessarily want to worry about which Baker they just want to be assured to have some yearly interest without any risk at all so pause the video and think how you would create such a contract that guarantees to whoever is putting their money that they will get their rewards so what we will do is our first decentralized Finance contract that will enable the externalization of the baker selection and monitoring Etc making sure your Baker does a good job in exchange it will take a small share of your rewards so it will guarantee you that you will get get a fixed reward of 4% a year to make sure that whatever happens you will get this 4% this amount for a whole year will be deposited in advance in the contract and stuck there for you to get your guaranteed interest but the owner if they do their job well delegate the balance of the contract to the right Baker monitor it Etc and make sure they get 5% and they will be able to keep anything that's beyond the 4% that they owe you in exchange for taking the risks and we will do that in a contract that handles only one lender at a time so only one person will be using this contract at a time pause the video and think a bit about how you would do that okay so we will have two people interacting with this contract the lender so that's the one that has money to invest in the contract and want to get 4% back so the lender will be able to deposit their funds using a deposit entry point and put some test on the contract and at some point in the future when they want to get their deposit back plus their earnings they will call a withdraw entry point on the other side the owner will be able to control what beger to delegate the balance of the contract to and they will have a set delegate and true point to say I want to delegate to this Baker and they can change it at any time is their responsibility to make sure they pick the right Baker because it will impact how much they earn of course at some point they may want to withdraw their own funds so we need to have an owner withdraw entry point for the owner to collect any amount that they are allowed to withdraw they always need to make sure there's enough Reserve in the contract to pay whatever the lender has deposited plus one year of yields finally since the need is reserved in the contract need to have a default entry point to deposit this Reserve at the beginning before the lender deposits their own funds but this is also the entry point that Bakers use to send money to the contract when a baker send their rewards to an address that delegated to them they simply send test to this address so we need to make sure that our smart contract has a default entry point that accepts the rewards quick reminder the default entry point of a smart contract is the entry point that is called whenever you simply send some test to the contract if there is no such entry point the transfer will fail and if this entry point fails then the transfer will fail and you won't get the test so if all you want to do is accept direct transfers from anyone you can create this entry point called default that doesn't take any parameter and doesn't do anything so with the instruction pass but remember that any entry point can accept TZ as long as the call is valid okay so in our yield fing contract we will do a number of computations so first we need to add a ramp of period so it's a period of time where you don't get any yield and the reason is that when you delegate your Tes to a baker you don't immediately start earning you need to wait for the baker to get the opportunity to bake a block so to keep it simple we simply wait let's say 3 weeks before we start paying interest to the lender after that ramp period the yield becomes proportional to the time between the deposit after that rer period and the withdrawal so if you live your money for one year you would get exactly the annual yield rate if you wait for 6 month you will get half of that as interest as we said earlier we always want the owner to leave a reserve so that they can always pay one year of Interest so we will have a computation to do that where we multiply the deposited amount so deposited amount is whatever the lender has deposited multiply that by one because they at least should have that amount kept in the balance of the contract plus the annual yid rate so let's say 4% of that amount when the lender withdraws from the contract the amount they should get is their deposit times one plus their deposit multiply by the annual yield rate and multiply by what percentage of the Year passed since the deposited so the duration since the deposit after the rampant period divided by one year and here is how we compute this direction so we take the current date minus the deposit date and we substract the rampup duration now if we look at the contract in more detail we can focus on what we need to store so we need to store the address of the owner the address of the lender how much money was deposited on the contract when it was deposited we can store the annual yield rate that we promise that we will give to the lender and then how much time we need to wait before the yield starts so the ramp up duration then we have our different entry points we already talked about the default entry point we need the owner withdraw entry point for the owner to be able to withdraw some amount from the contract and then we will check that it's indeed the owner calling we check that the amount they leave in a contract is sufficient and then we send the amount request to them if everything is good we'll have the set delegate entry point that takt an address it's technically an option on an address as a parameter it will simply check that the caller is the owner only the owner may decide which Baker to delegate to to and then they will simply change the delegate to this address we need the deposit entry point for the lender to deposit funds and when we do that we check that there's not already some amount been deposited so we cannot increase how much we have in the contract we can simply deposit once then withdraw and if we want to start again we can deposit a bigger amount or a smaller amount so when we deposit keep things simple we check that the current deposit is zero and then we update this value and we keep track of when it was deposited finally when the lender tries to withdraw some funds we check that the caller is indeed the lender then we compute how long it has been since the lender deposited the amount and we subtract the ramp up duration from that and finally we compute how much they should get back so that the amount that deposited plus this amount times the yield so they are guaranteed annual yield rate times the proportion of the year that they got the money for then finally to say that the money has been reimbursed so we can say deposited amount is back to zero so that the owner can now withdraw everything because they don't need to leave any reserve anymore since there's no nothing deposited so now we can check the actual code so we see the constructure that initializes everything the owner the lender deposited demount deposit date here we set the deposit data at zero we could say well nothing has been deposited yet so why not use an option but again an option will make things more complicated here it's easier to just set the data at zero we see that we have our default entry point that doesn't do anything just pass uh we have our set delegate entry point that simply takes the address of the new delegate technically an option we check that it's the owner wanting to change a delegate and then we call sp. set delegate so this sets the Delegate for the whatever test are in the balance of the contract to this address we have a deposit entry point for the lender to deposit their money so we check that it's the lender we check that there's not already some money being deposited which would cause a mess in all the computations we then store the amount in deposit amount and we store the current date in deposit date now when the user wants to withdraw their funds again we check that it's indeed the lender we compute the duration since they put the money in so for that we take the deposit date we add the ramp up duration that's a number of seconds we subtract that from the current time and then we convert it to that there's an easy way easier way to convert to n here we can simply do as nut so that's the duration and then we take the duration of a year so that's approximate um but it's good enough we say year is 365 days and then we compute the yield for one year so we multiply the deposited amount times the annual yield rate that's at percentage let's say 4% this would be four so that's one year yield multipli by 100 then using the duration we compute the duration yield so how much for if this is how much for one year multiply by 100 this would be how much for this direction so we use split tokens to take one year yield and we for this duration divided one one year times 100 so that g us how much yield we should get for this duration then we simply send that amount plus the deposit itself back to the lender and then we reset everything deposited amount to zero and deposit de to zero finally the owner May withdraw at any time but always needs to keep a reserve that's enough to pay for one year of Interest so here we check that the owner calling owner withdraw we compute one year of yield again using split tokens so we take the deposit amount and we take the annual yeld rate out of that so 4% of that amount and the reserve should be whatever the user has deposited plus that interest if the amount that the owner is requesting to withdraw leaves enough so the balance minus whatever we take is more than this Reserve that we have to leave then we can send them that amount and that's it if we run it we can see that we initialize it with an annual y rate of 4% initially everything is zero then we set up this random duration ramp up duration I think that's 3 weeks the owner transfers five TZ to allow for some amount of deposit then the user deposits 100 T then we check that if we try to deposit again this doesn't work we can only have one deposit at a time on the contract if we try to withdraw with the wrong owner we cannot do that if we try to withdraw too much it doesn't work either but we can here withdraw one TZ and we still have enough to pay for one year of yields here we use set delegate to change the delegate of the contract so which Baker We delegate to and then here the owner withdrawals after some anount of time that we set here that corresponds to a year plus the ramp period and we see that they received 104 Tes so they deposited 100 Tes and now they get 104 back so that could be a very nice way to provide a service but again this contract has not been audited um this is just for educational purposes so don't trust it as is now it's your turn to work on an exercise where you do some computations and we'll take this opportunity to play a little bit with interesting nfts so the idea is that with smart contract we could show that you can create digital objects that has an owner that can be bought Etc but you can add interesting properties that can be very unique either Collectibles or you can even run interesting social experiments so let's try to do one we will create an nft that has a price that automatically increases by 10% after every sale so the owner of the nft doesn't set the price at which they sell it the price is automatically 10% more than whatever they paid for so pause the video think of how you would do that and give it a try so if we want to create an nft that has a price that increases by 10% after every sale we will need to remove the set price entry point point from our nft contract and then we will need to change the buy entry point so that it automatically sets the new price at 10% more than the previous price after the sale so if we do that and you start with an nft that's worth one TZ after the first sale it would be 1.10 TZ after 10 sales it will be 2.59 TZ and after 100 sales only this is exponential it will be 13,780 t pause the video and think about how you would change your contract and implement this let's look at the solution the contract we get is actually pretty basic we have three values in the storage the owner the Met data and our price that we set with an initial price and we only have one entry point left the buy entry point that simply checks that whoever is trying to buy is sending the right price then sends that amount to the owner and changes the owner of the nft and then computes the new price using sp. split tokens so we take the old price and we take 10% of that price and we add it to the old price and we can give it a try and calling a couple times the buy entry points and we see okay we initialize with five Tes so the first purchase is the actual price five T so we transfer five T back to the owner then the next time someone wants to buy then it became 5.5 T So 10% more and so we transfer 5.5 t to the new owner and finally if we try to purchase with the wrong amount so six t it's incorrect because now the price is 6.05 as we ver ify here so all good so the sad thing about this is that if you deploy this contract all you will get is those initial five tests if the price keep increasing and many people buy it and sell it it would end up being worth tens of thousands but as the initial creator of this great idea you will only get 5% wouldn't it be nice if you could get a percentage of every sale and therefore if your experiment Bec very successful then you would get a nice reward so what we want to do is create an nft that gives royalties to its author the idea is that every time the nft is sold we want the author of The nft to get 5% of the price of the sale and of course the 95% remaining should go to the owner of the nft so try to add this feature to your nft contract of course you will need to add an author in in the storage that is separate from the owner and when you will compute the shares that the owner and the author have you can use sp. spit tokens so pause the video and give it a try let's take a look at the solution here we added two fields in the storage the author and the percentage of each cell that the author should get then we modified or buy entry point to compute the share that the author should get so for that we use split tokens and we take the price and we compute the author rate so 5% and for the owner share we take whatever is left so the price that was just paid minus the share of the author it's important to do that rather than do another speed token maybe with 95% because there's always a risk that with some approximations and running Etc the total wouldn't be 100% in which case the sale couldn't happen because you try to send even a tiny bit more than 100% everything would fail so it's safe for the last person you send test to to send whatever is left after everything else has been added we'll talk about that a bit more in a minute then we send the owner share to the owner and the author share to the author finally we still have our formula to increase the price and then we update the owner you could wonder why we didn't send simply the balance to the last person for example to the owner after sending their share to the author but it's important to have in mind that when you send Tes using sp. send it's not actually directly sending the Tes to the owner it's adding a transaction to the list of transactions that will be executed after the end of our entry point so it's not executed immediately and it definitely doesn't change the balance the balance that you read in this entry point stays the same for the whole direction of the entry point but later on the transfer will be done to the owner and then the transfer will be done to the author or at least will be attempted again you need to be careful when splitting the balance if we did it this way it's a bit unusual but if we did it by subtracting to the price the share that the other person would get so here we do split tokens we take the price uh whatever is sent to the author as a percentage then 100 minus other R so we subtract 95% of the price from the price for to get what is sent to the author and here we do the same with the owner if we did it in this bit unusual way but when you look at the computation everything seems to be good you send the price minus 95% to the author and then you send the price minus 5% to the owner this should give 100% right but if you do that with some value of the price you would end up with running issues where this value is a tiny bit less than 95% therefore the Alor share is a tiny bit more than 4 or five% so it would be if the um rate is 4% I would be 4.1 and then the owner share would be 96 6.1 so the total would be 100.2 and therefore this would fail because there's not enough money in the balance of the contract you cannot send 100 point something per of the amount this would fail so again the best practice is for the last amount that you sent compute it as the total that you have so the balance of the contract for example the price minus whatever you send to the others this would avoid failures due to running issu that would get your contract completely stuck unfortunately there's still a flaw in our contract so if you look at this piece of code can you identify the flaw please pause the video and think about it so this is a flaw we already talked about the author could block any sale and the reason is that the author here could be the address of a smart contract that has a default entry point that they can switch to reject any payment so this transaction could be blocked by the author so the author would say nope the nft I created years ago I don't want it to be sold anymore or maybe they could try to use it to extort money from the current owner that really wants to sell it and needs the money so this could be dangerous so again the best practice is to let the author claim their share using a separate claim entry point that they can call you could say the owner can do this same and reject the the transfer but in this case it doesn't really matter here the whole point is that the owner wants to sell so if they refuse to sell well they just don't get their money this is not a big deal but for the author it's really important they shouldn't be able to block the sell so the way to do it is to remove this line so that we don't directly send the money to the author but we add an entry point claim author rate that the author can use to get whatever is left in the balance of the contract so we check that it's indeed the author and we send them the current balance of the contract so you may wonder if there could be a flaw if the author called this at the wrong time so for example when we buy we send the test to the balance of the contract then we check okay is the amount right we compute the share of the author Etc and then we send the owner but you could think in the meantime the balance contains all the money that is owed to the owner so couldn't the author call this right at the right time in the middle of this to steal the balance of the contract and the answer is no thankfully because the execution of an entry point is atomic nothing else can happen while this is running there is no race condition there's no parallel execution everything is serialized so this code and any transaction generated by the entry point will be completely finished before anyone can call any other entry point everything is serialized and done in sequence so you'll safe from that kind of issues in this module you will learn how to use records in smart p and will'll apply this to an example your first Dynamic nft a record is a data structure that allows you to group several values within a single object single value each of these values has its own name within the record and the different values may have different types for example you could create a record to store data about a person so you would have their first name that is a string their last name also a string and for example their age that would be a n we already manipulated records implicitly when we call called a smart contract with multiple parameters so when you call an entry point and you have to give the name of every parameter that was creating a record since in reality an entry point only takes one parameter so if you want to pass multiple ones you have to use uh record but now we'll work on explicit records to create a record you use the syntax sp. record and between parentheses the list of fields with the name equals the value and all separated with commas so here we have a record with a integer or natural named field one and then the string named field two once you have a variable that contains a record you can access any field simply by using the name of the record Dot and the name of the attribute so here if you create a record with two values X and Y we can extract the value of x by doing record. X when you need to describe the type of a record this is how you do it so you may notice that anytime we Define a type for example when we created a pair or an option we used square brackets after the name of the type uh the record is basically the exception to that for technical reasons related to how python works so in this case we use regular parenthesis so creating a record type looks very similar to creating a record value so we do sp. record and then between parenthesis the list of fields and this time the only difference is that instead of providing the value of each field we provide the type of each field so here field one equals sp. not and field 2 equals sp. string you may sometimes end up having to provide the type of a record multiple times within your code and it can become quite large if you have many fields in a record so to save your time you can name the type by creating what we call a type abbreviation that you would put outside of any contract within the main module so for that you would create a tie by giving the name you want to associate to it so here I wrote T record as the name for some example then colum and the keyword type equals and then the description of the type and then within your contract every time you needed to describe the type of your recard you can put this name instead let's work on an example and we will create a dynamic nft so usually an nft is associated with some static image or maybe some video or some music that you may actually want to store offchain and then you only store the hush in the metadata but for things like games you may want to have nfts that have different properties that evolve over time and with a set of rules on how they can evolve so we'll create this kind of nft and we will make our nft contract an nft of some creature that we would use in a game so we will give this creature two attributes a name and a size and we want to store both of them in the metadata field of our nft then we'll be able to add a feed entry point where we can pay one TZ and that will increase the size of the creature by one so we will increase this at distribute by one every time we call feed so let's look at the contract here in the Constructor we don't actually change anything because we still store whatever metadata is sent and we don't need to specify the type it will be specified directly in the taste case or inferred from other aspects of the contract for set price nothing changed buy nothing changed but now we add this new entry point feed where we check that the color paid one t and we simply change the size attribute of metadata and increase it by one so that's all we had to change in the contract itself and in the test that's where we initialized the storage with a metadata that is composed of a record so we create sp. record with an attribute name say let's call it beast and a size that we initialize at 10 so here here we used to just have a single value a string and now we provide a record and that's about it in our test we add this call to feed where we pay one TZ using Alice's account you may notice that anyone is allowed to feed the beast it doesn't have to be the owner so let's run it and we can see that now in the metadata we have this record presented using two columns one for the name one for the size and so we have the name Beast size 10 and we set the price and we fit it and when we check the details you can see that now the med contains a name that's Ste beast but then we crease the size to 11 records are actually not supported by the underlying mikon language there is no such thing as a record in mikon so what you do to create a record is to use nested pairs so as you remember pairs enable you to group two values with different types and so if you create a record with just two values then it's just simply a pair but if you create a record with three values then we need to use two pairs and the idea is that the first element of the pair would simply be the first of the three element but the second element of the pair would be another pair with the next two elements so like this so we have a pair that contains an regular element an integer and then another pair pair with two values in mikon we write it like this or a first pair with 42 and then the second element is a pair with 12 and three this way of organizing it is what we call the right C presentation so if we were to add another element we would again replace the last element of the inside pair and then replace it with another pair that contains three and then the next value we would like to add so if we keep adding it looks like that it just looks like a com with a handle and a different teeth it would be possible to represent a record in using a different approach and instead of always using the second element and replacing it with a new pair we could do the same but on the left side so take the first element of the pair and then replace it with its own pair we would still put the value in this order so if you Traverse the tree from left to right you would obtain all the different values so this would be what we call the left com representation both are perfectly valid and both are possible with mikin and it's really a matter of convention whether we use right comb or left com different languages actually may use different representations but if you want to be able to make two contracts compatible and make sure they understand each other you can specify what layout you want to use so if you want to use the righton approach after the creation of your record you can add dot layout out and then between parenthesis you describe the structure so here we have the first element of the pair and then another pair with the two elements the names of the two elements between double quotes on the other hand if you want to use the left C layout we would have to do dot layout and then the first pair with A and B comma name of the last element so sometimes you your contract has to interact with another contract that uses a specific layout that may be different for the default layout your language is producing so that's why you need that now it's your turn to work on an exercise let's change this uh Dynamic nft contract to add an extra attribute to the metadata we will call it strength and then we will add a train entry point that somebody can call but only once within a window of 24 hours you may never call it more than once within a given 24 hours window so with a strain and two point if the size is more than 10 it will reduce the size by one and then in exchange increase the strength by one so you train you lose a bit of weight but you gain some strength pause the video and give it a try let's look at a solution so in the constructure we still don't change anything to the metadata but we need to add an extra field in the storage to keep track of one is the last last time we trained our creature so we add this last training parameter we set it at a time St zero of course this is way in the past so we don't need to worry about how soon we're going to be able to train it again we don't need to use an option we don't change set price or buy or the feed entry point but we add this train entry point we check that the size is not too small for it to be trained so it should be at least 10 we check that it's been more than one day since the last time we trained it so we add one day to last training and we compare that to the current time and if we're not yet passed this then we output too soon then we Mark the last training at the current time and then we apply the changes we reduce the size by one and we increase the strength by one in our test we initialize the strength at zero and then we try different tests so we start by feeding the Beast to increase the size by one then we train it to increase the strength by one and reduce the size by 10 we fit it again to train it a different time and see if everything works it would be good here to add scenario at C1 do data do strength equals 2 then we try to train it it again but the size is still 10 let's verify that too so we're too small to train it so we need to feed it again then train it again and then we can verify that the strength is three and the size is back to 10 and we fit it one more time but we're trying to train it right away so it's 3 days plus 1 second and this should fail because it's too soon but if we wait a bit more then this should work and we can check that we had the strength at four and the size is back to 10 let's give it a try and here of course I forgot to put strength within the method record so I need to change that and add this here here here and there and it's all good so now we can check that we start with the name Beast size 10 strength zero and after we feed it the size increased after we train it the strength increased the size decreased we feed it again Etc then we try right too small too soon and at the end as we already check in the code the size is at 10 and the strength is back to four all good in this video you will learn how to use maps and big maps in the storage of your smart contracts and this will enable you to go from small smart contracts that only store a few informations uh single nft uh long single string to large scale smart contracts that can store whole databases of data many ffts and potentially the assets of millions of users a map is a data structure that store key value Pairs and the keys and values in a map can be of almost any type all the keys have to be of the same type and all the values have to be of the same type so for example we could store data about different countries we could create a map that stores the population of each country where the key would be the name of the country a string and the value would be the population of a country and that so for France you would have the population of France for the key Italy you would have the population of Italy Etc similarly you could create a map that stores multiple informations about each country where each entry would be a record so the key would still be a string but the value would be a record with not only the population but the size of the country and other information to create a map all you have to do is write a pair of curly brackets that that would create an empty map but you can also create a map that already has a few elements so you put the key column the value and then comma the next element you can put as many element as you want in the initial map separated with commas and every time the key column the value if you need to specify the type of your map you simply write sp. map and between square brackets two values separated by comma first type of the key comma the type of the value when you want to manipulate entries you use the name of your map and the value of the key between square brackets so to add or update an entry you write the name of your map and then between square brackets the key that you want to change and then you can assign a value to it if you want to delete an entry you simply write Dell and then the name of your map and between square brackets the value of the key that you want to delete from your map and more generally anytime you want to access any entry and value corresponding to a key you write the name of the map and between square brackets the value of the key if you want to check if a map contains a certain entry based on its key you can write my map dot contains then between parentheses the value of the key this will return true if the map contains an entry with this key and false otherwise with the map you you can also get information such as its size you can write sp. Len of your map and this will return the size of the map the number of entries in the map so for example if I have a map with two entries then if I call sp. Len of that map it would return to I can also request the list of items within my map and we'll talk about list later but basically if you call for given map do items it will turn a list where each element will be a record that contains two field a field key with the value of the key of that element and a field value with the value of the corresponding entry so this way we'll see that you can access all the elements of the map and look through them by numerating elements of the list if you only want a list of keys you can use dot keys and so for example if you do this map. Keys it will return a list of keys so one and two in the list similarly if you only want the values you use dot values and then will return a list that contains all the values before you start manipulating map there is something really important you have to have in mind and it concerns the costs and limitation associated with storing a lot of data between uses of a smart contract the storage of this contract is serialized so it is stored as a sequence of btes in a compact way and whenever you call the conract the sequence of bytes needs to be distalized to make it in the form that is convenient uh to manipulate so distalizing is taking this packed bite sequence and then converting it into a format that's really easy to use and manipulate that is typed Etc where we can efficiently access the data but once the entry point is over the new content of the storage has to to be serialized again until the next Call of the smart contract so convert it again to a simple squence of bites and this is done to save memory and make it possible to store this data on disk in an efficient manner but distalizing the storage at the beginning of every smart contract call and resizing it consumes CPU there's quite a few competition that you need to do to deserialize and resize so as the size of your storage gets bigger you increase the amount of CPU that you're using to call this smart contract and we cannot use an infinite amount of CPU for calling a smart contract uh we need every node to be able to run it so it has to be fast enough and there's only so much computation we can reasonably do to execute all of the transactions in a given block So to avoid abuse and transactions that take huge amount of CPU to be executed we have a system called Gaz that is an estimation of the amount of CPU needed to execute a given transaction like even smart contract calls for example we cannot know exactly how much CPU will be used because it really depends on what kind of computer you're running what kind of microprocessor Etc so this is why we need not the exact amount of CPU but some estimation that would be the amount of CPU that an average computer would spend to execute this uh transaction so for every operation every addition every cryptographic operation that we can run in a smart contract we have an estimation of how much CPU it will consume and so we have a corresponding gas cost of this operation so to limit the amount of computation that is done for a transaction and more generally for a block we use a financial incentive by having the color of this transaction pay for this spend Gap so as part of the fee they pay to the baker they pay for the amount of gas needed to execute the transaction and therefore they pay for the CPU they will be using on all the nodes and for each transaction there's an upper limit of how much gas we can spend and similarly for each block there's a limit on how much gas all of the transactions of the block can spend so these limitations mean that if the storage of your smart contract gets too big simply the fact that you need to deserialize and res serialize content before and after the execution of your smart contract means that you could reach this limit and the contract would fail so if you do a smart contract call and dis realizing all of the storage and resizing it costs more in terms of gas than the maximum amount of gas you can spend in one transaction then your call will fail and not be executed at all we already discussed the fact that most types have no limits in terms of how much you can store so we can store nuts and ins that are can be as large as you like time stamps can be as far in the future as you want strings don't have a specific length limits and similarly there is no hardcoded limit to how many entries you can store in a map but in practice there are two limits the first one is that every time you increase the storage so every time you add an entry to your map you have to pay for that extra storage and the second limit again is that if the storage gets too big the realizing and resizing it may exceed the gas limit so for these two reasons there's a limit to how many entries you can add in your map this limit will depend on how big the keys and values are and again if this happens to you your contract will be stuck any call will fail and any funds you have in the contract may be stuck forever to avoid the issue of exceeding the gas limits of a transaction due to having too much in your storage we can use a data structure that is similar to map and is called Big Maps big maaps are pretty much the same as Maps but with a few differences when your storage contains a big map instead of deserializing all of the content of the big map and resizing it at the end of your call we only deserialize and serialize individual entries in the big map that the contract call uses so instead of having to distalize the whole content of the big map you only distalize and resize the entries that you access to during your smart contract call so this removes the limitation of how much you can put in a big map as long as you only access a few entries within a single call of a smart contract there is no limit on how many entries you can have in your big map the syntax to use a big map is pretty much the same as the map except that you will use sp. big map instead of sp. map but many of the operations like getting the length of the big map getting the list of all the entries the keys the values are not available for big Maps so that means if you want to get any information about the content of a big map you have to know the key to the entries you cannot list all the keys you cannot enumerate them all you can say is is this key a available in my big map and what is the value for this key this limitation only applies on chain as everything is public on a blockchain outside of a smart contract you can request information about a map from a node and you can find out all of the entries in the a big map but on chain from within a smart contract you cannot list all the entries you can only request the entries that you already know the key so if we recap the syntax of a big map to create a big map instead of Simply a pair of curly brackets we have to use sp. big map so this will create an empty big map and if we want to have values then the syntax is the same for map curly brackets the different entries separated with comma and for each entry the key column and the value if we want to express the type of a big map we write sp. big map and between square brackets the type of the key comma the type of the value so very similar to map except we add big map here accessing deleting entries Etc is done exactly the same as for maps no difference but getting the size of the big map getting the list of entries the keys and values is simply not available because that would require dis realizing the whole big map which defeats the purpose of using big Maps let's take an example so far Our Endless wall was using a string to store all of the content so it was not really endless if the string got too long eventually it would be too big to be deserialized within a single call it would use too much G just to deserialize the content of our string so with a big map we can fix this instead of storing a long string we can store a big map of Records so in our big map the key would be for example the address of the sender so who is writing on on the wall and the value would be a record that contains the message a string and the date a time stamp so let's take a look at the contract we have this truly endless World contract and in storage we have a messages attribute that we initialize with an empty big map we then indicate what the type of this big map is by using sp. cast the attribute and then the type so SP big map and it between square brackets the type of the key an address so that would be the address of the user who sends the message and then the value a record that contains the content of the message a text or a string but also the date of the last message a time stamp in the right message entry point we have a text parameter so that's a message that the user wants to write we create a data that contains the record we would add if this is a new entry so with the content of the text and the current date but then we check if our big map already contains an entry for this sender then instead of using this new record we fetch the current data we have for the sender then we add the new text after a comma and we update the time stamp to the current time finally we write the data in the big map at the address of the sender so this will create a new entry if there is none and it will update the existing entry if there was already one now that this is necessary in both cases so even if we got the existing entry and modified it this wouldn't be sufficient to actually write the new entry to memory we always have to have this instruction to write back the data in the big map so we're not manipulating a reference to some data in the big map we have to explicitly write again and overwrite the content of this entry so we have this small test where we simply write a couple messages using Bob's address and so we can see that initially we have this empty big map then after the first call we have an entry for this key that's Bob's address and then we have this first message and sometime St zero and then after another call then we see that we updated the text with an extra message so here we have used a new syntax that we need to introduce the if and if lse syntax that's the typical python if and IFL syntax so you can write if this condition colon and then you have a block of code that you will execute only if this condition is true and if if you want to have an alternative piece of code you can write if the condition column and then the block indented block where you put a code to execute if the condition is true and then at the same indentation level as the if we can do else column and then we put here the code that we execute if the condition is not true we don't use a lot of conditional instructions in smart contracts so you won't see a lot of if and L's but once in a while it's necessary okay so now it's your turn to work on an exercise you will create a smart contract that is able to handle multiple nfps the approach we use so far to have one contract for each nft is really not ideal it can be unnecessarily costly to deploy one contract for each nft you want to Min and also makes it pretty hard to keep track of all the nfts so it's a lot better to have a smart contract that can store many nfts and for example a whole collection of nfts so pause the video and think about how you would do that and don't hesitate to start writing the code so if we want to handle multiple nfts we can store all of their content in a big map now that we know that we have to think okay what should be the key and what should be the value for this big map and so we have to think again about what an nft is it needs a unique identifier and it's an owner some metadata and a way to transfer or sell it and in this situation we will need to be able to create new nfts within our contract so we will need a mint entry point to create new nfts so if that helps you pause the video and try to continue working on your contract if we think more precisely about what we need to have in our storage we have to think about what we will use as a unique identifier for each nft this time the contract address won't be sufficient anymore it is still necessary so that you cannot simply write a separate contract with nfts that have the same ideas of all contract so the address of the contract will be part of the uniqueness of each nft but we will need something extra to differentiate between nfts that are stored in the same contract to do that we can simply assign each nft in our contract with a number so we can just start with one for the first nft two for the second Etc it's really that simple as long as these numbers are unique so we can store a nut that starts at one and every time we mint a new nft we increment it by one so this gives a number for each of our nft and we can use it as a key for the big map that will store all the information about our nfts again if that helps you please pause the video and continue to work on the code if not we can continue with some help so let's look at the code structure of this new smart contract in the storage we want to keep this counter this next idea that will will use as the value for the key for the next nft we want to make and everything else can be stored in a big map that stores all the information about the nfts we meant the key would be this token ID so the value of the cter that's with one for the first nft then two Etc and then in the value we have all of the data associated with this nft so we will have a record that contains the owner of this nft the current owner the original author of The nft as this is the type of nft where we still want to pay royalties and increase the price by 10% every time we sell it then we have the metadata and the current price then we need two entry points one entry point to Mint a new nft where we pass the Mt data so this will create a new entry in the tokens big map with as key the current value of next idea we can set the owner and the author to the address of the caller we can set metadata to the value of the parameters and to Mint and then we can initialize price to one test finally we need to increment next ID so that we have a new idea for the next token that will be minted then we need to buy entry point for someone to buy a given token and so this time we pass a parameter that is the number of the nft we want to purchase so it's token idea first we can check that is token exists in our big map then we can check that the amount sent by the buyer is equal to the token's price then we can send 5% of the price to the author then send the rest to the current owner finally we can replace owner with a new owner and then we can increase the price by 10% let's take a look at the contract in the storage we have this counter next idea that we initialized to one and then we have the tokens big map that we initialize with an empty big map you will notice that we don't add a cast instruction to specify what the type of the big map with the type of the key and the type of value we will use type inference and let it determine those types in the mint entry point we use cast to indicate what the type of the Met data is because all we do is stor it so there's no way in the contract to determine what its type is so we say this is going to be a string then we use the current value of next ID as a key to the new entry we put in our tokens big map and we store a record that will contain the metata a price initialized at one TZ the owner and the author that are the address of the sender finally we increment next ID to have it ready for the next nft in the buy entry point we need to take as parameter the token idea that we want to buy we check that there is such a token we fetch the data from the big map then we check that the amount sent was inde the current price we compute the fee that we have to send to the author we send everything but that fee to the current owner and then we send that feed to the author finally we update the address of the owner to this address and we compute the new price and that's it here we have a very basic test that only runs a call to each entry point and we can see the content of the storage so next idea is set to one we have this empty big map initially after the first mint we can see that in the tokens big map we have this entry with a key one the address of the author the metadata the owner and the price and then when we buy it we can see that the owner hasn't changed and the reason why the owner hasn't changed is that we have forgotten to rewrite the content of the token into the big map so it's very important here to add self. data. tokens of token idea equals token otherwise all these changes are simply ignored so if we run it again this time we can see that the owner goes from tz1 H4 to tz1 HJ so it hasn't been been bought by Bob and we can see that the price has changed of course it would be good to do a lot more tests to make sure that the contract is good but keep in mind that passing all the tests and as carefully as you can write your test doesn't mean that there's no bug in your contract and here in this contract we have a big flaw that you should be able to recognize that probably wouldn't have been noticed even by extensive tests pause the video take a look at the code and see if you can find the flaw and here the flaw is one that we have already mentioned before when when we have those two lines the author could be a contract that has a default entry point that fails and this would prevent the sale so the author of the contract could use this as a way to extort funds from the current owner now how can we fix this flaw pause the video and try to change the contract so that it doesn't have this flaw anymore one idea that you could have is that since the cause of the flaw is that all can be smart contracts we could try preventing people from minting their nfts through a contract so basically in the Min entry point you could say okay let's check if the sender is a regular user or a smart contract and there's multiple ways to do it like comparing the address of the user to the smallest possible address of a smart contract for example and other ways so it is possible in practice but I really don't recommend it and the reason is that you don't want to write smart contracts that can only be used by regular users and couldn't be used by other contracts you really want to be able to benefit from all the potential users of your contract and as a user it's really convenient to be able to call your contracts through some other contract could be a joint account like we presented earlier could be a multisig that multiple people can control collectively and the idea is that contracts should be bricks that can interact each other so if you limit the author of your nfts to regular users you will prevent many useful use cases so I really don't recommend differentiating between regular users and smart contracts even though it's possible and it would indeed prevent this issue there's a much better way to prevent the issue but this will required an extra big map pause the video think about it and try to implement this fix so the solution is to avoid sending test directly to the author in the buy entry point and instead as we have done before we let the author claim their own test through a claim entry point the difference here is that we need to keep track of many different authors and store how much each author is being owed by the contract so for that we will create a new big map in the contract that we will call Ledger and it will have a key the address of a user and the value will be the amount that the contract owes to that user and so whenever the user calls claim entry point we check this Ledger if there's an entry for them we just send them that amount and then we delete the entry let's take a look at the modified contract so here in the Constructor we add this new big map The Ledger the mint entry point doesn't need to be changed at all so it's only in the bu entry point instead of directly sending the author fee to the author we check if there's already an entry in The Ledger if not we create one with zero Tes so we don't owe anything yet to them then we add the fee to their entry in The Ledger and that's it that's all we need to change instead of sending test directly to the author we add an entry in The Ledger and then we add the claim entry point where we check if there's an entry for the color of this entry point in The Ledger big map not we just cause an error saying we don't owe any test to that user then we send the amount stored in ledger to the user and to say that we don't own anything anymore we simply delete the entry in The Ledger so if we run a simple test we M an nft somebody buys an nft and then the author can claim the test and they are being transfer their 5% of the cell all good so with this big Maps we can start creating really powerful contract that store data for all kinds of users in this module you will learn the basics of mikelson the lowlevel language that all high level languages on tesos layer one compiled to and and this will give you a deeper understanding of what happens behind the scenes when you execute a smart contract all of the tesos Slayer one smart contract languages generate mikon they make it easier for you to write smart contracts but the actual smart contracts that you execute are in the michelon language it's a lowlevel smart contract language that was designed specifically for tesos you can think of it as the Assembly Language for the tesos layer one blockchain as a lowlevel language it doesn't have any variables everything is based on the use of a stack but even though it's lowlevel it offers quite a few features in particular it has a static type system with a number of basic types such as int not TZ string Etc it has builtin data structures such as pairs lists Maps sets or big maps and it has an API for you to access to the tesos protocol such as cryptographic curves transactions Etc it benefits from a number of design choices that reduce the risk of bugs so as we said mikon is a stack language at any time it has access to a number of values organized like a stack of plates where each plate contains a value most of the melson instructions affect a number of values at the top of this stack there are some instructions that can reach beyond the top of the stack but they always express the location of the elements they read relative to the top of the stack so to give you a quick idea of how this stack works if you want to compute three plus 4 * 5 we write this piece of michelon code first we push elements on the stack so we push three at the top of the stack then four becomes the new top of the stack with three below it then we put five at the top so in the stack we have three then four then five then we execute the multiplication operation mu it will consume the top two elements four and five compute their product 20 and then put it at the top of the stock so after a mo we end up with three at the bottom of the stack and then 20 at the top of the stack then we can use the add instruction that will add those two values remove them from the stock and instead put the results so we get rid of 20 and three and we add 23 instead in the stack we'll see more examples of that the hardest is expect when you write mikelson code is to keep track of the content of the stack after in instruction and we will use commments and tools to help us with that let's take a look at a few instructions from the melon language we won't see them all in this module we will focus on the ones that manipulate the stack or allow you to do some arithmetic operations so that we can practice a little bit manipulating the stock the first instruction is an instruction to put something on the stack so we use the word push then the type for example int not t string Etc then the value so if you want to put the integer five at the top of the stack you write push in five next instruction is an instruction to duplicate whatever is at the top of the stack for example if you have three at the bottom of the stack and then five at the top of the stack and you call dub then you end up with three five and another five at the top of the stack the drop instruction simply gets rid of the top element of the stack so if we had three five5 we end up with three and five in the stack we say that it consumes the top element of the stack the Dig instruction is an instruction to move things around within the stack so you indicate a position related to the top of the stack and it will move that element to the top of the stack so if you have 553 and we do Dig Two it will take the third element from the top and bring it to the top so we end up with five at the bottom five in middle and then three at the top we took the three from the bottom we brought it back to the top the arithmetic operations consume elements from the top of the stack they remove them and then put the results back at the top so the add instruction takes the top two element in the stack consumes them so remove them from the stack and put the result back at the top of the stacks if we have let's say three five three then we take the three and five from the top add them to get eight and then we end up with three at the bottom and eight at the top for the product we use mole that takes the two elements consumes them puts a result of the mation at the top of the stack in mikas we have pairs so a pair is a value that contains two other values of any type and we use pairs a lot in meason so if you have a pair in your stock and you want to unpair them so that you get the two values as separate elements at different level of the stack then you can use unpair if you want to do the opposite take two elements and then pair them to replace them with a single element that contains them both as a pair you simply use the pair instruction finally you will see that even basic contracts will need to push an empty list of elements of a given type in the stack and for that we use the instruction nil and then we indicate the type that we want to put on the stack when you think about what a Merson contract does you really have to think about its input and its output because it's really all it does take some input and compute some output a melson contract starts with a stack that contains only a single value and this value is a pair that contains two elements the parameter of the contract that you pass when you call the contract and the current value of the storage so it can read those value and it also has access to some special values like the balance of the contract the address of the sender so whoever called the contract the timestamp of the blog that contains the current transaction this smart contract call belongs to and the amount that was sent by the caller to the contract Etc it can also access a table of Conant that all smart contracts have access to and finally it can obtain values from other smart contracts using onchain views but that's all it can read in particular cannot read the storage of other smart contract or any outside information can only read its own storage special values and then call onchain views from other contracts to obtain information from them and as the output the contract will produce a single element in the resulting stack and this single value will be a pair of two elements the first one will be a list of operations to execute after the execution of your smart contract your smart contract itself doesn't directly execute operations if your contract needs to transfer a few tests to an address what it will do is generate an operation and added to this list of operations that will be executed once its own execution is over the second value of the pair is the new value of the storage so you rewrite the whole new value of the storage that will replace the one you obtained at the beginning with an exception for the way we handle big Maps where you can write values individually so it's important to keep in mind that a smart contract doesn't have any effects other than Computing this pair and updating values in big Maps so let's take a look at an example this is a very basic smart contract in M that takes as a parameter a pair of integers A and B and all it will do is compute the expression 2 b + a and then put this value in the storage so here we can see the description of the type of the parameter so the parameter is a pair with two integers the first one we add anotation to say the it's named a and the second one is named B the storage only contains an integer we will put the result of the last computation in it and then we can see the code is put with the keyword code and then a pair of curly brackets and then we have the sequence of instructions one per line separated with semicolons so we start by unpairing the value that we have on the stack at the beginning so the storage and the parameter so then we have the parameter at the top of the stack and the storage at the bottom then we unpair the top of the stack so the parameter and we get a and b we use dig two to go get the storage back from the two levels below the top back to the top then we drop it we get rid of that element because we don't need the pr value of the storage we'll replace it with the result of the computation anyway then we call dig one that will get the B bring it to the top so we basically swap the top two El elements of the stack then we push the integer two at the top of the stack we'll multiply it with the second element so we do 2 * B and we get 2 B at the top of the stack we consume those two elements then we call add to add these two elements and replace them with a result so we get a single integer that's worth 2 b + a then since we need to end up with a list of reparation and the new value of the storage we need to create an empty list of operations so nail operation is an instruction that will generate this empty list of operations and then we pair them so that we end up with a pair that has this empty list of operations then the new value of the storage you will notice that we made a good use of the comments to keep track of what was in the stack at any time remember that the hardest part when you write code in mikon is to keep track of what's in the stack so in each comment we write what do we have on the stack after we execute this instruction so it's a good practice to put a commment for every line to describe what's in the stack after the execution of this instruction and then I recommend putting the bottom of the stack on the left and the top of the stack on the right this way when the bottom doesn't change we can see that it's exactly the same and the changes are always on the right so it's easy to just align the left so that the bottom of the stack doesn't move and only the top of the stack is changed for example between this instruction and this instruction we can clearly that the only change is to add two at the top of the stack if we use vs code with the melson extensions we can have a syntax highlighting but much better than that we can see that anytime we select an instruction on the right side the first extension will show us what is the current content of the stack and what it is before we execute this instruction and what what it is after we execute this instruction so we see can see that before we execute the first instruction we only have one element in the stack and it's a pair that contains the parameter itself a pair of two values A and B and the storage and we can see that after we execute and pair we have two values in the stack so at the bottom we have the storage and H and then at the top of the stack we have the parameter or pair a and if I click here here then again see that um before I have the two integers and the storage and after I execute drop I only have the two elements and that's it so it's very inconvenient to check that the type of what we have in stack at any moment is what we expect the second extension allows us to debug mikon code so I can click here to execute this code run and debug it will ask me the value of the contract parameter so here here this is a pair so I write it between curly brackets and for example I will write 1 for a and 10 for B so that's my input parameter then it asks me for the value of the storage of type in so I don't need the storage I'm not using it in this contract so I'll just keep it at zero then I can debug line by line and on the left side I will see the content of the stock so I can use this to run my code step by step so I can see that I will unpair this value that compet my parameter and the storage so I can see that at the bottom of the stack I have my storage zero and at the top I have my pair one and 10 we can see that the pair here is represented differently from the syntax I Ed for input for the input I used curly brackets with the sual in the between here it is represented using a pair of parentheses and then a comma in between so be careful not to mix up the two but they both represent the same pair if I unpair this top element in the stock 110 then I will get one at the top and then 10 and then zero at the bottom of the stock now I execute dig two so I get the second element from the top of the stack and then bring it back to the top so we see Zero is not at the top then I drop the top element of the stack then I do dig one so I get the the element at one position from the top bring it back to the top then I push the value two and I multiply the top two elements so I consume two and 10 multiply them to get 20 and then push 20 at the top of the stack then I add those two 20 + 1 I put 21 back on the stack then I generate this empty list of operations that we have here here it just chose it as a pair of square brackets but here we can see that it's indeed a list of operations and then finally I can pair them to get the end result so a pair containing a list of operations to execute after the smart contract and the new value to put in the storage of the smart contract and that's it so there's a couple things you need to be careful about when you write your smart contract um the first one is when you debug your smart contract if at one point you realize you want to make a change to your contract for example here you actually wanted to push three instead of two you should be careful because when you get to this instruction we will see that it actually pushed two on the stack because it's still running the previous version of the code the changes you make while you debug don't affect your current debugging session so that means anytime you want to make a change to your contract you need to make sure you stop debugging and then start debugging again otherwise it can be really confusing because what you see doesn't correspond to what code you have there and you can spend a lot of time trying to understand what's going on why why do I have this result it doesn't really correspond to what I wanted to do Etc and that's because you're not actually running the code you see so always make sure you stop it run it again and of course then when you execute it you can see that we indeed push three of course here we really wanted to push two another situation you can run into is when you for example add an extra instruction here you can see that everything is in red and it tells us that we have a type check error it doesn't really help us with anything it just says what we have at the end is not right it just not helping us that's because since I added an instruction what I end up at the end on my stack is of the wrong type I get two elements instead of one and that really confuses the type checking and it doesn't help us understand what's going on it just says type check error and if you don't remember that you just added this instruction it can be pretty hard to figure out what is wrong so there's a trick that you can use to do that which is to add a fail instruction at the end and this way the type checking always works because a contract that fails doesn't have to return anything in the stack it just fails and it's always of the right type this way you can check every instruction and see okay what do I have in my stack is that what I wanted Etc and then when you get here you can see oh actually have a one too many elements this doesn't correspond to what I have Etc so you can fix the bug and then once you're good you can remove this extra fail instruction so that's a good trick when you're confused and everything is red and you don't know what to do you'll notice that we put annotations here for each element that we have in the parameter and that's something you can do to help you better understand what's in the stack so here we can see that we have this information that this integer is actually a so basically this annotation was propagated all the way to this position but as soon as you do the computations what you end up doesn't have any annotation it doesn't tell you that this is actually 2B it just tells you it's it's an N so this can be helpful but very quickly you don't really benefit from it anymore so it's much better to use comments that really describe what we have on the stock one thing you may wonder is why do I need to learn meason I write just fine in my higher level language um and I can write smart contracts without knowing meason so why do I need to learn mikin we teach you a little bit of mikin because it can be quite useful in a few situations so for once deployed contracts that you can check with your block explorers are in meason so if you want to read a contract that has already been deployed and that you want to use you have to read the mikon code that's the only thing that's always available sometimes authors U make the original smart contract in the high level language available to you but not always so it's good to be able to read the contract another thing is that while you write your smart contract sometimes you want to make sure you understand what's really going on behind the scenes is it generating a lot of computation or is it something very simple even in a lowlevel language so it can be a good idea to once in a while look at the mikon code generated by your highle language compiler and understand what really happens behind the scenes another time where you will need to understand some mikon is that sometimes you can have compiler errors that are actually expressed in meason it's often type errors so it's important to have some basic idea of uh what mikon is to help you understand these errors more generally it's good to have a deep understanding of what's going on behind the scenes you don't need to be an expert in mikon but it's good to know the basics I advise you to take the habit of reading the mikelson version of contracts you write little by little you will get used to at least reading mikon code and understanding it's not too hard to understand again the hardest part is to keep track on what's in the stack after each instruction as an exercise you will write your own melon smart contract that does some arithmetics so write a contract that takes a pair of integers A and B as a parameter just like we did in our example but then this time computes a * 2 b + 3 a and again puts the result back in the storage pause the video and give it a try let's take a look at the solution so here we have our contract that takes a and b as a parameter with the storage of type int so we start by unpairing our storage and parameter and pairing our two values A and B then we get rid of the storage because we won't need it then this time we will need to duplicate a because in our final expression a * 2 b + 3 a we need a twice so we duplicate a so that we can make use of it twice that's something we often need to do in a stack based language so now we want to compute two B so we dig twos to obtain B at the top of the stack then we push the value two and we multiply them to obtain 2 B now we want to compute 3 a so we dig one to get a a back to the top we push three we multiply them to get 3 a at the top of the stack then we want to compute this expression 2 b + 3 a so we add those two values to get 2 b + 3 a at the top of the stack then all we have left to compute the final expression is to multiply a with this value 2 + 3 a so we have our result here but now we need to add an empty list of operations on the stack so we call nil operation at this empty list of operation we see here that we have indeed a list of operations in the stack and then the new valuable storage we pair them and we get the results in the stack we can give it a try we can use one for a 10 for B zero for the storage and so we compute let's compute a few things so let's see here after doing the addition we still have a = 1 at the bottom then we have 2 B so that's 20 plus 3 a that's three so we get 23 at the top of the stack then we multiply that by a so by one and we get 23 and we compute we have the empty list and 23 if I run it again but this time with two and 10 then I can execute it so I should get 3 * 2 so that's 6 + 20 * 2 so that's 26 * 2 52 which is correct all good in this module you will learn how to install Smart py in your own environment which is what we recommend when you start creating contracts for your real projects the installation procedure of smartp is very straightforward forward all you need is Python 3 and pip which is the tool to install modules for Python 3 there's one exception if you use a Mac and have an Intel processor you will also need to install Docker we'll refer you to the corresponding documentation of these tools to install them if you want to find the latest installation procedure you can go to smart py. I and in the manual in the installation section you will find the commands the version we will use for this demo is a version that's not officially released yet but that you can find here so if you go to the coresponding website you can go in the manual installation and here you find the installation procedure where you have one command that you should run and that's all you need to install Smart Pie as long as you have the prerequisite python pip and maybe Docker for our demo we will do this in the gpen environment prepared and you can try it yourself in the same environment if you don't want to install it on your own computer so we'll create a new workspace with this environment where we don't have anything specific to smartp installed yet so you may need to create a gitp pod. iio account using your gitlab or GitHub authentication if you don't already have a gitpod account then it asks you to create a new workspace which we will do it may take a couple minutes make sure you have the tab open in your your browser with the focus so that it doesn't take too long so once your git pod environment is running I'll Zoom a little bit but all you do is go copy the common line provided in the smart P manual so we copy this line you paste it here it may ask you if you authorize pasting content on git pod so of course you need to authorize and then you simply execute this command it downloads everything needed and everything is ready now you create a folder so will test or endless wall contract so I'll create a endless W folder and I'll open the uh vs code editor where I will put my contract file but you can use any editor you like your contract file should have the py extension and I will paste the count of our contract once you've done that all you need to do is run python contract. py I forgot to save contrl s run it again well good and we see here that created is a test folder with a lot of files so we'll go through them to understand what just happened so all you need to do to run a contract and it's scenarios is simply to run Python and then your contract and this will produce a folder for each of the test scenarios you have in your contract and in each folder you will have a number of files you would have the main file which is log.txt that will contain all of the steps of the execution and you will have files for each contract or Reg ation with the content of the contract in mson the content of the initial storage and you will also have files for each call to an entry point we can see here with the names those are files for the contract for the initial storage the type of the storage and parameter Etc and then for each step we have the files for the parameters of the entry point calls so if we look more precisely at the content of the log.txt file it will contain sections for every step of the execution of your scenario you will have the contract origination with the initial storage of your contract and you will have an entry for each call to an entry point with the parameter and the resulting new value of the storage you will also find the comments produced by calls to the scenario. H1 Etc and you will also see lines for calls to scenario. verify where it will show what conditioning checked and what the result is the output of calls to sp. trace that you use for debugging are not visible in log.txt but they are directly displayed in your terminal as the error output so here we can see the content of some sp. Trace that we added here so we can see that it's displayed directly in the terminal and then if we open the log.txt file we can see the origination of the contract so our contract simply contains a big map so here we can see the initial content of the big map it's empty then it will list all the different files with the storage the types and the contract so for the storage we can see the content either expressed in smart Pi or in mikon or the Michelin version so the Jon version of mikon here we can see the types of the storage the parameter private and Views directly smart p and you can see the contract itself either in the Michelin Json representation or directly in melon as a TZ file so you can see what the melon code that you generate looks like and you can see that after every instruction it shows the content of the stack after the execution of this instruction with the top element of the stack on the left so for example here after impairing the content we have the parameter in the storage and after running now we have now at the top of the stack for each section you can see the corresponding smart pie code so you can follow what part of the code corresponds to what part of your smart pie code that can be quite useful if you want to understand what your code really generates on chain so to recap for each contractor origination you will have the files with the initial storage in different formats the file containing the different types in the smart P format and files with a compile me contract both in the TZ and Json format then for each smart contract that you call some files will be produced they will contain the content of the parameter both in the TZ Jon and smart P formats so we can take a look here for a call we can see that the call had one parameter that was a string with Bob's message here we simply have the string and same here in the meason format so we can see here in the log. XT we originate the contract we see the corresponding initial value of the storage here we can see the output of a call to scenario. H1 here we can see that we call WR message with the parameter and we can see here the new value of the storage so the content of the big map with the key here which is Bob's address and then the corresponding entry then we make another call so we can see that the content of the storage change for the key that is Bob's address and then finally when we make a call to send a message as Alice we see that we have another key in the big map with Alice message and finally you can see here when we verify so if we check our contract here we have a verification that the Tim stamp for Bob's message is zero because we didn't specify any other Tim stamp in log. TT file we can see this verification with the corresponding condition and the result so this is everything you need there to check that everything goes well and to look in detail what happened during the execution of your scenario and remember that for each scenario you will have a similar folder so you can organize your test very nicely okay now it's your turn to give it a try and run smart P locally so what you should do is simply reproduce the demo but you with your own smart contract so you install Smart py in your own environment you execute your own smart contract uh you can take the one from the previous excise make sure you include contract calls verifications comments and calls to trace to see what happens in each case and if you have trouble for some reason to install Smart p in your own environment on your own machine you can test all this using or gitpod environment at this address so pause the video and give it a try in this module we will talk about DS decentralized applications and what it means to develop your own DS adap is an application that is built on top of one or more smart contracts it stands for decentralized application but it is a regular application with or without a user interface that may interact with smart contracts but also a wallet one or more nodes indexers decentralized file systems like ipfs and sometimes a regular back end but you have to be careful in spite of their name decentralized applications only the smart contract part of adap is always decentralized the interaction with different tools are made available through libraries and depending on the type of front end or back end you use you may use different libraries on tesos we usually use takito for web based daps we may also use py tesos for python based daps or we can use the unity SDK for tesos for DS that can work on the web desktop and mobile using the same code base and that is particularly useful for games that you develop using the unity SDK and there are more such libraries for other languages and pl platforms there are also tools like Factory or cleum that can help you by analyzing contracts and generating bindings and make it easier to develop and debug your DS the main capabilities of these libraries are the same but they run on different platforms and with different ease of use a key aspect of DS is their interaction with wallets the role of the wallet is to allow DBS to interact with smart contracts while providing security for the end user it keeps the private keys of the end user safe and it gives them the opportunity to check the transactions before those transactions are sent by the DAP to the node so the D interacts with the wallet at different steps first it uses the wallet for the user to authenticate on the DB then it uses the wallet to simulate transactions and check how much the felds will be the fees to pay to the Baker and the amounts to burn for the storage then the wallet is used to sign and emit the transactions send them to the blockchain but it can also be used to sign other types of messages or to verify signatures from other users we use a standard protocol Bon to interact between deps and wallets so that you don't have to write code specific to each wallet in your DBS and connection between the DBS and wallet can be done either through a QR code or through dip link DBS can also communicate with nodes either through the wallet or or directly they do so to obtain information about a given blog for example its level its timestamp the transactions it contains Etc they can read the balance of an account or a smart contract directly from a node or they can read the storage of a smart contract and they can also execute views and obtain other kinds of data these interactions are done through RPC calls directly to the nodes all of the data is available through the nodes but only block by block and it's not very convenient to access the data this way so to make it easier we use what we call indexers the role of indexers is to fetch data from the node blog by block as the blocks arrive and then make it easily available to the deps so you have apis to find accounts contracts and operations based on many different types of criteria and you can also obtain aggregated or sorted data and more generally you can access data in more digestible format in particular for standardized tokens and the access to data is much faster than you if you try to access directly through a node a good way to get an idea of what is available through an indexer is to look at block explorers because behind each block Explorer such as Bal Dev TZ KT or TZ stats there is a corresponding indexer that stores all that data and makes it easily available so typically the work of an indexer is to keep track of new blocks fetch all of the data store that data in a relational database with indexes to allow for good access performance and then reply to simple or complex queries through a rest API there are a number of public indexers that are available for tesos such as TZ KT or TZ stats but you can also install your own local copy of these indexers but keep in mind they use significant resources because they have to index all of the data from the blockchain a more lightweight approach consists in using selective or custom indexers that only inexs the data you really need for utap there are tools like DP dap or dzer that make it easy for you to create your own selective or custom indexer blockchains and in particular layer ones are not good for storing data in large quantities because every single node on the blockchain stores everything so the St storage on the layer one is expensive in practice when possible we only store a hash of the data in the smart contract we only store the data itself in the smart contract if the smart contract needs to directly interact with the data but even though you don't store all of the data in the contract itself it's important to make sure that the data is available in a decentralized manner so decentralized file systems play this role of storing this data and make it available to everyone everyone ipfs is currently the most used such decentralized file system it stands for interplanetary file system it consists of a protocol for organizing and transferring data through a peertopeer Network an ipfs also represents a number of implementations of this protocol and a decentralized network based on this protocol on ipfs or any similar tool any file is identified by its hash that has multiple advantages because it guarantees that the content has not been tempered with you can check that it matches the hash and even if at some point the content is lost by your system if some content is not available on ipfs anymore anyone can add it back and it's identified by the sash as long as the content matches is hush then you can add it back and you have to be careful because nodes of ipfs are free to decide what data they store just because you put some data on ipfs at some point doesn't mean it stays there for dri so it doesn't guarantee that availability if you want to make sure some content stays available you can use spinning services that take care of that for a to recap adap is an application that is built on top of one or more smart contracts and you have to see it as a regular application that may or may not have a user interface and that may interact with smart contracts with a wallet with a node with indexers with decentralized file systems like lpfs and maybe with a regular back end so again be very careful in spite of the name only the smart contract part of a DB is always decentralized the front end of a Dap is often hosted on a centralized server and the deps often interact with a centralized indexer they also interact with a specific node or a specific set of nodes and they often have a centralized backend so when that's the case only the smart contract part gets the benefits of decentralization furthermore many smart contracts depend on the third bodyy to make some calls so you have to keep in mind that the technology makes decentralization possible but it doesn't require it so it's possible to write AAP and smart contracts that are not fully decentralized so many of the benefits of blockchains can be lost if you don't apply them correctly you can take the example of what happened with f PX for example and see what could go wrong but you also have to keep in mind that to attract users you need to make it easy for them so the hard part is to benefit from all of the aspect of decentralization while still making it easy for users to use one of the barriers of Entry op ups for your final users is that to call any smart contract they need to pay fees and in order to pay fee that means you have to buy TZ which implies doing a K1 YC know your customer prove your identity Etc even if it's a very small fee so this is a barrier for many users when starting to use your product your D so to make it easier one possibil is for you to pay for your users fees users can set up a wallet but don't go through the kyc or obtain TZ and that means instead of signing and paying the fees for a transaction they can use their wallet to sign a message that will allow a transaction but then they send this message to your server and your server receives this message and calls a contract that will then receive the message and do the corresponding transaction so this way the users give their authorization by using their wallet to sign the message but you're the one paying the fee on your server so that's a method that you can use to make it easier for your users to start using your D and there's a standard on tesos on how to do that called tzip 17 one issue that can come up when you do D and in particular when you use Fess transactions comes from the fact that each transaction has to include a counter to avoid replace but that means from a given address you can only emit one transaction with one value of the counter per block but some services including in the case of Fess transactions require sending many transactions per block so to solve this issue we have a system of batches of transaction actions a batch of transaction can contain one or more transactions from the same account and either all of the transactions in the batch are included and are successful or they all fail and issue is that the bigger your batch is the higher the risk that the batch and all of its transactions will be rejected so to manage your chances you will have to split your transactions into several batches that you emit from multiple addresses for a given block so that's one of the things things that you may need to take into consideration When developing Advanced apps and in particular if you use Fess transactions so that give you an overview of the kind of issues you have to deal with When developing daps in this module you will learn how to make inter contract calls and this will open many interesting possibilities the possibility for a contract to call another contract really expands the potential of smart contracts you can create Market Place contracts that interact with nftd contracts or Dow decentralized autonomous organization contracts that allow people to collectively own and trade assets through the interaction of the Dow contract with other contracts you can also build the centralized Finance contract that build on top of one another with Landing contracts that allow you to invest in yield forming contracts Etc or you could create game contracts that interact with dynamic nfts there's really a lot you can build thanks to the possibility of contracts interacting with each other but all this potential also opens up many potential flaws and risk associated with interc contract calls for example if you're not careful it would be possible to trigger a contract on behalf of a user without them realizing that that contract is called in their name and interc contract calls can in some cases give attackers access to potentially Unlimited funds for their attx so when dealing with interc contract calls it's important to be very careful about what you're doing and we'll show some of examples of that the syntax of inter contract calls is pretty straightforward if you have the address of a contract you can use these two instructions to call an entry point of this contract so first you get a contract object by doing sp. contract and then you have to pass three values you pass the parameter type of the entry point you want to call then the address of the contract that has this entry point and finally the name of the entry point and this returns an option on the contract because there may not be an entry point for the contract this address with this parameter type so since it's an option if you know for sure that you press the right argument you can unwrap the option using unwrap sum and store the result in this contract variable once you have this contract variable you can do the contract call by using sp. transfer because calling contract is also transferring some test to a contract then you pass the value of the parameter for the entry point it should have the type that you provided here you indicate how many Tes you want to send as you call this entry point and you pass the object that you just obtained with the previous instruction and this will create a transaction to call the entry point with this name from the contract at this address and with this value as a parameter setting along this amount of Tes this transaction is cued in the list of transactions that you execute at the end of the execution of your current entry point it is never called immediately to test several contracts that interact each other in your test you start by creating instances of your contract in the usual Way by calling the constructure of each contract then you simply have to pass the address of one of the contracts to the other contract for example in an entry point call or it could also be in one of the Constructor parameters so this make the contract address available for the entry point to run these commands let's take an example with contracts that can interact with other contracts we could create a contract that serves as an intermediate between the user and another contract and this adds a lot of new possibilities on how existing contracts can be used so for example if a contract has an owner you could use an intermediate contract to change it to two owners so if we take the case of an nft we can create an nft joint account contract so that two people can jointly own the same nft so let's see how this would work so we have this nft for sell contract that represents a single nft that can be bought and sold in its storage we have the current owner we have its metadata and we have its current price then we have our two entry points one to buy this nft at the current price and one for the owner to set a new price for the nft and so the idea is that we can create this nft joint account that will become the owner of one or more such nfts and then we will have two owners for this contract that will be jointly the owner of this contract and therefore both control the associated nfts and here since it's a joint account each owner has full power on the contract so either one of them can either buy nfts set the prices Etc so for this contract to be able to buy and sell nfts through this um nft for sell contract we need the following entry points the first one will be to buy an nft and so for that we say which nft we want what's the address of the contract corresponding to the nft we want to buy and this entry point will call the buy entry point of the corresponding n Fe and then the contract will become the new owner for that nft once it owns that nft either of the owner could call set nft price again indicating which nft contract this will be and then passing the new price and this entry point will in turn call the set price entry point of that NFD contract finally once someone buys the nft the funds will be sent back to the owner of the nft for sale so it will be sent to the default entry point of our nft joint account contract so we need to make sure we have a default entry point that accepts TZ otherwise we would never be able to sell those nfts so if we look at our contract in more detail so we have those two owners that are both addresses in our buy nft entry point we first check that the caller is either owner one or owner two then we simply call nft address. bu with the amount that was sent to by nft so sp. amount next he set nft price entry point checks again that the color is either owner one or owner two and then simply calls the set price entry point of the nft contract with the new price finally if the default entry point is called we do nothing we simply accept the test let's take a look at the contract so here in the same file we can have our nft for sale contract and our new nft join account contract so the nft for sale contract is one of the versions we used in the past that has a basic set price entry point that checks if the caller is the owner and then updates the price and then the buy entry point check that the amount sent is the right amount sends it to the owner and then changes the owner so now we have this nft join account contract that simply stores the two owners and in the buy nft entry point we get the address of the nft contract that we want to interact with so keep in mind that this joint account could own many different contracts using many different addresses so every time we want to interact with one of these nft contracts we just pass the address but first we check that the caller is either owner one or owner two and then we execute those two instructions I was showing before so we get the buy entry point of this address since the bu entry point doesn't take any parameter we have to say that the type of the parameter is nothing and nothing can be pressed by the type unit so we use sp. unit as the type when we have no parameter at all and since it's an option we need to unwrap it we store it in this variable then we can call transfer we pass the value of the parameter so when we have no value to pass the value for nothing for the type unit is expressed as a pair of parentheses with nothing in it so that means sending no parameter in a when but we need to put something here so we have to put this pair of parenthesis that represents the unit value which means sending nothing then we pass the amount so since we just buy the nft we just forward whatever amount was sent by the caller so one of the two owners to this entry point and we just pass it along to the buy entry point of our nft contract and then we pass the contract object that we got from the previous line and that's it this simply calls the buy entry point of the contract at this address very similarly for the set nft price entry point we check if if it's the owner one or owner two then we obtain the corresponding contract using the same thing the main difference is that this time the name of the entry point is set price and this time we have a parameter the new price that is of type newest so we indicate this new price here and again we unra the option then we call sp. transfer we pass the value of the parameter so the new price that we got from this parameter this time we don't pay so we send zero Tes to the set price entry point and the contract is what we obtained from the previous instruction when we test this contract here we instantiate the two contracts so one for the nft one for the joint account we add them both to the scenario so that they can be both originated within the scenario then we call the set price entry point to set an initial price for this nft so that we can buy it at that price then with the second contract with our joint account we call by nft and we give the address of the nft contract we say okay Bob who is one of the two owners of that join account is calling the buy nft entry point and sending seven TZ to buy this nft the nft with this address that we just created then we can try to change the price from the nft directly so this won't work only the contract is allowed to change the price and here we see that we try to use this join account again called by Eve so Eve is one of the two owners of the joint account and we try to buy it at 7 T but this doesn't work and the reason why this doesn't work is because we didn't add our default entry point yet so if we want this to work and turn this to a true we need to add the default entry point so that when somebody even us buy the nft again then we can receive the money so we can add the default entry point that doesn't do anything but pass and now if we run it then this time it works so we basically bought the nfg from ourselves not very exciting but this can only work if we have the default entry point then we call the set nft price to change the price to 50 TZ so we can see here and the new price has been set to 50 test here if we show the contract we see here the new price and here we verify that the need the new price has been set to 50 St and and that the address is in the address of the contract so not a lot of test but this illustrates the different calls we can make and how we can have a joint account contract that can interact with an nft contract unfortunately this join account contract has a big flaw can you find it and fix it take a good look at the contract and see if you can identify the flaw and find a way to fix it pause the video and give it a try so the issue here is a situation that can be pretty sad once you realize what the flaw is these two users who are the owners of that joint account could jointly buy and sell many nfts for many years accumulate funds by selling nfts selling them later for a higher price and accumulating money on their joint account but there's one small issue the day they decide to retire and get the test out of the contract is the day they realize that they forgot to add a way to get the funds out so it's very important to always remember to add an entry point to claim any profits if the contract is meant to accumulate funds make sure you have this way to get the funds out otherwise all the funds you may accumulate all the time by the service your contract is providing uh will be lost and will be stuck in the contract for forever so the solution of course would simply be to add this claim entry point that either owner one and orer two can call the idea here is that you have two addresses that you can use to the same thing it could be two people that trust each other or the same person that has two different keys and one that's a safe key in case they lose the first one for example and after checking who is calling all the entry point we have to do is send the balance of the contract to the caller so it's very easy to fix the problem is to make sure you don't forget to have this entry point in your smart contract there's been real situations where people accumulated significant money and had no way to get them out but now let's imagine you actually did this and you deployed this contract without the claim entry point so you cannot change the contract itself once it's deployed right it is immutable so the question is can you find a way that you could still get your funds out of this contract I mean imagine that you have millions of TZ stuck in this contract so you really have to try hard and see if there's any way that you can get those funds out pause the video and think about it so again assuming that you have millions of Tes stuck in this contract how can you get them out there's actually one way to change the contract once it's deployed at least in theory can you tell what that way it would be pause the video and take a minute to think about it so this theoretical solution is that on tesos anything is possible thanks to unchain governance all you have to do to get your funds out is to propose a new Amendment to the tesos protocol and you can make any changes you like in amendments so you could propose an amendment that changes your contract so that you can get the test out but the next step would be much harder The Next Step would be to convince the community to vote for your new Amendment and Save You by letting you change your contract so in theory it is possible in practice unfortunately for you this is extremely unlikely to succeed that's because the whole point of a blockchain and of our smart contracts is that you should be able to trust that it won't be changed that it's what is written in the contract is what will happen so it would be really hard to convince the community to go against this principle just so that you can get your Tes out that got stuck there because of your own negligence but really you have millions of STS tuxed in your contract isn't there a way to get them out so you can't change the contract you can't convince the community to let you change the contract and add a claim entry point but you still have access to those existing entry points the buy nft entry point the set nft price entry point and the default entry point and that's all you have to work with calling those entry points is the only way you can interact with your smart contracts so using just this can you figure out a way to get your TZ out of your contract pause the video and think about it for a while imagine that there is millions of stake okay so all we can do with our contract is buy and sell nfts but we could use that to our advantage we could use the TZ in our balance to buy one or more nfts at their market price using our jointed account so those should be nfts that are easy to buy and sell and that have a clearly identifyed market value so that you know that if you buy them at the marketplace you will be able to sell them at a similar price then you change their price to a very low price close to zero and then right after that you buy them with another account let's say a regular account at this very low price and now that you own it and control it you can sell them with your regular account to a buyer at the market price or maybe a bit less than what you paid for and by doing that you got your money out or most of them this sounds good right there's only one small problem if you do this you could actually lose everything can you figure out how pause the video and think about it for a minute so the problem is that if you can do do it someone else can too after you bought the nft with the joint account and changed their price to a very low price so that you can buy it at this very low price with another account someone else could buy it too and could buy it before you do anyone can buy it at this very low price so if anyone or even a bot notices that there is this nft that has a very high value but somehow got a price set to a very low price then there is a good chance that somebody will notice that and immediately buy it then sell it to a buyer at the market price and profit instead of you so there's a risk that you will lose everything and someone else will make the profit thankfully there's a way that we can prevent this the idea here is that between the time that you change the price to a very low price and the time that you buy it with another account you would like to make sure that no one else can do anything and buy it before you do and you can do this using batches of transactions the idea is that on tsos a given user can submit a batch of transactions so it's a sequence of transactions from the same user and that will be executed automically that means right after another without anything being able to happen in between and either nothing happens of the whole sequence of transaction happens with nothing in between so by creating a batch of transaction from the same user so that has to be one of the two people who own the joint account will call the joint account to change the price of the nft then with the same account they will buy that nft at that very low price and now we know for sure that no one can buy it before we do and we manage to get our Millions out of the nft contract we were pretty lucky because this approach worked in this specific case but in many cases they would be no such approach so we get lucky but it may not be the same next time let's look at some other interesting situation that can happen with interc contract calls suppose you are the owner of an nft that has an automatically increasing price and royalties that you worked on before and let's assume that you got smart and bought this nft through a contract that can contemporarily prevent Sal so it has a default entry point with a switch that you can turn on or off to allow prevent sales and you pause the sale so you own the nft at some price the price has increased by 10% since then and then you pause the sales by making sure no one can buy it because the account that owns it will reject the money and prevent the sale now let's say that enough time has passed and for some reason you know that somebody is ready to pay a very high price to acquire this nft somehow it got really famous and someone is really eager to acquire it unfortunately for you the price is already set so if you unlock the sale well that then person is likely to buy it at that price so the question is how could you bypass the increasing price rule so that you can sell this nft that someone really really wants to buy and is ready to pay a high price for it so how can you bypass this increasing price Rule and sell your nft for more and take advantage of the fact that somebody is willing to pay a very high price for it pause the video and think about it for a minute one easy way for you to do that is to increase the price by selling it to yourself and and increasing the price by 10% and you keep doing that until you reach the Target price that you really think you're able to sell it for so every time you sell it to yourself whatever you pay is sent back to you the only issue is that the 5% of royalties fees will go to the author for every sale it's still a good way to increase the price so that you can get the most out of your nft you can use a batch of transaction to make sure that nobody else buys it between the time that you unlock the sale and the time that you buy it now knowing that this is possible and you're the auor author of this automatically increasing price contract you would like to make sure people don't do that and cheat and go around your rule of the price automatically increasing by exactly 10% so if you're the author of the smart contract how can you change the smart contract before you deploy it and prevent users from bypassing this rule pause the video and think about it one idea that wouldn't really work would be to add a rule in your buy entry point to make sure that the current owner of an nft cannot buy the nft from themselves so basically in the buy contract you could check that the caller sp. sender is not the owner otherwise you reject the sale and this wouldn't work because it's very easy for the owner to use a second address to buy the nft so they could go back and forth between two addresses increase the price until that value and since there's no way to know if two addresses are the same person there's really no way to fully enforce this increasing price Rule and preventing the same person from buying a contract again and again to increase the price and you really have to keep in mind when you see nfts that seem to be bought and sold at very high price this may make it look like those nft are really worth a lot but it could be that it's actually the same person buying it and selling it it's just money changing from one address to another but owned by the same person so it doesn't cost anything to sell and buy an N at a very high price if you're selling and buying it from yourself so that's a good way to inflate the apparent price of an nftd so you should be very careful about that so now let's think about a more interesting question what if you want to sell it for Less how could you bypass the increasing price rule so that you can sell your nft for Less let's say it went to a ridiculous price nobody wants to buy it anymore you really want to get rid of it and sell it for less than its automated price and the value of the price in the storage of your contract is really computed by the ENT Point bu and there's no way to change it in any other way all it can do it be increased by 10% when you buy the nft so how could you bypass this buy entry point and sell the nft at a lower price pause the video and think about it one solution could be to not sell the nft itself but sell the address that owns the nft so for example you could sell the private key of the account that owns the nft to someone else and then they would be in control of that nft this is a very dangerous idea especially for the person buying your private key the reason is that there is really no trustless way to automatically verify that a private key has been transferred so we have this issue of who goes first do I send you the private key first or do you send me the Tes first who pay for it so you cannot use the blockchain to do this kind of things safely but most of all there's no way to prevent the original owner of the private key to sell their private key multiple times when you sell a private key then two people I'll have this private key and basically it's like a joint account that both people control so it's not safe at all to buy someone's private key it just doesn't work but this could give you an idea for another approach that relies on inter contract calls can you figure out how pause the video and think about it so the idea is that although you cannot sell the address of a regular account so the private key of the regular account you can sell a smart contract and a contract can own an nft so instead of buying the nft with a regular account and then trying to sell that account you can simply buy it with a new smart contract and then sell that smart contract so we can custom build a smart contract so that it can purchase or sell nfts and also be purchased and sold itself and the rules for selling and purchasing this contract that will own the nft are completely independent of the rules that set the price of the nft itself so in a way we are wrapping the nft into another new contract that we can buy and sell and since this contract owns the nft it's really like selling the nft itself except that it's wrapped into this other contract so we can call this contract nft wrapper and the idea is that whoever owns the nft rapper contract that owns or nft effectively owns the nft through this contract but owning our nft through this nft raer contract will really allow us to go go around any restrictions not only on the price but also on the royalties when you sell that new rapper contract you don't have to pay royalties to the original author because you're not even using the buy entry point of the nft you simply using the buy entry point of the wrapper to change the owner of the wrapper let's look at how this contract would work in the storage we would have three values one we need to be able to say if we allow or disallow sales of the nft it owns so those will simply be a Boolean that we set to True when we allow sales on nft and false otherwise then we need to store the price of the wer and the current owner of the wrapper now we have a number of entry points so we can use this rer to buy nfts and this will simply call the buy entry point of the nft contract with that address so this is just about okay let's have this wrapper buy an nft then we can set the price for our wrapper so when we call it we check that the caller is the actual owner of the wrapper and then we replace price with a new price in the storage we can have this buy entry point for anyone to buy or wrapper we check that the amount it transferred is equal to the price of a rapper we send that price to the current owner and then we replace the owner with a caller so we simply sell this rapper like we sold an nft before now we have this entry point to set the value of this allow sales Boolean all it does is check that the caller is the owner of the rapper and then replace allw sales with a new value and the point of that is that we find have this default entry point that can control whether the owned nfts so the nft that this rapper owns can be sold or not and if allow sales is true then the default entry point will accept any test that is sent to them and not doing anything but if we set aw sales to fals then the default entry point will fail whenever someone tries to buy one of the nfts its owned because that's part of that buy entry point it's sending says to its owner so to the rapper and if the default entry point says Nope sales are not allowed then it will fail and the nft cannot be sold so we can control whether the nft we own can be sold or not we can buy nfts and then we have the entry points for people to buy and sell the rapper itself so your exercise is to implement this nft wrapper so you will have two contracts one is the nft for sale cont contract you have used previously and the second contract will be this nft wrapper contract with this structure so pause the video and give it a try so let's look at the solution here we have a old NFD for sale contract that has an owner metadata and a price or basic nft we have the set price entry point that checks that it's the owner that is calling and then updates the price and finally the buy entry point where we check that whoever is trying to buy sends the right price then we send that amount to the current owner and we change the owner now let's look at the wrapper contract so we have this allo sales Boolean that we initialize when calling the Constructor we have a price and we have the owner of this repper contract we can call the buy and nft entry point to have this rapper buy one or more nfts so we give it the address of the contract that we want to buy we check that the caller is indeed the owner of the rapper contract then we fet a contract for the buy entry point associated with that address again there's no parameter so we put sp. unit as a type and then we call the entry point with no parameter so two parentheses for the unit value and we send the amount that we got so that we can purchase the corresponding nft now we can have the entry points to buy and sell the wrapper itself so the owner can call set price to set a price for the rapper we check that it is indeed the owner that called this and then we update the price for the NF wrapper then we have the buy entry point so we check that whatever amount was sent is the price of the wrapper we send that price back to the owner of the wrapper and then we change the owner very similar to what we do in the nft itself it's just the two entry points we need to buy and cell or contract then we have the set allow cell entry point that simply let the owner of the rapper contract change the value of allo sales and finally we have this default entry point that will fail if our sales is false we don't really need to write that here but if all sales is false then it will fail and then prevent anyone from buying any of the nfts that this contract owns so here we have a test so we create instances of the two contracts initially we said that the sales are allowed we add both contracts to our scenario we set the initial price of the nft to 7 TZ then we have the rapper contract by this uh C1 nft and Bob is the owner of that nft rapper contract so Bob can say buy this C1 nft cont contract through my rapper contract and pay 7 T now we can verify that indeed the owner of this contract is the second contract the rapper contract Bob canot say I don't want to allow anyone to buy the NT I just bought through my wrapper Bob can then set the price of the wrapper itself to 50 TZ and then even though the current price of the nft itself s is at seven we cannot buy it for seven T because buying it would try to send the seven Tes to the reper contract the reper contract has allow sales at false so its default entry point will reject the TZ sent to it and therefore reject the sale but on the other hand someone like Dan can buy or rapper contract at 50 TZ and then take control not only of the repper contract but also of the nfts that this repper contract owns So with this idea of a repper you can see that although it is possible to have all kinds of rules such as paying royalties to the order or having rules on how the price can involve smart contracts are also very powerful and through inter contract calls we can go around certain Rules by wrapping contracts into other contracts and this IDE IDE of wrapping nfts and tokens in general is also one of the ways that we can transfer nfts across blockchain in this module you will learn how to use lists and enumerate elements of lists using Loops you may be surprised that it comes so late as in general programming Loops is one of the first things you learn but in smart contracts we actually try to avoid using loops and lists and we'll talk about why a list is an ordered collection of values of the same type or we could say sequence of values of the same type if you want to create an empty list just like in Python you put two square brackets and if you want to create a list with already some elements you put the elements between the two square brackets separated by commas to describe the type of a list we write sp. list and between square brackets the type of the elements in the list so contrary to python list for example we cannot access any particular element in the list using an index or insert element in the middle or at the end all we can do is add an element at the beginning and for that we can use sp. conson the new element we want to add at the beginning and then a list and this returns a new list that contains all the elements that we already had plus the new element at the beginning of the list and finally you can obtain the length of a list using the Len function the main thing we typically do in a smart contract with lists is Loop over the elements of this list do something with each element so for example if we want to add up all the values in our list of numbers we can initialize a variable total to zero and then we write a loop similarly to how we would write it in Python so four the name we want to give to the variable that will contain each element during each iteration of the loop in and then the list so for the variable in and the list column and then indented the operations we want to do using this variable to access the current value so here we Loop through all the elements and then we add each one to the total to compute the sum if you want to repeat something three times or have a variable that goes from 3 to six for example you can create a list using the range function and if you give it one parameter it will simply create a list with elements that go from zero to that value minus one so with range of three you get zero one and two if you give two values you get all the values between this element and then this element minus one so range of 3 to 7 gives 3 4 5 6 and you can add a step to say that you jump 2 by two so this would be three then five and then It Stop So this way you can create a loop with a variable that takes every value between two values and potentially with a step let's work on an example we want to change our nft joint account contract so that we can purchase multiple nfts at once this can be a good idea because instead of having to call one transaction every time we want to purchase one nft if we have many nfts to purchase it can reduce gas fees to purchase multiple nfts in a single transaction because each transaction involves signature verification Etc so it involves extra gas costs and the calization and serialization of the storage of the contract you Call Etc so if you can do several in one call then you can save some gas fees and therefore some money so let's take a look at the code here we have our usual nft for sale contract where we store one nft with an owner the metadata and the price and we have a set price and a buy entry point but in our nft join account here instead of having code to buy a single nft we pass a list of nfts to buy and then with this list we can do a loop to Loop through every nft in this list so nft will contain the current element in the list and then we call as we did before the Buy entry point of our nft contract by passing the amount stored in nft so here the idea is that we pass a list of Records where each record contains an address so the address of the nft contract that contains it and the price the amount that we are willing to pay for when you call byy nfts you have to send the total amount that you will spend buying all these nfts and then in the list you indicate the address of each nft you want to buy and then how much you're willing to pay for it and that's it in the test we call here joint account buy nfts and we passed a list of records with here two records one with the first nft we minted here and then amount of seven T and then another one with the second nft with the amount of five T which are the current prices of those nfts after we initialize them at five T and then change the price of the second one to 7 T so let's give it a try we can see that we originate the two nfts then we originate the joint account we set the price to seven t for one of the nfts and then we called buy nfts and here you can see that the argument is a list where each element is a record with the address and the amount so we buy the nft at this address for seven T and the nft at this address for five T and we can see that there were two calls to the buy entry point so one to buy the first nft at 7 T and then we can see that the transfer of the 7 t to the original owner has been done and here the second purchase now it's your turn to practice on an exercise so the goal here will be to change this nft joint account contract so that this time both owners have to agree before they buy nfts in a way this becomes a multi where multiple people have to sign on an operation to happen but this one will be a very specialized one that can only be used to buy nfts and your goal will be to change the buy nfts entry point so that the process works as follows so first one of the two owners of the jointed account can propose a list of nfts to buy by calling buy nfts the first time with a list of nfts to buy and the corresponding price and so during the first call we don't purchase anything we simply store that list for the nfts to actually be purchased the other owner of the joint account contract then has to call by nfts again this time with their own list and then what happens is that the nfts that are listed in both lists the one we stored during the first call by the first owner and the one just provided by the new owner we take the nfts that are in both lists and if they are listed with the same number of tests the same amount then the contract buys them and any nft listed by the second owner that had not been bought should be left in the stored list list so that the first owner can then in turn send another list and maybe confirm some of those proposed nfts to buy if the same owner calls buy nfts twice in a row we consider that this overrides any previous list they have sent so at any time we only store the list proposed by the last caller and whenever one of the owner calls byy nfts and the stored list is from the other owner then we check the intersection between the list is sent and the list that is stored check if the prices are the same and when they are we buy the corresponding nfts so pause the video and give it a try let's look at the solution so we don't change the nft for sale contract but we will change the nft joint account and add in the storage two values the list proposed by the last caller in initialized to an empty list and the address of the owner who proposed this list so whoever called byy n FTS last then we Chang the buy nfts entry point we still check that it's only one of the owners calling it if the caller is the same person who called it last so if the owner is the last proposer or if we start with an empty list then we simply store the list that this caller is proposing and that's it if it's the other owner who's calling it then this time we will compute intersection with the currently stored list so there's different ways to do that but we don't have a lot to work with if we simply use lists I mean at the moment pretty much anything you can do with a list is Loop through all the elements so if we simply use that we would have to Loop through all the elements of the new list and for each of them try to search for the same nft in the stored list so we have to look through all the elements in the stored list and see okay if the current element in the stored list is the same address as the current element in the new list with the same amount then we buy this contract otherwise we add it to a new list that we create that will be replacing the old list in the storage of the contract and then we remember that the last color is the sender so this would work but this is a very slow if we have let's say 10 nfts in each list then for each of those 10 nfts in the first list we would have to Loop through 10 nfts in the new list so we basically have N squared iteration of this element so this can get pretty expensive pretty quickly because of all the computation we have to do to compare the two lists so we can do a lot faster than that but to do that we have to use another data structure that you already have learned about oh here we have a bug you forgot to store the proposer so this should be stored whatever happens so the indentation here was incorrect pause the video and think about it for a minute so to take advantage of a map we will take the proposed list and put all of its element in a map where the key is the address of the nft and the value is the amount so this is assuming that uh the same nft address is not listed twice in our list that's a rule we can set for the users of the contract we just say you're not allowed to try to buy the same nft at two different prices in the same list so assuming that will will have one entry for each nft in this map and then when we Loop through the new list of nfts all we have to do is check if it's in the map using the contains instruction with the address as a key then check if the amount for that nft is the one we have in the new list if yes we buy it if not we add it to our new list of remaining nfts so this makes it a lot faster faster to find intersection between the two lists but it's still not the approach I would recommend cuz although this code is less than 20 lines it's still a bit more complicated than necessary so the idea is that we want to avoid doing any unnecessary computation within a smart contract if it can be done off chain and here there's really no need for the smart contract to handle the negotiation between the two owners to find a way to determine which nfts they both agreed to buy they could have this negotiation completely offchain through a d when it's just two people there's really no need for anything in between them for them to agree on which nfts they want to buy the role of the smart contract here is simply to make sure that they do agree before the purchase actually happens and so the way we do that is that we have a first owner could be either one of the two call byy nfts with a list that they allegedly came up with as a list that they both want to buy and so we store that list and we store the address of the owner who proposed that list and then all we have to do is have the other owner called and approve nfts to say yes I agree with the current list that's fine with me so we check that they're indeed one of the owner they're not the proposer it's not the same person agreeing with themselves and then we Loop through all the nfts in the list and simply buy them so that simplifies our contract by quite a bit and so there less risk of bugs but actually in this specific implementation there's a potential flaw that would make it possible for one of the owners to cheat can you figure out how pause the video and think about it for a minute so the way that one owner here could cheat would be to detect when the other owner is calling the approve nft entry point and right before that moment in the same blog potentially but making sure their transaction is accepted first they would call buy nfts again with a new list so basically they would switch the list of nfts right before the person approves it and after they send the transaction so it's too late for them to notice that the list has changed and they're not approving the list they thought they would buy so we need some way when the user calls approve nfts we need a way to make sure that they are approving the list that is currently stored and not a previous list that they have checked before so how would you do that pause the video and think about it for a minute so there's several ways that we could do it one way would be be to ask the caller to send the whole list again and then we compare the two lists and and compare every element and check if they're all the same but that would be a bit more code we could think about Computing the hash of that list and storing it and then we would have the other users send the hash of the list they approve of and a hash is guaranteed in practice to correspond to the same data it's impossible to create another list at the last moment that would have the same hash so this would be safe enough but Computing a hash is a little bit expensive so it's maybe not the cheapest way to do it all we need to do is to have a unique value associated with that list and it doesn't have to be the hash it could be a counter so we could have some counter that uh we increment every time someone makes a new proposal and then when we approve you send the value of that counter so that would be one way to do it so we could do here set to one and then here we increment it and here we check we pass counter and we check the approved counter is is equal to the stored counter so this way we know that by nfts hasn't been called at the last minute before we call approved nfts and if it has been called then the approved counter wouldn't match the current counter so that's a good way to protect against the other user trying to switch the list at the very last moment so making the codes simple is a good way to avoid bugs but it doesn't guarantee that there's no Buon you should always think about ways that someone could cheat it's just easier to think about it if the code is simpler so as I said in introduction we actually try to avoid using lists and Loops in smart contracts when we can that's because using lists in a contract can be dangerous can you figure out why pause the video and think about it for a minute so there's two reasons why lists can be dangerous as we discussed before serializing and deserializing the storage cost gas and so if you have a list in your contract this can increase the cost of calling your contract in some cases it could increase it so much that your contract could get stuck it wouldn't be possible anymore to distalize and resize the current content of the list so you should be very careful about having a list in your storage that people can fill arbitrarily up to the point where it's not possible to dis realize it anymore the second related reason why list can be dangerous is that simply looping through their elements cause gas and as the number of iteration increases the cost increase and similarly your contract can get stuck just because you have to Loop through a very long list and perform some computation on every item so it's important to remember only to use lists if you know that their size is bounded if it's simply a list that you pass as a parameter it's up to the caller to decide the length of the list that passes a parameter there's not much risk of course you're going to pay more if your list is longer but it's really up to you when you do the call to reduce the number of elements of your list if you want to pay less or if you want to make sure that the gas cost doesn't exceed the limit of how much you can spend in a single transaction but if it's a list that you store in your storage then that's when it becomes dangerous and you should be really careful and make sure that the length of the list cannot increase indefinitely so now the question is if we shouldn't use list and we can't use list in the storage with a length that could increase indefinitely what would be the alternative if you feel that you need a list that type of data structure so an ordered sequence of elements of the same type what could you use instead of a list pause the video and think about it for a minute the alternative when you want to store for a lot of data with no limits on how much data you can have is always the big map because that's the only data structure that is not limited by the gas costs and if you pick the right key you can use a big map to emulate all kinds of data structures so for a list the idea is to use a counter to indicate the position in the list so you could store two fields in your storage let's say field elements that's your big map and then a value that counts the number of elements in your big map that starts at zero and if you want to add an element all you have to do is write your value with a key being the current value of NB elements and then you increment NB Elements by one then you can create a loop that just Loops from zero to NB elements minus one so that you can iterate through all the elements in the big map but if you Loop through all the elements in the big map This Way well again if the size of the big map gets too much and you could get stuck again let's say you want to compute the sum of all the elements but there's too many elements to Loop through in a single transaction without exceeding the gas limit then you have the same problem so how would you solve that pause the view and think about it for a minute one way to avoid the very long loops and avoid Loops that cannot go through in a single contract call is to Simply use multiple contract calls you could split the loop into multiple calls that maybe do only 100 iterations in one call so you could keep in your storage where you're at in this big loop so you could have a loop counter in the storage and then you have this continue sum entry point where you pass how many iterations you want to go through at the most and then you Loop through them you increase your counter for every iteration you do and if you didn't exceed the number of elements in your big map then you add the corresponding value to your sum so this could be one way that you can make sure that no matter what you will be able to Loop through all the elements in your big map and compute the sum this could end up being expensive this if there's millions of elements but you will be able to do that if you're ready to pay the price but for this specific example of computing the sum we can do much better can you find out how pause the video and think about it so the idea is that instead of looping to compute the sum when we need this sum it's a lot better to maintain the sum as we add elements all we did to the list is ADD elements to it and maybe we could have a way to remove element from them but as long as we don't do anything more complicated we can maintain the sum as we modify this data structure so we add this sum elements variable in our storage and then every time we add an element we simply add the value to some elements this way when we need the sum we just have to read it in the storage so this is pretty basic and pretty easy to do but it's something to really keep in mind because that's something we use a lot and this works if you want to compute the sum if you want to compute the smallest element in a list or the maximum element in a list or even the average value in your list but a lot of times just like we did a bit earlier this other approaches to reduce the gas consumption that really mostly consist in doing work off chain that's really the best way to avoid paying too much gas is to do as much as the computation as possible off chain in this video you will learn a new way that contract can interact with each other and that will make it even easier to build projects composed of multiple contracts that interact with each other and this new way is what we call views more precisely onchain views but we'll just say views to keep it short and it's a mechanism that allow contract calls that are really meant for one contract to obtain information about another contract and Views are readon so when you call a view of another contract that view cannot modify the storage of that contract and cannot emit its own operations so that means it doesn't have any side effect so by calling that view you not have any effect on this contract all you can do is obtain some information from that contract there can be some computation to obtain that information but there won't be any side effect other than returning the data from that smart contract when you call a view you can pass arguments as input that will be used by the view in addition to the content of the contract storage of that view and uh the view may call other views from other contracts again with no side effects no modification of their storage or no emitted operations calling a view in itself is not an operation all it does is return a result as an output and unlike contract calls or transfers of Tes they are executed immediately they are synchronous so as soon as you call it the view is called in the other contract the C of that view in the contract is immediately executed and the result is immediately available to the caller contract that's very different from inter contract calls that we have seen before where an inter contract call is really a new transaction that you add to a queue but here with views there's no new transactions you immediately execute the code and obtain the result so let's take a look at how we create and call an onchain view creating an onchain view is very similar to creating an entry point we use a different decorator sp. onchain view to indicate that that this is a view then it's like a method that takes one or more parameters just like entry points we can have any kind of computation within the entry point except for modifying the storage and creating new transactions and then the other difference with an entry point is that it returns a value with a keyword return to call a view within an entry point you write sp. View and then between parenthesis and number of values the name of the view so that's the name you gave to the method in your contract then you provide the contract address so the address of the contract that contains this view then you provide the value of the parameter so it could be a single value like here it could be a record it could be anything and then you provide the address of the return type so here we are returning the address of the owner of a token so we pass the token and we say the return type is an address what you will get is then an option on a value from this type so you have to unwrap it to obtain the actual address let's work on an example there was an issue with our nft join account contract which was that if when you pass a list of items you want to buy and a corresponding price a corresponding amount for each nft if one of the nfts in your list list has a price that has changed since you built your list then the purchase of that nft will fail but not only that since one call Will Fail then your whole contract will fail and none of the nfts will be bought so that can be a bit frustrating So to avoid that we will use views by simply checking the price of an nft the current price of an nft right before we try to buy it if it's the wrong price then we'll just skip it and avoid having the whole transaction being cancelled so in our basic nft for sale contract we will add an onchain view get price that only does one thing which is to return the current price of the nft so we just return that value and this way in our join account contract here when we are trying to buy a given n we use the get price view we pass the address of the contract our parameter here is of type unit there's no parameter so we put a pair of parenthesis and what we get is a price so the return type will be mutes and we unwrap the option that we get into a variable price then we can check if the price is the amount we expected to pay then we do the transaction and here we know for sure that this trans transaction will succeed because the price cannot change between the time that we call this contract and the time that the buy code is run so that makes it really convenient and it's easy enough to use so that before we actually do a transaction with another contract we can check information about that contract to make sure we do something that will not fail if we combine interc contract calls and views we can split complicated contracts into simpler contracts which is something really recommend it has several advantages but most of all it makes contract simple for example if we keep the topic of nfts we can split two key roles between two contracts we would have one contract that only takes care of storing the nfts with their IDE their metadata their owner we would call that a ledger contract that just keeps track of Who Wants What nft and we could have a separate contract that will handle all the trading of nfts we would call that a Marketplace contract if the Ledger contract can allow the marketplace contract to change the owner of nfts then we can use this pair of contracts to have people trade nfts and we will keep each of the contracts pretty simple and it will also make it possible to reuse contracts and com combine them with new contracts for example a new type of marketplace or a new type of nft let's look at the structure of The Ledger contract so we would need to store and admin that's who is allowed to change the owner of the contracts that will be our Marketplace contract then we have our usual next token idea to keep track of the idea for the next token we will mint then we have our token speak map that will store all information so we use the token ID as a key and then for each token we store the address of the owner and the metad dator then we have three pretty basic entry points first the mint entry point where we pass metadata and we will simply create a new entry in the tokens big map with the next token ID as a key the caller as the owner and the past metadata as the metadata then we increment the next token ID then we have an entry point to change the owner of a given token so we pass the ID of the token and the new owner we check that the caller is the admin so the admin is allowed to do anything we trust this admin we trust the marketplace because we have read the code before we do that and then we simply change the owner within the tokens to the new owner and for the marketplace to be able to interact with the Ledger it will need to be able to find out who's the current owner of a given token so we have an unchain view get owner that Tex this parameter a token ID and then will simply return who is the owner of that token now let's look at the nft marketplace contract the goal is simply for owners of nfts to be able to put them for sale at a a given price and then buyers will be able to buy them so here we will store all the offers in a big map for the key we will use a composed key a pair of two values the address of the nft contract so in which contract is our nft we can have a Marketplace that can handle multiple collections of nfts in multiple contracts within the collection we need to know the token ID so a given offer has a key that is the description of which nft it is through the address of the contract and the token ID within this contract and then for the value we simply have the price at which the seller is willing to sell this nft then we need three entry points one entry point for the owner of nft to create an offer so again we say what's the contract that stores this nft what's the token idea within this contract and at what price we want to sell it using the get owner view of the nft contract we will check that the caller is indeed the owner of this nft and if it is then we'll add an entry to the offer is big map we give a chance for the owner to cancel their offer so they indicate what what's the nft address and what's the token idea we check that the caller is the owner of the nft again using the view and we simply remove that entry from offers and finally when a buyer wants to buy rft they indicate which contract which token idea so basically they indicate which one they provide the key to the entry in the offers big map so using that we check that the amount they send as they call the buy entry point matches the price stored in the big map we transfer that amount to the current owner that we obtain again using the get owner view of the nft contract and finally we change the owner by calling the change owner entry point of that contract and so we pass them the address of the new owner that is the call and when we're done we remove the entry from the offers big map so your job now using this description is to implement these two contracts so you implement The Ledger then the marketplace and you create the corresponding test to make sure everything works pause the video and give it a try so let's take a look at the solution we will start with the ledger so for The Ledger we store the admin that will be the address of the marketplace contract we create a tokens big map that will store the content of The Ledger all of our tokens their price and owners then we have this counter next to token idea that we initialize at one in the mint entry point we obtain the metadata as a parameter we indicate that this Matera is a string there's no other way to find out by just checking the contract so type inference won't work so we say this is a string then we add an entry to the tokens big map using as a key the next token idea and the value is a record that contains the owner so whoever is calling this entry point and the materal data and of course we increment next token idea so that next person Ms with a different idea then we have this onchain view get owner that takes as parameter the token ID and that simply Returns the owner of that token finally the change owner entry point takes the token ID as parameter and the address of the new owner we check that the caller is the admin of this nft contract so that would be the marketplace and then we assign the new owner to this to toen so that makes it a pretty basic contract pretty easy to proof read and check now let's see how we can create the marketplace contract that interacts with it it's very simple as well we have a storage that only contains this big map with the offers we have an entry point new offer where we indicate which contract and which token idea we are selling at what price then we call our view get owner from from the nft contract we pass the token ID and the return value is the address of the owner so we provide that type and then we unwrap the option to obtain the owner so here of course the idea was to check that it's the owner calling so we have to add assert owner is sp sender and once we've checked that then we create the entry in the offers big map with a key that is a pair containing the address of the nft contract and the token idea and the value is simply the price that we are willing to sell this nftg for then we simply have a buy entry point for any buyer to try to buy this nft tesas parameter again the description of which nft it is through the contract and the token ID within this contract so we first check what's the price of the corresponding offer and if there is no such offer this will fail so the contract will fail so there's no need to check that the offer exists we simply try to read from it and it will fall if it doesn't exist then we check that the amount sent was indeed the price so if this is the case we will change the owner of the nft by calling the change owner entry point of the contract so we use those usual two instructions obtaining the contract object we pass has the type of the parameter the address of the contract and the name of the entry point for the type of the parameter here we have used uh type definition here where we say okay this is a record that contains a token ID an integer and the new owner an address this is a good habit when you do inter contract calls it's a good idea to have the type defined as a type abbreviation at the beginning of your code so now that we have the contract we prepare the parameter so a record with the token ID and the new owner so caller sp. cender and then we call the contract so here it's not going to do a call right away we are simply adding a transaction to the queue that will call this contract with this parameter and sending zero test but we know for sure that if this fail everything will be cancelled so here one thing we didn't do is send the amount to the previous owner so for that we'll need to obtain the address of the previous owner so we can just copy that code and then we can send to the owner the amount also creating a transaction that will send this amount to the owner and at the end and we need to make sure we delete the offer to make sure someone doesn't buy it again right away and immediately take it from this buyer so here we have a very basic test that doesn't check much but shows the two calls we have here created two different ledgers to show that we can have the same Marketplace interact with multiple nfts and when we create each of these Ledger we pass as the admin of The nft Ledger the address of the marketplace that we have created here then we Mint one nft in each then we create an offer in the first Ledger for the token ID one so this NFD that we have minted here we say we want to sell it for Tes and it's Alice selling it so she's the owner of that nft then someone else can buy the nft by NE getting okay I want to buy a token from this contract with this token idea and it's Bob buying it and he's paying those 10 so we can run it and we can see the origination of the marketplace then the two ledgers then we have the minting of those two nfts then offer is being made and stored in a big map of offers and then we have this uh purchase it sends the test to the previous owner and then calls change owner so we see that here the calls to the Views are not shown they're not individual transactions so they're not visible but they have definitely worked to check who to send the test to for example one thing to know about onchain views is that although they are called onchain views they can also be used offchain so this means from adap for example or from any offchain software you can execute this view to obtain some information about a given smart contract so if you want to know the current owner of an nft for a given nft contract you can do an RPC call so remote procedure call to the node to say hey I want to execute this view to obtain information about this smart contract and then you will get the result at different libraries like takito make it easier to do that and this can be very useful if you want to standardize option read access to contract so if you want to know who is the owner of an nft of course you could directly access to the Mig map you have access to everything from of chain but if you want a standard way to find out and work with all kinds of nft contracts that maybe store their owners in different ways if they follow the contract they should all have this um onchain view that Returns the owner of a given token idea and so the same code will be able able to interact with all different contracts through this standardized view so this means we can write a standard on how to obtain the owner of a contract without having to specify how the owner of an nft is stored and very often those views are usedful both onchain and offchain one of the reasons they are called onchain views is that there are other types of views that we have been using in the past and are still using in some cases on tesos there is the term offchain views or that we call metadata views so those used to be melon code that you could call from offchain to obtain information about a smart contract but with nothing executed on chain so it's basically the old way to do the offchain use of the views that we just described and there's a standard that describes it called tzip 16 it is still part of some wellused standards like aa2 that we'll talk about later there was another type of views that we were using before onchain views were created and this was called Lambda views it was also a standard um defined as called tzip 4 and it was not a feature but more of a pattern on how to implement your own views using a system of call backs so it was using inter contract calls but passing a call back to the contract you were calling to say hey compute this information and then when you're done send it to this call back so it served the same purpose onchain as our onchain views but was a lot less convenient to use and so this new onchain view concept is basically replacing both those old ways to do views but again they are still in use for legacy reasons in existing standards but for your new contracts onchain views are really the way to go and make it really convenient in this module we will talk about custom types a piece of syntax that will save you a lot of time when you use interc contract calls or onchain views you often have to specify the type of the parameter and the type of the return value and those types can be a bit long here we present a short example of a typical type that we may pass as a parameter where we specify a destination address a token ID an amount and to match the specifications of Standards we have have to specify the corresponding layout putting this whole piece of code every time you have to specify the type or calling a smart contract that uses this kind of parameter is very inconvenient and if you make changes to the type then you have to make sure you change it everywhere but more generally it makes the code hard to read and hard to maintain So to avoid this and make it things easier we can give a name to a type directly in the main module here for this type Ty we declare the name transaction type we say it's a custom type by putting a column then the keyword type then equals and then the description of the type from then on we can use this name everywhere we need to provide this type so be very careful this only works if you put it in the module itself you cannot Define a custom type within a smart contract for example so typically you would have all your custom types at the beginning of your module as an exercise create a joint account contract with a deadline so you take the existing joint account contract and change it so that they can purchase nfts where prices have a deadline that means to buy the nft at that price you have until that date and after that date the price is not valid anymore while you work on this exercise the whole point is for you to use a custom type to avoid having to put the full type every time you call the smart contract for this exercise there probably will be only one call but the point is to practice grading custom types pause the video and give it a try let's take a look at the solution so here we will need a type record that takes the new price and the deadline so that we call the entry point to update the price we give both the price and the deadline so we create a custom type for this that we Define at the beginning of our main module then when we we call the contract here instead of doing sp. contract and then describing the whole record type in detail we simply put entry pointcore type the name of our custom type and we can give it a try and it works all good in this video we will talk about the set data structure and we will work on the membership contract that can be used to define which users are allowed to access specific features of a smart contract a set is an unordered collection of values of the same type it's a bit similar to a list except in a list the same value can be present multiple times and we worry about the order of values but in a set all we care about is whether a value is or is not in the set you can do three main operations in the set very efficiently you can add an element to the set you can remove an element from a set and you can check if a given element is or is not in the set and those three can be done pretty efficiently because internally the values are stored in a balance tree sorted by value the syntax to use sets is pretty straightforward you can create a set in two ways using sp. set for empty set or you can provide the list of values in the set between curly brackets if you want to specify the type of a set you write sp. set and between square brackets the type of the values then you can do the three operations adding an element with add a your value you can remove an element with remove and the value and you can check if the set contains an element by calling your set do contains of the value and will return true or false depending on whether your set contains it you can obtain the number of elements in the set using Len and then you can obtain the list of elements sorted by values by calling your set. elements so let's work on an exercise where we will create a membership contract it can be quite useful to have a contract dedicated to storing a set of members we can use it to restrict access to features of a smart contract based on some conditions that's what we call allow listing so the list of users that allowed to do something and we can use it to create artificial scarcity for example if an nft can only be bought by members of a club then that makes this nft a bit more exclusive which can increase its value we can also use a membership contract to create a community for example da a decentralized autonomous organization where we store the members in a membership contract and it's often a good idea to separate this data into a dedicated contract that focuses on membership and then this list of members can be reused in other contracts not just this initial contract contct that we meant it for okay so your job for this exercise is to think about how you would Implement such a membership contract and we want to make it exclusive so the idea is that we only want rich people to be able to join this contract or this elite club we don't want them to pay a fee to join but we want them to prove that they do have access let's say to 10,000 T so if you don't have access to 10,000 T you you are not allowed to join this exclusive club we also want to restrict the size of this club to 100 people and of course we want members to be able to leave this community if they want to your contract will need to have an onchain view so that any contract can check if a user is a member of this club or not pause the video and think about what you would store in this contract and what the entry points would be and would do so it's a pretty simple contract in a storage we can store the threshold how much you need to show that you have to be able to join the club we will of course store members the set of addresses that are members of this club and we can store the maximum size that we want the club to have of course those two values could also be hardcoded but here we decided to make them values in the storage then you have three entry point or two entry points and one on chain view the main entry point is the join entry point for someone to join the club so first you have to check that the club is not full so the members doesn't already contain Max size entries then we check that whoever wants to join is actually sending the amount required to join the club to the contract we won't keep that value we will send back here back to the sender but this is a way to prove that they do have access to this money because they are able to send it to the contract before they get it back so if they do have this amount and send it to the contract we can add their address to the members set our onchain view will simply return whether user so the address passed as a parameter is in the members set and then we have a leave entry point where we simply remove whoever is calling this entry point from the set of members pause the video and implement this smart contract let's take a look at the solution we can see here that we have a Constructor that takes the membership thr so and Max size as parameters and stores them and then it creates this members empty set in the join entry point we check that the caller did send the required amount we check that we still have fewer than Max siiz members in the set we check that we still have fewer than Max siiz members in our club then we add this uh color in the set of members and we send them back the amount since we don't want to keep it in the contract we have our is member onchain view that takes a user as a parameter and we simply returns whether it is in the member set or not finally you can call the leave entry point and then we simply remove this address from the members we have a basic test where we create a rich Community by calling this contract with a threshold of 10,000 TZ and a maximum number of members of 100 we then have Alice join by sending the right amount Bob first tried to join with the wrong amount so it shouldn't work then he tries again with the right amount from the scenario we can call the onchain view to check that Alice is indeed a member and that Carl who never joined is not a member then we can test that we can leave so Bob is leaving the community and here we check that indeed he's not a member anymore if we can give it a try we see that we first create an empty set Alice join Bob tries to join and fails Bob then succeeds in joining we can see that we have Alice and Bob here and then we send the 10,000 back to Bob and then Bob leaves and only Alice is a member all good it's important to know when not to use sets and there are situations where you really shouldn't use them pause the video and think about why for a minute the issue as often is with the amount of storage that you have to serialize or deserialize when you call the contract if you have a set and this set gets too big then this amount could be so big that the amount of gas you spend in a transaction exceeds the maximum amount that you allowed so your contract could get stuck if your set keeps growing arbitrarily in our exercise we don't have this issue because we had a limit of 100 members in the set so we were safe it could never grow to more than 100 members but what if you didn't want to have this size limit how could you make sure that your contract never gets stuck pause the video and think about it for a minute so as often when you want to use a data structure doesn't have any size limit you can use a big map and big map can associate a value with a key here we don't have a value but we still can use keys so we could use the values of the set as keys to our big map and then for every key we simply store unit which is nothing so when we want to add a member to our big map we simply say members of this address equals sp. unit so it creates the entry even though the entry doesn't contain anything we can remove it using Dell and we can check membership simply by checking if there's an entry for that address then we can have membership contract that has as many people as we like without having to worry about the costs so big Maps is always what you have to think about when you want to store a lot of data but you should be careful it doesn't always solve all of your gas issues in particular you have to keep in mind that whenever you access a given entry in your big map you still have to deserialize and resize this entry so if you store for example a full set within a single entry then it could be risky because that single entry could get really big and then you would end up with the same problem again so big maps are part of the solution when you want to store a lot of data but it's not always sufficient so you should still be careful in this module we will talk about variance a piece of syntax that allows you to create your own types let's start with simple variants a variant is a type that we use to represent one of several predefined values for example you could Define a type called day of week for values that represent a weekday so a variable of this type could hold any of these values Monday Tuesday Wednesday Thursday Friday Saturday and Sunday simple variant are similar to inms in some other languages that you may be familiar with the syntax to create a variant type is to write sp. variant and then between parentheses the list of possible values and a type unit we'll see later how we can have variance with parameters where the type is different but for now you simply put a list where each element is a name then equals sp. unit meaning nothing to avoid repeating this every time we use a type we usually create a named type a custom type in the main module so in our main module we would write day of week column type equs and then sp. variant with all the different values then within your smart contract you can use values of this type for example in assignments or comparisons here we create an attribute in the storage called day and with initial value of Tuesday so when you use the value you put the name and then a pair of parentheses then you can compare this value to different possible value of this variant here we compared to Sunday or Saturday to determine if this is the weekend and the price for some work is more expensive during the weekend when you use variance you need to keep type inference in mind because if you don't specify the type it can be determined automatically using type inference but it will only be determined based on the actual values that you use so if you have a variant for all the days of the week but you only use some of the days in your code then the type inferred by the type inference algorithm will only contain the values that you have used but you may need the other values in some other cases so that could be a problem so in this example the type inference only creates this variant it only has Tuesday Sunday and Saturday type inference can't guess that there are other weekday than the ones you use in your code if you want to execute different code depending on the value of a Varian you can use sp. match as an alternative to using ifs and elves and comparisons sp. match works like this you write with sp. match and then between parentheses the value then you put one section for each value where each section start with with and then sp. case do the name of the variant colum and then the corresponding code in the test scenario with the current version of smart Pi the way you use variance within your test is a different syntax from the syntax you use within the smart contract itself this may change in the future but that is the case at the moment of recording to describe a given value of the variant instead of writing sp. variant Dot and the name of the value like you do in your smart contract in the scenario you will write sp. variant and then between parentheses the name of the variant between double quotes comma the value unit as a pair of parentheses and then if you want to check if a value is a given variant instead of writing your value do is variant Dot and then name of your variant and parenthesis you write is variant and then between parentheses the name of the variant between double quotes again most likely in the future version of smart py they should be Unified to the same version we use in smart contracts let's take a look at a full example that uses variant here we Define our custom type for the days of the week from Monday to Sunday then in our smart contract we initialize the storage attribute day with the value Tuesday we use sp. cast to make sure that we don't let the type infer determine the type of day but we say this is day of week to make sure that all the days are possible then in our work entry point we compare the value to Sunday or Saturday and determine the price based on that and finally in our test scenario we can call set day with a different syntax to create a value Sunday and then we can verify that the value has been set to Sunday using this test specific syntax we can give it a try and everything works as an exercise to practice variance write a contract that has an order drink entry point and that entry point should take the identifier of a drink as a parameter in the form of a variant it should charge the user the corresponding prices so if you order water you pay nothing if you order a CocaCola you pay one TZ or if you order Fanta you pay two TZ and the smart contract should store the items you order in a list named items POS video and give it a try let's take a look at the solution here we Define the custom type drink type as a variant that can have the values cooka Fanta water and we added seven up in our smart contract we simply Define a list we don't need to specify the types here but in the order drink entry point here we cast drink as the type drink type to make sure we have all the different types including seven up as possible values of our variant we set the default price at zero then we use sp. match to check the different possibilities so one test for Coca two test for Fanta and zero test for water Etc we could add more then we check that the person who ordered the drink paid the right price and then we add the drink to the list of items in our test we use the other syntax to create variants to order drinks can give it a try and everything works all good so you may wonder when you should use Simple variants simple variant are quite convenient when you already know the final full list of possible values so in the case of days of the week we know that they are not expected to change we're not going to add an eighth day of the week anytime soon so you're pretty safe with that variant or if you create a game of chess the list of chess pieces is also very unlikely to change in your game so varant in those situations are a very good way to make sure you never attempt to assign an invalid value and they make it convenient to use names in your code the alternative could be using Naturals from 0 to six four days of the week and same for chess pieces but it's very convenient to name each chess piece but variance could be problematic if you ever want to allow a new value in your list for example for a menu item in our examples where we use drinks we could easily want to extend the list of drinks for example we could add root beer or Sprite so in this situation using variance is actually not a great idea and for anything that could change where new possible values are likely to be added using numerical values or even string values are preferable to variant for example here we have prepared a smart cont contract split in two so this restaurant smart contract is pretty much the one we just worked on where you can order different drinks but then we added an entry point quick drink that uses another contract that stores the favorite drink of each user this favorite drink smart contract has a big map and for each user it will store the favorite drink that this user has recorded and then there's a view favorite that can can request the favorite drink of a user and then the restaurant can have an entry point quick drink that checks what the favorite drink of the color is and then orders that drink here it happens to be a free drink if you order your favorite drink now let's say we want to have a new version of the restaurant where we allow a new type of drink so for example we add stri so we create this drink type new where we have the same list of values but we add this Pride value that we might want to use in the new restaurant then we PR drink contract so that we don't lose all of the data and can keep honoring this quick drink offer but if we do that then when we create an instance of the new restaurant it won't work we can check it we can see here that we're missing the variant Sprite in the type variant that we use in line 71 so that's really the type inference that is not happy when here we try to push a drink in our list because the type of drink is not the same type that we have used in our favorite drinks contract and there's no way to make them compatible because from the point of view of the type inference those two types are really different so this shows that if you ever want to add add a possible value to a variant you could be stuck and unable to use existing smart contracts that you are used to interact with you would have to rewrite the favorite drink and then lose all of its data so that it can be compatible with a new restaurant so that's clearly one case where it might not be a good idea to use variant and instead you could just use strings or numbers so we presented simple variance where you simply have a list of possible values but you can do a lot lot more on tesos with variant you can have variance with parameters for example let's say you want to store a value that represents the current status of a worker the worker could be available could be absent could be away could be in a call or could be in a meeting if you know for sure that this list will never change and this could be a good use for variants but in some cases we may want to add extra information specific to one of the status so for example if the status is away we might want to store the expected date of the next availability of the user so we would want to add an time stamp to this away status or if the person is in a call you may want to add the URL of the online call so that somebody can join that call so here the parameter would be a string and of course we could also want to store multiple information in this case you would use a record for a meeting you may want to store the floor and the room of the meeting associated with the meeting value of the variant you may want to store a record with a string and an INT if you want to create a variant with one or more parameters you can create values directly like this so for no parameters we do as we have done before but then you can create a variant with a parameter where between the parentheses you simply put the value of the parameter and here for a record you simply put the value of the record of course we recommend using a type declaration as we have suggested before so that you can have a precise definition of the variant so here we would say that for the status away the type is sp. time St this is where you understand why we put sp. unit before this was to say that there's no information no parameter associated with this status so for simple variant you put sp. unit but for variance with parameter you put the type of the parameter so sp. time 10 for away sp. string for call and sp. record and the different attributes for meeting now how do you check the value of a variant that has a parameter so let's say we have a status variable in the storage that has one of the following value it can be either absent or away and with this time stamp to test if the status is absent we can use a simple comparison as we have done before you can check assert self. dat. status equals sp. variant. absent but this one won't work if we want to check if the status is away whatever the time stamp value is you cannot just compare to away because it could be a way and a value so if you want to check if a value is of a specific variant independently of the value of the parameter you can use this syntax you can do assert self. dat. status. isore variant. away this will make sure that the status is away with some value if you want to extract the value of the parameter from a variant you can use unwrap so you take your variable status and then dot unwrap Dot and the name of your variant so for example if you want to extract the time associated with the status away that we have defined like this s p. variant. away of this time stamp then you can extract the value of this time temp like this you can say deadline equals self dat. status. unwrap do away this should return the value sp. time stem of 1 2 3 4 5 that is contained in the variant as we defined here if the current value of the status is not of the away variant then it will raise an error as before in the current version of smart pi as we record this video the test scenario is still using an old syntax to unwrap the value of a variant you will write contract. dat. status. opencore variant of double quote away so this is different from what you use in the smart contract itself where you use status. and r. we can expect that in the future you will be using this syntax in the test scenarios as well so earlier when we were working with simple variant we used the match and with construct to handle the possible values of a variant we can use that for variants with parameters as well at the end of the width line for a given variant we can use as and the name of a variable and when the variant matches this case this variable name will contain the value of the parameter here's an example where deadline will contain the value of the parameter when the status is away so we write with sp. case. as deadline then we can use the value deadline that is basically unwrapped from the value of status and compare to some value if the parameter is a record the variable will simply contain the value of the entire record nothing special there let's try this on an example we'll create a contract that manages the status of an employee and so the employee can be available absent away until a certain date in the call but we store the URL where the call can be joined or in a meeting in a given room of a given name and on a given floor where the floor is a natural number the employee should be able to set their status with a set status entry point and their boss should be able to invite them to a meeting unless they are currently unavailable let's take a look at the code the beginning of our module we will Define two custom types the main custom type is for the status where we have a variant that can be available with no parameter absent with no parameter away with a Tim stamp call with a string that is the URL to join the call and then meeting with the floor and the room we'll talk about the other type in a little bit we have a contract employee status that will store the status of a given employee we initialize it with available and we also store the owner of the contract and the boss of that employee we have an ento set status where where the owner of the contract can change the testes so the owner here would be the employee themselves we have a set status entry point where the employee is allowed to change the status to a new value so here this is where we indicate that status is of this type to make sure the type inference doesn't forget any possible value for the variant then we have our invite entry point that allows the bus of that employee to invite them to a call or to a meeting and here we indicate what type of event they want to invite the employee to so this is why we need to describe this event type that can be a subset of the different values of the status type so in this other type we can have two possible values either a call with a URL or a meeting with a floor and a room we make sure the caller is the bus and then we'll have this first section where we determine if the employee can be interrupted and is available for this call so by default they can be interrupted if they're available that's fine if they're absent well they cannot be interrupted they're not here if they're already in a call or already in a meeting then they cannot be interrupted but if they Mark that they were away until a certain date then they can be interrupted if that deadline is passed so if we are after the time that they were supposed to be away then we check that indeed they can be interrup erupted and then depending on the type of event we set the status to a call or to a meeting here you can see that we cannot set the status to the value of the event itself because they're not of the same type those are two different variants so we recreate the call and recreate the meeting here with the meeting information that we extract from the event and we have a simple corresponding test and we can check that everything works well good let's do a recap of the the syntax you use when you manipulate variants if you want to define a variant type you write sp. variant and in between parentheses the list of potential values where each value consists in a name then equals and then the type of parameter Associated to that name if there's no type you can write SP sp. unit then when you want to create a value you write sp. variant Dot and the name of your variant if there is no parameter then you just put a pair of parentheses with nothing in between but you can also put a value of a parameter if it's a variant with a parameter if you want to check if it's a given variant when it's a simple variant you could simply compare it to the exact same value to sp. variant and then variant name one but if it has a parameter you cannot do that so you do assert your variable do is variant dot the name of the variant so that ignores the parameter and checks if you're that variant if you want to extract the value of a variant with a parameter you use unwrap so you take your variable do unwrap Dot and the name of the variant and then this will return the value of the parameter to execute different code depending on the value of a variant we saw that you can use the sp. match syntax so you write with sp. match then between parentheses your value and then you have different cases starting with withth sp. case the name of a variant column then the code you execute if that value is of that Vari if the variant has a parameter you use the same syntax but you add as value this is the name of a variable that you give and where the value of the parameter will be put then you can use it during this code at the moment in a test scenario you use a syntax that's a bit different if you want to create a value you use sp. variant and then between parentheses a string that contains the name of the variant then the value and if the value is nothing you put a pair of parentheses to represent the value unit nothing if you want to check if it's a given variant you can write s scenario. verify of your variable do is variant and then between parentheses the string that represents the name of the variant if you want to extract the value from a variant in a test scenario then you write your variable. open variant then the name of your variant between double quotes we discussed earlier when to use Simple variance we can ask the same question about when to use variance with a parameter or when to use parameters with a variant as we stated before a variance can be convenient if the list of possible values never changes the same applies in the case of variance with parameters both for the list of cases for the variant and for each case for the type of the parameter but you don't need to know all the values of the parameter in advance for this to work you just need to know their type the main use of variance with parameters on tesos is actually an internal use because in meason entry points are really variants each entry point you call has a parameter that corresponds to a different value of a variant where the name of your entry point is the name of the variant so the parameter of a smart contract is a variant type which with the different entry points and their parameters internally variant types are represented as a binary tree if we look at the melson code for a status example where it can be either absent available away on a call or on a meeting internally we have this structure of nested ores and we can represent it as a tree with the main ore here with two children each of them being an or between two values this one is between absent and EV available and the other one is between a way with a parameter Tim stamp and either call or meeting and when you want to describe a value of a variant what you describe is a path in that tree where you go left or right at each step so for example if you want to describe the value available you go left and right so in mikon you write Left Right unit for the value available if you wanted to have the value call you would write right right left and then a string to represent the variant call so this is good to know if you ever see errors related to variant or even entry points that talk about variants okay so under then exercise to work with variance and parameters let's create a new version of our fast food contract where we add more choices and here we listed all the different choices you can either buy a hamburger an ice cream a drink or a brownie the hamburger will be h t by default it has a parameter for the type of sauce that is a string a parameter for the quantity of sauce that is natural and the price will be increased by 0. two Tes for each sauce beyond the first two so the first two units of sauce will be free but then after that you need to pay 0.2 t for each then you can have a side dish with your hamburger that itself is a variant it can be either fries or potatoes and the price will be zero test for fries and one test for potatoes so you have a variant within a variant for the hamburger for the ice cream we have two parameters the flavor a simple string and the extra topping that is a Boolean do you want extra topping on your ice cream or not the price by default will be four Tes and if you add an extra topping you would pay an extra two test and we have no choice in what topping it will be for the drink we simply have a parameter that is the flavor and here instead of using a variant because we know we want to add more types of drinks later we decided to use a string and to keep it simple we said that every drink is three T finally you can order a brownie so this will be a variant without a parameter and which charge fight test so write a version of our fast food cont that can handle all these different choices pause the video and give it a try let's look at a solution here are the main part is to define the variant type so we Define a custom type food type that is the variant where the different possible values are hamburger ice cream drink and brownie brownie is a simple variant with parameter type sp. unit so no parameter drink has a string p parameter for ice cream we have as parameter a record with a flavor a string and an extra topping a Boolean for hamburger it's a bit more complicated so hamburger is a recur that has a type of sauce that is a string a quantity of sauce that is a natural and a side dish that is itself a variant that we hear Define directly in line we don't create its own custom type so we create a variant that is either fries with no parameter or potatoes with no parameter then in our place food order entry point we make sure we cast the parameter as food type using our custom type then we initialize the price at zero and then we will add to it depending on the type of food so we use sp. match on the parameter food if it's a hamburger we extract the parameter in the variable composition we set the initial price at eight TZ we extract the hamburger side the sauce quantity we check if the quantity of sauce is more than two then we add 0.2 T So 200,000 mes for each amount of SCE Beyond two so here we need to write minus two and do sp do ASN because we know this will be a natural then we match the side dish to either Varian fries in which case we add zero or the Varian potatoes in which case we add one if it's an ice cream we extract the parameter in composition and we check if there is extra tupping in which case we add two tees and if it's a drink or bronie the price doesn't depend on the value then we check the price is good we have a test where we buy a hamburger with fries an ice cream with extra topping and a Coca and finally a br we can give it a try and it works well good in this module you will learn about the fa2 standard and this will allow you to create tokens contract that can interact with all kinds of existing tools in the tesos ecosystem so when we talk about tokens we talk about any digital representation of an asset or utility fa2 stands for financial asset number two and it's a token stand standard that we use for tokens on tesos this token standard enables smart contracts to interact with each other and to interact with tools such as wallets and it does so by using a set of rules conditions and functions that any F2 contract need to apply the fa2 standard supports both fible and nonfungible tokens there's also the fa 1.2 standard that is an earlier standard that is simpler but only supports fungible tokens there's also a new version of A2 called a2.1 that is in preparation and it is retro competible with fa2 so anything you learn about fa2 will also apply to fa 2.1 so the standard defines three mandatory entry points that your contract needs to have to be compatible with the fa2 standard the balance off entry point is meant to return how many tokens of a given token ideas one or more users then the transfer entry point will be used to change the ownership of a number of tokens owned by a user and then we have a update operators entry point that will update the list of addresses that are allowed to perform transfers for a given token the standard also defines some value that you should have in the storage of your contract called metadata and it should contain information about the contract following another standard called tzip 16 we won't go into the details of that standard there's also a number of optional mikas Sun storage views get balance total supply all tokens is operator and token meta data we provide pieces of code that you can execute offchain to obtain information stored in the contract but obtain them in a standard way so if we try to implement a very basic A2 contract in the storage we will need to store two things we will need to store the Ledger that keeps track of who owns Which tokens and what information there are about each token so we will store a big map the key will be the idea of the token and the value will be both the owner and the metadata if we don't have any quantity value then we will only be able to handle nft types of token then we need to store operators so that's who is allowed to interact with a given token we'll stall them in a big map and the key will be composed of the address of the owner who set this operator the address of the operator who is allowed to perform actions on that token and the idea of that token and that's it there's no value so the value will be unit so as long there's an entry in the operator's big map for a given owner operator and token idea that means this owner allows this operator to perform actions in its name for this token the balance of entry point takes as parameter two values a call back that will need to be called to provide the result and a list of requests where each request is a record with the owner and the token and it's basically asking for each of these records please give me how many of the token this user owns and then the balance off entry point is supposed to call the call back function passed as parameter and send it a corresponding list of results and it will do that by sending a list of Records where each record contains the content of the request again with the owner and the token ID and the balance for that particular token so it basically says this user owns this much of this token the transfer entry point is used to transfer tokens from one address to another its parameter is a list of batches of transfer and each batch represents the transfer of one or more tokens from a given owner so it will contain a field from that will represent the owner and a list of transfers where each transfer contains a token ID and a destination so basically each patch will say we transfer tokens from this owner this token ID we transfer this amount to that other person and we'll say that for this token idea we transfer this amount to this destination so when we execute it for each transfer we will check if the Coler is either the owner of that token ID or an operator for this owner and token ID here as we only want to transfer nfts we'll simply check if the amount is one so is this nft owned by this owner so we will check that the owner really owns this token ID then when we're done checking all this we can transfer the ownership of the token to the destination given in the parameter finally we have the update operator where we want to say okay either say that we allow this address to transfer tokens in our name or on the other hand we want to remove this operator from the list of operators for a given token so the parameter of this entry point is a list of updates where each update will say if it's an addition of operator for a token or if we're removing an operator for this token then we say uh who is the owner of the token what operator we want to add and what's the token idea that we are updating this operator for so for each update if it's of type ad operator we will add an entry in the operator's big map we talked about earlier and the entry will contain the owner of the token the operator we're adding and what token this is about and if it's soft type remove operator we simply remove the corresponding entry the errors that those entry point May emit are also standardized so there's a list of different errors but here are a few you can have the fa2 token undefined that's when we make a request about a token IDE that doesn't exist at all or we could have A2 insufficient balance if you try to transfer more tokens than the owner has let's take a look at a simplified fa2 contract so that you have some idea of how it works so here we Define a few types we Define a transaction type so a record that authenticates a destination address for a token ID and a given amount then we have the operator type to Define who is allowed to transfer tokens for a given owner so we specify the owner the address of the operator and what token idea we talking about you will notice that we'll specify a layout because this is a standard melon representation has to be a very specific way for this to fit the standard and the representation is that it should be organized as a right com so a pair where the owner is the first element and the second element is a pair containing the address of the operator and the token idea so we use do layout to specify that it should have exactly this structure then to manage operators we have a variant that can be either adding an operator in which case the value is are recorded with the OWN owner the operator and the token idea and then remove operator where the value is also of the same type then we have our contract we see that we store a big map of tokens and next token ID it's started at once so every time we mint we will increment this value and add a new token in the Mig map in the mint entry point we simply take a metata that is a string and then we will create an empty set of operators that are allowed to transfer this token so it's a set of values where each value is operator type that we just Define with the owner operator and token ID then we create the nft itself that is a record with the owner the metadata and the set of operators and now we can increment next token idea so that the next token will have a different idea so we have the balance of entry point so that people can check how many tokens of a given ID I user has so the request is a list where each element is a record with the owner and the token idea so we basically asking how many of this token idea this owner has and we prepare a list for the results where we add for each request the corresponding answer we check that this token ID exist otherwise we have the standard error fa2 token undefined we fetch it from the big map we assume by default that the balance is zero but then if the token owner is the request owner then their balance is one so we add this information to the results so it's a list so we use sp.com to add to the result list a record where we specify the request again and the balance that this owner owns for this token idea so one if he owns it zero if he doesn't finally we send the result back by using this call back and doing an interc contract call where we send this result and zero test to that call back we then have our update operator entry point with a list of actions and each action is either variant add operator or remove operator if it is ADD operator we unwrap the information from the variant to get the data we cast it as operator type to make sure we are compatible with the standard we fetch the token corresponding to the Token ID that's in the operator data we check the that the owner of the token is the user who's trying to update the operators for that token we also check that we are setting the operator for this owner so the sender is the owner in the operator data and if that's all good then we add this operator data to that token so we say yes the operator address that's defin in operator data is allowed to make transfers for the token idea in the name of this owner if the type of the variant is remove operator then we do something similar except this time we remove it from the set of operators finally we have the transfer entry point where we take transfers a list of transfer as parameters and each transfer contains a list of transactions of type transaction type we check that we trying to transfer one of this nft because it's an nft you can only have one we check that the owner of the nft is indeed who we're trying to transfer from so that the transfer is valid we fetch that token and then we create the operator that indicates that we are looking for an operator for this owner the operator is a sender and we manipulate this token idea so we want to check if this user is an operator in the name of the owner to do transfers for this token ID here so if it is if there is such an operator in our set of operators for this token then we transfer the ownership of that token idea to this address and that's about all we have to do for a simplified A2 contract then we have a Marketplace contract that will interact with this fa2 contract it needs to store the address of the corresponding token contract and it will have a big map of offers every time we make an offer we increment this offer ID so when somebody makes a new offer we say I want to make an offer for this token at this price in the sense that I'm willing to sell this token at this price here we don't check that the seller actually owns that token we will check it when we do the transfer in the buy entry point and in the buy entry point so someone a buyer will call this buy entry point and say I accept this offer so we fetch the offer we check that the buyer pays the amount specified in the offer then we obtain the token contract based on this address we provide the type of the transfer entry point to obtain the address of the transfer entry point then we prepare the parameter so we create a transaction that is a record with the sender so that's the destination so the color to whom we will transfer the nft here is the token idea of the nft and here is the amount of the that nftd that they want to transfer we make sure it's of the right type transaction type and then we call the transfer entry point passing a list of transfers where each transfer is from the seller from the address of the seller and we have a list of transactions with only one transaction which is what we just created here so the marketplace says I want to transfer this token that is supposed to be owned by the seller and I want transfer it to the caller the buyer and the amount is one token so when I ask the transfer the token will verify that I'm allowed to the marketplace is an operator for this owner and this token idea we will of course check that the seller is the owner of the nft and if it is we will change the ownership and then I send the price to the seller and here we have a test where where we create a few accounts we create The Ledger itself we create the marketplace we main nft the owner of that NF Alice creates an offer to sell her token for tentes then we add an operator to say that the marketplace should be an operator for Alis for the token id1 so we add an operator and then we tested by having Bob try to purchase the token for 10 is so if we give it a try it all works so this should give you an idea of what an fa2 contract is and what a contract that interacts with it is so here we use the standard for the marketplace to interact with the token and it should be able to interact with other tokens that are also compatible with the fa2 standard in this module you will learn how to develop oracles a special type of smart contract that allows all the contract to obtain information from the offchain world and we will see that this makes many type of applications possible many smart contracts need to access offchain data for example if you want to create an insurance contract that can insure an event against some heavy rain then the insurance contract will need to access to weather data to decide if there was Indeed heavy rain during your event so you should be reimbursed for the Cor Corr responding loss or you could have decentralized Finance contract that need to access exchange rates for example some contract may need to determine what the exchange rate between the US dollar and the euro is to take some other decisions or you could create supply chain contracts that track shipments and may need to access to the current location of a ship in order to assess the current situation of the stock for example or you could imagine that some contracts may require some heavy computations that cannot reasonably be done on chain and so those could be done offchain with the help of an oracle now if we want to access offchain data could we simply call the API of some oft service for a smart contract when we need the data what issues do you think this could cause pause the video and think about it for a minute so if you tried to call a rest API directly from a contract assuming this was possible it really wouldn't work at all you would have three types of issues you would have consistency issues when you execute a smart contract the result has to be the same on every single node but if you use a rest Epi you have no guarantee that this rest API will always give the exact same answer every time you call it so when each of the the nodes of the network would call this rest API then some of the nodes may get a different answer from other nodes and that would create a mess then you have performance issues if the smart contract has to wait for the response from AR rest API that means pausing the execution of all the transactions in the current block and you need everything to be done in a specific order specified by the sequence of transactions in Block so while you wait you don't do anything SO waiting for AR rest API within a contract will slow down the execution of each block considerably finally there are reliability issues the execution of a smart contract needs to always work no matter what this includes running the contract weeks or years later when you want to reexecute all the transactions from Genesis for example so the execution of a smart contract and the result can't depend on the availability of some external service at the moment of the execution of the contract now can you think of a way to obtain this data without being confronted with those three issues pause the video and think about it so one solution is to pay for an offchain service to fetch the data from the original source of data and then call your contract with this data as a parameter so instead of pulling the data from the smart contract you push it from an offchain Source doing that solves all three issues it solves the consistency issue because once you created the transaction with the data as a parameter and injected into a block every node will get the same transaction therefore we'll get the same data it also solves the performance issue because when you execute the contract the data is immediately available to the node they are just part the parameters of the transaction so it doesn't need to wait for anything to execute the contract once it's in the block everything is available finally it solves the reliability issues because we can rely on the resilient architecture of a decentralized blockchain once data is in the Block it's available to all the nodes very quickly but we're not really solving the problem here we are just moving the problem somewhere else can you think of what could go wrong with this approach pause the video and think about it so the issue is that if you rely on an off service to send the data to the contract you lose the benefits of the centralization you lose the reliability aspect of the centralization because the offchain servers that you rely on could simply stop sending the data to your contract and your contract would just stop working you also lose the trust aspect because you have to trust that the offchain service will send correct data to you your contract whoever is in control of it could cheat and make it send invalid data and and make it take all kinds of wrong decisions finally it wouldn't solve the censorship issue because the offchain service could decide to refuse to send some of the data based on all kinds of different criteria including refusing to send some data that wouldn't be beneficial to whoever is in charge of that service so you could say okay if I cannot trust some off server to send me the data what about if I run my own service to fetch data from the original source and then send it to my contract would it solve all these issues I wouldn't need to trust some offchain service I would just run it by myself so pause the video and think about what issues this could create so the idea is that if you run your own offchain servers to provide data to your contract then yes you can trust yourself but you move the problem again cuz the whole point of a smart contract and of a blockchain is that users of the smart contract don't need to trust a third party so here instead of trusting this offchain service that some other party runs they will need to trust you the author of the contract to keep running your own service and so the problem is they cannot be certain that you will always keep your service running they also cannot be certain that you want change the data yourself before before sending it they really have to trust you and that's what we want to avoid to need when we use a blockchain so even the owners of a contract shouldn't need to be trusted once the contract is deployed so this approach may still be used if you are the original source of the data anyway and so you need to be trusted no matter what then you should directly inject the data in smart contracts sometimes the application makes it so that we have to trust you anyway at least for that part another idea if you're not the original source of the data itself is to have this original Source send the data instead of you going to fetch it and then provide it to the contract you could try to convince the original source of the data to directly call your contract then your contract could simply verify that the caller who's sending the data is indeed this official Source you could check the address the issue is that convincing official source process of data to call many contracts on many blockchains is unrealistic so for example if you imagine that we are interested in the weather data and we want to convince the weather agency to call your smart contract and send today's weather to your contract it's going to be quite hard to convince them to do so they probably don't worry much about blockchains at the moment so instead of having those sources try to call every contract that is interested in weather we could simplify things for them and have a single contract on the blockchain that is dedicated to receiving data from this source and this type of contract that centralizes all the data from a given type and makes it available to other contracts is what we call an oracle that's a contract that collects offchain data one way or another and makes it available for all the contracts but still even convincing this uh Weather Service to send its data to a single Oracle contract is not easy at all most potential sources of data are not involved in blockchains at all at least not yet so we can't really expect them to call oracles themselves before we continue I really want to bring your attention to the fact that incentives for people to inject false data into an oracle can be very strong because when you get incorrect data from an oracle your contract can make really bad decisions so for example if you have a contract that relies on knowing the exchange rate between two currencies but obtains the wrong exchange rate then it can make a terrible decision that could lose millions of dollars so it can be very profitable for an attacker to cause an oracle to return an invalid value if you check the news about blockchains and about attacks and millions that are being lost many times those millions are lost because of exploits related to oracles where the value provided by the Oracle is manipulated and as a result Millions were lost or stolen here I listed a few example just within a window of a few months where several millions of dollars were lost due to Oracle manipulations so it's really important to have ways to obtain accurate data from the offchain world so if we can't come convince official sources to send their data to many different blockchains and their oracles something that's a bit easier to convince them to do is to have these original data sources published signed versions of their data so instead of Simply publishing on an API here is the weather today in this city we would just ask them to add a signature to that message then we could run a service that would fetch this data an offchain service and I would send it to the Oracle contract and the Oracle contract could then verify the signature and therefore check the data indeed comes from the original data source doing this has multiple advantages whoever takes the data from the original Source API and then sends it to the arle by calling a entry point of the Oracle we will call them an intermediate they can't temper with the data because if they change the data the signature will be invalid and they can't sign themselves because the signature has to be done with the private key of the original source so we don't actually need to trust whoever is taking care of transferring the data from the official source to the Oracle because they have no way to change that data it's also quite reliable because you don't have to trust that some intermediate will do their job you can rely on multiple people to do it anyone can run their version of that service to increase reliability and go themselves call this API fetch design data and call the Oracle to make it available on chain of course this still assumes that the original Source will keep publishing correct signed data they stop doing it then your Oracle will stop working this kind of approach that relies on sources publishing signed data is used on tesos by what we call Harbinger oracles and the typical source of such data is coinbase where we can find exchange rates between different currency pairs okay let's work on an exercise where we have a contract that will use an oracle so we created a contract called binary bets that lets user bet on the outcome of sport matches and to keep Simple we will assume the following we'll assume that every game is identified by a unique value that we will call game ID again to keep it simple we will assume that the game only has two possible odomes true or false true may be that the first player won and false means the first player lost and therefore the second player one and we also assume that there is an official Sports Federation that publishes the signed result of every game and that we can trust so for the exercise we prepared most of the code of this simple binary bets contract and your job is to write the code of an Oracle and change the binary bets contract so that it calls this Oracle to obtain the outcomes of the sport matches and then reward the winner of the bets let's take a look at the code so here we have this binary bets contract that will store a big map of Bets with the usual next bet ID that we increment every time someone bets then we have the Oracle address and we have the fee that we need to pay the Oracle to obtain the result oracles are servers that want to make money so they may Char a fee when you request some information then users can call the create bet entry point to make a bet and propose a bet to someone on a given unique game ID and they say I bet that the result will be this so again to simplify we say the result will either be true or false so I bet that the result would be this and we set a deadline we say okay the result should be determined before this deadline if it's not then that means we couldn't get the data so we cancel the bet so we simply create an entry in the bets big map we say whoever called this entry point is player one we don't know player two yet so we just store the smart contract address in player two as a way to indicate there is no player to it's easier to do than using options and setting none but using options would be another possibility we store the game Ida we say how much we want to bet so we send that money to say I bet 10 T this team will win and we store of course the expected result the deadline and we say this has not been cancelled then another player could say I accept this bet so they provide the idea of that bet and then we fetch bet we check that the amount they provide is the amount that the other person bet plus the fee for the Oracle so here whoever accept bet is in charge of paying the fee to the Oracle person who creates the BET has a small Advantage we check that nobody else already accepted bet so player two is still the address of the contract itself and we check that the BET has not been cancelled we store the address of player 2 and we store the bed and here since we just accepted the BET here we create a request on the orle to say please send me the result of the game that we bet on and do so before the deadline that the user set so this part of the code is for you to write then we have uh withdrawal entry point that's when something wants to get our money back because the BET was cancelled so here we get the BET which check what amount we should be paid back if we are the player one then we can withdraw the funds either because the BET has been cancelled or because nobody else has accepted the BET yet so in this case we replace player one with self address to make sure that player one cannot call this a second time and be reimbursed twice then we make sure it's set as cancelled and then we send the amount to whoever was calling if the caller is not player one then we make sure it's player two otherwise they have no reason to call this entry point we check that it has been cancelled and then we delete Player Two by saying okay the address is now the address of the contract so it's not a real user and we add to the amount the Oracle fee that player two has paid and then we do the same so the way it could be cancelled is if somebody calls cancel after a deadline for a given bit and here basically the idea is to say if the Oracle didn't provide the result before the deadline that we set then the beted can be cancelled so here your work is to call the erle and get information about whether the result was provided or not to the Oracle and if not then that means people can be reimbursed so the bet is cancelled finally when someone has won the bet they can call claim prize to get their funds so here we check that the BET hasn't been cancelled then we get the result from the Oracle this should only be called once the Oracle has the result we can check that off chain before we make the call if the caller is player one then we check okay did they win is the result what they expected the result would be and if it's not player one then we make sure it's player two and if it is we make sure that the result is not what the first player expected it to be so if we don't fail that means the caller has one so we send them the amount of the BET times two and then we delete the bet so that they cannot claim the price a second time and we need the default entry point because in case everything is cancelled we need here the Oracle to reimburses and the way they reimburses is by simply sending the fee back to this contract through the default entry point so we should have a default entry point to be able to receive the test and here we have started trading the Oracle contract and it's going to be for you to implement it but all you know is that the Constructor takes an admin and then the public key of the source from which you will get the data and so the idea is that when you get data from The Source you will verify that it contains a signature that matches this public key we can now take a look at the test so here we have created three usual accounts and a special account that we call data source that will be the account that won't be an account that directly interacts with the blockchain but that will be the account whose key is used to sign the data so we first create our Oracle so you provide the address of the admin Alice and then the public key of the data source so that we can use it to verify signatures then we create the Ping contract and we say the fee for the Oracle is two TZ then we have a first test where everything goes as planned so we have Alice create a bet on game with ID one she expects the result to be true and she says okay the result should come before this deadline and she bets five T then Bob first tries to accept the bet but by paying only five Tes so this should not be good because Bob needs to pay for the Oracle fee which he does in the next attempt paying seven test then Alice tries to claim the prize before the Oracle even got the result so this should not work so here you will add the part where you send the assigned result to the Oracle that the Oracle will verify after the Oracle got the result Bob will try to claim the price but Bob actually lost because you sent true and Alice bet that the result was true so Bob lost but then Alice one so she can claim the price and this should work then we have a second test case where this time we cancel after the deadline so in this case the orod never obtains data so as soon as the deadline passed test at 1,1 we cancel and everybody should be able to get their money back and finally we have another one where this time Bob wins so your job is to complete this contract by writing the code for the eracle writing all the different calls and completing the test to send sign data to the Oracle and check that everything works pause the video and give it a try let's look at a solution so we will first start by looking at the Oracle contract in the Constructor we store the admin and the public key but we also create a big map of requests that the Oracle will receive and we also store the fee there will be two test when a user requests the result for a given game they need to pass a bet idea so that we can identify their request using their bet idea for a given color we'll see that in a minute and then of course they need to say for which game ID they request the result and what's the deadline for the Oracle to provide this result we indicate that bet ID and game ID are Naturals and deadline is a Tim stamp we check that they paid the fee and we will create an entry with the key being the BET ID and the address of the caller because multiple contracts may call this Oracle and each contract uses its own system of ideas for their bet but for this contract we have a unique bet ID that identifies this request we check that this is not already an entry for this bedge from that contract otherwise they may overwrite a previous request and M things up and then we create the entry where we store that for this bet ID and this sender this is the game idea that they request information for this is the deadline and we set a result that is an option that we initially set at none to indicate that we didn't receive the result yet when we do receive the result some servers will be constantly looking from offchain at what request the Oracle has received and when it sees a new request it will go fetch the data from the original Source the sign data and then send the result of that request to this entry point so when they do that they know all the information about the bet so they can provide the BET idea they can say which contract was doing this request so that we can rebuild the key for that request and they send the message that will contain the result plus the signature associated with that message the message itself will contain the game ID and the result if you only sent the signed result but without saying which game this is then the same result could be used for many games and so people could cheat it's really important to have all the information in the message so that the message is the proof that the source that signed this message claims that the result for this game is this result so after getting the key we fetch the request from our requests big map we check that the game for this request is indeed the game indicated in the message and then we check that the signature that we've received corresponds to this public key signing this message that we pack when we check a signature it has to be a sequence of bytes that we check so we need to pack the message before we sign it and before we verify its signature then we can store the result and we have to store it as an option so we store the result as an option on the result that was in the message finally since we did our job we received the result before the deadline then we can send the fee to the admin actually here we need to check that we didn't already get the results so we need to assert but it was none otherwise we could send the result multiple times and get the fee multiple times the Oracle will have an unchain view so that the contract can immediately fetch the result it will simply pass the key and it will return the result for this key and finally if the contract didn't get the result before the deadline they can call cancer after deadline to get their fee back because the Oracle didn't perform their service so they shouldn't get paid so we say for which bet ID we didn't get the result we fetched the corresponding request we checked yes indeed the deadline is passed we check that the result is still none so the actual result of the game has not been provided then we send the feedback and to make sure somebody cannot cancel twice we Del delete this request so another we have an oracle where we can make requests receive the results signed by the source obtain the result from the contract and cancel the request and get the feedback if nobody sent the results so in our betting contract when we accept the BET then we call the request game entry point from the error call we pass the best idea the game idea the deadline and we make the call when we want to cancel after the deadline similarly here we call the cancel of the deadline entry point here but we do that after verifying through the get game result view that the result has not been provided for the the result is none finally when we claim the prize we call the get game result view to obtain the result we unwrap it and then we award the player if this player has one based on the result in the test here we send the result to the eror call so we prepare a message that contains a game ID and the result we sign that message with the private key of the data source so of course this in practice would happen in some service of chain that sees the request and then calls the smart contract and here we call the receive result entry point we say for which P it is we say for which contract we send the message and the corresponding signature and we do the same here with the version that shouldn't work let's give it try try everything works and we can let you play with the code and check that everything works as expected the Oracle was presented was a very simple Harbinger type of Oracle but it relied on a single source which means we have to trust that source and a lot of cases we really don't want to trust a single Source because a source of data could simply avoid publishing data that doesn't benefit them and similarly if we rely on a single transmitter this single transmitter could avoid transmitting data that doesn't benefit them in some cases when it's about data that changes on a very freaking basis maybe the source of the data or the transmitter could decide to only publish or transmit the values that benefit them and skip the ones that don't benefit them when the value of a token for example goes up and down with time and preventing this behavior from a single Source or a single transmitter is really hard finally if you rely on a single source of or on a single transmitter this causes reliability issues if this source of this transmitter stop doing their job so what we want to do in practice to avoid especially relying on a single source is to combine multiple sources of data so we can fetch data for multiple sources one available if there are multiple sources for example for the weather there may be different agencies that publish information about the weather or for the exchange rate between the US dollar and the Euro you can expect a lot of places to be able to provide that information independently and you could also rely on multiple transmits to take care of sending this data to the Oracle so you should never rely on single transmitter and check the address anyone should be able to send this data the data is signed anyway so we don't need to trust the transmitters so we could have multiple transmitters running at any time and then the oracles that would get information for multiple sources would have to check that enough sources agree with the result and enough sources provided the result and if the set of different values we could take the median of the value as the actual value that the Oracle would return and if this is about a value that changes over time at high frequency such as an exchange rate we also want to average it over a short period of time so that we can avoid flukes like between two different calls it goes up down up so you want to average it over a period of time to to have a better estimate of what's the current value we won't go into detail of different ways to do that but some of the ways to do that include doing some of this work of chain so this idea of using messages that are signed by official sources is great but in practice unfortunately very few sources of data publish such sign data for blockchains for the moment but even if they didn't plan to publish signed data they actually do so for other reasons in particular when you access the website of a service or you access a rest API you usually do so through the https protocol but using https means that the data is encrypted using the private key of the domain's certificate so this means you can verify the authenticity of the data when you decrypt the data that the API returns through the public key of the certificate using SSL so this cannot really be done in a smart contract you cannot send the full https response to an Oracle and expect the Oracle to decrypt it so what we need is a service that we can trust and that will take care of doing this https request to the web page or the API of the original source that publishes the data then decrypt the https response extract the data you need from that response and then sign it and send it to an oracle so if we do trust the service that does that then everything is good of course the issue is how can we run a service off chain that does all that and that we can trust to have such a service we will need to set it up on an architecture that really guarantees that it Run unified code so you write the piece of code that does all that and you have to run it on Art architecture it will tell you yes this is the code what was actually executed and this service will fetch the data directly from a source using https request and then we'll call the Oracle contract with that data along with the proof that all the codee was executed and modified IED and all the Oracle would have to do is check that proof to verify that the service has not been tempered with and indeed the script that you wanted to execute is the one that was executed this is actually possible using what we call trusted execution environment or tees for short tees are architectures that guarantee that the software that is run by the service has not been modified and corresponds to a specific hash so you provide the code you compute its hash and the service will be able to provide a proof that the code that was run was the code that matches this hash and it can also guarantee that the SSL connection it used to fetch the data was secured and the data hasn't been tempered with there are a number of providers of trusted execution environments and this really means running some specific Hardware in a special mode that guarantees that nobody has tempered with the machine even the people who have physical access to the machine there are different solutions to do that but one of it is to use some Android phones that have the right Hardware to be able to provide this kind of security on tesos we can use the acurus service that specializes in using tees using Android and provides a service where we can set up this type of oracles BAS based on the safety net architecture you run your mobile phone in a special mode where you cannot do anything else all they can do is execute scripts in such a way that you cannot interfere with them if you want to learn more about oracles we invite you to check the indepth oracles article on open.com in this module and the next few ones you will learn how to detect flaws in smart contract and learn about best practices to avoid these flaws in your own smart contract the first flaw is related to the use of the sp. source command there are two ways in a smart contract to check who called the contract so far we have used sp. sender that gives you the address of the direct color of your contract but you can also use sp. source which gives the address of the user who is at the origin of the chain of calls of smart contracts so for example if a user a calls a contract B and that contract B then calls a contract C from within the contract c sp. cender will correspond to the address of B so the direct color of contract C but sp. Source will correspond to the address of a the user who is at the beginning of the chain of call so user a called contract B that called contract C but since a is the initial caller that's what you get when you use sp. Source but it's never a good idea to use sp. source and it may Ed for attack so I recommend for you never to use sp. source so for example if you look at this small smart contract can you find the flaw and how someone could take advantage of it so this is a contract for charity where people can deposit some funds using a deposit entri Point here and then the admin can decide to donate some of the funds that have been given to a specific charity so you say how much you send and to which charity so think about how someone could take advantage of a flaw in this contract related to the use of sp. sour pause the video and think about it for a minute so the issue is that an attacker could convince the admin of Charity fund to donate to a fake charity and could be a very small charity and could be just for a few test but when the charity fund donates to the fake charity transfer of TZ to this other contract would call the default entry point of that fake charity contract and that entry point could then call Charity fund. donate and by doing that impersonate the nmin so from the point of view of donate if we look at the code here we check that the original Coler is the nmin but if we call the fake charity from here then the fake charity calls donate again but with a different amount for the donation and with a different charity then they could trick the admin into donating all of the balance of the contract to some destination address the different steps would be that the admin calls charity fund. donate of one test to the fake charity then charity fund. donate would transfer some test to fake charity therefore calling the default entry point of fake charity and then this default entry point will would call Charity fund. donate let's say with a thousand T and with the destination being the attacker address and so charity fund. donate would check that SP source is indeed the admin and assume okay the source is the admin therefore it's the intention of the admin to do that transfer and then we transfer a thousand test to the attacker address so basically the admin thinks they're just donating one test to some contract but in practice a th000 as well be spent so this is very dangerous there is a very easy way to fix that flaw it's simply to avoid using sp. source and instead use sp. sender so to require the admin to make a direct call to char fund. donate and this way they cannot be tricked into doing something else more generally if a contract uses sp. source to identify who is calling the contract all he have to do is Trick the admin to call a small small smart contract you created that only requires a small amount to be transferred but then your smallart contract could do anything in the name of the admin with that contract that uses sp. source so make sure you simply avoid using sp. Source there's never any good reason to use it as far as I know here is the code of the fake Char ready contract it stores the address of the contract to attack so the charity fund stores the address of the attacker and then when it's default entry point is called here when the charity fund sends some test to it then it calls the Donate entry point of the charity font but with the donation of thousand t to the address of the attacker and that's it all you need to do then is convince the admin to donate one t from the contract to your fake charity you can give it a try and you see that indeed thousand T our trans to the attacker's address a second type of flaw that is extremely common so you should always be very careful is when using sp. send especially if it's a destination that is not the caller of the contract and even in some case when it is the color of the smart contract so you should be very careful when using esp. sent here is an example of a part of a contract that is likely to have this kind of flaw where we send 10 Tes to some address and then 10,000 Tes to you to the caller here some address could actually be the address of a smart contract that means when we call send to transfer 10 test to this address it calls the default entry point of that contract and that default entry point could fail and this would make the whole smart contract fail therefore it would prevent the transfer of 10,000 test to your address so you should always be careful whenever you send some test to some address you should think about what if this address is actually a smart contract that has a default entry point that rejects the funds so for example let's say the destination of this ver call is this contract we see that it has a default entry point that checks if the Boolean open is set to true so we initially set it to true but we have this set State entry point where the admin can set the state of the open value to true or false so this way you can control when you're allow to receive the funds and therefore control when this contract is going to fail or work so by using this contract you could block some user from getting their the money that is owed to them and then extort some extra money from them as a condition for you to enable the transfer of test your contract with changing the state of open so you can tell okay I know you have 10,000 test stuck in this contract I have the power to unlock it so give me a th T and I will unlock it for you so that's a way to extort funds so the best practice to avoid this kind of flaw is to always let users claim their own Tes through a separate claim entry point we have already seen that in the nft with royalties contract where we had this exact issue and allowing this claim entry point may require you to add a ledger to your contract if there are multiple users that may have Tes in the balance of the contract that need to claim so if you add a ledger a big map that for each user address keeps track of how much is owned to them by the contract then anytime you want to send some test to someone instead of doing the sp. send you simply add that value to their entry in The Ledger that's something we already did with a multiple nft with fixed contract that we all in another module another common flaw is related to unlimited computations and we talked about this already on tesos we have this notion of gas that is an estimate of the amount of CPU used by a transaction and when you emit this transaction you have to pay a fee that covers this gas but there is a limit to how much G you can spend in a single transaction there's also a limit to how much G you can spend spend in a given block but if a contract call exceeds that limit of how much gas you can spend in a transaction the call will fail and this may mean funds will get stuck in the contract so it is very important to make sure that the gas consumption of a contract can't grow indefinitely and exceed that amount to avoid this kind of flaw you have to avoid storing data that can grow indifferently because you have to remember that the store of a smart contract has to be deserialized at the beginning of every call to an entry point and has to be res serialized at the end of the entry point and this cost gas so you need to make sure that you check this whenever you use lists sets and maps and even basic types that can grow IND definently for example strings can be as long as you want or in nuts and Tim stamp in general the idea is to use big Maps whenever you want to store unlimited amount of data because you can have as many entries as you like in a big map you only pay for the distalization and calization whenever you access a specific entry of the big map but of course if that entry is too big then you still could spend too much to diser realize it so it doesn't guarantee that you won't have any issue so make sure you don't store too much in a single entry of a big map another option in some cases is to consider storing data off chain if you don't actually need the data on chain you don't need the smart contracts to have access to it you may store them off chain so for example you could store it on ipfs so the second part to avoid unlimited competions is to avoid Loops where the number of iterations of the loop can grow indefinitely and to avoid that you can usually do the computations off chain and let the contract focus on verifying that everything you computed is correct and when you cannot do the computation of chain another possibility is to split the computations into multiple contract calls so that in the first call you do part of the computation and then in the second call you can continue the computation that might be necessary the best option is to try to do the competitions of chain whenever you can for example let's take a look at this contract this contract called time save can store deposits that will be stored in the balance of the contract and can only be withdrawn by the owner after a certain deadline so whenever you deposit some money fall the owner you set a deadline and you say okay they will only be able to withdraw that amount after this deadline and here we add all the deposits in the list and whenever the user wants to withdraw we Loop through the list find out all the deposits that I have deadline that is expired and then count the corresponding amount and then transfer that amount to the owner so here we clearly have a data structure in the storage that can grow indefinitely someone could make very small donations and deposit many many different amounts but very tiny amounts like one MCR at a time so much so that the size of the list would be so big that diser realizing the data would take too long and exceed the maximum of guys you can spend in a transaction so here are the ideas that this list can grow indifferently nobody can control how much it can grow there are some ways to limit it you could just set a hard limit on how many deposits there can be at a given time and then delete the deposit when you withdraw the corresponding money or you could make it that deposit has to be at least 100 Tes so it would be extremely costly for someone to add so much to make so many deposits that the contract could get stuck but a better approach is to use a different data structure and use a big map here is a version of the contract that use a big map for the deposits we count how many deposits are been so that we can use this as a key for the big map with all the deposits and whenever somebody calls deposit we create an entry with the key being the current value of the counter and in this entry we record the center the deadline and the amount and this way each entry with all the entries in a big map the data structure can never be so big that just calling an entry point would distalize the whole thing and then exceed the maximum amount of gas you can spend in a transaction however we still have a loop here that goes through all the different elements of the big map by trying every possible counter and so in practice we still have to deserialize everything when we try to withdraw so we can of solve the problem for the deposit entry point that can never fail because it's not going to deize the whole content of the big map but then in withdraw we have a loop so the loop itself may have too many iterations and exceed the total amount of gas you can spend in a transaction but more so you will have to deserialize all of the content of the big map so that doesn't solve the problem to solve this problem instead of a loop that goes through all of the elements we can do the computation of chain of which entries have expired deadlines so instead of looping through every single entry in the big map and then checking if the deadline is expired we do that computation of chain and then when we call withdraw we send a list of keys where the deadlines have expired and so the loop here only enumerates all the entries that have been listed in the parameter it could still be possible that the list is so long that we cannot execute the whole Loop but then we can split the call into multiple calls and then maybe do only half of the list so that we only need to Loop through half of them and distalize half of the entry the caller has control over how many items they put in the list so in this case we are safe we avoided using the type of data structure that can go indefinitely by instead using a big map and we avoided doing a loop that can grow indefinitely and instead did the competition of chain and let the user send a list of items they get money from and that solves our problem in this module you will learn how you can reduce the amount of fees you need to pay when using a micro payments contract where you have to perform a lot of transactions to buy lowcost items so the challenge is to create a micro payments contract let's say a person a very often wants to buy cheap items from a seller B and wants to pay using TZ so we will have transactions where user a gives some amount of M to be a small amount compared to transaction fees and then B will give some item to a so a buys an item from B but at a very small price so the question is how can we do that in the cheapest possible way we don't want to have to pay a transaction fee for every purchase if the item is very cheap we might end up paying more inunction fees than what we actually need to pay for the item but we want to do that by still enjoying the security of the block blockchain we don't want B to have to trust a or a to have to trust B but we can allow for a little bit of risk so for example B could accept that maybe they will lose the amount for one sale but no more than one so B might accept that they will lose the price of one item purchased by a but no more than that so with this constraint try to think about a way you can reduce the transaction fees to the the minimum pause the video and think about it for a minute if we really want to avoid paying too many transaction fees the best way is to avoid doing transactions at least onchain every time you do an onchain transaction you need to pay a fee but we could handle most of these transactions of chain using signed messages the idea is that we would create a micro payment contract where user a will put some amount of test a deposit on the micro payment contract that it is reserved for A's future purchases from B so that amount is really strictly reserved for B and we set a deadline the idea is that a May withdraw those funds but only after that deadline so the idea is that b knows that there is some amount for them that will be available in the contract until that deadline once we have that deposit in the micro payment contract every time a wants to purchase an item from b instead of doing a transaction on the chain and calling the contract and paying the fee a will send a signed message to b so a message would say I hereby declare that I owe you this amount of money more precisely I can say the amount I owe you is now X mutes signed a and of course the signature will be a cryptographic signature that a smart contract could verify so this message is directly sent to be off chain without going through any smart contracts any way they could be by email could be any means and then once B receives that message they have a proof that a owes them money and so they can send the corresponding item to a whenever B wants to get paid whether it's because the deadline is getting closed so they want to make sure a doesn't withdraw the deposit from the contract or whether there's quite a bit of money or that they want to to have and they are ready to pay a transaction fee to get that money then B could call the macro payment contract and sendeth the last sign message signed by a that says I owe this mat to be the smart contract could then verify the signature and if the signature is valid then the contract could send whatever amount a owes to B so to do that we need to be able to sign and verify signatures on tesos you can sign any piece of data as long as it is in the form of a sequence of bytes that's the only type of data you can sign but thankfully we can convert pretty much any data to a sequence of bytes and back we can use the pack instruction to convert type data into a sequence of bytes and later we can unpack this content to extract the typed content so it could be a record for example we pack the record we just get a simple sequence of bytes then later on we can unpack it and get the record back once we have a sequence of bytes we can use a function called make signature to generate a signature for a given sequence of bite and of course we use a given private key to generate this signature on the other side the destination of the message can use check signature to verify the validity of a signature verify that it corresponds to the public key of whoever is sending it so let's look at the syntax to pack and unpack data it's pretty straightforward you can call sp. pack of your type data could be almost anything could be a number could be a record could be a list anything you liked and then you get a pack data that is of type B then you can unpack this data by calling sp. unpack you pass the data and then you pass the description of the type of this data this returns an option it could be done if it's impossible to unpack this data into this type it could be a different type so we use unwrap sum to get the original data back once we have packed data we can use make signature to create a corresponding signature and we pass the secret key of the user and the pack data and we obtain a signature when we want to check the signature we call sp. check signature we pass this time the public key of the user who is supposed to have signed this message we pass the signature and we pass the pack data so this verifies if the signature corresponds to this pack data signed by the person who has this public key we don't need the secret key to verify the signature and this returns true if this is indeed a signature that corresponds to this message and this public key with that your job is to write the corresponding contract with its tests the storage will simply need to contain a big map with all the deposits what is the key and the value for each entry is up to you and we will have three entry points one entry point for someone to deposit some funds for a given seller so we say who are these funds for we set a deadline after which we will be able to withdraw the money back and we send our public key so that we can sign messages and have the contract verified that they come from us so whatever amount is sent to deposit sp. amount will be stored as a deposit from the center to this destination so we create an entry in this big map or update it if there's already one when seller wants to get paid they can call claim payments they say I want to get some funds from this user and here is the message they last sent me and here is the corresponding signature so the contract will check that the signature is valid for this message so the signature is indeed a signature for this message using the public key we stored for this source so the public key we passed here once it checked that the to valid it can transfer the amount that the source owes to the caller and then it will update the corresponding deposit entry finally when a user wants to close their account and withdraw their Deposit they say I want to close my account that I have with this seller so we fetch the corresponding entry in the big map we check that the line has passed and we transfer any funds that haven't been withdrawn yet here we purposely left some details for you to work on so your goal is to implement this contract and try to make sure that there is no flaws that somebody could use to steal some funds or get funds stuck pause the video and give it a try let's look at a potential solution here in the deposit big map we will create entries where the key is composed of the source and the destination so a deposit is really some funds we store for our source and a destination so it makes sense to have an entry for each pair source of destination here we use the record we could also use a pair as a key then we check if there's already an entry and if not we create one we store the deadline the amount that was sent the public key and we also store how much has been spent so far out of this amount and if there is already an entry we verify that the new deadline is after the previous deadline we can only extend the deadline we cannot bring it closer to the present otherwise it would be too easy for a to get their money back even though be trusted that that money would be available in the contract so we can only extend the deadline and here we update the deadline and we add the newly deposited amount to the amount stored in the deposit once there is a deposit for some user reserved for Destination then this user and this destination this seller can freely exchange messages where a sends messages that says I now owe you this much and then B says okay then I can send you this item Etc and the amount a owes to be increases increases and when the deadline gets near or when the amount is quite a bit and B wants to get it out of the contract B can call claim payments they I want to claim the payments from this source and here's the last message that sent me this last IO you and here is the signature that proves that it comes from them so we get the key for the corresponding deposit then we check the signature so we check that this signature corresponds to this pack message with this public key so it has indeed been signed by the public key we stored for this user then we unpack the message and in the message we store the destination and how much the author of this message owes to this destination so the total they owe so far since the beginning which check that the destination is the person who's claiming the payment then we compute how much they need to pay to them now and that amount is the amount indicated in the message so how much I owe you so far minus how much we already sent them before so how much they already spent in the previous message so the idea is that a always increases the amount they o to B since the very beginning because if a sent I ow you 10 more tests than last time we would need a complicated system to track okay when was this message sent how much did we owe last time Etc it would be hard to really know how much we need to send to B but if we simply accumulate how much a has pened in the beginning and then how much we already took from the deposit and send to B then it makes the computation simple so the amount we need to pay is the amount AO so far minus what we already got from them we make sure they have enough in their deposit to pay for that amount if not that means B accepted payments for which there was no corresponding deposit so B made a mistake and they could maybe send a previous message where a didn't owe as much then we update the amount in the deposit we subtract the amount we are paying to B we increase the total amount that we are paying to be so far we add amount to pay and then we send that amount to the sender so send that amount to the seller to B finally when a wants to close their account we fetch the key we check that this is after the deadline and then we send whatever is left in the deposit and and we delete the deposit in the test we create different accounts and here in the test we create a deposit from Alice that deposits 100 t for the seller Bob with a deadline a th000 then when Alice wants to spend a little bit of money and purchase something from Bob she can create a message that says I know all five T to Bob she has to pack the message and then sign it with her secret key so this is done offline she could send more and more of these messages increasing the amount every time by the price of the item she wants to purchase and then eventually when Bob feels okay now it's time for me to get paid Bob will call claim payment saying I want to be paid using the deposit from Alice here's the last message I received here is the Corr opening signature I'll is sent me and Bel gets paid we can give it a try and we can see that indeed Bob gets paid unfortunately there is a big flaw in this contract pause the video and take a minute to try to find it there's a couple similar flaws in this version of the contract the first one is that if Alice closes her account we delete everything and later on she decides to do some business again with Bob then she would deposit some money again saying okay I'm depositing some money I want to make new purchases Bob could steal her money can you figure out how pause the video and think about it for a minute so the issue is that if Bob saved this message and the corresponding signature Bob could send the message again to claim payments and get the same amount again Alice didn't make any new purchase but Bob still has a copy of this IOU 5 test from Alice and the signature is still valid the message is still valid so claim payments would simply send the five test to Bob now how can we avoid this pause the video and think about it for a minute so what we really want is to make sure that the same message cannot be used Again by Bob there's a couple ways to do that one way would be to never a close deposit here instead of sending everything and deleting the deposit and resetting everything and then forgetting that there was already a history between Alice and Bob we could simply reduce the amount deposited to Z but keep the record in our big map this way we remember that the amount spent so far is already five TZ so if BB sends a message that says Alice owes me five TZ then we check well you already received five test from Alice so there's nothing Alice owes you and if Alice wants to make a new purchase she would have to say okay I now owe you five plus xas then Bob could claim the extra xas so that's one way to do it never to close the account another more typical way to do it is to make each deposit entry a bit more unique by adding some information adding a counter similarly to what we do to transactions if you remember a description of how transactions are verified transactions have a signature but to avoid transaction being replayed we add a counter to each transaction that says how many transactions has this user signed so far so we could do exactly the same here when we deposit we could add some counter that we store and that the author of the deposit should increment every time they deposit some money if we are simply adding to the existing funds we shouldn't count the counter this is a counter of how many times we recreated the deposit and then when we claim payments in the pack message we should have the value of the counter and here we could check that the counter for the message equals the counter for the deposit of course when we sign messages we need to add a counter as well so if we close the contract created a new one then we would use accounter two so that messages for a given deposit cannot be reused next time we recreate a deposit and here when we deposit we have to send the counter so counter all good but we still have a flaw and the flaw comes from the same idea of the same signed message being replayed being reused in a different context so now that we have this Contra in the message that says okay this is the third time that we create a deposit and so everything should be reset and every message from previous deposits are not valid anymore but still it would be possible in some cases for Bob to steal money from Alice pause the video and think about it for a minute so the issue here is that we could have multiple instances of this micro preman contract and there is nothing in the messages that says that those messages are about this contract so we could even imagine that a very different contract just happens to have a structure of messages that contains a record with a destination with an amount and with a counter that would have nothing to do with micro payments it's just used for something else and then Alice and Bob happened to be using that other contract so using a message with the same structure for a different contract Bob could call claim payments and extracts funds from this contract that has nothing to do with this message and the way to solve that is to add to the message the address of the contract that we are talking about so here we would need to add contract equals micro payments address to make sure this is about this contract and then here we would get Contract sp. address and then we check message. contract equals sp. self address this time a message dist to a different contract couldn't be reused in our contract this makes everything a lot safer so this idea of always having some kind of Contra in the messages and identifying for which contract the message is and really making sure that the information is complete that says everything we need to verify then you can avoid this flaw of being able to replace signed messages in this video we'll look at a smart contract that enables people to play a geocaching game and will will discuss a number of potential flaws in this smart contract geocaching is a game where one person hides one or more Little Treasures somewhere in the world it could be anywhere and then they publish hints about the location of these treasures and the players use this hints to try to find those items so here the goal is to create a smart contract that makes it easy to play this game for each treasure we assign a unique identifier and a password so if you find the capsule containing a treasure you can call a contract to prove that you indeed found the treasure and the password and ID that it contains and so we could make it into a game where the person who finds the most Treasures gets a reward so the interesting part in this contract is that we will need to be able to verify that a player found a given password but we can't simply store the passwords directly in the contract as we discussed before the storage of the smart contract is public so if we simply store the passwords in the contract anyone can simply see the password and then send them to the contract and pretend that they found the treasure so the question is how can we verify passwords without storing them pause the video and think about it for a minute so a typical way to verify passwords without saving them is to store the hash of the passwords that's what most authentication systems use they store hashes of passwords typically with added salt so that they can authenticate users without keeping the actual password in the database so here we will use a cryptographic hash function that we apply to passwords and those have a few key prop properties for the same input they always produce the same output that we call the hash of that input and if you're given a hash it is virtually impossible to find an input that produces this hash unless you actually know the original input or unless you try every single possible value which typically would take way too long for anyone to ever find the correct input value so the input value here the actual password that we will hash needs to be large enough that it's impossible to simply try every single password and check if it gives a given hash so instead of comparing the password to a store password a contract can verify a password by Computing its hash and then comparing it to the stored hash so let's take a look at the first version of this mod contract in the storage we will keep a big map with all the treasures and we will see that for each treasure the key is an identifier a simple number that we increment every time we add the treasure and the Valu is a record that will contain the hash of the password and a flag that says if somebody found this treasure then we will keep the scores of the different players so for each player we will keep their current score we will maintain the address of the current winner we initialize it with the owner's address and then we also need to initialize the score of the owner to zero so that as soon as somebody finds a treasure they can become the current winner and we can compare their score to the score of the owner we separately store the address of the owner we store a deadline after which we will give the award to the winner and then uh we count the number of treasures the owner is able to create a number of treasures and all he needs to send to the smart contract is the hash of the password we check that he does that before the deadline and that only the owner can call this contract we increment the number of treasure and then we store the information and say this treasure has not been found yet then when somebody discovers a treasure they need to send the ID of the treasure and corresponding password so we check that they do so before the deadline we obtain information about the treasure we check that it hasn't been found yet then we compute the hash of the password was send Using sp. blake2b and we compare it to the hash of the treasure if it's correct then that means the treasure has been found and we just have to increment the score of the player so if there's no entry for that player in the big map we create one with score zero and then we increment their score by one and if their score is more than the score of the current winner then they become the new current winner finally after the deadline the owner can call this award prize entry point we check that he does so after the deadline and then we simply send the whole balance of the contract to the winner so whatever the owner decided to send as a reward when they called for example pre treasure and then we have a test where we check that everything goes well now unfortunately there are a couple of flaws with this contract pause the video and try to see if you can figure them out already to help you remember that flaws in smart contracts can typically have two types of consequences either someone can steal some value from the contract and other users or some value can get stuck in the contract pause the video and try to see if this helps you find the bugs in cashing contract so the first flaw is that you can have funds stuck in the contract and this is due with the way that the award prize entry point has been implemented how could this piece of code make it so that the funds are stuck in the contract what could possibly go wrong and think about it from the point of view of the winner how could your funds get stuck after you won the game pause the video and think about it for a minute well the issue is is that here for the winner to get their prize we need the owner to call the entry point but you could imagine that the owner doesn't call the entry point for a number of reasons for example they could simply forget to call that entry point or they may be unable to call it for example what if they lost their private key and they could also do that on purpose they could say okay I'll give you your prize but you have to do this for me and they could try to extort money from the winner before they give them their price here they would be able to weird but that could be one of the reasons why the owner doesn't call the entry point that Awards money to the winner and you could say well that's the organizer of the price I mean yes if the organizer of a game um is not available anymore and decides not to play well yeah it's okay to imagine and in this kind of situation the winner wouldn't get their prize but the whole point of a blockchain the whole point of using smart contracts is to avoid having to trust that some specific person will do what they are supposed to do we don't want to have to trust a third party and here we don't want to have to trust that the organizer will do what they're supposed to do so the question for you is how can we solve this how can we make sure that we don't have to trust the owner pause the video and think about it for a minute the solution is simply to let the winner or actually anyone call the entry point themselves there's really no need for it to be the owner we simply verify that the deadline has passed and then if it has and somebody calls that entry point then we send the funds to the winner so the best practice in your smart contract is to avoid unnecessarily requiring that a specific third party performs an action if there's really no need for that to be the owner of the contract or someone else then just don't verify it and let anyone call the entry point so here we can simply delete that line and everything still works just fine even if the owner forgets to call that entry point so that fixes the first flaw now the second flaw is that somebody can actually steal money that should go to someone and by that I mean somebody who didn't find a treasure could still become the winner so posi video and think about how you would do that how could you claim the prize without actually having found any real treasure so the second flaw is due to the fact that all transactions are public so as soon soon as you send a transaction to a node you can assume that everyone can see it it will be known by whoever owns that node then this node will send the transaction to all its neighbors and then to other the neighbors Etc so all the nodes will receive the transactions before it's even considered for being added in the block and if you send the password and the ID in your transaction then everybody sees your password so anyone can create their own transaction with the same password and pretend that they found that treasure and to make sure that they get the point and not you they can add a fee for their transaction that is a bit higher than yours so that the baker is more likely to take their transactions first before they take yours and they will get the point and you won't this kind of attack is what we call bpev flaws block producer extractable values and sometimes also calls me maximum extractable value so the idea is you can have Bots that always analyze all the transactions that travel through the peer top Network and they analyze those transactions to see if there's any valuable information in in there and especially they simulate what would happen if they perform this transaction from their own address and if the outcome of that transaction benefits them if they see that after the transaction is over their balance has been increased then will emit the transaction but with a higher fee than the original one so there's whole bunch of bots on all blockchains that look for this kind of transactions and then copy them and send them again but with their own address and a slightly higher fee and so since you have many different Bots that do that eventually the fee goes up and up and up right up to the Limit where it's not profitable anymore to keep increasing the fee so in the end it's likely to be the baker who will make the most profit because they benefit from that higher fee so that's why we call it block producer extractable value because whoever creates the block gets all the benefits of these increased fees and the baker the block producer can even make sure that they are the ones whose transaction is taken because they get to pick which transaction are added to the next block so they could just decide okay I'm going to get the treasure I'm going to be the one creating a copy of this transaction and getting the benefits so one way or another the block producer is able to take advantage of this flaw so here someone who didn't find the treasure could just look for the password in one of transactions and then claim to have fun the Treasure by sending the same password but with a higher fee so the question is how can you protect your contract so that this kind of attack wouldn't work pause the video and think about it for a couple of minutes so to protect against block pess or extractable values there are a number of approaches and none of them is ideal but we can try to find one that would work well for this construct a good way to think about this is to try to imagine that you're in a real room with a number of people and there's a transparent box in that room and your goal is to go around and find treasures and when you find them you need to put a piece of paper in the transparent box and and so you can write the password on a piece of paper and you add the ID of the treasure and your name so that you can claim to be the first one who found that treasure and of course you destroy the password so that another person cannot claim it and then there are will be 10 minutes until the game master opens the box then this game master will look at all the messages and check the passwords and count who found the most Treasures so if you imagine this situation how would you make sure that other people don't copy your password that they can see through the transparent box so that they can lie and claim that they found that treasure and if you can think of a way to do that in this room with this transparent box think about a way that you could apply this idea to a Smart contract pause the video and think about it for a minute so the solution would be that as you write the treasure idea the password and your name to a piece of paper to prevent other people from copying it you would just simply fold the piece of paper this way the game master would have to unfold each piece of paper before counting who found the most treasures and you would make sure that once the game master starts unfolding the pieces of paper making them visible for everyone you wouldn't let anyone else at their own piece of paper to the box so this way as the pieces of paper are folded nobody can read them until it's too late to add a piece of paper in the box now how could you do something similar in your smart contract on the blockchain pause the video and think about it for a minute so one way we could do this would be to encrypt that information so instead of sending the treasure ID password and your address as a clear message in a transaction you would first encrypt it of course the contract wouldn't be able to know the decryption key because anything that the contract knows is public so you cannot have a key in the contract that they would use to decrypt that information so instead you wait until the deadline is passed and then you send the description key so that the smart contract can extract the value from your encrypted message so this way you have to know all the information so that you can encrypt the message before the deadline and then after the deadline you reveal the message by sending the key that you use to encrypt it so that the smart contract can decrypt it and check if you did indeed find the treasure it's important to include your address in this encrypted message otherwise people could still copy a transaction and send the same message and later send the same decryption key so this approach would work but it's a bit costly because encryption functions are pretty costly so you don't want to run them in the smart contract can you think of another way to do that similar way but that may be a little bit less costly pause the video and think about it for a minute so a second approach to solve this but very similar is what we call the commet and reveal scheme and the idea is instead of encrypting the information we simply send a hash of the information and then in the second phase we send the actual information so we have two phases the first phase is the comet phase where each player can s the hush of their message containing the ID of the treasurer the password and their address and then we have a reveal phase where after the deadline each player can send the message itself then the contract compute the hash of the message compare it to the one that the user has sent before and if it is correct they canward the point to that user and Computing a hash is less costly than using any encryption algorithm but it's actually possible to make it even faster and to help you think that the best way to save gas is to do as much as you can offchain rather than onchain so if there's any competition you can avoid doing in the smart contract itself but instead do an offchain then you can save a lot of CPU therefore guys pause the video and think about it for a minute so the third approach is to still use this commit and reveal scheme so you still commit before the first deadline by sending a hash of the message with the ID the password and your address and then you steal reveal after the first deadline where every player sends the actual message but instead of immediately having the smart contract check if the hash corresponds to their produced message you let other players check themselves and if they see a message from a player that doesn't correspond to the hash that this player sent earlier then they can call an entry point to to say hey this player is trying to cheat they're sending a message that doesn't correspond to the hush to sent earlier and if the player indeed cheated then the smart contract can check verify yes indeed this message doesn't match the hash that they sent so I will eliminate them or maybe even punch them so this way we don't always check and compute the hash to verify that the hash of the message corresponds to the hash that the user previously sent we only do it if somebody complains so we have a second deadline and people have some time to complain before we award the prize in practice you can expect that nobody will try to cheat so the actual computation of the hush will never need to be done so let's take a look at the updated contract so here on top of the treasures and score per users we store for a big map with all the comments that people make once they find the treasure and we also keep a value of a deposit that every player will have to send to the contract as their register this way they can be punished if they do something bad and other people can be rewarded for denting anything bad that they did so we'll see that in a minute and then this time we will have three different deadlines the deadline for people to commit the hash of their message the deadline for revealing the actual message and the deadline for other players to dispute a message if they think somebody tried to cheat we add a register player entry point so that people can register before the deadline to commit and send their deposit and we use this as an opportunity to set their score to zero then we still have our create treasure and point for the owner to create treasures and they still store the hash of the password then once somebody finds a treasure they can send a hash of their message to this commit discover treasure entry point so they send the IDE of the treasure and the corresponding message and this is a hashed message so it will be of types sp. bytes we check that the owner themselves cannot uh play so we don't allow the owner to commit a message we check that this is before the deline to commit we check that we didn't already receive this message this is not really necessary I can remove that then we Mark that we received that comment then we have the entry point that people call once the comment deadline is passed and it's time to reveal their message and this time they send the actual password we check that I do that before the deadline to reveal we get the corresponding treasure we check that the treasure has not been found then we Mark the treasure as found we store the password for this treasure and we also store the player who found it then we increase the score of that user assuming that they are not lying that they actually did send a password that corresponds to their previous comment and we check did they get more points than the the current winner and if they did then we store them as the new current winner but now if somebody says hey this person claimed to have F found this treasure but that's not true that's not the case somebody else found it then we can call this dispute Discovery entry point we check that it's not too late to dispute it we obtain the corresponding treasure we check that indeed somebody claimed that they found it then we check did the password that Des send actually correspond to the password for that treasure so does it match the hash of the treasure we didn't even check that they sent the right password when we called reveal this discovered treasure we assume that the person can be trusted but here somebody disagrees so we check did they send the right password so we generate the message that they should send that includes the password and the address of the user so whoever claimed one we compute the hash and we check that indeed this person didn't commit a message corresponding to this hash so that means this whoever is disputing is correct because the hash of that message was not committed then we simply eliminate that player if that have not already been eliminated by someone else and then we send the deposit from that player to whoever calls this a dispute entry point if that player was the current winner then we reset the current winner to the owner we Mark treasure as not having been found so that if someone else has actually found it they can reveal that they found it so they can call the reveal discover treasure if it's still not too late and to make sure they have time to do so we add some time to the reveal deadline an hour and we also add one hour to the dispute deadline so one issue here is that we don't have the winner anymore and we cannot Loop through all the different scores to see who is the new winner now that we eliminated someone so we have to add an extra entry point update winner where we will check this is before the deadline to dispute anything and then we check that whoever is calling this actually has a higher score than whoever is marked as a current winner and then if they do then we update them as the new current winner so anyone can say hey I'm actually the winner look my score is better than Whoever has claimed to be the winner so far finally when the deadline for the dispute time is over then the current winner can claim their funds so the code here and especially the code of dispute discover is a bit more complicated but in practice since there is a way for anyone to tell if you cheit it and you will be punished if you cheit it this part of the code is very likely never to be executed so you won't pay for the cost of it but you need to make sure that there's no bug in there so as you can see preventing block producer extractable value can be a bit complicated make the code a bit more complicated but this is necessary to make sure nobody steals your funds it's actually still a way to cheat at least in some situations and this way is to prevent people from scoring P TR Treasures that they found but this can be costly so can you think about it for a minute and find a way that somebody could prevent you from getting the points for your treasure if they're really motivated to make sure you don't win pause the video and think about it for a minute so that approach that can be used in some situations is to actually attack the blockchain itself preventing some transactions from going through by sending so many transactions that the these users transaction may not be accepted and for that you have to keep in mind that Bakers typically select the most profitable transactions and most profitable means you add an extra fee on top of the minimum fee that you should send to pay for the gas so this means that if you send enough transactions with relatively High fees you could prevent legitimate transactions from being added to blocks so if you send many transactions with high fees you will feel the blocks until the deadline and none of the regular transactions will be added unless somebody notices and pays a higher fee this would be very costly but if there's just a little bit of time left for other players to submit their Treasures they find at the last minute then it could be worth it depending on what the reward would be so the different ways to avoid this kind of situation uh can be to give enough time between deadlines for this to be really expensive of course you could always prevent people from submitting their commit or reveal at the very last moment but then it's up to them if they don't do that so make sure you give people enough time so that nobody can block transactions during the whole window of time and another way to avoid this is for players to be a baker themselves so that they can make sure they give priority to their own Comet and reveal transactions and so this could be either if you're the owner of the contract and you want to make sure nobody can do that for your contract you can be a baker and then once in a while you make sure the transactions for your contract are accepted so that you can guarantee that your service is always reliable but of course anyone Els players themselves could make sure they are Bakers so that they can do that themselves so when the stakes are high it makes sense for big entities that uh rely on Smart contracts to be Bakers themselves so that they can make sure that their transactions go through in this module we will talk about Randomness picking random numbers in a smart contract is a very interesting but hard problem so let's say you want to organize a raffle where every participant can register and pay 100 Tes and after a deadline one of these participants is picked randomly and they get the whole balance of the contract as a prize so the questions for you are how would you structure this contract what would you store what would be the entry points Etc and most importantly how would you pick the winner among all these participants pause the video and think about it for a minute the structure of the contract itself is relatively easy in the storage you will store all the participants you need to use a big map to avoid any gas issues and the key will be an ID and the value will be the address of the participant for the idea we will simply use a counter and we will count the number of participants so a natural that we initially set at zero and every time a new participant registers we will increment this value then we set a deadline for everybody to register now we have two entry points one for participants to bid where we check that they do indeed send 100 test to the contract we check that they do that before the deadline we assign their address to their ID so the current number of participants and then we increment this value by one so we basically register that they participated in the raffle finally after the deadline they can claim their prize whoever is the winner will be able to claim their prize we check who the winner is by picking a random value between zero and the number of participants minus one and then we send the balance of the contract to the corresponding participant so that's for the structure now the hard question is there is no such random function available on tesos so without such a function how can you pick the winner pause the video and think about it for a couple of minutes in a regular program you run on your computer when you pick a random number it usually consists in calling a function that uses a mathematical function that produces a randomish sequence of numbers so we show here an example of such a basic version of a function where you take the current value you multiply it with a big prime number you add some value Etc and then to make it between zero and some value you take the module of that value and then to make sure that every time you run the program you don't get the same sequence you initialize with some randomish source of entropy and we typically will take the current time step because on the regular computer that can be in micros seconds so that changes all the time and it's hard to predict so the question is can you do that in a smart contract using sp. now for you seed and if you can or cannot try to think about why pause the video and think about it for a minute so using sp. now as a source of Randomness to initialize the seed of your function is a terrible idea first the value of sp. now is expressed in seconds so there's really nothing not much Precision it doesn't change too often and since you have blocks every 15 seconds there's really only a few values that are possible for a given block but more than that the baker of the previous block actually gets to pick the exact value so it's not random all all it's just some person on the computer I mean their computer picks it one way or another but the baker has control over that value so the idea is that in practice the value sp. now is not the actual time stamp of the current Block in the sense of when was this block created it's actually 15 seconds plus the actual creation time of the previous block and the idea is that in each block there's really two time stamps there's the time stamp that's the actual time where the block was created at least according to the Baker and then there is the value of sp. now that is 15 seconds plus the time stamp of the previous block so really the baker of the blog to pick what will be the value of sp. now in the next blog so in practice when you look at the actual value of sp. now it tends to be every 15 seconds so it makes it extremely predictable which makes it a really bad source of Randomness it can be predicted and it can be controlled by a baker okay so now that we get this idea out of the way can you think of any better ideas pause the video and think about it for a minute some ideas people tend to have have is to use hashes as sources of Randomness when you look at a hash it looks pretty random you just change one bit of the input and it changes everything in the output so it looks pretty random but be careful it may look random it's actually very predictable if you know the input of course the output will always be the same but more than that just like the time the baker can manipulate it because the hash of a block is really computed based on the content of the block based on what transactions they are and so if a Baker wres a block with a number of transactions then compute a hash and somehow that hash is not good for them it will not produce the right random number when you run the smart contract then they could just try a different set of transactions to obtain a different hash for their block so they do have some control on the value of the hash simply because it can make multiple attempts at traing a block and it will give different values for the hash therefore different random values for who is using this hash as a source of Randomness another reason why you shouldn't use the hash of a block as a source of Randomness is simply that you cannot access a has of a block from a smart contract so this is clearly not a possibility another idea would be to deploy a contract because when you deploy a contract from a smart contract you can obtain the hash of the operation that is created and this is something you can do from within the smart contract unfortunately the value of this hash depends on different things that the baker can control so the baker again can manipulate it in the same way as the hash of the block so we cannot use that as a source of Randomness finally an idea people sometimes have is to use the address of participants but if you do that for example if you add up all the addresses of the different participants to compute a random number then whoever is the last participant to consider bidding can predict the outcome of their choice they will see okay if I bid here's what the outcome will be by adding my address to the total number so they can decide if they want to bid or not depending on whether it makes them win so the address of participants again is predictable and so the results would be not only predictable but controllable by some participants so that wouldn't work either another idea people tend to have is to increase the Run as by mixing different values some ideas people have is to get the exchange rate between two currencies for example the current exchange rate between the Euro and the US dollar and you would say well if somebody could control that then they could be rich and obviously nobody can control precisely what the exchange rate will be on the Dex but then you cannot predict it within maybe a few tens of percents but of course you can predict the main value so you don't have too much Randomness that come out of that just just a few bits then you say okay I can combine that with other sorts of Randomness for example other pairs of currencies this is something you should be careful about when you try to combine different sources of Randomness you get more bits of Randomness for sure so you increase the range of different values you can pick from but the whole result is actually as weak as the weakest of these sources so if somebody can manipulate one of the exchange rates one way another then they can manipulate the outcome so it's actually dangerous from the point of view of making sure people cannot control the outcome to mix multiple sources of Randomness another issue is that the exchange rate of a decentralize exchange can be manipulated for example you could do a couple of transactions you could first buy or sell one of the two currencies of the Dex that may impact the exchange rate if you buy dollars it makes dollars a bit more expensive and then if right after that you call the contract that will compute the random number then your initial call will impact the results of your random number selection since everything is deterministic you can compute in advance what the impact of any peress of sale of currencies on that de will have as a result so you can just try different values and see which one generates the random value you're looking for so you can control it and know exactly in advance what the outcome will be so that doesn't make it a good source of Randomness either another idea people can have is to use a Randomness Oracle so rely on some offchain source to generate that random number but it's not as easy as it sounds if you use a basic oracles just some guy who's sending random numbers to a Smart contract and whoever that person is controls every single number and if they forget to send the number you are also stuck so this can be dangerous so you could use more advanced oracles such as chain link vrf verif fireable random functions this could work if it was available from tesos but you're basically moving the problem away the kind of problem that chain link has to solve is exactly what we trying to solve here and even in that case you should be very careful about trusting this kind of oracles sometimes there's possibility for collusions between different people that make it not as random as you would like finally as we discussed in oracles you can use a trusted execution environment Oracle like Acuras this may be the best solution based on oracles at the moment but again you need to make sure that the whole solution is safe and it's not always easy to have all the details about a given oracles to really be convinced that the randomness is really secure but this last option might be the best for an Oracle that produces random numbers at the moment on tesos but what we really want is to make sure nobody in particular controls the random value and that you don't need to trust some entity to keep producing those random values so we want to use a decentralized source of Randomness how can we do that it's actually possible so the idea is for multiple users and here it could be the participants in the ruffle to cooperate and produce a random number together and the hard part in that is to make sure that none of the participants can manipulate the outcome and make it be something they like so to try to think about a decentralized way to do that try to imagine that you are in a room in a physical room with 10 people and there 10 people you have no dice no coins Etc you just each have a pen and a piece of paper so the question is in that situation how would you generate a random number that none of you can control pause the video and think about it for a minute so one way that people could pick a winner among themselves would be if each of the 10 people could assign a direct number to each of them so one way to randomly pick a winner among those 10 people is to First assign a direct number to each of them from 0 to 9 then each of them would write a random number on their piece of paper and show it to everyone then each person could write a number on their piece of paper and show it to everyone then anyone can sum all these 10 numbers and obtain a big random number then you could take the last digit of this number of the sum which would be a value between 0 and 9 and that gives you the winner would this work try to think about issues with this approach pause the video and think about it for a minute so the issue is that someone could cheat and control the outcome if they wait for everyone to reveal their number and if they're fast at Computing they just quickly sum up all these numbers the nine other people to obtain the current total and then from that it can decide what number they should give so that when they add this number to the total it gives a result that makes them win so that's pretty easy to cheat how can we avoid this pause the video and think about it so the solution is to use something we presented earlier with the geocaching smart contract we want prevent users from changing their numbers once others start revealing theirs so in our physical room we could have each person write a random number on their piece of paper that do so discretly and then they immediately turn the paper over to hide the number from others or they just fold it in half and then when everybody's done writing the numbers we ask everyone to put their pencil down so that they cannot change their numbers anymore and once it's all done every participant can reveal their number show it to everyone and then everybody can sum up the value and pick the winner if we do that there's still a flaw in this process can you figure out what it is pause the video and think about it for a minute so the issue is that someone could decide not to reveal the number to help a teammate so let's say we have these 10 users numbered from 0 to 9 and they all already committed a random value from 0 to 9 that we have here but then two people Eve and Gwen have not revealed yet but let's say Eve and Gwen are actually friends and teamed up and they already waited for everyone to reveal and they know okay the current total is 33 now they get to decide okay if Gwen reveals her number but Gwen doesn't and we just add all the numbers that we revealed before the deadline then we add 33+ 4 so the total would be 37 that would make Iris win so in the last digit would be seven but if Eve reveals her number but Gwen doesn't then the total would be 35 and Gwen would win so by doing this just deciding who between Eve and Gwen reveals then they can decide the best strategy to increase their chance of winning so basically the two of them can generate three outcomes that gives them a chance at winning either are they both reveal so we get 2 + 4 or only Eve reveals so we get two or only Gwen reveals so we get four that we add to 33 and for each of these three possibilities it generates a different outcome a different winner so they can pick out of these three possibilities which one is the best for them and the question is how can we avoid this issue so the idea here is to force people to reveal to make sure that nobody is going to want to use this strategy the first approach is to use a financial incentive you ask each player to deposit some extra money on top of their bed at the beginning of the game and if they don't reveal they simply lose their deposit so they have a very strong incentive to reveal because otherwise they would just lose some money but then the question is how much would this deposit be and the issue is that for this to work as with just a few people that can control the outcome if you have 10 people in a team out of 100 people who bid 10 people can generate 1,023 different outcomes so they're very likely to have one strategy that makes one of them win so you pretty much want the deposit to be as large as the reward so if it's a big ruffle where you can win one million test nobody will want to deposit 1 million test but this could work for a small ruffle there's another approach that is using Brute Force then we will see in a moment if it's in the the physical room we have someone steal Gwen's paper and reveal it for everyone I would call that brute force and we can actually give people an incentive to that if Gwen doesn't reveal we can reward that person with Gwen's deposit so if we can do that when one dare to cheat so then the question is how can we do this on the blockchain we've already seen it in the geocaching smart contract if we use incentives but no BR Force we can use a set of phases and deadlines so we have a registration phase where participants bid and deposit T each participant is assigned a number then we have a comment phase where each user gets to pick a random value and they send a hash of that value to the contract we have the revealed phase where each user sends their chosen value this value must match their hash finally after the reveal phase ends and everybody revealed the winner can collect all the bits and then everybody who revealed gets their deposit back so your job is to write a smart contract that uses this approach to organize a raffle pause the video and give it a try let's take a look at the solution in this raffle contract we store the bid amount so how much people need to bid to take part in the raffle then we store how much they need to deposit for the financial incentive then we store two deadlines the deadline for them to commit the hash of their random number and then the deadline for them to reveal the random number they picked that corresponds to the hash in the big map we store all the information about the players we will store the address we will store the hash of the random number and we will store whether they're already revealed or not then we store the number of players and this will serve as a key for the player big map then we'll store how much has been deposited how much has been bid so that we can know what the total price will be and then we have a total that will be the sum of all the random values finally we need to keep track of how many people have revealed then the bid entry point this is the entry point that people call during the commit phase where they need to send the hash of the random value that they picked they need to send their bid and their deposit so we check that the amount is equal to the sum of both they need to do so before the deine to commit so we check that then we store all the information about the player address the hash of their value and they haven't revealed yet we can then increment the number of players and update the total amount of the deposits and the total amount of bids in the next phase the reveal phase each player has to reveal their actual random value since we use an ID as the key for players we ask people to send their ID instead of sending their address for and they can easily find it out of chain we check that they call this entry point before the end of the reveal phase we check that they have not revealed yet otherwise they would be able to reveal multiple times and then manipulate the outcome we check that the hash of the random value they sent is the same as the hash that they sent during the commit phase then we Mark that they now have revealed we update the total of the random numbers by adding their random value then we increment the number of people who revealed after the deadline to reveal the winner can claim their price so we check that they do so after the deadline then we determine who is the winner to do that we divide the total of the random values by the number of players and we take the remainder using sp. mod and this gives us the ID of the wi of the raffle we fetch their address we make sure they're revealed if they did reveal they cannot win so they cannot claim the price then we compute how much we need to send to them so we send them the price the total amount of bids plus their share of the deposits so the idea is that if somebody didn't reveal they don't get their deposit back and we share it among the other players so to send their share to the winner we divide the total amount deposited by the number of people who revealed using split tokens so they get a fraction of the total deposit one over the number of people who revealed we send them that amount and then we delete them from the players so that they cannot try to claim the prize again then we have an entry point to send their deposits back to players who did reveal but didn't win we don't need to check who is calling it it doesn't matter I mean most most likely they will be calling it but there's no need to check it they need again to send their ID we check that they try to get their deposit after the deadline we make sure they're revealed we get their address and then we need to compute the amount that needs to be shared between the players who revealed to do that we take the total amount of deposits but then we need to find out if to that total we need to add the price if there is no winner if the winner didn't reveal then we need to share the prize between all the players who did reveal so we compute again similarly as here the ID of the winner we check if they are still a player if not that means they already claimed their price so we don't need to worry about uh sharing the price and if they didn't reveal then we add the total price the total of bids to the amount to share then we divided the amount by the number of people who View field we send it to the user and we delete that user from the players to make sure they cannot claim again then we have a test where we have a few people play commit their hash of their numbers then reveal them and some don't reveal and then the winner can climb their price Etc it's a small test in a real test you need to do a lot more than this to check all the different possibilities we can give it a try and we see that everything works all good now the issue with this approach of using Financial incentives to force people to reveal is that the amount they need to deposit should be similar to the total amount that they may win but in a ruffle if you imagine a big ruffle where there's thousand players and a million T to win very few people would have the means to put a million Tes as a deposit and if they did probably wouldn't want to risk it just for a small raffle where they have a small chance of winning so Financial intensive work if it's a small raffle if it's a deposit can be small enough but in some cases the deposit itself makes it unlikely that people will take part so we need a better solution and for that we will use cryptography so the solution is to force people to reveal or at least make sure that their number is re reveal by using cryptography and A cryptographic Primitive called time lock in a sense it's using Brute Force to reveal number for them for people who didn't reveal themselves and time lock is a cryptographic primitive that we will use instead of a hash so instead of hashing and sending the hash of the number we picked we send a time lock of that value and the time lock has the properties that it's like an encryption mechanism but where if you are given enough time anyone can actually decrypt it but it has the property that if you only have a certain number of minute let's say x minutes we could say 10 minutes then nobody will be able to crack it and and decrypt it without the private key even if you have the most powerful computer in the world even if you have a specialized ASC so A specialized Hardware dedicated to decrypting time locks or even you have fpga that you program to decrypt time locks really fast you still won't have time to decrypt it in this number of minutes on the other hand if you have enough time let's say 100 times that amount then anyone can decrypt it even with a regular computer without the private key and so the idea is that the encryption algorithm takes a number of iterations on a single processor you cannot paraliz the computation so you cannot use hundreds of computers in the data center you have to use a single processor and so given enough time whatever computer you have you will be able to decrypt it so this duration of how long it takes at the minimum with the fastest possible computer you may find has to be more than the amount of time people have in the commit phase so that between the time the first person commits their number and the time that the last person can commit theirs this amount of time should be shorter than the smallest amount that anyone with a fastest computer will need to cck the time lock cck the chest and find out what your number was then has to be still small enough that during the reveal phase if somebody didn't reveal somebody with a regular computer can correct the value in a reasonable amount of time let's say 10 hours and reveal for that person and the idea is that if somebody doesn't reveal then someone else can reveal for them and be rewarded so there's really no point for someone to not reveal because they will lose their deposit and someone will reveal their number for them anyway and be rewarded for doing that computation so you gain no benefit in not revealing your number so with this approach we can have a commit and reveal system where we make sure that everybody's value is revealed and we find the right in this module we will talk about reentrancy flaws it's a type type of flaw that is particularly hard to detect but easy to prevent reentrancy bugs happen when the contract calls another contract and then that other contract calls the original contract again in such a way that it breaks the assumptions you make in this original contract there was a very famous reentrancy attack that caused the da hack on ethereum in June 2016 and that attack was so serious that it eventually led to the fork of ethereum into the current ethereum and ethereum classic as the community split between deciding to rewrite history to avoid the attack or simply accept it with ethereum Classic on tesos the languages are designed in such a way that reentrancy bugs are less likely but we will see that rency bugs are still possible on tesos we will also see a way that we can prevent them we'll take an example where we have two contracts that manage unique tokens identified by the ideas the first contract is a ledger contract that simply keeps track of who owns each token so it has an admin contract that can collect and make changes and it simply stores a big map of tokens with the token ID as a key and the address of the owner as a value then we have an unchain view to obtain in the current owner for a given token idea and then an entry point to change the owner of a given token idea to a new owner and only the admin contract is able to change this owner then we have a purchaser contract that is the admin of The Ledger contract and this purchaser contract is simply in charge of purchasing tokens are predefined prices so we store the address of The Ledger contract and in a big map a list of prices so for each token idea we store the corresponding price and that's the price at which the purchaser is willing to buy a given token then the owner of a token is allowed to call the apply offer entry point for a given token idea say okay I'm willing to sell you that token at the price you listed so we check that the caller is indeed the owner of the token by calling this view get token owner of The Ledger then the contract sends the corresponding price to the caller and one thing to keep in mind is that the transfer of test is not immediate but we create a transfer that will be executed after this entry point is over then we call the change owner entry point of The Ledger to say okay I'm the new owner so the purchaser contract becomes the new owner of token ID and again we add this to the list of operations to execute after the end of this entry point with that in mind can you figure out how this contract could be attacked and by attacked we mean how could funds or assets be stolen from this contract or get stuck in this contract pause the video and think about it for a minute so the key idea of the attack is to call this apply offer entry point twice and get paid twice before the ownership change actually happens so while apply offer is taking place and all its consequence is taking place but before the actual change to the owner is made we call apply offer a second time note that on a blockchain you cannot run two transactions in parallel if a user simply creates two transactions to call apply offer twice the first goal will be completely over before the second one can be executed we don't have concurrent execution of different transactions so you never need to worry about that but it's still possible to have a call to apply offer before the owner is changed can you figure out how this can be done pause the video and think about it for a minute so let's look at the code of an attacker contract so we will assume that the contract below is the owner of the token with ID 42 and we also assume that the purchaser contract list this token for a price of 100 T so it's ready to purchase it for 100 T and then we will call attack attack of the purchaser with token idea 42 in the storage we will store a number of calls and the token idea for the token that we are trying to attack during the attack we set the number of calls to two we'll talk about why in a minute and we store the token idea and then all we do is accept the offer by calling purchaser do apply offer saying yes I'm willing to sell you my token 42 for the price listed which is 100 T so far nothing special you simply have a contract that accepts the offer from the purchaser contract but the trick is to also have a default entry point in this attacker contract and to have this default entry point also call apply offers and the idea is that we accept the offer a second time before before the ownership of our token is transferred to the purchaser and to avoid doing that indifferently since when we accept the offer a second time the purchase contract will again send us 100 Tes and call the default entry point again and So to avoid an infinite recursion we have this NB call variable in the storage that we set initially at two and every time the default entry point is called we decrement it by one and when it reaches zero we stop calling apply offer so in practice we only call it twice we call it here the first time and then the first time we receive 100 T then we'll call it again but the second time we receive 100 T we don't call it anymore so this contract uses reentrancy to steal 100 test from the purchaser contract again the idea is that when the attacker calls apply offer for the token ID 42 so the attacker is indeed the owner of token 42 we send TZ to this attacker but you have to keep in mind that we don't directly transfer TZ we add a transaction to the list of transactions that will be executed after we execute apply offer then we add another transaction to this list which is to call The Ledger to change the owner of that token to ourself to the purchaser contract those two transactions are added to a stack of transactions to execute after the apply offer and point is completed so once it's completed we take the top of the stack which is this transaction we transfer 100 test to the caller but we also call the default entry point of the attacker which then create another call that will be added at the top of the stack and that calls apply offer a second time and when apply offer is called a second time we check that the owner is the caller and it's still the case because we haven't changed the ownership yet then we will add two transactions to the stack at the top of the stack we will add a transaction to transfer 100 test to the attacker again and then right below it another call to change the ownership of the token to the attacker then we execute the transaction at the top of the stack which is to transfer 100 test to the caller call the default entry point but this time NB calls gets to zero so nothing happens and then finally we have have this call to change the ownership of the token to the purchaser that was added to the top of the stack by the second apply offer call and then finally we have the same one but this one that was created by the first call to apply offer so let's look at the succession of steps that happen in detail we first have the call to our attacker contract to say okay let's attack this purchaser contract and try to steal funds through through the token we owned so token ID 42 this creates a call to the apply token entry point of the purchaser saying yeah I accept the offer to sell token ID 42 to you then this applyer offer entry point is executed at first time it checks that the call is the owner it creates a transfer of handes to the attacker and a call to the change owner entry point of The Ledger then for the first call the default entry point is executed decrements the NB calls from 2 to one creates a call to purchaser apply offer of 122 and while it does that hand has a transfer from the purchaser contract to the attacker contract then the second call to apply offer is executed it checks that the caller is still the owner so the attack contract and creates a second transfer of 100 test to the attacker then a second call to change owner so this one against is executed first which calls the default entry point that thec end to zero so nothing else happens but 100 Tes are transferred from the purchaser to the attacker again and finally we execute the change owner call that was created here in the second call to apply offer so we set the ownership of the token to purchaser and then we have finally the initial call to change owner that is executed that sets the ownership to the token again to purchase her a second time in the end the attacker contract received 200 Tes from a token that was priced at 100 T so it stole 100 T from the purchaser contract if we had initially set n be calls to 10 it would have stolen 900 T from the purchaser contract by accepting the offer 10 times before before transferring the ownership of the token to the purchaser contract so the question is how can we avoid this type of flaw so you have to keep in mind that what makes this flaw possible and hard to detect is that a new call to the purchase contract can be initiated in the middle of the execution of its different steps and Our intention in the purchas contract was to Simply send usest to the seller and then take ownership of the token but what really happened is that we sent test to the seller but then the seller did all kinds of things including trying to sell its token a second time and only after that did we take ownership of the token so with that in mind how can we avoid this type of flaw pause the video and think about it for a minute so the first approach is to Simply order the steps of your contract in a safe way and the idea is to start with the steps that will prevent future similar calls so in our example we could have avoided the flaw by swapping these two instructions so the instruction to send the 100 test to the caller and instruction to change the ownership to the purchase contract if we simply changeed the ownership first and then transferred hand test to the caller then during that transfer any call to accept the offer again would have been rejected because the attacker contract wouldn't be the owner anymore so this approach can work if you're really careful you make all the changes that will prevent future calls first and then the consequences and in particular transfers of TZ afterwards it's possible to avoid them but as contracts become more complex it can become really hard to be 100% sure that you cover all cases and that no reentrance attack can happen so there's a second approach that is a bit more radical and that simply prevent any reentrancy at all and therefore any reentrancy attack the idea is to use a Boolean flag for example we can call it is running that we put in the storage of the contract and that will be said to True while the contractor is being used so that it cannot be called a second time and so the entry point will have this structure we first check that is running is false then we set is running to true then we do all the logic including creating calls to other contracts transfer of test Etc and then we call an entry point that set is running to false it's important to do it through a call to an entry point that simply set is running to fals because all of these calls created here all this transfers will happen after the end of the execution of our entry point so we cannot just simply set it to false again we have to call an entry point that will set it to false after all the consequences of this section will be done if we look at the fixed contract it will look like that in apply offer we first check that is running in false then we set it to true then we check that the caller is the owner of the token that we are trying to purchase then we change the ownership of the token to ourselves so the purchase or contract then then we transfer her test to the color and then finally we call stop running that will check that the color itself so that no one else can change the value of is running and then we set is running to false so this way apply offer can't be called during the transfer of test to the attacker and the attack would fail here we can look at a more complete version of this attack and test it we have this Ledger that's stes tokens and has anmin we can Min tokens then check the ownership of a current token or change the owner or token then we have our purchaser contract that has a list of offers here we have a system of escrow so you put funds in a processor contract in case somebody wants to sell the token to you the buyer has the funds available in an escroll big map in the purchase contract then when someone accepts an offer we send the price to the current owner of the token and then we call change owner to change the ownership and we can see here the attacker contract that does exactly what we said we initialize and calls at zero we call the accept offer entry point of the purchaser contract and in the default entry point we decrement and be calls and if it's greater than zero then we call accept offer again and if we run a test that has an attack for token ID one then we can look at the details and see that we get 100es transferred twice once here and once here so the attack worked in this module we will look at an auction contract that has multiple flaws and your goal will be to find the flaws in this contract let's take a look at this auction contract in the storage we will store a map of tokens each token will store the metadata of the nft and the current owner and the key will be a token ID that will start at one and that we increment every time someone meets a new nft then we have a map with all the options where the key is the IDE of the token that is put for auction people can mint nfts using the mint entry point that pass the data of the NFD they want to Mint we check that they pay a fee of one TZ to Mint that will be used to fund the website and the advertisement everything to bring users to this project and then we simply add an entry to the tokens map that will contain the metadata and the initial owner of the nft then we increment the token ID once somebody wants to open that auction for a given token they provide the token ID and a deadline for the auction that means people will have anth this deadline to bid and the highest bidder will become the new owner of that token so in this entry point we store that the caller is the seller we store the deadline we store the current top bid and here instead of using an option to set that there isal top bid we simply set it at zero and we say that the top bidder is the cender so whoever is putting the item on auction bids zero but then anyone can bid so that if nobody bids anything then they can get the ownership of the token back then once somebody bids for this token they indicate what token ID they bid for we get the data of the corresponding option we check that they're bidding more than the current top bid for this nft and we check that they bid before for the deadline so since they bid more than the current top bidder we send the amount that the previous top bidder have bid back to them and then we set the new top bid to be the amount sent by this sender and then they become the new top bidder and we save it back into the map finally after the deline the seller can claim the top bid and get the funds while transferring the ownership of the token to the top bid so we fetch the auction object we check that this is after the deadline we check that the caller is the seller of the token we send them the value of the top bid and we change the owner of the nft to the top bidder now your job is to find all the bugs from this contract and there are at least seven bugs in this small contract pause the video and give it a try so for the first bug I will give you a hint remember that if the storage of a smart contract gets too big the time it takes to derealize all of the data in the storage before any contract call and then res serialize it after the end of the entry point May exceed the amount of gas that you can spend in a transaction so it's always important to think about how large the storage can be and make sure there is no risk of exceeding that maximum amount of gas to spend in a transaction so with that in mind can you figure out what the issue is pause the video and think about it for a minute so the issue here is that we used maps to store the nfts themselves and to store the information about the auctions but maps are stored directly in the storage which means the serializing them takes an amount of gas that is proportional to the number of entries so as people mint more and more tokens and put them into more and more auctions the size of the storage that you need to distalize will get bigger and the gas could exceed the maximum amount you can spend in the transaction so this is bug number one and to fix it all we need to do is change these into big Maps like this and this as big map are serialized and deserialized On Demand there always the data structure you need to use for any data I can keep growing indefinitely a second bug is in the open auction entry point there's actually two bugs in this entry point because we don't need nearly enough verifications so pause the video and focus on that entry point for a minute the first bug in this entry point is that we never check that the sender who is trying to sell this token in an auction is actually the owner of the corresponding entry point and we don't even check that this token exists so we need to start by checking is the color the actual owner of this so we can write assert of. data so we check that the owner of this token is the cender so they're allowed to sell it this automatically checks that this token exists otherwise this would fail anyway so we don't have to add an extra verification to check that this token ID exists for the next issue you can use a method that I always recommend to apply when proofreading a smart contract which is to think about what would happen if somebody calls a given entry point twice with the same information so let's imagine that we call open aution a first time with a given token ID for example 20 and the deadline so we first check that the caller is the owner of the token 20 and then we create a record and save it in the big map for the key token it here then if we call open auction again with the same parameters we will again check that the sender is the owner but then we will overwrite the previous auction with a new record so in this case it's fine we just redo the same thing but if in the mid time somebody has bid for this auction then we lose all the information about the top bidder and the top Bid And so basically any funds that any bidder has sent to the contract would be lost because they're not recorded as the top bidder anymore and they won't be reimbursed if someone else bids Etc so here we have a clear bug that the owner of a token can basically cancel everything that has happened with an auction by creating in a new auction so to fix this we need to verify that there is no auction going on for this token so we assert that self data auctions does not contain the token ID the next bug that is reasonably easy to find is on the claim top bit entry point so focus on this and try to use the techniques that we presented thinking about what happens if we call an entry point twice but also what happens if we don't call an entry point if the person supposed to call it doesn't call it pause the video and think about it for a minute so here the issue is if somebody doesn't call the entry point we can see that here we expect the seller so the owner of the token to call claim tub bid but the seller may not call it for a number of reasons it could be because they're not available because they forgot or it could be for nefarious reasons for example they could say well I'm not happy with the auction I feel I want to get more than the current top bid so since I have their money stuck in the contract anyway I will try to pressure them to to give me more money if they don't well too bad their money is stuck they don't get the nft and that's their problem I don't lose anything so somebody could pressure the top bidder to try to distort a bit more money for example and it's always the case when somebody needs to do something we have to trust that they will do it and if we depend on them to do it then they have some leverage over us so it's not good to require that the seller call this entry point the whole point of a blockchain is that we don't want to have to trust someone to do something so here we could say well maybe the top bidder themselves could also run this entry point and so if the seller doesn't do it then the top bidder will do it so we can add here or SP sp. sender equals top bidder but we actually don't really care who calls this entry point so we can simply delete this line and as long as somebody calls it then everything is good the next bug is actually a bug that we now have in in two places we have it both in this entry point and in this entry point the version in this entry point is the most dangerous one because somebody could really steal all of the tokens that are P for sale through this auction contract so try to focus on this entry point and think about a way that somebody could steal all of the tokens are put for auction pause the video and think about it for a minute so here I may give you another hint when you send funds to an address if it's a regular cheesy address of a basic account you simply send the TZ to that user address but if the address is that of a smart contract then what happens is that this calls the default entry point of the contract while sending the test to that smart contract if the smart contract doesn't have a default entry point the transaction fail if it has a default entry point but the default entry point fails then the transaction fails so for a contract to be able to receive direct transfers using sp. send and without explicitly calling a smart contract it needs to have a default entry point like this that for example doesn't do anything so when you try to turn transfer some test to this contract with sp. send it will call default it shouldn't have any parameters otherwise it's not the right entry point and it will fail and it shouldn't fail so here we put pass so it doesn't do anything and doesn't fail but if the destination of this transaction either doesn't have a default entry point or has a default entry point that maybe checks for Boolean something like that and maybe has another entry point point that allows them to change the value of accept test then they would be able to control at any time if they allowed transfers of test to them or not so here if the top bidder is the address of a contract with this kind of default entry point that has a Boolean to accept or reject transfers of Tes they could bid for the nft with a very small amount as soon as the nftd is put for auction then they could set this to false to to reject any future transfers of test if somebody else bits a higher amount for the same token idea we will check yes they bit more yes it before the deadline but then when we try to reimburse the previous St bidder that previous St bidder would reject the transfer and therefore this new bid would fail and then this initial bidder who's trying to steal the token just has to wait until the deadline and then claim the top bit and get the nft so with this we have a system for anyone to bid a very small amount and then prevent anyone from bidding above them until finally they get the item so it's really important to be very careful every time you have an entry point that calls sp. send especially if you're not sending Tes to the colar of the entry point itself we have the same issue here here we sending Tes to the seller but the seller could be the address of a smart contract that has a default entry point that may or may not accept TZ and they could use that as a way to prevent anyone from calling the claim to bid entry point and finalizing the transaction so we have the same issue here and here and this issue is an issue we can have quite often in smart contract you should be really careful anytime you call sp. S now what do you think the solution would be to fix this issue pause the video and think about it for a minute so one solution people often think about is to prevent contracts from bidding or prevent contracts from trying to sell Etc so if we know that this is not the address of a smart contract then we know that it's impossible to block the transfer but preventing smart contracts from using your smart contract is really cutting yourself from a lot of potential use cases for example no entity that is using a multiseed contract to collectively take decisions on how to use their assets would not be able to use your contract there's many occasions where we don't want to directly interact with a contract with a TZ address but instead through a smart contract so I really don't recommend testing if the caller is a smart contract or a regular user account an implicit account instead what we want is to let the top beider here and let the seller here get their friends back themselves through a separate entry point but for that we need to use a ledger that keeps track of how much the contract owes to each user so here we will add a big map Ledger where the key will be the user and the value will be the amount that the contract owes to them so here instead of sending test we check if there's already an entry for that user so if it doesn't exist we create the entry with zero T and then we add the amount that we wanted to send them like this and we also need to add a claim entry point where we send to the color the amount that is in The Ledger for them and then we delete the entry and here in claim to bid we can do the same thing I'll just copy this but here it's going to be action auction seller and that's it so that's fixing the next bud so it's really it's a good habit to to have a ledger in your smart contract so that instead of directly sending test to different addresses you just keep it in The Ledger and you let people withdraw the funds through a claim entry point the next bug is in claim Tob bid and again think about what happens if you call the same entry point twice pause the video and think about it for a minute if we call claim Tob Bild the first time let's say for 2 id20 we check that the deadline to be is passed we send the amount of the top bed to the seller Through The Ledger and then we change the ownership of the token to the top bidder now if we do it again we call claim top bid a second time with the same parameter 20 then we do everything again we check it still past the deadline but then we transfer the amount of the top bit again to the seller the seller didn't change then we assign the ownership of the nft again to the top bid so this doesn't change anything but here we add the top bid a second time to the seller so the seller could keep calling this entry point many times and get the amount from the top bit again until the balance of the contract is lower than the top bit by doing that basically the seller would steal funds from top biders of other auctions that are currently ongoing to avoid this we can delete the entry so that the entry point cannot be called again and maybe another auction can be set later the last bug that I know of is related to The Mint entry point and to the fact that we charge one test for someone to Mint and through this contract pause the video and think about what the issue could be with that here are the issues that we have accumulated TZ in the balance of the contract but the owner of the smart contract whoever is managing the website that goes with the smart contract has absolutely no way to get this money so they may look at the contract see yes many people are minting nfts and accumulating money Etc until one day when they say Okay I want to use this money for something else to pay for some developer some marketing Etc then they realize that they have absolutely no way to get the Tes out of the contract this may sound silly but this kind of issues forgetting to create an entry point to get the money out of the contract is something that has happened to multiple companies with their smart contract so when you test your smart contract make sure you test the whole life cycle of the contract including the time where you want to get the money out so here there's an very easy way to fix that which is to Simply add these T to The Ledger but for that we need to specify who the owner of the smart contract is so we have to specify an owner and store it as there is no default owner of a smart contract just because you deploy the smart contract doesn't make you the owner so we have to store it in the storage there is really no default notion of owner that we can access to so here as soon as we get the one so here we can use this piece of code again and we add one test to the The Ledger you may notice that I have copied the same piece of code multiple times and there is a way to put it in the function but we will see it later in the module about Lambda so for now we simply copy this piece of code in each of the smart contract that uses it and that's it to recap we found seven flaws in our simple auction smart contracts we forgot to check that the seller of an nft was actually the owner of that nft there was a way for a bidder to bid a very small amount and then prevent anyone else from out bitting them and therefore making sure they could win the auction with a very small price and therefore stealing all the tokens we noticed that the seller could never call claim top bid and maybe use this as a way to extort money from the top bidder so if we fix that we also notice that the seller or anyone could call claim top bid multiple times and steal t from other auctions and we noticed that the admin the owner of the contract could never claim their earnings so we added a way for them to do that through the Ledger we also noticed that the usage cost of the contract was increasing little by little as people created new tokens Etc in the map in the storage until the contract would be completely stuck once the amount exceeded the total amount of gas we can spend in a transaction and we simply fix that by using big maps and finally we noticed that it was possible for a seller to delete an auction and everything that was already bid by overwriting the auction with a new one so you can see that in a very small smart contract it's quite easy to have many different bugs and so it's very important not only to test very carefully have people other than developer proof fre the contract and also go through checklists and making sure you don't have any of the typical bugs we just presented on open.com we have a page about all the typical flaws we can have in smart contracts and you can use that page as a checklist when you review your own contract in this video we will talk about the type of contract used in decentralized finance called flash loan and we will see that with a flash loan you can become temporarily very rich so we'll start with an exercise in a previous module about sets we presented a membership contract that only rich people could join and the way we did that was that the join entry point that people had to call in order to join this club required you to transfer a large amount of TZ to the contract that the contract will then reimburse you so in order to join the club you needed to have access to a large amount of money so the question for this exercise is let's say you don't have access to a large amount of funds is there a way you could still join this club pause the video and take a minute to think about how you could create a smart contract that would make this possible so the solution is that you have to borrow some Tes and so the idea is to create a contract that can lend TZ to users and of course users would have to pay back later with some interest so the question is how can you have a contract that lends you money but then makes sure that the user will pay back pause the video and think about it for a minute so the usual way that even Banks use to reduce the risk when they lend you money is that you have to have some kind of collateral it could be a house it could be anything on the blockchain is typically money but in a different currency so let's say you want to borrow some amount of T let's call it X from a contract we could deposit some amount of token a so a different cryptocurrency that is worth more than x Tes for example it could be 130% of X then in exchange we receive this amount X of Tes then for some amount of time we can use those T but at some point in the future we pay back that amount plus the interest once we do that we can get our deposit back in the token a so the amount we deposited in the token a was never used was never invested or anything it was just kept by the contract so that we could get it back once we returned the amount of Tes one thing to keep in mind when you do that is that the value of token a may change over time it's a different cryptocurrency so the exchange rate between a and the T could vary over time so if the value of your deposit in the form of tokens a becomes so low that it's starting to get close or even lower than the amount that you got the contract can liquidate the loan to make sure it doesn't lose money for example let's say the value of token a gets close to 110% only of xegs then it will use an exchange to exchange your deposit for some T so that's what we call liquidating the loan so this is the way the contract makes sure and no matter what it will get the test back plus some interest either you pay it back or if you don't pay it back or if your deposit is starting to lose value then it will get back the money by liquidating your deposit so this is a type of loan but not the one that would work for us because in our membership contract the whole point was that we want to join but we are not rich we don't have any funds whether it's in form of Tes or another token so we cannot pay in any way and we cannot provide a collateral basically this kind of loan doesn't work if we just poor so if a user doesn't have any funds how could someone lend to them without taking a risk so I can give you a hint in our situation we only need the money very briefly so how could we do that pause the video and think about it for a minute so the idea is to do everything in a single transaction in the same transaction we could borrow money from a contract then use that money to join the membership contract and then immediately get it back then we could pay the money back to the contract plus some very small interest if all this is in the same transaction then if we fail to pay the money back then everything will be cancelled right because when it's a single transaction a single contract call if one of the part fails then everything fails and is cancelled so basically the contract never lends you money if you don't actually pay it back so there is no risk for the lending contract so this type of contract where you borrow some funds without any collateral use it immediately and then pay back plus some interest that's what we call a flash loan contract so in a Flash loan the key idea is that funds have to be borrowed bored and repaid within the same transaction so you borrow some amount from The Flash loan contract you use it for any kind of financial operation that generates a profit or at least where you don't lose any money then you repay the funds plus the interest to the flash loan contract and you can keep any profit you made so in the case of our membership contract your profit is simply that you manage to become a member of this membership contract so there's really no risk if anything goes wrong the transaction fails entirely so it's as if nothing has happened which means anybody can be temporarily as rich as needed in particular to profit from an opportunity okay so let's work on the implementation of such a contract think about how you would Implement a simple flash loan contract you have to have an owner who will deposit t on the contract and eventually claim them back when he needs to to those Tes will be used to lend Tes to other people then anyone can borrow these Tes with no limits other than the total balance of the contract so the amount deposited by the owner and then the lender needs to repay the loan with interest in the same transaction so again there is no risk if the lender can't repay the loan the entire transaction is cancelled let's look at the structure of such a smart contract in the storage we would need to have the owner so the person who puts the funds in the smart contract to lend to other people we provide the interest rate so what percentage of the funds you borrow you have to pay on top of reimbursing the loan itself we only need to make one loan at a time since we're going to pay it back right away so there's only one Loan in the flash loan contract so we can store the amount that is being loaned we need to keep track of whether there is actually a loan in progress we'll see why a little bit later we need to know who who borrowed this amount and then we'll need to know if the amount has been repaid then we have five entry points we have a deposit entry point where the owner will deposit the initial funds and a claim entry point where the owner will claim their bance back at the End plus their interest and people can call the borrow entry point and specify how much they want to borrow and they willing to provide a call back that says what is the next step right after a the money this entry point will transfer the amount to the sender and then we'll call this call back and within this call back the funds will be used profit may be made and then the call back will repay the loan so after we call the call back we need to call a function that will check if the loan has indeed been repaid while the call back is running at some point it has to call repay and send the funds back to the flash loan contract then finally check repail will be called and we will check that the loan was repaid otherwise we fail and everything is cancelled so the idea is that the contract that borrows the money will call borrow and pass its profit entry point as a call back so let's say we want to borrow 10,000 TZ and as soon as we have those funds The Profit entry point should be called so we call borrow borrow transfers 10,000 Tes to the sender then it calls this function call back then it calls check repaid to make sure that indeed call back has repaid the loan the next step is that profit is being called so the tests that have been transferred to it can be used to buy something for example then we can sell it for more somewhere else that's one way to make a profit and finally we need to call Flash loan. repay with the amount borrowed plus some interest so when we call repay the repay entry point of course checks that the amount sent is the amount of the loan plus the interest and it sets the repaid flag to True finally the check repaid entry point is called and here we check that repaid is true otherwise we fail so we make sure that indeed the amount sent was repaid So based on this try to implement this fles loan contract and call it from the borrower contract and note that you will need a total of three contracts The Flash loan contract the membership contract and the attacker contract the contract that will borrow the funds so that it can be then become a member of the membership contract we'll pause the video and Implement those contracts let's take a look at the solution so here is our flash loan contract we instantiate it with an owner and some interest rate we store those two we Mark that the flash loan is not in progress we have no loan so we set the loan amount currently to zero we have to set a borrow to avoid uh using an option so we set it to owner and then we say the flash loan hasn't been repaid so we set repaid to Falls we then have the deposit entry point that the owner can call to deposit some funds that will be used to lend funds to anyone only the owner should call it but we don't have to check it if somebody else wants to send money to the flash laan contract that's fine the owner will be able to claim it so nobody else is likely to send some Tes then we have our borrow entry point that takes an amount someone wants to borrow and the call back to be called after the money has been sent we check that there is not already a loan in progress because if we can borrow while there's a loan progress that will complicate things we would have to keep track of the list of people who borrowed Etc so we only want to have one loan at a time so we say it's in progress the money is being used so we set it to true and we won't be able to borrow again until the loan is paid back we record who is borrowing we record how much is being loaned then we send that amount to the caller and then we call the call back it has to be an entry point that doesn't take any parameter so we send unit to it then after the call back is acculate we will call the check repaid function so the call back is supposed to use the money make some profit and then call the repay entry point so here we call the check repaid entry point here to check that indeed repay was called by the Callback so when the call back calls repay we check that indeed there's a loan in progress and we check that the amount paid back is equal to the loan amount plus the loan amount times the interest rate so for example if the interest rate in one and we need to pay back 101% of the loan amount then we can Mark repaid to true so the loan has been paid back so later when we call check repaid we check that it's in progress we check that the loan has been repaid and we say okay the loan is over it's not in progress anymore everything goes well and the whole transaction happens if check repaid is called but the call back didn't call repay then this will fail and everything will be cancelled and the money will be safe finally the owner can call claim at any time unless there's a loan in progress so we check that is indeed the owner calling we check that the loan is not in progress and then we send the balance of the contract to the owner who's calling claim we have our membership contract that checks when we joined that the caller sent a certain amount and then we send it by to them then we have the attack contract that will borrow some funds then join the membership contract then pay the funds back to the flesh Loan in the constructure we take the address of the membership contract the address of the flesh loan contract and then the amount that we will need to pay to join this club therefore that we will need to loan we store all three then we have the impersonate rich person entry point point we will call the borrow entry point of The Flash loan contract and we will pass it the amount we want to borrow plus the address of the call back entry point so here we get the attack call back entry point so that we can pass its address when we call the loan contract so we say we want to borrow this amount when you're done please call this call back which is this entry point so in the call back we call the membership entry point and we send it that amount of money so that we can join the club and then we repay the contract so we compute the amount to repay which is the amount we borrow plus 1% here we hardcoded that it's 100 T then we call the repay entry point of The Flash loan contract and send that amount of T to it so that we can repay the contract and of course we need a default entry point so that we can receive the funds that the flash loan contract sends to us and that's it so then we can see the test we create a membership contract we say the amount to have in order to join this club is 10,000 TZ then we create the flash loan contract we say Alice is the owner the interest rate is 1% and note that this is not 1% per year or per any unit of time it's just that any time you borrow you have to pay back with 1% of Interest immediately Alis sends 100,000 Tes to the flash loan contract so that people can use it to borrow some funds then we create the attacker contract we pass the address of our membership contract the address of our flashl contract and then the 10,000 test or the amount that we will need to pay to join the club and we simply call impersonate rich person we have to send some extra test to be able to pay the interest let's give it a try so here we can see that we originate the membership contract we originate the flash laan contract Alice deposits 100,000 t to the flash loan contract then we originate or attack a contract with the address of those two flash loan and M ship contract then the attack starts we call imperson at reach person we pass 500 T so here we borrow some funds 10,000 T and we say here is the call back the flash loan transfers 10,000 test to the default entry point of our attacker then it calls the call back so this function where we join Jo the membership contract by sending 10,000 TZ we get the 10,000 TZ back into the balance of our attacker contract then we can repay 10,000 plus 100 T back to the flash loan and so when the flash loan calls check repaid everything was good so everything works but if anything went wrong and for example we didn't pay the full amount back or we paid without interest let's say we pay only 10 T of Interest interest and if we run it we can see that this didn't work so everything was cancelled all good in this video you will learn how to create your own fible tokens in particular you will be able to create your own currency on chain fible tokens can be used in many different ways they can represent an existing fible resource for example we can create a stable coin or we can create an ingame C currency represented by a token we can also use fible tokens to fractionalize the ownership of a tangible asset for example we can have a token that represents a piece of real estate or a piece of art and the tokens make it a lot easier for the owners of this real estate to split their ownership and then Trade It Etc fible tokens can also be used to raise capital for a project similarly to stock the fible aspect ECT of tokens means that different units of the same token are interchangeable and if you own an amount of token you can split it into sub amounts this is very different from nonf B tokens nft where each nft is unique and cannot be split into sub nfts with all that in mind try to think about the structure of a basic contract that would represent a fible token I'll give you a hint think about the test token it is a fible token and what we want to be able to do with our fible token is very similar to what we are able to do with the native test so with that in mind think about how you would structure a contract to handle this pause the video and think about it for a minute so with the native TZ we have accounts and we have a balance for each account and we can transfer Tes from one account to another so we need to be able to do that with our token contract so we need to store the balance of each user in that token and we need to be able to transfer tokens to other people for that all we need is to have in the storage of our contract or Ledger a big map that contains the balances of all the users the key would be the address of the user and the value would be the amount of this token that the user owns and we need a transfer entry point where a user can say I want to send this amount of token to this destination and the ENT triport will check that we have enough tokens in our balance to transfer that amount if the destination does already have an account we create it by setting the balance for this address to zero then we can do the transfer we add that amount to the balance of the destination and then we subtract the amount from the balance of the sender so that's great but with the test we can do more than that so try to think about what else we can do with the TZ that this doesn't support and I'll give you a hint think about what you can do with Tes within smart contracts or when you use Smart contracts pause the video and think about it for a minute I'll give you another hint think about how you would write a version of the Endless wall contract where it would charge one token instead of charging one TZ to add a message to the wall what would you need in The Ledger contract to be able to support this here is the code of the Endless W contract that uses TZ so what would you need to do to be able to write a similar code but by charging using your own token instead of one TZ pause the video and think about it for a minute so with the native TZ token you can transfer test to a contract when you call an entry point then within the entry point you can use speeded amount to check how much was sent to the contract to pay for some service or to deposit some amount Etc so we need to be able to do something similar with our token one way would be to call the transfer entry point to send tokens to the address of the contract just before making a call to an entry point so that we can send some amount of token to the contract we are just about to call but if we do that we there would be no way for the contract to check how much we just sent to it so we need a way for the contract to be able to check who transferred how much to it and we need to make sure that the same transfer of tokens cannot be used for two calls by the same user to the same smart contract one way to do that would be to store information about every transfer to a given contract call and we could store that in a big map where we store all the transfers the key would be the source so who is calling this entry point and sending tokens to it and then we will store the destination address so the address of the smart contract and how much we are transferring so we would add an entry to this big map when we make a transfer to a Smart contract and the destination contract will then be able to call some entry point of the token contract of The Ledger to check that there is indeed a transfer that has been made with the right amount and they will then delete that transfer so that it cannot be reused so that could work but in practice the standards we use to write such fible tokens contract do it a bit differently so that we can mble more your cases instead of keeping track of how much we just sent to the contract we calling we will allow the contract to take some money from the caller so we allow a given contract address to spend some amount of tokens in the name of a given user or contract so users can say okay this contract is allowed to spend this amount of tokens from my balance and then the contract can directly transfer that amount to itself or to some other destination so instead of sending some token to the contract and having a way for the contract to check it we allow the contract to use some of our tokens and then the contract can do it itself so instead of storing transfers we store allowances in the storage of our Ledger where for a given account and a given operator that's the address of the contract we allow to use some of our tokens and we say how many tokens it can spend we create an allowance by calling an allow entry point that takes the address of the operator that is allowed to spend some of our funds and the amount that we allow this operator to spend if there's no entry we create one and then we add this amount to the entry so with the account and the operator then when we call transfer we specify the source because the source may not be the sender so we say I want to transfer this amount from this source to this destination and within the entry point we check if the source is not us then we check if there's an allowance that allows us to spend at least that amount then we subtract that amount from the Alan so that you cannot spend it a second time so now it's your turn to implement this contract so your job is to write a ledger contract such that a user can create a new token and set an initial amount of tokens that he owns then anyone May transfer their tokens to other users so this first user can distribute their token the way they wish then The Ledger will keep track of how many tokens each user owns in their balance with a system of accounts and balances and finally users can allow contracts to spend some amount of tokens in their name once you've done that use this Ledger in a version of the Endless wall contract such that anyone can add text to the wall as long as they pay one of your tokens and the tokens that are paid can be directly transferred to the owner of the Endless W contract to help you we provide you an incomplete code that you can find either in the G repository or on open tesos and your goal is to complete the contracts and the tests let's take a look at the solution so in our Ledger we store the balances so a big map initialized with the owner of The Ledger who owns the total Supply that we provide then we'll have another big map that will store all the allowances when we transfer some amount from a source to a destination we check if the source is not whoever is calling the transfer point then we check that they're allowed to transfer that amount so we check if there's an entry in the allowances for this source and this callar we check that the allowed amount is more than what we want to transfer and then we subtract the amount from the allowed amount this could be negative except that we check that it's not so we can convert it to a natural and then update the allenes we also check that the balance of the source is sufficient to transfer that amount then we update that amount by subtracting the amount we transfer from the balance of the source finally if the destination doesn't already have a balance we create one with the value zero and then we add the amount we transfer to their balance we will use a get balance onchain view so that any contract can figure out what's the current balance of a user for this token and then we have our allow entry point where a user can allow a given operator so the address of a smart contract to spend some amount in their name it could be a regular user but in practice it's almost always a smart contract if there's no entry in the big map for that key composed of the sender and the operator then we create one and we say the allowance is zero and then we add the amount we want to allow to this allowance and that's it for The Ledger now let's look at the modified version of the Endless wall contract all we have to do here in the contract is to do the transfer so we get the entry point transfer from that ledger contract the type of the parameter will be a source a destination and the amount and then we do the call to the transfer entry point we say the color of WR message is the source the destination is the owner of the unless will contract and we transfer one token we don't need to transfer any Tes and so this is just a way to say transfer one token from whoever is calling right message to the owner of the UN listable contract of course for this to work the user who is calling right message has to have allowed us to do so then we change the text in our test we create the ledger so Alice creates a ledger with a million tokens then we create an endless wall where Bob is the owner of that endless wall but the endless wall needs to know the address of the ledger so we pass the address of The Ledger here to Our Endless W Constructor that we store here and then finally Alice will need to allow the endless wall contract to spend one token in her name and once she's done that then she can call right message and this one token will be taken from her balance and transferred to Bob we can give it a try so here we originate The Ledger where only Alice has an entry with 1 million tokens then we originate the endless wall with the initial text hello then we allow the endless World contract to spend one token in the name of Alis then Alice can call the right message entry point and this will trigger a transfer of one token to Bob's address all good when we create fible tokens on tesos we need to make them compatible with tools and contracts and wallets so that generic tools can be used for you to view your balance and spend your tokens Etc so we have a set of standards that are used to create fible tokens the first standard was the a 1.2 standard that is dedicated to contract that manage fible tokens only then we have the A2 standard that also supports nonfungible tokens we talk about it in another module and at the time of recording we're about to release the AA 2.1 standard so an updated version of the fa2 standard these standards all include support for some system of operators and or allowances that can be done in different ways depending on the standard but the idea is always the same that we allow some address to do some operations in our name they also include A View to access the balance of a given user from another contract and they have additional metadata about the tokens in this video we will talk about how you can trade tokens for example if you create your own token you can trade it against TZ or against tokens from other people and we'll talk about how the value of a token can be calculated so in the module and fungible tokens we saw how we could transfer tokens from one address to another and how we could spend tokens in smart contracts using a system of operators and allowances but we also want to be able to trade our tokens with t or to trade them with other tokens so for example we can take the simple case of trading between a pair of tokens we create our token a and we want to be able to trade tokens a versus TZ so if someone has an amount of token a they want to able to sell it for some mon of t or vice versa so the question for you is think about how you would create a contract that would allow anyone to either quickly purchase tokens a using TZ as a way of payment or quickly sell tokens a in exchange for TZ and the important part is to do so at a fair price how can you make sure the exchange is on the right price pause the video and think about it for a minute so we can think about a multiple ways to determine the price a basic idea would be to set a fixed exchange rate once and for all so you could say well I create this token for my game currency and I will say that one token is worth exactly 0.3 T for example but if you do that no trading would probably happen because if some people think the currency in your game should be worth more than 0.3 TZ for each token then they will never sell it at that price or vice versa if people who may want to buy your token think well it's worth a bit less then they won't be willing to buy it at that price the whole point of creating your own currency is for the token to be able to have its value changed based on demand so if your game becomes very popular and lots of people want to earn some currency in your game then the price should go up and vice versa if the game is not too popular then the price should be able to go down so that people still can buy and sell those tokens so a fixed exchange rate wouldn't work another way would be to try to have a group of people decide together what the current exchange rate they could have meetings every day say okay we think it should be lower it should be higher let's change it a bit that would be a bit complicated and it wouldn't really help because it wouldn't adjust fast enough to the demand and this group of people wouldn't have a good way to know what's the right exchange rate it would say okay yesterday people bought it but didn't sell it so it's probably too cheap or vice versa and it's probably too expensive we need a way to instantly adjust to the demand we could think about using auctions like we do for nfts but auctions are slow you need to set a deadline in the future you need to make sure there's people who know this your auction Etc and they're hard to use because you would put an as an auction a certain amount and this amount may not match what the buyer wants to purchase and if you make an offer while setting up the offer at the right price is not easy either so we want something that really determines the right price automatically and instantly if you want the trading of tokens to be effective we need liquidity it should always be possible to buy and sell at any moment you shouldn't have to wait for someone to be available and agree to sell to you or buy from and the prices should be adjusted automatically and instantaneously based on the offer and demand for your token and the token you want to trade it for so to support that we could use a contract that will store some amount of the two tokens that you want to trade so we will store some amount of token a and some amount of TZ so that if people want to buy or sell there is some amount that is available immediately for trading and this contract will have to automatically adjust the price based on the offer or on the demand for your token so think about how you would design a contract that will store some amount of tokens a and of TZ and then will automatically adjust the price based on offer and demand and will let anyone trade at that price pause the video and think about it for a minute this type of contract is what we call a liquidity pool and a liquidity pool enables users to easily trade between Pairs of tokens let's imagine that we have token a and TZ in our liquidity pool some investors could deposit initial amounts of token a and a corresponding amount of TZ these tokens would form a reserve of liquidity for each of the two tokens then users would be able to trade amounts of one token for the corresponding amount of the other token at the current price and this current price the exchange rate would be based on the available amounts of both tokens in the pool we will see that when we do that any deviation from the real exchange rate based on the offer and demand the price that people are willing to buy it for or sell it for can't last very long because as soon as the price is cheap then somebody will quickly buy and it will increase the price or if the price is too much people will sell and this will reduce the price and there will be a system of Arbitrage opportunities that makes sure that the exchange rate is the right rate the investors who deposited the liquidity on this liquidity pool will be rewarded using Exchange fees so percentage of every trade that they will receive in exchange for providing this liquidity so the main question is how can we determine the exchange rate that we will use typically liquidity Pools use what we call an automated Market maker or am mm mechanism it's a mechanism that determines the token prices based on the amount of token a and of TZ in the pool for example of be a TZ there can be a number of different formulas you can use but the most common formula that is used is called the constant product formula and with this formula the prices are such that the product of the balance of both tokens remain constant so the balance of token a multiply by the balance of TZ that is in the reserve of the liquidity pool should always be equal to some constant K that we set when we create the liquidity pool and the idea is that with this formula the more of a given token you have out of the two the cheaper that token gets and of course the less of a token you have the more expensive it get because it's rare so it's more expensive than if it's really abundant so the the idea is that whenever we buy or sell a given token we compute the price to make sure that after the transfer this product is still constant so with that in mind let's Implement a very basic liquidity pool contract at the beginning we will have a single user who will provide liquidity to this pool a single time then other users should be able to trade tokens for tez or vice versa there should be a way for contracts to be able to check the current exchange rate and again the idea is that the balance of the two token in the pool should always verify this formula token a balance time token B balance equals K so first think about what you would store in this smart contract and what would the entry points be pause the video and think about it for a minute so in the storage of the contract we will need the address of The Ledger because we will interact with the Ledger that stores the token we also need the address of the owner who is the single user who put liquidity at the creation of the liquidity pool and they will be able to get it out when they want to close the liquidity pool we need to store the constant K so since we multiply a natural number with a number of TZ then K has unit TZ and finally on top of the balance in t that we will have access to using sp. balance we also need to store how many tokens the liquidity pool owns and we could of course check in The Ledger but it might be more convenient to store it directly in the storage then we will have five entry points the first entry point is for the creator of the liquidity pool to transfer some liquidity and so they send some amount of Tes to the entry point along with a number of tokens they want to deposit in the balance of the liquidity pool so you add to the balance in TZ and to the balance in this token some amount based on this you can compute the value K that's the product between this amount and the amount of test transferred and so we can store these two values and then we of course need to transfer this number of deposit tokens to the address of the smart contract through the ledger so this assumes that the caller has allowed the liquidity tool to transfer these tokens to itself at the very end owner should be able to withdraw their liquidity so when they call it withdraw liquidity we simply send all the tokens in the balance of the contract and all the Tes in the balance of the contract to the owner and this closes the liquidity pool then we have the two main entry points for for users to sell or buy tokens so our sell tokens entry point we will say how many tokens we want to sell but as a safety measure to make sure we don't sell them for cheaper than what we expect we indicate how many Tes we expect to get at the minimum when we sell our token so it's a safety measure to make sure that if the price goes temporarily very low then maybe we just don't want to sell so we can set some minimum value of how much we will get for those tokens and so in this entry point we will compute using the formula how many Tes the tokens that we want to sell are worth and if this is more than the Tes we requested then we simply transfer the tokens and T accordingly so we transfer the tokens to the liquidity pool contract and then we take test from the balance of the liquidity pool to send them to the seller the buy tokens entry point Works similarly we send some amount of TZ to the contract and we say with that amount of Tes I expect to buy at least this number of tokens if the price price of the token goes too high then maybe I just don't want to buy them and here again we start by Computing how many tokens I can get for that amount and if this is more than the minimum that I want to buy then we transfer the tokens and the test accordingly we keep the test sent by the user in the balance and then we transfer tokens to the color finally we will have a view get token price that will compute and return how much it would cost to buy one token right now so your job is to implement this contract and keep in mind that this formula should always be maintained the product between the balance of one token and the balance of the other token should always be equal to K before and after each call to an entry point again you can start with the incomplete code that we provide in the G repository or on open tzel pause the video and give it a track let's look at a solution here we have our Ledger that we didn't change and here we have this liquidity pool contract where we store the address of The Ledger contract the address of the owner the constant K that we initialize at zero before we know the value it will have and then we keep track of how many tokens the liquidity pool has on its balance and then this will be used to simplify the calls to The Ledger contract so basically this is a variable where we will store the address of the transfer entry point for that contract so that we don't have to compute it every time we have the provide liquidity entry point where the owner will deposit some amount of tokens and some amount of Tes initially to the liquidity pool we check that whoever is calling is the owner we check that we have never sent anything so the liquidity pull is not open yet so the value of K was Zero then we compute the value of K as the product of the balance of the contract after the transfer of TZ from the user and the number of deposited tokens so here K is set once and for all and finally we keep track of how many tokens the liquidity pool owns finally we do the transfer to obtain those tokens from the user through the ledger so this is where we initialize this Ledger contract up variable with the address of the transfer entry point of The Ledger you may notice that to avoid having to repeat the type everywhere we created this perm type that we Define here as the record that contains a source a destination and some amount so that we don't have to repeat it every time once the owner has provided some liquidity in the form of TZ and some amount of tokens we have the withdrawal liquidity that will be called at the End by the owner to withdraw all of these tokens so we check that this is indeed the owner calling and then we simply send the balance of the contract to the owner and then transfer the tokens themselves to the owner finally we just say now the tokens own are zero and then we set K back to zero so that maybe the contract can be used again later by the owner but this effectively closes the liquidity pool for now let's look at the get token price on chain view so that we can figure out how we compute the current price of the token and here the idea is to compare what the current balance in T is to what it would be if we had one less token and this difference is how much the balance needs to change so that the product between the two balances stays the same so here we divide K by the number of tokens we currently own this should tell us what the current balance is and then we do the same but with the current amount of tokens owned minus one and so this tells us what the balance should be after we sell one token so if we have the balance before we sell one token and the balance after we sell one token then the difference between the two should be how many Tes we get for that token and so this is how we compute the current price of a token now in the sell tokens entry point we do something similar we compute what the balance would be if we had this number of tokens on top of the token we have and so we compute how many Tes we are supposed to send by Computing the difference between the current balance and what we should have once we obtain those extra tokens so this is not the same as Computing the current price of one token and then multiplying this by the number of tokens sold because the more you sell token to the liquidity pool the cheaper they become because the more tokens the liquidity pool has then the cheaper each token becomes so we cannot simply use the price of the first token and then multiply that by the number of tokens so this is why we use this formula as a way to check what is the current balance and what should be the balance after we obtain those tokens and the difference between the two tells that the price that we should pay for those tokens so here we check that this price is more than what the seller is requesting and once we have that it's very easy we transfer the tokens we transfer the TZ and we keep track of how many tokens we still own the buy tokens Works in a similar way we compute the number of tokens we should get for the price that the user sends so sp. amount by Computing the difference between how many Tok tokens we currently own and how many tokens we should own based on the new balance that we have so we divide K by the New Balance to determine was the number of token we should own after we got this uh new amount and again we check that this number of tokens is more than what the buyer is expected to receive and if it is then we send tokens to them and we update the number number of tokens we own now in the test we create The Ledger we create the liquidity pool Alice provides 2,000 tokens and 2,000 Tes and C provide liquidity to the pool this means K will be 2,000 * 2,000 so 4 million then we have Bob bu at least 90 tokens for 100 TZ then Carl buys a th000 T worth of tokens and expect to get at least 500 of them then finally we have Bob sell his tokens so it allows the liquidity pool to withdraw 96 tokens that's the number that he will actually be able to buy here and then calls sell tokens to sell those 96 tokens and he expect to get at least 200 TZ so if this works so Bob spent 100 TZ to buy 96 tokens then Carl spent a th000 TZ to buy a lot of tokens so this increased the price of a token so that Bob can sell his 96 tokens at at least 200 and make a big profit of at least 100 T so let's give it a try so we can see here that we created The Ledger with 1 million tokens then we created the liquidity p cool with K set to zero no tokens own we provide some liquidity after allowing 2,000 tokens to be provided we provide 2,000 tokens and 2,000 Tes the transfer is made for these tokens to be transferred then we have Bob by 100 T worth of token and he wants at least 90 tokens for that price with see that the amount computed for 100 T is 96 tokens then Carl buys for a th000 TZ worth of token expect to get at least 500 and we see that he indeed gets 614 tokens for 1,000 Tes we can see that the price of the token went up for 100 TZ Bob got 96 token but for a th000 TZ Carl only got six 114 and the price keeps increasing as the supply of tokens in the liquidity pool gets lower we can see here that the number of tokens owned is down to 12290 whereas the balance is up to 3,100 so tokens are getting rare which means they're getting more expensive then Bob allows for his 96 Tok tokens to be transferred back to the liquidity pool and then sells them and says I should get at least 200 T and we can see that his 96 tokens are taken from him but then he gets 23997 T so he indeed made a profit of almost 114 TZ for his initial 100 T purchase so here there's high demand for these tokens so people who bought tokens early can make a profit all good in this video we will talk about the concept of Arbitrage and we will see that if there are two liquidity pulls or in other word two exchanges for the same pair of tokens but the price is not the same for both then there's an opportunity for Arbitrage where we can make some profit so the idea is that you could have two contracts two liquidity pools to exchanges where the exchange rate between the two tokens A and B or a in TZ are different when this happens this creates an opportunity for anyone who owns some token to purchase some tokens a in the contract with the cheaper price paying with the other token and then to sell these tokens in the contract with a higher price and you get a higher amount of token B that what you initially paid so you make a profit this happens all the time on block chains but also other markets and we presented a very simple opportunity where it's just a direct exchange rate between tokens but it could be path where you go through intermediate tokens but then find a way to make a profit with a succession of exchanges so there's always many many users and in practice Bots that constantly look for search Arbitrage opportunities and as soon as they see W they purchase some tokens in one exch change and then sell them for more in the other exchange by doing that they make a profit but they also help to make sure that the exchange rate for a given pair of tokens stays approximately the same across all the different liquidity pool contracts all the different markets and you can do this even if you don't have money by using flash loans so that you can take advantage of any such Arbitrage situation if you notice two liquidity pull contracts that have different exchange rates for the tokens A and B you could borrow tokens of type B from a flash loan contract then you can purchase tokens a at the cheaper price using your tokens B that you just borrowed immediately sell your tokens a at the higher price in the other liquidity pool getting more tokens B than you spent and with these tokens you could reimburse a flash loan and the interest but still make a profit so you don't actually need to own any tokens b or a to take advantage of an Arbitrage situation thanks to flash loans because Flash loans can make you temporary rich in any of the tokens and of course if you make a mistake and cannot reimburse The Flash loan everything is cancelled so there is no risk for anyone let's work on an exercise where you will take advantage of an Arbitrage situation you will use the Ledger and liquidity pool contract and create a test that does the following with a user Alice you will create a token with a supply of 10 million tokens then Alice will create two instances of the liquidity pool contract and each of those instances she will provide liquidity with 1 million tokens and 1,000 TS once this is ready we will have Bob purchase 100 TZ worth of tokens from the first liquidity pool and this will create an arbitr situation because it will change the price of the tokens that was initially the same in both pools but not at Bob bought from one pool it will change the price of the token in this pool so Carl will take advantage of this Arbitrage opportunity and earn some TS so using the example contracts that we provide on a g repo and on open tesel pause the video and write a test where Carl makes as much of a profit as possible in this situation let's take a look at the solution so here we have our Ledger contract and the liquidity pool contract that we didn't change and so in or test we here create a ledger in the name of Alice with a total supply of 10 million tokens then we create two identical liquidity pools lp1 one and LP2 each liquidity pool is created in the name of Alis attached to this Ledger and Alis provide 1 million tokens and a thousand T of liquidity initially the price is the same for both tokens then we have Bob buy 100 T worth of tokens from the first liquidity pool and he expects to get at least 80,000 token so this creates an arbitr opportunity because the tokens on the first liquidity pool will be worth more than the tokens on the second liquidity pool because there are now fewer tokens in the first liquidity pool so Carl can buy some tokens from the second liquidity pool and then sell them for more in the first liquidity pool and the question is how many should he buy and at what price and the idea here is that since Bob only bought a small amount of tokens compared to the the whole pool then the price won't change by much so we could use some math to compute what's the right amount but by triy and error we can see that the best amount is to spend 48 TZ and this will buy 4,82 tokens and with this numberous call we'll make a profit of 4.76 T and if he bought for 49 T then the profit would be a bit less and same for 47 T profit would be a bit less so maybe the ideal value is not precisely 48 T but this will be close enough so Carl will buy this amount of TZ worth of tokens and he expects to get exactly this amount but that's the minimum he says he wants to get then he will sell those tokens back on the first liquidity pool so allows this number of tokens to be transferred by the first liquidity pool and then sells them so so let's give it a try so we can see the creation of The Ledger creation of the first liquidity pool then we allow transfer of liquidity to this first liquidity pool we do the same for the second liquidity pool and then we have Bob who buys 100 T worth of token we see that with this amount he actually got 9,910 token then Carl buys for 48 T worth of tokens with see that indeed the number of tokens he bought is 45,8 two and that by looking at this value that we actually set this exact value here then the tokens are transferred and then Carl allows for these tokens to be transferred when he sells it and he to sell this amount of token and he expects well he doesn't expect anything he'll just see what he can get but we can see here that the tokens are transferred and then we have 52.76 TZ transferred so he bought them for 48 T and he sells them on the other liquidity pool for 52.76 making a profit of 4.76 T if we want to better understand what happens we could check the prices at different moments of the different liquidity Pools by calling scenario. verify and then I get the token price and check that for example it's at least 90 mutes some rary value and the get token price can be instrumented with some Trace instructions to find out what the different values are what the ratio are what the current price should be and so we can run it then open the console to see here the price of the token return is 1,000 so when we call it here right after we created the liquidity pool then one token equals 1,000 mutes but after Bob buys some token then we can run it again and we see that this time the price increased to 1210 mutas Etc so you can use this instruction at different places with the two liquidity pools to check exactly what's happening very convenient to help you understand you can play around and see what happens in this video we will show that in some situations it's possible to manipulate prices of tokens and cheat if contracts are not protected against this manipulation contracts that want to attract wide audience may offer users to pay in a choice of multiple tokens so you could accept payment in TZ but also accept payment in number of other tokens that people own so that they don't have to First Trade their tokens before they can use your contract so for example we could change our membership contract to sell the access to a club we could set the entry price at A th000 T but people could also pay the equip equivalent price using token a for the contract to be able to do that and use the right price it will need to obtain the exchange rate between those two tokens but this can be done through the liquidity pool you could use the view get token price from the liquidity pool to find out what's the current exchange rate let's take a look at this version of the membership contract it will use a ledger it will use our liquidity pool that we don't change and here is the membership contract when we created we initialize the membership price in TZ we said the owner we give the address of The Ledger and the address of the liquidity pool and we have our set of members here then users have two ways to join the club they could join by simply paying the membership price in TZ so we check that they pay the right amount we add them to the list of members and we send the amount to the owner this is a extra usess line here but users could also join this club by paying with tokens and when they call they say how many tokens they pay we will then check the current token price by using the get token price onchain view from the liquidity pool and then we check that if you multiply the number of tokens that the user is willing to pay with this current price it should be at least the membership price in TZ and if that's the case then we transfer the tokens from The Ledger to the owner and then we add this user to the club then we have our test where we create a ledger liquidity pool we provide liquidity to the liquidity pool then we create the membership contract with a entry price of a th000 TZ we have Bob simply join the club by paying a th000 TZ then we have Carl joined by paying 1,000 tokens let's give it a try it worked so we see that we created The Ledger the liquidity pool we provide liquidity to the liquidity pool then create the membership contract and then we transfer a thousand TZ from Bob's account so that Bob can join we can see here that Bob is a member then Alice transfers 2,000 tokens to Carl so that Carl can join using tokens and Carl allows for 1,000 T to be spent by the membership contract and then calls joins with tokens with a thousand token and the tokens are transferred and so the current price paying 1,000 token works now the issue is that unfortunately this contract has a very serious flaw and the question is can you figure out a way to obtain membership at a very low price and as a hint I can tell you that the idea is that the exchange rate can be manipulated look at this membership contract and think about how we can manipulate the price so that people can join the club without paying much pause the video think about it for a minute so the way you can manipulate the price to join the membership contract is that you can manipulate the exchange rate of token a versus T to do that you would first buy a lot of tokens a from the liquidity pool this will automatically increase the price of token a by a lot in this liquidity pool then you can purchase membership in the club using just a few tokens a because those tokens are worth a lot now and then you can sell your tokens a back to the liquidity pool at the same price you bought them so you temporarily increase the price of token a by a lot by purchasing most of the tokens a from the liquidity pool to make them be worth a lot then you use them to purchase membership and it will check the price using this liquidity pool and then you can sell all your tokens back but for this to work you need to have enough funds to buy tons of tokens a from the liquidity pool and you also need to make sure that nobody jumps on the abrage opportunities because if you bought a lot of tokens then people can sell tokens to the liquidity pool because the price is very high before you get to purchase membership in your contract and remember that there's always Bots looking for these opportunities so as soon as you buy a lot of tokens a some bot will purchase tokens a from a different pool and then sell them to the liquidity pool to make a profit and your attack won't work so for this attack to work we need to make sure we have enough funds and we need to make sure nobody can jump on the Arbitrage opportunity that you create by buying so many tokens because if this happen when you sell them back you won't be able to sell them at the right price and you will lose money so if you assume that you only have 200 Tes how could you still join this club without spending much pause the video and think about it for a minute so the solution to both issues with our attack is to use a flash loan you could borrow enough TZ through a flash loan to purchase lots of token a and therefore impact the price and then you could pay back the loan within the same transaction and if you do everything within a single transaction nobody will be able to use Arbitrage because nobody can run any smart contract call or any transaction at all within your transaction as an exercise you will try to simulate this using The Ledger the liquidity pool The Flash loan and the membership contracts you will create an attack manually in your test that will make it possible to purchase a membership from an account that only spends 200 test to create this attack you need to be careful with the execution or of a transaction remember that when from an entry point you call a smart contract you're not actually executing that smart contract right away you're adding it to a stock of transactions that will be executed after the execution of your entry point and the Order of execution of the different transactions is important for you to be able to create this attack and to help you we prepared a file that you can find on open tesos or on git with all the contracts you need and you just have to write a test pause the video and give it a try let's look at the solution so we have our Ledger we have a liquidity pull we have a fles loan contract then our membership contract and then we will create an attor contract that it will temporarily use a flash loan to increase the value of our token then use just a few token to pay for the membership and then pay pay the loan back so this attacker will need the address of all the different constructs it will interact with we will need to calculate how many tokens we buy so this is a value you can calculate and we initialize how many Tes we will borrow from The Flash loan and we have the price of membership and so the attack needs to be in three parts that's because the first part will borrow some test from The Flash loan but since we don't get the funds immediately we cannot do the second part immediately so what we do is we then call the second part to make sure the second part is executed After we receive the funds from the flash Loan in the second part we will buy tokens from the liquidity pool and then call the next part because the next part needs to happen after we receive the tokens from the liquidity pool so that we can then benefit of the new of the token in the liquidity pool to purchase the membership so here we borrow funds from the flash loan here we buy a lot of tokens from the liquidity pool and here we buy the membership at a low price we sell our tokens back to the liquidity pool and then we replace the flash loan we can check the details and here we can see see that we use the view from the liquidity pool to compute how many tokens we need to pay to the membership contract and send here so we compute here pricing tokens by getting the current price of our token and then we see how many do we need to pay for the membership price we add one to take into account running issues and that's the amount we will transfer when paying for the membership ship then in the test we can see that we create the liquidity pull The Ledger the membership flash loan we deposit some funds on the fles loan and then we simply call or attack your contract after allowing the liquidity pool in the membership address to withdraw some tokens from the funds of the attacker contract so the question you may now ask is how do we prevent such a tax and for that you need to really understand what's the cause of the flaw and the cause of the flaw is that the liquidity pool may not always reflect the real exchange rate it only reflects the real exchange rate if you get enough time for Arbitrage opportunities to be taken advantage of by Bots or other users so knowing that how can we avoid this issue this type of attack pause the video and think about it for a minute so if you want to prevent a tax based on price manipulations one way is to keep track of prices within some time frame so for example within some number of blocks like five blocks then across those five blocks you could use the medium price within that time frame as given by the liquidity pool this gives enough time for Bots to take care of Arbitrage opportunities and you avoid flukes in the price of the liquidity pool and most of all you make sure you don't take the instant price returned by the liquidity pull based on the current balances you take a price that has computed before your current transaction there's another approach that consists in combining multiple sources multiple liquidity pools and again taking the median of their prices but you should make sure you don't take instant prices because multiple liquidity pools could be manipulated at the same time in this module you will learn how to generate events from a smart contract a feature that makes it a bit easier to create that that react to Smart contracts so smart contracts May emit events that you can observe from an offchain app and so the goal of events is to standardize how external apps can keep track of some aspects of a contract instead of having to go look at its storage analyze transactions in the block Etc they will simply be able to listen to events some examples where events could be used to inform for apps and their users an event that corresponds to the sale of an nft within a collection or an update to some value provided by an oracle or the operation of a new proposal for a multi or a dow contract where the user is expected to participate and vote after checking what the proposal is in all of those cases it's convenient for the contract to emit events and for apps to observe those events so that they can react to it or warn the user about it to emit an event from an entry point you can add this instruction sp. Emit and then you have up to three parameters the first one is the only one that's mandatory the other two are optional the first one is a value attached to the event it can have the type of your choice here we put a string but it could be an integer it could be a record almost anything you like then you have an optional tag so it's a word with no spaces that is attached to the event and that deps can use in filters so you could listen to all of the events that have a specific tag for example so finally there's a wi type attribute and when you set it to True some extra content will be added to the event that describes the type of the value in a way that is fully annotated so events have absolutely no effect on chain it's not going to change anything about the behavior of your smart contract it's only only for offchain apps to observe they are emitted by a transaction and are listed in its result in the order that they are emitted and an app can obtain the list of events emitted by a transaction with their values their types and their tags they can do so through RPC calls directly to the node or they can use the dedicated API of indexers that support events for example TZ KT let's take a look at an example we'll take the basic C the calls contract that simply counts the number of times we call make call but now when we call make call it will emit three events one just with a string hello one that will have both a string and a tag my tag then finally one a bit more advanced where we include a full record with two attributes a tag and we include the annotated type of this record so whenever somebody calls my call all these three events will be generated in this order in the smart P IDE when we run it we can see that we have this meel entry point being called and then the hello event the second event and then this event with a record that's about it if you go to a block Explorer on the contract that emits event here we can see in the melon code emission of some event with a pair of ins then you can see that you have an event events tab that is only present for contracts that emit events and if you go to the events tab then you can see the different events from different transactions here we can see one in this block one in this block Etc in this module we will talk about how we can upgrade contracts whether it is to fix a bug or add new features so by Design and thanks to decentralization a Smart contract can't be mod ified by the author this is so that users can trust that the contract will always do what it says but the author of a smart contract sometimes really want to be able to make some changes it could be because they need to fix a bug that was found in the contract or it could be to add a new feature or make it compatible with a new standard or to finetune the business Logic for example how rewards are distributed or votes are counted Etc so the question is how can we solve this Dilemma on one side you want to make it possible to change a contract but on the other side you want to allow users to trust that the contract won't be changed to their disadvantage so how can you solve this dilemma pause the video and think about it for a minute a common solution is the simplest one you can simply replace the contract with a new one and sometimes it's just that simple you simply Point your dab to the new contra contract but this approach has limitations first you have to warn everyone that the new contract is being used and that the address that the DAP points to has changed and if users have Assets in the old contract they have to move these assets to the new contract and then stop using the old contract but these assets may be locked in the old contract for example into the deadline that is quite far in the future let's start with an exercise where you will take the endless World contract we use a version that has an unchain view that gives access to messages from each user and then your goal is to create a new version of this contract where we now require new messages to be at most 30 characters where we charge one test per message and we allow users of the old contract to transfer their messages to the new one for free without paying the one test per message so we have our existing endless World contract here that stores all the messages in the big map and that stores the owner with the right message entry point and then we have this onchain view read messages that simply returns all the messages for a given user so start from this contract and write a new version of the contract that can transfer all the messages using this view into the new contract you will have to have both contracts in your files so that you can create a test that makes them interact with each other pause the video and give it a try let's take a look at a solution so here we have the old contract and here this is the new version of the contract so we still have a big map to store all the content we still store the owner but we also store the address of the old contract so that we can interact with it in the right message entry point we simply make the changes to the logic where we charge one TZ and we check that the messages are shorter than 30 characters everything else is the same as the previous right message but now we add this new transfer old messages entry point where we call the view read messages from the old contract to obtain the data associated with that user the user who's calling this transfer old messages entry point and we simply store this old data in the new contract without charging anything we ass assume that the user never called right message so we simply create or replace uh the entry with the sender as the address finally we keep the same onchain view in case we want to upgrade the contract again and then in the test we first create the first contract with some message and we need and then we test the new contract where we write messages and of course longer messages are not allowed we need need to make sure we pay one t but we can also transfer messages from the old contract here by calling transfer old messages as Bob and then Bob can finally add new messages an issue with this approach is that it requires the initial contract to have views so that the new contract can access the old data so the question for you is how would you manage the transfer of data without having an onchain view in the old contract positive and think about it for a minute so if the old contract doesn't have any views we have to count on the owner to validate every transfer of data we can think of three approaches to do that the owner could simply initialize the contract with all of the data from the old one the issue with this approach is that this could exceed the gas limit for the deployment the origination transaction would be too large to fit in a single block and it would also be quite expensive the next option would be for the owner to have an entry point to transfer Bunches of data from the old contract and split the transfer between many different calls and the main issue with that is that the owner themselves will have to pay for all the storage costs and all the transaction costs required for all these calls and that could be quite expensive if the contract is very successful a better option would be for the owner to publish signed messages that allow users to repost each of their old messages so the idea here is that users should be able to post old messages for free but for any new message they would have to pay one TZ so the owner can send them signed messages of chain as a proof that the owner of the contract allows them to post this messages for free with this approach each user will pay for the transaction fees and the storage fees for the transfer of their own data they just don't have to pay the one Tes to the owner again so let's do this as an exercise you will start with the same initial endless walk contract as in the previous exercise but this time without the onchain view and then you can create a new version of the contract or modify your new version of the contract so that users can repost their old messages for free so you can assume that offchain the owner will publish a signature for every existing message and the signatures will guarantee that the old messages sent by users were present in the old contract so you will have to write a tests and in the test generate all the signatures and then call the new contract in the name of different users with the content of the messages and the corresponding signatures pause the video and give it a try let's take a look at the solution here we have the old contract that we didn't change except we remove the onchain view and here is the new version of the contract here we don't store the address of the other contract we don't interact with the other contract instead we store the public key of the owner that we will be able to use to verify signatures sent to the contract the right message entry point didn't change so we only change the transfer all messages entry point and we take as parameters the all data packed as a sequence of bytes and the corresponding signature then in the entr point we check that the signature is valid so we check that it corresponds to the public key of the owner for the signature and this packed data then we unpack the data the data contains the text of the messages from the user and the corresponding timestamp and the user address so we unwrap the data and then add it to the big map and in the test here after creating the new contract we fetch all data from the old contract off chain anybody has access to this data so we can simply fetch that data we create a record where we add the user address we pack it into a sequence of bite and then we call make signature using the secret key of Alice to generate a signature for this data and then we call transfer all messages let's give it a try and we can see that everything worked well in the version we just presented an issue is that all the messages were duplicated into the new cont contract and we had to have each user pay for the storage and transaction fees again this can be a bit costly but another issue is that if the data represents assets duplicating them could be problematic for example imagine that the assets are nfts if you duplicate nfts this would mean both the original nft and the copy could be sold separately and exist at separate nfts so the question for you is can you think of a solution in the case of an nft cont contct that avoids duplicating the nfts one solution in the case of an nft contract is to wrap the nfts we already use this approach as a way to go around paying royalties and the idea is that the new contract can buy an nft from the old contract and then Min its own version of the nft and this copy would become the new official version and could have a different set of rules for trading the nft compared to the old version but this can be considered as upgrading a contract this approach only works when the ownership of assets can be immediately transferred to a new owner that will be the contract if you can plan things in advance there are better approaches available so you can make upgradability a feature of your contracts we already saw that if you planned an onchain view in your contract this can allow you to duplicate the data but what we really want is to avoid duplicating the data but instead move the data or the assets into a new contract without duplicating them so the question is how can we make sure that data can be moved into a new version of the contract pause the video and think about it for a minute really transferring the data to another contract can be costly or complicated you have to repay for all of the storage costs in the new contract and you also have to split the transfer into many transactions so what we really want is to keep the the data in the same contract but since we want to upgrade the contract and have a new contract a good way to keep the data in the same contract is to separate the logic into a separate contract that interacts with the data contract so you have one contract that takes care of storing the data and then one contract that takes care of the logic and the contract in charge of the logic could easily be replaced so only the ownership of the data contract would then need to be transferred instead of the ownership of every asset in the old contract let's do it as an exercise so your goal is to create a version of the Endless World contract that is upgradeable and you do that by splitting it in two you will have one contract that will be in charge of storing the data and then a second contract that will contain the logic and access the data through the first contract then you will show how it can be upgraded by using a new contract that accesses to the data contract and again it should only allow messages to be of length less than 30 characters and it should charge one test for each new message let's take a look at the structure of such a contract so first we look at the data contract in the storage we will have all the content in the big map W content and then we store the owner of the contract but this time the owner is the address of the other contract the logic contract then we have two entry points that will be be called by the logic contract the first one is the right message entry point that takes the message and the user as parameter the caller will be the logic contract so we check that indeed only the logic contract can call this entry point and then we simply store this data into W content with the user as the key then as the goal is to be able to upgrade the logic contract we need another entry point update owner where the previous logic contract can say okay okay I need to be upgraded here is the address of the new contract that will take over the logic and so we pass the address of the new contract as parameter and we check that the caller is indeed the current owner before updating to the new owner then let's look at the structure of the logic contract that we call upgradable endless wall in the storage here we don't store much we simply store the address of the data contract and the address of the owner of this contract in the entry points we simply have the usual WR message entry point that takes a message as a parameter and all it will do is call the right message entry point of the data contract with the message and the address of the caller then when we want to upgrade this contract we call an entry point upgrade with the address of the new contract we check that it's the owner of this contract that calls and then we call the data contract to say update the owner to the address of the new contract so your goal is to implement these two contracts and demonstrate the upgrade procedure to a new contract in your test and of course again the new version of the contract should only allow messages of length below 30 and charge one test for each new message pause the video and give it a try let's take a look at a solution so we start with the data contract we see here that we have our big map and the address of the owner contract here in write message we check that the caller is the owner so the logic contract and then we simply add the content as usual in the big map and then the update owner entry point simply checks that the caller is the Old owner and replace it with a new address of the logic contract then in logic contract we store the owner and the address of the data contract in the right message all we do is call the right message entry point of the data contract contract and then in the upgrade contract we call the update owner entry point of the data contract to change the owner after checking that this is the owner of the logic contract doing the transfer in the new version of the logic smart contract we keep exactly the same structure and the same content the only thing we need to change is to add the assertions that about the length of the message and at about the one test price to call right message and in the test we first create the first version we pass we first create the data contract we pass it to the first version of the logic contract then we upgrade to the new version and continue adding messages we can give it a try and we can see that we can keep adding messages and then we have all the messages sent through the old logic contract and the messages sent with the new log contract so one issue with this new solution is that sometimes we really don't want the address of our contract to change because then we need to send everybody to the new address so to deal with that we can use a proxy contract a proxy contract is a contract that forwards all of the calls to the real contract so it's an inter intermediate between the user and the real contract and the address of this real contract can be changed while your proxy contract never changes as long as the API the entry points and the parameter of the entry points stay the same so let's give it a try as an exercise try to make the endless wall contract upgradable using this proxy pattern then show how it can be upgraded to add the rules about the length of the message without changing the address that people use to interact with the contract so here we would have again two contracts the inner andless W contract would have the usual storage with the big map and the address of the owner that will be the proxy contract and we'll simply have one entry point write message the TT this parameter the message and the user check that the caller is the owner and update the data and in the proxy contract we will store the owner and the address of the inner contract in the right message contract we simply call the inner contract write data entry point with a message and the user that is the caller and and then we have an entry point to upgrade to a new contract we check that the caller is the owner and then we replace inner contract with the address of the new contract so your goal is to implement these two contracts and demonstrate the upgrade to a new inner contract pause the video and give it a try let's take a look at the solution so here we have our inner contract with the wall content and the owner the right message entry point is the usual nothing special about it then we have here our main proxy contract where we store the owner and the address of the inner contract and whenever we call write message we simply forward that call to the inner contract and when we want to upgrade we simply store the new address of the inner contract and if we want to upgrade this contract we only upgrade the inner contract and so we can update the address of this inner contract and keep using the same address for the main contract so here we have a new version of the inner contract this is pretty much the same as the initial one but with this extra assertion and here again we have the test that first creates the proxy then initializes the inner contract and then we upgrade to the new inner contract can give it a try and see that it works so once more there is an issue with this approach is that which is that when we upgrade the inner contract all the data is lost and again deploying the new inner contract with a copy of all of the data would be too costly but we could combine the two approaches that we just saw the proxy W contract on one side and splitting the contract between the logic and the data on the other side so we would have three contracts it starting to be a bit complicated but it can work in the next module we will see another approach that is based on a feature called Lambda in this module we will see another approach that can be used to upgrade contract and that is using a feature of the language called landas on tesos it is possible to store pieces of code in a variable or in the storage of a smart contract using lambdas a Lambda is a piece of code that can be stored then executed in particular it's a piece of code that can take some parameters and that returns a value this value could contain operations to execute but by default they have no side effect so executing Lambda itself won't change the storage or emit operations but with smart P there's a syntax that makes it transparent to include feature that allows to do either of these so let's see how to create a Lambda to create a Lambda we declare a function within the main module that takes one parameter error and return a value we can keep this Lambda in the storage by simply using the name of the function as the value as we do here we store a default rule that is defined here in the data. rule attribute of the storage then we can call it from an entry point so here when we call execute rule we can call self. data. Rule and pass the current value as a parameter and then we get the result and store it again in the contract so here this is a rule that simply increments the value that we passed as a parameter then we can have another entry point that updates the rule to a new function so here we can call we can simply change self. data. value equals new rule where we use a different Rule and store it so our Lambda really only takes one parameter so if we want multiple parameters we have to use a record in the definition of your function you actually declare multiple parameters separated with commas but these parameters will correspond to different attributes of the record that you will send when you make a call so here we have two parameters A and B and the rule simply adds A and B and Returns the result but when we call this Lambda we need to create a record with the attribute a with the first value and the attribute B with the second value so here it looks like separate parameters but when you make the call it's a single parameter that is a record containing two attributes although internally lambdas do nothing except doing some computation and returning a value and cannot modify the storage or create transactions in smart Pi we have added syntax that you can use in Lambda to allow you to modify the storage and create transactions so in practice what really happens is that the internal lamb does simply return the changes to apply to the storage and also return a list of transactions to be added to the list of transactions of the entry point let's work on an exercise where you will create an upgradeable contract using a Lambda so you will start again with the endless wall contract and then make it upgradeable by the author using a Lambda so that you can support rules about the amount to pay when writing a message and rules about the content of the messages that are allowed for example the length of those messages so everything about that should be handled by a Lambda and then you add an entry point to allow the author of the contract to change this rule so the initial rule should be that any message is allowed and it's free and the new rule should be that the messages length should be less than 30 characters and the amount to pay should be one test pause the video and give it a try let's take a look at a solution here in the main module we create two versions of the internal rule the first version doesn't do anything we don't check anything we allow every message and it's free the second rule simply checks that the length of the message is less than 30 characters it should be strictly less and you will notice that we don't check anything about the price yet we'll talk about it in a minute so in the endless World contract we as usual store the content in the big map the owner but then we store this extra value that will be a Lambda verify that takes care of very verifying if we allowed to send a given message so we initialize it with default verify message in the right entry point we do the usual but at the beginning we simply call at s. data. verify with the message and then we have an entry point to change the rule set verify that TT the new Ru as parameter and we verify that it's the owner calling it and we simply store this new rule so one issue here is that we did didn't plan in our right message entry point that we would be able to change the price of calling message so since we didn't plan it and didn't pass the amus parameter we will be stuck here and cannot verify the price so when you use a Lambda you have to think ahead of time everything that you want to be able to change on one side it's good because people who read this contract know that all you can do is check if this is allowed based on the content of the message and if they read this they see okay you won't be able to charge ever in the future so I'm free to use this it's always going to be free I don't need to worry about so in a way that's a good thing so you have to think about everything you may want to change in the future so if we want to make sure we can decide later on to add a price we need to send the amount to the Lambda but again we cannot simply send two parameters we have to create a record so we create parm equals sp. record message like this and then we send that parameter and now we need to change each of these lambdas to add the price here and here and then we can assert price equals one t so if we give it a try we can see that here we didn't send one TZ because I just changed the rule but here we can pay one t and then it works all good so when using lambdas as we just saw you can only change aspects that were already planned to be changed another example is that in the code we just presented we couldn't add a rule about the total length of a text G a given user may have we can only make a rule about the new messages that we add but not the total amount of text that they store in the contract but as we said this is a good thing the Min users can read the contract and know the limitations of what changes you may make in the future so that they can trust that everything else won't change which is a really important part of using smart contracts in a decentralized blockchain in this short module we will list all the different ways we presented on how to upgrade contracts we presented four different ways the first one was to Simply Point The Depths to a new contract which implied supporting transfers of data or assets to the new contract but we saw that the transfer may be inconvenient or costly and that for nfts we could use wrapping as a way to transfer the assets the second approach was to store the data in a separate contract that could be used by the New Logic contract but of course this means we cannot change the structure of the storage between versions since we keep this data contract between upgrades the third version was to use a proxy contract so that we could keep the same address for the contract but the limitation is that this means the API has to be the same between versions and finally we just saw how we can use lambdas to place some of the logic in the storage of the contract so this means there are limitations to what the owner can change in the contract which can add trust for the users but that also means that all the aspects that the owner may want to change need to be thought about in advance so here we talked about how to upgrade the contract but in each case the owner could unilaterally make changes to the contract at any moment so we could limit what the owner could change but still they could change quite a bit whenever they wanted but we really want users to be able to trust that the contract won't be changed so easily as this really defeats the whole point of using a disiz blockchain so there are two ways to help reduce the risk of a better surprise for the user when a contract is being upgraded the first one is to have a delay between the time the change is made public and the time this change is effective so for example you could have a two weeks delay that allows users of the contract to exit the contract and get their assets out before the changes applied if they dis like that change but this may not always be possible the assets could be stuck in the contract for a very long time another approach is to use contract governance basically letting users vote and only apply changes that users approve this can be done through a multi or a da a decentralized autonomous organization contract which will we present in the next module in this mod module we will talk about multisig and DOW contracts contracts that allow people to work together as one for example to collectively manage some assets so first we'll talk about decentralized autonomous organization or Dao a Dao is a smart contract that enables communities to collectively manage resources the participants in a DA can contribute funds or resources that are stored in the contract then in exchange they receive tokens or shares representing their ownership and influence within the Dow then they can propose ideas projects or changes then vote to determine which of these ideas are accepted or rejected and people may receive Rewards or incentives based on their contribution work or voting participation so the good thing with Dows is that the decision process to manage the shared assets is decentralized fair and transparent dials can be used in many different situations for example you can have collective decision making on a project development where you allocate resource manage the budget and distribute rewards those can also be used in various Industries such as Finance art governance social impact and decentralized applications in finance daos can facilitate decentralized investment funds lending platforms or decentralized exchanges finally Dows can Empower communities to collectively manage digital assets develop opensource software curate content platforms or govern decentralized protocols as an example let's look at the C Finance protocol col is a defi protocol that allows users to borrow stable coins against T it uses smart contracts and each smart contract is referred to as an oven to collateralize TZ versus the stable coin kusd each oven has multiple functions you can deposit some Tes into the oven you can withdraw TZ from the oven you can borrow kusd against the oven using TZ as collateral then you can repay K USD that was borrowed against the oven finally you can liquidate and your OV is liquidated automatically if your borrowed stable coin exceeds your test deposit so let's look at how a DA is used to manage the governance of the C Finance protocol Kow is the governance token used for the cber finance protocol and you need to own Kow to participate in the governance of the protocol you can vote or submit proposals to submit a proposal you need 1,000k D and you submit it it on the c. Finance protocol by pushing a piece of code a Lambda as an example we can take a look at proposal 41 it was proposed after a white hat hacker had found two critical vulnerabilities in the C protocol that could have led to a drain of all of the funds of the protocol this white hat hacker disclosed those vulnerabilities and the developers took actions to patch the bugs but as a reward the community decided to make an unchain proposal via the Dao implementation in order to transfer 50,000 USD to the white hat hacker we can go to the Cur governance website to check all the different proposals and we see here proposal 41 pay security researcher for bug disclosure and we can see that people voted yes by a wide majority and some people abstained and we can click here to see the detail of The Proposal with a short description a link to some details and here we can see the melson code of the Lambda that was sent and that included a transfer of tokens to the researcher another example of Da is the tesos ecosystem da it was designed to curate and vote on the distribution of TZ for various tesos ecosystem initiatives it's governed by a small number of key holders that include the tesos comments TR TCH tesos domain Foundation the tesos foundation itself and the tesos India Foundation anyone can submit any initiative to the DA via the tesos Agora Forum then the initiatives will be curated by tesos comments and proposed to the DA on chain and the objective is to facilitate Community engagement in funding decisions and to promote the growth and development of the tesos ecosystem basically it's a way for people to be rewarded to contribute to the tesos ecosystem now let's take a look at what the smallest Dow could be we can have a variety of different types of dows with different features including governance tokens rewards Etc but they all include a voting system with various rules on how votes are counted for example with quorums Etc so a minimal Dow would include a list of participants a system to propose decisions and a voting process where decisions are executed when approved by a given number of participants this kind of minimal Dow is already very useful it even has its own name we can call it a multisig so what is a multisig it's a contract that requires multiple signatures in order to execute a given transaction this is a way to enhance security by ensuring that no single party has complete control over a transaction for example if you have a company you don't want to have one single person in charge of the private keys and instead you can use a multi where multiple people have to agree before a transaction is confirmed multi contracts operate on the principle of consensus where a predetermined number of signatures are required to authorize a transaction each signature is associated with a specific participant or key holder and the contract verifies that the required number of signatures is provided multis contracts are commonly used to secure funds or assets especially in cases where multiple parties are involved or an added layer of trust and oversight is desired multi6 can be used in a number of use cases for example for escr services multis contracts can be used when funds are held in a contract until specific conditions are met and multiple parties must provide their approval for the release of the funds it can be used in decentralized organizations where they facilitate this centralized decision making within organizations by requiring multiple keyh holders to approve proposals or fund location finally they can be used to secure wallets multi contracts can be used to create secure wallets where multiple signatures are required to authorize outgoing transactions which provides enhanced protections against unauthorized access or theft as an exercise your job will be to create a multi contract where in the storage you have a a predefined set of participants and a number of required votes to approve a proposal and you will have an entry point to make a proposal in the form of a Lambda to execute with a deadline and another one to vote for that proposal and have it executed when the number of votes is reached pause the video and give it a try let's take a look at our solution so here we have a Lambda that we will use as an example of proposal that simply sends some Tes to a given address in the contract itself we will have a set of participants a big map with all the proposals a number of required votes for a proposal to be accepted and then the ID that we use as a key for the proposals bigma in the proposed entry point people can call the proposed entry point to send a piece of code a Lambda with with a deadline for people to vote we check that the caller is one of the participants in the multi then we store the proposal with the next ID and we store the code the deadline number of approvals at zero and then a set of people who have already voted to make sure people cannot vote twice on the same proposal then we increment the ID when somebody votes they indicate for what proposal they vote and then we check that they vote before the deadline we check that there are indeed a participants in the multi seek and we check that they have not already voted then we Mark they have voted we increment the number of approvals and then we check if the number of approvals is equal to the required number of votes then we execute the proposal we don't need to delete the proposal because we have to be exactly at the number of approved so if one more person votes then we will exceed the number of proposals and so this will not be executed and in the test we simply instantiate the multi seek with a set of participants and a required number of votes at two so both Alice and Bob have to approve a proposal for it to be executed then we propose a Lambda and have both people vote for it for