Dr R is back with another Advanced JavaScript course he'll teach you how to build a virtual environment entirely from the ground up get ready to use basic HTML CSS and JavaScript to craft a world you can use in all kinds of projects he'll show you how to fill the world with selfdriving cars but you can fill it with anything you like hi and welcome to phase two of the selfdriving car course a virtual world this is actually a standalone so you don't need to have watched phase one to follow along we'll start building this world from scratch using some basic HTML CSS and a lot of JavaScript and whether you'll fill it with selfdriving cars or something else is completely up to you the focus will be on generating the world itself and I'll only integrate the selfdriving car code at the end I made this course to prepare for phase three understanding AI where we'll focus on neural networks and other AI techniques I hope that by the end of face three you'll understand why neural networks work why hidden layers are needed and things like that but for that we need this fancy world to generate complex scenarios the one we had earlier is too simple to teach you all that so if neural networks is what you're waiting for be patient and enjoy phase two meanwhile you learn a lot of things in this one as well a set of skills I really benefited from during my PhD and my time at Microsoft and I'm sure they'll be useful to you as well in your career we first learn about graphs and I'll show you how to implement the spatial graph from scratch I'll also show you how to make an editor for it as well it will have a dynamic viewport so we can pan and zoom to edit graphs of virtually any size when building this editor I'll explain the mathematics and logic behind good user interfaces in modern pieces of software and we Implement something similar ourselves then we use geometry to generate the road borders around the graph I'll teach you about polygons and some useful operations using them we'll apply the same techniques in a slightly different way to generate the buildings and the trees as well we spent two lessons on these because I want to show you how to implement this 3D look as well they're not really 3D models just a little bit of math that gives that illusion then we Implement a way to add markings to the road this will make phase three even more interesting because we'll need to teach the car to respect all kind of traffic roles as well now we'll focus on making this world editor a pleasure to use minimizing the number of clicks and maximizing the amount of autogenerated content but I'll also make videos on how to load real world data from open street map so the car can drive in your city as well this is yansu the card just passed by kelia University of applied science that's the Vila campus where I'm currently filming and it started off at tiar the other campus and now it's heading toward City Center where I've marked some it companies on the map looks like the car is heading towards Arbon out which is on the other side of town I'll add a link to this demo in the description check it out it's a good way to learn about yansu if you plan to come study with us you'll find many useful links there as well oh and I'll also make a video for creating this mini map it really helps when the world is big and the mini map was probably the most requested feature I got in phase one I've tried answering to all requests when making this but there's still a few I'm leaving for phase three they fit better there now to be clear this project is complex especially because we're going to code everything ourselves and not use libraries it won't be easy to wrap our minds around at all but I divided it into components lesson that I believe are easy to understand on their own I consider this course to be at an intermediate level but I do encourage beginners to give it a shot as well to get an idea of what a more complex project looks like I explain everything the best I can and if you have difficulties just ask in the comments or on my Discord the prerequisites are high school math and if you have trouble with that this playlist will have you covered you also need to know some JavaScript if you completed phase one you'll have no problems here but if you need to brush up on it I explained some tricky JavaScript syntax in these sketches so check them out if needed I hope you're excited and thanks for being patient this long can't believe it took me over a year to make this but I wanted to do it justice since you liked phase one so much now let's begin I'm going to code everything using visual studio code and we'll begin somewhere in an empty folder on your computer and let's create our first file here it's going to be index HTML and we begin with basic HTML we write the doc type here and the HTML page structure in the head I'm going to add a title and the title of this will be the world editor this will make it appear in the browser Tab and let's make it also visible by typing it inside of the body in an H1 tag like this now most of our functionality is going to be built on top of an HTML canvas element so let's add canvas element with ID my canvas onto the page as well now let's open this in our browser I'm going to be using Google Chrome and remember to open the developer tools as well it's really important to know if you make any mistakes the errors will pop up here now you can see here the title of the page is correct and the H1 tag is here but the canvas is not really visible it is there if you press this button right here you can find it on the page but it's transparent and we can see it so let's add some styles to this page I'm going to go here below the title and Link a CSS file like this called Styles CSS we're going to create this file here Styles CSS and for the bot I'm going to give it a black background color and I'm going to align everything to Center like this the H1 I'm going to give it a white color so that we can read it on the black background and set its font to harriel I think it looks better and finally the canvas I'm going to give it a back color that we can see on this black background and I'm just going to use this shade of green that I like let's save this and refresh and it now looks like this I'm going to make the canvas bigger and we're going to use JavaScript for that in index HTML we'll write JavaScript code here at the end of the body we begin with script tag and I'm going to set my canvas width to 600 and my canvas height also to 600 because it fits my screen well pretty much but you can choose other values if you want now we're going to be drawing on this canvas and for that we're going to need to access the 2D drawing context of this canvas like cell and we will draw a graph let's pretend that we have a way to define a graph like so and that the graph has a way to draw itself on a given context so we're going to need to implement these functionalities the graph itself and the draw method and we'll do that in a separate Javascript file I'm going to include it here we're going to place JavaScript files in a folder called JS but this is going to be a pretty big project so we need to think about code structure early on and I'm going to place the graph itself in a subfolder called math and then graph JS like so so let's create the Js folder first and inside of this JS folder we're going to create math another folder and inside of math we create our Javascript file graph. JS graphs are data structures made from a set of nodes also called vertices and a set of edges or links that represent relationships between the nodes like in a social network a graph can store which users are friends these relationships are bidirectional here but in other applications like here on YouTube I may be subscribed to you but you may not be subscribed to me there is very much to say about graphs like we already use graphs in Phase One when implementing the neural network there the links had weights so we were dealing with a weighted graph and there was a link between every input and every output so we used the Matrix to represent those relationships in memory but now we're going to implement a new type of graph called a geometric or spatial graph where nodes are not just abstract things they will represent Road intersections or places where the road geometry changes like this you can see there are not so many links here really so a matrix would be mostly empty and not the right choice in this case when implementing a spatial graph the proper way would be to separate the node metadata the points from the connections themselves but I think it makes things too complicated and since this whole project revolves around geometry I will simply say these are the points and they will be connected by segments with one point at each end so a bit unconventional here but I think it simplifies things in our case now let's code one of these graphs in JavaScript it's going to be a simple class and each Constructor is going to have two parameters we build a graph using points and segments I initialize them to empty arrays so that you can create an empty graph as well now let's store these parameters as attributes like so and in Implement our draw method that takes the canvas context as a parameter and I'm just going to Loop through all of the segments that we have and tell each of those segments to draw themselves on the canvas context we don't have these segment objects yet but they will be there and they will have the same kind of structure as the graph has it's important to be consistent with these things and then I'm going to do the same thing for the points like so and uh I draw the points after the segments because I don't want the segment lines to be on top of the points it doesn't look good now let's Implement these segment and point objects in index HTML I'm going to copy this line and I'm going to place these in a folder called Primitives points and segments are primitive objects so let's write here Primitives point and Primitives segment like this and inside of this JavaScript folder the main one here not inside of math I'm going to create a new folder called Primitives so it's next to the math folder here and in it we create a new file Point JS it's also going to be a very simple class Constructor takes in X and Y as parameters where we want the point to be and we set these paramet values as class attributes like so so that the object knows where it is pretty much and then in the draw method on the given context I'm also going to pass two more parameters to style these points a little bit the first one is going to be a size maybe 18 pixels and a color I'm just going to use black we're going to draw the points as circles and the circles need a radius I'm going to just calculate that as half of whatever this size is and we begin a path set the fill style to this color that we have in the parameter list and use the arc method of the drawing context and draw this at this X and this y we pass the radius next and the last two parameters specify that we want a full circle so starting at 0° and ending at 360° but we have to write this using radians that's just how the function works so 360° is 2 pi radians now we fill and we're done with this point for now let's do the same thing with the segment so create a new file called segment JS our segment class The Constructor will have points this time P1 and P2 let's save these as attributes of the class and Implement our draw method given a context and again I'm going to pass two parameters here as well the width the line withd how thick we want the segment to be I'm just going to give it a default value of two and a color again I will set it to Black like so and we begin a path we set the line width to the given width and we set the stroke style this time to the given color we move to the first point p1x P1 Y and now we're going to copy this line and line to P2 X P2 Y and then we stroke and we're done with these core functionalities the only thing left to do is test so make sure all your files are saved go back to index HTML and let's pass some actual points to this graph I'm going to go here above where we defined the graph and say P1 is a new point at 200 200 pixels let's copy this few more times and have here P2 P3 and P4 maybe P2 is going to be at 500 200 then 400 400 and 100 300 and let's pass these as an array to our graph here as well this will be the points parameter of the graph and the segments will be the second parameter but we can actually test now already so save the file refresh the page and there's our graph it has the four different points this is the 200200 this is the 500 200 uh keep in mind that 0 0 is this top left corner so 5 100 200 like so let's add segments as well I'm going to go here and say S1 is a new segment between P1 and P2 and let's copy this two more times maybe S2 and S3 between let's just link P1 for now P1 with P3 and P1 with P4 and pass these as the second attribute here save and refresh and we can see now the segments as well let's connect these to as well so I'm going to copy this as S4 between P2 and P3 and passing s for here like so good now this is a static structure we can't really edit it in any way and the next thing we'll do is add some functionality to add points remove points add segments remove segments and so on we'll do that in a very basic Way by adding here buttons that just add some of those elements on the screen I want to teach it like this because it's how interfaces were made 30 years ago and then we're going to make it modern I want you to see how things have changed since then so let's go up here and below our canvas element I'm going to define a div with an idea of controls and this is going to contain some buttons that we can press to do operations with our graph the first first button on click it will call a function called add random Point let's call this button add Point like this give it the label and let's implement this add random Point function next I'm going to just make it here on top of this script these functions will go away at some point we just need them to develop the core functionality so I'm not going to worry about the code structure too much and add random point it's going to tell the graph to add a point the graph object will have this functionality so let's pass here as the point a new point and give it random coordinates so X is going to be random and I'm going to scale this by the width of the canvas so that the value is not between zero and one what this gives but between 0 and 600 pixels and the height in the same way now to see this point after it was added we have to refresh the canvas we do that by clearing the whole canvas starting get 0 0 top left corner and with height bottom right corner and then we tell the graph to draw itself again so graph draw on the context so let's implement this ad Point function real quick we are going to go to graph JS and here below the Constructor we say add point a given point and we just take the points attribute of the class and push the given point like so now let's refresh and when we press this button you can see a new point was added there you can try pressing it multiple times and it's going to work pretty much always unless we run out of memory but uh that's not going to happen anytime soon now there is one situation that I want to take care of I don't want to have two points at the same location it makes no sense points are identified by X and Y and if you have two of them with the same X and Y then that's the same point so let's see how we do that we're going to need a function that checks if the graph already contains a point right and I'm going to write it like so using the array find method which finds inside of these points a point that equals the given point like so what happens here is that the find Loops through all of the points here and let's call them p and then Returns the one that equals point and if it doesn't find that point then it's going to return nothing so something and nothing will also correspond to true and false in Boolean logic and we're going to use this as such it's just how JavaScript works so equals here here we need to implement as a method to the point class we need to check if p is equal to the point somehow so inside of the point class I'm going to implement equals point and return if this x is equal to point x and this Y is equal to point Y like so this will only be true if point and this are the same and now we could go here and check to see if the graph contains the point before adding it or we could add the new method to the graph that tries to add a point and then maybe we monitor here the success did it succeed to add a point or not let's log this in the console right here so we can go inside of graph JS here and try add point is going to check if this point is not part of the graph at the moment then we add the point and notice here how I'm reusing the method we defined earlier then we also return true it was a success otherwise we return false like this let's save a refresh and when we press this add Point same thing as before happens pretty much but we always get here this true and that's because it's really unlikely to randomly generate another point on top of an existing one but to test we should force that to happen somehow so I'm going to go here in index HTML copy this entire function here paste it here in the console and instead of having random I'm going to write 0.5 and 0.5 this means that I'm going to overwrite this function so that it generates the points always in the middle of the screen so if we press multiple times on that button the same point will come again and again to overwrite we have to press enter now and let's press this point again once and this is the point in the middle of the screen and when we try adding another one we get our false as well so it wasn't a success and the number of points in our graph graph points 18 doesn't change now we have a way to add points to our graph let's add segments as well we're going going to go here and copy this button and call the other one add segment and the function will be add random segment and we Define that function here at random segment this will work a little bit differently it first gets the points that we want to connect and then creates the segment let's get these points again at random by using floor of random times the number of points floor makes sure that we have an integer value and let's copy this for another index two different points and then tell the graph to add the segment a new segment between the points at index one and points at the index to like this now to see any changes after we press this button we also need this thing right here clearing and redrawing the graph so let's save this and go to graph JS to implement this add segment method we go here below the points section and let's Implement add segment let's call it seg and it's going to take the segments of the graph and push this new one at the end let's save this refresh and now when we press add segment it added a segment here and now I pressed again and nothing happened let's try again nothing nothing nothing what's wrong can you figure out what the problem is pause the video now and try to figure out the answer for you yourself or just listen to me carry on the issue is that here where we are adding these segments sometimes index one and index two could be the same so we create a segment from one point to itself we could check here and say success is false and then if index one is different than index two success is true let's also add the segment only in that case because a segment from one point and to itself doesn't really make sense and let's log this success here as well refresh and when we press add segment we get a true and we see the segment when it appears but sometimes we get the false when we try to link the same point to itself and if we press more times oh we got the true now but I didn't see any change what happened try to figure out what happened pause the video and now I'm going to tell you the answer so turns out it's possible that you add the same segment multiple times as well like maybe now this segment was just added again let's actually see here in the console the segments and the last segment between 200 200 and 100 300 I think that's this one here yeah and you can see they're exactly the same let's try adding few more segments even though they are going to be copies of themselves and now we see here 18 segments but we can really only count 1 2 3 4 5 six so it doesn't make sense to have more than six segments here we wouldn't be able to see them and we wouldn't be able to tell that there are duplicates there this last one actually is the same that we had previously but in Reverse P1 is P2 and vice versa we're going to need to handle that case as well so let's go back here and convert this into a Triad segment as well and move that to the success and have the same kind of structure as here pretty much let's go to the graph and implement this method try add segment and it's going to be very similar to the try add point but we first check if this contains the segment and if it doesn't then and we add segment and return true and here we return false like so this contain segment is going to be here and what we do is again use defined method on the segments this time I'm going to Loop through them using this s and find the one that equals the given segment like so we're going to need to implement equals functionality for the segment as well so here equals is going to be return P1 equals seg do P1 and P2 equals seg do P2 but we also want the opposite check if the points are flipped so we're going to do or P1 equals seg P2 and P2 equal seg P1 now if we we refresh and add a few segments we can see there false appearing many times eventually one of them will work okay so now we have all six of them here and when we go in the console and type graph segments they are indeed six so it works but before we move on this line of code is quite complicated here checking so many things and it's always good to try to simplify two segments are the same if they include the same points so we could make a helper method here called include point and return this P1 equals point or this P2 equals point so now we have a way to check if the segment includes a point and two segments are equal if this includes P1 and this includes P2 it makes sense and if you save and refresh it still works but it's nicer to read in this way and you'll see that later we'll need this includes for other reasons as well now this part here where we check to see if the indices are different we could incorporate it part of the Triad segment so try to see if the points are equal and if they are it won't add the segment so we could actually have success here defined as so and we don't need to use let here we can use const again so try add segment now is going to not only check if it doesn't contain the segment but also if P1 is not equal B2 let's save refresh and try adding segments again and we still have six here great now let's go to index HTML and have a way to remove these segments also I'm going to copy this and say here remove a segment at random and remove segment like this and the function for removing is going to be like this I'm going to first check to see if there are any segments so if graph segments length is zero you can also have a methods added to the graph that check if it has segments or Returns the point count if if you want to do a really really proper job but this is Javascript then I don't bother too much so here I'm going to log no segments just as a warning that no bother trying to remove something there's nothing to remove and return and otherwise we are here where we get a random index from the segments this time and remove segment the one at that index like so we also need to copy this code here otherwise we won't see the change after it happens and now let's implement this remove segment I'm going to go here and say remove segment splice so splice removes elements at the given index here we get the index of this segment and I want to remove just one element the segment itself now you can add many other methods here maybe removing the segment by the index we already had the index here to begin with or try to remove a segment similar as those other ones but they won't be needed in our project and I'm not going to over engineer this refresh and remove segment okay okay okay okay all good and if we try one more time no segments written in the console great let's remove the points as well for that I'm going to add another button here remove random Point remove point and let's copy this remove random segment like this and have here remove random point if graph points are empty no points index is going to come from the points this time remove point graph points and let's implement the function remove point in the graph file let's copy this remove segment and put it here in the points section and rename it to remove point the given point and it's going to look inside of the points array and supplies the points index of point would have been faster to just rewrite this but I wanted to show you how similar these functions are now let's save this refresh and when we remove a point we can see it's gone but I'm removing all the points and and now we also get that message there but the segments are still there and that makes no sense how can you have segments between points if there are points so let's make it so that when we remove a point it also removes all the segments that contain this point so the New Logic will be here let's first get some segments with point the given point and then for each segment of this small list we remove the segment like so using the method that we have defined earlier so we need to implement this get segments with point and I'm going to do that here in the segments section get segments with point we we start off with an empty array and now look through all the segments of this graph if the segment includes this point then we add it to this array and at the end here we just return the array of segments that contain this point simple enough let's refresh and remove point and you can see that the segments connected to it are also gone let's try adding some points adding some random segments question for you given a number of points how many segments can there be between them like in this case we have 17 points how many segments can there be here let me know in the comments and now we can also try removing some segments removing some points good everything seems to work but one more useful button to have here would be to clear everything to remove everything I'm going to implement the method for that here it's really easy let's say this will be dispose of the graph and I'm just going to set the points and the segments to empty setting the length attribute like this doesn't generate new objects for them so it reuses the same array object and in index HTML let's copy this and say remove remove all remove all and the remove all function call graph dispose and we need to copy this again if we want to see the update refresh and it works now you could build an interface like this maybe when adding point it wouldn't just be a random point but have there some inputs for the X and the Y adding the segment maybe it can have a drop down for the first point and the second Point removing again a drop down with all the segments and all the points and that interface would work but it would have so many clicks and so much use of the keyboard that nobody would use it nowadays I will teach you how to make a modern interface so we won't need these buttons here let's remove them actually I will keep the control section here because we might use it later but no need for these functions at all all that was important was to have here all these useful methods inside of the graph Class A good user interface is one that minimizes the number of clicks and keyboard input I'll teach you how to build a graph editor that does that now in other courses I've considered mobile as well but in this series I'll focus on the mouse because I think it's the best tool when creating graphs it has two easy to press buttons we can use for adding dragging and removing points we'll implement the editor step by step adding new features when needed and polishing existing ones until we're happy with the final logic at least I'll be happy with it but if you're not I hope you'll get the skills to edit things in or out just the way you want we will Define our graph editor here after we have the graph and we initialize it like so new graph editor passing the canvas it's going to need that for event listeners and the graph and it's going to also be doing all the drawing on the canvas so actually we don't need this call anymore it's going to be handled by the graph editor and the editor is going to be very interactive it's going to change all the time depending on our Mouse moves and the simple way to implement this is using an animation Loop so a function that we call here and start to animate and it's going to be really simple all it does is it clears the canvas because it's going to redraw again and again so clearing starting at 0 0 and all the way to the canvas width and canvas height and then we'll have our graph editor display itself it knows where the canvas is because it has it here as a parameter and finally we call Quest animation frame and pass this animate call again and again and again it's going to be kind of a recursive call where the browser will try to recall this function 60 times per second so we're ready to implement this graph editor and we'll do that in a new file I'm just going to Define it here in the main JavaScript folder so it's going to be called graph editor and injs create a new file graph editor JS the class is a simple class and the Constructor will get the canvas and the graph as parameters now let's set these values as attributes so that the editor doesn't forget them and let's have a reference to the canvas drawing context as well defined here as a class attribute so that we have easy access to it like so and the display method for now let's just have it draw the graph on this context save the file refresh the page and it looks pretty much the same as before but now if you go to the console and you type for example p1.x is equal to 400 and press enter you're going to see immediately that point jump to a new position because it is rendering again and again and again all the time you just don't see it so we are ready to start adding event listeners for the mouse action I'm going to create a private function private method for this here so it starts with the hashtag and then add event listeners and this method is going to be here below the Constructor the first event listener we add to our canvas is going to be for Mouse down and we get the information from this event and write the arrow function so this Arrow function let's close it here and now implement the body the first thing we'll do is get the mouse location from the mouse down event from The Click so Mouse is going to be a new point and the information is inside of this EVT do offset X and EVT offset y are the XY location of the click now with this point we can just tell the graph to add the point and the code should work so let's refresh and click somewhere and there you go points added anywhere we want them so it's an improvement over the randomness we had previously now one thing that we'll really need in this editor is the ability to select a point and let's Implement that so that the last point that we add is also selected we'll have a more complex Logic for the selection later but now it's just like that to test so I'm passing here this selected is equal to the mouse and this selected will be attribute of the class initially null it can be null if we don't select anything and then in the display here let's draw it separately in a different way so if we do have a selected point I'm going to tell this point to draw itself under the context but this is just going to draw it on top of itself already it's already there from this graph draw so I want to specify a little bit different properties for this selected point and let's give it an outline we don't have this functionality yet so let's save this go to our Point primitive here and in the draw method add an outline here now the more parameters you add here the more difficult is going to be to remember their order so I like to group these as an object like this and now you could pass them in any order you want you just need to specify these properties the name of these properties here like what we just did so if you want to pass this without these options we write here equal to an empty object and then you can just called Draw as we did before in the graph now this outline I'm just going to go here below and if we do have an outline We Begin another path set the line width of two for example and let's give it a stroke style of yellow and draw a new arc at X and Y but our radius will be a little bit smaller I don't want it to be exactly the outline I want it to be kind of inward I like the look of that so let's say radius time 0.6 and again 0 2 pi for drawing a complete circle and again if you want this selected point to look different just make it different it's your code now now let's save this refresh and now when we click somewhere we're also going to have that point that we just added selected and this is how it looks like and the next thing we do in our logic is when we click on a point that is already existing I don't want to create a new point on it or close to it so I actually want to select that point and at the moment this doesn't happen it just creates a new point on top of it pretty much so let's see how we do that we first have to figure out what point are we hovering over so going back to our graph editor in this mouse down event listener after we have our Mouse location we get the hovered Point by looking at the nearest Point so we're going to need the function get nearest point from the mouse from all the graph points like this and then if this hovered Point exists we are going to select it like so and now I'm going to return so the code doesn't go here anymore for adding a new point and selecting it it just select let's define hover also in the Constructor here same as selected hovert initially null and what we need to do is implement this get nearest Point somewhere and what I like to do is create a new file and Link it here in index HTML it's going to be also part of math and we will call this new file utils JS this will have utility functions mostly math functions that will help us during our project so in math create a new file called utils JS and the function for getting the nearest point to a location from a set of points point is going to be a basic minimum search so we look for the minimum distance from our location to all the points and select the point with the minimum distance we do that by initializing this minimum distance to a very large value like this and the nearest Point let's just have it null in the beginning and then we Loop through all the points in the array like this and calculate the distance between that point and the location that we have here as a parameter if this distance was found to be less than our supposed minimum distance then minimum distance becomes distance and we record the point with this minimum distance as well in this nearest attribute then we go here at the bottom and just return nearest and what we still need to do is implement this distance function between two points and this is really easy we've done it countless times I have a special video about it it uses the Pythagorean theorem and we just return the Hot between the difference on X and the refence on y between these two points let's refresh and now when we click you see it selects a point it always selects the nearest point when we click somewhere but we can click anywhere really and maybe we would like to have a limit so that we are close to that point to actually select it because at the moment we can't add new points anymore we're always is just selecting so what we'll do is when we look for the nearest point we'll check also if the point is under a threshold so this third parameter threshold let's have it 10 I like to have it just a little bit bigger than the points so that you can click almost there and it's still going to work and then here our if is going to check and the distance is less than the threshold then it does everything let's save refresh and now when we click here it adds new points but when we are close to something it selects that point and you can still get nearby points if you are outside of that threshold but if you're close enough you actually select it play around with this and let me know what you think what should the proper threshold be now our get nearest Point function here should have this threshold as an optional value really because the name implies it's going to find the nearest no matter what so the threshold here I'm going to Define it to be this very large value that we can use and then in graph editor when we get the nearest point I'm going to pass here 10 like so now refresh the page and the code will work as before pretty much what would be really nice is to know if I'm going to click here will this add a new point or will it select the other one are we inside of the threshold or not and we should know this before doing it otherwise we get surprised by what happens so visualizing the intent is important I think and that's that's what we're going to do next we are going to need to define a new event listener for Mouse move this time so Mouse move and on every Mouse move we are just going to take this hovered Point like so and here in the display we will visualize this hovered Point as well in another way let's copy these lines and say if hovered draw the hovered one as well and this one let's emphasize it with the F this time so F set to true and inside of the point we pass now this fill as well by default it's false and at the end here I'm going to check if we do want this point to have a special kind of fill We Begin The Path and we draw a new arc again at The X and Y and the radius I'm going to have it smaller this time full circle and let's remember also a fill style I'm going to set it to yellow and instead of stroke I'm going to call fill let's save this and refresh and now when you move the mouse over the point you're going to see the highlighted point so you know if you see that that once you click it's going to select it and if you're close but you don't see that and you're going to click it's going to create the new point so the interface is not surprising anymore it's much more useful for the user I don't like this point I think it's too close to that one so I would like to remove it somehow and I'm going to implement removing of points by right clicking on the points we go to our graph editor in our Mouse down here and actually we don't need this hovered anymore because it's already happening here on Mouse move so we could remove it entirely and nothing will change everything will still work and to implement the right click we're going to go here at the top and check if we press the right click or not that information is also part of the event and we do if event button is two this means right click and I write here a comment because I always forget which is which then if if this hovered I'm going to say graph remove point this hovered like so and the logic from here is if we have pressed zero which is left click now you maybe know why I'm confused about these numbers sometimes let's save refresh and now when we right click something happened you actually don't see this but I have this menu appearing on the canvas and let's get rid of that so to get rid of this rightclick menu I'm going to add here another event listener for context menu and the function I'm going to pass is going to call prevent default this is just going to prevent that menu from coming up now let's test again clicking on the same point it removed the segments connected to that point but not the point oh also the point but for some reason the point is still visible until I move my mouse away from it and that's because when we remove the point here from the graph we still have selected and hovered there you could do here a more complex code or you could reactor this saying this hashtag remove point and now go somewhere here below and Implement a private method for remove point that calls the same thing we had before the method we implemented for the graph also sets hovered to n and selected to know to get the proper interface let's refresh and now when I remove it really goes away and no weird artifacts coming now if you test this and for example remove this point you see it also unselected that point any point that is selected will be unselected because we just said this should be null but maybe we want that point to stay selected not make the user have to work again if they want to select it again for some reason so we can easily check for that here and say that if this selected is that point then we Mark selected as null we don't have a selected Point anymore because we removed the one that was selected refresh remove that and it's still selected but if we remove this one then it goes away and no weird artifacts are there okay great does this work in all possible situations well one thing that you'll notice is if you add a point here and right click on it now it doesn't remove it it doesn't go away even after I move the mouse and that's because we're removing points that we hover over our hover is updated here on Mouse move but when we add a new point it's not yet assigned to that point even though our Mouse is hovering over it so we could do that here like so and now creating a point and right clicking on it will indeed remove that point as well small things like this are what makes a interface not just good but really good and people will choose you over somebody else making one now correcting points is possible already if we want this point to be a little bit more to the right we just remove it and recreate it a little bit more to the right but dragging would make this much easier to work with so let's add drag functionality next and in Mouse down when we hover over some something here on left click I want to also enable dragging for that point so let's say this dragging is true and this is going to be another attribute here false by default and as we move if we are dragging the selected point X and Y are going to come from our Mouse location like this now we also want to release of the points somehow and I'm going to do that with another event listener here let's just copy the context menu and this will be for Mouse up like this and what we do in it is this dragging is false and we don't really use this event here so we can remove it now refresh and if I'm going to click and drag this works so I can add points I can drag points and it works just as expected so far we've figured out the points and it's time to move on to the segments as well create new segments and when building roads a very common thing what you have to do is generate the shape of the road like this and you really get a lot of help if the interface is going to generate a new segment between the current point and this new point that you're going to add at each time so let's do that we are going to go to this Mouse down event listener and here when adding a new point just before settings selected to that point we're going to use the previous value of selected if it exists and add a segment between that and the mouse location so I'm going to do this if there is a selected let's try to add the segment new segment selected at The Mouse and the reason why I have Trad segment here is so that I handle things like clicking on the same point multiple times or clicking between the points multiple times which would otherwise add a lot of segments that are overlapping or invisible or something like that now let's save refresh and if I start to click you can see those segments added there just fine but maybe I would also like to add the segment between things that exist already like these ones so let's copy this code also here when just selecting points so before this selected is set to what is hovered we try to add a new segment between this selected and this hovered this time let's save refresh and now I'm going to select this and this seems to work now if I'm going to continue like this at some point I have a problem because maybe I want to connect these two points next and clicking this point or this point is going to add a new segment here something I don't want and the reason for that is I have no way of unselecting points at the moment so if we would unselect points we would unselect this one before clicking on this one and then this weird segment wouldn't happen here so maybe we go up here when we right click and if we are not hovering over anything we do an else this selected is no okay and now I'm just going to try to recreate a little bit that click somewhere else with the right click and now I can click on this point and then this point and get the segment that I want now the code that we have here is pretty much the same this part and this part is identical I'm going to implement a method for selecting a point so this is going to be here a private method select point and in it I'm going to copy one of these and pass this point properly so instead of mouse point point and now up here this duplicate from here we just remove and say this select this hovered and here we say this select Mouse and everything should work the same as before selecting points and selecting points connecting them everything pretty much one thing that we did before for the points this intent showing what happens when you click somewhere would be really useful for the segments as well like now we have this point selected and if we would click here with the left click it will connect them but maybe we forget or maybe the user is new and doesn't want that connection to happen but he does it anyway then this is going to be annoying because what the user has to do now to undo everything is pretty much remove this point and now recreate oh no it selected that one because it was already selected remove this point click it here and connected to that so maybe the user just wanted to select this like so without having anything else selected but if they don't see the intent that having this point here selected is going to create a new segment here then they don't know that they may be surprised by what happens and then a lot of work is needed so I will show this intent of creating a new segment somehow for that we need access to where the mouse is in the drawing section here so I'm going to take the mouse from Mouse move here and make it as an attribute of the class so this mouse is going to be that and I'm going to put this dot in front of everywhere we use Mouse pretty much and actually the mouse that we C calculate here as well it's not needed because we move the mouse before pressing it so we're always going to have it more or less and here this mouse this mouse this mouse I think this is all of them and let's define it here at the top and set it to n like this and with this mouse we can go in the display here before drawing this selected note and let's say we create a new segment from this selected to this mouse and draw it using the context save and refresh and now when we have a point selected you can see this line creeping out so it does tell us that something is going to happen there when you click here it's going to create the segment on that line and when you're going to click here I would actually like this line to snap to that point when I see that point hovered I also want this line to appear there as well so let's do that we will get our intent is the hovered if the hovered exists otherwise the mouse and now we pass here this intent instead of the mouse refresh and now you can see that intent jumping there but this segment that we are drawing here as the intent looks too much like the other ones so let's make it look like a dashed line I'm going to pass here also Dash options three and three and an array this means three pixels of line and three pixels of space and save this and we have to modify our segment primitive to know to show this as well and this starts to have again many parameters so I'm going to group them as an object as we did before so Dash by default it's going to be empty and we do this so that we can just draw the segments without passing any of these parameters now the dash here we set line Dash to the given Dash and after we do the stroke here at the end I like to copy this and reset the dash so it doesn't affect all following drawings many people like to use here uh context save and restore at the end so that everything gets reset but I find it a little bit slower on my computer now let's test and we can see that situation from before so anybody using this would know that clicking here would create that but if they right click and now click there it selects the thing with without any surprise happening so if we test this a little bit more aha did you spot that let's make what we had before here I wanted to actually select the point that I'm hovering and for that I did a right click but right click didn't unselect this one it it actually removed that point so the priorities are different here I would like to unselect first and then delete deleting is more troubling if you do the wrong thing than having a point unselected so going back to this graph editor I'm going to redo the logic here for right click let's remove it if it's selected we unselected else if we are hovering over something we remove the point that is hovered like that save and refresh yeah and now I can select this one even if I'm right clicking over something it doesn't remove it okay test it out let me know what do you think is this a good interface do you want to make it better how do you make it better what is wrong with it write in the comments and let's see if we can get an even better one to work now before moving on to something else I do want to mention a little bit about code cleanup here so this ad event listeners function is kind of long it doesn't fit on one page that's kind of the rule make it fit on one page so that scrolling is not needed when looking up logic so these event listeners for Mouse down Mouse move could be extracted as their own methods I'm going to cut everything here inside of the mouse down event listener call back and create here handle Mouse down private method for this and paste inside it the previous code now here instead of having this Anonymous function we just say handle Mouse down and if we save and refresh and click it doesn't work there's an error here and if we press here we can see where this error happens let's put a break point and click again and inspect this you can see this here is the canvas it basically points to the canvas but we don't want that I I mean the canvas doesn't have a graph the graph editor has a graph and when you exit this scope where this referred to the graph editor now this inside of this function refers to the Target of this event to the graph so we need to tell this function that this should be this and the way to do that in JavaScript is with bind bind this and in this way it will send this this to this function and it's going to work again save refresh and click and now when we hover this it's the graph editor again so removing the break point pressing display the point actually appears there and everything still works we do the same thing also for this mouse move so I'm just going to cut this and Implement handle Mouse move for the event paste this here and here let's just say this handle Mouse move bind this save refresh and everything still works this graph editor is nice but I'd like to make larger graphs as well and my screen size is not that big so I'll teach you how to make a viewport that can be zoomed and panned around to allow editing outside the initial region as well it's going to be like in Photoshop where you can draw like that then we can really make anything we want and it would be a shame to lose a large graph like that so I'll teach you how to save it so it doesn't disappear when we refresh the page now let's begin and get the bird's ey view of the graph we'll initialize the viewport here before the graph editor like so giving it the canvas to work with I will also implement this in a separate file next to this graph editor here also in the JS directory so let's go to JS and viewport JS this is also a class and the Constructor takes the canvas as a parameter let's store it as an attribute like so and let's get a reference to the to the drawing context here as well now the first thing we'll Implement is the zoom and let's have an attribute for this by default it's set to one and add event listeners to change the zoom very similar structure to what we did previous lay in the graph editor but here we'll use different things we're going to listen for the mouse wheel the wheel is going to change the zoom so let's add an event listener to the canvas for the mouse wheel and have a separate callback function called handle Mouse wheel and we bind it to this so that it knows what this is and let's define this handle Mouse wheel with an event here below and let's log this event Delta y property and see what it looks like in the console save refresh and now when you scroll upward you can see minus 125 appears on my computer and downwards 125 we're only interested in that sign plus or minus so I'm going to go back here and say the direction in which we are going to change our Zoom is going to be coming from this sign like this and let's update our Zoom with with this direction so s function from the math library is either 1 or minus one depending on if the value is positive or negative and let's log here this Zoom save refresh and now when you scroll up you're going to get lower and lower values when you scroll down you're going to get higher and higher values and I'm really only interested in this range from one to something maybe one to five I think that's going to be a good range to work with so we will disregard zero and negative numbers and positive ones and we want the zoom to change slower than this so not just by one increment each time so what we'll do here is I'm going to define a step how much much do we want the zoom to change in that direction maybe 0.1 and then here the direction we can multiply it by that step we can also cap the zoom in a specific interval by writing Zoom is the maximum between one and the minimum between five and the actual Zoom value it's a oneliner that keeps it between 1 and five so let's save refresh and see if it works so scrolling up keeps it at one and going down goes down until five so scrolling down is going to zoom out five times basically if that makes sense you could keep these as attributes like mean Zoom Max Zoom whatever I'm just going to keep it like this because usually you don't change these once you implement it and it works the way you want so let's remove now this console log from here save this file again and inside index HTML change the canvas properties based on this viewport information I'm going to go here after clearing the rectangle and save the state and then do a scale with the inverse of this viewport Zoom like this because I want to zoom out basically and then here restore this save and restore are important because this scale is going to be called on each frame so if we don't do anything about it it's just going to scale again and again and again and again on top of each other making some weird effect to happen let's save this refresh and now when we zoom out so I'm doing this yeah this seems to work just fine but um if you click somewhere like here you're going to see that the point doesn't come where it should come and uh we need to fix that the way we get the mouse should take into consideration the zoom as well so I'm going to go to viewport and give it away to get the mouse information it knows what its Zoom is so get mouse given this event information we return a new Point typically we had this offset X and Y but now we're going to multiply it by the zoom and that's going to fix the problem and we need to call this get mouse in the the graph editor where we need the mouse information the mouse location so the graph editor needs to know about this viewport not about the canvas I'm going to change the way that we initialize it here with the viewport and that means we have to go in graph editor JS in the Constructor here change this to be a viewport viewport viewport and the canvas which we do need is going to come from the viewport like that now here where we get this mouse information we just take it from this viewport get mouse using this event information refresh and now zoom out a bit and when we click it works as expected one thing that we should fix at this point is when you zoom out a lot like that it becomes really difficult to click on the points here you have to be very very close so this threshold here of 10 gets shrunk because of this zoom out F so you want an Adaptive threshold basically and you can fix that by multiplying here with the zoom as well what happens now when we refresh and zoom out a bit you can see that point starts to be hovered when we are closer than 10 pixels away from it but we're not really hovering it we just get close to it the same distance that we had previously making it much easier to interact with those points but maybe we don't want this maybe we do want to um have zoomed in view like this when editing to be more precise and now just drag to go to that part of the space where the points are and we're going to implement drag also using the mouse wheel but we're going to click on it and drag by holding the mouse wheel so this middle button will control the offset of the viewport let's define this offset at the top and by default it's going to be Z 0 and we're going to need also a way to store the drag information we're going to be dragging the viewport and we need to know where we started where we ended and compute some kind of differences and add them into the offset like so and I'm also going to add here a way to know if we are actively dragging or not then this event listener for Mouse wheel we're going to copy it three more times so that we have one for Mouse down handle Mouse down Mouse move handle Mouse move and mouse up handle Mouse up and we Define these below here as well so handle Mouse down given the event it's going to first check is it the middle Mouse button that we are pressing is it this one not these other two because then it would interfere with the graph editor so if event button is one this is the middle button then we set the start of the drag to this get mouse EVT this get mouse will have the correct information no matter what the zoom level is then we also say that the drag has started has been activated now on Mouse move we will only do something if this drag is active and we will calculate the end location of the current action so the current Mouse location pretty much and I'm going to to write this in this end attribute here this get mouse EVT so start and end are different after the drag has started and you continue to move the mouse and from start to end that gives you the offset of your current drag and I'm going to store that offset here you just calculate the difference and this is going to use vectors the difference between the drag end and the drag start so this Vector essentially you can imagine it starting at drag start and ending at drag end it tells you how much the offset will change when you release the mouse which is the next thing that we'll do the mouse up event handler if we are inside of an active drag again we add to the existing offset the drag offset and we also reset the drag information here so what we have here at the top this drag is equal to that I'm just going to past it here like so and we need to implement these simple Vector operations here so math utils I'm going to go here below this distance and say add P1 and P2 return new point where we just add the X and add the Y and for subtract I'm just going to copy that subtract and put here minus minus and everything's going to work but we still need to use this offset somewhere so here in index HTML after we scale we are going to also translate viewport offset X viewport offset y save the file refresh the page and now I'm going to press the middle Mouse button move it here and release the middle Mouse button and when I do that the drag has happened but of course you would like to see the drag as it's happening so you want to get the cumulative offset of the current drag action and the stored offset information this works otherwise I'm now going to drag everything back and like this and like that and some interfaces do work like this they don't show the current action to keep the processor usage low but nowadays pretty much everybody expects to see what is really happening at a glance so I'm going to take this offset including the drag and I'm going to have the viewport computed for me so get offset will add viewport offset and the viewport drag offset together and here we just keep this so going to viewport JS below get mouse we will also have get offset which adds this offset the this drag offset like this now save this refresh and as I'm dragging you can see the motion like this and you can feel it a little bit lagging here and that's because our animation Loop here reenders itself pretty much 60 frames per second but your mouse movement is a little bit faster than that so you can see the location of the points dragging a bit and you could get a faster interface update if you link this rendering to the mouse move event but I prefer to use this animation Loop here because at the end there will be things in this world that animate like the car movement and and whatever so this structure here is more in line with what we did in phase one of of the course now zooming out here bothers me a little bit because I'm very used for the zooming to happen from the center somehow not the top left corner so if my object is here and I'm going to zoom in now I expect to keep it in frame and it doesn't happen so we need to consider where the center of the viewport is as well I'm going to go to viewport JS at the top and above this offset let's get a reference to the center point of the canvas so half the canvas width and half the canvas height and now in index HTML before we do the scale so the original width and height of the canvas is going to be what it is and not affected by the scale we translate to this Center at first save and refresh and you'll see that things have moved that way by half the canvas width and half the canvas height so this point here is now 0 0 if we drag everything in the middle though and zoom out and in like this we do get what we want so what we need to do is this initial offset that we have in the beginning it should be directed that way by how much this Center is offset so we're going to go to viewport JS here and our offset here is actually going to be equal to scale this Center by minus one so basically it's going to be a point with minus canvas width / two and minus canvas height divided by two but now I have an opportunity to implement this scale function for vectors here in utils it's a little bit different than add and subtract because it takes the point as a parameter and the second parameter is a scaler it's a simple number it's not a point with X and Y and what we do with it is just multiply both P of X and P of Y like this save and refresh and now the initial view is correct zooming out and zooming in is as expected but clicking is not so now we have to consider also the offset when we calculate the mouse location in the viewport here we do that by subtracting here this offset X and here this offset y and here we also have to consider that Center information as well so I'm going to put in parenthesis minus Center this is before stretching it with the with the zoom and the same happens here with the center y like that save and refresh and now let's zoom and move somewhere and when when we click everything seems to work and you can now edit these points by zooming in and working on different parts of the screen H but now this intent doesn't show well you can see how while I'm dragging here something strange happens to this intent to this line it's fine when I'm not dragging it's always at the mouse location but if I start here and move to the right a little bit it seems to go to the right even more and same happens like this the mouse is always in the middle of the starting point where we began the dragging here and whatever the current tip of that dotted line is there so what we want to do is actually subtra ract the drag offset in this case and I'm going to go to graph editor here where we get the mouse and say that yes we want the mouse by subtracting the drag offet so this get mouse needs an update here where we subtract that drag offset so this is going to be false by default we like this functionality all the time except while we are doing the drag there so here instead of return we are going to say Point p is the new point and what we return is depending on this second parameter if it's true then we do subtract from P this drag offset otherwise it's just p as before save this refresh and now if we select something and drag we can see that it's always still pointing at the mouse apart from that small delay caused by the animation tuop yeah this is quite good but what we really need to take care of is here this animate function is really getting complicated and all of this kind of functionality should be really taken care of um by the viewport the problem is we have this graph editor display wrapped between the restore and everything else and one way to solve this problem is actually move it at the dop so the restore happens before the save and if you think about it it does make sense so now all this code from here before this is going to be cut I'm going to cut it and it's still there it's in my clipboard so don't lose it and we're going to just call viewport reset so we reset the viewport and then we display now this reset functionality I'm going to implement it here and say reset let's just paste everything and CTX will not be recognized so we have to say this dot CTX pretty much everywhere where we see CTX and my canvas it is a global variable but we have our own local one that we can use like this and viewport here it's just this so this this this this and this save refresh and now everything should still work as before but the code is much cleaner and now you are free to make any size graph you want and um might be useful to have a way to save this and this is not really a great graph here so maybe also removing it a button that deletes everything so let's have two buttons here for the save and for removing everything otherwise you'd have to right click click a lot and you don't want to do that in these kind of situations we're going to go to index HTML where our controls were in the very beginning and let's define a button it will dispose of the graph and I'm going to copy this the other one will be save and these buttons will stay there in the end so I'm going to style them a little bit better I'm going to use emojis and this is just a trash can emoji and this one here it's going to be the save Emoji so this dispose function let's implement it here below dispose and it's going to tell the graphic Editor to dispose itself and the reason I do this is that here inside of the graph editor now Above This display it's going to have another public method called dispose and in it we tell the graph to dispose but we also want to reset hover then select it so I'm going to say selected is null and hovered is null like that that's it for this pose so let's go back to index HTML and also handle the save function this one is just going to store the current version of the graph in local storage so local storage set item the graph and I will use Json stringify to convert the graph into a string because local storage only works with strings let's save refresh and let's try dispose seems to work and let's create a new graph here maybe just going to say hi and save it now when we save it we should be able to see it here inside of local storage get item graph like this we see the points and the and the segments just fine but when we refresh the old one comes again the one with the hardcoded values even though the one we stored is still there so we just need to load this information inside of the graph instead of the hardcoded values I'm going to go back here and let's remove these hardcoded things from here leave this as an empty graph for now and what we do is we check to see is there this string information inside of the local storage and if there is we get the info object containing the points and the segments by parsing it using Json parse or it's null if the local storage doesn't contain the graph and now here the graph will either be what is in graph info or this one if graph info is null so let's say graph info and if it exists we have have a new graph with the points and the segments from graph info so we load that original graph that is stored in local storage save and refresh it doesn't work the problem is the things that we have in local storage here are just objects called points and segments but they are not really points and segments in the same way that we expect them to be they don't have for example a draw method this is all they have so we need to convert this information into points and segment objects I'm going to do that by using um static method called load that we're going to add to the graph given some information it's going to create a graph for us so in graph JS below the Constructor let's define it here static load info so we call this function with capital graph as you seen here and this function belongs to the class not to the instances like all the other ones and what we do in it is we prepare our point and our segments with the information from this info so I'm going to get the point information of each individual point from the info points and just say push a new point with Point info X and point info y so what happens now is I'm generating a point with the same information from the Json object and same thing with the segment as well segment info of info segments segments push new segment segment info P1 segment info P2 like this and now with this information we can return a new graph like this so it's not just passing in info points and info segments but actual points and segment objects in two different arrays let's save refresh and look at that just as we expected JavaScript is killing me with this uh serialization stuff to be honest the problem is these p P1 and P2 points are not points they are again objects that have an X and Y but they are not the same points from here even though they should be so we have to take care of that I'm going to remove these from here and we need to find in this points array the same points that correspond to P1 and P2 from the Json info so let's find point that was equal to this P1 in the list of points that we created and also P2 like so save and refresh and now everything looks as expected I really don't like that you have to do so much work to get this to work but it is what it is if you know a better way of doing this do let me know actually I know a better way of doing this we can refactor a little bit and say here for example the points we can just use the map method and go through each point I and create a new one so this I stands for Json info and we create new points using that information in one line so we don't need this for Loop anymore and we can even do the same thing for the segments as well so the info segments we can remap them to actual segments each segment I is going to be a new segment and here we just paste this information like so and make sure that this seg info is high now and we don't need this second for Loop anymore so a little bit more concise save refresh and everything still works it's just a little bit nicer structure here we could design the road border now like this but it kind of looks like a child made them making sure Road borders have the same thickness everywhere is important and not fun so today I'll teach you how to use geometry to wrap the graph segments in what I'm going to call envelopes they're just polygons with more points here to make them look round we then compute the union of these polygons to keep just the outer segments this solution keeps the number of clicks to a minimum and makes the World building very satisfying I think now let's get this show on the road I'm going to draw a simple graph that kind of looks like the letter J save it and now let's Implement a functionality that creates a polygon using these points we're going to test this functionality here after displaying the graph editor like so creating a new polygon with the graph points and drawing it on the context so we need to implement a polygon and give it the draw method same as the other Primitives speaking of which the polygon is also going to be a primitive here and let's create the file polygon JS now the polygon is also a simple class and in the Constructor I'm going to pass the points and store them as an attribute like so and the draw method I'm going to give it the context and some options with uh default stroke set to Blue and the line width of two and I want it to be transparent let's set it to a transparent blue fail style like this now inside of the draw method We Begin the path we set the fil style to the fill attribute the stroke style to the stroke and the line withd to the line WID Now we move to the first point like this and use a for Loop to essentially create line to all the other points one by one until we've connected all of them so CTX line to points of i x and points of I of Y like this and now we close the path this will draw the line back to the first point and then and I want to fill and also stroke this time let's save and refresh the page and now we get this so the graph is still there but now we also see this polygon this blue polygon on top of the graph points and if I'm going to add some more points here and play a little bit with these points maybe connect these ones you can see the graph starts to appear here in the middle but the polygon and the graph are two different things it's not the same kind of structure the graph can have these branching elements here now the next thing I want to do is create a polygon along one of these graph segments so somehow enveloping it in a polygon and and we're going to do that by creating another object called envelope and it's going to be used like this new envelope graph segments of zero the first segment and let's give this a width and the width of 80 pixels and draw it on the context like so as before we Define here another primitive envelope in our envelope JS class envelope and the Constructor is going to take the parameter of the segment and I'm going to refer to this as skeleton it's like the inside of the envelope and the second parameter is going to be the width of this envelope let's store this skeleton as an attribute and we'll use the width to generate the polygon like so in a private method called generate polygon like this now we're going to be working with the points of this skeleton and I don't want to type this skeleton P1 this skeleton P2 all the time so I'll just use the destructuring assignment like this and now we can just use B1 and B2 we also need the radius half of the width and the angle between P1 and P2 two we can get it with ar tangent 2 method between the difference of those points like that now we're going to need an angle that is offset by 90° and actually offset 90° clockwise and counterclockwise so I'm going to refer to that angle like this and just add half pi to Al Al and let's copy this below and say here Alpha counterclockwise and put a minus here for minus 90° and now we can start to get points that are offset so from P1 we are going to get a point P1 CCW offset counterclockwise by translating P1 according to Alpha CC W by the radius this is going to be the offset that we move it along the angle from this given point B1 we're going to need to implement this translate method but I'm just going to first use it here to define the other similar points P2 CCW coming from P2 and then P2 CW coming from P2 and Alpha CW and P1 CW coming from P1 Alpha CW like this and these are the points that we will use to create our polygon so we return a new polygon with this array of points like so let's implement this Translate method and maybe we'll also extract this angle function because this is kind of cryptic here like if you don't know the formula what is this doing so inside of math and utils I'm going to go here at the bottom and Implement our translate method which returns a new point relative to the given location we add and now we have to use the trigonometric Circle and remember that on the X it's the coine of the angle and we multiplied this cosine by the offset how much we want to move it because cosine is between 0 and 1 so multiplying this is going to move the point a total of offset on X and Y respectively so diagonally now that angle function is going to be really easy given a point we just output its angle like this and back here we can replace this with angle and then we can just subtract the two points because that's what this is doing so let's put here angle subtract P1 P2 and to draw the envelope we also need to give it a draw method here and for now this is just going to tell the polygon to draw itself now save this and refresh and we get this you can see now this polygon forming surrounding only the first segment of the graph the others are ignored for now but I want this polygon to have curved sides like that here surrounding this because round roads are just nicer so let's figure out how to do that here I'm going to first collect some points around P1 I do that by defining here an array called points and now let's loop from alpha counterclockwise to Alpha clockwise and increase this I with a step we'll Define that in a second and then push into this points translating P1 at this I angle by the radius and this step is going to be a fraction of Pi actually I like to use Pi when dealing with circles and let's try to see what these points look like so I'm going to pass here points instead and we really don't need these other variables they were just there to learn how this works save and refresh and now we get this we get some kind of curviness here we can actually control this by this value if we put here 10 for example we're going to get a much more curvy shape and let's do the same thing with P2 as well so I'm going to copy this below and this doesn't change but here we are going to use P2 and it's on the opposite side so 180° difference and I'm going to add here matte pi plus I like this and save refresh and now we get this this is actually a parameter how round we want this shape to be and we could replace this with roundness and here let's pass it as parameter roundness and I'm going to pass it also here and here maybe give it a default value of something let's try let's try what happens with zero like zero roundness this doesn't really look good let's try one it's what we had previously and this is actually what I would assume to have if the roundness is zero as well so I'm going to go here and do this kind of trickery to avoid that zero situation because it doesn't make any sense and now when we set zero here it's actually going to look like one so when moving it like this there seems to be some problem and it happens because here sometimes I doesn't exactly reach Alpha uncore CW this happens because how floating Point numbers work and sometimes you just get a value that is below that and the next value adding step exceeds feeds that so it never hits exactly there and then you're far from this end result we can fix this by adding a small Epsilon value and I'm making it here a fraction of the step we add this Epsilon value here to this and in that way we guarantee that we include this final angle there and we don't go overboard because it's just half a step in this case so I'm going to save this refresh and now no more strange artifacts like that coming I'm going to keep this default roundness here to one because it somehow makes sense you can create an envelope without a roundness and we can play with the parameters here as well if we want maybe set a width of 200 and let's give it a roundness of 20 see how it looks like okay really round large shape there now I really want to generate these envelopes for everything and it's time to start thinking about defining our world object the one that will contain the roads and all the other components there because these envelopes are going to be part of what is required to build that world so let's implement this world object containing all the things and in there have a way to generate all the envelopes for all the graph segments I'm going to go here below this graph definition and instantiate the world with the graph the world will be based on this graph and now I want this world to automatically update every time we change some things every time we edit the graph and I'm going to add this call here to generate the world and also to draw the world and I'm doing it before the graph editor because it's going to contain things and I want to still see the editing tools on top of that let's now import a new file called World JS and this is going to be here in the root JS directory so next to the editor and the viewport and the class is going to be also relatively simple for now it's going to become quite complex by the end of this course I'm going to pass here some default parameters like the road width and roundness and let's store these things as attributes as well and roundness and now I want to store these envelopes to generate these envelopes uh we will generate them in this class attribute which is empty by default and the generation will happen here we generate them with this generate method and if they're already generated because we do this in a in a loop in in the animation Loop we empty this array to begin with because we are going to regenerate them again and again on each frame maybe we change the editor and then we want the changes to reflect in the world that we create so let's Loop through all the segments now like this and push into this envelopes array a new envelope from this seg and with the road width and Road roundness attributes from above and now this world is also going to need a draw method and I am just going to for now Loop through all of these envelopes and draw them on the context one by one let's refresh and now we get this um funny to play with this reminds me a little bit of this uh quop game I made in uh live stream once all right now the thing we need to deal with next are these sections here these kind of inter sections between these envelopes they need to somehow disappear and all of these envelopes should form a union a single shape that doesn't have any kind of overlapping Parts the first step in that is actually detecting these intersecting points all these small intersecting points between the envelopes and we are going to do that for the first two envelopes to begin with maybe I remove this part from here and save a simpler version of the graph to avoid confusion so let's find all these intersecting points here somehow we'll store these intersections here in an attribute and the function that will do this is called break it's going to be a static method inside of the polygon class and it's going to take two polygons and break them you'll see what that means soon enough but it will return these intersections that I was talking about so here we are going to draw also these intersections after the envelopes maybe int int and this intersections here and and they will appear on the canvas after we implement this break method let's go to polygon JS and it would be useful to have the segments of this polygon as well the sides of the polygon having them readily available here is going to make implementing the brake function easier so in the Constructor I will also get the segments by looping starting at one through all the points like this and pushing into the segments array a new segment between the previous point and the current point and I want this to Loop so when I is going to be equal to points do length then points of I would return an error but doing this is going to return the remainder when dividing by that so this will jump to zero instead of giving an error and that's going to loop around and connect back to the first point which is what we want to have that segment as well and now we can Implement that static method called break that takes two poies poly one and poly two and really only uses the segments of those so let me just take poly one segments and poly two segments like this and now Define the intersections that we want to find and find them by looping through all the segments of the first polygon and for each segment we check to see if it intersect any segment of the second polygon so we need this other for Loop here as well and then we get the intersection between P1 P2 of the first segment and P1 P2 of the second segment and then we check here if the intersection exists because sometimes segments don't intersect and if the offset is different from one and different from zero this means that they don't intersect exactly at the tip which is a situation we want to avoid then we get the point from this intersection object you'll see that in a second and push to the intersections this point and then return intersections like this now I'm going to go to utils JS and add this get intersection function and I'm just going to go down here and paste so this function I'm not going to explain I already have a special video about it and it was part of phase one of the selfdriving car course so if you took phase one then you already know what this is it also includes this linear interpolation function which I also have a video about and we also Al used in phase one I will link to this code somewhere in the description so you can copy it now but let's see if it works and it does show some points here let's make them a little different looking so we don't confuse them with the graph points so here when we draw the intersection I'm going to say color it red and uh make it smaller I think the red color is enough striking and now we get this yep seems like it works and what we'll do next is we're not done with this break method here it doesn't just create the intersections but it's also going to break break these segments so that for example this segment here on the side of this envelope is going to be divided into this segment and this segment after that we're going to take the segments that are contained inside of another envelope and remove them that's how we're going to do the cleaning so let's do this breaking at this intersection Point here after after we have this intersection point I'm going to keep a reference to P2 of Segment 1 and replace P2 of Segment 1 with this so what we did now is instead of having this large segment we just replaced the end point to be here this space here is empty and we need to create create a new segment that starts now here and ends at that place that's why we kept the reference to the original P2 we need to use it now and we do that by using splice at I + one so the next segment and we don't remove anything splice expects here how many things to remove from the array we don't want to remove anything we want to add a new segment starting at the intersection and until what was P2 previously and we do this also for the other segment where the intersection happened so I'm going to copy this without this let because I just want to reassign this auxiliary variable to something else and this is going to be seg 2 of J and SE 2 of J SE 2 splice at j+ one and this should work but we need a good way to test this and I'm going to do that here I will Implement a way to draw the segments by using different colors and in that way we know if it's the same segment that continues after the intersection point or something else so going through all the segments I will draw them on the context with the color get random color and this let's go to utils again I'm going to paste something again we used it in Phase One to draw cars in different colors let's also go to envelope JS here and after we draw the poy normally I'm also going to draw segments with this debugging function we just implemented so refresh and now we get this crazy thing with a lot of colors going around let's make these segments wider I think they are not very visible as such so I'm going to pass here inside of the polygon JS draw segment also um width of five now refresh looks a little better I'm actually going to remove the intersections we don't need them anymore we know they work and actually this breake function doesn't need to collect and return the intersections it just needs to break the polygons so I'm going to remove this part from here here as well it uses the get intersection function but it doesn't collect the points we don't need that and inside of world JS I'm going to stop using the intersections there refresh and things move a lot but you can kind of tell that this color here is not the same as this color here and here there are quite many small changes as well you can debug this better by typing debugger in the console and this is going to instantaneously stop what is happening here and you can see this green red orange and pinkish color here and a lot of these small changes here every time something intersects so the code seems to work but only for the first two envelopes if I'm going to draw here another one you can see this segment here is not affected this segment here is not affected and same for the small ones here so this is the difference what we did now breaking the polygon segments at the intersection points contrary to what we have on the right and what we're going to do next is do the same thing on the right and for every possible combination of envelopes instead of having here polygon break we are going to remove this line and have polygon multi break and I will take all the polies from all the envelopes and send as a parameter one array now this multi Brak inside of polygon JS let's add it here at the top is a static method that gets this array of Poes and I'm just going to Loop through the polies excluding the last one and then for each of these Poes loop again starting at i+ one so I'm not going to compare Poes twice I'm just going to compare every poly with all that follow afterwards and that means we don't do unnecessary work and this one will go all the way until the end and now we use the previous method break between Poes of I and Poes of J like this and if we save and refresh let's add again this other segment here and call here debugger we can see now that this intersection is breaking everywhere as it should and what we'll do next is calculate a union of all the segments that are not inside some other envelope so this segment will disappear this will disappear this will disappear this small one here will disappear these will disappear because they're in this envelope and these will disappear because they're also in this envelope these disappear because they're in this envelope so everything that is inside some envelope will disappear and the result from this will just be a set of segments that we keep it will not be a polygon anymore because for example the resulting shape here would actually be a polygon it would start like this and go like this around and then have a concavity here but if you think about this shape here it would be a polygon that also has a hole and that's a more complex structure and I don't want to get into that so let's Implement our Union function maybe we save this graph as well and here we start off this Union process with the given Poes with a multi break so we break them to get the individual segments and now let's collect the segments that we wish to keep in this array I'm going to scroll down because this is going to be a longer function so looping through all of the polies one by one one and now looping through all of the segments of a given poly we have to figure out if we keep this segment or not so I'm going to say keep is true for now but if this segment is inside another envelope another polygon here then we don't keep it so let's Loop through the Poes again through all of them but ignore here the situation when I is equal to J so we don't want to check if a segment is inside of its polygon it makes no sense and in that case when it's different then we check if it does contain this segment if one of these Poes contains this segment this seg right here then we don't keep it anymore we say keep is false and we can break here to save some computational time because it could be inside several envelopes and here if we keep then I'm going to push it to the kept segments like so and at the end here we return these kept segments so it's a longish function but um it is what it is I'm not going to refactor it anymore what we need to do next is implement this contains segment function so how do we check if this segment is inside something else and because these segments that are in inside are entirely inside something else I'm going to simplify this and only work with the middle point of the segment so the average of the endpoint locations here what that means is that this contain segment is going to transfer its functionality to another method called contains point which is a simpler thing to do now this is not really a great implementation because sometimes the segment may be just partially inside but for our needs it's going to be okay the only problem is the name of this method right here contains segment is a little bit misleading because it only checks if the midpoint is contained inside it and the average function here it's just a simple thing that we add quickly here in utils let's move it next to the other point Vector operations so average of two points I'm just going to return here new Point p1x + p2x ided by 2 and P1 y + P2 y / by two like this and now we can go back and implement the content Point algorithm for this we're going to need an outer point that outer point I'm just going to Define as a point that is far away in the top left maybe minus 1,000 minus 1,000 I just hope nobody goes there and draws the graph in that area it's going to make some small glitches happen I guess and then what we're going to do is we're going to check how many times this line segment from point to this outer Point intersects the polygon if it intersects one time then it means that we are inside but polygons can be quite complex shapes sometimes this line segment may cross it multiple times maybe it goes outside and then inside again and then outside again but if it's always going to be an odd number of times then that means that we are still inside the polygon if it's an even number of times it means we're outside of the polygon we just crossed it to go in and then out then we reach this outer point and even number of intersections so that's how the algorithm is going to go I'm going to Define here intersection count set it to zero and go through all the segments of this polygon and calculate the number of intersections from Outer point point to P1 and P2 of this segment and if there is this intersection I'm going to increase the intersection count like this and at the end we just return if the intersection count if the remainder when dividing by two is zero then this doesn't contain the point because it's even but if it's one then this does contain the point so we are done with our method now to test we need to assign these new segments to some object here and I'm going to call this road borders like so and here we are going to say Road borders is equal to polygon Union of all the Poes and in the draw method I'm going to Loop through all of the segments of this road borders and draw them under context maybe we give them some clearer style here let's give a white color and a width of four so the line is thicker let's save refresh fresh and now you can see here these white sections are only on the outsides of the envelopes let's set um larger roundness maybe 10 and now you can see these white sections are here curving quite nicely around this shape let's Style this to look more like a road I'm going to make the envelopes um gray let's remove also this crazy colorful highlighting there so the envelopes here I'm going to style them with the fill of BBB so this is light gray and the stroke is going to be also the same this means we have to pass options to the envelope draw method as well because it doesn't have them at the moment so options and let's pass these to the poly so that it's going to use the same options and we don't need this draw segments anymore for the colorful highlighting refresh and now it looks like this and you can play around with it and see that it does behave quite nicely as you would expect but I would like to add a little bit more of a region here that is gray so that this white border of the road is not exactly on the border of the road but the road continues just a little bit it's just a marking to do that I'm going to go back here and give also um line width of maybe 15 to the envelopes and now we see here this margin like that and I would also like to draw the mid lines on the road as dashed lines so for that we're going to go here and loop through all of the segments of the graph and draw each segment also with white and also maybe for and a dash of 10 10 save refresh and something happens here but this um graph editor is blocking and I can't really see what is happening maybe we go to index HTML and um let's try commenting out this graph editor yeah and uh graph editor actually still works even without displaying the the things there so you could leave it like this but I don't like it I don't get those intense marked in any way like if I'm hovering something or what is going to happen when I click here uhuh something weird happened I didn't know that because I don't have my editor anymore so I will remove this and I will just go here and add um transparency for the editor I think that this is going to be enough so now I still see it but it's not anymore the main thing there the roads are more emphasized we're going to add some decorative items next the buildings and the trees and we'll just focus on the basis first fancy stuff comes later now with few modifications we could use the same graph editing tools to generate the bases of the buildings as well but I think it's really tedious as especially if you plan to build really big worlds and if you want things to align just right so we'll reuse the functionalities we already have and Implement an algorithm to procedurally generate buildings next to the roads and then just Place trees randomly where they fit this solution does have a downside that you cannot have a building exactly the way you want it but I think it really compensates for that because generating everything becomes so fast and easy that you actually could build Rome in one day let's go to world JS and here in the Constructor add some more properties for generating buildings I'm going to align these a little bit different because there will be quite many things appearing here first one is the building width and then the building minimum length the length will vary depending on the size of the road segment I want to have a minimum value and in this case setting it the same as the building width means that in the worst case we will have a square building otherwise it's just going to go alongside the road and the spacing is so buildings don't get stuck to each other now let's set these values here as attributes of the world like so building width to minimum length and the spacing and let's store the buildings here in this array now we'll generate the buildings inside of the generate function here by typing buildings is equal to this generate buildings we'll write all the functionality in this private method the algorithm will go like this we first generate some thicker envelopes and use the same processes before to get the outer segments from these we keep those is long enough to support at least one building and if they're really long we divide them into multiple supports like this we then generate a poly around each of these using envelopes again and do a little bit of fine tuning you'll see generate buildings let's first get these thicker envelopes I'm just going to call them temporary envelopes because we don't need them afterwards from the graph segments we take each segment one by one and create an envelope using it and push it to this temporary envelopes so the envelope that we're going to create has the segment as the skeleton but then the width we have to calculate so it's going to be the Road width and then I'm going to add here the building width and then the spacing twice and finally the roundness I'm just going to use the same one from the road now let's return these envelopes for now these are not buildings just yet they here just envelopes but we will use the result of this method and the contents of this buildings array to debug and we are going to display now those envelopes even though here I'm already going to WR as if they are buildings save and refresh and we see this it's uh not really clear but um these are some thicker envelopes than the ones used to define the road so next step is to avoid these inner segments here so we do the union of these envelope poies here and those remaining segments will be guides I will refer to them as guides here and they will be computed by doing the Union on these temporary envelopes so I map here just the police let's paste this here and debug and now you can see these guides appearing here as segments this time and the buildings are going to be generated on them but not on all all of them only if the guide is longer than the minimum length of the building so let's filter out these very small segments here in the curvy areas and anything that is too short to support the building we are going to Loop through the guides that we have let's just take it here like so and if the length of this segment is less than the minimum length of the building then we are going to remove that I will remove the guide at I one of them and then we also have to do I minus minus here because when removing something from an array it's going to shift everything over this so then the index at I where we are will have some new item that also needs to be checked so if we let I increase which it will for the next step it's going to skip that one unless we decrease as well now this segment here we need the way to calculate its length and it's really easy we just go to The Primitives segment and Implement a length method here that will just return the distance between this P1 and this P2 now we can save and refresh and you can see it looks different these are the only places where buildings can appear in this scenario The Next Step will be to generate the supports for those buildings so for example this segment here is quite long and it's probably going to support multiple buildings and I want to get small segments that we can use as a way to define the buildings around them using envelopes again you'll see now let's say that we could fit three buildings here I want them to start from here and here and also have the spacing in between and the logic for what we're going to implement next is going to be much easier I if we consider a little bit of extra spacing at the end as well because then we can think of a building as the building and its spacing the building and its spacing the building and its spacing and that will help in writing the code so let's go back to World JS here and Define these supports that we need to calculate next and loop through all the segments of the guides and for each segment let's calculate that length with a little bit of extra spacing there so it's the length of the segment plus this spacing and now we can find out how many buildings would fit so the building count is going to be ma. floor of the length divided by this building minimum length plus this spacing and now that we know how many buildings there are we can find out what is the actual length of the buildings so the buildings on this segment will have a length equal to the length of this total segment with the extra spacing divided by the building count but now we have the building and the spacing included in this length so let's subtract this spacing as well and we can proceed to generate the supports along this segment with this building length that we calculated so to do that I'm first going to focus on the first support so let's get the direction of this segment we're going to needed and then two points q1 is going to be segment B1 and Q2 is going to be according to segment q1 we move along this direction the length of this building length so what we're going to do is add to q1 scaling this direction vector by the building length and add this segment to the supports like so let's implement this direction Vector it's also easy going to be calculated by normalizing because I don't want this vector Vector to contain any magnitude any distance really it's going to have a distance of one a magnitude of one and we just get it by subtracting P1 from P2 like this so this is going to be the vector from P1 to P2 and it's going to be normalized so it's just the direction there this normalization we don't have it implemented just yet but it's easy to do we just go to utils and maybe here below the scale we normalize P by just scaling p with the inverse of its length of its magnitude and now this magnitude it's just the distance to the origin so I'm going to implemented using the hypotenuse there and I'm only going to pass X and Y because the difference is X and Y the other point is the origin and refresh I have a typo here World JS floor refresh and now it works looks pretty much same as before but if we make one segment longer it doesn't work I forgot to pass here the supports to the return as well okay now if we make this segment longer you can see that only the first support for the buildings along this line is shown and same happens here so let's do the other ones we just Loop here starting from the second building until we reach the building count and update these q1 and Q2 so q1 is going to become Q2 but we add the spacing in the direction of the direction vector and Q2 is going to be q1 now but we add in the direction Vector the length of the building this time and we add a new support segment between q1 and Q2 let's save this refresh and now we can see these supports for the buildings appearing there let's generate the base for each of them using the envelope with no roundness we are going to get a rectangular Reg there a polygon so here after we're done with these supports I'm going to write bases like this and looping through all of the supports I'm going to push a new envelope from this segment with the building width as a width no roundness because it's going to default to just a rectangular shape and then I take from here the polygon I don't want to use envelopes here I just want the polygon I'm using the envelope Constructor to get the polygon that I want pretty much and now let's remember to return these bases and refresh yeah this looks nice but here there are some intersecting bases and I'm just going to remove one of them if this happens so let's go back here and say looping between all pairs of bases to find those that intersect if some of them intersect I'm going to Loop through all all of them except for the last one and now all following ones so starting with j at I + one and going until the Bas is length to include the final one as well and now we check to see if bases of I intersects the poly bases of J and if it does I'm going to remove let's say basis of J because it's the second forward Loop there and decrease from the second for Loop because of the same issue mentioned previously now this intersects poly we need to implement and we're going to go in polygon JS somewhere here maybe and type intersects poly a given poly and we're going to look through all of these segments and all of the Poes segments and we check to see if there is any intersection between any of these in theory it's possible to have a polygon inside another so their edges their segments don't intersect but we are not going to have that situation because of the sizes that we have defined and um topology of the network so let's return true here and return false here now let's go back here and before I refresh I'm going to save this state so that when I refresh I'm going to have this same situation and let's refresh now and see what happens so this one Building from here disappeared it's okay if we have empty spaces like this sometimes we're going to fill them with trees you'll see now let's test a little bit oh oh there is some weird fidgeting happening there on that side let me try to isolate when it happens like this one there should definitely be a building there I'm going to save this state and try to fix it the problem is is actually inside of our get intersection function here and it's not really a problem of the logic or the math but it has to do with floating Point numbers sometimes this bottom here is basically zero but because of how floating Point numbers work it's not exactly zero it's very very close to it and that's the situation that you see here the building disappears here because that triggers that bottom to be close to zero instead of zero so some kind of fake intersection appears there and I'm going to fix this by just using here a small Epsilon value and instead of saying here bottom different than zero I'm going to say absolute value of the bottom because it can be either way is is greater than Epsilon and let's refresh and see what happens here and the problem is gone and you will see that there is no more fidgeting happening now let's move on and generate trees in this region I'm going to close some of these tabs I have open here at the top and go back to The Constructor here in World JS and prepare a holder for these trees and they will be generated here generate trees in a new private method generate trees and let's start by giving this uh parameter and say we want to generate 10 trees somewhere in the region occupied by our graph now the way this will work is it's going to prepare a trees array here and while the length of this array is less than the count it's going to try to add more trees here and for now they will be just simple points and I will randomize the location using lurp so I'm going to lurp between the left side of the region the right side of the region and then from the top to the bottom and these Left Right top bottom we will need to Define above but basically randomly generating trees within the region is what we're doing here and let's push the tree into this dis array and return trees like so now for this Left Right top and bottom top is going to be this point right here it's the minimum y value of the buildings and these um envelopes sometimes the envelope could be the topmost thing like maybe and this situation right here and same goes for the bottom so we need all the points coming from the envelopes forming the road and the polygons forming the buildings for the road I'm actually going to use the segments from the road borders that we have already so here let's take those points into a variable points is equal to and here I'm going to form an array with from the road borders let's map each segment so that P1 and P2 go in a new array and after all of them are here in an array so an array of pairs of points also arrays we can flatten that into one single array of points and we do a similar thing also for the buildings but here we map the points because they are available as uh part of the Poley and we flatten these as well otherwise we're going to have a big array of small arrays with four elements okay and now we get left right top and bottom so left is going to be the minimum value we map again from these points so that we only take the x value and we spread here the spread is used just to take individual items not the whole array and we've used it everywhere here and um let's do the same thing for the right but with the maximum here and let's copy both of these for the top with the Y value here and the bottom with the Y value here so minan max min max is uh okay here and let's draw these trees so similar how we do the buildings here I'm going to Loop and say that through all the trees draw the tree they are points for now now let's refresh and you can see something funny happening here they're generating again and again and again and again at each frame because here in index HTML we do generate on each frame and because we use Randomness we get this funny effect going on but it's kind of okay because it does show us that the region where they're appearing is indeed what we expect it's probably time to stop generating this graph again and again on each frame it's very processor intensive and only generated if it changes for that we're going to go here and calculate the hash for the graph a kind of unique identifier so let's say that the old graph hash is the graph hash we're going to implement this function soon and this is going to be the one when the page loads in the beginning and here before generate we are going to check if the graph hash is different than the old graph hash then we generate and all the graph hash gets updated to the graph hash like so let's close this and invent this better and the hash I'm just going to stringify the graph so in graph JS here at the top I'm going to add the hash function that only converts this into a string let's refresh and you can see now the points is dark points here are now the trees and every time we change the graph they actually get regenerated so what we did works next will be avoid generating trees in these illegal places like on the road here or inside of this building let's go to world JS where we generate the trees and above this Loop I'm going to have a holder for these illegal poys where we don't want things to be inside so illegal poce a new array and here I'm going to spread the buildings they are Poes still at this stage later we're going to actually make a building class for each of them so we'll have to refactor this code a little bit but now this works just fine and from the envelopes I'm going to take each individual po like this so let's check to see if the points that we are adding here should be kept as a tree or not and I'm going to implement this like so keep is true by default and then looping through the illegal Poes if this poly contains the point P then we say we don't keep it keep is false and we can also break here because it's enough that the tree is in one poly it's not going to be inside another one as well so no point to look for another one in this case and here here I'm going to wrap this in his keep then push the tree to the trees otherwise this is going to try again and again until you reach that count let's save and refresh and now the trees don't intersect those and we could try also changing the graph a little bit just to see multiple Generations and it doesn't seem like any intersection is happening so the trees are in almost okay places the problem is these trees also have a size right so maybe this is too small of a space for the tree to be in and that's what we are going to need to do next let's define the size for these trees here as another parameter and I'm going to save it here as a attribute and when drawing the trees let's also give them this size so that we see them properly and I'm going to give them a color that is transparent black so that we see intersections between trees as well that's another thing that we're going to look out for close this save and refresh and now you see those things that I was talking about so these trees first of all they intersect and then also they hit the other objects there so we need to take care of these somehow let's first take care of these trees that intersect so if a tree is too close to another tree then we just don't generate it there we try to generate it again so back in the generate Tre function here just before we decide if we keep the point or not I'm going to say if we have kept it so far we are going to Loop through all of the trees and if the distance from the tree to this point that we want to decide on is less than the size of the tree then we don't keep it we can also break save and refresh and now the trees shouldn't intersect each other anymore because we said that the distance between the trees should be bigger than a tree so that problem is solved but let's also solve the problem of being too close to the road or too close to the building Poes so here where we check if the illegal poies contain the point I'm also going to check or the distance from the poly to the point is less than half the tree size so here we just need the radius let's save and implement this distance to point function inside of the polygon maybe here distance to point for a polygon is going to return the minimum distance between the point point and all its segments so I'm just going to map through all the segments and return the distance to the point from that segment and then spread and return the minimum of that let's save and now we have to implement the distance from a point to the segment so we go to the segment file maybe somewhere here and I'm going to paste some code this code is explained in my other video and I'm not going to go through it now you can also copy this code from a link in the description and notice one thing that the distance to point uses this project Point function here so that's why there are two methods that I pasted here and also one more Vector operation the dot product needs to be add added in utils so save this file and then in utils where our Vector operations are maybe somewhere here I'm going to paste this dot product now let's save and refresh and you can see where the trees are now this is a time when you should be a little bit careful because well if your space is so small that the trees wouldn't be possible to fit you're going to get an error and not really an error but a problem with the execution your while here will never end because trees's length will never reach count so that's why I've used only a few trees until now we would like to write this in a way that it doesn't depend on a count but on something else because if I'm going to make now a very big graph here like so it's still going to generate 10 trees but much of this space is going to be empty 10 trees in a very very big city will be will be nothing so the way we will rewrite this is not having a counter here but having a try count here so what we will do is we will try to add trees and if at some point we tried a lot we just assume there are enough trees we can't add anymore so what we do here is try count set it to zero and here let's say while we try for 100 100 times we're going to do all of this if we manage to find the space for a tree then we reset the try count and then increase the try count on each step this is very important otherwise we have an infinite loop again now refresh the page and you can see the trees and they are 1 2 3 4 5 6 7 8 9 10 10 11 12 13 14 but the number of trees will really depend on the size of the area here really and uh come to think about it there are some situations like I don't really care what is here in this section it's so far away from the road if I think about our selfdriving scenario we will mostly just watch what happens on the road and we might see some trees here here maybe here if we zoom out a bit but our Focus will be on the road so generating trees so far away is kind of a waste of memory and I'm going to add a control for that so let's go here and add another filtering step if we still keep the tree up to this point we are going to check if it's close to something by default we say that is false and then Loop through all of the illegal polies again and if the distance from the poly to the point is less than I'm going to put here tree size * 2 so that I can fit up to two trees uh away from the from the items then I say yes there is something nearby we are closed to something and we can break we don't need to look further and here I'm going to say keep is this close to something now save refresh and you can see now the trees no longer get generated in these sections now this piece of code with all this filtering is a little bit long it's quite long actually maybe should refactor it somehow extract these as functions but I'm just going to add here some comments so this is going to be a check if the tree is inside or nearby the building or the road and then here check if Trees Too Close to other trees and here avoiding trees in the middle of nowhere so I think this is fine let's save refresh and test again sometimes these buildings can still be quite close to each other and I don't like that very much that uh spacing is not preserved also here between these ones because there's this point here on this otherwise straight line let me save this state so that I have it for f future testing and go where we generate the buildings here we check to see if it intersects the poly but we can also pass now if the bases of I distance to poly base of J is less than this spacing that's also a problem and we need this distance to poly function implemented in polygon JS but it's going to be quite easy we just go through all the points and say that for each point we take out the distance to that poy so now the distance between two Poes is actually the distance between the closest points it's not exactly what we want because sometimes you might have poies that are offset a little bit and then the distance will appear to be this um even though they are touching but it doesn't matter very much in our case because of how aligned the things are and for this we would need to have a way to calculate distance between two segments and I don't have a tutorial for that yet so it's just going to have to do let's save and refresh and now you can see here that building is gone it's going to leave an empty space there but it's just fine maybe it's going to get filled by some tree like now there will be trees there let's test uhuh there's also one more problem here these buildings are now leaving gaps here again and this is because of that floating Point Number issue sometimes the buildings that are like this and should have a spacing there don't have it because when we calculate the distance now because of the floating Point values just appear a little bit short so back here in World JS instead of just spacing I'm going to add a small Epsilon here as well so minus the Epsilon save let's save this state and refresh and now you can see that those buildings don't have the Gap there what if you want things to look 3D well you could refactor this entire app to use a 3D rendering engine some people already ported the code in Phase One to use 3js or even used other programming languages to do it so what I'm going to teach you now is not the only way to do it and I'm not really sure I recommend it I mean if you really want to make something three the user Library it will take care of cameras lights and a bunch of other things making the end result more professional but I think teaching you this is still interesting because I like the way it looks and getting this to work was actually easier than I thought you may also find the math interesting since it touches on some principles of how 3D renderers work even though they mostly use triangles or boxal and we won't be doing any of that I promise I'll stop here and we won't go to higher dimensional spaces get it no because I have that video on how to calculate distances between points in higher dimensions and no no no let's start converting our tree points here into actual trees so instead of pushing just P here we're going to push a new tree at be with this given tree size let's go to index HTML and import a tree object and I'm going to copy here this viewport and the trees will be inside of items slash tree the buildings will be also in items so let's go inside of JS and create the items folder and then inside the items we are going to have our threejs and this is going to be just a simple class again with a Constructor at the given center with the given size let's also store these attributes Center and the size and by the size I mean the size of the base of the tree so let's make it the year and the draw method for now is just going to draw a point at the center with the given size and let's make it green this time so that we know when we test if it if it works or if we're testing some wrong version now this code won't work directly we need to refactor a little bit here in World JS you see here where we are checking to see if we're too close to other trees distance between tree and point makes no sense so we need to take here instead of tree we add tree do Center and also when drawing here at the bottom everything we don't need to pass these styles to the tree anymore because the tree knows to draw itself so let's save this and refresh and now the circles here are green I'm going to teach you how to make them look 3D is next let's begin by drawing a line at an offset a segment at an offset here so inside of tree JS we are going to calculate the top of the tree as the center but adding an offset so it's going to be to the top left towards the top left this offset by 40 on X and 4 and Y and now let's draw a segment from Center to top like this save refresh and you can see this it kind of looks like sticks going up from this circle but we are watching all of them from the same angle and we don't really want that we want the angle to change depending on our Viewpoint here so these should look like that but these should go the other direction so we need to know this direction from the Viewpoint to the center of the tree we're going to implement our 3d effect based on this simple fact if the Viewpoint is above the item the top and the bottom align perfectly but if they're not there's a bigger offset here than here let's go back here and do just that I'm going to calculate here this difference as the difference between the center and the a Viewpoint now this Viewpoint is something we need access to and I'm going to pass it here like this so the world needs to give it to the tree somehow and the world has to get it from somewhere so it's going to be past here and in index HTML in animate where we're doing the drawing this is where we calculate the Viewpoint and we get it from the offset of the viewport but it's actually the opposite of the offset at the view part so we do this Viewpoint is scaling the viewport offset by minus one and we pass it here to the world like that save refresh and um it doesn't work I think we forgot here to pass this diff here instead of our outc coded value there refresh and now we get something more like it it looks like these trees are really really tall things here maybe too much basically if we focus on this one tree here it's now this distance from the center and it's going to have this length the same distance as that so it's way too much maybe we can go with half or or even less so I'm going to go here inside of 3js and this difference I'm going to scale it I will type here scale the difference by 0.5 save refresh and now this effect is not so pronounced anymore so I think it can be even a little bit less and we can take this out and call it maybe height coefficient and this is going to be here a parameter and it will control the height pretty much let's set it to 0.3 and here height coefficient equals the height coefficient so that the tree knows how tall it is safe and refresh this looks about right now we're going to start styling these trees and we're going to form them from many levels stacked on top of each other we're going to go here and let's define our level count how many levels we want the trees to have I'm going to put seven and um let's loop from Level zero to level count level Plus+ and get a t value that we will use in interpolation so this is going to be between zero and one maybe should take special consideration here when dividing by zero if level count is one but I don't bother with that now and then the point that we will use at each of these levels is going to come from linear interpolation between the center and the top that we calculated previously using this T value and now we we can just say Point draw in the same way that we did the center and actually we don't need to draw the center anymore because it's already taken care of at level zero that's the bottommost circle now so let's implement this lurp 2D function it's actually not here yet in utils we have lurp but this slurp to the is just lurp applied on the X and Y components of the two points so like this save refresh and now we see kind of like a cylinder there made of seven different circles on top of each other let's give them a different color so that they come brighter towards the top and we go back here in tree JS I don't think we need this segment here anymore instead we go here and say the color is equal to and we're going to interpolate again using the simple lurp this time for just the green green value in this color so we're going to go between 50 and 200 these are just values that I like how they how they look and I added some values for red and for blue as well they are quite low values so they just control the shade a little bit and now this color we can actually just pass it here like so save refresh and now this cylinder looks like that next step we also interpolate the size so it becomes smaller towards the top and um we do that here size lurp between this size and 40 I just chose as a value that looks good to me but you can play with these values if you want now let's pass this size here I I think this should work save refresh and now the trees look like that they start to resemble something like what trees are supposed to look like at least these kind of uh Christmas trees let's make them look a little bit more fuzzy so this is too abstract for my taste and we're going to instead of drawing perfect circles here we're going to draw some kind of noisy circles uh you'll see basically here instead of using points to define the levels we remove that and let's use Poes instead and I'm going to make a private method generate level one level from the point and with the given size and let's say poly. draw at CTX let me give here the color and I don't want to use any stroke style for the tree so I'm putting here one with Alpha zero and now we can go up here and implement the generate level method where we just draw circle like shape around this point with this size so now let me take points here that we will put on the circle shape and the radius will be half of the size and now I'm going to loop with this a variable for angle starting at zero and going all the way to 360° or 2 pi radians and I will increase a by Pi ided by 16 so this means we will have 32 points along the circle and here we need to not use just a fixed radius otherwise it's going to be a circle but we will get a noisy radius where we just multiply the radius by math dot random like this and then we push to the points a point where we translate our original point at the given angle with the noisy radius like so and let's return here a new polygon with these points now save and refresh and uh you will see some funny stuff happening here maybe if we type debugger in the cons so we get a better idea of how these trees look like because the radius now is between zero and the tree size you get these spiky spiky look to the trees I guess it could be okay but I don't like it that much instead what we're going to do is add a lurp here between 0.5 and one so that we just get the upper half of random pretty much so between 0.5 and one are the random values if we do this save and refresh and now this looks more like what I want but of course they shouldn't be fidgeting like this and this is an annoying situation here because many programming languages do have a way to Generate random numbers with a fixed seed and you could do that fairly easy but not in JavaScript so I had to come up with something that generates kind of random numbers but always the same thing for each tree so that when redrawing it doesn't re generate the tree like that and I have a quick fix here for that so my kind of random number that I will generate comes from this very simple mathematical formula okay and now we pass it here instead of this actual random save refresh and now the trees don't shake like that anymore so this formula is um I'm not going to go too deep into it but cosine gives you a value between minus one and one square the cosine is going to give you a value between 0 and one so same as the random that we had previously and inside of this cosine I mixed together the angle with the center of the tree and with the sze and what this means is that each level of the tree is going to look a little bit different because the size contributes to it each part of the level according to the angle is going to look different because a contributes to it and I'm also offsetting a by this Center X location of the tree so that two trees don't look the same if you remove for example this part here all of the trees will look the same if I remember right let's save and refresh so you can see all of them have here this Spike Spike Spike spike because the center location doesn't affect in any way and same goes for other values I also have some hack here with remainder when dividing by 17 because it's a prime number and also it adds a little bit of fuzziness to the result but still if you save and refresh you will see that there is some kind of pattern to how these trees are being generated they are not exactly the same but they do have some similarities like maybe two of these thicker branches here and here and here and all of them kind of seem to have that you can find some pattern there these are not really random numbers they are just random Mish numbers and they are influenced a lot by how the cosign looks like so that's why you get this periodic change there anyway it's just a function I mushed there together to get this to work alternatively you could also save these levels when you generate the tree and then just draw it but I didn't want to bother with that it would have been more work explaining things now one thing that we could have here in the Constructor is also defining the base of the tree so I'm just going to call here generate level at the center and with the size this is already happening here when level is zero but now I'm storing that as the base of the tree and this is important because this base of the tree is something that the car May interact with like if it hits this base of the tree then it hits the tree pretty much so the base is giving us segments here on the side of the tree on the bottommost level that we could use now I'm going to remove this it's just for debugging so you see what the base was and we're going to continue to generate the buildings next so let's close this tree and the details and in World JS here this is the end of the generate buildings method instead of just having the bases of the buildings those polygons we are going to map these to new buildings as well and we're going to do very similar things for the buildings starting with let's fix the situations where buildings were poly previously so in the generate trees method here we are using the buildings as Poes we are accessing here the points directly but the building will also have a base like we added for the trees just now and that's how we will get the points from now on and also here illegal poies it's not just getting the buildings those are going to be new objects so what we do here is take out just the base from these buildings and now we have the Poes here to work with in the draw method below we also have to pass this Viewpoint to the buildings they'll also have a 3D look and let's go to index HTML and include the building similarly as we include the tree here building JS inside of items here where the tree is building JS and let's define the building class so simple class with the Constructor getting a poly for the base and a height coefficient let's set it 0.4 a little bit taller than the trees just to see how it looks like and now let's store this base here and the height coefficient and uh write a simple draw method CTX and the Viewpoint and draw the base and the context and let's make it white and uh grayish light gray stroke so let's just debug to see if our refactoring caused any issues save and refresh and now the buildings are white but no 3d effect just yet for that I'm going to go here at the top and calculate the top points on the ceiling of the building so top points is taking the base points and remapping each point to something else and here we type add this point scale subtract p Viewpoint this height coefficient like so and the ceiling is going to be a new polygon from these top points this formula here is the same that we used here in 3js but it's divided so we have first add scale SC and then this diff is subtract of that so add scale subtract it's the same thing now let's draw the ceiling as well I'm going to do the same thing as with the base but the ceiling save and refresh and now you can see that floating ceiling there over the buildings over the building base let's do the sides as well I'm going to go here after we have the ceiling and the sides are going to be polygons as well and we will make these sides by connecting two points two consecutive points from the base with two consecutive points from the ceiling but in reverse order in the ceiling you'll see so we do this looping through all the points like that and let me just write here next I for I + one basically but also make it loop around so I'm going to take the reminder when considering the length of this array so the last point is going to have next the first point in this polygon of the base and now let's generate these sides one by one inside of this for Loop so it's going to be a poly new polygon like this and first point base points of IE and then base points of next eye and then the ceiling points but they're already in that top points and it's shorter to right so top points next eye and top points I so basically bottom and then top reverse and let's add this poly to the sides and now before drawing the ceiling we're going to go here and draw all the sides one by one let me just copy this here and this is side I'll use the same style save and refresh and um some things look really good like this but some of them look like these I don't know empty boxes here and some are even over the other ones it's um a little bit confusing what is going on but uh the thing is this side here it's being drawn and after that this side here it's being drawn so you see this line from this side on the right on top of this side that should actually block that side on the right this means that we need to draw these sides in a way that makes sense the backmost ones first and then the front ones second so we will sort the sides of this building so that the further away ones are going to be in the beginning they get drawn first and then the closest ones to this Viewpoint are going to be second we do that here calling sort and the call back function will be this one uh comparison function that takes a and b to polygons this time and we write the result to be distance to point to the Viewpoint minus a distance to point Viewpoint so we're sorting all of the sides all of the polygons according to the distance to the viewpoint but because we write it in this way with B uh first and a second it means that we sort in reverse order so the closest ones are going to be the last ones to draw let's save and refresh and now you don't see that problem that kind of empty box look anymore but we still have some problems like this building being drawn before this building the same logic goes here for the buildings as well but we're going to use the base poy to decide which building to draw first and actually trees as well so here the tree goes underneath the building so we need to group trees and buildings together and do this sorting via their base at the same time to get the 3d effect to work so I'm going to go back to World JS here and let's combine these items into one array I'm going to write here items buildings and trees and let's pass here items and this is item item we don't need the second Loop anymore because we're now drawing them with the single Loop let's just see if this works it should be so that now the trees are over the buildings because they are drawn later save refresh so yeah same problems as before but now trees are over the build buildings so let's do that sorting now for these items here and it's the same thing really sorting the items same kind of function but now we tell the Poes the base of these objects to calculate the distance to the point save and the refresh and now this looks proper you can see this tree here between this building and this other building quite nicely and it changed relationship now so now it's drawn before this building now it's drawn after this building so this works just fine you can see sometimes these uh weird lines here but these are actually from the graph editor um it's not any glitch or anything like that they won't appear when we just use the world without the editor showing now you can style these however you want you can go further and make them look even nicer I will have a special video for channel members and they will get to see how I made them have roofs and also how to make a more realistic 3d effect because this one if you pay attention what happens here these buildings just get taller and taller like that and if your viewport is bigger and bigger they will just look really crazy so something is not right here you shouldn't exceed a size when looking at the building like this and the building should have a proper height not a height coefficient what whatever that meets so I will have a special video for that it's not going to be very long so not too much content in it but uh the code from that I will put now and mix it together with this one and you can look at it afterwards and selfstudy it even if you don't watch that video the worlds we can create now are much more complicated than that straight line we had in phase one but adding some traffic rules here will really give us a lot of flexibility in phase three we'll be able to teach the car all kinds of things because our world is really 2D apart from these tricks here we will enforce these rules as markings on the road I'll show you a clever way of adding the markings so they snap to the road and always have the correct orientation we're not going to have our users worry about things like that they should work as little as possible to get something nice try remember that as the general rule we're going to start adding markings to the world and we'll begin with stop markings but to do this we're going to need another editor um a stop editor and a way to change from the graph editing mode to the stop editing mode I'm going to do that here by adding two buttons for that they're going to be mutually exclusive let's start by adding an empty space to separate from the save and load functionalities and the first button it's going to have an ID this time because we're going to change the way it looks soon in JavaScript and uh we need to access it and when we click we're going to set the mode to the graph so this will enable the graph editing tools and the second button is going to have an ID stop BTN and onclick it's going to set the mode to stop let me close this tag and I'm going to style these buttons using emojis again for the graph and one for the Stop like this let's save and refresh the buttons are here but uh let's style the buttons a bit better they have this default view and I don't really like it let's make them bigger at least in Styles I'm going to add a style for the buttons let's put the background color white for maximum contrast and the font size 20 pixels refresh and they're bigger but I would like them to look Square as well and I found that adding here a padding of 5775 does the trick refresh and it's fine but this border here that the button has is a little bit uh nerdy and I will remove it and also add rounded Corners as well so here border set to none and Border radius five and refresh looks much better now this button and maybe this one too the contrast is not so good it's not so easy for me to see this button I'm going to add also a drop shadow on the bottom right so let's have a text Shadow one one black and I like buttons to have this uh hand cursor when you're hovering them so let me add all also here this cursor pointer save and refresh and now this looks good and feels good I think but pressing them does nothing this set mode is not defined yet so let's define it I'm going to go in index HTML here at the bottom and say set mode and the first thing that it will do is is disable any editor all the editors disable everything and then we're going to have a switch case that will enable the one with the given mode but let's handle first this disable editors and only visually so make the buttons look disabled if they are disabled and I'm going to start with the graph button and give it a gray background color and I'm also going to remove the colors in the Emojis by passing a grayscale filter with the 100% like this and this we have to do also for the Stop button so stop button and stop button now if we save and refresh press one of these buttons no more error there and both them are disabled now because this set mode was called so after they're disabled let's enable the one that has been clicked depending on this mode so switch depending on the mode if it was the graph I'm going to set the background color of the graph button back to White and remove the filter as well and let's break now I will copy this also for the stop using the stop button stop button save and refresh and clicking on them now toggles the behavior but when we refresh the page one of them should be selected and I'm going to enable this graph by default so I will go above here where we before we start the animation Loop and I will type set mode graph and now we can start talking about the functionality as well not just the look and feel so what we want to happen here in set mode is to enable the graph editor if we Press On the graph button and let's add this functionality to our graph editor it doesn't have it yet enable and here disable editors it's also going to need a way to disable it let's save and go inside our graph editor and the first thing we'll do is remove this call to adding event listeners because we want that to happen in the enable method so enable we add event listeners like this and then the disa is going to remove event listeners like that remove event listeners should look very much like ad event listeners but with remove in all of these parts so remove like this let's save and refresh and now we are able to edit the graph here to create a graph and when we switch to the stop editing mode which doesn't yet exist but it should disable the graph editor we still can edit the graph the problem is here when we add event listeners and we call bind on this method it creates a new method where this inside of it is this so remove event listener expects to get the exact same thing here when removing it not to create a new copy of handle Mouse down with this bound into it this is a problem and we're going to need to fix it and the best way I know how is just to store this version of the function here as an attribute and then use the attribute here and here so hopefully you get the point I'm going to store here the bound Mouse down function and let's just copy this from here and now put this here and here the second one is going to be bound Mouse move and we're going to cut this from here and copy this here and here and we have to do something for these as well because they're Anonymous functions so actually here we create a function and here it's another function they just do the same thing but it's not the same function that we want to remove here as well so let's do the mouse up is next Mouse up is um I have it here the last one let's actually rearrange these because I think it's more logical to have the order like this with the mouse Events first and then this context menu at the end and let me cut this here and now we pass this here and here here and finally context menu context menu I think could be also removed forever we never really need the context menu in this application but uh I'm not going to bother with that now I just keep this consistent and make sure that all the listeners are added and removed like this now save refresh try to add the graph change to this stop try to add more points and it doesn't work we can't select points we can't do anything with the graph anymore now but if we reenable it we can and disabling it again has this weird artifact now because we still have a select point there so I'm going to go here where the disable is and let's pass also selected is false and hovered is false save refresh and let's try one more time when pressing this that line disappeared so no more problem and we can can actually Define a new graph here to use because it's time to implement the stop marking as well and we should add stops on something I'm going to keep this format now let's save it so when we refresh it loads this graph now and we can begin to implement the stop editor we're going to go in index HTML and um it's going to work pretty much like this graph editor Let me just copy this instantiation here and say stop editor is a new stop editor but adding the stop markings on the road is going to need some information about the road itself not just that graph so how big the road is and something like that so we're going to pass here instead of graph world for this one otherwise um here when we do the display for the graph editor we're also going to have a display for our stop editor dispose I'm not going to deal with this now we will handle it a little bit later but then here this enable needs to happen here for the stop as well and the disable here let's implement the stop editor in a separate file and we will have more editors now so I'm going to move graph editor and the stop editor into a new folder let's call this editors and I'm going to move this editors here above the items so that these files that are directly in JavaScript are grouped together and let's copy this graph editor with a stop editor and create now the new folder injs called editors move graph editor inside it and create the new file stop editor JS next to it now this functionality will be quite similar to the graph editor so we will be copying some things from there but let's first handle this Constructor passing the viewport and the world which is a little bit different and store the viewport and the world as object attributes and also add here a reference to the viewport canvas and and a reference to the context stop editor will also have a display method and these items will come in handy for that now let's go to graph editor and I'm going to copy enable disable and adding removing the event listeners I think they are pretty much the same like this but but um this selected and hovered will make no sense here and we actually won't have a mouse up event listener this editor is going to be simpler than the graph editor so Mouse up won't be needed and we won't be dragging anything and let's begin to implement this mouse move private method here handle Mouse move I'm going to copy it from graph editor here and to begin with I want to win hovering the mouse over some of these segments to highlight that segment the thing is these stops will be added on the roads themselves so we're going to use them as guides otherwise it's going to be very difficult to place that stop exactly at the location and the end result won't look good so we're going to use the segments that exist already as some kind of guides and our interface for using this stop editor is going to be much easier to use much more user friendly so we begin by finding what is the nearest segment where we want to add this stop on so this get nearest point is going to change to a get nearest segment and we're going to store that segment in a constant get nearest segment and here let me align these a little bit better they go out of the screen and it's going to use the graph segments but here we don't have this graph directly we have the world so the graph is part of this world graph segments like this and this dragging part we don't need it what we do need to do is check if we do get a segment if there is a nearest segment under this threshold and if there is I'm going to Define find an attribute called intent again I want to show where the marking would appear if we would click the button so the intent for now is going to be the segment itself otherwise it's going to be null like this and let's take out Mouse and intent as attributes up here as well now to see this intent we need to implement the display method as well if there is an intent I'm just going to draw it on the context with default styling and we still need to implement this yet nearest segment function it's going to be in math utils at the top next to the first function we implemented in this file which was get nearest point and now we're also going to have get nearest segment which takes the location and a list of segments same threshold and here we Loop through each segment of segments and when we calculate the distance we can't use this Pythagorean theorem implementation to get the hypotenuse we have to call from the segment the distance to point instead and here the nearest will not be a point it's going to be the segment that has been found with the smaller distance again and again eventually leading to the one with the smallest distance now if we save and refresh we get an error here in the stop editor because it doesn't have yet a handle Mouse down method so let's just add an empty one here for now we will handle it later save and refresh and switch to the stop editor and now you can see that segment being highlighted the nearest segment to our Mouse location it's not a strong highlight but there is a highlight so I want the stop to be generated at the location centered exactly on that segment so next thing we'll do is Project our Mouse location on that nearest segment if there is a nearest segment here to get one point the center of the stop marking for that will go here when we have the segment available and I'm just going to project the point on the segment by doing this and the projection may also fall outside of the segment so that would be a weird uh error there and I'm going to check here if the offset is really between zero and one so if the projected Point Falls indeed on the segment not on the support line and in this case the intent is going to become the projected Point otherwise it's going to be null again save refresh switch to the stop editor and now we get a point there and we don't have to worry about is the mouse exactly there or not it's always going to be perfectly centered just as we want it and now it's time to define the marking itself so it's going to be a polygon but I'm going to have a specialized object for it a stop object for storing and drawing the stop marking so here we're going to need to pass some properties to that the first one is going to be the point itself so as before but I want the marking to orient nicely according to the segment that it's on so I'm also going to pass here the direction Vector of this segment and then a width and height I want the width to span the whole Road really and the height let's just use a factor of that like half the road width at least for now now to Define this stop marking we go to index HTML and we're going to do that in uh folder called markings so let me just copy maybe viewport here and say markings stop let's close some of these folders here and create a new one in JS markings and in it our file stop JS like this the stop class is also going to be quite simple but the Constructor has four parameters now so it's the center location the direction Vector the width and the height of this polygon let's store these as attributes and then generate that polygon somehow so the direction Vector is already normalized which is nice and height and now first thing for that polygon I'm going to get a support and it's going to be on the segment and and height half of the height towards the front of the segment and half of the height towards the back of the segment so we are going to Define this support as a new segment relative to this center location by translating Center at the angle of this direction Vector half the height and the second point is going to be the same but at a different angle the opposite angle you can either add um Pi here or say that you want to translate opposite way with the minus here let's debug and implement the draw method for this stop where we just draw this um support for now save refresh change to the stop editor and hard to see but it's there this support Vector with half the road width as its height let's convert it into a polygon and to do that I'm going to really use the envelope trick again so we Define a new envelope with this support vector and the width parameter and no roundness I don't need any roundness here and just take the poly from this envelope object and we debug Now by drawing this poly instead save refresh select the stop editor and there it is and I just realized that I don't want this stop marking to be the whole Road I want it to be just on half of the road here for the cars that go this way and they need to stop in this intersection so we're going to need to fix that but this is still useful this could be another marking like maybe the crossing it's pretty much exactly what the crossing should look like but for the stop marking we need some other guides not these graph segments we need something here in the middle between the borders of the road and the graph segment so let's define those new Lane guides the middle of the lane the right lane and the left lane so they will be Lane guides in the stop editor instead of using these we will pass Lane guides and we have to to go to world JS and Define them I will store them here as an array and Below generate here we're going to need the function to generate them it's a private method generate Lane guides and I'm going to use the same trick that we used with the generating buildings with these envelopes so I will copy this here as well these envelopes will be actually half the road WID like this and now we're going to take the union again so avoid those intersecting Parts as before by considering the poly of every envelope and just returning these segments we call this method here and um same as we did with the envelopes before let's empty the lane guides if they exist from a previous rendering and then push I'm just going to spread here the result of generate Lane guides push can actually push multiple things if you pass them individually not as an not as an array and let's quickly debug that these look as they should I'm just going to go here at the end of the draw method and say looping through all of the lane guides segments drawing them in Red Save and refresh and they look good and now when we switch to the stop editor you can see it's centering now on these um Lane guides but the width should be smaller so going back to the stop editor Road width divided by two save refresh switch to the stop editor and now it's good let's remove these guides and start styling our stop marking here I'm going to draw a rotated text saying stop so for that we need to do the translate and rotate trick we first translate to Center X and Center Y and then rotate by the angle of this direction Vector let's begin a path and I'm going to style the text by centering the basine and also horizontally way like this and it's going to be a white text and it will say stop at 0 0 because this translate is already moving us to where we need to be and rotate helps us out as well now let's remember to restore to the original state without these translations and rotations save refresh select the stop editor and you can see now this stop text appearing there but it should be rotated so I'm going to subtract half pi from that and um let's make it also bigger here we subtract 90° and um let's set the font size to be a fraction of the height I I think this should look good save refresh stop editor yeah let's make it bald as well refresh stop editor and good and typically these markings are stretched a lot when they're displayed under the road so that when you're driving and they are stretched like this you actually see them normally somehow unstretched while driving so let's do that as well here after we rotate I'm going to scale this not horizontally but vertically by a factor of two and vertically here means in the new frame of reference after rotating so save refresh stop editor I think we can do even even more maybe three refresh stop editor and uh for some reason it doesn't align exactly how I want it I'm going to give it an offset here and now it's good let's draw also the line on top of it that's the line that the cars shouldn't um shouldn't cross so that's going to be the Border here I will store it as an attribute because this border is really important for the cars to know about so let's put it here at the top and it's going to be the first segment of the poly and now drawing this we don't need to draw the poly anymore it was there just for reference and this one we style I'm going to give it thickness five and white like the rest of the marking save refresh stop editor oh it's not that segment it should be the other one so uh segments of two refresh stop editor that's how we want it but we want to add it not just see this intent here so let's do that next and um we're going to need to go to the stop editor Mouse down and start to implement it so if we are going to press left click left click and if we have an intent here then markings push this intent and I'm going to also delete this intent set it to null in case somebody presses multiple times in the same spot now for this markings I'm going to do a trick here and say that this markings comes from the world markings taking advantage of references here World markings doesn't exist yet so we need to go to world at the top and the world is going to contain markings it's going to be an empty array in the beginning and then in the draw method after drawing these um envelopes the gray F I'm going to draw the markings like so save refresh stop editor and now clicking actually adds the stop there at the intersection now saving doesn't work yet if we save nothing really happens except for saving the graph structure for the markings we're going to have to do something else we're going to implement saving for the markings and actually for the whole world a little bit later it makes sense to group everything together in one one spot but for now we can test them by just still using these uh buttons and and clicking it's not too much trouble I think we added markings how about removing them as well maybe on right click so let's go back to our stop editor and here on Mouse down if the event button is two so the right click we are going to look through all of the markings one by one get the poly of that marking for ease of use and check to see if we clicked inside the poly so if we clicked inside the poly of any marking that marking will be removed so if poly contains Point our Mouse location we splice at I one element we remove it and um now we can just return we don't have to do IUS minus here because we return anyways save refresh stop editor add some stops and remove some stops seems to work but one thing that we should still deal with is um this thing deleting the graph leaves the markings there let's clear them as well so going to index HTML l in our dispose function I'm also going to say World markings length is zero and now if we save refresh stop editor add some markings here and then we remove they all go away one thing that you probably have noticed is that markings can exist without the graph or outside of the graph like this I won't bother with that they are not tied to the graph in any way users should just add those markings after they are happy with the graph structure and in a way it's kind of what happens in the real world as well you may end up with markings in some strange locations for weird reasons I tried coming coming to A solution that is more friendly with this part but it was way too much trouble to teach it and um I gave up instead I'm going to show you how to add some other markings so let's make Crossings Road Crossings next and the way we'll do that is pretty much the same that we did everything up till now for the Stop we have to do it again for the crossing and after that we are going to have a step where I'm going to teach you about refactoring and see the similarities between those and remove the duplicate code you'll see so here let's copy this stop button and call it Crossing button set mode to Crossing and I will put here an emoji of this person walking and now every time this stop button is used I'm going to look for that and enter another entry for the crossing crossing BTN Crossing BTN we will have also a Crossing editor Crossing editor enable and then here this code Crossing BTN Crossing BTN Crossing editor let's look also for this stop editor it has been also used here with this display so Crossing editor display and of course here where we initialize it to uh new Crossing editor Crossing editor and importing the file so I'm going to copy this stop editor here and say Crossing editor and marking stop we will copy it to markings Crossing and in instead of making new files for crossing and Crossing editor I'm just going to Copy Stop and stop editor so let's copy this stop editor and rename it to Crossing editor and let's Copy Stop JS and rename it to rossing JS and in Crossing JS let's edit this real quick so here Crossing now I won't bother with styling it just yet instead I will just draw here the poly without any special Styles and remove what we had previously for for the stop so we're done with this Crossing for now and in Crossing editor we have to rename this to Crossing editor and we already know the things that we need to change to get it to work differently here instead of the lane guides we are going to have to use the graph segments again because it will Center in the middle of the road and here the width should be the full Road width and the object that we create is not a stop it's a crossing the one we just created let's save refresh and now we have the button here and they seem to toggle just fine and when we try adding a Crossing it looks like this but adding a stop still looks polished like what we had it previously removing things Works without actually changing to the other one I find this as a useful thing because it's sometimes uh quite often that you want to add a Crossing very close or instead of an existing other marking so then you can just right click even though you have the crossing editor selected and remove the Stop and create the crossing where you want it so I think this is actually a pro even though the logic wasn't necessarily planned like that now let's style these cross cring in a nice way for that we're going to get a line that is perpendicular to this support line that we had previously and then style that perpendicular line in some way so let's go to Crossing JS here and we don't need this poly anymore we will just get this perpendicular line line from this direction Vector this will also return a vector perpendicular to that one and the logic is actually quite similar to this but I want to avoid using translate and the angle and show you another implementation using vectors and teach you the formula for this perpendicular Vector as well so you could implement it the same way but I want to teach you things so let's have here the line a new segment and now we add to the center point and we scale this perpendicular vector by half the width and then copy this and scale it by half the width but with a minus in front in the other direction so you can see similarities here very much and then let's draw this line now let's implement this perpendicular function it's going to be in math utils maybe here next to translate and it's a really easy given a point we just flip it so to speak by changing these coordinates in this way save refresh select the crossing editor and now we get this perpendicular line there all we need to do is style it pretty much so let's go back to our Crossing JS and add here some Styles like so the width is going to be the height of this marking if that makes sense let's save and refresh select this Crossing editor and now you see it at its full height with the width of the line this is a very thick line now and next we are going to make it white and give it a dashed property like this let's save refresh select the crossing editor and now it looks like that when the cars are driving they will need to make a note of this border and this border here so two borders are needed now we have to record both of them here and I'm going to put them in an array like this let's debug see what we did is working or not I'm going to try to draw here all these borders save refresh Crossing editor and they look okay so no need for this debug anymore and we are done with this Crossing as well but look at this Crossing especially this part right here and the stop this part right here they are pretty much the same and now the stop editor even worse stop editor is very much like the crossing editor the only difference are these Target segments that we use here and the type of marking that is created so let's begin by refactoring this stop editor and the crossing editor into um socalled marking editor and then we inherit from that most of the same functionality let's copy this stop editor like this rename it to marking editor and here at the top this will be marking editor and here where we get these this nearest segment we just pass this target segments the target segments will come from the Constructor so this marking editor will be told what segments to look for and it's going to store them here in an attribute of this object and the second thing that we need to do is add here a method for creating a marker this should be a Dynamic method that will be overwritten by the stop editor and the crossing editor in a different way so this one needs the center location of the marker and the direction and that's it the width and height are things that those subclasses that will inherit from this super class will worry about so I just return here this Center as a point just to have some something but this function will be overwritten to be overwritten by the sub classes so with this create marking function in place we are going to call it here this create marking and it doesn't need these last two parameters and we are done with this marking editor now we go to stop editor and extend so extends marking editor like this and instead of doing anything here in the Constructor we just say super viewport world and the target segments will be the world Lane guides in this case everything else just goes away because after extending marking editor the functionality is there all we need to do is overwrite the create marking method given these properties and I'm going to return a new stop in this case at the center and Direction vector and now we can pass here the row width divided by two and the road width divided by two this square shape of the stop marking and that's it now inside of the crossing editor we do the exact same thing we extend marking editor like this we remove the contents of the Constructor super with the viewport P world and the world graph segments this time so this is the difference and remove all this code implement the create marking function over write it actually it is already there it's just returning Center if we don't do this and return a new Crossing this time at the center according to the direction vector and the full Road width this time and the road width divided by two and we're done with this refactoring we just need to include the marking editor as well so here in index we should include it before the other editors so that inheriting it is possible I'm going to put it here at the top above graph editor and say marking editor save refresh and now everything still works as before but the code is much much better and we can do even better we can refactor the marking as well so in the same way we are going to copy stop here rename this to marking marking and the border is something that is different between all of these markings so I will not have it there and the draw method for this marking we are not supposed to draw these objects just inherit from them but if we do maybe we draw this poly here instead so poly draw and I'm just going to use default styling remove this it's part of the stop drawing and that's it now in stop JS we can extend marking and here we call Super with all of these parameters like so and we don't need any of this except for the Border there so not so much code removal as in the other part but there is some still and let's do the same for the crossing here so extends marking remove this type super copy paste semicolon and now we need to include this marking as well so in the same way I'm going to include it on top of this so markings marking JS save refresh and add some of these markings here works just as before but uh we can do even more refactoring here inside of index HTML you remember all this tedious stuff that we had to do like the stop editors checking where it is and adding the next one next to it in all places and the stop button these buttons and editors I'm going to group them in an object called tools so tools is going to contain now a tool for the graph and this one will have access to the button and the graph editor now the same goes for the stop a button for the Stop is stored here and the editor for the Stop is stored here and finally the crossing the button for the crossing we added here and the editor for the crossing we add it here as well and with this object we can Loop through these values here so instead of having three displays here or like so we can just Loop through all of the tools like this then take the tool editor and display we are not gaining much like three lines here and three lines here these go away but when more editors are going to be added there this will make a difference and of course the effort of typing something new here and remembering that you have to type something there goes away with this implementation now we're going to copy this again here in disable editors here we want to disable not display but also this code for the button we can copy it here and just say tool button tool button and all this code goes away and it should be the same thing now this switch case here becomes much simpler because these values here match those from the tools that I defined on top this was on purpose and that means we don't need the switch at all anymore we just remove it align this better and this is going to be the tool from this mode button style background color style filter and here we enable not the button but the editor instead now save the file refresh the page and everything still works just fine there's something a little bit more that we could do is that this copying here can also be omitted if we just pass directly here the instantiation of the object like so so these are not needed anymore but uh this graph editor is actually called here in this pose so let's remove this but also edit this pose here and say tools graph editor dis poose save refresh try to add some markings and when we press this pose everything still works now the next marking we are going to add is not a kind of marking that you find on the roads really it's going to be a start marking where the selfdriving cars are going to spawn at so we're going to need that in the future and let's see how quickly we can Implement that now that we have this better code structure here we are going to go at the top where the buttons are and I'm going to copy this one and say start BTN set Mode start and repl this Emoji here I'm going to use a blue car because my car is blue and now here in the tools we are going to have to add a new entry for the start using start BTN and start editor we also have to include these two new files here so let me copy this stop editor here call it start editor and this stop marking here call it start and to implement this we just copy the stop editor from here rename it to start editor and the only change we do here is rename start editor and this is going to create a new start and then here copying the stop marking as the start renaming this to start and this marking will not have any border instead it's going to have an image we just display the picture of the car that I drew in phase one of the course so let's store here an image New Image and set its source to car.png and in draw we don't need this border we also don't need this scale but we do go between the rotation and the restore point here and here we draw the image we draw the image like so and 0 0 would Center it so that the top left corner of the image is going to be at this center point so we need to offset it by half its width and half its height I've added an image of a car now here it's this one so we can save refresh and now this button is here toggling seems to work just fine and the car appears there so here we're telling the system cars will come at this location and of course maybe they should respect some of these markings as well now I will Implement four more markings but I will fast forward this part this is what I have now there are quite many uh new things here there is a yield which is quite similar to stop also a barking here the target is where cars are supposed to go and probably the most complicated one is this traffic light here which has a little bit of logic of how to change the colors um I will make a special video for the channel members showing the full process but uh otherwise you can take the code after this lesson and inspect it yourself it's not rocket science but uh the code structure could be a little bit better for the logic of these lights I just didn't bother with it because I'm not even sure if we will use them in phase three it depends how good our neural network works so let's see so far we've been saving the grass in local storage and regenerating everything based on that when the page loads but in this way we lose the markings also we can't save multiple worlds like this and the trees appear randomly and maybe you don't want that not to mention that the worlds can be quite big and generating them when the page loads can be time consuming you'll see when we work with real world data I'm not patient enough to draw such a large graph now so I think that having a way to store the information in actual World files and loading them afterwards is a must you'll see it really Saves the Day done now you have a nice world like this and you want to store it save it somehow with everything all the markings everything we'll do that using local storage as well so we're going to store here as the world item stringify the world it's now here if we type get item world all the information is here from absolutely everything so I shouldn't lose all the things that I have here but of course we need to add this functionality to the save button as well so let's do that inside the save function here instead of saving the graph we're going to save the world and loading the world when the application starts it's going to be pretty similar to what we have done here by loading the graph but we replace these so World string is what comes from world and then World info we take here World string like so and now I'm going to keep this for reference but the way we Define the world and the graph is going to be a little opposite way so so first the world is going to come from World info if it exists then world is going to load from World info in the same way we were loading the graph earlier and otherwise Define a new world with an empty graph like this so now this graph is going to come from the world instead and we don't need this code anymore now World load this is what we're going to do today focus on how to load the information stored there as a Json string so let's go and open world JS and just below the Constructor I'm going to implement here a static method called load with the info and then just return a new world where we load the graph from the info graph like this this is the quickest thing that we could do and get something that actually works now if I go back here and refresh you're going to see the shape is still here but the markings are not there and also every time we refresh the trees are a little bit different so that's something that I don't really like maybe we want to keep the tree locations so that everything is exactly as we as we know it and the markings of course are gone and one more issue with this implementation is that now we do call the world Constructor which calls generate and this does a lot of work really a lot of work for big Maps this can take even minutes and you'll see that later when we we work with real world data but basically when we load this it shouldn't need to generate anything we should just be able to restore all the generated items from this information and that's what we are going to do next so let's begin here by defining an empty world first one that does call generate since the graph is empty there's nothing there really and then start populating the items so the graph this first item right here this one is going to come from loading the graph from the information like that and here we just return this world that only contains the graph at the moment save and refresh and now we get this and this is okay the world just shows the graph because the other things are empty so envelopes Road borders buildings these are not there not yet at least and we're going to need to populate them also these properties should come from our local storage but one thing that you should note is that when I drag this things start appearing again because the generate starts to function again the at from here inside of animate when the graph changes the world does regenerate based on the graph so just for you to know that this is expected Behavior so let's begin by taking all of these attributes now from the info here so this world is also going to get the road width roundness building width minimum length spacing and the tree size from the info in case we want to generate roads with different properties here then they will come from the local storage and now we proceed to generate these envelopes and the way we do that is the same way we did for the graph this load method we have to implement load methods for the envelope as well and make them proper objects not just raw information from this info here so I'm going to say that the world envelopes are going to be coming from the info envelopes which are just info not actual envelopes where we map them so that each element e is going to be envelope load that information now we go to the envelope primitive here and we have to implement a load for it because this generate polygon is also quite an expensive function and I don't want to just call envelope with that information the skeleton for example and regenerate it I'm going to implement here a way to create an empty envelope one that if we don't pass a skeleton then none of these happen and our static function for loading is just going to get the information and generate an empty envelope it will have the type of object envelope and it will have for example the draw and this other method in it but then the skeleton of this envelope is just going to come from from the info by generating a new skeleton from the P1 and P2 of info skeleton like this now technically these should be also cast as points but I think it's going to be okay and then the poly we have to add a polygon load method from this info poly and now we can return this envelope like so and the polygon load method here at the top a static load given the info I'm going to return a new polygon from these info points but I am mapping them now to actual point objects this is important otherwise some errors will come now save re refresh and I have some errors here because I accidentally forgot to remove this I wanted to replace this with World previously and I made the mistake save and refresh and now the envelopes are showing as well now the next thing here in line is the road borders this is is not so demanding because they are just segments so Road borders is Road borders map each border to a new segment P1 and P2 and again I don't bother casting these as points we don't call any methods of those points in our code so I just save some time by not knowing it but the proper implementation would have that cast also here and maybe segment end point should have also this load functionality there that would be the most proper but um I'm starting to want to end this so I can focus on phase three now here the buildings are next let's write here World buildings info buildings map new building by loading it we have to do this here but it's straightforward so in our building item here just give it a static method that loads this info and we return a new building This Time by loading the polygon of the info base and here we have to specify the height as well so that the building remembers its height from the original info we didn't really play with different Heights or anything like that but this makes the code more proper let's save and refresh and now the buildings are there as well without the need to generate them next we have the trees let's do something also here I'm just going to go through each tree and generate the new tree here I don't think it needs any load because the processing that happens for trees is actually in the in the draw so if I open here tree ejs this generate level is called here while drawing and all we need to do here really is initialize this generating the first is just creating a single poly basically so not much trouble to just reinitialize the trees trees can be quite problematic in the generation process because here generate takes a lot of effort for the trees if you remember we had this while loop here that tries to add a lot a lot of trees and it's going to try again and again and again and then reset and again and again but now we are going to tell here which locations to use so that part is gone and if we refresh now we'll actually see that every time we refresh the trees are going to be at the same locations always because now there's no more Randomness at play when loading this world from local storage now for the markings to work we also need those Lane guides they are next in line here actually so let's take the lane guides as well Lane guides we map them two new segments with the same points and now the only thing left are these markings here and um this will be a problem because if I'm going to inspect them here World info markings the ones that I saved we can see that there's no information here telling what type of marking this is the type of object doesn't serialize in JavaScript oh yeah I can tell that this is a traffic light and it was saved with the state of red but um yeah it's just guesswork for many of these or this image I can tell that it's the start because it's the only one that has an image this has two borders so might be a parking or I don't know Crossing could be as well so we actually need to store the type of these markings with the object as well as an attribute and that means we have to open up these markings again and edit all of them and tell this one that this type is a Crossing save and this type is a light and save and this one it's a marking that hasn't been inherited from and shouldn't really be used like this but I will give it a type also for consistency and then this is uh par King and this is start and this is a stop this is Target and this is yield and now if we go back here we need to generate the world and save it with markings that have this type so the original ones are lost forever pretty much let's refresh and add new markings I hope I remember where I put them before these were the traffic lights and um I think I had the parking here maybe I had the crossing somewhere here I don't really know car was starting here I think let's put um let's put the stop let's put it here because this kind of looks like a priority line I think I'm happy with this so let's save again and refresh and the markings are not there but now if we do look in the information that they have the type is there so I do know this thing with two borders now it's a Crossing so we do have what we need to load them into memory as proper objects I'm going to close all of these open files now and in World JS let's write this world markings we remap the information from the markings to marking load M like so and we have to implement this load method next so inside of marking JS here static load the info and here we have to do a switch based on that type that we now have so switch info type and just going to take these in order from here case Crossing return new Crossing at the info center X info center y we have to create a new point and this is the direction Vector X Direction Vector Y and uh the width and the height are like that and I have to copy this for all of them pretty much much and it would be quite a lot of code here and many many lines so I'm going to extract these two longer ones at the top it's going to be the same for all of them all of them have this center location and this direction Vector there for sure short I'm just going to put this one here and now here we can type point there and with and height and close this in one line which is much nicer I think and we can copy this seven times this is going to be now light light marking marking parking parking start start stop stop Target Target and yield yield let's save and refresh and there they are our markings are now here great so this now works but what if we want to store many scenarios many worlds we want to play with this and create a bunch of different worlds I'm going to teach you how to stored them as a file and then load them from the file that you stored them in this is also going to help with memory problems if the world is too big and it doesn't fit in local storage so here inside of this save I'm going to go at the top and uh Define an a tag which we will artificially click to download a world file now the Syntax for this I won't explain in too much detail but basically we will use Json here so I am going to specify that we use application Json and um just in case utf8 and we encode this information like that coming from the string of the current world object now here we generate the file name and it's going to be name. World by default but depending on your browser settings you're may be asked to enter the name when you save the file and then here I'm going to set the attribute to download and pass this file name as well and now we can trigger click which is going to start the download so when we press the save button all this will happen and it will put the world information in a file called name.or but you can change this name just the extension world is important let's now save and refresh and let's save this world file you probably don't see these uh screens here where I'm entering the name but it did save somewhere on my computer so this I have a backup of it and now let's remove it and try to have a new world maybe different looking let's just use this kind of square shape and maybe give it a diagonal like so and let's save this one as well and I'm going to use a new name for that and now when we refresh here I am going to get the new one the first one is lost basically but we can get it back if we Implement load functionality from a file and I'm going to do that here below the save function we are going to have another function called load and this is going to be linked to U file input you'll see we get the first first file from there and if there is no file let's just give here a quick alert that you haven't selected anything and return we don't want to get to this part of the code here so we begin to read the information from the file and we read it s text then unload I'm going to pass this callback function here given an event as the parameter I will take the content of this file like this and parse it because it's a string by default and now we can use this information to load a new world so world is going to be load this new data and what I'm going to do now to prevent reinitializing a bunch of objects is I'm going to set this information in local storage here and then reload the page so basically this button is going to reload the page after it stored the world in the new local storage item here but uh one thing we still need to do is this world needs to be reassigned to something else and it's a const so going back up here I'm going to change this world into a let and this should work to call this function we're going to need um file input and I'm going to put it here and give it also a label for this file input and the class I'm going to make it look like the other buttons in CSS otherwise it's very ugly I think and um I will use this emoji of a folder here and the input itself let's put it like this the type will be file and ID is this file input it will accept files of type world and unchange we call our load with the event information which file did we select now if we save and refresh we're going to see here some quite bad layout happening but let's see if it works so pressing this it asks me to select the file and I'm going to select the first one that I had previously and I got it back great only thing now to style this to make it look like the other buttons and I do that in Styles CSS I'm just going to reuse this style like so and the default styles for these are a little bit different I'm going to for for both of them to have this inline block display and um I want to hide the contents of the file type input as well so we just see that emoji there save refresh and now it looks like that and when we refresh the page we still have this world but now I can change to the other one we created and it's here every time we refresh it's still this one until we change to another one I'm now constantly selecting different files there but you don't see those windows my recorder doesn't catch them one thing I would like when storing these worlds is also to keep the viewport information part of the world itself like how should it be presented because here it doesn't show everything and I always seem to scroll zoom out like this so maybe this world should look like this by default we can do that by storing the viewport zoom and offset information part of the world itself let's go back to index HTML in our save function and here at the top I'm going to do just that world Zoom his viewport Zoom World offset is viewport offset and now let's save this refresh and put again this reference Here and Now save again I'm going to overwrite the previous worlds that's one and the other one like this so now they should have that information in them but if we refresh the viewport isn't adapting to it so we have to do that and also make sure that the world is going to load that information from the info so inside of world JS here I'm going to also type World Zoom comes from the info zoom and World offset comes from info offset and back in index HTML where we Define our viewport here let's pass it also to zoom and the offset of the world and handle it inside of viewport JS in the Constructor these will have some default values in case they don't exist but otherwise here let's just pass that and the offset this is fine if the offset is not specified so I'm just going to say if there is an offset set it to that offset otherwise whatever we had previously save refresh and now we get this exactly as we wanted and the other one works as well thanks for watching if you want to learn how to integrate the selfdriving car with this new world watch this video on my channel you may also want to watch these other two videos that teach how to use real world data from open street map and how to create the mini map I hope you liked this course and if you did please remember to like subscribe to me and to free code camp and share the course with others so they can learn as well see you guys and stay tuned for phase three it will start soon I promise