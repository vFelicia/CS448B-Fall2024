In this video, Brandon will teach you about 10 common JavaScript security vulnerabilities and how to protect against them. Brandon is an engineer at Semgrep and teaches at Carnegie Mellon University. To make it interesting and fun, it's in a quiz format. He shows you a small code snippet and asks you to find the vulnerabilities. Feel free to pause the video to see if you can answer. After that, he talks about the vulnerabilities, explains how they are vulnerable, and provides an example of remediation code. Semgrep provided a grant to make this video possible. Semgrep is an open source code security tool that can find vulnerabilities in your code and your dependencies. How much do you know about software security? Think you've got what it takes to diagnose a real vulnerable application? My name is Brandon. I'm a program analysis engineer at a software security company called Semgrep. In this video, I'll be showing you 10 examples of common vulnerabilities in real code. And I'm here to challenge you on how many of them you can figure out. Your goal will be to figure out both the kind of vulnerability demonstrated as well as how it can be exploited. I'll show you the code and then go over the answers with you afterwards. Give it a try. You might just learn something. All right, without further ado, let's get started. This first example I have for you is in JavaScript, and it's just rendering a simple web app. This is known to be vulnerable. I'll talk a little bit about what it does, and then I'll let you try to figure out why it's vulnerable. So this query params demo, it was demoing query parameters. What's happening is that we're using this use query function we defined and using this use location function that we imported from this React router DOM library. And what that's doing is it's constructing this new object of the URL search params class. Now, the point of this class is that it lets us interface with these things called query parameters. For instance, if our website that this web app was at was https colon slash slash example.com and let's say slash settings or a query parameter is something that looks like this. It's redirect equals foo. What this means is that redirect is being is a query parameter whose value is foo. And that means that when we click on this button over here, we're going to get that query parameters value. So we'll get the foo here and then clicking upon this return home button will end up making us go to that whatever that value is. OK, so, for instance, if this was our overall URL of the website that we were at, then that means that clicking on this return home button would make us go to this URL. In other words, going home. So I'll let you think a little bit about why this is vulnerable, but we'll come back in a second and talk about it. All right, let's get into it. So this code is vulnerable because of a vulnerability called crosssite scripting. Crosssite scripting is when a malicious attacker tries to get code to execute on your machine through your browser. They try to get a script to run crosssite. So in this particular example, this has to do with this query parameters thing I was talking about earlier. In particular, something you need to know about is this JavaScript protocol. The JavaScript protocol means that when you visit a URL that looks like JavaScript colon slash slash everything after the slash slash is interpreted as JavaScript code and executed within your browser. That means that if I were to write do something bad as a function call here, if I visited this URL, it would try to execute this do something bad function, which potentially could be unsafe because it could execute arbitrary code. Now, in particular, if we combine it with this query parameter idea, we know that for this code, for this website, if I click the return home button, it'll take this value from the redirect query parameter and go to it. In particular, though, we might actually take this and put it in place of that query parameters value, meaning that if this were our URL, if we clicked on this button, instead of visiting through or home or whatever, we would visit this, which executes the do something bad or any kind of arbitrary code. That means that someone might give us a malicious link that could execute arbitrary code in our machine across a scripting attack. To fix this, what we need to do is we need to sanitize the URL or validate it to make sure that we're not going to run into this JavaScript protocol attack. So, what we're going to do is we're going to do that by writing this validate URL function, and we're going to take in this URL. So, what we're going to do is first, we're going to create a new URL object using this builtin URL class. And what this will do is it'll give us access to some other information about this URL. In particular, we want to know what its protocol is. We know that if it's a JavaScript protocol, that's pretty unsafe, but also in particular, HTTPS is okay. So, let's say that we're going to condition on whether or not this user supplied URL object, whether or not its protocol is equal to HTTPS. And if it is, then we know we're safe. In that case, we're just going to return the original URL we were given because we know that it's not going to cause an attack. Otherwise, if we're not, then let's just say we return slash, which will essentially make us go home. And then once we have this validate URL function, we're going to pass in the value that we got from the query parameter into it so that we can validate the URL and make sure that we don't fall prey to a crosssite scripting attack. And that's all. Okay, let's get into the second example. So, this is another JavaScript program, and it's just defining a simple web app that listens for get requests. It's going to be listening on this endpoint slash API slash data. So, if we had our previous website as before, example.com slash API slash data, it's listening to these requests. And like the previous example, it's using query parameters. In particular, we're looking at this URL query parameter, which would look like this. So, in this example, if we were to visit this URL, the foo would be what gets assigned to this URL const. And then what happens is the web app will then fetch the data from that URL and then return it, turn it to a JSON and then return it back to the user. Now, going along with this, in this hypothetical example, we have some kind of like internal website where we're storing our data. And there's some publicly facing data. Like we have this countries.json file that is publicly facing, and there's also a states.json publicly facing data. So, if we were to visit these two URLs, what would happen is that the web app would then read in the query parameter and then try to fetch the data from this internal states.json or countries.json. All right, try to figure out why it's vulnerable, and then we'll come back and talk about it in a second. Okay, let's do it. So, this code is vulnerable because of a vulnerability called serverside request forgery or SSRF for short. What that means is that an attacker tries to dupe a server into doing dirty work for them by using permissions that the attacker wouldn't ordinarily have, by getting the server to execute some kind of query that the attacker wouldn't be able to normally do. So, in this instance, I talked about how we have this setup that this internal website has some publicly available data that we're trying to scrape using this web app. But it's not the case necessarily that all of the data is public. In fact, there might be some kind of confidential.json on the server. In which case, if we visited this URL, we would then get this URL from the query parameter, and this server, this web app, would then fetch the data from this confidential.json. And it might be able to do it because the server has more permissions in this case. So, we want to make sure that we only visit the stuff that we're allowed to, this public data, without being able to do an SSRF attack to get confidential data we're not supposed to see. So, to remedy this, something we can do is we can make a const of allowed URLs. And this is just going to be a list of two things. The two, let's say, publicly available data JSONs that we want to see. So, let's put both of them in there, states.json. And then what we want to do is we want to make sure that this URL, whatever we're going to be fetching from, is not not in the allowed list. So, we're going to say that if it's not the case that allowed URLs includes this URL, well, then we have a problem. It's not in our allowed URLs. So, what we're going to do is we're going to do something like we did down here with these statuses, we're going to return res.status 400 to signal there's an error. And we're going to say, error, we got a bad URL, because we don't want to visit this URL if it's not allowed explicitly. We don't want the server to make that mistake. And just by doing that, we make sure that we only visit the public data that we're allowed to without the server being able to give away this confidential data that we wouldn't want to otherwise. And that's how we prevent an SSRF attack. All right, let's talk about the next example. So, in this example, suppose that we have some kind of check token function. Basically, we have some user supplied information specifying some kind of account. And we want to check whether or not the user supplied information has some kind of secret token that matches the account's secret token that's on record. And we're going to use triple equals and return true if it's true. Otherwise, we'll return false. Okay, that's it. Think about why it's vulnerable. And we'll come back and talk about it in a second. Okay, this code is vulnerable because of something called a timing attack. Basically, what happens is that in JavaScript, when comparing two strings, this triple equals function is going to just iterate through each character and compare them. And if they don't match, it'll just return false. So, in particular, suppose that the account secret token was like ABC. Well, then if the token that we supply is like D, we look at A, we look at D, we compare them, we see that it's false, and we return no. But what if it was a little bit more similar, like it was AE? Well, then triple equals would look at both A's. It would say, okay, looks good. It would move on to B and E. Oh, they're not the same. It would return false. But if you pay attention, you notice that it takes a little bit longer before it gets to returning false in the second case because the prefix, this A and A, were actually the same. That means that if a malevolent attacker was sitting around with their stopwatch going, and they had all the time in the world, they could brute force a bunch of strings to try and see which strings take a little bit longer than others, at which point it would figure out that it was getting closer and closer to the real token that it wouldn't otherwise know, a timing attack. So, what we need to do is we want to make sure that that won't happen. We want to make sure that we don't give away information about the token based on how fast we return false. So, to fix this, what we'll do is we'll import crypto from this crypto package. And instead of using triple equals, we're going to use a crypto equality function that is a little less transparent about the timing. So, this crypto timing safe equal function is going to be the same as our triple equals, but it'll be better about not giving away how similar the inputs were. And just by doing that simple one line, two line change, we prevent us timing attack. All right, example number four. So, in this example, we've got a validate token function and it's taking an HTTP request. What's happening is that we're checking the header, the header at this key of token, and we're going to pass it into this buffer.from function, which decodes it from this basic C4 encoding. And then what we're going to do is we also have this sum object thing, which is let's say empty. We want to check whether or not this token that we pass into the server is a member of this sum object. But right now it's empty. So, this should always be false. And then if it were to be in it, we would send true. But because it's empty, we should always send false in this case. But I'll tell you that there's a vulnerability where we can get it to sometimes send true. All right, I'll let you think about it. We'll come back and talk about what the vulnerability is real soon. All right, the vulnerability here has to do with prototype pollution in JavaScript. The idea is that JavaScript is a prototype based every object has a prototype, which is a parent class that it inherits its methods from. Now the idea is that if you if you index in with a string underscore underscore proto, it'll try and fetch that prototype object for you. And even though the sum object is empty, it does have a prototype because every object has a prototype. So if you manage to pass in the string underscore underscore proto, what will happen is that this sum object indexed into it is going to fetch that prototype object, it'll end together with the proto string. And then because those are truthy, this if will actually evaluate to true, and then we'll send true, even though it should have been false, even because we should have been looking for the token in the object, and the token in the object is empty, so it shouldn't have had the token. So to protect against this, we want to make sure that instead of indexing in with this token, we want to make sure that we only look at the properties of the object in question. And it turns out we can do that using this has own property function. So we use this method, we pass in the token and then instead of even if we were to pass in this underscore underscore proto string, it's not going to go and fetch the proto, it's going to go and just check whether or not that property exists in the object. And because the object is empty, this will never evaluate to true, and then we'll never send true. And that's how we prevent the prototype pollution attack. Alright, example number five. So this is another JavaScript program that is just a simple app that's taking in post requests from slash user. What we're doing is we're looking inside of a database of users to try and find users whose username matches the thing that's in the request. If we find it, then we just send it back. Otherwise, we're going to send an error message. Alright, think about why this one's insecure, and then come back when you're done. Alright, so this code is vulnerable because of a vulnerability called a NoSQL injection, which is basically like a SQL injection, but not limited to just SQL queries. In this case, the user could possibly enter a query that could allow them to access things that they shouldn't. In particular, what's happening is we're finding every entry, every document in our users that has this username matching rec.body.username. But it's not guaranteed that rec.body.username needs to be a string. In fact, what it might be is it might be this object here when we have $ne to null. And what this means is this is a special MongoDB operator, where $ne means not equal, not equal to null. In essence, if we were to try and find with this query instead, we would find every single instance of a user in our database that had a username where the username was set. This is really bad, because we're not just finding the username, we're finding things by the username, but finding all the data associated to it within our database. That means that this username could be paired with all sorts of sensitive data, like credit card number, like social security number, like date of birth, stuff that we're not supposed to see. So what we want to do is make sure that someone can't abuse this database by putting in some malformed query, something that's not a string, essentially. So what we can do is we can do if type of rec.body.username, and we can case some other that's not string. And if it's not a string, then it could be one of this MongoDB operator stuff that causes them to scrape data that they shouldn't be able to see, in which case, what we'll do is we'll return the status 400 on them, and then we'll say, we'll return a message that says, this is a bad username or an invalid username. This way, people can't access stuff that they don't want, and we're only constraining requests that are actually usernames that they want to look up. This way, we prevent the NoSQL injection attack. All right, challenge six. So we've got another JavaScript program here, and we've got an app taking in post requests at slash validate email. Now, what we've got here is assume that this regex is a gigantically, incredibly complex regex that happens to validate emails. And what we're doing is we're taking in this rec.body.email in the request, and we're checking for whether or not it passes against this regular expression. If it doesn't, then we'll say invalid email and complain, and otherwise, we'll send back valid as true. Okay? All right, try to figure out why this code is vulnerable, and then we'll talk about it in a second. All right, let's talk about it. So this code is insecure because of an attack called a redos attack, or regular expression denial of service. What this means is that this regular expression is really complicated. Don't worry too much about what it does, but it might take a really long time to validate certain inputs because the regular expression has to try out a bunch of options. It might take a very long time, depending on what the input that is being fed into it is. And because the input is under the control of the person making the request, this is not within our control and could potentially be crafted by some malicious attacker leading to denial of service, because we might hang on certain inputs. So instead of rolling your own regular expression and doing this whole thing, what we can instead do is we could say we could use this validator library, which is very efficient. And then what we'll do instead is of instead of using this email regex test, we're going to say, if not validator dot is email, which is a function that already exists. And then this way, we can test for whether or not it adheres to the email structure, both without needing to roll our own regex, and also while ensuring that we can do so relatively efficiently and prevent these denial of service attacks. All right, example number seven. Now, this one's actually not in JavaScript, but it's a Dockerfile that's running in the root directory of some node.js application. And what this Dockerfile is doing is it's going to create an app directory. It'll copy the package.json, describing the app dependencies to that directory. It'll set the user privileges to root, run npm install, copy the source of the app to that directory, and then run the app on port 8080. Okay, think about why this code is vulnerable, and then we'll come back to it in a little bit. Okay, so this code is vulnerable because of a potential security misconfiguration. This happens because when we set the user permissions, we set them to root, which means administrator level privileges on this whole Docker image. This is really bad because something that happens afterwards, like npm install, or even running the server itself, we could be installing some kind of malicious package, or we could have a vulnerability within the app itself. If this happens, that means that because this whole Docker image has these administrator level permissions, this could potentially have disastrous consequences for the machine that we're running on. We don't want to give away administrator privileges willynilly. So what we can do is instead of doing that, let's run with just user level permissions so that we don't have the potential to wreck everything, if there's something malicious going on here. And by doing this, we prevent the security misconfiguration vulnerability. Okay, so this code is vulnerable because of hard coded credentials. We see here there's this const secret that we have here, my super duper secret key, it is pretty secret, but not secret enough, because we have it in our app source. In general, it's not a great idea to hard code secrets like this inside of your application code. If you were giving up the source, you'd be able to see it. If you were giving out even a compiled version, it'd be quite possible to reverse engineer the precise value, which means that your secret would get leaked, which is really, really bad. So what you want to do is in general, it's a better practice to use something like environment variables. So we could write something like process dot n dot JWT token, which means that we're reading the environment variable JWT token to find the identity of the secret, but it's not within the app source itself. This is both more secure for the reasons I mentioned earlier, as well as it makes it easier to swap out the token if we so need to, for instance, if we were to compromise our previous token. So just by using something like environment variables, we no longer have hard coded credentials. And this is no longer a security vulnerability. All right, example nine, we've got another JavaScript app that's taking in post requests at a slash sign up endpoint. And what we're doing is we're looking in a database of users to find a user whose username matches the username given in the request. And then what we do is if there's an error, we do some error handling. But otherwise, if we don't find that user with that username, then we just insert the rec dot body as a new user. And then we return success, try to figure out why this code is vulnerable. And then we'll come back in a second. Alright, so this code is vulnerable because of something called a mass assignment attack. Mass assignment is when user input might be able to set properties on an object that it shouldn't be able to. Now, we the reason why this happens is because we're looking up usernames by the rec dot body dot username. But if we don't find it, we insert the entire rec dot body object. Now, suppose that our database has a few things in it associated to a username. It's not just a username, but also let's say a password, an email and an is admin flag. Now when we insert the entire rec dot body, this could potentially be an object that sets this is admin flag that should not be able to be set by just anybody, nobody should be able to just make themselves an admin. But because we insert the entire rec dot body, we don't have control over this. And someone could specify all these fields together. So what we'll do is instead of inserting the entire rec dot body, we'll make a new object that only sets the things that we know are safe. So we'll set username to be string of rec dot body dot username, we'll set email to be string of rec dot body dot email. And let's also say that we set password to be string of rec dot body dot password. This is cool, but also it's probably not a good idea for us to store the password in our database in plain text. So what we can do also is we can do import encrypt password. And supposedly just have this dot slash utils, slash passwords thing lying around. And we have this encrypt password method. And the next thing we'll do is instead of storing the password as a string, we're just going to call encrypt password on it. This way, we prevent ourselves from the mass assignment attack. But also we encrypt the password so that it's not stored in our database in plain text. And just like that, we prevent the security vulnerability. All right, by example. So here we've got this web app that's taking post requests, and they're taking a generate password reset URL link. What's happening here is that we're trying to generate a password reset for some kind of customer for some web app. So assuming the customer exists, we find the customer using the email, and then we get the password reset token via the customer's ID. What then happens is that we generate this reset password URL using this rep dot header dot host. Using password reset, we just make the URL out of string interpolation, and then we send back the URL in a JSON object. Try to figure out why this one's vulnerable, and then we'll talk about it in a second. Okay, so this code is vulnerable because of a host header injection attack. The reason why this might happen is we use this rec dot header of host. So we use the host header basically as one of the parameters to this URL. But this is actually under control of the person making the request in possible control of the attacker. By convention, this is usually just going to be something that's safe, but this could be changed by the person who's making the request. So in general, it's not a great idea to use the host header, because this could be used to send back a malicious link that then when clicked on could send the user anywhere. So best not to use this host header. So what we want to do is we want to use something that's more robust than just using the host header of the requests we're getting from the user. So suppose that we have this process dot m dot host URL environment variable lying around, it would be a lot safer if in the server in the web app, we were referencing this host URL instead of looking at the host header given to us by the request itself. By doing just the simple step, we prevent the host header injection because we're no longer using a potentially malicious source of data. Alright, that's it. Alright, that's the end of the video. I hope you managed to find all 10 vulnerabilities, but definitely leave a comment below on how many of them you managed to figure out. If you want more resources on how to learn about security, they'll be linked in the description below. But definitely check out some of the other videos that bring code camp has their excellent resources for learning more about computer science. Security is something that's becoming more and more important by the day. So taking the time to educate yourself now can pay off a lot in the future. Thanks so much for watching the video. I hope you learned something more about security and till next time.