all right welcome to lecture nine of gd50 today's topic is dread halls um so last week we ventured into unity our first foray into 3d and not only 3d but also just getting our hands around um our heads and hands around the unity game engine which is uh among unreal and others sort of the most popular game engines in use for 2d and 3d games um and last week we did sort of a 2.5 d style helicopter game whereby everything was in 3d but we were still aligning things based on just two axes the x and the y i believe um possibly the z and the y i don't remember but two axes versus three axes today we'll actually be diving into using all three axes available to us in unity 3d in the context of a game called dread halls and so what dread halls is is a v it was a vr game actually the first vr game that i ever played um on the oculus the the gear vr samsung gear vr and it pits you in sort of this dark and eerie 3d maze where you don't really know what's going on and you can go around and get collectibles and encounter creatures and stuff as you can see in the bottom right screenshot there today's example is going to be a little simpler but it allows us to explore things like procedural maze generation and first person camera controls so last week recall we were using sort of a three a third person camera whereby we were sort of far back on the scene today we'll actually be using a firstperson camera where the camera is effectively our eyes as if we were walking around in the maze ourselves unfortunately we won't be using a vr demonstration this week but next week i hope to put together sort of a vr sampling using this project so we can see how this works in vr and how unity's toolkit works in vr so some of the topics we'll be covering today we'll be talking about texturing so recall last week the helicopter and all of the items in our game were just sort of flat colors they didn't really have any textures associated with them we'll talk about how to assign textures to materials and how to apply those materials to objects in our scene we'll talk about materials and lighting so not only materials but also the different kinds of lights that unity supports and a few details about those we'll talk about again 3d maze generation so we'll have a simple but effective algorithm for creating a 3d data structure to represent our level as opposed to previously where we had just a you know a tile map that we could generate to give us the appearance of walking around in some sort of 2d world now we'll actually perform a similar operation on data a 2d array but we'll take that array and we'll actually create 3d blocks and create a maze that we can walk through in 3d space which is kind of fun and interesting last week we only had one scene in our game so which was just a play scene and even though we had sort of like a game over state within that scene we didn't transition between scenes we just sort of reloaded the same scene today we'll have a title screen and a play scene which sort of um is an evolution of the idea that we had in love 2d where we had a state machine that was governing our entire game um in terms of the different states that we could be in whether it was the title the game over the play state and so forth unity does the same thing with scene objects which are effectively a snapshot of a series of game objects aligned in a particular way in the editor we'll talk about fog and also global lighting and certain other things that allow us to create a atmosphere conducive to the sort of feel that we want to get in our game today which is sort of creepy and eerie and lastly when we talk about how to create ui elements in the game we'll talk about unity2d it's canvas object and text labels and some other things and how those all operate which is sort of two sides of the same coin unity 3d also comes bundled with unity2d a set of tools used to make not only 2d games but also 2d interfaces that you can apply to your 3d games so first a demo now i've been sick for the last week so i'm not going to ask for anybody to come up and demo just because i don't want to get anybody else sick so i'm going to just go ahead and show just this lecture the game that i put together for you so here i have two scenes notice here i have a title scene and a play scene i'm in the unity editor right now i'm going to load up the title scene here which i've done and then notice that it has sort of a game view and a scene view i'm going to hit play i'm going to make sure that it's set to maximize which it is and so we have sound here so we should hear audio and hit play and notice that we have sort of like this ambient creepy music track playing we have a very we could have easily done this in love2d this is just a black screen with two uh text labels on it um and this is done with unity's 2d ui toolkit and so it says it tells us to press enter so if i press enter we instantly get teleported into kind of like this maze this creepy looking maze and so i can walk around in this maze and there are a few things going on so anybody um can anybody tell me some of the things they noticed about the scene what jumps out at them what are some of the elements if you were to put this together yourself where would you start what are the pieces that we can put together here yep there has to be a ground that you can stand on and there is so we're generating uh not only walls in our scene of course but we need a ground to sit and obviously and also if you look up top it's kind of difficult to tell but we also have a ceiling so ground and a ceiling and walls some kind of lighting yes and so in in this case we're actually using ambient world lighting as opposed to having a light source so we'll take a look at that last in last week's lecture we used or two weeks priors lecture we used a directional light object but in this case we have no lights in the scene we're actually using unity's world lighting which we'll take a look at soon when we walk around notice that i can move my where my camera is looking with my mouse so we're actually controlling the camera with a first person controller an fps controller which is actually a component that unity provides to you and then notice eventually if we keep exploring the maze we come across this little thing here which is a um sort of a pickup and when we pick this up we get sort of like this piano weird creepy piano sound and then the scene reloads um anybody notice anything about what we see in the distance like how that's how that's affected like if i'm looking at this wall right here for example it's kind of hard to tell but as opposed to like down this hallway what's what's the difference there the light source is further away i guess the light source is further away kind of so we're what we're experiencing here we're seeing is uh it's a a graphics a sort of concept called fog and so what fog lets you do is it effectively adds color to the scene based upon how far away the objects are in the scene it multiplies color onto them and it gives you the illusion of looking in look as if you're surrounded by fog basically and it's been around for a very long time back even as far as the n64 days and we'll talk about that um later today and it's actually incredibly easy to add that into a game with unity and its world lighting system any idea as to how fog not only in terms of aesthetics but how it could maybe help with performance yeah you don't need as much pixel clarity because it's already blurry you don't need as much pixel clarity um kind of the the big thing about fog and the way that it was used a long time ago is that because eventually things are completely opaque beyond a certain point you don't need far draw distance in your game so you can actually like dynamically you can you can emit rendering things that are a certain distance away because you wouldn't be able to see them anyway and so this was an optimization technique used a lot back when draw distance was a huge bottleneck on computers and gave video game consoles back in like the 90s for example like silent hill the game for ps1 was almost exclusively fog and you could see very little in front of you and we'll see a screenshot of that later and they use that for um to boost their performance and also to provide a certain aesthetic and then one other thing you might be paying attention to is there's a sound on loop just sort of this creepy sort of whispering sound and that's to um just add atmosphere right just because without it we would you know it's little things like that especially in horror games like this the atmosphere can be everything so with very simple ideas fog some whispers first person controller sort of tight hallways you can produce something that's pretty scary now there are a few things missing from this namely there's nothing that's going to come at you and attack you but it would be not terribly difficult to add but because we're using procedural generation you would need what's called a nav mesh and you would need to generate that procedurally so things could follow you in 3d space we might have some time to talk about how to do that a little bit later today but that's not implemented in this particular lecture but it would be not too infeasible to accomplish but those are some of the pieces that we'll take a look at today so that was this is the title scene notice that there's uh not a whole lot here actually so if i zoom back out we can see you know canvases are huge in unity just because it's more optimized for the engine to render them that way but we can see even though it's a 2d sort of ui it's very visible in 3d space and if we click this button here we end up getting uh oh no that's that just brings us into sorry click this button here that brings us into sort of the 2d unity 2d mode so now we're interacting with things in 2d and i can actually click on this label and move it around in 2d as if we were using a 2d game engine as opposed to a 3d game engine so we'll look at that a little bit later this is the just the title scene so the play scene itself i'm not going to save that the play scene itself i'm going to go from 2d back to 3d here is pretty much empty so we have a first person controller here this is the fps controller object does anybody anybody tell what basically constitutes an fps controller just by looking at the scene here what are the some of the pieces that jump out at you i thought you just put the camera right where the player is or right in front of the player exactly but the camera right where the player is effectively where their head should be relative to where their body is and their body what's constituting their body here can you tell it could just be uh it looks like a cube in the middle there it's this it's actually this capsule right here i don't know if you can see it uh there's this capsule here this green capsule it's a little bit more organic feeling than a cube necessarily but you could use a cube as well but a capsule is how uh character controllers in unity are represented and character controllers sort of come for free in unity which is really nice they're part of the standard assets so if you go to import package in unity if you're going to assets import package there's a lot of packages that come for free that sort of bootstrap you notice there's like 2d packages cameras characters the characters package has 3d characters uh are thirdperson characters firstperson characters some that are physicsbased some that are not physicsbased this particular controller is not physicsbased meaning that we don't apply forces to it we move it around it's kinematic it can't it is affected by gravity so in a sense it kind of is physics based but it's not strictly physics based like a rigid body and a rigid body would and the collisions that occur between this and another rigid body aren't the same as they would be if we were to make this a purely rigid body based character controller there is a purely rigid body based character controller that you can import i haven't experimented with it a lot but you could probably figure out a good use for that in terms of a game or maybe you want to move precisely on surfaces that have different materials like icy surfaces or whatnot and have it apply it in a very physically realistic way another few things that we have here in our play scene we have a dungeon generator object so this dungeon generator object is just an empty object with a level generator script here and then we have a few other objects a floor parent a wall's parent and a whisper source so we'll get into the details of what all of those mean our goal today we'll be talking about a few things so we'll be talking about here's a picture of just our maze so we talked about some of those things at a high level we'll actually explore how to implement them in unity today so making a maze making the fog effect walking through it with our character controller we want to be able to have some kind of game play here so we have collectibles in the form of this red coin it's actually part of another standard assets pack they prototype assets pack it comes with a prototype little coin object that you can throw in anybody notice anything about this uh coin beyond the fact that it's uh you know just a sort of red coin what else do you notice about this scene here it's emitting a glow any ideas as to how it's emitting a glow it's a light source inside of it exactly so we'll talk about that we'll show you how that's implemented very easy to do in unity and then we'll also talk about towards the end our 2d scene our title scene and how to construct it which is actually very easy in unity as opposed to doing something by code you very rarely actually for interfaces need to touch code at least in terms of how to lay them out in unity you can do everything very visually and with the mouse it's actually it's a it's a pleasure to make you interfaces if you're used to just making them in in code so texturing so last week or two weeks ago we did nothing with textures it was well that's not true we had one texture on the background which was the sort of scrolling background but we didn't really look at that too much in today's example you know the helicopter and the coin and the um the buildings and all that stuff those were all just polygons with flat colors associated with them today we'll be talking about how to actually texture things with materials and so this is very easy to do in unity so i'm going to go over to a to my title scene here just because it's fairly it's it's lit in a fairly normal way as opposed to the play scene which is not lit in a normal way because we're using environment lighting we don't have a sky box the title scene has a fairly normal light a lighting setup so if i add a cube here to the scene so you can see right off the bat by default we do get a material here which has an al what's called an albedo component albedo just means like what's its surface color look like it has a much more technical definition and you can look up on wikipedia what albedo means it has something to do with the way that light interacts with surfaces there's a lot of other elements here you can make something look metallic you can make it look smooth or rough and you can also add normal maps height maps and a few other things which gives it more of like a bumpy texture and so forth and you can also make things emit uh light this way which the coin actually not only emits light but also is a light source so it does both and there's a few other things here for example let's say you have a very large cube and a small texture if you put a very small texture on a large cube what's it going to look like what's your instinct if we have a very large cube at a very let's say we have a 64 by 64 pixel texture but our cube is humongous what's that what effect is that going to have on the cube it's going to look kind of like an n64 cube right it's going to what basically happens it's going to interpolate between the texture pixels the texels when you apply a texture to your cube and so when you apply a small texture to a large surface it's going to look stretched it's going to be it's going to look stretched and like it's going to look also filtered as it like you sort of see in some youtube videos if you watch them and they recorded a very small resolution but you blow them up they look filtered or if you've ever stretched a picture in the right software and it's looked it looks interpolated and filtered it's going to have that look so you can do is you can apply tiling so here we can see there's a tiling element x and y so of 1 in the x and y direction because it only applies on a flat surface so the effect of tiling would be such that if you have a 64 by 64 texture you could just tile that texture several times to get the desired look that you want on whatever surface that you're trying to look at in your game world maybe it's a very small object but maybe it's a very large object that you're looking at as a character and you want to tile bricks for example or you know stone so to apply a texture to a to a 3d object in the scene i'm going to go into here so you need a material first and so these are all unity material objects you can tell because they have a circular they look like if they've been wrapped around a sphere these are all unity materials as opposed to textures textures are just 2d objects 2d you know textures 2d images so this is part of a an asset pack that i downloaded for this lecture called dungeon modules low poly dungeon modules which is in the asset store and so what i'm going to do is i'm just going to apply let's say i want to just apply this rock material to this object right and i go over to that i'm going to first add a i think because i went into the material uh had a incorrect appearance so do that oh that's strange i'm going to create a new scene and then i'm going to add a cube and then a not pop but maybe the beam i wonder why it is not that's very strange for some reason it might be a setting that i have enabled that's not allowing it to correctly render but the effect of that should be that we apply normally if you apply a um uh a texture to a material it'll have the effect of creating it'll instantly texture it but what i can do is i can go to textures here and this should work too i can go to that and then it'll apply it that way so normally if you're in a fresh project and you add a new 3d object and you just click and drag a material onto a 3d object it will texture it for you in this case i think because it's automatically assigning a material to these objects based on some project setting that i'm off off the cuff just unable to i don't know for sure you can instead just go to the albedo component here so albedo functions not only as a color but also as a texture for your object and so you can apply a texture just a 2d image to your albedo component of a material right and that'll have the same effect as texturing it immediately so normally what this is supposed to do is create a albedo create a new material with that texture as the albedo when you set a material to the 3d object now i wonder if i yeah i'm not sure i'm not sure exactly why uh it didn't work as uh like right off the bat like it's normally supposed to in a fresh project it will i'll try to investigate but if it ever happens like that where for some reason you're i think it has to do with the way the shaders are set on here maybe there's a setting i'm just not sure about but you can just set the albedo component here manually and it'll have the same effect so the albedo component of your material setting that with a texture textures objects and so that's effectively how we get from this sort of look of a flat shaded or flat color shaded object to a texture shaded object just like that and texture mapping sort of in itself is a very wide field and fairly complicated but ultimately it looks something like this so does anybody can anybody tell me what this looks like here so we see here obviously we have a fully textured model but if we're looking at this what does it look like we've done here so what does it look like ignore all the lines but what does it sort of look like we have on this surface it's just a texture right we can see whoops we can sort of see the colors here for example maybe the his belt here or or actually that looks like the top of his head here this being the top of his head and then we have like his belt and other things this right here we can pretty clearly see that's like sort of his face mask right but it's just on a 2d surface like this is a just a regular texture and so what we've done here is basically taking all of the polygons that comprise the model and sort of laid them out flat right lay them out flat as if on a table where our texture is and that's what uv mapping is and this is usually something that you do in whatever 3d modeling software that you're using in unity when you apply a texture to a material or a material with a texture to an object it will use its standard um it has its own builtin like mapping algorithm that'll apply material to a model and so it does it differently for different objects we can we can create a like a sphere for example move the sphere over here and i'm going to try again and just to see if the uh applying the material works on that no it doesn't so applying a so if you go into this material here which is for some reason grayed out um new scene again create a new 3d sphere and then oh this time it looks like it's i can't tell no i don't think that's working um oh now it's now it allows us to accept a texture okay so we can apply a texture whoops we apply a texture to that and so now we can see our sphere has been mapped as well and it looks fairly convincing it's been wrapped around it in a way that doesn't look too distorted or too weird and so unity has its own ways of mapping for its primitive objects whether it's spheres cubes we have a few other ones capsule cylinders planes and it'll depend obviously on where your texture is if your texture is fairly ornate it might end up looking distorted but for most purposes for simple primitive objects for most textures it should work pretty well now if you imported a model that was like a table or character and you just applied a texture to it it's not going to look good it's going to look messed up and so your 3d software will export a material with the model assuming that you've modeled in that software with a texture it'll actually give you a material that you can then reference that will properly apply a texture to your character but the same sort of apply a texture just a regular texture to a complicated model just isn't going to work because it hasn't been uv mapped in a smart way unity's not going to know i have a table i want to map i want to map the texture to the table in a you know in a way that looks convincing you can see this kind of if we create a cube and then if we go ahead and i've been making it apparent for some reason uh if we go up here i'm gonna first assign uh okay for some reason that worked instantly um but you can see we've applied a sort of wall texture to it and then if we scale it down so this is the scale button up here so we have um you can move rotate things if unfamiliar the uh sort of these top buttons up here are transform operators so you can move things scale or rotate things and scale things so if you scale this along the you know this yaxis a bit and then you zoom in the texture looks pretty compressed and distorted because it's just doing the same algorithm and assuming it's the same kind of surface without taking into consideration how it's been warped right so ideally you wouldn't have the sort of like flattening thing this this flattening happening and so in your 3d software you would unwrap your model and then um apply a texture to each separate polygon of your model in a way that looks convincing and so this isn't anything that you necessarily have to do um for the lectures for the demonstration for your project but if you are creating your own 3d assets if you're importing 3d assets and if you want to use textures in a way that we're doing today you will need to probably become familiar with uv wrapping uv unwrapping uv mapping in whatever software that you're using and if you're just unfamiliar with it in general and have wanted to know sort of what goes on in turning a you know flat white polygon character into something that has a texture this is effectively what happens you unwrap it make it flat sort of like stamp the material onto it effectively and that be they know that maps the uvs of the texture sort of the textures virtual coordinates to your 3d model so any questions as to how this works at all or about unity and um applying textures what's the general way that you uh you make the the textures on the right where it's kind of like you know it's like a world that's been flattened how do you make the textures on the right that i mean that's kind of an art form in itself you you do have to do it by hand um and sort of know i mean there's a good amount of trial and error that'll go into it too as you're making your model and sort of unwrapping it and noticing oh this looks weird as i'm applying this polygon to the surface i'm gonna go and change that texture but you could use any you could use or photoshop or any standard texture creation software and kind of just um it's something i don't do a lot of it but it's something that i imagine that you just get better at with time and artists texture artists and modeling artists probably have developed sort of like an attuned sense of what makes a good texture versus what doesn't generally you'll make the model first and then you'll make the texture so okay so we already talked a little bit about models uh sorry about materials um we'll we'll go back over it really briefly again there uh there is a resource that i really like and i think does a really wonderful job of teaching beyond far beyond the basics of unity and that's catlitecoding.com and it's totally free they just have a bunch of free articles on there which are very indepth and this is a screenshot taken from one of the articles where they talk about how to make really interesting materials so you can see here this one on the left it looks very you know it looks like a fireball like it's made out of magma and it's got bumps on it it has contour you can see that there's sort of like a glow to the fire on it on the right you can see that this model has um sort of conditional shine on certain parts of it like the metal part of it is shiny but the rest of it isn't and so like how do we make certain parts of the material shiny how do we make certain parts of it flat the article goes into depth on that and effectively what they do is they use several layers of maps like a shininess map which is a texture that tells that you reference in a unity custom shader that you write which the article teaches you how to write which will make certain parts of the texture glossy and certain parts of it not glossy so matte and so you can do a lot of really cool very interesting things and unity's shading system is very um sort of the sky is the limit i mean because it's effectively a standard shader language like you would it's effectively the same thing as hlsl i believe which is high level shading language which is a if i'm not uh microsoft originally came up with it and it's very similar to glsl which is the opengl shading language um and so what these are effectively is just little programs that run on your graphics card we talked about this before but they tell your scene how to process lighting for the objects that are within it and everything in unity has a shader associated with it even if it's just the standard shader which by default is just a white color but you can write your own shaders and you're capable of virtually unlimited possibility and the this effectively is all a shader and it's all a shader that's been written in code but we have a lot of these variables that are exposed to us and albedo is one of them and albedo is sort of conditional if it if it gets a texture applied to it it will just render that texture but if you apply color to it it will apply that color to your material and so that's how you can get you know textured things versus nontextured things metallic just computes shininess and reflectivity off of surfaces and that's just something that's written into the shader and produces the lighting responsible to make that happen and all of these different things are just part of a single shader and a material is effectively a shader they're kind of one in the same a material is a little bit different in that you can also specify how its surface should interact with other things so for example if you're in an ice level a material can not only be like the glo the sort of glossy icy look of something but also how slippery is it when i walk over it and should i slide and how should other things interact with it that have physics so like those two sort of hand in hand are sort of what a material is but um likely as you're starting out the only real things that you'll need to consider and you're sort of bound only by your curiosity are albedo and maybe metallic and maybe emission and then depending on how much you how big your thing is and how small your texture is maybe tiling and then recall last week we manipulated offset so offset is how much the texture is shifted and recall it loops around back to the other side and so by manipulating offset on the xaxis we were able to get a scrolling infinitely scrolling texture right and so all these things have their uses and pretty much everything in unity has its uses it's a very vast tool kit to use but those are probably the important things that you'll see and this article and many others on this website which i highly recommend if you're looking to get really deep into unity will give you a lot of insight into how things work far beyond just the surface level there so any questions on materials all right so we're going to take a look now at lighting so materials materials are one part of the equation so that's sort of defines how things should look when light hits them but we also need light itself in our scene to illuminate things and so this is taken from another article on cat like coding on rendering and so this is a scene with a lot of lights a lot of glowing lights emissive lights and there's a lot more going on here but this is a another great series of articles on how to understand the lighting model in unity and it teaches you a lot it teaches you almost you know down to the very bare ingredients of the sort of the software and the rendering if you want to go that deep i certainly haven't gone through every article because there's just a tremendous amount of content it's very deep but if you're looking to really um if you're looking to really get a sense of how it works i would i would encourage you to explore that so we'll look at a few different types of lighting beyond the more complicated things that this article talks about we'll look at the different styles of lights which you'll probably use more often as you're starting out so point lights anybody have an idea as to what a point light might be based on this picture uh it's not pointing in a very specific direction that's actually a spotlight so a point light is a set a source of light that actually uh shoots out in all directions around it so it emits light in all directions but within a confined area at a specific intensity a spotlight shines light in a specific direction so only one direction and what's interesting about spotlights is you can actually apply what's called a cookie to them and what a cookie does very similar to what the bat like the batman light does it allows you to apply a texture to a light and therefore cast shadows specific shadows on the light so if you wanted to make like something like the bat signal you could put the bat man icon cookie on your spotlight and it'll shine the light but the bat uh the batman logo will be in the middle of it it's effectively the same thing as taking a literal spotlight and putting a object onto it it produces a shadow a manual shadow it's called a cookie yep um a directional light so anybody know what a directional light is so despite its name it's actually not not the same thing as a spotlight so directional light we used a directional light last week actually last lecture directional light casts light in a single direction but throughout the entire scene as if it's the sun so this allows us to illuminate globally the entire scene but all light gets cast from one direction so if you want to produce the appearance of daylight in your scene just a single directional light will illuminate everything and then the last thing which is used less is called an area light so does anybody know can anybody guess what area light is based on this picture here yes so it's light that's only on the surface light that's only on the surface kind of yes so it's light that will emit from the surface of a specifically designated uh rectangle effectively in one direction so you can define a large area for example maybe like maybe you want like a wall strip in your game or something along the wall to emit light specifically uh to the left or something like that that's what an area light is capable of now area lights are computationally expensive and so you can only use them when you bake your lighting does anybody remember what baking means when referring to lighting so baked lighting just means that instead of realtime lighting calculating things dynamically the light gets calculated one time and saved and almost like freezed onto all of the objects in the scene and so there are pros and cons to this what's a pro to baked lighting do we that's think computationally intensive less computationally intensive what's a downside to baked lighting it can be dynamically affected can be dynamically affected so if you're walking through a baked lighting scene and you're expecting to cast a shadow on something or for something to cast a shadow onto you it's not going to happen because the environment's already been pre the lighting for that scene's been prebaked it's almost as if we've just recolored the world in a specific way but we're not actually doing any lighting calculations but this is how lighting worked in like the n64 era and it's how it still works now for certain situations if you know nothing's going to cast a shadow on something you can make really nice looking lighting for a scene without needing to do it in real time you can just bake it right so those are the different types of lights so we can see that in unity so if we go here i'm going to so right now we have a directional light so this directional light is this object here by default all um and you can zoom in as much as you want but it's sort of like um oh there we go this directional light is only shining in one direction so i can move it here so currently i'm in um it's a little bit weird to navigate just because it's been rotated a little bit given that it's a directional light it's rotation so notice how it changes so if i shine it upwards notice that everything comes black because the lighting is just shining upwards right so as if it's coming from below and if i shine it towards there notice that the the lighting on the the sphere and the little cube there sort of change a bit right because they're getting affected by the direction of the light a little bit but they both get affected the exact same because the directional light is omnipresent it's throughout the entire scene it's a global object now if i delete the directional light notice we have no light now so these things just look kind of like statically shaded you can add a new light through if you right click in your sort of game object view and then you go over here you can see we have all the different lights we talked about there's also things called reflection probes and light probe groups and those are a little bit more complicated but those allow you to effectively get pseudo real time lighting and reflection with baked lighting and reflection we won't talk about those in today's lecture but here's a point light for example so let's see where is it that's right over here so i'm going to move it over here so you can see it's not global like the um directional light was right it's just affecting this very limited and i'm going to zoom in a little bit so you can see a little bit better but it's affecting just sort of these two objects relative to where its position is right and so this works perfectly for things like lamps in your scene if you want to have a street light or whether you want to have maybe like a fire going on in a house or if you want the you know like the power up that we had in the uh or the pickup that we had in the uh unity scene right we have just the it's just emitting a purple light that um is within a very small radius notice here we can uh change the color of the light so if i make it like that for some reason oh there we go so we'll do that so notice now it's emitting a purple light so you can color a light however you want to produce whatever effects you want so fire is not going to emit white light it's probably going to emit like an orange red light street lights are probably going to emit kind of like a yellow orangey light so depending on what your scene looks like and what you're trying to emulate you can accomplish pretty much anything with just the you know these very simple objects so i'm going to get rid of the point light and then i'm going to create a spotlight i'm not going to create a area light just because we need to actually bake the lighting into the scene but i will create a spotlight just so we can see what it looks like get it in the right position sometimes it can be a little tough to uh figure out exactly where you are okay getting close there we go perfect so this little spotlight right here is being produced by our object so we can see we can move it around and then we can apply a cookie to it if we want to as well it's right here so in your if you're in a spotlight and you want to apply a texture to it just this little cookie and it just expects a texture so whatever whatever image you want and if you're creating a cookie texture white means full light and black means full shadow and so you can make it a grayscale image you can make it anywhere in between white and black which will allow you to produce some interesting effects the for example the manual in um it's not here it's not i didn't include the picture here but the manual shows like there are some kind of like the lights that you put on a stand and they have a bunch of leds right and they're sort of in a grid and they shoot out a spotlight you can create a cookie that's kind of a gray scale with those gridded lines and it'll shoot light onto the scene as if it's being broadcast from a sort of grid of leds so there's a lot you can do with just some very simple ideas those are the kinds of lighting that we can use and in today's lecture we only really use the point light and the last lecture we use the directional light and spotlights you can you could for example programmatically change for example the rotation of a spotlight if you want to have like a swinging spotlight in your scene to illuminate some wall or some surface there's a lot of cool things you could do with it so those are the core types of lights in unity does anybody have any questions as to how they're used or how they work for the directional light does it matter where it's placed or only the direction it's it does not matter so for the directional light it does not matter where it's placed you could place it anywhere in your scene zero zero or some far distance away you'll have the exact same effect on the entire scene yeah any more questions okay cool cool so those are lights um bump mapping talk about very briefly so bump mapping is we actually do use this in the game um the a bump map effectively is so what you see here on the left is a an actual 3d scene these are actual models being shaded in real time and on realtime but they're actually real models being illuminated in the middle we can see what's called a bump map and on the right we can see a just a flat like a flat plane with a bump map with that same bump map applied to it and then illuminated so what a bump map allows us to do is to take a flat wall or flat surface or whatever you want and then simulate like an actual threedimensional contour threedimensional bumps or whatever you want on that surface without needing to create the actual geometry to make it possible and so there are different tools that will allow you to create bump mapping objects are bump mapping textures often 3d packages will have these so you can create them or other software but they are effectively just the encoding of what are called surface normals so just a vector going from outside of the um outside of the polygon at that given point and they tell the lighting system in unity pretend as if there's actually geometry pointed in that direction when you calculate it and so even though it doesn't distort the geometry in a way that's like this is still completely flat the lighting thinks that the geometry is kind of you know contoured and so it allows us to create this is kind of a toy example but it's actually relevant in the in the case of walls that have and we covered this last week just not in as much detail but walls that you want to be flat and you don't want to have a lot of polygons for you can create a bump map for and apply that bump map and then when you're rendering it when you walk past a wall it's going to look as if the wall actually has cracks and bumps in it for a realistic effect and this is used in the game to slight degree and you can crank it up if you want to i didn't on my computer because my settings or my specs aren't sufficient but every texture in today's example has a bump map associated with it so you can actually see where what the um you can actually see the effect of bump mapping at various degrees of of use the materials here so i'm going to go i'm going to load up the scene that has the actual stuff i'm going to actually i don't need to load the scene all i need to do is go to the materials and the floor for example where's the floor right here so notice that before we talked about albedo and then i also mentioned normal map so right here all you really need to do in order to get unity to detect normal maps and this is just part of the standard shader normal maps and bump maps by the way are effectively synonymous you can just drag your normal map texture into this field here this little square and then give it a degree i wish to apply that normal map and so if you look at this here you might be able to see i don't recall yeah we can sort of see how it changes the texture right so at zero there's no normal mapping taking place at all that texture is just completely flat as if we had done just the regular apply texture to a sphere but the degree at which we apply normal mapping so notice at degree one it kind of looks pretty realistic as if we've got kind of a stony texture and the more we go right the more exaggerated it starts to look right and you can just keep doing that and it'll eventually just look really distorted but that allows you and depending on how strong your computer is you can go higher or lower to affect just how bumpy just how strong the bump map the normal map affects the lighting rendering so it's that easy to get just a fairly sort of extra sense of realism in your scene so you'll notice if you're walking through the scene if you turn off lighting it's even easier to see all of the surfaces the floors the ceilings and the walls have a bump map as well as a texture map so that's in case you're wondering what these weird colored textures are rgb or xyz for the surface normals and how and their permutations thereof and that's how it gets encoded into this and so often you can see if you're looking at a bump map and a texture map you can kind of see together like oh okay this makes sense the parts that i would expect to be bumpier do have a correlation to how they look on the actual bump map texture you can see it here everything that is bumpy or contoured is very visible in the bump map that's just by nature of the way the data is encoded so any questions as to how bump maps work or what they are or how to use them in unity all right cool so now we can start getting into a little bit more into how this all comes together in our maze on our game and we'll talk about maze generation so i'm going to just start up the uh game the scene here so i'm in the actual play scene so in scenes i loaded up play as before i'm going to hit play i'm going to turn off my sound just because the creepy sound is a little disorienting after a while um and then i'm going to oh and actually i'm going to go to a 2x3 view and then hit play so we have the regular game view down here below and then also if i zoom out you can see that our scene was empty before but now we've got a maze and currently it's not very visible at all um because one we're playing fog right and recall fog allows us to effectively add color to objects that are farther away from us and two there's a ceiling on top of our um a roof on top of our maze so it's actually blocking out the actual what the maze looks like so we can fairly easily make a couple of changes here in order to see our maze a little bit better so i'm going to go to window i'm going to go to lighting settings and so if you go to window lighting settings those are your sort of global unity lighting settings right you can set your skybox you can set environment lighting you can set things like fog you can choose how things are baked there's a lot of things here we won't cover nearly all of them we will cover a few of them environment lighting is a big one that's actually how we're lighting the scene in this game so all the lighting that's not um well all the lighting is environment lighting uh that's how we're doing it we're doing it with color so notice that you can choose skybox gradient and color so if you choose skybox environment lighting it's going to have sort of like it's going to look kind of like this skybox that we have here right this sort of in the far distance looks blue kind of looks a little bit more natural but i didn't but it when it's applied to our scene it doesn't look uh quite the way we want it to look so we went instead was just color and i chose this sort of murky greenish brownish color and that gave the result that i was looking for but you can make this any color you want to we can make this some sort of bright yellow color i have no idea what this is going to look like this is probably going to look horrible but yep i mean actually this in a in a weird way this kind of looks interesting this actually looks closer to the original dread hall's game than what i did but it's not very scary kind of looks like we're in a pyramid um that is um am i able to go back no okay well i uh screwed up the color let me try and find kind of what color i had before it's kind of like a nasty green kind of like that it's probably good enough okay something like that and so we play it again we can see you know we're back to the nasty dark color but that's environment lighting so it applies a lighting uh uniform just ambience kind of like a directional light but it doesn't have a direction it just applies to everything in your scene at a given intensity and that that is how we are lighting our scene that's it's that's that easy just environment lighting in our scene on our lighting scene window now the other important thing here is the fog so fog is as easy almost as easy as just clicking this button here that says fog and then choosing a color for it probably you can choose the density so obviously if it's a higher density fog it's going to look as if you're in a foggier place like it's going to sum the color to things that are closer to you faster than it would if you had a lower density fog and there's some other features here some of which i'm not terribly familiar with but for the sake of today's example just the click make sure fog is selected and then click uh make sure you have the right color for your fog so if you have like a ridiculous red color for your fog it's probably gonna look weird yep but you can see how you could do all kinds of weird effects just by adding these things together like if you want to have the effect of being in some sort of like i don't know noxious foreign world maybe you want like a purple fog instead of like a dark green fog or whatever that's you know super easy you produce a lot of very basic but effective effects that way um i find i think it was just that kind of the same nasty green color so to bring up this lighting screen all you need to go do is if you're on a mac i think a window is the same thing there's a window option in the top menu window and then lighting here and then settings and so this will bring you to all of the settings that are pertinent to at least today's example and so we're not using any lights in our scene that we talked about before um at least for the lighting of the scene itself now there are there are point lights being used for the pickups and i'll show you that in a second but what i wanted to illustrate was how we can sort of look at our maze as after it's been generated and so what we need to do first notice that before we were kind of um we couldn't really see our maze at a distance it was just purely dark green because of the fog it was adding green to that um geometry because it was so far away so i'm going to disable fog for now it'll actually remember your settings which is kind of nice so just going to disable fog and i'm going to actually add a directional light to the scene so i'm going to go here add a directional light and then i'm going to hit play again so now our scene is lit and um you know it looks a lot different a lot less scary and we can see our maze a lot better we can actually see that it is a collection of blocks it's all it's tiled blocks now we can't see into the maze because the maze has a roof so what i did was i just made generate roof an option in the script and so if you unselect that and then we try again now we can see our maze so this is what our mazes look like and so the cool thing about unity which i really love is just this ability to look through your scene independent of the actual game just to like help debug like it's hard to know if you're generating your maze correctly um when you're creating it in 3d you know in 2d you can easily just look at it but in 3d if especially in a first person game you can't really see it so being able to split your view like this the scene and the game and actually see oh my algorithm is working or it's not working it's super helpful so we can see that it is carving a maze for us it looks a little bit weird it's not a traditional maze in the sense that it has the you know the classic maze shape to it but it effectively functions as a maze and it works very well for its intended purpose um and the algorithm is incredibly simple and we'll talk about that so that's our maze i'm going to go ahead and revert all of the i think if i just reload the scene it should just revert it don't save yep okay so everything's been reverted all the lighting everything just gonna do a sanity check and make sure yep everything works perfectly well so anybody have any ideas as to where to get started if we were to implement a 3d maze the way i did it once before is you uh you put a bunch of x x's where you want something to be drawn in an array and then you loop through the array and draw instantiate the uh the balls yes so um create an array populate it with x's where you want data wherever you want something to be instantiated and loop over and instantiate everything it's exactly how it works um now in terms of actually creating the maze do you have any ideas as to what how would you go about implementing a a simple maze generator and there are obviously very complicated maze generation algorithms so like nothing terribly fancy but just a simple how would you make a maze or it's random so starting with the idea that we have an array right it's going to be a 2d array because we have two axes upon which we're generating things here even though we're in a 3d environment we don't need a 3d array we just need a 2d array because if there is a positive value for wherever we want to generate a block in our 3d or 3d maze we just generate a column of blocks we don't need to worry about a third dimension right our maze isn't like taking into consideration like multiple levels at which point we would need to maybe consider three dimensions i mean even still you can still divide those into separate 2d arrays of mazes we just have an x and a y so how would we get started what would we start populating the array let's say we have an array it's just a bunch of zeros right what are we populating with the array after after we've initialized it so i'm thinking maybe you would kind of start off with um just full of walls and then add like um corridors maybe so start with a bunch of walls and then add quarters that's exactly what we do um the algorithm is actually pretty simple so i'll try and maybe draw a little bit just to see if it can illustrate how this works by making sure that every um thing that you change is orthogonal every block every step that you move is orthogonal that will that will ensure that you start at one point and another point and those points will always be accessible to one another just by virtue of how simple the algorithm is and the orthogonality of it so if we start with um walls so um one one one one one one one one these are all in the in the distro these are all booleans because we don't need we only need zeros and ones so we're just gonna use true and false we don't need to use integers for that so this is our starting maze here um and actually i'm going to add another dimension because or not another dimension but another size just because the the walls always need to stay to be there these these are basically untouchable i'm gonna try and draw that as best i can right so we effectively have this as our working area for creating a maze right because we want this to be we want walls no matter what because we don't want our person to be able to walk outside the maze or see the outside world ever we want them to be locked in so we have all of these ones here these trues effectively and so all we need to do is start like at some random position let's say this value um at 3 2 or well it's actually technically it's 2 3 because we go we index at y and then x in a 2d array so we go 2 3 we go here and then we basically can move either left or you can move either left or right or up or down well we can't move both at the same time and why can't we move both at the same time let's say that we're let's say first of all let me say that we're let's say we're going to carve our way through the maze right so we're going to turn these ones into zeros but we can only move either we can only move orthogonally meaning left or right up or down we can't move diagonally so we can only let's say we have a an x move right and a y move and those can be set to but by default there's zero so we're basically saying where on this step of the generation are we going to move and actually technically it's direction because we're the way that we do it is via directions what's in front of you will have no wall and there'll be walls on either side of you except for where you came from yes so if you're here and they move down this is gonna be zero this is gonna be zero and so those points are linked right and then from there we're gonna move in in a given direction and so all of the let's say we move here all of those are going to be linked and so if we move here all of those are going to be linked just by virtue of the fact that we're moving orthogonally we will we can't create a maze that's unreachable because the way that um just by virtue of the fact that we're moving it now orthogonally now if we move diagonally if i were to move here right there's walls right here and then two spaces there that's not going to work because we can't access that we see it we're going to see a cube here and a cube here and we're going to see we won't be able to get move diagonally through walls right so that's why we need to ensure that we only move either in the x or y direction not both at once and so what the algorithm does is it randomly chooses should i move x or should i move y and should i move positive or negative so it'll do math.random equal you know two equals one effectively in the code it's random.value less than 0.5 because random.value in unity gives you 0 to 1 as a float so you say if random.value less than 0.5 which is a random chance between you know true and false effectively 50 percent moving x or moving y and then same thing but should i move in the negative or positive direction right so if i'm here i'm thinking okay let's see x move or y move uh it's again it's going to be an x move so i'm going to move either left or right okay so am i going to move either negative one or one step one to the right or to the left right so if it's negative one and that's going to move to the left right and if it's positive 1 it's going to move to the right so i mean that's the essence of the algorithm just loop over a bunch of times whenever i move to another tile turn that into a zero so actually this becomes a zero uh change the color so this will become a zero right so that's now an empty space and in the code that instantly teleports the character to that space two so we know that our character is always going to be in an empty space because he gets placed in the first open space that gets generated in the maze and so let's say x move is equal to negative one on this iteration so let's say we're looping until we've cleared x blocks so i want to clear it let's say i want to clear five blocks so two clear equals five right that's how many blocks when we've cleared that many blocks we're done with the maze generator right so cleared one so our current counter is one so x we get flip a coin we're moving to the x direction by negative one so we move um two here and then we turn this into a zero now this implementation of the algorithm moves one step at a time and so because of its randomness what this ends up doing is it produces very large chunks of deformed space just because the crawler is just constantly moving around kind of like haphazardly so what's a refinement that we can make to this algorithm to make it look a little bit more like corridors or like hallways just keep going until you hit the outer wall you could do that yeah keep going until you hit the other wall um the result of that you mean hit the like the side of the maze yeah because well if you did that it would effectively just be like it would kind of be it might work in some cases but it will be very long hallways and not a lot of like turns or anything like that so the result what we actually want to do is when we flip a coin and we say x move or y move we want to also say times to move we want to create a new variable called number of times to move effectively right to move and then we just set that to a random number between one so we're going to move one tile or the size of the maze minus two right taking into consideration both walls right so let's say we get the let's say we let's say we did x move minus one and it and we only got two move equal to one right so we only move here we move once in this direction so we've got two spaces and then let's say we flip a coin again and then we got y move right positive one and then two move we got two right so we're going to move two directions in the yaxis by one so what this is a result of us going down here so we go zero and then zero right and so the effect of this is that we move um we can move in more than just uh one block at a time and avoid sort of random like haphazard weird organic large room aesthetic that we want if we want like a hallway gridlike dungeon looking like room generator right now there's a caveat to this and that is if we start here for example and then we want to uh let's say we flip a coin it's x move but it's positive like positive four right we can't obviously move four tiles to the right because one it'll go into our walls on the outside and two it's actually beyond the bounds of our array so we need to clamp that value down when we add one to our value to wherever our x we have to basically keep pointers right we keep pointer to whichever tile we're currently at we need to keep uh when we actually go to the next tile in our step we need to clamp that value within the range of our walls so we need to clamp between one so because we don't want to be at zero we want to clamp it between one and maize size minus minus two actually because we want to make sure that we don't go any farther than the this one here does that make sense this this is how that is effectively how our generator works it's a step beyond just the move one block at a time just because the mazes look way too empty and weird with this approach where you're moving in a direction and for a random number of tiles as opposed to just one tile at a time you actually get pretty nice looking simple mazes this isn't how like actual maze generation works um for mazes that you would see in like an actual maze that you do on like a crossword puzzle book or a maze book or something those are more complicated um but this solution works well it's very fast and very cheap and actually pretty simple to understand so any questions as to how the maze generator the algorithm at least is applied to our 2d array works all right cool that's the um that's basically the gist of it so we're gonna take a break here um for about five minutes and then as soon as we get back we'll dive a little bit more into um sort of how the character controller works and the pickup and a few other aspects of the game all right welcome back to lecture nine so before the break we were talking about uh the way that we implemented procedural maze generation so a fairly simple uh algorithm that creates this sort of hallway look where we can easily get lost but they aren't technically mazes in the traditional sense like you might have seen growing up in puzzle books and such another pitch for cat like coding because articles are amazing he has another one on how he did a maze generator and in this one beyond just regular blocks oh i'm sorry i didn't have the uh slider on the on the thing so this is a screenshot of another article from cali coding where he talks about how to make his own maze generator and the cool thing about his is that he has a bunch of different geometry involved in the scene it's not just blocks he has doors and windows and other things and his algorithm is a little bit different than mine and produces some pretty interesting looking things you can see here also it has a view of the scene sort of superimposed on the actual scene which he does with a trick using two cameras so also here's another um maze slash dungeon generator article that i really like where he creates sort of like dungeons and dragon style generators and this is sort of pertinent to my interests as a developer because i really love roguelikes and dungeon generators and rpgs but he goes into extensive detail on how to make a really nice and efficient 2d maze slash dungeon generator that produces really nice looking dungeons as you can see here it's got a very variable layout lots of corridors and rooms and stuff like that so implementing something like this in unity would be really cool and there's a plethora of generators and assets like this that'll do the same kind of thing in unity available in the asset store so you don't have to make this yourself most the time you can create you can just go find either free or paid assets that will do all this for you and save you a tremendous amount of time and much of them are also very customizable too so you can tailor the generator to fit the domain of your game so we saw how the lighting works in our game we've seen the maze sort of how it's generated what it looks like we have not taken a look yet at the character controller so we'll briefly just take a look at that it's actually incredibly easy to do in unity at least to get something fairly basic up and running the way that we get a fps controller in the case of our game is unity has which i alluded to before a set of custom or a builtin standard asset packs that allow people getting used to the game engine or i'm just trying to bootstrap their game up and running with some very basic components very basic things that are super helpful for um just to started getting your game running so actually we use the prototyping standard asset pack for our pickup we use the um characters one for the character controller the fps controller so if you if you're in a fresh project and just go to import package and you import this characters thing here it'll import it into your game so you can immediately use the prefabs that it gives you to create a character object so it'll by default just put it in your assets folder um underneath standard assets and then characters and then there's a first person folder and within the first person folder there's a prefabs folder with which has the fps controller game object and so all you need to do is just drag it into the scene and then that becomes your um default camera so it comes with it comes with unity correct that's just a standard asset uh it's always in the the fps controller will always be in the so you have to import it first you have to import the um the asset package the characters package once you've imported the characters package you'll go into standard assets in your assets folder there will be a new folder called standard assets within standard assets you'll go to characters then first person and then prefabs and that's where you'll find the fps controller yes no problem so the fps controller if we take a look at it we talked about it before briefly but effectively it's just a capsule collider which is sort of defying physics because it's kinematic kinematic with gravity applied to it and it has a camera sort of on towards the top of it where the head is to simulate the perspective of somebody from first person view and there's some programming involved that allows you to control it with the keys and the mouse to control the camera's rotation with the mouse and the position of the collider with the wasd keys and if you want you can dig into the actual script for it too they're all built included with the standard assets pack when you import that into your project it comes with all the scripts that make all that possible i haven't dug through all of them in too much detail but it's all there for you if curious as to how it works and so if you want to get just a simple you know fps controller in your game the character in your game to walk around and you know play a first person game it's takes about a minute to get up and running now there's a lot of customization that you can apply to your character controller to make it not just the standard basic character right so you can set a walk speed you can set a run speed you can set jump speed you can uh you know you can set the sensitivity of the mouse look on the uh on the game on the fps controller you can apply what's called fov kick which means when you're sprinting which it allows you to sprint by with pressing shift which multiplies your speed um it'll actually um uh i think it'll expand your depth of field a little bit to make it look as if you're kind of like claustrophobic right like things kind of like um go out and so it looks more narrow and it kind of gives you that look as if you're like sprinting down a path and you can set just how much it increases by you can set the curve of how that is applied here so this is one of the components that unity allows you to to do is there's a curve object and you can use this curve to influence various things in your game i actually haven't used it much myself but if you're looking for something to apply a curve to unity has an interface for making that visible within your inspector head bob which means when i walk should should the camera kind of like go up and down and when you do have a head bob like what's the curve look like so here's another curve this is the sort of what the head bob looks like kind of a sine wave but a little bit distorted and a few other things so for example footstep sounds maybe you don't like the sounds that come by default with the controller so you give it your own footsteps sounds super easy to do just drag new sounds here jump sound and a landing sound to more sounds that you can add to it and that'll allow you to customize most of the feel of how your character moves around in terms of just a basic fps controller and so just by applying those very basic things customizing a little bit we got lucky with this maze it just means that the maze went all the way around and then looped right back to where we were and ended there so this is that's that maze okay but um i'm gonna go ahead and turn up the sound you can hear the footsteps right along with the creepy whispering but the footsteps are just provided to us with us uh provided to us by the fps controller and again you can customize those to be whatever you want and so this gives you the ability to walk around in your scene from a first person view it doesn't really give you much more than that um in order to do like an fps where you have like maybe a gun or a weapon or something you need to program some more things and it's a lot more complicated but for just basic navigation of a 3d scene that's a great foundation a great way to way to get started so any questions as to how the fps controller works there are other controllers too there are third person controllers so if you want um to use those they don't come with a camera based on my experimentation they don't actually come with a camera by default so i think you have to parent a camera to them in the way that you want for your game like for example some games have the camera super high above your character while you're walking around and some of them have like a like behind the shoulder look almost like like fortnite or gears of war like really close to the character and then some kind of have like in banjokazooie you could be walking up a mountain and so the camera's kind of like perpendicular to where you are and sort of like follows you around so camera programming for 3d characters is a little bit more complicated than it is for first person games and so that's why i imagine it doesn't come with a camera by default so it can be a little bit more complicated but i do believe there are a lot of assets on the asset store that can help bootstrap you for getting a programmatic camera setup going for your character in a 3d third person view yeah when you're walking around your maze like occasionally you're like clipping the wall and kind of seeing like yeah yep uh that i believe that's the result of the collider being a little bit too big so what um what he said was that they walking through the maze you can kind of clip through the wall a little bit see if we can actually experience it yeah like right there uh yeah and that's the i believe that's just the the camera or the collar the collider being a little bit too large and so it's probably like get rid of that all together just by shrinking the collider a little bit um just a detail that i didn't iron out but you'll see that a lot of games actually a lot of games have like clipping that you can get that you can observe depending on how they've programmed the game um but yeah any other questions as to how character controllers are work and how the import process works and how to get it in your scene okay cool yeah it's super easy again here's what the fps control looks like capsule collider with a camera and then the third person controller by default they give you a pretty nice looking model on the left side there so that you can experiment with it and they apparently give you an ai one as well so you can test ai in your scene with it but i haven't experimented too much with that to vouch for how well it works so an important aspect of today's example is that we've gone from having just one scene to having two scenes so i wanted to illustrate how we sort of move between the scenes a little bit and also i realized we didn't really cover the dungeon generator in code detail but notice that i have exposed a lot of things here a floor prefab wall prefab ceiling prefab these are just the the cubes that are textured to be our floor walls and ceiling we can just click and drag them from the inspector into our scene onto the components there we have a character controller reference here so that we can place the character controller in our scene when we've generated the first block we can basically take the transform and set its position to whatever that xz is and then a floor parent and a wall's parent so the reason that we have parent objects actually which we didn't look at before oops i've lost track of where my there it is the reason that we have parent objects here is because when we instantiate all of the cubes in our scene just sort of you know just instantiate them without really thinking about it it ends up basically i'll show you here um well first of all i don't know what this is oh i think it's that's interesting oh because i clicked on the floor parent right okay um so you click on the walls parent actually i didn't do that yet but it'll actually show you where all of the all the objects that are parented or that are dependent on that parent so the floor parent here see how many floor blocks there are there's quite a lot excuse me there's a lot of floor blocks here and in the walls parent there's even more there's a lot of walls and ceiling blocks and if we just generate those without assigning them apparent it'll just fill up our hierarchy there a very messily and it makes navigating our scene um during debugging very difficult right we don't need to see that we have a million clones of the floor or the the ceiling blocks or the wall blocks and so what we do is we just take the all of the clone blocks and we just parent them to an object and when you parent something to an object you get that little drop down like for example this first person character this fps controller is the parent of this first person character as those are two separate objects that both comprise the fps controller effectively a parent is top level and its children are therefore within it within this little arrow here and it's collapsible all of the things within the play scene for example the play scene is the parent to all of these it's sort of like a folder hierarchy type of thing and so if you want to clean up your scene if you're instantiating a ton of things just effectively containerize them by putting them into a parent object and so we do that in our game with a function called create child prefab and so create child prefab does is it does an instantiation as normal right creates a prefab instantiates it gives it a position xyz quaternion.identity because we don't want to apply any rotation to it but myprefor prefab.transform.parent equals parent.transform effectively linking our um we're assigning the parent field of our of that prefabs transform to the parents transform and that has the effect of basically linking them together in a parentchild relationship and that will allow us to collapse and expand a list when one parent has a bunch of children we can expand it and contract it in the hierarchy view and save us a lot of save as a bit of a headache in terms of navigating our scene when we instantiate a lot of things which is fairly normal um so the actual may i'll go over this fairly quickly it's a fairly simple algorithm and i've talked about it on the screen we don't have a ton of time but basically we go z to x the reason that we go z to x is because in unity z and x are sort of like the ground axes and y is sort of like the up and down axis and so we don't want to instantiate we're not really worried about navigating the yaxis during our maze generator because all we're going to do is instantiate four blocks along the yaxis during that phase right so we're basically taking our 2d array and we're iterating over it x y and then we're mapping that to unity's z x or x z if that makes sense because notice the uh like this is our ground right so where this transform is you can see the ground how this is x the blue is a z and y is this axis here we're generating we're effectively only concerned about generating on the ground and then when we generate a wall we just generate it four blocks high on the y we don't think about the y so that's why x and y for our 2d array but x and z for applying that array to unity's 3d coordinate system does that make sense okay so we're iterating over z and x and then we're indexing into our um map data z and x which is effectively the same thing as y and x and then we are creating a child prefab if map data zx so recall if so recall that our map data is a 2d array of booleans right and so if we have map data zx equal to true that means there's a wall there it means that there's a true in our array so we should instantiate a wall at that location so we create three wall prefabs assign them to the walls parent so that they get containerized within there so they don't clog up our hierarchy view and then let me see here and so if we don't so if we've if we've gone through our maze right if we're generating our maze and we get to our first tile that's actually not a wall so it's an empty space so basically the else here so if map data zx is not true it's going to be false so if that's the case and if not character placed so character place is just a boolean it's a private bully and we don't want this to be visible in our inspector there's no purpose for it to be visible in our inspector this is just a boolean for us to use in our script so we set that to false by default because we haven't placed our character yet but once we when we generate our maze we have to make sure we put our character in a spot that there isn't a wall because we'd obviously don't want him trapped in a wall or clipping through the maze right so if not character placed we're going to set the character controller's transform we're going to set its position and rotation which is a function um we're going to set it to x and then y one and then z and then no rotation so quaternion.identity and then set that to true so therefore this will never be called again so this only gets called on the very first empty space that we go through our maze and that's it for that um when we no matter what we do um whether there's a wall in our maze or not we're going to want to generate a floor and a ceiling at that space so that's of course assuming that generate roof is true which recall we made a public boolean in our inspector so that i could debug and show you guys what the maze looks like from up above so if generate roof create a child prefab for ceiling prefab at x4z so a bit higher up and then no matter what always want a floor so create a floor prefab at x 0 z so down below and our character controller gets placed at recall x1z so just above the floor the assignment is actually part of the assignment is generate a hole in the floor and if there's a hole in the floor and the character falls through the floor of the hole should get a game over right so you're going to create a game over scene you're going to need to transition to that scene and then we're going to need to check to see whether the character's transform has gone below a certain amount right that's all fairly easy stuff to do but you'll look to do some of that in here and then the actual maze data function is here i won't go over it in detail but it's the algorithm that we talked about before where we choose direction to move randomly and we choose a random number of steps to move clamp that value within the constraints of the maze and then set every tile that we explore to false and that has the effect of creating the maze and then we just return that data back to our function it's just a 2d array notice that in unity sorry in c sharp to create a 2d array it's a little bit different than in a lot of other languages it has its own syntax for that you have the array syntax that you're probably familiar with but then you also have this comma and that comma is to designate that there are two arguments to that um index syntax here just means there an x should go here and y should go there basically um or a y x and that's 2d array and you can make it you can make it as many degrees as you want to just add more commas to it and notice that to actually allocate the memory that we want for that 2d array newbool may size may size so our maze is always square shaped same same and you could easily make this mace x maze y if you wanted to to make it like rectangular so you just need to have two public variables instead of one and all of this is fairly visible through the inspector too and our dungeon generator you can see i made a tiles to remove 350 so that means that our maze is going to cut out 350 tiles and as soon as it cuts out 350 tiles it's done and then our maze size is 30 by 30. so that means there's going to be 900 tiles in our maze so you can tailor this to whatever you want in order to produce sparse or denser mazes to your liking so any questions as to how the code for that works more or less so now we'll actually get to the scenes part of it and so transitioning between oh yeah yeah um i'm thinking like you know for like a smaller game like that like that works great but like for a larger game wouldn't you want to model the walls as like 2d kind of objects and like the ceiling instead of like a whole cube oh yeah so for a small game um is it ideal more ideal for the walls to be rendered as like one con one discrete object as opposed to like several cubes yeah absolutely that's 100 true and actually minecraft is an example of this sort of idea that you think would work but they actually consolidate all their geometry after they've generated it in this way and produce like um models that are more optimized like that you think that you're interacting with this world that's a bunch of these little blocks all separate but it's actually one big piece of geometry and then it dynamically figures out what you're hitting and removes and adds blocks as needed and there's some uh some cool videos on youtube as to how to do this in unity too which i looked at a long time ago and it kind of shows you you can actually dynamically create meshes and vertices and stuff in unity and then create objects that way which is really cool but that's a little bit more on the advanced side but yeah absolutely for an actual implementation of this a simple but more efficient way to do it would just be to have like yeah one solid large wall object that's like as tall as you need to be and maybe as wide as you need it to be for um one character and have that work but for simplicity's sake to illustrate the algorithm um we were just using the cubes yeah exactly but yeah good point that's a 100 true all right multiple scenes so the way that we do this so i'm going to go into my text editor whoops so the grab pickups script so grab pickups is a component that's attached to the character controller because he's going to be picking up pickups and what the grab pickup script effectively does is the character controller built in collide has this function that you can define for it called on controller collider hit where anything that collides with the controller's collider will trigger this callback function and you can grab the information about the um object that you collided with and then perform some sort of logic on that and so it's actually calling this function every single time we uh collide with any of the tiles or the blocks in our scene as well there's just no logic to account for them so it's just effectively an empty function call but if it's the case that the game object has a tag of pickup which we've set in our ed unity editor and i'll show you how to do that then we should play a sound from our pickup sound source and then we should using we actually use this in the last lecture but only within the same scene we're going to call scenemanager.loadsceneplay and you need unity engine.scene management using unityengine.com at the top of your script in order to use this and load scene effectively just like we'll literally just load a scene by its name and we're doing that in a couple places so we're actually doing it there but remember we had the title scene which had the same sort of thing you press enter and you load a you load the play scene right so this load scene on input component that i created is attached to a text field in the title scene and all we're doing here is in the update we're just saying hey if update if input.getaxis submit is equal to one then cmanage.loadsceneplay almost almost the same kind of almost the same code only in this case we're querying unity's input it has a global input manager get axis so it has several axes is how it defines it different like methods of input and then it defines them by keywords so in this case submit is a keyword and you define you map those keys or you map those keywords to specific keys and input sources on whatever platform you're targeting in this case submit is synonymous with either enter or return depending on which platform we're using and it could have other meanings if we're exporting this to xbox or for exporting it to the web or for exporting it to a mobile phone there's a lot of different ways it changes and so the way that it checks is it'll be zero or one specifically so we can say if input dot get access submit equals one um c manager load scene play and it won't let you do if input dot get access submit because it's explicitly expecting an integer and it'll throw an error if you're trying to use it like a boolean so we need to use this equals equals 1 to test for equivalence and that's all we're effectively doing there now the interesting thing is when we reload the scene for the pickup right for the maze there's a soundtrack playing in the background and we want the soundtrack to constantly be playing the same thing and to loop right the sound effect we don't want it to start up immediately again and start like from the very beginning again we kind of want the seamless sort of feel to it and so how do we think we can solve this problem correct so any ideas as to how we would do this well so whenever we collide with the pickup we reload the scene completely from scratch and so when you reload a scene it destroys every game object in the scene including all the objects that have audio sources attached to them and so when it reloads the scene it reinstantiates all the game objects in the scene including those with audio sources and retriggers their playing so what we want to do is prevent this from happening just have a counter and when you get the first pickup then it goes to one and then you say if less than one play the sound um that will have the effect of so you're saying have a counter and when true so have a counter or true false when you load the scene it starts the music but what happens when we reload the scene from scratch and the audio that was playing gets deleted can you transport certain objects between scenes can you transport certain objects between scenes effectively you can there's a function called don't destroy on load actually so with that it's a unity function which allows you to preserve an object as it is between scenes so uh if you don't want your scene with the music to or your object with the music to destroy itself and then reinstantiate unload well technically just don't destroy itself um just do don't destroy unload at the game object and so this don't destroy we apply this to our audio source our whisper source it's called in the scene the only problem with this is if we reinstantiate or if we don't destroy on load this object it's going to persevere but when we reload the scene it's going to instantiate a new one so what's the effect of this going to be gonna have two audio sources playing at the same time what happens when we do another one we have three audio sources playing at the same time so for every time you go to a next level you're going to add the same audio track to the scene it's going to be very annoying very quickly the way that we avoid this happening is by making what's called a singleton and so what a singleton is is a class that can only effectively be instantiated one time right and um we do this by creating a static variable here called don't destroy um uh no we called instance which is of type don't destroy so it's this component here right and so the don't destroy class as a whole has this static variable called instance and we set it to null by default when we haven't instantiated a don't destroy component yet and what this ensures in our scene by the logic we have in the awake function awake is almost the same thing as star just means whenever you can you can pause an object and it'll awake from its pause state but awake also gets called when an object gets instantiated so if the instance is set to null on awake um instance equals this so this don't destroy so whatever this is being called from this this don't destroy will be the instance whatever the first don't destroy component is in our scene the very first maze that we generate the sound source instance will be this and then we set don't destroy on load for the game object that is holding that don't destroy don't destroy component right that audio source but if the instance is not equal to this so if we've woken and this is level two for example instance is going to be set to the um the don't destroy a component on the don't destroy unload object that we created in the first maze right because we did this logic here and so it's going to try and instantiate a second don't destroy a component it's going to another sound source but instance is not going to be null instance is going to be equal to that first object so we say if instance is not equal to this destroy game object so this is going to be from the standpoint of the second um just don't destroy that got created basically the singleton will persist indefinitely yeah indefinitely upon its first instantiation and there will only ever be one singleton this is a very basic very common pattern in software engineering for ensuring that you only have one object of a given type present throughout your entire project but this is how we prevent multiple sound sources from being instantiated we always ensure that only one object of that with that component gets instantiated at once and any future instantiations of that object get destroyed immediately assuming that they aren't that first object if they are that first object instance will not instance will equal this and so it'll still skip this part and so it'll stay alive so any questions as to how the persevering through multiple scenes works for their sound source okay um that's how we get multiple scenes so far we looked at fog already but i have a few screenshots here to kind of help illustrate what fog has looked like over the years so fog looks pretty unconvincing in this screenshot this is turok for the n64 it's just kind of looks as if you know sort of at a certain distance a very dense sheet of fog has appeared and you can actually make this happen in unity by setting the there's a curve a fog curve that i believe you can manipulate that while effectively the algorithm that determines how the color gets summed to things far away is very fast as opposed to gradual or linear so you can make it just like exponential effectively and make it look as if the fog is incredibly dense and starts almost at a very fixed spot and have the rest of this area sort of in front of you look normal here's another example star wars the empire one of my favorite n64 games which has sort of the same look and so in this area you can see fog is very distinguishable very artificial looking because it's very tinted in this case it looks very blue in this case it looks very like pale blue this is silent hill and silent hill looks realer more realistic but um kind of the same thing at play here you have a very pale gray metallic blue color and the density in this case is very high the density is much higher well maybe close to as high as it is in our game that we should that we're showing today um but it's effectively the same thing just with a different color and they used it to great effect in here not only for um sort of this aesthetic to make you look as if you're in some sort of desolate town but also to dynamically load objects or to prevent rendering objects that are a certain distance away and to optimize performance on the hardware that was severely limited at the time which was playstation 1 which is a fairly weak console and then here is shadow of the colossus for ps4 which just came out not too long ago and we can see fog is still being used but it looks photorealistic and there's probably a lot more that they're doing they probably have several layers of fog they probably have textures and um you know transparent objects that are simulating fog and a lot of more complicated things like that fog that only hangs at a certain distance so it looks like fog going over the lake there's a lot of things here but it's the same idea and they probably have the same sort of foundational base fog present throughout the scene and then here's our game just to show how it looks like you can barely even see it but it does give you this sort of like lost in a really dangerous maze feeling which and it's super easy to do and it can it can save you performance and it can add a lot of aesthetic to your game and so the last big thing we'll talk about today is unity2d actually so i'm going to go back into questions about fog i know that was a pretty high level overview i've already looked at fog we looked at how it applies in the settings any questions as to how it works or how to get it working unity okay so we're going to go ahead and look at our title scene and so we looked at this earlier briefly but i'm going to go ahead and show you the components so i'm going to take a look at our canvas if you double click on something you'll zoom out and so it'll automatically detect sort of what your resolution is and scale the canvas accordingly in your scene view there's a 2d button here i'm going to go ahead and go to my default layout i'm going to click on the canvas notice that it shifted things a little bit because now i have a larger window that's going to be rendered to i'm going to click on the canvas and then i'm going to go to 2d mode and then notice when you click on 2d in 3d mode you go like instantly into like seeing it as if you're manipulating it in a 2d engine versus a 3d engine and then going back to 3d now it's a threedimensional plane that you're actually looking at so in 2d mode you can easily sort of navigate it right click and drag it around i'm going to go here like this and these are very simple components that you can just interact with as a gui now the main thing that you need to get any of this to work is the canvas which is here so if you right click and then go to ui you can go to canvas if you want to or you can just add any of these things that you want and it'll automatically add a canvas for you because a canvas is necessary for all of the unity ui rendering stuff so if i were to just add a text and on an empty scene it will just create a a brand new canvas and an event system the event system is just how unity talks to the canvas and the all the ui elements of your canvas given mouse and keyboard input and stuff like that it's nothing that you necessarily have to worry about or use but the canvas is the sort of overall container for all gui stuff that you do now if i click on the the title text or the enter text notice that they are children of the canvas so they are within the canvas the canvas is their parent the title text i can move it around notice that it snaps right it's got some nice snapping functionality i can set it up there it'll snap to the top it'll yeah it's pretty handy you can scale or scale the bounding box it doesn't scale the actual text but the notice that i do have like right justification centering left justification those sorts of helping the sort of features i can increase the font size via slider right so i can immediately see without having to edit some code and then reload the project what changing some of these values will look like i can easily change the color in real time so i can get a sense of how that looks if you wanted some sort of slimy dread 50 look i guess and you can also assign materials to it as well which is kind of cool which i haven't explored too much in detail but you have that option if you want to give it a material instead of a instead of a color materialed font because ultimately all this stuff is still 3d but unity presents it in a way that makes it look as if you're interacting with it in 2d it's pretty nice i mean when you hit play it's going to open up to that yep and then how do you transition to the rest of the game so the transition to the rest of the game is in the load scene on input here so this script that we looked at earlier so this is assigned to one of those text labels so i just gave it to the i forget was it the i think it's the enter text so i gave it this load scene on input just because it's a it's the enter text it seemed appropriate uh you could put it on anything in the scene it doesn't matter as long as it has this update function which then has this if input dot get access submit equals one and then recall the go into the project settings input all these axes here are defined for you automatically and then you can choose what they map to but submit as you can see positive button is return so if submit is equal to one repress return it'll be equal to one effectively and it gets mapped to other buttons depending on what input sources you have on your device but you can check what it is on your computer just by going to axes in your input manager so it's once again edit project settings input and then you can see all the axes here the 2dc that's a whole that's just a scene in itself it's a scene in itself completely as a camera so we are um the camera renders the thing about canvas is it's kind of separate from the camera so it gets rendered onto whatever the camera is rendering separately but the camera in this case what i've done because if by default we just render the camera and the ui it's going to look just like this it's going to look like the sky with dread50 and press enter that's not the aesthetic that we want so i take the camera and then you can give it a background so by default the background is that sky is the sky box and so it's set clear flags clear flags are same thing as background so whenever there's no geometry or anything um clear what this clear color clear flag this gets drawn to before any geometry in the scene basically excuse me so clear flags solid color in this case and then just black using a color picker so super easy super nice um and then this ui this canvas will get drawn on top of this camera so that's what produces the sort of combined effect of having the the ui text and the black background and then that enter text having that component that checks for the submit input because that's what enter and return map to that is um that is what lets us transition from uh the current scene to the play scene and so there are a lot of other cool features that these like labels and such have for example being able to set its anchor position so depending on what device you're shipping to you might want you know you're going to have multiple screen sizes and screen resolutions so you can say i want this label to always be at the very top middle of my scene and i can do this by clicking this little box here which is the anchor point selector and then just clicking that and so that will always anchor dread50s text to the top middle no matter what our resolution is it'll always be there and there's a lot that you can do whoops on top of that and you do that with any ui component just relative positioning depending on the resolution and the nice thing about unity 2 if you go to game you can actually choose sorry in the second menu you can choose a lot of aspect ratios so 5'4 doesn't look that great 4 3 doesn't look that great 16 10 16 9 and then standalone so standalone is the default export size of your platform but you can choose you can have it you can test different resolutions and you can also add more to you can add a fixed resolution if you want or an aspect ratio and do a lot of cool things that way so you don't have to necessarily test it physically on different devices although it's very good too so you can make sure that you're not blowing up your hardware but you have that option so any questions as to how unity2d works and how the canvas works or how we've gotten the simple ui to work part of the assignment will be and we'll take a look at that now actually so assignment nine we talked about this already about the gaps on the floor but this will be part of you know the maze generator right because that's where we generate ultimately or the degenerate the maze instantiator the actual part of the maze generator that creates the physical maze but create gaps in the floor and then when the player falls through approximately two blocks below which so you can set make check the transform is the y positions less than a certain amount right which should be should be less than zero i think it's based on the top part of it um then you should transition to a new screen that says game over so create a new scene very similar to the first scene that we looked at which was just the title screen and you can probably copy most of that but that scene should say game over and then pressing enter there should load the title scene right and then lastly add a text object to the place scene that just keeps track of how many levels you've navigated through and you can probably do this with some kind of static variable but any solution that accomplishes it is welcome but all together all pretty easy pieces to put together that was this week which was dread halls and our first foray into first person games next week we'll look at portal it won't look necessarily this good but it'll look similar to this this is a screenshot from portal itself but we'll look at how we can render to textures how we can cast rays from our character our first person controller how we can actually make it look as if we have a weapon or a gun or portal gun which is you know not too difficult you just have to parent basically a model to your first person controller um and then when we walk through a portal how do we transition from the other two from one portal to the other portal so just a uh you know teleport your transform to another position but that was that next week is portal and i will see you all next time