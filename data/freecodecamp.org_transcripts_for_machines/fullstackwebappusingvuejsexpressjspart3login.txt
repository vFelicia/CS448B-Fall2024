hey everyone and welcome to part three of building a full stack web application using vue.js and express.js so if you remember in the last part two we kind of pulled in sqlize to connect to the database and when the user registers we create a user model and save that then we did a little bit of validation and stuff to return different error messages and then finally near the end we started to style this register page to kind of have a more like material looking design to it so i guess we'll start off going from there and the first thing i want to do is i want to kind of fix these input labels so let me go to the view to fi website again and we can try to find some other components that we could possibly bring in so if i go to the left go to components maybe i'll do uh i think text fields yeah there's a text fields component that we could potentially use so here are some examples of the text fields or labels whatever you can use um and again just to show you like how i kind of do this i just click on view source i look through the code really quick and i say okay well they have this as an example so i'll just go ahead and copy that so instead of using inputs let's just use a text field here and i believe that's all you need to do and now instead of doing i can just put the v model on that i don't even know if you really need any of these let's see let me go back to this really quick so i guess there's different styles depending on which one you want if we just want the normal one we could just start off with the normal one for now so if i were to search for normal with hint text label so i'll actually copy that one i kind of copied the wrong one and then inside here i can say v model is equal to email let's see labeled text we'll say email id i don't think we even need an id or a name so i'm gonna get rid of that stuff save this and see what it looks like on our page over here see there it's already filled out with my username cool so we got a we brought in the beautify text field component by just doing view text field or whatever and just kind of follow the approach that they're using and we want to do the same thing for the password down here so let's go ahead and just copy this make this password change this to password get rid of that input save this boom we have email and we have password here i'm not sure if they wrap this in anything oh it's just enough flex alright so i'm not sure why these don't have a black board at the bottom like if you go over here i would rather have a have a border bottom here just so you can tell that it's like an actual input box so what i'm going to do is just find out that class that i need to style so input group text field i can just go down to my scoped css and i'm just going to go ahead and say border bottom 1 pixel solid black in fact i think this is more of a global setting i want it to be on all the input boxes so i'm going to go over here to this app.view and notice that the style for this is not scoped so this is globally so anything here would be global in the whole app so if i save this now we have a border underline on these two input boxes and again i don't know why i need to do this because their example says that you know there's already a underline so maybe there's something i did wrong in the setup maybe there's something in version 5.2 that broke that underline who knows but anyway it looks okay now so let's move on to um potentially adding some new features so again i like the text i want the text in this top bar to be white and not to be dark and i think before if i go back to the register.view page i thought if i added dark here it's supposed to add um like change the colors maybe i need to add the dark to that no yeah anyway it's just another thing i could probably style globally just to make it look a little bit nicer so i'm going to go ahead and figure out what class this uses toolbar title right so i should be able to go to toolbar title just say give it a color white so cool we got a color white there and so that should be effective for everything and then we also have button content i'm pretty sure for the buttons if i were to go and add a dark attribute to that i guess it doesn't change i don't know something must have changed or i have something set up where it's not styling like it was before but anyway i'll just go ahead and add that so globally our buttons will have a white color text and then our headers will have a white colored text for that all right so at this point um i think it'd be nice to add a a fixed header at the top and have like you know the name of the app maybe like a hamburger menu so i can open up a site nav and a login and log out register button so what i'm going to do is if you go to beautify i think they have a toolbar so toolbar is one of those components that they have and again they have like examples what not you could view the code to see how how exactly do a toolbar um again they have a ton of different examples so this is really good documentation so what we're going to do is inside our components let's just go ahead and make something new called header.view and that's going to represent our view header so inside here of course let me just go ahead and copy an existing one and gut it out so go here gut out that code and that code get rid of all that boom so we have a blank i have a blank view.js file or sorry a blank view file and what we want to do is we're just going to say our header is going to be composed of a toolbar which is fixed and that's one of the special attributes that you can find in their documentation go down here at the bottom their api says they have a fixed boolean that you can do sets the position of the toolbar to be fixed and that means that's basically going to stay attached to the top of the screen like if you notice this blue bar up here it's fixed so if you just add fixed here it should just become fixed go ahead and give it a class assign as well go ahead close that off so we have a toolbar let's go ahead and add a title to it so v toolbar title class of margin rate four we're going to call this tab tracker save this and now at this point we should be able to start using this so if we go to our app.view page what we want to do is we want to bring that in so first of all we can say components we want to bring in our header and of course we need to import that so i can say import page header from component slash header.view i think header might be a reserved keyword and view so i had the name this thick page header so once we include line 9 which basically brings in the header.view file that we've declared or component that we declared we can pass it into this components to allow our app to actually use it and what we mean by that is we can go over here and actually say page header and put it inside the template here and now when we save this make sure there's no let's see trailing spaces is not allowed on the header maybe that was the issue yeah so now if we go back to our client nice we have a fixed header at the top so you saw how easy that was to add something you basically just read through their docs look at their examples oh copy and paste it into your code and then change it as needed and then i'm also just kind of typing this from some notes to have it look a specific way for me so first thing you'll notice is this panel right here is a little messed up and i think we need to do a little bit more work on adding all the beautify components so i think if i go back to the beautify i thing somewhere they have it and they say you must have your app that looks like this pretty sure they say this so if i were to copy this and put that here that's probably why like my dark styles aren't working so basically they say you must have a v app and inside here you must have a main which has a v container and then inside the v container we can go ahead and put our router if we want so go ahead and put the router in we don't need this image anymore i'm going to go ahead and put the main page header on side view app there uh oops i thought i deleted that so go ahead and delete that go ahead and add a fluid attribute which basically allows it to be a fluid layout go ahead and save this and hopefully that works boom so we have a nice spacing already added for us because that's what beautify does for us um let me just try something out really quick i wasn't sure i wanted to add dark here and see what happens without having to actually like hard code get rid of this stuff yes okay so that whole stuff i added before with the colors we don't actually need because once we've set up our app to use this particular v app we can then start using dark onto things that we want to change the text to white so like in this case we can add dark to this save it and i believe this will become white awesome and then same with the button if we go to that register find b button add dark to it our text will become white so that's built into beautify so we don't really need that css hack that i did it before so sorry for about wasting time on that but at least it was fun to figure out how to do globally styled stuff inside that view style tag down here at the bottom and the same with this i doubt we even need that border bottom anymore because i assume that that's working now cool it goes to show make sure you read the docs before you start using because it says right here you must wrap everything in view app and i wasn't doing that so shame on me huh all right so cool we have a fixed top header here and what we want to do is over on the right let's go ahead and add like a login or a logout button depending on if you're logged in and then also like a signup button so let's go back to our header so here i'll go to header.view and then inside here we can inside the v toolbar which again is that cyan color toolbar we can add another component which is built into beautify called b toolbar items nsib toolbar items can add let's say a button and it's going to say browse and we can just um make that a flat button and a dark button see what that does oops name my brows instead so this is a browse button when you click it it's going to take you to all the songs but we can implement this later on let's go into the very far right we need to first add a v spacer and again these are in the beautify docs but a b spacer is going to pretty much allow you to put things all the way over here fixed to the right and then at this point we can say v another v toolbar items and then inside the v toolbar items let's just go ahead and make another button let's make it flat and dark the button and what we want to do is name this a sign up button and just to so we have to worry about this stuff now let's just comment out that browse button because we're not really even worrying about that functionality so we can come back later and you know say add a nice little todo there so we know to come back and fix it up so now we have a signup button over here you you saw that pop up and what we want to do is we want this to actually navigate us to our register url so if i were to go to the base url here and click sign up it doesn't do anything because we haven't actually linked it to our view router so one thing that if you go to the view router documentation one way they tell you you should do this is by using a or the docs should be like the first link when you go to a github i'm not sure why they have it like hidden okay so router link all right so this is kind of one way you can kind of make links work basically you can use a router link which will wrap whatever you do inside an a tag and then you can do special stuff like writer link to whatever so i'm just going to go ahead and copy this let's just go ahead and put it right in our application sign up i'll say go to the register page and then we have to verify that we actually have a register page so if i were to go back to my router we do have a name called register and what this does is basically whatever you put in this two so two equals register it's going to look through this router routes array and find anything that matches that exact name and then if you were to click on it it's going to go ahead and point you or navigate you to that so you see here it's now a link with sign up if i were to click it it does nothing and that's because i think maybe i need to just wrap this on the outside yeah i don't know i guess the button was catching and preventing the propagation down to that sign up event so one thing i'll point out is this is again one way to do your whole router logic and it kind of wraps your html elements with a an a tag you see here and it completely jacks up your style i don't know if there's a better way to do it in beautify so please leave me some feedback if there's a better way to do this but my approach to a solution is instead of wrapping it with that router link directive or component instead what we can do is just say if a user were to click on this let's just go ahead and go to a register page manually so what we can do is manually you know set up a methods here so on click we can say methods and that's going to have a nav navigate to method and then we'll say route here and then when you use vue.router basically you have the router object that's put onto every component's local object so you can access the router by doing this dot money sign route and then i can push a new route by just doing like this so money sign or out push and then push the route in fact i'll change that to an object like this let's have name instead of two i'll put name so kind of a workaround not sure if that's necessary but it keeps the button completely styled how it should be and when i click it it goes to the register page oh maybe not i'm getting an error error in the event handler for click this.route.push is not a function oh should be router my bad so i changed that the router and now it's working so you saw here i clicked on sign up and it goes to the register page another thing i want to do is i want to be able to click on this logo here and go back to the home page so again if i were to go back to the app and go to the header view we could simply just i don't know should maybe we should make that a button too yeah i don't know but i'll just make it for now a span we can come back and change this later it's not that big of a deal so make it a span for now so if you anyone were to click on that span it will navigate them to the root i don't think i have a root installed so if i go back here to path and name this root now if we click on this it takes us back to the root of our application and again we can do some styling here right now like there's no hover effect there's no cursor um let me just do that really quick it's not that hard to do so in here we could say class equals logo i'll just say home so now that style that span has a class of home onto it if we go down to the scoped styles we can say pointer is or cursor is equal to the pointer save that now we have a cursor when we hover over it in fact let's just go ahead and do like home hover color is pick some random color cool and we can change that color later on but again recap we added a fixed view toolbar header by doing let's say a v toolbar fixed gave it a class a sign in dark so that the text is white remember dark makes the text white cyan changes the color so we can go over here we can just like green see how it changes the green or i know blue and there's a bunch of colors already defined on beautify so if i go to the style drop down and go to colors we can basically use any of these colors so they have like that one's cool let's use orange darken two so if we go over here change that to orange darken two and go back to our app awesome but in this case let's just keep it as cyan save that and start moving on to something new such as the login page so for the login page we we already have a way to register right but we don't really have a way to keep track of the state if the user's already registered or logged in so let's go ahead and work on adding a login component which we can you know have a link up here called login so let's just go ahead and go to that header we can go down here and say let's just go again go ahead and add a new button called login so i'm going to go ahead and say login and when we click it it's going to go to a login state so we have login here click it goes to login state but login state does not exist yet so if you remember you need to go to your route or router we need to go ahead and add a login state which means we need a login component which we haven't created yet so let's go ahead and copy a login component so go to register and i'm just going to copy and paste a register component because it's going to be very similar right so now if i were to just go through here anywhere it says registered let's just go ahead and rename to login and then for this logic we're probably not going to use it actually we might so right now we're kind of assuming there's a login method on this service um but there's not so let's just go ahead and save and see if this this works all right so now we're at a login page we have this login panel email and password we have a login button if we were to click login this should just throw an error mainly because login is not defined yet so you saw how easy it was to add a new link at a new view at a new component called the login component and we basically just copy and paste register and we could just change it as needed so now at this point what we want to do is actually invoke a login endpoint with this email and password so if you remember if we go to authentication service so i'll go over here to services authentication service we don't have a login method so let's go ahead and create one so if i were to copy and paste this change this to login we want to do a post request to a login endpoint with these credentials um again i think this is fine just you know prevent present an error if there's a login error call login from authentication service with email and password and i think honestly we're good to go with that got a little syntax error thank you webpack so now this point if i were to type in one two three test.gmail.com five six we hit log in and we go to the network tab we see that it does make a request to slash login using a post request it's pasting the payload email and password here and it's returning a 404 not found and why is that well it's because we haven't actually implemented a login endpoint all right so let's move on to the back end and try to implement that login endpoint so if i open up the server package and first go to routes we can just go ahead and copy these routes and what i'm going to do is just indent that and go to login and basically we actually don't need a policy for this one at the moment or let's not even focus on a policy so let's just focus on adding a new login method to the authentication controller so save that file and i'll go over to authentication controller let's go ahead and add a new async login method and inside this method um we're going to do let me just copy and paste this code what we need to do is first find a user which matches the email that's passed in right so the first thing we need to do is grab that email and password that the user has passed in in their body so we could do that on line 16 and then instead of creating a user here we need to find one so find one user where the email is equal to the email that the user is passed in and we can do that like so so instead of using create we do find one it should return a user object and if it doesn't return a user object it could be undefined or null what we need to do is say if that user object is not defined let's go ahead and send back a 403 which is the authentication error status and then just say error the login information was incorrect it's typically a good idea to return generic messages back to the user when you're dealing with authentication or logging in so that a hacker doesn't you know find a way to figure out all the different users that are in their system so again we grab the email and password from the body we find one user in the database which matches the email we check that we actually found something and if not we're going to return a 403 status make sure you have return there and then finally what we need to do is say is password valid we need to verify that the password the user passed in matches the password that's attached to the user model so i could do this is password valid equals password equals user.password and say if the password is not valid again we're going to do that same logic to just return it 403 and just say the login information was incorrect and then at this point if everything was good to go we're just going to return that user so i'll say user json is equal to user.2.json and we can send that back here and again if there's any type of error whatsoever we can just again return like valid login information i shall say an error has occurred trying to log in and in this case i think that might be like a 500 error because if for some reason you failed to make that sqlize call and it's pretty sure there's something wrong with the uh server so return 500 status to the user so they understand that it wasn't their fault so at this point we can go ahead and try to test that endpoint so if i were to go and make sure that we have a account registered we do and we go here and try to log in because the login information was incorrect and so let's try to figure out why that's happening you may not even be finding that user in the database so it's finding a user you see how it printed out user here so it should not be getting to that let's print out what's happening here it's printing out false it's saying password is not equal to user.password so let's go ahead and just do a little bit more debugging try to figure out why this is having issues and the password that user has is one two three four five six and the password expects is seven eight so for whatever reason i'm not sure why that user has password length of 6. so what i'm going to do is i'm going to go to the app.js i'm pretty much going to clear out the database so if you in in sqlize if you do sync and then pass this force flag it basically drops all of your tables so this is very dangerous in a production environment but when testing locally if you want a clean database you can just go ahead and add that and then run it so now that that is ran we should not have a single user in our database so i'm going to go back to register register with testing and then log in with this and it let us log in this time cool so we want to do jwt or java or json web tokens for kind of our authentication method so the first thing we need to do is install a package called json web token so i'll say npm install save json web token and while that's installing basically we can come up here and say const jwt is able to require json web token and we also want to go ahead and just include that config file that we had created earlier and i'll write a helper function called jwt sign user which basically is a function which is going to sign a user object using the gwt library to give us back a gwt token so i'm going to say first of all i'm going to declare this variable called one week which is basically 60 seconds times 60 minutes times 24 hours in a day times seven days in a week and i'm going to return jw.sine give it the user i'm going to give it a second argument is some like options so let's say authentication.jdw jwt secret and then the third one is some more options where you can actually pass in the expires in so in here in config let's go ahead and define an authentication uh key and we say jw secret is equal to process env jwt secret or secret and basically what this is going to be used for is signing the jwt's token you typically need to pass it a secret string and that secret is only known by the server and basically it's used to determine if the jwt token is valid or not because technically anyone can go to you know jwc.io and create their own token and try to send it to my server but if they don't know what this secret is then my server is going to be like yo that's a bad token and just reject it and we'll see this used later on when we bring in passport and start validating using passport but for now our goal is to just send back a jwt token when the user signs in so again we have this helper method and what we need to do is down here we could just send back token jwt sign user and pass it to user json here so now when i save this file and go back and hit my login endpoint we get back our user information and we also get back our token all right so now as you might have seen when we register a user it's storing the password in plain text and that's again another security concern you shouldn't be doing that so let's go ahead and try to fix that issue by just using bcrypt and encrypting the password so yet again we're going to install another package and this one's going to be called be crypt node.js and basically as a package you can use for encrypting insulting and hashing passwords or whatnot so maybe i should rephrase that i'm not going to encrypt the password i'm just going to add a hash with assault hash so we can easily check to see if the password that's sent in by the user matches what we expect in the database so now that decrypt is done installing if we were to go back to the user model i'm going to go ahead and include that bcrip package and i'm going to promisify all of that be crypt package i like to use bluebird as the promise library i don't remember if we already brought that in so let me just go over here npm install bluebird and basically promisify all is going to take any typical function which has like a callback structure and it's going to wrap it to allow us to use the promise format and again i don't know how much that really matters since we're typically going to be using async and a weight where possible so this might even be used let me just try to write this out and see if we need it so i'm going to change this up a little bit i'm first going to say change this to that because i need the actual reference to the user object i need to return the user object here so that's just like a little refactoring just so i have access to user here and what i want to do is i want to on the prototype attach a method called compare password and that's so that the user model is kind of the one that's doing the the password compare instead of the controller and that's useful if we need to do like password comparisons anywhere else so starting off instead of doing that compare password where i do password is equal to user password we expect the password to now be encrypted so what we need to do is return be crypt compare async candidate password actually i'll change this to can candidate actually i'll just keep that as password why not so compare the password to the model's password in fact change that to function because we don't want to use the fat arrow so assuming that the password is stored using bcrypt we can just compare the password that the user sends in against the model's password so again any user object now is going to have that method so instead of having to do this logic up here we could just say user dot compare password i could pass it password and i could say await since that's going to return a promise i believe and now that's going to call this method which is going to use bcrypt to compare that password against the model's password and the second thing we want to do is before we store the user we instead want to hash the password so if i were to go here and say hooks i can add a couple of callback functions so i'll say before the object is created we want to hash the password we want to say before the object is updated hash the password and before we save this object also hash the password and then up here we can go ahead and just declare function hash password that takes a user object and options and so the method for hashing the password we first need a salt factor which is just used in by decrypt not sure what happens really behind the scenes i have to look into that but the second step is we need to check if the password has changed at all so if the password hasn't changed we can just go ahead and return out of this hash password function and not do anything otherwise we need to call bcrypt we need to tell it to gin generate which is gin salt async using the salt factor we need to then take that salt and then decrypt using the user's password so basically we just take the plain text password and we salt it which will give us a hash we can then update that user's password value with that hash so at this point let's just go ahead and do force true again to clear out the database of all those bad passwords and i can go back to here go to the register endpoint go ahead and register that user saying the account is already in use so i probably have some type of like exception that's been thrown so let's first make sure that we're getting into this hash password function okay so i guess they didn't clear the password last time so now you see that we registered and we got a user back with a strange looking hash of a password at this point what we can do is if we were to try to log in it's going to check that one two three four five seven eight string password against the hash to verify if it works or not so i can go back to here and just remove that um okay so let me just recap again really quick what all changed so inside routes we added a login endpoint which calls the authentication controller login method and then we went to authentication controller we added this login method which basically grabs the username and password from the body we find the user using the email we check if there wasn't any email our user returned we just returned an error if for whatever reason the password they pass and does not match the user's password return an error otherwise we are going to go ahead and return a jdbt token with that user information and that's about it for that and then the register endpoint we didn't change we did add this jwt sign user helper method which is used for generating that jwt token and then inside the user model we added some hooks which basically run whenever or before we create the method create the object update the object or save the object would cause it calls the hash password method up here which basically takes that user password and hashes it and then saves it again and then finally we added a prototype method called compare passwords so that any user model we can call compare password as needed and in fact just to make things a little bit easier let's just go ahead and do the exact same thing for register like we can return a jwg token while after they register otherwise i think the user would have to call login after registering to get that jwt token which i don't know i don't know what the better approach is for this but that's basically how we're going to go forward with that so at this point let's go ahead and go back to the ui remember we had that login endpoint that we created and let's verify that it actually works so if i go i think the account was testing or test yeah oops testing at gmail.com password is one two three four five six seven eight if we were to hit that login endpoint does it work yes it returned us the token and the user and again we did change the register method so let's go back here and try registering with something regression test manually so yes it allowed us to register we got back a token and we also got back a user and if i were to try to log in with that user we got back those things um one thing i'm noticing is it's allowing us to type in a plain text into the password instead of having stars so that's no good so let's go back to the client and go back to register endpoint i think we can just say type is equal to password here and do the same thing for the login controller okay that's working and i think one more thing i'm kind of annoyed how on the register page it's auto filling it's fine for login to autofill but i don't think that's good for the register page so there is a autocomplete new password attribute you can pass in to input boxes and that should prevent it from auto filling and i think it's also a good practice to like wrap everything in a form i think like internet explorer might need the form thing and then chrome uses this other thing it's just kind of a pain but whatever so hopefully now it doesn't autofill the register page good it doesn't because it doesn't make sense to me it's auto fill the register page but login that's cool for it autofills i don't really care about that all right so what we want to do now is we have the ability to log in and register and we get back that jwt token at this point let's bring in the view x library for the front end which is if i go to view x npm or maybe i should go to github not really sure probably github has better documentation basically vue x is the equivalent to redux which is the flux implementation you can go through these docs if you want to but basically when your application gets larger and you have components kind of interacting with other components the original approach was to use like message passing so like your parent component would use props to pass down to your children and your children will use events to propagate up to the parent and that's fine or you could use like a message bus to kind of communicate between all your components and i think it's fine for small applications but everyone always says that it gets out of hand when an application gets larger um i'm not really sure if that's the case because they don't really have that in angular one and i didn't see an issue with message passing becoming an issue in angular 1. maybe my application wasn't big enough but anyway they say you should be using vux for something like that if you need to keep track of a state that's used throughout your application and in fact that token that we're passing back and the user id those are two things that we want to keep track of throughout the entire application so it makes sense to use vuex here so i'm going to go ahead and again do an npm install but this time on the client i'll go ahead and install vue x and then i'm also going to install something called vuex router sync and it's a good way to kind of sync your router to your view x view x store so while those two are installing let's go back to our front end close all these tabs to make this all manageable go back to source we can go back to main and here let's go ahead and import the sync from vux view x router sync and we can go ahead and say sync store to router we need to import a store which we're going to have to define ourselves so import store from store store which means we need to create a store folder inside the store let's go ahead and make a store dot js so basically inside your store let's go ahead and import view let's import view x let's um tell view to use view x that basically allows you to access your store and all of your view components and then we can go ahead and create the store i think i could just do that export default new view store i'm going to say strict is true which means that you can never modify the state unless it's through an action or a mutation um for state i'm going to go ahead and just put token null and then user null and also say is user logged in i'll say false so these are kind of the global states of our application that we want to keep track of and they can be used for like adding stuff to the headers or changing and changing what's displayed in the header or side now depending if you're logged in or not and i'll go ahead and add a couple of mutations actually i think it might make more sense if i just keep it you know start with one and then add on later so how view x works is you have your actions your mutations and your state basically you should always invoke your actions from your like view components so your actions are like basically just like event names like i say set token which is going to take in a commit as a first argument and a token as a second and then inside your actions you typically want to call your commit or to your async calls basically this is where you do any type of async logic and then inside your mutations you'd have a method with the same name as that but in this case we're going to take a state and then whatever the the second parameter we pass in which is a token so here basically saying call the mutation called set token and pass it that token object and then inside here we can say safe.token is equal to token so it's kind of a lot of extra like work just to freaking change the value of a token but i guess it's supposed to allow your application to be easier to follow because you know that in order for this to change you must be invoking either you must invoke a mutation in order to invoke a mutation typically you want to invoke an action but okay so how does this help us right so when we log in if we go back to that logging dot logging.view component at this point if we keep track of the response that was returned which will have the username and the password our username and the token we can use that and call that action using dispatch we can say set token response.token and basically that's going to call our stores set token method which is going to call our mutation set token which is going to update our state to token and then we could do the same thing with a set user so response i think actually should be response data user and response data token so same idea with register go ahead and just copy and paste that code same idea set token and set user based on whatever we got registered or whatever is returned from that register endpoint and then i'll go ahead and save that all right so let's go ahead and just force refresh the page just in case and for view x you can install a chrome plugin called like i think it's called view i don't know what it's called but if you search the chrome store it's called view dev tools so if you install that you basically can keep track of the events that are firing off and how they're affecting your application so like in this case if i were to change this to testing at gmail.com change the password to that and hit login we are getting an error back okay so i was kind of looking through the code and i found that i needed to add s it was mutation and i needed an s and then also i'm trying to call i'm trying i'm like jumping the gun right here i'm trying to call set user and we haven't even defined set user so that's an oopsy on my part again so let's just go ahead and allow us to also set a user state so set user users null and hopefully this will work this time it's going to hard refresh just in case there's like any type of issue please work no uh is it because i use a lowercase u there probably moment of truth oh my page refreshed oops all right sorry this is getting kind of annoying but you know debugging is part of programming so you got to get used to spending 20 minutes debugging something where you've left off a character or something all right i'm going to pause this video and i'll come back when it's fixed because i'm wasting too much time all right so i realized that in the main.js file i completely forgot to add state or sorry to add store so before vue had no idea how to even access the store but now it should be able to access the store now so let me just refresh this page and try that one last time cool it worked so now in this view dev tools you can actually see every time that we commit an action in the state changes we can kind of check how this state is changing over time if we want to we can actually revert and time travel back to like the state of the application before i set those tokens and time travel forward and we'll see this how this can be useful later on when i'm trying to hide these login and sign up tokens up here um so let's actually try to use those right so if we were to go to the header now and we only want to show these if the user is not logged in so what i could do just add another state say is user logged in set that to false and i could say if token is defined go ahead and say state dot is user logged in and signal to true otherwise set it to false and then i could use this is user logged in if i were to go to the header component here in fact let me just delete this hello component just like is that we even using that still yeah i guess we are i'll keep that so anyway uh the header component if i wanted to hide those two items i could simply do v if and then i could say store dot state dot is usually logged in so this will only display if that is true in fact i added that to the wrong thing so let me add it to the button same thing here i'll add it to the button so only display it if the user is not logged in so i'll go ahead and negate that save that file and hopefully these are hidden now i think i need to relog in one more time all right so after we logged in you saw that those two links actually disappeared from the header and i can go back and time travel to like different states so in this state user and token and is logged in as false and this state token is defined is user logged in is true uh user is no for some reason i think that's because we totally forgot to uncomment that code here so i will do that change that to response data token make sure register is all good let me just hard refresh this and retest that one more time so i keep getting all these like teeny little bugs and that's because i'm i'm moving too fast so just a little piece of advice you know slow it down and relax you don't have to like be a speed coder because the faster you go the more chances you're gonna make stupid mistakes so hopefully i'll slow it down in these future videos all right so now the user's defined here we can go back in time travel and we can see those links appearing and just disappearing as we change our state all right so like always let's do a quick little recap so we brought in the ux module inside the main.js we went ahead and included view router sync and we included the store we told view router sync to sync the store to the router and then we also make sure you include line 29 setup view to use that store and then inside this project the client project we created a store folder we created a store.js export which basically says or pretty much tells you to use view x we create a view x store we tell it to use strict mode we created these three different state variables that we're going to be using throughout our entire application and then we created the actions and mutations that are needed to kind of change those as needed and then lastly in the login and register endpoints we are keeping track of the response that's returned from the server and we are setting token and setting user based on those two responses and we're going to use these two later on right now we're kind of only focused on is user logged in but these will be useful later on and then lastly in the header we wanted to hide certain navigation based on that state so we're saying hide the login button and hide the signup button if the user is logged in all right so that pretty much wraps up part three i think we did a lot of extra work getting everything set up with the registration and login and then brought in a couple of new modules so i think it's good to have a little break here maybe make part four in a little bit after this is all sunk in um thanks for watching again i'm cody seibert and feel free to follow my twitter to get updates as to when i release part four alright thanks for watching