welcome to this tutorial we're going to build a tetris game with react and the first question you should ask yourself is is react a good choice for making a game like this and to be honest i don't know it is probably better to build it with vanilla javascript but i wanted to do this for myself to test how this game can work out with react and sometimes i do this kind of projects just to yeah kind of expand my knowledge and try things out and the idea for this started when i was looking at the tutorial at youtube where this guy creates a tetris game with vanilla javascript and it's in this channel that's called methmeth method and yeah you can think whatever you want of that name the tutorial is really good actually and i learned a lot because i have to say this i'm not a game maker i create web applications and stuff like that and web pages so i'm kind of a rookie in the game development so it was fun to create this game with react and see how it works and in this video he used canvas i'm not going to use canvas i'm using regular divs and a grid for this one because i wanted to try it out also and not use canvas and it's also good to see how good react performs because there's going to be a lot of divs that we rendered to the screen because each cell in the tetris game is a div and i'm also going to borrow some of the code here and especially the one where we're going to check for collision when we rotate our tetra minor that is the name of the blocks in tetris big credits to this channel mathmath method and the video where this guy shows how to create a tetris game in just i think it's 50 minutes or so yeah and it's a really good tutorial if you want to learn how to build a tetris in plain javascript all right let's get to the app then and here's the tetris game that we're going to build i choose to have kind of a retro style to it with this stars in the background this is just an image i found on unsplash and we're going to show the score at the rows and the level and then we have a start button so if we press start game we can play the game and we're using the arrow keys on the keyboard for this one you rotate the tetra minor with the up arrow and you kind of go left and right with other arrows and down will make it go faster down there and there will be some limitation in this game and because this is not a perfect tetris game for example the key input we're just using the regular repeat here when holding down the down arrow key there should probably be a better function for this where we can control the speed of this one and also i will be using an interval for this one we could also use uh request animation frame where we can create kind of a more controlled animation so it will not be a perfect tetris game but it will be a good practice in react and especially react hooks that so many people are talking about now on the internet so we will be creating custom hooks and we will use state we will use use effect and use callback and also we're going to use react memo for minimizing or rerun this of the cells so i think this will be a good practice in react and especially react hooks so let's get to it we will start creating the game in the next video we're going to start to build our tetris game now and we're going to use create react app and i actually use that one a lot because it's great for bootstrapping your project and you don't have to set up your webpack and babel config and everything like that from scratch so i highly recommend you use create react app it's great and we create a project by go into our console in my case i'm using hyper and we just type npx create dash react dash app and we can call our application react dash tetris this will create the folder that's called reacttetris and then press enter and then we just wait it will take a second here all right we're good to go here and it's important now that you navigate into the new project folder you created so type cd react tetris and if we list the files you can see it has created some folders and files for us here and now i'm using style components for this game so we have to install that one also and we do that by typing npmi style dash components all right some arrows here but i think we'll be fine it's just on my computer i can clear the console i have also included some files in the starter files that you have to copy to your project folder otherwise it won't work so make sure first of all that you download the starter files it's on github and the link should be provided to you and then in the starter files you have something that's called bd.png that's the background image that the stars you see here then we have the font that's called pixel if i found this one on the internet it should be free to use so i hope it is and we have something that's called use indival dot js and that's a custom hook that's created by dan abramov that i'm going to use when we create the game loop with the javascript interval so we just have to copy this one over and i'll explain it later in the tutorial first grab the bd.png file copy that one and go into your project folder and inside the src the source folder we create a new folder that's called imd and that's for image of course and you can just paste the background in there all right then we have the font so grab that one copy that one and create another folder inside of your src your source folder and we can call this folder font go inside over there and paste the font inside of it and then we have the use interval.js file so copy that one and still in the src folder create another folder that's called hooks this is the folder where we're going to create our custom hooks so go inside of that folder and paste the use interval.js file and this should be it this is everything we need to get us started so in the next video we'll start to scaffold out some components and we'll continue with our application the first thing i do when i create the react application is that i scaffold out all the components that i need and that's what we're going to be doing in this video so first of all you can see that we have a lot of files here that was created for us with create react app and we're not going to use some of this stuff here you can yeah you can delete it if you want the logo the service worker the app test and stuff like that or you can just let it be because we're not using it now we are going to use the app.js file here and the index.js file for now and the index.js file we don't actually have to touch that one we can just go inside the app.js file we can delete everything inside of there so as usual our application is going to start in the app.js file this is kind of the highest component in the hierarchy so we import react from react we import tetris from dot forward slash components forward slash tetris like so and of course this one we haven't created this one yet so we're going to create that in a minute and we create our app function i like to use arrow functions for this one you can use a regular function if you want to do that but we have const app equals parenthesis and we're going to create an explicit return for this one so we just need parentheses then we can create a div with a class name of app and we have our tetris components like so and then we export default app and that's our app component then we can create a new folder inside of src folder that's called components inside the components folder we are going to create five different components so we can just create the file names now so we create one that's called cell.js make sure you have a capital letter here to start with or yeah maybe you don't name your components like that but i like to name them with capital letter because it's a component so we create another file that's called display.js and we have a new file that called stage.js and we have a new file that's called start button.js and the last one is going to be the tetris dot js file all right these are our five components the tetris.js file is kind of the heart of this application we can go into our cell.js file and start scaffold out this component so we import react from react as usual and we create the component const cell equals to parenthesis and we are going to have props for this one so we can create these ones also either structure them out we're going to have a type for this one and we talk about this later on we make an implicit return for now and we can just have a div and write cell inside of it and we export default cell like so we save that one and then we have our display.js file we import react from react we have a const that's called display equals and for this one we're going to have two props so we destructure them out one is called game over and one is called text and we create a div inside of here where we're going to have the text we create curly braces and text to grab that prop and display it inside of the div export default display we will style these components later with style components so we will change some stuff inside of them we just scaffold them out now so we know what components we're going to have for this game save that one then we go into our stage.js file we import react from react of course you can copy and paste a lot here also if you want to do that for this one we're going to import the cell component so we import cell from dot forward slash cell and then we create the const stage equals to i mean the structure of the prop that we're going to have that's called stage and we make an implicit return for this one also and as you can see i'm not doing any prop type checking for this course you can add that in yourself if you want to do that to verify your props with prop types all right we create a div for now again and inside here we're going to map through our stage prop and create cells from this stage prop and we're going to do that later also so it can just have a cell for now inside of this and we export default stage like so and we save this one then we have our start button.js file so we import react from react and we have a const start button and we have a prop that's going to be a callback for this one and we make an implicit return with a div that says start game and we export default start button like so we save that one and then it's the last one it's our tetris component or heart of this application so we import react from react like so and then we're going to have some components here we import our stage from dot forward slash stage also going to need our display from dot forward slash display and we import our start button from dot forward slash start button and these ones we can check them out here this is obviously going to be the stage with the cells in it and these are the display components we have three of them and this is the start game button here so these are the ones we've created now then we create our const tetris and equals to an arrow function and we have curly braces for this one because we're going to have more logic inside of here and we can create the return statement here first we have a kind of a repetitive here and as i said we're going to rename these ones when we style the components then we have our stage and for now we're not sending in any prop because we don't have anything to send in to it right now then we can create a side element that's obviously the sidebar here that we're creating and then we're going to have three different displays and for these ones we have a text prop and for now they can just say score we can copy this one and paste two times and this one can say rows and level all right we can also wrap these ones inside of a div and end it like that and below we're going to have our start button and it's going to get a callback prop but we don't have that yet either so we're not giving it that now so this is it and we export default tetris like so okay then we can store this up to see what we've got so mpm start and we have all our components showing up here and that's great they are of course not styled yet but we're going to do that soon first we have to create the stage and or tetra minus and we're going to do that in the next video before we do the styling so we can see the ui here okay we're going to create the stage and the tetra minus in this video and to do that we have to create a couple of new files inside our source folder or src folder we can create a new file that's called gamehelpers.js and that's a lowercase g on that one because this is not a component and we can also create a new file that's called tetrominos.js make sure you're inside the gamehelpers.js file here we're going to create a stage and we are going to have two const where we can set the stage width and height and we have to import these ones into our components so we have to export them from this file so we export const and then with capital letters we can have stage width and we can set that 1 to 12 and we export const stage height and we set that to 20. so that's our width and height but we actually need a function that creates the stage for us and the stage is going to be a nested array a multidimensional array that represents rows and columns and we have to export this function that creates the stage also because we're going to need it in our component so we export const create stage and it is an error function all right so how is this going to work well we're going to create a multidimensional array that represents the grid so we create an array from something and that something is another array that we're going to create from the stage height and this is going to be an empty array so it's not going to be useful for us so we have to do something we have to fill this up with something we can do that by supplying an inline function here and that means for each row we create a new array from the stage width and we're going to fill it with another array there's a lot of arrays here and for now we set it to zero and we have something that's called clear and these ones i'm going to explain that later on 0 equals nothing on the grid we have the different tetra minus each of them going to have a letter here so we know that the grid has that tetramino in that particular cell and we also have this clear property here that is going to be set to merged when we have a tetra minor merge into the stage that means when we have collided so the tetramino should stay in the stage and not be cleared in the next render and as i said i will explain this later on so i hope you understand this function what it's doing we're creating a new array from an array that we're creating here with a state height that's the 20 rows we're going to have in our grid and we're supplying an inline function that for each row create a new array with our cells and we're filling them up with this array here that has one value that is zero and that's represent a clean cell there's nothing in that cell on the stage and we also have this string here that says clear for now and that means that there's no tetraminer that has collided in this cell and we should wipe it out from the stage in the next render okay so that's how we create our stage and if you remember up here in the components we had our stage here and we had our prop that's called stage and this is the stage we're sending in from the tetris component so we can actually import this one here in the tetris.js file we can import our create stage function here and we grab it from dot dot forward slash game helpers like so and for now we can just send it in to this one we have the stage prop equals curly braces create stage and parenthesis because we we invoke this function here just check in so we're not breaking anything here no and we're going to change this later on because we're going to have the stage in a custom hook and a state for this one but for now we can just send it in so it renders something inside of stage component we can remove this one and inside the div here we create the curly braces because we're going to use javascript now and map over our stage prop so we have a row and we also map through that row and then we get a cell and our x value for that one so what are we doing here well we have the stage that's the one we created we map through that and when we map through that stage array we get the row and each row is also an array that holds the cells so we map through that row also and we get the cell so for each cell we are going to render out the cell component we can set the key to x and our type are going to be the first value in the salary and that's the one we created down here we're telling it when we initially do the render we're telling it that this stage is clean we don't have any tetra minor in the stage so we're grabbing this value here and that's a zero that we set it to initially go back into your state component we have to close this one also this one should hopefully render out the stage for us but as you can see we didn't style it yet so it's just a lot of cells here in one column but we're going to fix that when we do the styling later on all right let's get back to our code that's our stage now we have to create our tetra miners and we're going to keep them in a const that's called tetra minus and it's going to be an object so we export const capital letter tetra minus equals an object and we're going to have different properties for these ones first we can create a property that's called syrup because i'm going to use this initially when we start up the application we don't want to show a tetra miner on the stage but you could do it some other way of course but i think it's nice to have it inside of this tetra miners object alright so we create an object we're going to have a property that's called shape and the shape is also going to be an array with a race i noticed that there's a lot of arrays with arrays when you create games like this so we have an array then we have another array and we just set it to zero and then we have another property that's called color and this is just going to be a string zero comma zero comma zero like that so that's our clean cell that's what we're using when we're not showing any tetra minor and then we have seven different tetra miners we have the i j l o s t and said so we can start by creating the i so we create a new property that's called i and we create a new object for that one we have the shape property that's going to be an array and inside of that array we're going to have another array and as i mentioned before a zero equals nothing on the grid and we're going to use a letter where we want to show this tetra minus first we have a zero that's nothing then we have a string with a capital i then we have a zero and a zero then we create another array with another zero and another i and a zero and a zero and this one is just going to be a four by four so we can copy this once and paste them in like that and as you can see this is going to be the eye shape that is the long one the long tetra minor that's the only one that has four in width and we can make it a little cleaner here maybe i will not auto format this because it will destroy this formatting i've done here it's easier to see the tetra minor here otherwise it will format it in just one line for me and that's no good so we have another property here also so we have the color and this is yet again a string and this is just an rgb value i'm going to use in the css later on so i'm setting the call of this one to 80 227 230 so this is the i we have here and i guess we can just copy and paste this one make sure you make a comma here and we create a j and the shape for the j is going to be we can remove these last ones because it's going to be three by three so we remove the last row there also change this once to j j j and we're going to have a j there also i hope you see this oops it's going to be a string i hope you see this pattern here that this is a j and the color for this one is going to be 36 95 223 all right then we copy this one and paste we're going to create the l shape and it's exactly like the j but we change this one and put it there instead and of course we should have an l also as a value in these strings and the color is going to be 2 2 3 1 7 3 and 36 all right we copy this one make sure you don't forget the comma there and we're going to create the o shape and this is actually just going to be two values in so we have the o and o like so and oh so we have a two by two array there and the color for this one is going to be two two three two one seven yeah and also 36 for that one all right then we can grab the l up here copy it make another comma paste it we have the s shape and it's going to be a zero an s don't forget that this is a string here so don't forget the ticks here and then we have an s and an s and a zero and these ones are just going to be zeros like so and the color is 48 211 and 56 all right then we paste in yet another one and we have two to go we have the t and that shape is going to be zero zero zero then we have a t a t and a t and now we have a zero a t and a zero a nice little shaped t there and the color is 132 61 and 198 and then we have the last one and that's the said whoa kind of boring this but we have to do it otherwise we don't have any tetra minus all right this said we have a said a set and a zero then we have a zero a set and a set and then zero zero and zero and then we just have the color for this one and that's two to seven seventy eight and 78 all right so that's our tetra minus and we have one more thing to do because we want to have a function that generates a random tetra miner for us so we export const random petromino and we create the function for that one we have curly braces here so first we create the const called tetraminos lowercase letters and we create the string with capital letters i j l o s t said and this is of course the string with all our seven tetra minors then we create another const rand tetro minor like so we're going to grab a random letter from this tetra minor string and we do that by typing tetro minus that's the string const and inside of here we do a little math dot floor math dot random times tetra minus length like so and this is just a standard for generating random numbers of the length of this in this case the string so we have the string length and we're getting a random number for this one and i misspelled this one it should be tetra minus yeah so we have the tetra minor string and we're grabbing a random number for that one and that will return one of the letters for us and that's how we get the random tetra minor because now we can return from our tetro minus rand tetra minor so for example let's say that this will give us an l here so we have that one and we go to our tetra minus object and we have an l here and that will of course grab the l property for us and return this one here the l tetra minor with the shape and the color this is an object here so we get that object back and that's how we get a random tetra minor i type the zero here it should of course be an o there and save this one all right this was a lot i know i know and i think that's why i don't do games but i i recommend it to really go through this code and try to understand it as much as possible before moving forward in the next video we're going to create the styles with style component and after that we actually going to start to do some heavy coding on the game we're going to do some styling now to get this sad look out of this tetris game and if you're not a css person you don't like to style things you can just copy and paste the styles from the starter files into your project but you have to import them into your component as i'm going to show in this video and also change your divs to the components that we're using from the styles component i'm going to show you this soon so let's get on with it first of all we're going to create the global styling and actually i've been kind of lazy for this one because you can create global styles with style components but i'm actually just going to use this index dot css file that's yeah premade for us with create direct app and it's imported in the index file and that's because we're going to have a font and it's a little bit more troublesome to import it with style components so if we go inside the index.css file first we're going to set our body we're going to set our margin to zero and then we are going to import a font so we have a font face and the font family is going to be called pixel and we have a source src with our url and we grab our font from font forward slash pixel dash lcd7 dot buff we can also set the format to vof like so and we save that one yeah and we will not see anything happening here right now but that's our global styling then we can move up to our components and we're going to style the tetris component first and what i like to do when i use style component is that i create this folder that where i place all of my styling and then i import them into the components so inside of the components folder create another folder that called styles and inside the styles folder create a new file and call it styled cell.js i also like to name them like this with styled and then the component name and dot js so styled cell dot js capital s capital c and first we have to import style from style components and then we need to export our style component because we're going to import it into the tetris component when we created this one so we export const style cell and equals style dot and this is going to be a div we have backticks because this is a tagged function and this is how style components works you have this tag function and you can write regular css inside of it and if you don't know style components i really recommend you to read more about it at their webpage i'm not going to go through everything with star components in this tutorial because as i said before this tutorial is about showing you how to build a tetris game with react and i assume that you know some stuff with react and yeah style components also otherwise it's not that difficult to use style components so i think you will pick up a lot just watching me create these components all right and i just realized i created a styled cell now okay i said tetris component but it's the styled cell i created now so well let's create the styles for the cell component first then okay we're going to have a width and set that to auto then we're going to set our background and that's going to be an rgba and we're going to grab this from the props that we send into the cell component so for now i just type this out and we go to the cell component and i'm going to show you how this prop work so we have a dollar sign curly braces and props and an arrow function and a props we have one that's called color so that's how we get our rgb value and we set the alpha value to 0.7 this is just regular css so we're going to come back to this in a second but first we save this one and we go into the cell component and i'm going to show you how this works with the props so first of all we import our styled cell that's the one we created and we grab it from styles forward slash style cell like so then we also going to need our tetra minus so we import our tetra minus if you remember that's the one we created down here it's an object with different tetra minus so we grab that from dot dot forward slash tetra minus all right so now we got everything we want in this component we can now first change this one to our styled cell that's the one we create here and we import it in this component here so we use it here you could write the style component inside of this component and many people do it like that but i like to have them separated because i think this is yeah i like this structure of things so you can do whatever you want and then you don't have to do all this export and import stuff that i do here okay so this style cell is going to have a type prop and we grab the type from type we are sending that in here and now we're passing that prop into our style component and then we're going to have a color and the color we can grab from the tetra minus and the type is going to be the tetra minor so we if we for example have the type of l it will grab the tetra minus l for the color and of course we're also going to grab the property color because when we created the tetra minus we have both the shape property and the color properties so this is the one we're grabbing here is the color property from the tetra minus all right so for now we can just we change this one to yeah we can say on l because we're not sending in anything to this component yet because as i said i intended to do the tetris first but now we do the cell here instead and as you can see now we're getting the color here but it will color everything here and that's because this cell row you see it's the com it take up the complete width here so the color is there but we haven't created the grid yet and that's because it's showing all yellow now because each cell is a hundred percent with right now all right let's go back to the styling we need some shadows on our tetra minus so this is also how it works with props that you send into your style components you can grab them with an inline function like this because this is a tagged function you can use a dollar sign and curly brackets and use expressions inside of these ones and by using this inline function we can grab the props that we send into our style components and we had one prop that is called color so we're grabbing that one inside of here all right so that's our background we also want to set our border yet again we have a dollar sign and curly braces we have our props and then we're going to do a ternary operator here we check if our props type if that one equals to zero that means we not have a tetramino in this specific cell so we don't want to have a border so we set that one to null pixels solid i don't actually yeah i don't think we need solid here but yeah let it be there for now otherwise we set it to 4 pixels solid all right then we have our border bottom color and that is going to be on rgba and yet again we have a dollar sign curly braces we have our props and we have our props dot color and we're going to set the alpha value here to 0 to 0.1 we can actually just grab this one and copy and paste it in three times because now we have border right color and that one we're going to set to one and then we have border top color and we set that one to one also and bore the left color and we set that one to 0.3 and this will give us kind of the shadow effect on the blocks yeah if you don't like them you can just play around with this and set your own shadow and this is also what i like about style components because you can send in props like this we can easily modify your css conditionally with props and that's really nice actually so what i'm doing here i'm just using the same color value as we set in the tetra minus object but i'm just changing the alpha value to get different opacity on the blocks all right let's go to our tetris.js file now and do it in the right order here we are going to create two different style components here we have one that style tetris wrapper and one that's called style tetris so we have a wrapper around here and we have the tetris also we can actually just type them out here so we can see the structure of it here is going to be a styled tetris wrapper like so and we close it down below there and it will complain of course we haven't created this one yet and then below we're going to have the styled tetris component and of course we have to move that down here like so and i will explain later why we have this wrapper here so these are the two style components so let's create a new file inside of the styles folder that's called styledtetris.js and inside that file inside styletetris.js import style from style components like so we also need to import our background image so we can call it bd image and we grab that from dot dot forward slash dot dot forward slash imd pj dot png like so then we export const or styled tetris wrapper and that one is going to be a style.div and we have our backticks because this is a tag function we set our width to 100 viewport width and our height 200 viewport height yeah this is just regular css now and i'm not going to explain the css here either i hope you know your css otherwise you can pick up some things here but i won't explain them yeah in detail and here we can set our background with the url and now we can just use our bj image and we do that by creating a dollar sign and curly braces and inside we have our bj image and we can set a default color to zero zero zero we have a background size of cover and overflow is going to be hidden for this one and this is also great with style components because otherwise if you set a background image you may have done some inline styling to get the image to show up as a background image but here we can just import it and use it in the style component like this so we don't have to do any inline styling on the component itself all right then we have our export cons to style tetris and that's going to be a style div also type function this is going to be a flex align items to flex start we set our padding to 40 pixels and we have a margin of 0 and auto and a max width of 900 pixels the css here is not really optimized you can try to get a better look for yourself if you want to do that i haven't put that much time in the css styling i just wanted something to work fairly good so you could probably improve the css and get a better grid and stuff like that and inside here we have our aside and we're going to style that and this is also great with star components of course you can nest them inside of here just like you do in sas for example so we set our width to 100 a max width of 200 pixels we set our display to block and padding to 0 and 20 pixels like so and that is going to be our style component for the style tetris now we just have to import it up in the component so we can import our styled tetris wrapper and or style tetris and we grab them from dot forward slash styles forward slash style tetris and no it shouldn't complain here no all right and as you can see we are gradually exchanging this one to something else so we see the space here now and we see that the cells are just yeah these tiny bits now all right then we can create another style inside of styles folder that's called style stage.js and we create the style first so we import styled from style components then we export const style stage and it's equal to styled div and we have backticks course it's a tagged function and we're going to display a grid for this one we have our grid template rows it's going to repeat and we're grabbing from props or props dot height or coma and then we're going to do some css calculation here we have 25 viewport width and we divide it with we have dollar sign and curly braces because now we're going to have another inline function another inline function to grab our props and we grab the props dot width and this is going to do some nice little calculation for us to make the grid look nice and we are doing this to keep the aspect ratio of the grid cells then we have our grid template columns that's also going to repeat and from our props yet again we grab our props dot width and it's going to be one fragment and of course that one should be there like so these calculations is because we want to keep the aspect ratio of ourselves we want them to be perfect squares all the time and this is actually kind of tricky to do so yeah i've got it to work yeah fairly responsive but not 100 percent so if you come up with a better idea feel free to change it to whatever you want we want to have a grid gap of one pixel and the border going to be two pixels solid and we can set it to three three three we have a width of hundred percent and a max width of 25 viewport width and a background of say one one one all right so that's our style stage we just have to import it into the stage component so make sure you're inside the stage component and import style stage from dot forward slash styles forward slash style stage all right and then we rename this one to our style stage now we close it with the same and we're going to send some props inside of this of course we had a width and that one we're grabbing from we are sending in the stage as props to this one so if we grab the stage and the first row and the length we know the width of our grid and the height we just grab the stage length like so and that will give us the height from our multidimensional array all right we save this one and see what we've got and as you can see we have something here so we're slowly getting there we can actually now also go back into the cell component and we can remove the text here we don't need that one and that's why we can just selfclose it like this and that will get us our grid and here you can also see the shadows that we created in the cell component and it works fairly responsive what have we got left to do we're going to style our display and our start button inside our styles folder create a new file styled display dot js and import style from styled components and we export const styled display and it equals a styled div and yet again backticks box sizing to border box we display flex we align items to center why i'm using flexbox is to align the text in the different displays we have a margin of 0 0 20 pixels and 0 we have a padding of 20 pixels we have a border of 4 pixels solid and a triple three we have a min height of 30 pixels we have a width of 100 percent a border radius of 20 pixels and the color and that one we're grabbing from props yet again we have a dollar sign and curly braces we have our props and we do a turner operator because we are using the same display component when we did play game over as we display the score and rows and things like that so we have a prop that's called game over and if it's game over we set the text to red otherwise we set it to some grayish and we set the background to black we have a font family of pixel that's the one we imported in the global css file and we can set it to yeah some fallback fonts here and the font size of 0.8 rem like so and then we just have to import and use it in our display component so we import or styled display from dot forward slash styles forward slash style display and then we change this div to our style display component and we also had our prop that's called game over so we send that one in like so and let's see what we've got and there's some nice displays and we have this retro font inside of them and that's good we just have to style our start button and then i think we'll be good to go to do some heavy coding on this game so inside of styles create a new file and call it styled start button.js import style from style components getting boring boring boring but we have to do this so we export a const and style start button and we have a styled button double backticks and inside we write our css we have our box sizing and we set that one to border box we have a margin of 0 0 20 pixels and 0 we have a padding of 20 pixels a min height of 30 pixels a width of 100 and a border radius of 20 pixels a border we set that one to none we have a color of white a background of a triple three we have a font family of pixel and some fallback fonts we have a font size of one rem on outline of none because we don't want to display that ugly outline when we press the button we set the cursor to pointer also and we save that one and inside our start button we are going to import this one so we import styled start button from dot forward slash styles forward slash style start button and of course we change this one to style the start button we are also going to have an on click handler on this one so we can type it in now so we have the on click and it's going to be a callback all right so that's the start button and it's showing nicely but nothing is happening now because we don't have that callback created yet but we have something that looks like a tetris we're just going to remove this yellow one from our cell because the type is going to be the type and here we also change that one to type because that was only to show you what we were doing here and as you can see now we have our grid here instead and that's nice because that's our playing field and everything set up for us so we can start coding the real game here and we'll start with that in the next video so see you then okay we got our stage our displays and our start button and it's time to code some logic for this game and how is it going to work yeah well we're going to have this stage of course with the cells here and we're going to have a player and we're going to use react hooks to create this game and two big advantages with hooks is that you can abstract them and you can reduce them and compose things together and that's really great and for this game we're going to create three own custom hooks and that's the use stage use player use game status and the use in the well is the one that dana remote created for us and the reason that i created these custom hooks is that i want to kind of separate out the logic for different things so we have all the logic for the player in the use player hook and we have all the logic for the stage in the use stage hook and we also have the use game status that is going to have yeah mostly the display logic that we're going to show like the scores and things like that and how many rows we cleared so that is how we're going to divide up the code and we have the tetris component that's going to be our main component as i said before that's the heart of our application and as we're creating a game we're going to have some kind of game loop and as i also said before we're going to use an interval for this one and not using yeah maybe the more sophisticated way where you get animation frames and stuff like that so we have this grid here that is uh represented by the array and we can actually console log this one out so we can see what we have in our array so inside of here somewhere we can console.log create stage like so and i'm just going to show the console here and as you can see we have an array with 20 rows in it and each row has 12 cells and as you can see here we have a zero and that means that this cell is clear we don't have a tetramino in this cell and it's also set to clear as we can see now we just have a clean stage here so everyone here is clear and that means that we don't have any tetramine or merge into our stage because when we collide with something we're going to change this one to merge and in the next render we're going to keep every cell that has merged here and that's the way we keep the tetra minus that has collided i think it will get too much more clearer when we actually create the tetra minor and how our game loop works because the game loop are going to do a couple of things for us the first thing we have to do in our game loop is that we clear the stage and then we check for an emerged cells here and we don't clear the merged ones so they are going to stay in the stage they're going to stay in the array for a stage and then we're going to check the position of our tetramino and if it hasn't collided we are just going to set it to clear again and that means for the next render it's going to be wiped out and it's going to move and that's the way we get the illusion of movement here or maybe it's not an illusion it is a movement but the tetra minor that hasn't collided is getting cleared on every render but if we have set this to merge it's going to stay in the stage and then we do this over and over again with our innerval and that's the way we get the movement for our tetra minor so that's the short very compact version of how this game loop is going to work and we also kind of have to look into the future because we are going to check the collision before we actually move the player so when we make a move if it drops or if you move it with the arrows on your keyboard we first check the collision before we make the move and if it collides we don't make the move because then we know that it has collider we always check the game field the stage one step ahead before we make the move and that is also going to be much more clearer when we actually do this coding i just wanted to explain it shortly for you so you have a rough idea of how this is going to work all right so let's get back to our code we can start in our hooks directory in our hooks folder and inside of that folder we create two new files we create one that is called use player dot js and one that is called use stage dot js and as i said i always name my files as the component or in this case the hook itself and in react you always name your custom hooks with use before the actual name so in this case it's use stage and use player so we can start off in the use player.js file so make sure you're inside of that file and we import and we're not going to need react for this one we just need to use state state from react because this is not a react component so we're just importing the use state then we can import our random tetra minor function and we grab that from dot dot forward slash tetra minus then we export const and we have our use player as i said it's important to have used before otherwise react won't know that this is a custom hook and we have an error function curly braces and we're going to create a state for this one and that's the only thing we're going to do in this video then we're going to build more up on these files in the next videos we're going to create a state now with a hook that's called use state that we imported up here and use state will return an array with two items in it for us and that's where we can use es6 destructuring to grab these two values so we have a const and we have an array that we want to destructure and we can call it the player and we have the set player and we use state and this is the way that you state works as i said we get two values back we got the actual state here and then we have the setter for this state you can call them whatever you want they don't need to be player or set player and this is just two values that we destructure out here so this line here is actually short for all of this we have a const with player state maybe and we use state and then we have our player and we grab player state and the first value in the array then we have our set player and then we have our player state and the second value in that array but by using es6 the structuring we can make it in one row here and that's very very convenient and that's the way you should do it when you use state so get rid of this we are also going to set an initial state for a player and you can actually send in your initial state to the u state when you create the state with it we're going to have an object so we have curly braces and inside we're going to have a property that's called pos that's the position for our player we're going to have an x value and we set at the zero and then y value we set it to zero also and then we have our tetra minor and that's going to be one of them we created down here that we're always going to keep in this state for the player and for now we can actually just set the random tetramino so we call that function and we're going to grab the shape from the tetra minor and if you remember we had one shape property and one color property so this is the one we're grabbing here that's the shape of our tetra minor zero equals nothing and the letter inside of here equals the cells that are occupied in our tetra minor and i choose to have the letter of the actual tetramine here you could actually have the same letter for every one of them it doesn't matter because we're just going to check if it's not zero when we render the tetra minor to the stage all right so we grab a random tetramino and the shape of that one and put it in our state for the player and then we're going to have a property that's called collided and we set that to false so that's our initial state for the player and now we're actually just going to return the player because we're going to import this custom hook into our tetris component and then we're going to need the player inside of the tetris component i'm going to show you this in a second for now this is it for the use player we're going to return to this file and we can now move on to our new stage hook and do almost the same for that one so we import use state from react so we import create stage from dot dot forward slash game helpers all right and then we create their custom hook so we export const and we're going to call it use stage and it's an arrow function curly braces and we create the state for this one also so we call it stage and set stage and we call the use stage hook and inside of this we're actually going to give it the initial stage and we can just call the create stage inside of here and it will generate the initial stage for us the clean board for a game as we have here so that's our state for the stage and we're going to return we're going to need both the stage and the set stage for this one so we return them and i can see that i typed use stage here it should of course be use state like so so we save this one and then we're going to do a little bit of coding in our tetris component also so make sure you're inside your tetris.js file we can actually remove the create state for this one now we just had it before we're not going to need that one because we're creating the stage in our use stagehook now so remove this one and we can actually make a little comment here this is a style components and then we're going to have our custom hooks so we import use player from dot dot forward slash hooks and use player and then we also import our new stage from dot dot forward slash hooks use stage all right and we already have imported the components we are going to use some state in this component also so we have to import use state up here all right so we're both importing react and use state and now we can remove this console log but it would be nice to have a console log here that tells us if it rerenders so we can create that one console.log rerender it's always nice to have then we're going to create two states now actually because yeah we're not going to use them right now but we can create them as we're already in this component we're going to have one that's called drop time and one that's called game over and the drop time is the actual speed that we're going to modify depending on which level we're on and then the game over is yeah simply going to tell us if the game is over or not so we're keeping true or false in a state for that one so we create the new state that's called drop time and set drop time we have use state and for this one we can just initialize it with null and we have a game over and set game over and our use state and we set that one to false of course it's not game over when we start and then we're going to use our custom hooks and if you remember from a player we exported our player and that means that we can grab that one with destruction here const player and use player like so and we also have our stage and for that one we exported two different values in an array so we can destructure them out also so we have our stage and our set stage we run our custom hook called use stage and we send in the player to this one we're not using the player in this custom hook yet but we are going to need our play in this one so we're going to modify this to use the player later so that's why we can send it in already now because we have the player here so we send that one in okay and then we can remove this one because we're not needing that functional we already have our stage in our variable called stage that we get from you stage so we use that one instead here and we can actually also use this game over variable here because when the game is over we're going to show a display that says it's over so somewhere in the side here we create curly braces we check our game over variable if that's one is true we're going to show a display component with a prop of game over we're sending that one into the display component because if you remember we're changing the color of the text to red if it's game over so we're just simply sending the game over variable and we have the text that equals the game over and we selfclose the component there this is a ternary operator so if the game is not over we're simply going to display everything of this like so so if we have a game over we just display this one that says game over we don't display the score the rows and the level and if the game is not over we are displaying all of these so we save the file and it seems to be working we didn't break anything in the game and it's just complaining here because we're not using these values yet but that's fine in the next video we are going to create the player movement with the keys on the keyboard and we're going to do the stage update we're actually not seeing any tetra miner now but we will see it in the next video hopefully okay let's create the movement for the player and also the stage update so we can see the changes take place on our stage here first we're going to be working in the tetris.js file the tetris component and i'm actually going to take back some code we deleted in the last video we are going to use the create stage function in this one also so import it again sorry for that we import create stage from dot dot forward slash game help us we're going to need this one when we restart the game we need to create a clean stage for that one so we're going to need a few functions now because we're going to create the movement for the player so down below here somewhere below the console.log rerender we are going to need a function that's called move player and it's going to take in a direction as a parameter for now we just leave it empty then we're going to need a function that's called start gain we leave it empty for now we have another one that we call drop and we leave that one empty and we have another one that's called drop player yeah and that may seem odd now that we have two similar functions here but it will get clear to you when we have more code in this component and i'll explain why them and the last one for now is a function that's called move and we're going to destructure out the key code for this one this is going to be the callback function when we press the keys on the keyboard all right we're going to fill them with code in a second but first i'm going to explain this style tetris wrapper for you so we created this one with the width and height of the complete window here and that's because we need some way to take our key inputs and this one the rapid over here is going to be responsible for that so it's going to have a few props we need to set the role to button otherwise it won't respond to the key press and we need to have a tab index that equals to zero and we have an on key down and we're going to call our function that's called move for that one and send in the event so that's why we have this style tetris wrapper it's on kind of her you don't see the div here but it will cover the complete screen here and that's why when we for example click here it will register the key presses for us if we didn't have that one or for example just put the key press on this one you have to click on this to get the key presses to register let's go to our callback function that's called move that's the one we call here first of all we're going to check that the game isn't game over because then we don't want to register any key press so if parenthesis and not game over then we can do something here and then we check again if our keycode we destructure that one out from our event because on our event we have a property that's called keycode and if we destructure it here we don't have to type e dot key chord a little win here because that's not too long to write an e but yeah and we're checking if the key chord equals to 37 and that's the key chord for the left error on the keyboard then we're going to move the player we call our move player with the 1 because we're moving to the left that's why it's 1 if our key code equals 39 that's the right arrow on the keyboard we're going to move the player to the right and that's why we have a one here so left equals minus one because we're moving minus one on the x and 1 equals right because we're moving one step on the xaxis and then we have another else if if the key code equals to 40 that's the down error on the keyboard we drop the player because we're pressing down so we want it to go down so that's our move function an in or drop player function for now we're just going to call the drop so we're just calling this one we're going to have another little special case inside of this later on so i'll explain that then then we have our drop function and we're going to create the function in or use player hook that's called update player pos and yeah it will do what it says it will update the player position update player pos and we're going to give it an object with the x value of 0 and the y value of 1 because we're dropping now and i can see that i'm in the wrong function here so just copy and paste that one inside it should be in the drop function so as we're dropping here we're going to increase the y value of one and make the player tetra minor go down and we set the collider to false all right it will complain because we haven't created this function yet and in the start game function we can just make a little comment here reset everything and we set the stage to create stage we call our function to create a new stage and we reset the player and that's also a function that's going to be in the use player hook and the start game is a callback function also that we're going to have on our start button so we can set an on click handler and call the start game function so what we'll do when we press the start game button we will reset the stage and we will also reset the player and then we have our move player function and that one is going to take care of the left and right movement so we call the update player pros and we give it the x value of direction and the y value of zero because now we're just moving left and right and we're giving it a value here minus one or one all right we save that file and it will break now of course because we haven't created these ones yet so we have to create the update player pos function and the reset player function and we're going to place them in our use player custom hook and that means that when we call or use player function here we also want to get the update player pus and the reset player from that custom hook all right so let's move into our use player hook so make sure you're in the use player.js file and we're going to continue write some code here we're going to create these two functions here so we have our update player pos and it's going to be a function that takes in an object and we can destructure out x y and collided from that one we create an arrow function curly braces and inside of here we're going to set the state because now we're moving the player so we can set the player state here so we call set player that's the one up here and we do that with an update function if we do that we get the previous state here and we have to have a parenthesis here because we just can't give it the object because it will think that these curly braces are for the block and that's why we have the parentheses here we spread our previous state we set our pos to the new one we have an x property so we set that one to our prev.pos dot x plus equals x then we set a y value prev pos dot y and plus equals y so we're adding the values to our state here and then we set our collided property like so so that's the update player position we're just setting the state with the new x and y values here and our collided value all right then we need one for reset player so we create the const reset player and for this one we're actually going to need a hook that's called use callback and that's because otherwise our game loop will go into an infinity loop we won't see it now because we haven't created one yet in our new stage hook where we're going to use this function but trust me we need to have the use callback here otherwise we will be in a mess with an infinity loop so we use callback and give it an inline function here it is going to be dependent on nothing because we just create this once so we set the player and in this case we're resetting everything so we won't need to have this update the function here and give it the previous state we can just set the state from scratch so we have our position or pus our x property we set that to our stage width and we divide it by two i subtract two also to get it kind of in the middle because this one will position the tetra minor in the stage so this one will give it yeah kind of in the middle and we have our y property we set that one to zero because we want our tetra minor to be at the top when we reset the player and we have our tetra minor and we will give it a random tetra minor and grab the shape so each time we call this we will get the random tetra minor and this is the way that the tetra minors change randomly and we set collided to false like so we also have to import the use callback up here and use callback is a standard react hook and the last thing we have to do for now is also return or update player position or update player pause and or reset player and this should be it now so it's still working but nothing happens here because we're not drawing anything to the stage now and that's what we're going to be doing now so let's go into our use stage.js file or use stage custom hook and this one is going to be a little maybe complicated but i hope we will get through it and that's the thing with game making because as i said i'm not the game maker so yeah some stuff can be hard to understand when you're not a game maker but even if you don't understand everything that's game specific i hope you will learn some stuff in react okay so let's continue in this one we're going to take in our player and reset player as our parameters for this one so add these ones up here then we're going to use the hook that's called use effect and that's one is for creating side effects with react and it's yeah kind of a replacement for the life cycle methods in the class components i won't go into detail with every hook here so you have to look up that yourself if you don't know how use effect works and what it's for they have an excellent text on the react homepage where you can read about all the hooks all right so we create our use effect and that one is going to have an inline arrow function where we're going to create everything for our effect and this is the dependency array for now we can just leave it empty we create another function inside of here that's called update stage we're going to give it the prep stage the previous stage and below here we're going to set the state of the stage with this function so we have the stage state here and we set it with the set stage so set stage and then we have our update function so we grab the previous stage state it's easy to be confused here with stage and state it's almost the same saying that so we call our update stage in our previous state and you can also see that we're placing this function inside of the use effect and by doing this we don't have to specify it as a dependency here so we can have it inside of this effect all right and now we have to do some things here because when we update the stage we first have to flush the stage we have to kind of clear it from the previous render so we create the const with a new stage we take our previous stage of prep stage and we map through it so we get our row and we have an inline function here and we make another map on our row because this is a multidimensional array so we have to do two maps here it will probably be a little bit faster if we do this with just four loops but i think we will be fine here using map but if you care a lot about performance you shouldn't use map i think in a game like this you should use the for loop because that will be faster than the map all right so we have a row with map over a row and then we get our cell and we're going to return a new cell value and here we're going to make use of the one i talked about here where we create the stage where we set it to clear or merged so i'll show you that now we create the turner operator here we have a cell value we checked the value in our cell array and i will go back to this again to make it as clear as i can it's this value here we're grabbing so we simply check if that one is set to clear clear then we are going to return an empty cell so we return an array with a zero and clear otherwise we are just going to return the cell and this is what i've been talking about before because if we haven't marked a cell to merged then we just swipe it out we just clear it and we return a fresh clear cell here otherwise we return the cell as it is and it will stay in the stage so that's the way we know what cells have collided tetraminos in them or not so we have flush the stage here then draw the tetra minor so we flush the stage remove everything that shouldn't be there and then we draw the new stage for this render and we can do that by loop through our tetra minor and we have our tetra minor in our player if we check or use player we created the state here so we have the tetra minor here it's in the object for the player and in our tetris we are sending in the player to the use stage and we're getting it here so that's why we can access the player in our use stage custom hook so we have our player and the tetra minor property for each we're not going to return a new one here we're just going to simply loop through it we have a row and we have a y value curly braces then we're going to map through our row because this one is also multidimensional array so it's unfortunately a lot of loops here when doing this we have our value and our x value for that one and we have another inline function it may be a lot to grasp now when you're just typing it in like this so i suggest again you stop and just try to really understand what we're doing here because now we're looping through our tetra minor and now we're going to check which cells in the tetra minor that are occupied and that way we know the shape of the tetra minor we have our value here for a tetramino for a cell in the tetramino so we can check if the value isn't zero then we know that we're on a cell that makes up the shape of this tetra minor and then we also know how we can position the tetra minor on the stage we have our new stage up here that we flushed it's a fresh stage that we can use to draw our tetra minor so we have a new stage and yet again this is a multidimensional array so we have to set the y and x value for this one first we have our rows that's our y value so we have the y value plus player pos dot y then we have our x value plus player pos dot x this will give us the coordinates on the stage so we are going to set these ones to the value and the value here remember that it's the tetra minor that we're looping through so we get the value of the tetra minor and in this case it's going to be yeah one of these values here let's go back to our u stage so that's our value and then we're going to do backticks here two of them and inside we have a dollar sign curly braces because we're going to check with the turner operator if our player is collided then we set this one to merged otherwise we set it to clear and this is yet again how we know that we should clear this tetra minor in the next render if we set it to merge we know it has collided and this one when we flush the stage before we do this it will be set to merged and that way we know that we should keep it in the stage because it has collided otherwise it's set to clear and then we can just delete it in the next render before we do anything else all right this is beginning to be a long video sorry for that but we have to do this and inside our function here make sure you're in the right scope here inside of the update stage function we are returning the new stage for now because we're not checking any collisions yet we're going to return to this one and as you can see here when i order formatted this one it has filled in this itself these are the dependencies that we need for this use effect so we have the player.collided the player.post.x the player dot post dot y and player dot tetra minor we're using them inside of this use effect and that's why we have to specify them as dependencies here and we are going to use the reset player that we wrapped in our use callback later so that's why we have wrapped it because we're going to add it as a dependency to this one and it's this use effect that will go into an infinity loop if we don't wrap it in a used callback all right save this one and as you can see we have a tetra miner here now and that's great and if we reload this one we get a different tetra minor because we have randomized them and that's working great and is this working no okay let's check that out in our tetris all right i see here it shouldn't be on click it should be called back because if we look in our start button we have the prop here that's called callback so make sure you're in the tetris component and change this one to callback and i bet it will work now and it does and i think i saw a little bug there yeah it disappears and i think it is it's probably when we get the same tetra minor as before and i think that is if we go into the use stage custom hook we have these dependencies here so when we get the exact same tetramino it won't rerender because this one is dependent of the collider the position x the position y and the tetra minor so they are going to be the exact same in the next render if we get the same tetra minor and that's no good i think we can just change the dependency to player and save this one make sure you reload it it's working great now um i don't think this will give us any trouble in the future so i haven't seen this bug actually before i think i had gone through everything but yeah that's the thing with code you always get surprised i think it will be fine to have the player there otherwise we'll change it later and i also saw some little other stuff here we have to adjust because when you start the game you don't want this one to show up here before we have pushed the start button and that's why i created in this file tetra minus i created this zero here with just a blank little cell here and that's the one we're going to use for this now so if we go back into our use stage now into our use player you can see that we are just rendering a random tetra minor here and that's not good if we import our tetra minus also here then we can just grab the tetra minor and we grab the first one in the array tetro minor tetro minus and we save it and as you can see now the stage is blank here and that's good and if we push to start it will generate a random tetra miner for us to start with and of course also we have created the movement for this one so if you press left and right and the down button we can actually move the tetra miner now and as you can see we have not done any collision detection yet so it will screw up here but that's fine for now we will fix that later but at least the controls are working and that's also great so we have something here now we are getting somewhere and we will continue this one in the next video it's time to create some collision detection now for our game because now it isn't working here we can move outside the play field and it looks kind of screwed up here and that's not what we want so let's go back into our code and we're going to be working in the gamehelpers.js file for now that's where we're going to place the collision detection function it made sense for me to place it in that file but if you feel that you want to place it somewhere else you can do that of course but for this tutorial i'm going to create it here so make sure you're in the gamehelpers.js file and we have to think about a few things before we create this function one of them is that it's probably better to use for loops because it will be at least a little bit faster than to use for example map or for each because we are going to loop through our tetra minor here again and we're going to have two loops for this one also so if we use for example for each we can't break out of that one and that's the downside for us because we want to break out of the loop as soon as we collide with anything so feel free if you want to experiment with this and try different ways of doing it i'm going to use for loops so we can start by creating our function now we need to export this one because we're using it in the components so we need to have an export const and we call it check collision we give it a player the stage and we give it an object where we can destructure out the move x and the move y so what i'm doing here is that i rename the x and y to move x and to move y and that's because i'm going to use y and x in my loops so i want to have a different name for these parameters here and it's an arrow function and we have curly braces so we're going to loop through our tetra minor in this one so we have a for loop let y equal zero and y should be less than player dot tetra minor dot length and then we just have the y plus equals one for each iteration and then inside of here we have another loop let x equals zero and x should be less than player dot tetra minor and we can grab the y value dot length and then we have the x plus equals one so we add one to this one for each iteration also and we could of course just say zero here because it doesn't matter which row we are checking the length so of course the rows are the same length all right so what do we have to do here now first of all this is the tetra minor we're looping through and we first have to check that we're actually on a tetra minor cell and the zero don't make up the shape of the actual tetra so we have to check that the cell isn't zero so we can make some comments here one check that we're on an actual tetra minor cell like so and then we create an if statement and we check if player.tetromino and now we're grabbing a y value and our x value from our loops and it shouldn't equal zero all right so that way we know that we're actually on a cell that make up the shape for the tetra minor and we should check that cell if it collide with anything so what collisions do we have to check we make a little comment here again we need to check that our movement is inside of the game area's height that we're not moving the tetramino outside of the bottom of the stage so we can just make a comment check that our move is inside the game area's height and we can just set y in parenthesis and maybe also we shouldn't go through the bottom of the play area all right and we can actually specify the other things we're going to check before we create them so down below here create number three then we need to check that our tetra minor isn't moving outside of the game areas with check that or move is inside the game areas with and that's an x and then below here we have the fourth thing we're going to check and that is we're going to check that the cell isn't set to clear because this function will return true or false if it returned true we have obviously collided with something otherwise it's false and we haven't collided with something so if the cell is set to clear then we know that we're not colliding with anything and it will return false check that the cell we're moving to isn't set to clear because if it is clear we're not colliding all right so that's our things we have to check here we're going to do this with a chained short circuit whoa that was hard for me to say as i'm not natively speaking english and you probably can hear that also but you have to live with it so if not stage and we grab the y value plus player dot pos dot y plus or move y we're looking into the future here you can almost say like that because we're checking here if the position that we intend to move to is colliding so here we're simply checking that our status y value actually has a value in it if it doesn't have that we know that we're outside the bottom of the stage and this will also return true because we're setting this to not with this exclamation mark so if it not find anything here in this stage row it will return true and we know that we are colliding with something and as i said we do a short circuit here so we do an or i actually don't know what these signs are called in english it's the sign for or in a short circuit okay then we need to check that our move is inside the game errors width so we have the exclamation mark we're checking that not stage y plus player dot pos dot y plus move y and then we need to check the actual cell here so we check the x plus player dot pos dot x plus move x and yeah it is complaining here because we of course need an if statement here also so wrap this in an if statement and return true and we go back to this one we create another or and we're going to do our fourth check here okay the fourth one we're going to check i misspelled this check we are going to check if this cell is not set to clear and we can do that by typing stage and then we do the same thing here y plus player dot pos y plus move y and then we have the cell so we have x plus player pos dot x plus move x and then it's the second one in this array that we have to check so we type in a one here and we check that it isn't clear like so and this one should of course be a capital y so there you have it that's everything we need for our kind of simple collision detection i actually almost copy and paste this code from the mathmath method tutorial because i think this is a very simple and clever way to check the collision because with this collision detection we can detect if we're outside the stage and also if we collide with any of the tetra miners because we're looping through the tetra minor that we have in play and check if any of the cells inside of that tetra minor collide with any of the cells in the play field and that's how this function can check for everything that we want if we go outside the stage and also if we collide with another tetra miner that's merged to the stage so we save it and we see that we didn't break anything and we didn't do that and that's good we have to go inside or use stage hook and add a little collision detection here because when we have the new stage here with the new updated position we then check check if we collided like so so we can do a little if statement here if player got collided then we just reset the player like so and it will need a new dependency here so we can add reset player because if we collide we just reset the player we move the player up to the zero y position and the other one will stay in place where we collided because we merged it into the stage here the last thing we have to do here now is to go into our tetris component and actually use our check collision function first we have to import it from the game helpers so we have our check collision imported there and we have to check the collision when we move the player and when the player drops so inside our move player we create an if statement and if we don't collide we send in the player the stage and the intended position we want to move to so we have an x value of direction and we have the y set to zero because this move player function is responsible for moving the player left and right so yeah i probably should have named it something else yeah i realized that so you can change it to a more descriptive name if you want to do that then we can move this one inside of the if statement and this means that if we're not colliding with with anything we actually do the move otherwise we don't do anything here so we save it and we can see if it works we shouldn't be able to go outside the play field to the left and to the right and we can't and that's great so it will stop the tetra minor there because we are colliding with the sides of the stage then we have to check for collision when we drop the player so inside of the drop function we do almost the same here we check if not check collision we give it the player the stage and the intended move so we have the x value in this case it's zero and it's the y value that we're going to give a one because we're moving one step down each at a time and we can move this one up here inside of the if statement in this case we're going to have an else also in this case as we're dropping we know that if we collide on something when we drop we also need to set the collided property to true in the player and that's because if we collide with something when we drop we know that this tetra miner should be merged to the stage because it can't drop anymore so we we need to yeah merge it into the stage so we update player pos we give it an x value of zero and a y value of zero we're not moving anymore we're just setting the collided to true we can also inside of this else block create something when the game is over because if we're colliding and the player dot pos dot y is less than one we know that we're colliding up here somewhere and the game should be set to game over so we can console log game over and then we're going to set game over to true and set drop time to null because we're not dropping anymore so we set at a null and also up here in the start game function we can set game over to false because we're starting a new game here so it shouldn't be set to true all right we save it and see what we've got we're checking here and it's still working with the collision on the sides and if we go down here it should merge into that position in the stage and it does so that's great and we can see if it will go into game over mode here when we're colliding at the top and it does also and that's really really sweet but now we have a kind of a half working game it's not dropping because we haven't created the interval and we can't rotate the player so that's what we're going to do in the next videos in this video we're going to create a rotation for the player and we're mostly going to be in the use player custom hooked so make sure you're in the use player custom hook we're going to create two new functions in this one so just below our state here we can create one that's called rotate this one is going to receive a matrix and a direction so the matrix is actually going to be our tetra minor so you can name it that also if you want and of course we're going to have an equal sign and an arrow here then we're going to have another function that's called player rotate and we could actually do them in one function but i wanted to separate them out because the rotate here actually do the rotation and the player rotate are going to do some other things also because we need to check the collision here when we rotate the tetra minor that's why i separate them into two functions so we have the const play rotate equals it is going to take in the stage and direction and we create an arrow function and as i said before you can of course create regular functions if you want it's just me that yeah i like to create arrow functions instead but if it makes more sense for you to create a regular function you can do that also it doesn't matter here okay so first we create a rotate function and that's the one that's going to take in the tetra minor and the direction and we want to rotate the tetra minor and how can we rotate the tetra minor yeah first of all we can make all the rows to become columns instead so we kind of shift them in the array and that way all the rows are going to be columns instead and then if we reverse all of the values in the rows we get the rotation so that is how this is going to work so first make the rows to become calls now we can call it this transpose okay we create the new const we can call it rotate the tetra all right so we take our matrix we map through that one we're not going to use the actual value in this loop but we need the index then we map through the matrix again and we have the column and we return the call and the index and this one will make all the rows in the array to become columns so that's the first step in rotating then we need to reverse each row to get a rotated matrix or a tetra minor in this case and this one we have to separate into two things because it depends on which direction we are moving how we do this if we move with the direction of a value that's bigger than zero we know that we're moving kind of clockwise then we need to reverse all of the rows to get the rotation right otherwise if we move in the other direction if it's for example minus one it's less than zero then we just reverse the complete matrix or in this case the rotated tetra as we call it i know that this can seem a little bit too much and i think this is one of the thing again with game making you do this stuff all the time when you rotate things i actually had to think about this twice or three or four times before i got it myself and he explained it quite good in the math math methods video on how he rotate things i don't do it exactly the same here in this function but the principle is the same we have transposed our array or matrix or tetra minor and we have converted all our rows into columns and we save them in the rotated tetra then we can check if the direction is bigger than zero we return or rotate the tetro that we're going to map and we have the row and all of the rows are going to be reversed for this one so we use the reverse function on this row and that's a builtin function in javascript otherwise we're moving in the other direction so we can just return the rotated tetro dot reverse okay now we can create our player rotate where we're also going to do some collision detection when we rotate the player and i'm going to show you why in a second but first as always we don't want to mutate or state or anything so we create a copy of our player we can call it clone player we cannot do a shallow copy here so we need to make kind of a deep clone and you can do that with json dot parse and json dot stringify player so now we get a complete copy a complete clone of our player and that's good we don't have to work with the player that's in the state because we shouldn't mutate the state then we take our clone player and grab the tetromino from that one and we use our rotate function and we rotate the clone player dot tetramino and we give it the direction also and this will rotate the player and we can set the player to the cloned player we also need to export our functions here or actually it's just a player rotate we need to export we will get back to this in a second but first we have to actually create the rotation in the tetris component first of all we need to add the player rotate here so we get it inside our tetris component from the use player we're also returning this one then below here in our move function where we check the key code on what key is pressed and call a function we also need to add another else if here so if the key code equals to 38 that's the up error on the keyboard we call player rotate give it the stage and the one because we are going to need a stage when we do the collision detection in a minute and this is the direction we're sending in so we're rotating it clockwise and this means that we have a function now that we can rotate counterclockwise also so if you want you can add another key here that will rotate the tetraminer in the opposite direction that's very easy to implement if you want to do that i kind of play tetris with just rotating it with one key so i choose to not implement two keys for rotating in different directions here all right let's see if this works and it does that's nice but if we go to the side here you can see if we rotate it it will rotate outside of the stage and that's no good and it will break it as you see here but it's rotating nicely we're going to fix this thing now so it can't rotate outside of the stage so go back into our code and inside or use player custom hook and inside the player rotate function we're going to continue write some code here that will solve this problem for us and this one i actually grabbed it directly from the mathmath method tutorial because i think it's very clever how he does this so this code is straight from that one first we want to save our position in a const so we have const pos equals cloned player dot pos dot x so that's the x position we save here then we're going to create a new let that we call offset and that equals one then we're going to have a while loop so we have while and inside a while we check collision we send in the clone player the stage and we're not moving it anywhere so we just give it zero values in this object here with the x and y we already imported this check collision up here so we don't have to do that again and now we're going to write some tricky code here actually um and i'll try to explain it for you if we go back into our game i'll try to show you here so let's just place a few of the tetra minus here and i try to explain it if we rotate this one here as you can see it will move inside of these tetra minus and that's no good and this little function we're going to right now is going to take wait i'm going to create another one here it's going to take the tetra minor when we rotate it and move it right and left and right and left and check if we collide with something and that's the clever little function that he came up with in that tutorial let's say we go right it will check are we colliding no then we go left are we colliding there no and then it will continue until we collide or if we don't collide we can actually rotate the player so that is how this is going to work in this while loop so we have our clone player we set the position dot x plus equals the offset and this is how we keep track on how many steps we're moving to the side back and forth so we set the offset it equals to minus parenthesis offset plus the offset if it's greater than 0 we set it to one otherwise we set it to minus one and it's this little row here that will create the kind of back and forth movement for us with the tetra minor then we can create an if statement and we check if the offset is greater than clone player dot tetra minor and we grab the first value in the array and length here we're just grabbing the first row and check the length of that one we don't need to do any more shakier because we have looped through the complete length of the tetra minor then we just rotate the tetra minor back because this move isn't a load we can't rotate it if we have try this back and forth more than the width of the tetra minor then we know that we can't rotate so we just rotate it back because we already rotated it up here so we just rotate it back rotate lone player dot tetramino and minus direction we reverse the direction so we rotate it back and we set the clone player dot pos dot x to equals position and that's the one we saved up here because we wanted to have the same position as we had from the beginning and then we just return so this is yeah quite a handful of a function i don't blame you if you don't get it especially this one it can seem a little bit tricky it took some thinking for me to understand this just think of it as this one we'll go back and forth and see if it collide with something when we rotate and if we do we can't rotate it that way and it will constantly move it away from that one when we rotate so we can save it and see if it works we can try this out if we rotate it now you can see that it kind of pops out from the wall it won't go through it and also if we do some rotating here you can't rotate through them and that's good so i actually think that this is the most advanced function in this tutorial because this is quite advanced don't blame yourself if you don't get it the first time just try out yourself try to change the code try to look at it read it try and change it again and you will soon get it how it works if you don't get it right away and if you get it right away well good for you and see you in the next video okay we have a kind of a functioning tetris game here just a few things left to do if we take a look here we see that we have some full rows here and they should be swept off the stage and it should give us some score at the end but it won't do that now because yeah we can just fill this up and nothing will happen in this video we will create the function that will kind of sweep the stage and see if there's any rows that needs to be cleared and also push down the other ones that shouldn't be cleared so that said go into our code again and into our use stage custom hook inside of this custom hook we're first going to create another state so we create a state here that's called rows cleared and set rows cleared and this is how we're going to keep track of all the rows that we have cleared so we use state and give it an initial value of zero okay and the first thing we want to do in this use effect is to set rows cleared to zero and then we're going to create another function here that's called sweep rows we're going to give it a new stage to sweep and it's going to be an implicit return for this one so we don't have to have curly braces we grab our new stage and we're going to do some reducing here so reduce this is the builtin reduce es6 function we have the accumulator and the row arrow function called braces so we give this function a stage and we're going to map through it with reduce so we we do that with new stage dot reduce and we get the row and the accumulator if you don't know how reduce works i suggest you look it up and the first thing we have to do now is to check if our row just contains cells that are merged and that means that we can check if a row don't contain zeros and we can do that with find index so if row find index we have our cell and an inline function we check if the first value in our cell array equals to zero and if this one equals to minus one we know that we haven't found a value of zero and then we know that this is a full row and should be cleared because find index will return 1 if it don't find a match with the provided function inside of it if we're looking for the value 0 and it won't find that one then it will return 1 and then we know that this row should be swept away from the stage so we first set rows cleared and we do that with an update the function because we're going to need the previous value and we just add one to that one then we're going to grab the accumulator that's the new array we're building up inside of this reduce function we're going to unshift and unshift let us add a new value to the array at the beginning of the array because if we look here if we for example remove these three rows here we need to add three rows at the top and we can do that with the unshift method so we remove these three ones here and if we add three empty ones up here it will push down the other ones and it will kind of create the illusion that these ones just pop out of the stage and disappear so with the unshift we can add a complete empty row at the beginning of the array so we create a new array from our new stage 0 dot length that will give us the width of the actual play field and we fill it up with an array of zeros and clear because these ones are completely fresh so they should be zero and clear then for each iteration inside of the reduce we have to return the accumulator also and this is if we find a matching row that should be cleared if we don't do that we just push the row into the accumulated array and we return the accumulator again like this and we could also give it an empty array to start with so this is the complete function here i will go through it again and tell you what it will do we give this function our stage and we take the complete stage and use the reduce method on this one by using reduce we can create a new array so we check if the row contains any zero if it does we know that this row shouldn't be clear because we haven't filled up a complete row but if we have filled up a complete row we first add a row to our rows cleared state then we add an empty a complete empty new row at the top of the array and we return the accumulated array this works because we completely ignored to return the full row that we should remove from the stage and instead we return a new empty row at the top of the array so this will create the illusion that we remove the row on the stage and move the other ones down that was above that row and if we don't have a full row we just return the row as it is in the array and that's the way it works we have to use this function somewhere and we can do it if we know that we collide with something we should do this sweep and see if we also have a full row so below the reset player and because this one returns a complete new stage we also need to return the function and give it the new stage so this one will take or stage we create here when we have done all the mapping with the tetra miner and everything and if it collides then we call the sweep rows with this stage and this one in turn will return another stage for us when it has swept all the rows and check that there's no full row that needs to be removed from the stage okay so we'll see if it works i have to do some gaming here to get a full row and that's nice to be able to play some game here let's see if it works and it does nice it's kind of easy now when it's not dropping yeah and we know that it works now so i don't have to create another row here and we actually forgot to do something here and go back into our code and into our use stage custom hook we also need to return our rows clear because we're going to use this one in the tetris component later on so make sure you add that one to the return statement here all right so that's it we'll continue by creating the interval for the tetra miners to drop by themselves in the next video we are going to set this game in motion and i think it's better we take a look at dan abramov's site first overreacted dot io and then he has a blog post that's called making selling develop declarative with react hooks and it's 16 minutes read so i won't go through it here but i suggest you read this one because here he explained why it isn't a good idea to just use set in the val with react hooks so he has created this custom hook that's called use inval that we are going to use and hopefully you copied this file over to your project folder as i showed you in the beginning of this tutorial here's all the answers to why setting the well is not good to use as it is with ragged hooks it's better to create a custom hook and use that one instead and one thing why it's not so great is because react hooks are heavily using closures and closures can be quite difficult to grasp if you're not that used to them he has created this use in the world for us that we can just use in our game and that's what we're going to do now so back to our app and our code inside of our tetris component we're going to be in that component in this video at the beginning here where we import our custom hooks we can import our use in a val from dot dot forward slash hooks and use innerval and that makes sure that we can use this one inside of our component okay and now we're going to make this one move by itself because now we can just drop it by pressing the down key on our keyboard and that's no good we want it to move by itself so we can set up this interval and below i think yeah here somewhere we can use our interval so use interval and this one will take an inline function so we create an arrow function and we are going to call the drop function as we created up here because that's the one that makes the tetra minus drop so we call that one and we can specify the interval timing here and we already have a state that's called drop time so we just send this one in to the use in a well because if we look at the use interval it will take a callback and a delay and the callback is the inline function we created and the delay is our drop time so that's how this works and also if we send null into the drop time it will stop and clear the interval so that's good for us because that way we can control the interval all right back to the tetris component we have to do a few more things here to get it up and running because now our drop time is set to null we set it up here so now the interval is not active but we have a start button so when we start our game we can set our drop time and we send in thousand that means one second and we save it and then if we press start game as you can see it's moving really good here now and that's nice because now we have a working tetris game great i want to do a few optimizations here also we created one extra function here that's called drop player and inside now we're just calling drop and that's when we press the down key on our keyboard i want to stop the interval when the player moves the tetra minor down with the keyboard and that's easy we can just set the drop time to null and that will make sure that we stop the interval but we also have to activate it again when the player releases the down key so we're going to create a new function here that's called key up and inside of this we're going to take in the key code again so we destructure that out from our event and yet again we're going to check if the game is not game over and we can activate the interval again when the player release the down key so inside of here we check if the key code equals to 40 that is the down key we will only run this if the player is releasing the donkey then we set the drop time for now we just set it to thousand again we are going to create different speeds here later in the next video so that's our callback function for our key up event and we also have to make sure that we have this event here and we can create it on our style tetris wrapper so we just add on key up and it equals key up and a little nice formatting here and we save this one and we can actually do a little console login here because here we can console log interval off and we copy this one and go to our key up console interval on make sure you're showing your console here whoops i misspell this one yeah my formatting here has added this one for us yeah that's nice so i can remove this one it should only be use in the valve here okay so we start the game and i press the down button you can see that interval off and then interval on when we release the button and that's great because then it will not interfere with the keyboard when we hold the key down it will repeat itself and make the tetra minor go down faster and that could mess things up for us if the interval also is activated then so that's actually all there is to it to create this movement this kind of game loop that makes the tetra minor drop by itself in the next video i'm going to conclude this tutorial and we create some nice little displays here with score and rows and level and we're going to do that by create our last custom hook we're almost finished now we're just going to create a custom hook for displaying scores rows and levels and we are eventually going to import it here in the tetris component with the other hooks here but we will create it first so we have something to import here so inside our hooks folder create a new file that's called use game status dot js and we're going to need a few things here so we import use state use effect and use callback from react then we export const use game status and we're going to need one parameter here that's called rows cleared that's the one we created in our use stage we're going to send this one in to use game status because we need it when we calculate our score and set the total rows that we cleared because this one here is just the rows that we cleared in the current render that's why we set it to zero here so we clear it on each render and then we're going to send this one in to the use game status where we can add it up to the rows we already have cleared before all right we have an arrow function and curly braces and then we're going to create three states here so we have a const with the structure outscore set score equals u state and we have a zero we can just copy this one paste it two times and we're going to call this one rows and set rows and we're going to initialize all of these with a zero then we have our level and our set level so there you have it three states then we're going to need a const that's called line points and this is going to be an array with forty hundred three hundred and hundred and these are the actual scores i did some googling and found this course from the original tetris game so we're going to use these to calculate our total score i don't know there's probably a lot of different versions so i don't know if this is legit that it's truly the original scores that were used and also the formula for calculating the score but i found this one i think it was on wikipedia actually so you can have what scoring you want here if you want to change it so we have a const that's called calc score and this is a function we're creating here because we're going to call this function in a use effect and we're also going to need to use callback because otherwise this will go into an infinity loop and that's no good and i think that's also not a problem but i think it can be annoying because it's easy with react hooks to make them go into an infinity loop if you don't think about that very very thoroughly okay so first we're going to check if we have score if rows cleared is greater than zero that means if we cleared any rows in the render that's the one we send in here because if it's zero we didn't clear any row so we don't have any score calculations to do and that means that if this one is greater than zero we know that we cleared some rows and we're going to calculate the score and if it's uh zero yeah we know that we didn't clear any rows in this render and we don't need to calculate any score we are going to calculate a score and set our total rows so i create a comment here this is how original tetris score is calculated so this is the formula i use i found that one on the internet and i'm using that here to calculate the score so we just set our score state set score we have a previous state and we use that previous state to add something to it and here's the formula we have the line points that's the array up here and these line points array have four different values here and they each represent one row cleared two rows cleared three rows cleared and four rows cleared and this is an array so the index starts at zero so we have to take our rows clear minus one because say for example that we cleared two rows we need to grab the value with index one in our array and we're going to multiply that with our level plus one and that's also because our level starts at zero so that's why we're adding one here so this is the formula to calculate our score and then we also need to set our rows we have our previous state here and we take the previous state and add the new rows cleared to that one and that will always keep track of our total rows that we cleared all right and as this is a used callback we have to make it depend on something so we have the dependency array here we have the level the line points and the rows cleared so this one is always going to change when the level line points or rows cleared are changing otherwise it will stay the same and that's why it won't go into an infinity loop because if we didn't have this use callback it will change every render and that will create the infinity loop okay and then we create the use effect we want this to fire off automatically and this dependency array is going to depend on the calculate score the rows cleared and the score we're just calling the score here and as we're using these ones in this function we have to specify them as dependencies here but then we have to return something from this custom hook so there's a lot of things we're going to return here we want the score we want a set score because we want to reset the score when we start a new game we need a rows and we also need a set rows we want to set the rows to zero when we start a new game and also the same with the level so we want the level and the set level like so so we save this one and go back into our tetris component we import it where we import our other custom hooks use game status from dot dot forward slash hooks use game status all right then we have to use these values inside of our tetris component but first we have to call or use game status hook we can do that below here so we have a const and we are going to receive everything that we returned from this one all of these here we're going to receive here so we have to specify them we have the score set score rows set rows level and set level and we're going to call our use game status and we're sending in the rows cleared as we talked about before and of course we also have to grab the rows cleared here from our new stage hook see if i can make it a little bigger here i think we actually can move this one down here to make it a little nicer looking like so okay and now we have to use these values inside of our tetris component first in our drop function we want to change the level depending on how many rows we have cleared and that means we have to have something here that calculates that on every drop so i make a little comment here increase level when player has cleared 10 rows i think that that also is the original tetris but i'm not sure when you clear 10 rows then we go up a level and the speed will increase we create a little if statement here we check if the rows are greater than level plus one that's because the level starts at zero just as before times ten we set the level with our previous state and we just have the previous plus one we're just increasing the level by one and we also want to increase the speed and this little formula i created here i don't know if it's optimal actually i'm going to set the drop time like so and then i have thousand that's one second i divide it with the level plus one and then i just added 200 here so it will not get too fast and you can actually play with this and try another formula and see if it works better for you so i don't know if it's good i think yeah it's working fairly nice but yeah probably there will be a better formula for this to use so that's how we calculate our level we can actually also set a few things here when we start the game because we also want to reset our score level and rows so we can set our score to zero set rows to zero and we set our level to zero and then there's one more thing we have to do here we are going to take this formula here and copy that in the drop function where we set the drop time we have to also paste that in our key up function because now we're just setting it to a thousand here so just paste it in there and we want to display our score rows and levels also so we can change these ones inside of the props we're sending in to the display components so we create curly braces double ticks and we have our score and a dollar sign and curly braces and we grab our score then we do the same with the rows and the levels we can copy this one paste it in and then we change this once we have our rows and we have our level so this will make sure that we display the score rows and level and i think it's time to save this one and see if it works so it's already displaying the series here so we can start the game and it seems to be working nice so that's it we have a working tetris game i just want to make a little optimization here and i'm going to show you why because if we go inside our cell component and for now i have to do like this because i want to console something out rerender so what i'm doing here i'm just going to console.log out rerender on each cell here so i save this one and as you can see we have 240 rewinders here and that's fine when we build this table for the first time but as you can see on each little drop here now on each rotation and everything we get 240 renders it probably won't be an issue here because react is fast but i want to show you here how you can create a little optimization for this one so we go back inside our cell component and where we export this one we're going to export it with react dot memo and this will make sure that it memorizes this cell component and only rerenders when the cells actually are changing so we save this one and as you can see we're just rerendering the cells that actually change with the tetra miner now and i actually think that this is a really good example to show you what react memo does in react because now it won't affect the cells that won't change on that render it will only rerender the cells that change with the tetromino and that's good so we made quite an optimization here and reduced the rewrites here and that's good there you have it this is my this is my version of tetris with react hooks and as i said a couple of times now i'm not a game developer but it was sure fun to create this game and i think it's a good practice in react and especially react hooks to see how they work and i hope you enjoyed this one as much as i did and i'm very grateful that you have followed me on this tutorial and i hope you learn a lot i initially created this one exclusively for free code cam and i actually record a lot of free stuff especially in react and frontend and stuff like that in my own youtube channel so if you go to youtube and just search for webinfo weib you will see my pretty face here and you can just go to my channel and make sure you subscribe if you want free coding tips in react and other frontend stuff and i also create paid premium courses i'm going to move them to my own platform soon but for now they're up on udemy and it's a beginner react course and also a course in gatsby and how to create get beside with wordpress as a headless cms there's also a free course on react redux and there's of course the hooks introduction course that were published on free code camp a little while ago and i'm also on twitter just hook me up there if you have any questions or just want to follow me there and i sure appreciate the support i can get from you i want to continue to create free stuff and do things like this so hopefully you'll see me again in another video but for now thank you and goodbye