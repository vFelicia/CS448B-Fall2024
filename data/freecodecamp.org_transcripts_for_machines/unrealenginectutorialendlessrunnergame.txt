In this game dev course you will learn how to create an endless runner game using Unreal Engine and c++ file Fahir teaches this course. He has created a ton of game development tutorials and he is an excellent teacher. What is up guys Fahir here and back out again with another Unreal Engine tutorial this time a c++ one Yes, because a lot of your doozy blows blows. Okay, I'm going to do a c++ tutorial. Anyways, let us take a look at the game that we are going to create. So over here I have my editor if I hit the play button, it's a simple side scroller game. So if I, you know, jump and all that stuff, you see, we can jump we can move, the goal is to avoid this wall that is chasing us because if it touches us, we are going to die. And of course, we are going to have obstacles along the ways such as these platforms, such as the spikes that we are hopefully going to see pretty soon, because they're not spawning all of this time. There we go, we have the spikes. If we touch the spikes, bam, we are dead, the level is going to restart. If the wall hits us, bam, we are that the level is going to restart. As you can see, it looks like a basic game. But we are going to learn a lot of cool things, especially c++ wise, because we're going to do all of this in c++ from scratch coding everything and you're going to see me code and you know, you're going to enjoy that and learn a lot and yada yada yada. Anyways, what else can I say? Let's jump into this. Course. Yeah, it's a mini course. What else is there? No, it's a mini course. Okay, it's tutorial mini course, whatever, let us jump into it and create the school game. Alrighty, then my game devolves. Now that we saw the game that we are going to create, let us create the game. So over here, I have the Unreal Engine Project Browser, we are going to click here on games. And by the way, this is unreal engine version four point 25. And we are going to select our third person project. So not the blank one, but the third person because we need some elements from that, you know, third person package. And over here, we're going to click on Next. And from blueprint, I'm going to click on the drop down list and select c++ because Yay, this is a c++ course. And over here, I'm going to name my project I'm going to call it side rather CPP. Of course, you can think of something more creative than that, I'm going to click here Create Project and wait until the project is created. And then I'm going to come back. And here we are finally. So now what we are going to do is we are going to create the player and specifically the player class over here, by the way, I have this engine content, we will use that as well. If you don't have it, you're going to click here where it says View Options. So this right here that I draw, so click on that, and from there, you're going to click this checkbox show engine content. So make sure that that is checked. And then you will be able to see what I see in my project. Also one neat trick, if you find that all of these elements inside of the editor are too small, especially if you have a big monitor, you can go over here on the under window and then developer tools. And then you can go over here widget or reflector. And let me just bring that bad boy over here. And this is the scale for the application. Usually I set it at 1.16 and it is going to rescale my application basically make it a little bit larger and that stuff so that I can see more better. That's all there is to it. Anyways, going over here in the content, I'm going to right click and create a new folder that I am going to call maps because over here we're going to create a new map and that is going to happen under File and the new level basically new level I said map but as the same thing Ctrl S to save it I'm going to save it over here and I am going to call this one game play and there you go. So the first thing that I'm going to do with this gameplay is I'm going to remove the floor that we have over here so simply delete it and there you go. And next I'm going to go here into geometry and meshes and I'm going to take this template for and please head over here and there you go. Let me just position this bad boy so for the x is going to be zero for the Y is going to be zero z is going to be 20 and I am also going to rescale it so I'm going to click here on this lock icon to lock the scale and I'm going to say point 25 and there you go. rescale it and Wallah. Also in regard to the player start position let me just click on that yeah, it is going to be where it is. And this is where we are going to spawn our player. Now before we proceed to create the player class over here inside of the project settings and in the input we are going to have some mappings and axes. So basically we only need the jumps I'm going to delete this reset we are simply click here on this x and delete it. Here we are going to have move right we're not going to have move forward and all of these stuff. So look up look rate, turn, turn rate and move forward. We're going to delete all of these and leave only all of these. Of course you can also filter these so we Don't need the GamePad, I basically only need the spacebar. But again, that is up to you, depending on if you want to create, maybe you want to practice or whatnot, I don't know I'm not you I'm not, you know, I'm not controlling you and stuff like that. So there you go. So we should have jump and move right for the job, we have the spacebar for the move, right A and D, you can also add the, you can also add the left and right that is totally up to you, I am not going to go in there, you know, do not judge me. So now we can go over here inside of our c++ or c++ classes. And from there, there you go. Here we have our side runner CPP character, I am not going to use that one I'm simply going to right click and go here New c++ class, it is going to inherit from the character I'm going to click on Next. And I am going to call this one runner character and hit the Create class. Of course, you know that it takes a while for Unreal Engine to you know, compile and load all of this, I am going to get an m two SSD just because of this, like I'm not getting just because of this, I'm getting an es m two excuse me SSD that can read for I believe, three 3500 megabytes per second. So that is what I'm getting. Okay, this is what I'm going to get. And finally here is my class. So we have the runner dot h file and the runner dot cpp file. If you don't know the difference between the two I'm quickly going to explain so in the dot h file, we declare everything that we need and inside of our dot cpp file we then code all of that that we have declared simple. Yes, it is. So what do we need over here, right below where it says our generated body, I am going to declare a u property. So it's prah per T, there you go. Sometimes I cannot spell and I'm going to call it the visible anywhere, there you go. And this one is going to be our class. This is called a forward declaration when you type a class so that we don't have to include the file over here. And I'm going to say you camera component, and it's a pointer. So we need to denote that with the star. And I'm going to call this one side view camera. Now as I said, this is called a forward or forward declaration, I believe I'm not 100% sure, because I'm not good with those names, I don't care. But essentially what is the point of this is that we declare it with a class over here so that we don't have to use the include over here, you see, because every single thing that we use, for example, if we want to use functions from the character, we need to include the game framework character. But I don't want to do that for the camera component because every time you include the runner dot h file anywhere in your class or in any other class that is, then it will include all the includes that come with it, but when you use it like this, then it will not include them. But inside of here runner.or runner character dot cpp then we are going to include it and that is the better way to go. So over here, this is you know, the constructor for our character at the Begin Play and all of the good stuff tick and set up player input components, so we're not going to touch any of those. Instead, what I'm going to do is over here protected. And over here I'm going to declare my own functions and variables. First things first, I am going to declare here void move right and this one is going to take a float value as a parameter. And of course in a moment of do it is going to start complaining with a green line below this move right because we then declare it inside of the dot cpp file. Don't worry about that we will do it in a few moments. So over here, we're also going to create a public and this one is going to return our you camera component and again, it is a pointer and I'm going to call this one get side view. So get side view camera component. And this one is going to take a constant or actually it's a constant and it is going to return the side view cameras Simple as that. Next we are going to have another public function that I'm going to call void re start level this is going to happen at the end when our player gets killed, which is something that we saw as well. Also what I'm going to create and this is what I said is going to complain with this Don't worry we will implement this in a view. Over here I'm going to create a u function. And this one is going to be our void on over lap begin, it's going to take a u primitive. So prayer may tiv component which is a pointer and I'm going to call this one over lapped component, comma. It also takes an A actor Simply an actor, but it's spelled a actor. It's a pointer and I'm going to call this one other actor. There you go, we're also going to take another primitive component. So I'm going to copy this here and paste it and it's a pointer. So again, we need to use this star over here. And other comp or other component, this I'm going to call it to takes an int 32. Other body index, a Boolean B from sweep. And last but not least, a constant of F hit result. And over here sweep result, there you go. And last but not least, a few more private variables, one is going to be the Z position. So float z, the position, there you go, it's position like that, we are also going to take an F vector, which is going to be our temporary position that I'm going to denote is equal to f vector like that. And last but not least a Boolean to denote if we can move or if we cannot move. Now of course over here, as you can see, it is complaining for the move right and the restart level, it is not complaining for the on overlap again, but it will start complaining because I'm still waiting for that SSD to come. So what we need to do is we need to declare this function over here inside of our runner character dot cpp file. So we need to, as I said, declare it and that can happen by going over here and declaring and typing yet you know, void a runner character call on call on and so on, and so forth. But there is a quicker way to do this, what we can do is we can click on this move right then I can right click, and then I can go here quick actions and refactoring. And over here I can say create declaration definition. And there you go. When I click on that, it is going to create it of course, you know, this HDD drive, it's driving me nuts. And I will probably have to cut out this video because you know, if I sing to you, that will cost you extra. I mean, this is on YouTube, you don't pay anything for this. But there you go, finally, okay, so now if I go here in the runner, there we go. So we have the void runner move, right, we can do the same thing for this over here. So we can, you know, do the same thing for the restart level by typing void a runner character call on call on will ride. But instead of that, I'm simply going to right click again, quick actions and refactoring. And I'm going to create a definition for it. And last but not least, we need to do that for on overlap begin. So quick actions refactoring create declaration, there you go, save this over here, save this over here, and voila, here are the functions that we need. So from here There you go. So what are we going to do when it comes to our runner character? Well for our runner character here is where I said that we are going to add those includes. So first one I'm going to include, and that one's going to be components There you go, it's come ponents and then backslash and this one is going to be capsule component dot age, and I'm going to include everything that we are going to use so over here we're also going to include in quotes, game frame work, and then backslash spring actually we don't need the spring our component we need the camera so I got carried away usually when use the camera use the spring arm but I'm simply going to use the camera without it. So camera dash or backslash camera component dot h There you go. And also include and over here game frame work. So game frame work, actually, yeah, it's Capital Framework like that. And backslash character, movement component. And there you go, actually thought Ah, and now there you go. So this is the or these are the includes that I was talking about when I forward declared the camera component. So instead of using this camera component include over here, I'm simply going to forward declare it like this. And then over here I'm going to use the include because if we need to use the runner character in some other class and we need to include the runner character dot h file, when we include that, it will not include this import because this import is inside of the dot cpp file. So over here inside of our runner character, which is the constructor basically, what we are going to do first we're going to set the capital component so I'm going to say get capsule component. And from there, I'm going to say in it capsule size and the size is going to be 42 On the X and 96, on the Y, there you go. I'm also going to set the channel to response to collision with overlap, basically setting the collision settings to response with overlap. So over here, I'm going to say get capsule components or get the capsule, capsule component, there you go. And over here, I'm going to say set collision response to channel. And from here, going down, I'm going to say ECC underscore game trays channel, and is going to be traced channel one. And I'm going to say a CR, over lap, there you go. And moving forward, we are going to the note that we are not going to allow the controller to rotate us, instead we are going to use our own or basically we're going to control this class from within itself. So I'm going to say here be use control rotation pitch, that is going to be equal to false. I'm also going to simply copy this and paste it, paste, paste it and this one is going to be pitched then we're going to have the role. And last but not least, we're going to have the yard basically, as I said, this is not going to allow the controller to rotate, the controller is not going to rotate this character instead, we are going to do that from within this class. And since this is a side scroller, we're not going to rotate at all. Next, I'm going to create the camera so our side view camera is going to be equal to create default sub object and it's going to be type of view camera component like that. And I'm going to give it a name by passing here a text. And that name is going to be side view camera Simple as that There you go. Nothing complicated, I'm also going to or I don't want the controller to rotate the camera as well. So I'm going to say side view camera. And over here, I'm going to say be use pan control rotation that is going to be false. So this is not going to allow the controller to rotate the camera. Next, I'm going to set the character movement to face the direction that we are moving to so we are moving to the or in this case, because the game is a side scroller, we can move forward or we can move backwards. So that is why I'm going to say over here, get character movement. And from there, I'm going to say be orient rotation. So orient rotation to movement that is going to be equal to true, which is basically going to allow us as I said, to rotate towards the direction where we are going. Now this is going to be the rotation rates, I'm going to say get character movement, but I'm going to copy it because we're going to use it the few times over here. And I'm going to see here a rotation rate. And that's going to be equal to App rotate or, and over here I'm going to say zero for the X 720 for the y and 0.0 F for the Z now if somebody is confused if this is your first time seeing Unreal Engine c++ code, first things first, I'm advising you to go through my c++ tutorial series here on YouTube. You'll have that in my Academy as well. But what I wanted to say is if you're confused why I'm using here is 0.0. But over here 720 point and I don't add zero what is the difference? Well, there is you there isn't actually so you can add zero you can emit zero is the same exact thing. So that is when it comes to the rotation rate that I'm going to actually point zero here and move this backwards, and there you go. So next we're going to set the gravity scale for our characters. So I'm going to say gravity scale that is going to be equal to two. I'm also going to set the air control so air control is going to be equal to zero point f air control is basically how or the how much control of our character do we have while he's in the air the higher the number, the higher the control. Next we're also going to say here, our jump z velocity is going to be equal to 1000. That's basically going to be you know how far or how high we can jump. Next over here I'm going to say ground reaction is going to be equal to three. And ground friction is basically you know the collision with the player and the ground. Also over here I'm going to set the max walk speed that is going to be equal to 600. And last but not least max fly speed that is going to be equal to also 600. And there you go. And now we are going to get our temporary positions and we'd say temp pose that is going to be equal to get actor location, which is the current location of our actor or Basically the game character and I need this temporary position because I'm going to say our z position variable is going to be equal to temp, position that z plus 300.0. There you go. And now what do we are, what do we need to do, we need to bind, we need to bind our controls if we want to move the character. So over here, we have our set up player input. And this is where we are going to bind the axes and the jumping and all of the good stuff. So now we have this player input component that is passed over here in the setup input component. So I can simply use that. And I can say, player input component, which is, you know, called as you can see, to bind functionality to input. So I'm going to say over here, bind action. So bind action, and I'm going to bind the jump action and how where or what, where do I have this jump action? Well, the jump actions over here, if I go into the project, here it is action mappings. And this is the jump action. So this name needs to match up with the name over here that we specify. So bind that to. And of course, because this is an action, we can press it and release it. So I'm going to say IE pressed basically, what do we want to do when we press the jump button? Well, over here, we're going to bind it passing this as well. And over here a character call on call on jump, there we go. So essentially, when we press the jump button, or in our case, the jump button is denoted with the spacebar. So when we press the spacebar, we are going to call the jump functionality from the character that we have inherited. Because this class inherits from the character see here public a character. And the character has some built in functionality such as jumping. So I'm also going to copy this because when we release it, we are going to so this is I II pressed and over here, ie released. So when we release the jump button, instead of jumping, we're going to stop jumping, this will stop the jumping of the player and he will start to fall down Simple as that. Next I'm going to take the player input component, and now I'm going to bind the axes instead of binding the action and I'm going to bind the move right. And I'm going to bind it to this referring to this class and referring to the a runner character call on call on move right? There we go. So this right here is going to bind to the move right, which is again, going back over here, this is that move right, it is going to bind to our move write function, which is this function over here. So essentially Now, over here in our move right, we are going to add the code that is going to move the player. So over here, we're going to test if can move and we are going to use this to the note if the player can move when he's dead, we will see that later on. But if the player can move we're going to say add movement input. And from here I'm going to say f vector. So it's f vector, and over here, zero movement on the X on the Y is going to be one and on the Y or actually on the Z, it's also going to be zero in over here, I'm going to pass the value that we have. Now in order for this to work we do need to denote inside of our Begin Play that can move. So can move is going to be equal to true. This is when we start our game, which is you know normal and all of the good stuff, otherwise it will not work. So I'm going to hold Ctrl Shift and press B This is going to compile my code. And of course, we're going to wait a few moments. I don't know maybe I will cut out this video depending on how much it will take. Because again, my SSD is the lot here, I can also try to sync to you none and then and then and then there you go. It worked. You see here build succeeded, which means now we can go inside of our editor. And if I were to go into the gameplay and hit the play button, we do see a character and we can move the character but this is not the her character. This is the built in one that we have that we have created with the project. So in order to create our own character, I'm going to right click over here and go into the new folder. I'm going to call do some blueprints. And from here I'm going to click and go inside of that folder and I'm going to create a blueprint class and I'm going to inherit from the runner character. So here is my runner character and I'm going to click on that one and I'm going to say BB runner character. So this is now our character. This is going to create our character from the class that we have just created. Of course, as you can see, we don't have anything. We do have the side view camera you see we have created it over here, but what we need to do is we need to click on the mesh and over here, we need To add the Skeletal Mesh, which is basically going to be our mannequin, which is this bad boy over here, I'm also going to set his z location to negative 97 to lower him a little bit down as you can see, and I'm going to rotate him 90 or minus 90 degrees like that. And basically that would be it. I can compile save this well one more thing we do need to attach here, a blueprint class for his animation, which again, click on the drop down list and we have the third person an MVP, which automatically will make him or he will be animated. Now in order for us to add our character right now in the game, we need to create our own game mode because if you remember from the previous tutorial, previous Unreal Engine tutorial series, over here, inside of the maps and modes, you see we need to create our own game mode. Because currently, again, if I hit the play button, this is not our character. See, this is not the character that we want. Instead, over here, I'm going to right click and blueprint class, and I'm going to filter from game mode or filter for game mode and click here and inherit from game mode is going to be our BP runner or side runners cuse me side runner underscore game mode. And let's go over here into the into the Project Settings and select the BP side runner game mode. And here instead of the default pawn, I'm going to select the BP runner care Rector. And finally, this is going to allow us to have our own character in the game. So if I hit the play button, there we go, if I inject, here he is. Now we if I possess him, we have a problem. You see, we don't see the character, we don't see anything. And the reason for that is we can move him if I don't know if you notice, pay attention to where he is currently if I possess him, and if I move like this, I'm moving. And let's try to see where he is now. You see, he almost fell down. So there we go. Okay, so what do we need to do in order for this to make this work? Well, we need to go back in our c++ class, and over here where it says the tick. So inside of Arctic functionality, we need to say our temp position. So temp p o S is going to be equal to get actor location, again, we're getting the actor location, our temp position that x is going to be equal to or we're going to subtract from it 850 like this, and on the Z position, so temp position that z is going to be equal to z position. So z position. And last but not least, our side view camera set world location over here, we're going to pass the temp position, and there you go. So what this is going to do, it's again going to get the current actor location, the current actor location is basically Well, the actor location, just getting but the current location is the location of our own actor of the character, we are going to then change the exposition, So subtract from it 850, and the Z position is going to stay the one that we have over here, and then we're going to set that position to the word location of the camera. So Ctrl Shift B in order for us to compile this. And by the way, I'm not going to do that, but you're going to do it if you want to see the outcome like if you change this number to minus 1000 minus 100 said the Z position over here, I don't know plus 500. Try it out see the outcome that will be you know, that will be our practice you will understand more so if I hit the play button now There we go. You see here is our character he falls down Look at that, we but if he falls down like that, we cannot see him anymore. So that's all there is to it. Anyways, again, hit the play button, we can possess the character, look at that, we can move over here, we can move over here. That's the point you see, and he is rotating towards the direction where we are moving. If we move backwards, you see he rotates to move backwards. If we move forward, he rotates to move forward. There you go, we can press base to jump like that. There you go. But the issue is we only have this one platform. How are what we need to do well, we need to create more platforms, it's logic. So starting from the next video, we are going to prepare everything to start creating our level parts and then we are of course going to start encoding all of that so that we can have our level to play the game. If something was not clear in regards to this video, make sure that you ask in the comment down below and I will help you out and I will see you guys in the next video. Alrighty then my game dev ELS before we can create our level we also need to create the obstacles because they are going to be part of the level. So over here in our c++ class, I am going to create a new c++ class and it is going to inherit from the actor. So one is going to be called obstacle. So over here, I'm going to see up the call. And of course wait for Unreal Engine to add it into the project again, that SSD is going to arrive on Mondays or Thursday, Tuesday, because now it's Saturday for me recording this. I'm going to sing to you in the meantime then and then and then and then and then and then and then and then and then and then and then and then thank you very much that will be $5 extra. Now the bad news is that we need to create another one. So I right click over here, New c++ class, and this time an actor again and this one is going to be spikes. So spikes There you go, hit enter, of course and wait for it to torture us. What else can I say? The good thing is that we are not going to code anything. Instead, we're just going to use these classes so that we can, you know, do a cast later on when we collide with these objects, of course, from the blueprints that we will create. So over here, if I open it, let me just reload everything, reload again. There you go. So we have the spikes, we have the obstacle. But as I said, we are not going to code anything over here. Instead, we're just going to use these as references to create blueprints. So let's go back in our Unreal Engine, and over here into the blueprints, I'm going to right click a new folder, and I'm going to call this one obstacles. And inside of the obstacles, I'm going to create a blueprint class one is going to inherit from the obstacle, which is this bad boy. And I'm going to call it BB obstacle. Simple, very simple, right click again, blueprint class. And over here, one is going to inherit from the spikes. And I'm going to call it BP underscore spikes. Simple. Double click it, open it in our editor over here almost said Visual Studio, but it's actually the editor again. So what are we going to do? Well, first things first, for the spikes, I am going to click on this BP spikes and add a static mesh component that I'm simply going to call spike very simple. Now for the spike Static Mesh over here, I'm going to click on the drop down list and filter for our quad pyramids. I'm going to say quad pyramids, there you go, this is the one that we want. And over here for the materials, I am going to filter for the clay new, and this is the one that we want. There you go. This is pretty much it except over here, I'm going to set it to minus 50 on the Z position, so simple as that. And also when it comes to the collision, we are going to do one interesting thing. First things first, I'm going to compile and save this and I'm going to go here into the project settings. And I'm going to go here into the collision for the project settings. So it's basically this over here under engine when you go into the project settings. Over here, we can create our own object channels. What does that mean? That basically means we can create our own layers to differentiate the collision between actors. So over here, I'm going to click on new object channel, and the name for that one is going to be obstacle and the obstacle is going to block. So the obstacle is simply going to block the player, it's basically going to be a solid body not allowing the player to pass through. And that is what a block is. And I'm going to click here except next over here, I'm going to say new object channel and this one is going to be our spike, but the spike is going to overlap, the spike is going to overlap so that we can overlap in the deck collision between the spike and the player. I'm going to click here except so now we have the block and the overlap channels over here. What does that mean that means now that I can go inside of the spikes over here and scroll down over here where it says the collision There you go, this bad boy over here, I can zoom in for you to see There you go. So over here the collision preset. I'm going to set that to custom so click on the drop down list and click here of custom from the list. Over here we are going to have the collision back to query only. So we are going to have query only no physics collision because we don't want the physics we don't want to collide as a physics object with our pyramid or basically the spike and over here for the object type. Now we are going to have so let me just Compile and Save this. So now we should see the spike and the obstacle which is the one that we have just created over here. If you don't see it right away, just Compile and Save for your blueprint. And then here from the object type where it says world dynamic you can select this one to be spike, and there you go. So over here I'm going to set our spike to overlap everything except over here the obstacle I don't want it to overlap the obstacle and we can also set here not to overlap or simply ignore the camera because we don't need the camera Compile and Save that. So it is going to overlap all of these other ones. responses such as the pawn physics body, which basically our player were going to set him to be upon. So this right here will be able to overlap with the player. And of course then we will detect collision between them and destroy the player and all of that good stuff. So now we can move forward to our cube or to the obstacle which is this one and again, from here static component we are going to filter for our static mesh, and I'm going to call this one cube or simply call it block obstacle There you go. Over here for the static mesh, I am going to filter for the cube. So simply type cube and there you go, where is the QB QB. There you go, here is the QB QB. And over here for the material, I'm going to say basic shape material. This is what I want Compile and Save that. Now I'm going to leave at 000 for X, Y and Z and I'm not going to touch it rotation I mean there is no point in touching the rotation because it will still be the same it's a cube. And going back over here again for the collision preset instead of block all dynamic we are going to set it to custom over here the collision enabled will be query and physics because again, this obstacle this block obstacle, it is going to be a solid body and it is going to block the player when the player collides with it, the player will not be able to pass through it. And over here for the object type we're going to set that to be an obstacle and we are going to set it to block everything except over here to spike we don't need it to block the spike you can simply overlap this spike, but it is going to block everything meaning it's a solid body, I'm simply going to compile and save that and there you go. So this is pretty much it as a preparation when it comes to creating our level parts. Now of course if something was not clear, make sure that you ask in the comment down below and starting from the next video we are going to build our level pirates and the level and all of the good stuff then we're going to start spawning them and yada yada yada. So I will see you guys in the next video would it is game day begins here EDA has moving forward now we are going to create our levels and for that we are going to go inside of our c++ classes and right click and build a base level class which is going to inherit from the actor and I'm going to call this one so over here, base level and hit enter to create the class and of course, we will have to wait a moment or two or a gazillion moments for Unreal Engine to take mercy upon our motors mortal souls. Until we forget SSD man the more you watch these videos, the more ad revenue i get i guess and the more faster I can buy that SSD. Just kidding, but let's go over here and reload everything there you go. Here we have our base level dot age and here we have our base level dot cpp so inside of our dot h The first thing here at the top right below the includes over here I'm going to forward the Claire so I'm going to say class you box bone and as I said this is called forward the coloration so that we don't have to use the import or include Excuse me. Now going back here at the bottom right below the public virtual void I'm going to create protected and I am going to create a new property. And this your property is going to be blueprint read and write it is also going to be editable anywhere. So edit anywhere. And last but not least I'm going to set it under a category which is going to be equal to triggers like that. What the hell is this teacher I don't know I'm confused the I want to slap you listen, listen, and don't slap me. Okay, so what we have over here is blueprint read and write, basically meaning the component that we now declare which is going to be a you box component, which is a pointer, so I need to add a star over here. And I need to call this or I don't need but I'm going to call it a trigger, which means that this component trigger can be read and written, we can edit it and we can get a value of it inside of the blueprint edit anywhere means we can edit it inside of the Blueprint Editor on the side in the details tab. And the category triggers basically when we search for this component in the blueprint code, we will find it under the triggers category. So we can also call it my triggers you can call it like that and we will see that when we search for it. So what I'm going to do is copy this and paste it down below because we are going to have the same signature, but this time we're not going to call this one trigger but I'm going to call it spawn location like that. And last but not least, we're going to have to public function so public like that. And what's gonna happen here these functions are going to return a u box component which is a pointer so this one is going to be get trigger which is going to get our trigger not Teague. It's a trigger, and another one for you box component. And it is a pointer. So over here, I'm going to say get spawn location like that. And there we go. Now don't worry if this is still white text, you know takes unreal lunger engine for this to compile. While we're waiting for that SSD, you get my point I'm going to right click on this bad boy quick actions and refactoring, I'm going to create a declaration for it over here, do the same thing, quick actions, refactoring, create a declaration for it. And of course, I don't know what to say I mean, you see, you see the issues we all have. So inside of our CPP is where we are going to include same as what we do with our players. So include, and I'm going to include components, backslash box component dot h, it's that age, there you go. And inside of our Begin Play, I am first going to test if the trigger, if it's not equal to null PTR, meaning null pointer, then I'm going to say trigger. And from here, I'm going to say be hidden in game is going to be equal to true and not allow that trigger to be you know, visible in the game live, just compile all of this, so that we make sure that nothing is wrong, and that everything should be working because it's not giving me out to complete the argument, the anything you see build succeeded, we're good to go. But you know, it takes Unreal Engine, I will probably have to restart or close my Visual Studio and open it for this to work. I don't know, do not ask me over here right now going to return a null pointer, instead, I'm going to return a trigger. And over here, I'm not going to return an old pointer, instead, I'm going to return a spawn location. That's all there is to it. And again, make sure that you compile or build this. So it's Ctrl, Shift B to build this code. And voila, there you go. Of course, another way to build this code is to go here and simply Click Compile does the same exact thing. But I am not going to do that. Otherwise, we will wait a lot. So let's go over here inside of our blueprints, and right click and create a new folder, and this one is going to be our levels inside of the levels folder, I'm going to right click and create a blueprint class and inherit from the base level, there you go and select I'm going to call this on BP level one, of course, we're going to have level two up to level 10. And what's going to happen in this one, I'm going to open it and I'm going to create a few levels. And then I'm going to leave up to you to create the other levels because you know, this process can be a little bit tedious, it takes a little bit of time and all of the good stuff, the first thing that I'm going to do over here, in side of the inside of the VP level, I'm going to go and add a few components, the first few are going to be a static mesh, one is going to be a floor. And another one, I'm going to duplicate this bad boy, so copy and paste then instead of floor, I'm going to call this one cube, there you go. And also I'm going to have to box trigger. So box collision, that is one I am going to call and this is not going to be a child of the cube. So I'm going to call this one trigger box, copy and paste it and this one, I am going to call it spawn location box. Let me just Compile and Save that. And let me just add everything that I need. And we are going to code or actually before that in the Event Graph. What I'm going to do is remove all of this. And over here we have in the Event Begin Play, I'm going to set the spawn location. So I'm going to right click over here and I'm going to say set spawn location. And notice it's under my triggers. Look at that, you see this over here. Look at my triggers. It's basically what we did in our code. So if I go back over here, where we have declared these triggers, look at that. So my triggers, this is that category. So now we can find them under this category inside of our blueprints when we want to code. So I'm going to right click and I'm going to say set spawn location and the spawn location again, make sure that it is under my trigger. So set spawn location, here it is under my triggers, and execution flow is going to go over here and I'm going to set that or the spawn location box is going to be the spawn location. Next from there, I'm going to say set trigger, and it's this one over here under my triggers. So the execution flow is going to continue over here and then I'm going to take the trigger box and plug it in over here and let me just Compile and Save that. What this is going to do is going to set the spawn location from our code to this one over here. So we have have, you know connected these two, meaning that now this is a reference to this over here, same thing that we did over here, make sure that you Compile and Save that. So now going inside of our viewport, and here is my floor, what am I going to do to the floor? Well, I'm not going to do anything to the floor, because you know, I'm a good boy, I'm not going to do anything. Instead, what I'm going to do is go over here for the static mesh and filter for the cube. And there you go, here is our cube for the material, we are going to say basic shape material, voila, that's all there is to it. And I am going to change the scale of it. So the scale x is going to be 10. The scale y is going to be one and R, let me just go over here, I have locked the icon. So I don't want to lock anything. But over here, scale, x is going to be 10, y is one and 0.5. So this is going to be this is going to be our floor. Next we're going to have a cube. So over here, taking the cube. And again, adding a cube to it. And over here basic shape, basic shape material, there you go. Now for this cube, I'm going to set it and 90 for the Z position and leave it like that, that's all there is to it, the trigger box, I'm going to take it and for the trigger box, I'm going to set that location 380 The location was going to be stay or stay at zero and the location z 250. And I am also going to set the Z scale to 10. Over here for the trigger box, the trigger box is basically going to be the trigger that when we pass through it then we are going to detect collision and then we are going to spawn a new level. So this is what we are going to do with the trigger box. So when the player passes here and he touches that collision, then we are going to then we are going to detect that and we are going to spawn new level and over here just make sure that it is overlap all dynamic. So the collision preset is set to that. Next we have the spawn location and the spawn location. What am I going to do with it is simply I am going to reposition it. So I'm going to position it at 1,000th. And that's all there is to it. So the spawn location, we are going to use its position to position the next level. So when we spawn a new level, it is going to start positioning from here. And basically it's going to form a new level like that. Simple, that's all what we are going to do with the spawn or with the spawn location. So this is our level one and just make sure that you Compile and Save that. If I go over here inside of the gameplay, I'm going to right click and create a new blueprint class. And now you're going to assume that again, I'm going to use the base level but this time No, instead I'm going to use level one. And every next level that I create is going to be a child of level one. So BP level one, I'm going to select that, and this one's going to be BP level two, there you go. And I'm simply going to open it, it already has all of these components set up in the Event Graph, it is going to call the parents Begin Play which is going to do all of this, it's going to prepare everything, we don't have to do it again for this blueprint. Very clever I know. And that's all there is to it. Of course now we're simply going to add new things to it. And that would be it, for example, the cube that we have over here, I'm going to reposition and so the exposition is going to be minus 330, the Y is going to stay the same and the Z is going to stay the same. But I'm also going to add new boxes. So I'm going to copy this cube and paste it and I'm going to call this one cube two. And for this cube two, I am going to reposition it. So x is going to be 190 y zero z 130. And I am going to set the Z scale at three for the Z scale. Simple as that and copy this one copy and paste now we have the cube three, and for the cube three, the position x is minus 70, the position y 01 180 for the Z and set the Z scale 2.3 and Wallah, Compile and Save that. So this is our level two blueprint. Simple, very, very simple going back over here, right clicking, and again blueprint class. Again, inheriting from level one, there we go. Not level two, but level one, and this one is going to be BP level three. Again, we have everything prepared we we have our base queue, we have everything here prepared in the Event Graph. We don't have to do anything, but we are going to change or reposition this cube. So again, minus 330 For the x, y, I'm not going to touch in z, I'm not going to touch so it's going to stay as is. But now I'm going to copy this cube and rename it to cube two. And this cube two is going to be repositioned at 70 for the x, y 04 20 on the z axis, and over here, I'm going to say three scale for the Z Compile and Save that. Moving forward, we are going to have another level. So blueprint class over here, inherit from the level. So inherit from our level one, select BB, level four, double click it and open it over here in Visual Studio. And again, simply repositioning things so cube over here is going to be repositioned x is minus 303 30, excuse me, 174 the z axis, then I'm going to copy this cube and rename it to cube two. For our cube do, I am going to set the position 160 on the x y zero 2020, or two to zero for the Z and resize the Z scale to four. Last but not least, we have another cube, so copy and paste, and this one is going to be at the 10 for the X 370 on the Z and the scale, Z is going to stay one, but the scale x is going to be two and Compile and Save that this is our level for moving forward, I'm going to right click, and again inherit from level one. There you go. And this one's going to be our BP level five. And now we're going to add some spikes in here. And this is the last level that I'm going to create the next levels are on you. So over here for the cube, I'm going to set the x at minus 30 and the Z 390. And I am going to set the x scale to three the Z scale 2.3 There you go. And last but not least, we are going to attach something or we are going to attach a spike. And I am going to do the following. So here I'm going to click on Add Component selecting the BP level and I'm going to filter for child actor. And this one is going to be our spike. There you go. I'm going to call this a spike too. But of course we're going to have spike one as well. So copy this one. And so what we are going to do for our spike to is over here you see the child actor component. From here, we can select the blueprint, we can click here, and I can filter for spikes. There you go. And let me just remove this one I'm going to duplicate this one after. So for this one, I'm going to set the X to two to zero and the Z is 40 There you go. But I am going to move it a little bit upwards so something like this. There you go here on this position grid snap Val and we decided to one so I can snap it a little bit better, while odd There you go. And I'm simply going to copy this and paste it and this one's going to be our spike one and simply move it over here. Basically the position x is minus 260 and there you go Compile and Save that so this is the last level I'm going to create I'm going to cut out the video right now and create the other levels and go back and show you the levels that I have created but you have plenty of info for you to create your own levels. A quick note you don't have to create the same levels as I did you can create you can create levels on your own which is a good practice and I encourage that every single time. So again for this spikes when we you know touch them we are going to die but we will see that later on. Do not worry about that right now. And basically that's it every single level that you create is going to inherit from level one. I'm going to cut out the video right now and I'm going to continue just remember when you add spikes you're going to add them as child actor components. So from here you're going to filter for the child actor when you select the child actor over here we're going to select the spikes for that child actor. And that would be it. That will be basically it. So I don't have any the NX anything nx I don't have anything else clever to say I don't know how to talk I will see in a few when I create the other level parts and I am back Did you miss me because it took me a while to create all this of course for you it was a few moments but you know if you didn't miss me then you can watch this video anymore. I'm just getting anyways here we have the level 6789 and 10 so this is my level six as you can see you can also download the complete project I have provided that under the you know importing or creating the project video you can you know download the assets or basically the complete project as well and see that on your own or you can create your own levels which I highly encourage you to do but basically this is my life. Six as you can see so we have a cube here and two spikes Next we have the level seven which is very simple as you can see I'm not even moving the collision box or the trigger box and the spawn position they're staying at the same spot where they are in level one and I'm just you know moving the cube resizing it adding here child actors which are the spikes over here I have the level eight as you can see this is my level 8123 There you go till three boxes or T three cubes that is level nine There you go. We have a spike in this weird thing over here the L shape if your name is Lauren, then you know this is for you, Lauren, and over here we have the level 10 There you go. And that's all there is to it compile and safe. I cannot say anything else or I don't have anything else clever to say. Except if something is not clear. Make sure that you ask in the comment down below. And yeah, I will see you in the next video you know, where else can I see you, you know, I don't live where you live, I don't know you in person. So I cannot see you, you know in your home. I can see in the next video. So again, if something's not clear, as gone below, I'll see you in next video. Alrighty, then my game dev elf. So let's go here in the c++ class, I'm going to right click and create a new c++ class inherit from the actor and this one is going to be my spawn level. So spawn level level spawner, however you want to name it, I do not care. You can name it car, you can name it, same name as your grandma, that is up to you, I cannot control you. Okay, I named it spawn level. And this is going to be the class that is going to allow us to spawn all of these levels. But before we actually can do that, we of course need to add a few things inside of that class. But first things first, you know, the SSD drive is still not there. I think I will finish this recording today, which is Saturday for me, I don't know which day is for you. And there we go. Some info that we don't need. So here we have the spawn level CPP and spawn level dot h. So what's going to happen in the spawn level dot h, first things first here above below the includes, I am going to add my a base level class, because we are going to have levels that we are going to put inside of this inside of the spawn level. So over here, I am going to create another public like this. I know it's right below the public. This is how I differentiate my own variables, I like to group them and that's all there is to it. So over here, I'm going to create a u function like that. And this is going to be my void spawn level, which is going to take a Boolean is first meaning is this the first level that we are going to spawn, we're also going to have our own on begin overlap. So I'm going to go here inside of our player character and simply grab it from here so that I don't have to write all of these parameters and all of that stuff, you get the point it can be a little bit tedious, it can be a little bit you know, whatever. So there you go. So just go from the player and grab it copy and paste it is the same signature, the same name and everything. Next over here we are going to have protected. And for the protected, we are going to first have a player who is upon and it's a pointer and I'm going to call him player, we are going to get a reference to the player. Next over here, I'm going to create a new property, your property which is going to be added anywhere. So we will be able to edit it from the blueprint itself and is going to be a T sub class of a base level and is going to be our level one. And this is the reason why I have imported this over here. So don't worry if you don't have those autocompletes I mean, I don't have them. As you can see, the reason for that is simple because Unreal Engine is slow. And you know, reading all of this and the SSD drive is still not here. So over here we have the level two and we have the level three, come on level four, come on level five, you can see you know, some not everything about the game that is, you know, fun and all of that stuff. Some things are a little bit tedious for you and me to do but hey, you sign up for this, I did not you know, I didn't threaten you or whatever didn't force you. So this is all on you. Next year we're going to have a T array or simply an array of a base level who are pointers, and there's going to be my level list. And last but not least, we are going to have also public variables one is going to be a random level because we are going to randomize the spawning of the level. We are also going to have an F vector which is going to be our spawn location for the level and I'm going to call here f vector simply like that. We're also going to have the F rotate tour and this is going to be our spawn rotation again f rotate or simply declare it over here and our f x spawn parameters which is going to be our spawn info was going to be equal to again simply copy this over here so that I can declare it because these are the variables that we are going to use over and over. And Ctrl Shift to build this bad boy because you know, I need to build it okay. And yeah, that will be its Let us wait for it a moment or two. And there you go. We have something over here I believe function public static void. Expect struck Oh, okay. Okay. Okay. I didn't actually, you know, declared these do so right click quick actions and refactorings create the definition. Simple. Right click Actions and refactoring create the definition. Again, very simple, but yet, you know, people are forgettable, they tend to forget things as you just saw that. I cannot wait for that SSD to arrive, man. It's like, you know, I'm waiting for a new life, like I die that I'm not waiting to live again. So yep, I'm going to sing to you. Let me take my Oh, Colin 18 Union union union union union. I'm kidding, I don't have a ukulele. I don't know what that is. I just heard that word. And I told you that Okay, so over here, let me just now compile this. And you see only now we see you know, different colors of everything that we have declared and stuff like that. But now the you know, completion or the build has succeeded. There you go. So now inside of the spawn level, we are going to include or add our includes. So we are going to have over here include base level that age, though that is one of the includes the next include is going to be our engine dot age. So we're going to use the whole engine. And the last include is going to be our components, box component dot h like that. There you go. And I don't know why it's giving me here a red because you know, it's included the same thing. So what do we need to create here, inside of our spawn level, is where the main thing the main magic is going to happen. So over here, what I'm going to do, I'm going to say spawn location is going to be equal to f vector. And over here, I'm going to say 0.0, f 1000 for the y and 0.0, F for the z, y 1000 will because 1000 units is or 1000 centimeters is how large the level is because we you know, set the level to be 10 scale on the x axis, I believe, I think was x axis I cannot remember. But anyways, it's 1000 units, which means that when we have one level over here, if we want to place another level over here, that's 1000 units, that's all there is to it. Next we have the spawn rotation, which is going to be equal to f rotate or, and it is going to be zero here, 90 here and zero here, so on the Y where simply and wrote a shit like that. So 90 on the y and there you go. What I'm also going to check over here, or perform a check if this is not the first time we're spawning, so if not his first which is basically the parameter that we are going to pass here when we spawn the first level we are going to say this is true. But for all other levels, this is not going to be true. So if it's not the first level, then I'm going to say here a base level which is a pointer, last level I'm going to get the last level I'm going to say level list. And that last and this is from the array of the level list where I'm going to get the last level and the reason for that is because now I'm going to say spawn location. So spawn location is going to be equal to last level. And from here I'm going to say get spawn location. And from there I'm going to get the component transform component transform, and from there I'm going to say dot get translation There you go. And if I can finish the statement, if I hover over it says returns the translation of the component basically it will return the position of our spawn location and notice here I'm using get spawn location if you remember in our base level over here, we're getting the spawn location by returning it Look at that get spawn location, we're returning the spawn location and if you double remember inside of the blueprint for that so if I go over here inside of the blueprints and the level and over here, we are setting the spawn location to be equal to this one which is this bad boy over here and this is that spawn location. So we are going to get that value that reference here. And from there, we're going to know where is the last position of the last level. So next over here, I'm going to randomize this, I'm going to say a random level is going to be equal to f math, call on call on. And I'm going to use a Rand range between one and 10, which is going to return numbers between one and 10, including both of these. And then I'm going to say a base level, which is a pointer, new level, by default is going to be equal to null PTR. So null pointer, but now I am going to test for the random level. So if our random level is equal to one like that, then I'm going to say new level, which is the one that we have just created over here, that is going to be equal to get the world. And from the world, I'm going to spawn an actor, which is a type of base level. So this is going to be the actor that we're going to spawn and we're going to spawn the level one actor at the spawn location, using the spawn rotation, throwing bars at the Mars and and over here, we're going to use the spawn info. So spawn in felt like that. There you go. And simply now I can copy this, and I can say, Here else, and paste this over here. If the random level is equal to do then over here, I'm simply going to spawn level two, that's all there is to it, we need to read and we need to need to, why am I saying limini, we need to repeat this process. So again, this one is three. Now over here, we need to spawn the level three, going back over here, as I said, Sometimes things can get tedious over here, random level four, over here and the level four, of course, we can do this, you know, I mean, we need to do it, I don't know what I wanted to say, anyways, six now. And over here, there you go six, over here, now Come on, are going to have 7789 and 10. And we're done. So don't Don't cry, don't be a cry, baby, and all of that stuff, be patient. Imagine how I felt when I created all of this, you know, so yeah, there we go. The last one is here. And finally, we are done. So down over here, spawning the 10 over here. So based on the as you can see, based on the random level that we have over here, then we are going to, as I said, this is going to return either one or 10 or numbers in between. So based on those numbers, then we are going to set the new level which is currently at null pointer to be equal to one of these levels. If it's one, then level one than dude and three, you get the point. But if something is not clear, make sure you ask in the comment down below. Over here what I'm going to do if we have a new level, we need to perform this test because otherwise, if this gets to an old pointer, but of course there is no chance that this will get to an old pointer because over here where you know the randomized numbers are from one to 10. And we're testing for all of them. But if we have a level, then we are going to say if new level and from here I'm going to get the trigger. So I'm going to get the trigger from the new level again, what is this new trigger if or getting the trigger if you remember from the base level over here, we are getting the trigger we're returning that the trigger is again, the huge box over here, this is the trigger where the player needs to pass by so if the player passes by this trigger, then we are going to spawn new levels. Simple as that very, very simple. So if I go back over here, so if we can get the trigger, then we're going to say new level and from there gets the trigger. And from the trigger we are going to say on component begin overlap dot now we are going to add the dynamic which is basically we're going to assign a function that will be executed when we begin that overlap. So I'm going to say this, and from here I am simply going to copy this and I'm going to say and and paste this over here. So essentially, when we collide with the trigger of the level, the one that I showed you a moment ago, we are going to call the on overlap begin from over here from the spawn level. And over here, what we are going to do is we're going to call spawn level, passing false to spawn a new level, simple as that. So it's going to pass or go through all of this over here same as what we did right now go through it, and then it is simply going to spawn a new level And basically that's all there is to it, that's pretty much all there is to it, nothing, you know more. And over here, inside of our on Begin Play, we need to spawn the level. So spawn level and over here I'm going to say true. But I'm going to copy this because the first one is going to be true and the next three are going to be false over here false. Let me just copy paste, copy, paste, let me just compile this and make sure that we don't have any problems and issues because you know, this is coding I am you know, I cannot code according to some of the comments. So it can happen that I miss something and all of that good stuff. So essentially over here in the and while this is compiling, I'm going to try and explain what is going on. So over here, we have created a spawn level function that is going to spawn new levels, we have the spawn location, we have the spawn rotation. And over here if it's not the first, because when we spawn, the first one, we're going to say it's true, but for all others is going to be false. So if it's not the first level platform that is going to be spawned, then we're going to get the last level inside of our level array. And we of course need to add, which is one thing that we need to do at the end, so we need to add our level to the level list. So we're going to get the last level from the level list and then we're going to get its location of the spawn location which is a component that we added. So we're going to get its location and know from where we should spawn the next level. Over here we're going to randomize the value so from one to 10, and if that random value is equal to one, we're going to spawn level one if it's to level two, and so on up to level 10 over here as I said, I did forget so if we have new level after that, so we are going to attach a dynamic and what the hell is this again when I save the seed saving because it's processing everything gold this year. So again, if we have a new level and we do all of this over here so we get the trigger from the level we attach the on component begin overlap we add that to the dynamic spawn level and all of that good stuff. Then over here I'm going to say level list dot add and I am going to an over here it's actually level list like that and capital A and I'm going to add the new level so new level there you go. But I am not going to allow to have more than five elements inside of the level list. So over here I'm going to test if our level list dot num so if the length or how many elements we have in that level list is more than five then from there I'm going to say level list dot remove add and I'm going to remove the last element inside of that level list. Now the bad news is that this still did not compile and the even more worse news is that we need to compile it again. So I'm probably going to cut out the video right here until the SSD drive arrives and I'm going to continue from the you know when this compiles but again here at the end what we did is we added the new level to the level list so that we you know next time when we try to get the last level we will actually have it so we will not have an empty list but we will have a level inside of that list and we are checking if the elements or how many elements are inside of that level list. If that number exceeds five then we're going to remove the element that's at index zero meaning the first level that's there so that's all there is to it and I will see you in a few when this compiles and I am back we have a problem over here that is the reason why this was yelling at me so here spawn rotation I do need to declare this as spawn rotation and all here for every single level I need to add that to spawn rotation so spawn location here spawn rotation, there you go. Here it's bond rotation, rotation rotation, stupid misspelling, I really cannot wait for that SSD drive to arrive you know I'm saying this SSD drive over and over again in hopes that some of you guys will send it to me but you know apparently nothing will come out of it so I need to rebuild this again but this time I think it will be faster because it rebuild it at once so it you know went through that whole process and you know, it now knows it can go faster because we for sure waited a little bit. Well, a little more bit for all of this to reload. Anyways, come on. Let us wait and now there we go build has succeeded. Finally, finally, finally. If something was not clear in regards to this one and I've explained it two times, make sure that you ask in the comment down below because now we need to move on and go here inside of our blueprints and right click and create our levels bahner who who is going to you know, inherit from the level or spawn level Sue spawn level there you go. From here I need to say BP spawn level and go inside and attach all of these levels so we need to attach all of these levels so from here, we need to take level one, then level two, then here we have level three and all of that good stuff so the tedious part that nobody likes to do but everybody likes to play the game. So eight and nine and last but not least here is our level 10 and we need to Compile and Save that so now I can go here in the gameplay and I can simply put my level spawn or I can put him here 000 It does not matter what matters is if I hit the play button that he will spawn the levels and indeed he did there you go look at that all of the levels I can possess the character and now I can run and every single time we you know pass the trigger, we will spawn new levels as you can see over here we have infinite number of levels and every single time you see they're differentiated Look at that, then I can run and all of the good stuff and yada yada yada you get the point. So there you go. As you can see we can run infinite the leap so the last step is to add our wall that is chasing us that is going to kill us that we need to and there we go for whatever reason why these levels huh this was for the I need to redo the level or recheck this level that has these two I probably need to reposition the oh actually no, I don't need to reposition but I need to make that trigger a little bit larger because we jumped over it and that is the reason why that is the reason why we did not have new levels so we need to make sure that the trigger is a little bit larger because again here is the level you see we just need to make sure that the trigger is larger on every single level that is so make sure and since we are inheriting from the level one we can I believe go simply over here inside of the levels level one there we go and make this over here the trigger box a little bit larger so I don't know let's say 20 something like that so it will not allow it and we can move it there you go so now the player has no chance five to five is going to be the position for it unit 530530 and Compile and Save that and I believe it will change it for every single level yes it will there you go it will change it for every single level. So as I said now the player will not be able to jump over it and it will not give us the problem that we just had of not having the level so now even if I go from here and I tried to jump way over here I'm still going to create new levels there you go. So if something was not clear in regards to this video just ask I will not answer and just kidding I will answer and help you out. And that will be it for this video I will see you guys in the next one we're going to create our wall that is going to start to chase us and all of that stuff and then we are going to wrap up our game see it then All righty then my game Deaf gangsta Roni owes Let us wrap up our game so going here inside of our c++ classes are going to create a new c++ class but this one is going to inherit from the spike so I'm going to click here show all classes and filter for our spikes it's it's not spike spike just it spikes there you go and this one is going to be our wall spike There you go. And what's gonna happen inside of this class is I am not going to do basically anything in the dot h file but of course we need to you know go through the painful process of all of this man send me that SSD What else can I say? I'm waiting for it just kidding in a few days it will come to in the next tutorial we'll be ready and this is going to be fast as as as a as something that is fast, I don't know a squirrel. So in the wall, let's go over here reload everything first wall spike that age, I'm not going to do anything but in the dot cpp file we are going to do something. So over here basically in the dot h file we are going to have all of the you know basic so we have the generated body we are going to have a public over here we're going to have a wall spike which is our constructor in the protected so protect that. We are going to have our virtual void. So virtual void Begin Play because we want to override it. So override in our public, we're going to have our. So from here, it's going to be virtual, void, tick, and it's going to be float Delta time. And over here, override, there you go. Because now in the dot cpp file, we are going to implement all of that. So over here, we are going to say a wool spike colon colon, and is going to be our a will spike basically the constructor. And over here, we're going to have our primary actor tick that B can ever tick is equal to true. So we're going to enable that also over here in our void, a wall spike call on call on is going to be our begin. So it's begin blay. What's going to happen over here, first, you're going to call the super, which is the superclass and call the Begin Play from there. So begin, play. There you go, actually begin play like this. And then from here, what I'm going to do is it's not being it's begin play like that Begin Play, I'm going to say this, and I'm going to get the root component from our blueprint, and I'm going to say component, so component velocity, and we just said that F vector, zero for the X 25 for the y and zero for the Z. So this is the velocity, or basically the speed of our of the actor. And next, I'm going to say Boyd, a wall spike with double or capital W spike, call on call on tick. And over here, we're going to have the Delta time, like that. So what's going to happen over here again, first, I'm going to call the super dick. So super dick, which is going to take the Delta time and I know you're expecting me to do some jokes, oh, you're tick. Look, I'm not Danny, I'm not trying to be Danny, I don't care, you know, I'm not going to do the tick joke and whatnot, said actor location. And from here, I'm going to get the actor location, which is the current location of this actor, and I'm going to add to it on F a vector. And inside of this F vector, I'm going to say zero for decks 350 for the Y, multiplied with Delta time, delta time. So it's Delta time, there you go, and zero for the Z. And over here, I'm going to say true. And that's all there is to it. So let me just compile this and we can make sure that everything is okay, we don't have any issues. Essentially, what we did over here is inside of our Begin Play, there we go succeeded we are good. In on Begin Play, we set the component velocity of the root component to be 25 on the y and then over here, inside of the tick, we are moving the actor by using its current location and adding to it only the Y here because x and z are zero, that means they will not move and we're adding to it's 350 multiply with Delta time, of course, you can set a public variable speed or something like that. That is, you know, up to you if you want to do that. I'm not going to do it. But yeah, there we go. So let's go inside of the editor. And inside of the blueprints that I'm going to go in the obstacles and right click and create a wall obstacle. So I'm going to say well spike, because it is going to inherit from the wall spike BP will spike and we need to edit this, we need to edit it to look like a wall. So over here, I am going to filter for the static mesh that I'm going to call walls simply over here for the Static Mesh which is going to be our cube I'm going to say cube like that. There you go. And here basic shape material Wallah. I'm going to change you know the scale so the y and the Z scale are going to be 10. This is it. Over here for our presets you see it's set to block all dynamic instead over here and we'd say no collision. Now the reason for that is because I'm going to detect collision with a box Collider. So I'm going to here go here and I'm going to say bar collision. And simply call it box you can call it box or however, and for this one, I am going to set the x scale at three y scale is going to be 20 and the Z scale is going to be 20. And with this one I want to detect collision with our player. And in order for me to do that, I'm going to scroll down over here where it says for the collision presets and I am going To set this one to the custom collision, over here, I'm going to say query only no physics collision. So basically no physics collision over here for the world dynamic, I'm actually going to set this to spike, because the spike will be able to collide with the player, Compile and Save that now in order for us or for this to work, we are going to go in our player, which is this one, let me just close these levels. So closing, all of the levels Come on, there you go. For the player, I'm going to select his capsule component and scroll down over here for the collision preset, it is set to be a custom one end it is said to be upon. So this is what we need to do, we'll set it to be a custom one, set it to be upon make sure that it is overlapping the spike, because that is what we need. So we need it to overlap the spike. Now what we need to do is go over here inside of our game, and we are going to add our wolf spike, here he is, and let me just reposition him. So the exposition is going to be minus 30, the Y is going to be minus 830 and the Z it's 455. And of course, I'm also going to rotate it 90 degrees on the so 90 degrees on the z axis. If I hit the play button now There we go, you see, it is going it is trying to search for us or actually trying to get us if it catches us looking now is simply going to pass through us we're not detecting collision in the code. This is why we don't see anything. So we need to detect collision in the code for anything to happen. But the point that I wanted to show you is that it is not the tech thing. It is not a solid object, it simply passes through. So how can we detect collision with the player I don't want to leave that in the next video. Instead, I'm going to do it right now I can leave it in the next video, but I'm going to do it right now. So going back over here inside of our runner character CPP at the top here, so inside of Begin Play after or before we set can move to be true, we need to get the capsule component so we need to say get capsule component which is a component the capsule component of the player that we have just edited. You know the one that I said it, it needs to be upon. So from there, I'm going to see on component begin overlap dot and I would say add dynamic. And over here we're going to add this and I'm simply going to go down and copy the name over here so that we don't have to, you know, type it out. So and and that there you go. So this is going to take that capital component from the player, which is you know, in the blueprints, so taking that capsule component, then it is going to attach to it are on begin overlap or on overlap begin. So essentially what's going to happen inside of this one is that we are going to detect if we have collided with a spike or a wall spike. So over here I'm going to say if the other actor is not equal to no PTR. So it's PTR, not TPR. It's PTR other actor is basically the actor, the other one that we have collided with inside of our game. So if it's not equal to no we have collided with some of the actors then we're going to say a spike like that, or spikes which is a pointer. And I'm going to say here walls spikes There you go, or wall spike and that is going to be equal to I'm going to cast that to a wall spike like that and I'm casting the other actor. Now we don't have the completion or anything because we do need to go here on top and right here we need to include a few things so we need to say include our spikes dot h file, we also need to include our wall spike dot h file and last but not least, we need to include the engine. So it's engine dot h because we are going to restart the game when the player dies in order for us to do that. Then we need to use the engine and there we go over here our spikes wall spike we're going to do that or try to cast that next I'm going to say a spikes and over here because it's a pointer spike and I'm going to cast it into a spike like that then I'm casting again the other actor same as what I did be for naturally here it spikes not spike. So essentially if we collide with either the wall so if wall spike or we have the spike. So if we collide with any of these meaning they are not not so essentially over here what we are trying to do we are casting the other actor to the wall spike And other actor to the spike spike basically. So below over here we're testing if we have a wool spike, or if we have a spike, meaning they're not equal to null, that means we collided with one of the two, that means game over. So now I'm going to say get mash, which is going to get the mesh of our character, and then I'm going to deactivate that mesh, I'm also going to say get mesh. And from here, I am going to say set visibility for that mesh to be false so that we don't see it anymore in the game can move is now equal to false, we cannot move anymore. And next we are going to reload the level after two seconds. And for that we need to create f timer handle I'm going to say on used so on used handle like that. And I'm going to say get world timer manager. And from there, I'm going to say set timer. And I'm going to pass the unused handle so on use the handle into this and then I am going to pass this function which is our runner re start level. So over here and passing the restart level passing over here too, because after two seconds, I want that to restart and over here I'm going to say false because I don't want this to loop and be an infinite loop and spawn over and over and over again. The last step over here is inside of our restart level, we simply need to call you gameplay statics. So check out the statics and over here, open level. And simply we can pass the name of the level or we can do this, I can pass this and I can say the name of the level instead of passing the name. I can say here with a star get world like that. And over here get the name there you go. And voila, this world is going to get the name of the current level that we are in and it is going to paste it over here I'm going to compile this and while I'm compiling I am going to explain what is going on inside of here. I don't think there is nothing to explain because we already explained that inside of our runner character we attached here the on begin overlap for the capsule collider. That's everything what we did. And over here we're testing if we have the other actor, meaning we have collided with something so the other actor is not equal to null and there we go, the build has succeeded. So our game is done. And over here we have the other act and we have collided with something. So try to cast that other actor into a wall spike or a spike, basically meaning try to test if the other actor is the wolf spike or if the other actor is the spike. Is that true is that the case basically this is what we're asking. And if we have either of these so if we have a wolf spike or we have a spike meaning they're not equal to No, we are going to get the mesh and the activated we're also going to set the visibility of the mesh to false so that we don't see it anymore we cannot move inside of our game so that when we press the buttons we will not be able to move because over here if you remember only if we can move now we're going to have the move add the movement to the player and then over here we're going to restart the level this is the signature how you restart the level so we need to pass this timer handle even though we're not using it passing this referring to this class this is the function I want to be called after two seconds and no I don't want it to loop I don't want it to repeat over and over again and over here simply calling gameplay statics open level passing the level name to reload the level and that's pretty much it we are done so if I hit the play button right now when we you know collide with the spikes or this wall so now when the wall touches me there we go the character has disappeared now we restarted the level and if I collide with one of the spikes So come on let's try here is one of the spikes there you go bam. I've also died and there we go. This is our game Let's try it out again again let's run Let's run anyways you get the point. Congratulations for making it till the end of this game. If you liked this video, hit the like button and subscribe to the channel all the good stuff because it will help me out you know I'm trying to spread the word about my wisdom and just kidding but anyways, you get the point. So I don't have anything else to say. If you like this, you have more tutorials in my game development Academy. Thank you for watching again and I will see you guys in the next video.