Learn about API security with this course that is tailored to address the pivotal PCI DSS 4.0 requirements. PCI DSS stands for payment card industry data security standard. It is a set of security standards designed to ensure that all companies that accept, process, store, or transmit credit card information maintain a secure environment. As the PCI standard takes a definitive turn to spotlight API security for the first time, understanding its intricacies becomes crucial for businesses. Dive in to decode what DSS 4.0 means for your organization, why APIs are now in the limelight of attackers, and gain invaluable insights into ensuring compliance. Equip yourself with knowledge, best practices, and stay a step ahead in safeguarding your operations. This course was developed by Dan Barahona who has 20 years of cybersecurity experience. Hello, Free Code Camp community and welcome to APIsec University and this course on APS security for PCI compliance. My name is Dan Barahona, one of the co founders here at APIsec University, and for the next hour, you'll learn all about the new PCI DSS 4. 0 and what it. And what requirements it has for API security. I also invite you to check out all our free courses on apisecuniversity.com, including a hands on course on API Pen Testing, an introductory course on API Security Fundamentals, this course on PCI Compliance, as well as one on the OWASP API Top 10, API Documentation and more to come. All the courses on our site include quizzes to assess your knowledge. And if you complete everything and pass the final quiz, we'll issue you a certificate and badge to recognize your accomplishment, which you can also display on your LinkedIn profile. Thanks again for watching, and I hope you enjoy this course. Hi, and welcome to our course on API Security for PCI Compliance. In 2022, PCI released version 4.0 of the Data Security Standard, and it's the first major update in the last 10 years. A lot has changed since then, not just in the standard, but in the world of APIs. If you think back to 2013 when 3.0 came out Google was just releasing their Glass product, we were on the iPhone 5, Instagram was just adding video to their platform. And the OWASP community was six years away from releasing an API Security Top 10. Adoption of APIs was at a fraction of where it is today. And whole industries have emerged around APIs, particularly in fintech and ecommerce. Companies that rely entirely on APIs. And it's hard to imagine any credit card transaction taking place today that is not using APIs somewhere in the chain. And APIs don't even appear in 3.0 of the DSS standards at all, but feature prominently in 4.0. The goal of this course is to introduce you to the changes in 4.0, specifically as they apply to APIs. And not only to show you how to achieve compliance, but to elevate your security posture overall. I hope you enjoy the course. Well, let's dive right in and review what we're going to be covering in this course. We're going to start with the basics. Why are we even talking about API security in the context of PCI and DSS? How are APIs even relevant and why should we care? For those who are new to PCI, we'll do a very brief introduction of the PCI standard itself, follow that up with a review of the DSS, Data Security Standard, and examine what's new in 4.0. What's changed and when you need to comply. And then we'll get into the core of the course here, reviewing the DSS 4.0 standards and requirements in detail. We'll be unpacking individual sections of 4.0, understanding what the requirements are. The best practices and exploring what this means for APIs and how to keep your organization safe. As always, we'll wrap it up with some best practices and do's and don'ts that you can start implementing today. We'll feature some quizzes as we go along and a final quiz as well. And if you complete the whole course, we'll be pleased to send you a certificate and badge to demonstrate your achievement. But first, let me introduce myself. I'm your instructor for this course. My name is Dan Barahona. I've been in the cybersecurity industry for over 20 years, held lots of different roles, spanning marketing, sales, products. Holding leadership roles at places like Qualys, HP and ArcSight, Anomali, and over here at APIsec. From an education perspective, I earned engineering degrees from Rensselaer and Cornell University before doing an MBA over at University of Michigan. I'm the cofounder here of APIsec University. And I really love to be in touch. So if you want to look me up and connect with me on LinkedIn, or you can email me anytime at dan@apisecuniversity.com. Happy to get your messages, questions, feedback, anything we can do to continue to grow this APIsec University site. Thanks so much. So let's kick things off by understanding why API security is such an important topic and why it's so relevant to PCI. And there are three important dynamics happening now with APIs. The first is that APIs are exploding. We've known this for years and it just continues. You've probably seen the statistic that over 83% of all internet traffic now is API based. This is a study from Akamai, they analyzed all their network traffic and discovered this incredible prevalence of APIsourced traffic. Look at the API calls, a hundred billion open banking API calls this year and expected to grow by 5X over the next five years to 500 billion. There's really no end in sight of the adoption of APIs, and that's thanks to just the sheer value and benefit that these APIs provide. And they're powering virtually everything. Every ecommerce transaction, our medical devices, our connected cars, you can lock and unlock, start and stop engines through APIs. They're really powering virtually everything. But APIs are also under heavy attack. The stats are really quite staggering. 40 to 75 billion dollars a year in cyber loss related to APIs. For years, Gartner, the analyst firm, has been predicting that by 2022 APIs would become "the most frequent attack vector." I think that has been borne out and continues to be true. I have another course, API Security Fundamentals, if you want to learn more about specific breaches, we go into a lot of detail there and explore how APIs were exploited. So I recommend you check out that course if you're interested. But the third dynamic is API security. Our APIs are seriously undersecured. And if you just look at testing alone, this report from stateofapis.com looks at all of the testing we do on APIs, and only 4% of that effort is focused on security. And there's a reason for this. How we build applications has fundamentally changed, but security is still keeping up. I want to share some thoughts from a recent Gartner report that really nailed the challenges and the changes happening in application development and security. This comes from a Hype Cycle report on application security that Gartner published in July 2023. Some of the key trends are that we're now developing apps more quickly, in more agile ways, we're relying more and more on developers to secure the code to integrate security into their applications. And we've changed how we deploy and operate our applications with things like cloud native strategies. And these are challenging our traditional and established approaches to application development and provisioning and deployment. However, our existing application security controls have not kept up, and they've become less effective. Dionisio from Gartner summarizes it well. API attacks have resulted in a stream of data breaches, and DevSecOps teams have increasingly become interested in API testing and security. However, our traditional AST tools, application security testing tools, were not originally designed to test for some of the unique types of vulnerabilities associated with typical attacks against APIs. And his point is really spot on. API attacks are fundamentally different and let's examine why. So organizations have long used tools like SAST and DAST, static and dynamic application security testing solutions. And these are very mature, well known tools that look for poor coding practices, injection flaws, cross site scripting, things like CSRF, cross site request forgery, SSRF, server side request forgery, misconfigurations and the like. These tools are looking for common vulnerabilities, common flaws that might exist in your applications. But if you look at the breaches that successfully exploit APIs and result in the losses of hundreds of millions of records, this is not what's causing those breaches. It's not injections. It's not cross site scripting. API breaches exploit something different. Typically business logic flaws or gaps in authorization or weak authentication and the like. And if you want to keep up on this there's a great site, apisecurity.io, where they capture these types of events and exploits and breaches. And you'll see how API breaches happen just doesn't look like our traditional web application attacks. And this graphic down below reinforces the point. Our web scanners, for the most part, are scanning at the UI layer. Mobile UI, Web UI. And there are two issues with this approach. First, we've been relying on the UI layer for too long to do more than presentation. The UI layer is also providing security. It's filtering what data users can see, what actions they can take, what buttons they can press. And this is a problem. The UI should really be about presentation, not about security. And the reason why is that UIs are powered by APIs. And attackers are going to go right around your UI straight to the API. And at the API level, you don't have the benefit of this UI and the filtering and the controls that it's providing. So if an attacker can dream up a request for an API, they can send it. And if your backend app logic doesn't know to block those requests, they'll get executed. And that's how API breaches happen. Again, we have a whole course focused on this topic, the API Security Fundamentals course, where you can learn a lot more on this. No API security course would be complete without a mention of the OWASP API Security Top 10. The OWASP is the Open Web Application Security Project. It's a community that has produced truly foundational application security guides and is famous for its top 10 lists. In 2019, OWASP added a dedicated top 10 for API security, which differed quite a bit from their web app top 10. These lists are widely considered to be industry standards for how to secure your applications. And in 2023, The OWASP community released an updated version of the API top 10, which you can see here. There've been some changes, some additions and deletions, and some items remain the same. The top two are still at the top. And for good reason, the vast majority of API breaches violate one or both of these items. Number one is Broken Object Level Authorization, also known as BOLA. And it refers to the ability of, say, one user being able to access another user's data through an API. And there are many examples of these which we cover in some of our other courses. Number two is Broken Authentication, which is also a frequent cause of breaches. Many times, API endpoints are left open with no authentication, with organizations assuming these endpoints won't be discovered. You should always assume they will be discovered, as attackers will try their best to find these endpoints. And you should protect all endpoints with security, regardless of whether they are documented, published, internal, or external. One of the new entries on the OWASP top 10 is number six, Unrestricted Access to Sensitive Business Flows. And this is the first time that OWASP has referenced business logic specifically, recognizing the opportunities to exploit logic flaws in your applications to access sensitive data. And you'll see that this concept of business logic appears in DSS 4.0 as well. There's a specific requirement that we'll cover to test business logic of your applications and your APIs in order to find any vulnerabilities. We've got a whole course dedicated just to the OWASP API Security Top 10, which you can also find on our website. If you're new to PCI, let's have a very quick review about what it's all about. PCI stands for Payment Card Industry, and the primary goal is to safeguard sensitive cardholder data and maintain trust in the payment card industry. Until PCI was created, the five major credit card brands, Visa, MasterCard, American Express, Discover, JCB all had their own security standards. And in 2004, they all got together, formed the PCI, and created a unified set of security requirements, starting with defining what data needs to be protected, which you can see below. Data like the primary account number or PAN, cardholder name, expiration, verification, stripe and chip data, PINs and more. Now PCI is not a law. There's no government enforced regulation here. But it is a contractual obligation that applies to any entity that stores, transmits, or processes credit card transactions. You can see the timeline of PCI here on the right. It was launched in 2004. In 2006 and 2009 we saw major credit card breaches at TJ Maxx, where 45 million records were breached, and at Heartland Payment Systems, where 130million records were breached, which really reinforced the criticality of PCI and led to the release of DSS 2.0 in 2010, 3.0 in 2013 and 4.0 another nine years later in 2022. Within PCI, there are a number of different security standards, and you can see some of them here below. Each focuses on a different aspect of payment card transactions. For example, there are standards on encryption, on PIN security, on point of sale devices. The one standard that affects virtually every organization that's covered by PCI, organizations that store, process, or transmit credit card transactions is DSS, the Data Security Standard. And that's what we'll be focusing on for the rest of this course. So let's start at the top with the data security standard. Throughout this course, I will use direct excerpts from the DSS documentation itself. You can find the documentation and much more in the PCI Document Library at PCISecurityStandards.org. Let's focus first on the six primary goals of DSS. Running secure networks and systems. Protecting account data. Finding and fixing vulnerabilities. Control who can access what. Testing and monitoring. And maintaining a security policy. Those six goals are further broken down into 12 DSS Requirement categories, which you can see here. Everything from updating default passwords to controlling user access to testing apps for vulnerabilities is covered here. Each requirement provides a detailed description, how to test for compliance, and guidance on Purpose and Best Practice. We are going to focus on Requirement 6, Develop and Maintain Secure Systems and Software. Here is where the DSS specifies how organizations must develop, test, and operate secure applications. Next, let's dig into what's new in 4.0. DSS 4.0 is a huge update to the Data Security Standard. As you can see, the requirements doc itself grew by over 2.5X to 360 pages. The PCI Security Standards Council has outlined four primary goals for the new 4.0 standard, starting with, of course continuing to meet the security standards and security needs of the payment industry. Promoting the concept of security being a continuous process, not a one time or periodic assessment. Adding flexibility for different methodologies and recognizing that not all organizations do things the same way. So DSS 4.0 provides some options for compliance and certain requirements. And finally to enhance validation methods. Being more explicit about what compliance looks like and how to assess it. Now what's especially noteworthy with respect to APIs is that in 3.0 there was no mention of APIs. And APIs appear in multiple sections throughout Requirement 6 of the DSS 4.0. And even where APIs aren't explicitly mentioned they still are very relevant. And one way to think about this is if your APIs are in scope for your attackers, then they ought to be in scope for your security programs too. Let's look at what the compliance timeline looks like for 4.0 real quick. The 4.0 standard was published in Q1 and Q2 of 2022 and as of Q2 2022, organizations could begin certifying against the 4.0 standard. That's the beginning of the transition period that you see here in the timeline. The deadline for 4.0 compliance is March 31, 2024. Meaning all organizations must comply with the DSS 4.0 requirements by the end of Q1 ' 24. There are a few requirements that the DSS has provided a longer compliance period. Those are all required by March 31, 2025. I'll flag those where relevant in the coming slides. And if you want to learn more about any of this, here are a few useful resources. I've shared the links in the course materials. This brings us to the core of this course, reviewing the specific requirements in DSS 4.0 and what they mean for APIs. We'll be reviewing about a dozen sections in the Data Security Standard, mostly from Requirement 6, and examining in detail what is being required and how to achieve it. In each case, I'll show you the actual text from the DSS document itself, discuss how this requirement applies to APIs, and provide best practices to comply and keep your APIs secure. So let's get started. Starting with 2.2.7, which states " all non console administrative access is encrypted using strong cryptography." I bring this one up as this requirement explicitly mentions APIs. In fact, it's the first time the Data Security Standard has flagged API specifically. In this case, the requirement highlights that encrypted admin console access is required, not just for browser based UIs, but also for application programming interfaces or APIs. So it's a pretty straightforward requirement, and of course, all our application communication should be done over encrypted channels. Now we'll get into the core of DSS 4.0, which is Requirement 6, "Developing and Maintaining Secure Systems and Software." Here you see a number of sub requirements, which we'll get into, but one term you'll see throughout Requirement 6 is " Bespoke and Custom Software." This refers to any custom code developed by your organization or provided to you by another party, and this is subject to these DSS requirements, specifically if that software stores, processes, or transmits account data, or it could impact the security of account data. This definition encompasses APIs. So if your bespoke and custom software incorporates APIs, those are in scope. So as we review the requirements throughout DSS 4.0, if it applies to your custom developed applications. it applies to those APIs as well. Now, here at the bottom, PCI has provided guidance that for custom software, "numerous vulnerabilities can be avoided by applying software lifecycle processes and secure coding techniques." Organizations should strive to create a culture of security across the application development team, understanding application risks, writing more secure code, testing for vulnerabilities, and fixing ahead of production. Moving ahead to section 6.2.1, " Bespoke and Custom Software are developed securely as follows based on industry standards or best practices for secure development, in accordance with the PCI DSS, and incorporating consideration of information security issues during each stage of the software development lifecycle." That's the requirement of 6.2.1. Further, The DSS standard instructs organizations to "understand how sensitive data is handled by the application to inform how to protect the data." The implication for APIs here is pretty clear. PCI wants organizations to bakein security as early as possible in the creation of custom code, or "shift left" security as you may have heard it. Stating that "DSS requirements must be considered when developing software by design rather than trying to retrofit the software later." To achieve this requirement, organizations need to ensure application developers are aware of the API security risks and can create and test code to mitigate those risks. Where 6.2.1 calls for organizations to utilize industry best practices for secure application development, 6.2.2 goes a step further and mandates training for developers. It states, " Software development personnel working on bespoke and custom software must be trained at least every 12 months. And that training needs to be 1. Relevant to their job function and development languages. 2. Include secure software design and coding techniques. And 3. Train on the use of security testing tools for detecting vulnerabilities in software." As organizations develop applications with APIs, engineering teams must be trained on API related risks as well as best practices for avoiding API exposures and vulnerabilities. Organizations should arm development teams with APIfocused security training, such as what we provide on APIsec University. The standard also points to a need for vulnerability detection and testing custom software. For APIs, organizations need to begin or expand their security testing. And as we saw earlier, Only 4% of all API testing is focused on security. New API security testing tools do exist that will automate API testing and give you continuous assessment. Organizations can't rely solely on manual testing or once or twice a year pen testing. And finally. Development teams need to be trained on these tools and how to use them to find vulnerabilities before they ever get to production. I'd like to point out that APIsec University makes our courses compatible with internal Learning Management Systems. So if you'd like to provide our courses to your colleagues and employees within your LMS, we can help. Feel free to get in touch. Section 6.2.3 continues the theme of looking for and addressing vulnerabilities in code. " Bespoken custom software must be reviewed prior to being released into production or to customers to identify correct potential coding vulnerabilities." These code reviews need to look for new and emerging vulnerabilities. And traditionally, new and emerging vulnerabilities refers to things like zerodays or other newly discovered vulnerabilities. These vulnerabilities are most likely to be related to third party libraries and APIs that you use in your applications. So make sure to keep updated on any vulnerability reports. A critical best practice, though, when using third party APIs is to trust nothing. Your application should not assume that the data coming back from external providers is legitimate. Check all responses to make sure that it fits with what you're expecting. For example, if your app uses a third party API to normalize, say, physical addresses, make sure you don't accept responses that could be malicious, like URLs, or strings with slashes, or anything that doesn't look like an address. And the final item in the Good Practice section is especially relevant. "Checking for logical vulnerabilities." This is perhaps the most dangerous type of flaw in applications. If there is a logic flaw in your app, that flaw will get exposed via the API, allowing an attacker to exploit it. Your custom software must be analyzed and tested to find these logic flaws. This section of Requirement 6 is one of the most substantial in terms of testing for vulnerabilities, and I like to think of 6.2.4 as the OWASP section of Requirement 6. It mandates the use of "software engineering techniques to prevent or mitigate common software attacks and vulnerabilities in bespoke and custom software." So this section details a whole lot of attack vectors that need to be considered. Things like injections, authentication exploits, bypassing authorization, cross site scripting, cross site request forgery, security misconfiguration, and more. All of these covered by the OWASP Top 10. It also explicitly flags APIs as an interface that must be considered when addressing these risks. Your testing programs must include APIs, not just the web and mobile app interfaces. 6.2.4 also reinforces the concept of business logic attacks that we just learned about in the prior section and the need to examine your own application functionality and consider not only how your apps are meant to be used, but critically, how your apps might be abused. For example, and here's a real world example, there was an attacker who exploited an API on a crypto trading platform to sell his Ethereum stock as Bitcoin. The API allowed a user to overwrite what asset they were trading and sell it as something else. A great example of a logic flaw. Web scanners and pen testers regularly test UIs for injection vulnerabilities, and that must be expanded to include testing at the API layer. In the last callout box here, you'll see developers should be familiar with different types of vulnerabilities and potential attacks, and use measures to avoid potential attack vectors when developing code. The need for security training for developers repeats throughout Requirement 6. Again, the API Security Fundamentals course offers great training for developers and others who need to understand API risks. 6.3.1 covers Vulnerability Management and sets the requirements for how organizations need to operate a VM program. To start, security teams need to have access to vulnerability information. There are plenty of vulnerability databases. And the industry standard source for vulnerabilities is the CVE database hosted by MITRE. You can find it at cve.mitre.org. CVE stands for Common Vulnerabilities and Exposures. And pretty much every reported vulnerability gets documented here and is issued a CVE ID number. But what you'll find here, as the name states, are common vulnerabilities. I. e., vulnerabilities in third party code, apps, and libraries that you use. But notice the statement here at the bottom to specifically look for vulnerabilities in custom code and bespoke software. And here, the DSS adds more detail about where to find vulnerabilities in your third party software. And all of this so far really focuses on the third party. But here in the last callout box, you'll see DSS showing concern for your proprietary application logic. And this is a really critical element. DSS states, "for control over in house developed software, the organization may receive such information from external sources." And then they highlight bug bounty programs, independent investigators, and more. Now, this requirement has big implications for your APIs. First, you need to secure the third party APIs that your applications consume. That means keeping up to date on versions, patching that's required, monitoring for new vulnerabilities. And second, you need to look at your internally generated code, including anything that's exposed by APIs to find vulnerabilities or logic flaws, authorization gaps or anything else that can be exploited. And you're not going to find this in any CVE database or Patch Tuesday alert or anything else. Flaws in your code are your own personal zerodays. And these vulnerabilities are the types of vulnerabilities attackers most want to find. The traditional and common vulnerabilities, things like injections and cross site scripting, are rarely the cause of major API breaches. Your APIs expose your application logic, the good and the bad, and any flaws in your application logic will also get exposed. So it's critical to, 1. keep up to date on the latest API attack techniques, and 2. perform security testing on your applications regularly. That means not once or twice a year, but with every release. And make sure that testing covers your APIs and is providing adequate coverage. That means testing every endpoint across dozens of attack vectors, including logic and authorization tests. Now, this probably sounds a bit daunting, and the only way to achieve this level of continuous assessment is with automation. There are API optimized testing tools out there to help. 6.3.2 focuses on having an up to date, complete, and accurate software inventory, specifically your bespoke and custom software, as well as any third party code you're using in your custom applications. The stated goal of this inventory is to "facilitate vulnerability and patch management." And here in the Purpose section, the DSS explicitly calls out third party libraries and APIs. These need to be known, tracked, and managed to address any vulnerabilities that they might have. Actually, having an accurate inventory of your software and APIs isn't just good for security, it's critical to your overall application governance. I've met with many security teams who claim they have little awareness of all the APIs running in their organization, and this is undoubtedly true. But the fact that security teams don't have this information doesn't mean it doesn't exist. So security teams have to partner with Engineering to deal with these API security concerns. The reason why is APIs are fundamentally gateways to your application functionality. And most vulnerabilities will need to get addressed inside the app code in collaboration with the engineering team. We've got whole courses dedicated to API governance, but that's really where security needs to start. Governance means knowing what APIs you have, but also what function they provide, who has access to them, how they need to be secured, things like authentication, access controls, input validation, etc. And governance also means setting standards for how your APIs are documented, what policies you have for handling sensitive data, when you need new versions, what happens to the old versions. And governance also means APIs get deployed into production in a standard way where every release goes through, not just functional testing, but security testing too. And all APIs get managed in a common platform, like an API gateway. This gives your organization, not just great consistency and operational efficiency, but also enables security. What APIs you have, how they're being used, and they have to clear the necessary gates to get into production. For this requirement, organizations have until March 31, 2025, one year later than most of the DSS 4.0. And that's likely a reflection of the challenges organizations have in even producing an accurate inventory. Until then, DSS calls this a best practice, which I couldn't agree more with. Definitely invest the effort to produce an inventory. But if you're going to do this, then make the most out of it. Use this as a driver for better overall security in your organization and better governance across the entire API lifecycle. Look at your API program from design to coding to testing to deployment to really reap the benefits of better governance. We're next going to cover 6.4.1 and 6.4.2 together, and you'll see why in a second. This requirement addresses the need to actively protect public facing web applications against attacks. The purpose, of course, is to make sure applications are resilient against attacks, as web applications are going to be the primary target for those attacks. As DSS states, "poorly coded web applications provide an easy path for attackers to gain access to sensitive data and systems." But pay attention to that term web application. Many will interpret that as referring to their web, and maybe mobile, user interfaces. When we think of an application, we tend to picture something you can look at and interact with. But this is not the full scope of your application. You have to look at any interface, human or machine, that can exercise your application. And that includes APIs. So the choices DSS provides here are to either perform a vulnerability assessment or implement some kind of inline automated protection solution. If you go with the vulnerability assessment route, the requirement is to perform the scan every 12 months or after any major change to your application. The assessment must be performed by an organization that specializes in application security. It has to cover all the threats that we talked about in 6.2.4. You have to rank all the vulnerabilities you find and correct them, as specified in 6.3.1, and then retest your apps to make sure the vulnerabilities are remedied. Now for the automated protection approach, this has to be installed in front of your web app, running continuously to find and block any attacks. And it must produce audit logs that can be analyzed later as needed. The most common example of an automated protection solution is a WAF, a Web Application Firewall. These are widely used to analyze application layer traffic and block against known threats like injections, high volume attacks, cross site scripting, etc. An API gateway will also provide protection and can perform things like API input validation, user authentication, access controls, rate limiting, IP and geographic whitelisting and more. There are API specific runtime protection solutions as well that act like WAFs for APIs. In terms of timing, 6.4.1 gives organizations a choice of approaches, but you have to comply with one or the other by March 31, 2024. Now, under 6.4.2, that option goes away, and you must deploy an automated approach, or an automated technical solution, and that is due by March 31, 2025. Now, although runtime detection and blocking of active threats is very appealing, the reality is certain attacks are nearly impossible to detect in real time, as signature based blocking and anomaly detection aren't able to identify every attack. Some of the most damaging API attacks we've seen exploit unique application logic where unintended flaws exist. In the example I gave earlier with the crypto trading platform, the user exploited a flaw in the API where they could change their asset from one type to another. This would be virtually impossible to detect in any automated way. So really the best practice here is both. To do both automated blocking where possible, and to complement that with comprehensive testing to uncover flaws before attackers find them. Section 7 of the DSS focuses on access controls to critical data and systems. I just want to touch on this section in general and highlight a few requirements and best practices. The purpose of this whole Requirement 7 boils down to who has access to applications and systems and what can they do. Of course, this applies to the underlying infrastructure that supports your applications. The servers, containers, databases, network devices. You have to make sure access is secure and controlled internally. At the application layer, though, you have to think about all the functionality, the data accessibility, the business flows, and your user types. For example, a regular user should be able to access their account balance. They should not be able to see any other user's data. But maybe you have support personnel who need to be able to access any user's information. Or take that end user accessing their balance. They should be able to see their balance, but not modify it. So what this means is, you need to build a matrix of all functionality available through your APIs, and map that across all of your user types, whether that's an end user, support person, QA engineer, developer, admin, etc. And even map that across your different environments, development, testing, staging, production. It's not enough to do this analysis at the UI level. As we've seen before, while UIs provide the ability to control user behavior, filter data, and manage what they can do, when you take the UI out of the equation, you're left with individual API endpoints. So make sure you're analyzing access controls at the API level. Now let's talk for a second about authentication versus authorization. You definitely want to set up policies around API endpoint authentication and define those policies in an API Style Guide that all your developers can use. For example, if an endpoint is purely informational, has no user data, for example, an endpoint that checks where the nearest bank branch is, then maybe you don't need any authentication on that endpoint. But another endpoint could let a user check their account balance. So you'll want to authenticate them. And maybe even higher security for performing a transfer, like putting in a two factor challenge. That's all about confirming that the user is who they say they are. And this can be managed at the API layer. And the best practice is to centralize all that access in an API gateway. But authentication is not the same as authorization, and we've seen many breaches where an organization implemented user authentication but failed to address authorization. Let's use another example. There's a popular exercise equipment vendor that provides an API that has access to all users in the platform. Although the API required users to authenticate properly to access the endpoints, it did not control which records they could see. So once authenticated, the user could see not only their own records, they could see anyone else's as well. This is more common than you might imagine. The point is authorization needs to be considered and defined and then implemented within the application logic itself, not at a gateway or other access point. Lastly, once you've got your access controls defined and implemented properly. You want to make sure nothing changes. And if something does, you know about it. Here's where we recommend RBAC monitoring, i. e. continuous testing of Role Based Access Controls, to see if any settings get adjusted so you can be aware and ensure no control gaps emerge. Here's another section I'll cover at a high level. 10.0, "Log and Monitor All Access to System Components and Cardholder Data." This section spells out in detail all the requirements for collecting logs, storing the data in a central repository, and analyzing the activity records for security and incident response purposes. As the DSS states, "logs allow thorough tracking, alerting, and analysis when something does go wrong. Determining the cause of a compromise is difficult, if not impossible, without system activity logs." Now typically logging is enabled and captured at the system level, i. e. all the servers, databases, network devices, firewalls, and more. But logging must also be captured at the application level. Here's where you'll see the details of user behavior and be able to find anomalous activity. To get this level of granularity, your application must first be instrumented to produce the logs in the first place. Make sure your developers add logging events into their code that captures all the relevant details. Who's performing the action? What are they doing? When did it occur? From what source or IP address? Was the action successful? Another great source of application level logging is at the API Gateway. These platforms will natively record all accesses to APIs and individual endpoints. Finally, be sure to centralize all this data in a common repository where your security team can analyze and detect threats as they happen. And the last section I want to cover in PCI DSS 4.0 is Requirement 11. "Test security of systems and networks regularly." Throughout this course, and across many of the DSS 4.0 sections, we've talked about how important testing is. Many of the DSS requirements specify security objectives, with the need to test to confirm programs are running as designed, to ensure vulnerabilities aren't appearing, and access controls are set properly. Section 11.0 formalizes this need to test for security regularly, and DSS recognizes that "vulnerabilities are being discovered continually by malicious individuals and researchers, and being introduced by new software. System components, processes, and bespoke and custom software should be tested frequently to ensure security controls continue to reflect a changing environment." As you can see, this requirement specifically refers to bespoke and custom software and the vulnerabilities that your code can create. It also mandates organizations test applications frequently to ensure no vulnerabilities go undiscovered. As we've discussed throughout this course, application testing cannot be limited to UI alone. Public facing applications rely on public facing APIs, and these are ripe targets for attackers. So your testing programs must include APIs and should be automated to ensure complete coverage of every API endpoint, simulate attacks across all of the OWASP Top 10 categories and more. And run in a continuous manner, recognizing that modern organizations update code monthly, weekly, and even daily. So make sure your testing keeps up. Okay, we've covered a lot of ground here and have examined how organizations need to address API security concerns to stay compliant with PCI DSS 4.0. So let's bring it all together and summarize what the requirements are, some of the best practices for not only complying with the standard, but in elevating your organization's security posture. And we'll wrap it up with a list of do's and don'ts. First, let's summarize the various sections of DSS 4.0 and what they mean for APIs. Starting with 2.2.7, this requires secure access to admin consoles, including encryption of all communications. Make sure you're looking at API access to consoles as well, and not only encrypting the communication, but controlling access to those endpoints. 6.0 is the core of DSS 4.0 with respect to securing payment related applications. We spent a lot of time looking at many different subsections of Requirement 6. The key to remember here is that with DSS 4.0, APIs are 100% in scope now. All your bespoke and custom software, the code you write to power your organization's unique offerings, is powered by APIs. And those APIs need to be secured as much, or even more than your classic web and mobile applications. The subsections in requirement 6 get more specific about securing your custom applications. 6.2.1 focuses on secure software development, and requires engineers to be aware of API security and vulnerability risks. to ensure code is free of flaws that can be exploited. DSS recommends integrating as far left as possible to find vulnerabilities before they reach production. 6.2.2 sets requirements for annual training of developers. APIs have unique attack patterns, so it's critical that your developers understand what these look like and how to create more secure applications. 6.2.3 requires organizations to review and test code for security flaws. Here, DSS highlights how attackers are targeting your custom code via the APIs, and looking to find and exploit logic vulnerabilities. 6.2.4 covers a wide range of well known application attack types and mirrors closely the threats listed in the OWASP application and API security top 10 lists. This section rightly calls out API specifically and highlights attacks on business logic and manipulation of APIs. The point being, your vulnerability discovery efforts need to cover APIs, not just UIs. 6.3.1 calls on organizations to implement vulnerability management programs. It's important to focus on the vulnerabilities that are likely to cause the most damage. And while injections and cross site scripting are legitimate vulnerabilities, and you absolutely need to test and fix these flaws, these rarely are the cause of major breaches. What we see regularly are logic flaws, weak authentication, and authorization gaps. These are the vulnerabilities you need to test for, especially at the API level. 6.3.2 requires organizations to develop and maintain an accurate and up to date inventory of all custom software. This must include your APIs. Having that accurate inventory is really part of a solid application governance program where you standardize how APIs get created, set security policies that are implemented consistently and all APIs get tested and deployed in a common way. 6.4.1 gives organizations an option to perform either periodic vulnerability assessments or implement runtime attack detection and blocking. The option goes away in 2025 when all PCI covered entities must enforce active detection and blocking. Just be aware that not all threats can be detected in real time. There's no magic firewall that will protect against all threats, and in fact, frequently the most damaging exploits aren't detectable. So you need to keep up testing and detection of vulnerabilities, and then fix this in the code. 7.0 requires strong access controls. Here you need to examine the entire infrastructure and application stack and look at what users can access and what they can see. It's important to review these controls down to the individual API endpoint level to make sure there aren't any access gaps. And definitely implement continuous testing to uncover and alert on any changes in access permissions. 10.0 requires organizations to capture logs from all systems involved in payment processing. This is critical to detect threats and perform root cause analysis. Make sure you're capturing user activity logs on APIs as well, and this is best accomplished with an API gateway. And 11.0 calls on organizations to perform regular testing of their custom software. So make sure that includes all of your APIs as well. All right, as we wrap up this course, let's touch on some of the core best practices, not just to comply with PCI, but to run a more efficient and effective API security program. We'll start with governance. API security is not really something you can bolt on. You want to integrate security into the entire application lifecycle, from design, to product, to retirement, creating a culture of security throughout your organization. This starts with putting time and effort into defining your API policies, how your APIs get used, who can use them, what they can do, then defining your standards, what APIs should look like, how do they get created. And then standardizing your processes. How do APIs move from development through QA and into production in a consistent manner. It's highly recommended that you centralize all your APIs in a common platform, something like an API gateway or a marketplace. This will let you manage APIs consistently, define common policies, and give you a central source for auditing and logging user behavior. And make sure all your APIs only go into production having passed the required gates, including documentation, testing, security audit, and so forth. Our next best practice focuses on how to create a culture of security within the engineering and development organizations. We've hosted many roundtables with cybersecurity leaders and noticed a common theme. The CISOs uniformly agreed on the need to integrate security into the development team. And one of the best ways to create that security awareness was to embed security champions right into those teams. As we've discussed, especially with applications and APIs, development shares the responsibility for security, as most vulnerabilities will require dev involvement to remediate. Security champions are security savvy personnel who can work and operate directly within the development organization, providing insights, best practices, answering questions, and so forth. Number three on our best practices list is actually straight out of the DSS document providing API security training to all relevant employees. And this should include any developers creating APIs, any API product owners, and ops teams. As we've seen, APIs face new and different types of attacks, so make sure the training covers API specific threats, the OWASP API Security Top 10, and best practices for keeping APIs secure. We've got a great course at APIsec University called API Security Fundamentals. It covers everything I just mentioned and can even be deployed in an internal Learning Management System. And our last best practice here focuses on testing. APIs expose so much application functionality, and it's more critical than ever to really pressure test that functionality to make sure your apps can't be abused. This means testing every single API endpoint across all kinds of attack types, everything you see in the OWASP Top 10, and examine your app logic to look for any flaws or gaps that can be exploited. And you need to do this with automation. Implement a testing program that will run automatically, create the test coverage you need, and run against every release to find vulnerabilities before they get to production. I'd like to wrap up my courses with some really tactical do's and don'ts that you can take back and implement right away. As we've mentioned a number of times, DO educate your development team and API owners on API risks. They're under attack, and the threats are different than what our web apps have seen. DO integrate security into the dev process. Make sure engineers understand how to code more resilient APIs and test for vulnerabilities ahead of production. DO build communication between security and development. The gap here is way too big, way too often. Both teams need to collaborate to keep APIs secure. DO mandate documentation on all APIs. This feels like one that shouldn't be needed, but far too many APIs are not documented. Under documented or not updated. Documentation helps drive consistency, reusability, integrations, and also security. DON'T treat internal APIs as inherently secure. They may be harder to find, but attackers are pretty clever, and we've seen many internal APIs get accessed in unexpected ways. DO centralize API management and control in something like a gateway. Many organizations end up using multiple gateways, which is fine. Just use some platform to manage all your APIs in a consistent way. DON'T rely exclusively on manual security testing. A once or twice a year penetration test will not keep up with the pace of your code changes. And it won't give you the breadth of coverage considering how many endpoints you have and the attack types you need to simulate. Which leads to our next item, DO automate testing. Integrate your testing with your CI/CD pipeline. Make sure every release gets tested before they go live. DON'T filter data in the UI. This is one I can't stress enough. If your app returns all the fields of a record, and you rely on the UI to filter out the sensitive stuff, then all an attacker needs to do is go around the UI and call the API directly and get the raw, unfiltered data. DO take time to carefully define API standards. This falls under the governance umbrella. It's really important to have a well defined, thought out set of API standards and policies. This will aid your entire API lifecycle, including security and compliance. DO pressure test your APIs for logic flaws. These are nearly impossible to detect in real time, so make sure you test your APIs in ways they're not meant to be used to find these flaws. DO use runtime protection to block well known attacks. This is mandated in PCI and is a best practice. So use a web application firewall or other device to block volumetric attacks, injections, and others. But DON'T expect the firewall to prevent all threats. Some are going to get through, so make sure you're finding those vulnerabilities. especially logic vulnerabilities through testing before production. And finally, DO train your API teams on the OWASP API Security Top 10. This is the industry standard on API risks for a good reason, and you definitely want your developers to understand the threats. That wraps up the API Security for PCI Compliance course. Congratulations on making it all the way through. I hope you enjoyed the course. We'll be sending you a certificate of completion and badge to recognize your accomplishment. I really appreciate you taking the time for this course, and I invite you to check out our other courses at apisecuniversity.com. I'd love to hear from you if you've got any feedback, suggestions, or just want to connect for any other reason. You can find me on LinkedIn and you're welcome to email me directly. Thanks again and I hope to see you in another course soon. Okay, that wraps up the API Security for PCI Compliance course. Hope you enjoyed it. If you'd like to earn a badge and certificate for this course, please enroll at apisecuniversity.com, take the quizzes, and we'll be happy to issue your cert. While you're there, be sure to check out our other courses, including API Pentesting, API Security Fundamentals, and more. We also host many webinars with API experts across industries, disciplines, and geographies. You'll see these listed on our website and on our YouTube channel. Please subscribe. Thanks for watching, and hope to see you again soon.