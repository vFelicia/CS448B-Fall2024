well hello there welcome to this series where we make this beautiful simple application that you see right here that is uh akin to like a facebook or a twitter or any social media application where we allow the users to register or log in after they register and then create and share posts with other users and interact with the with those posts and those other users so if i were to demonstrate this app right now we could go to the register page which you see right here that shows us this form and if click on register you can see that we're going to be implementing validation so that's going to be done on the server side and represented on the client side as you see right here and i already registered so i can straight away go to login and have a user called user with a password of one through six so i hit enter and it logs me in and now i can have this form right here which allows me to submit a new post so i'm gonna do that here is my new post i hit enter and it immediately shows here and there's like a really simple slick animation that fades in like i said we can interact with these posts so for example i can like this post here and the in increments instantly and it changes color i can as well comment on it so i go here and i'll say yeah it's the new thing and i hit enter and it's posted and as you see anything that is posted by our own user will have this delete button right here which in this case is the delete comment and if i go back it's a delete post and if you click it it shows you this uh confirm model you click ok and indeed that post is gone so this application uses uh react on the front end so this is something that i hope you're at least a little bit familiar with if not it's okay this is a beginnerfriendly series i'm gonna go through every uh single thing that i use and explain it why i'm writing it in that way so alongside of react on the front end we're gonna be using semantic ui to style it and give it this very simple but still elegant uh style uh if you used something like bootstrap before you're gonna feel very comfortable using this it's a very similar kind of uh approach to the uh to styling but it has some extra elements and uh some simplicity to it and that's why i chose it for this series and uh in terms of the focus of the series it's going to be on graphql which is a query language that sits as an interface between our application and the server and the database and i'm going to explain in a little bit more about graphql so stick around for that but what is graphql well i'm glad you asked graphql is a query language that we can use as part of our serverside code and it sits on our existing api graphql is technology agnostic meaning that it doesn't care what programming language or database you're using whether your api is some code that fetches and writes data on a database or it's code that consumes another api and gets data from there as long as you shape the data properly according to type definitions defined by you it will receive and send data to the web client without any problems there are three types of graphql operations that we can perform queries for reading data for example fetching one or multiple posts and mutations for writing data which includes creating updating and deleting examples of this would be creating a post updating user details or deleting a comment um or deleting a like and subscriptions for listening to changes in our data in real real time this is done using websockets in the background and it's useful for things like chat or polling apps mostly you'll use queries and mutations when using graphql whether reading or writing data we always send a post request with a body that contains some information about what type of data that we want to get back or save on the database rest apis were created to have a conventional way of sending and receiving data between the client and the server but even though these conventions make rest apis easier to deal with there can be different types of resources and there can be different endpoint names and endpoint parameter variables etc graphql reduces the amount of information needed for developers to learn how to consume an api by having one main endpoint fewer operations and selfdocumenting apis this will become clearer as we start to implement it a lot of companies like facebook twitter paypal and many more are now using graphql in some of their services to benefit from the improvements that it offers over a traditional rest api the major advantage of using graphql is the control over the amount of data requested and sent back to the client let's send let's say for example in our home page of our app we want to fetch recent posts and we want to show a couple of things about them like timestamps body username and number of likes and comments using rest api we would send a request and get an array of posts each one looking like this and then display the details that we want and ignore the rest of the data that we don't need this isn't strictly speaking a problem but because in this example we don't need the comments and likes themselves just the number of them it would be better if we were to receive something like this by reducing the amount of data sent back from the server we decrease bandwidth usage and latency time we could actually do this by adding another endpoint that returns just that data and use that on the home page but this becomes a problem as we find ourselves writing more endpoints the more pages we have and which will drastically increase the amount of code that we have to write on the back end and we have to document all of these endpoints for our frontend developers or for anyone consuming this api you can now see why this approach isn't optimal graphql solves this by letting us send a post request to one endpoint and specify what resource we want in this case posts and what fields we want in this case everything except likes and comments we can also specify many more factors like what post uh what the post body contains if we were for example to search for a specific post or post by a certain user or a specific number of posts etc all of these can be done through one single endpoint and just by changing the request body itself so these are the tech that we're going to be using for this series basically mern plus graphql well mern if you will will use apollo server which uses an express server in the background or you can also use something like express graphql or graphql yoga they all do the job well but i personally prefer the tools that come shipped with apollo server like i mentioned this series will be a standalone and right after the series we'll implement the front end using react with hooks and context api and we'll use apollo clients there and the new apollo react hooks library to make sure that we write our app using the most uptodate features of the frameworks that we're using so i wanted to do a demonstration of the server that we're going to be building so this is our server application running at port 5000 uh you can have it at slash graphql or you can have it just at the base url it doesn't make a difference um so this is the graphql playground and one of the tools that we get from apollo server and here i wanted to show you some examples from our application that we'll build so this is an example of a query so right here you specify the type of operation in this case it's a query and then you specify the name of the query that we want to use depending on the type definitions that you have so i've already written this query get posts which returns us just that the posts from our database and here we specify the fields from that query that we want and these are of course defined as well in our type definitions that what each resource returns in terms of fields and if i press the play button here it's actually going to fetch from our database our data and returns it in a in this object inside of this data inside of this get posts object so each time we send a query our result is sent back in a object that has the same name as that query unless we have some errors and then we will get an object um errors right here and then we'll have our errors there so here as you can see we get exactly the data that we asked for id body all the way through a comment count and here to demonstrate to you the flexibility of graphql we can say just let's just get the id and the body and if we press play we get exactly that data so bear in mind that this is on the server right now that means none of this data has been sent to the client so the server gets this request and then on the server decides what data to fetch it fetches all of the data from the database and then it filters out the data that the user didn't ask for and then returns a smaller payload of data so here if you want to add more fields we can actually do control space and this tool self documents and it fetches automatically our types and knows what to expect so here if we forgot our fields we can just do control space and then click on create that and if i want to get the username now i add these two and i hit enter and we get those fields now as well now this tool is available for your frontend developer once you expose this once you deploy this app and you give this base url which will be something other than localhost if you deploy it live your frontend developer will have access to this tool and then we'll learn how your api works your graphql api works without you having to write any documentation they can just click on the schema tab and they will see all the queries and mutations available for example if they want to see how the get get posts query works they can click on it and they will see the type and the type of data each of the fields have and they will learn how to actually interact with your api without you having to write any documentation this is what i mentioned earlier by graphql being selfdocumenting now let's look at mutations so let me close this if we go here i've already written these two mutations for login and register if i were to run the login user or pass it of course i've already written the code for this saying that look at the login requires a username and a password and returns a couple of things one of them is a json web token that we will use on our client to authenticate the user and keep them authenticated for a period of time if i click here and i click on the login user um mutation there we go we get our token back which we will use later to access protected routes like creating posts or liking or commenting on posts and i've already like as well thought about validation and server validation which is an important thing for us to learn to validate the data and for example as we see here we already have a user with the username user if we were to try to register another user with that username and click here on register user we get errors and we get as well an array of errors right here and saying confirm password passwords must match actually it validated the passwords before the user if i were to put two matching passwords it will still have an error saying that the username is taken because it is taken and now if i solve all the uh the errors let's say user to which doesn't exist on our database and we say the email um well i set it up to be jane so i was meant to type jane here as a username and this should go through and we're requesting more fields than just the token and we click here register and there we go we get all the details back of from our user table record and we can use this on the client to authenticate and send protected route requests so yeah and by the way i didn't mean protected route and then protected operations since there's only one route when using graphql so i just wanted to demonstrate quickly our app and yeah this is of course we have more mutations and queries to build once we start building this app i hope that this gave you a clear understanding of what graphql is and that you're excited for building this project i know i'm excited about releasing this series thank you for watching and will see you in the next video cheers all right welcome to the first class of this series uh i decided to call them classes because lesson is way overused someone beat me to that and to be honest it sounds boring i wouldn't use lesson and video it's like everything is a video so i had to stand out okay all right enough of that now that you know what this project is about and what technology that we're going to use and why we're going to use it let's actually start to set up our development environment just to make sure to be on the safe side make sure you have node installed and npm i'm pretty sure you have it if you don't go to nodejs.org and download the latest stable version or the current one to make sure that you have it open up a terminal window and do node v and i have it i have 10 15 3 whatever and do mpmv to make sure that you have npm installed all right other than node we're going to use mongodb atlas which is a cool service by mongodb which lets us create one free cluster just because it's one it doesn't mean we're limited we can have as many databases and collections within that one cluster so yeah we're going to use this so go to mongodb.com and let's go to try free sign up for an account if you don't have one i'll sign up for one here as well so put my email my name misspelled my own name for the password and that's okay we need to agree guys all right let's create an account alright asks us to set up a couple of things i'll say i'm learning mongodb i'll select aws and select the uh the one that's nearest to you i'll select okay i don't have three tier in london so i'll select the ireland one if you're in america you're probably gonna select north virginia or or origin oregon i don't know what that is sorry americans i don't know what that reads like all right so make sure that you select stuff that's just the free tier you can sign up of course for a paid account it's based on uh it's hosted with aws so the performance will be great so cluster name i'm just going to give it cluster 0 that's fine i'll just say create cluster and there we go my cluster has been or is being created um while it creates let's create a user that we can use to connect to this cluster and edit databases and stuff like that so here let's go to security and then go to add new user here i'll give it a username say just classed like this and i'll have it auto generate a password actually i want to see that password because i'm going to need it and let's say add user make sure that your user if you want you can as well customize the role what what type of permissions they get read and write any database is okay for me but if you want to just lock it down to a specific database know that you can do that as well all right so one more thing that we need to do is go to ipwhitelist we need to as well give a certain ip address that we allow that ip address to connect to our database otherwise no machine is able to connect to this database so go to security ipwhitelist and go here add ip address you can add your current machine ip but i find the problem with this is that sometimes your ip changes and you fail to connect to it and you find yourself coming back to this dashboard and adding a new ip so as a just because we're in development i'm gonna click here allow access from anywhere which will allow any machine to connect to this cluster but in production of course that's not a good idea you only want your server to access your database all right so our cluster is still being created so i'll be back once this is done okay so our cluster has now been created uh let's leave it like that for now i'm gonna go to the desktop let's create our project i'm just going to create a folder here i'll call it merge like this and open it using vs code and here i'll open up the terminal window uh when i create uh actually we need to initialize an npm project so let's do npm init i'm just going to do dash y but you can as well write any details that you want i'm just going to leave it right like that i'm going to create two files so here i'll create an index.js and i'll create a dot get ignore file and by the way i'm going to initialize a get repository here and i'm going to have the pro the files for this project are going to be in a repository depending on whether i've finished the whole project and uploaded it on the github or not there will be a link in the description which is with each part of the video each class in its own branch so for example this would be class one and it will have the complete code for this class for this video all right so let me close this actually we need to install some dependencies so here we'll say npm install and we will need apollo server and graphql and mongoose that we will use to connect to our database so let's leave that to install i'll go to the index.js here i'll bring the apollo server so i'll say const apollo server equals require and i'll require apollo server like this which hasn't been installed but that's fine and here the thing is we need to have something called type definitions we'll say const type usually referred to as type defs like this and for this we need uh something called gql we can import that say const gql not from equals require and here we'll get it from something called graphql tag which is one of the the dependencies of apollo server so that's installed with apollo server here we'll say gql um and do backticks like this which is a tag template string and here we will write our types our graphql types and here we will start with type query and by the way to get um to get syntax highlighting inside of this ticks you need to install something called where is it it's right here graphql for vs code so this will have synth will allow you to have syntax highlighting inside of these backticks for graphql all right so here we'll have type query and inside of our types when we have the type query inside of here we will have all of our queries set them up and say what type they return so one of the queries that we're going to have just to test it out i'll call this say hi and it will return so kind of like typescript if you've used we need to say a return type for this it will return a string and we can add an exclamation mark to it that means it's required it has to return a string or we can leave it like that it's always better to have the required fields as required so you know you will have more type safety all right so here we need as well something else called resolvers so we'll say cost resolvers and what resolvers do is for each query or mutation or subscription it has its corresponding resolver so if this query is called say hi it needs a resolver called say hi which processes some sort of logic and then returns what this query returns so here we will say query again because we need to group all of our queries inside the query object and all of our mutations inside the mutation object so here we'll say query and we only have one right now which is this say hi so we can say say hi as a function and here we need to return we can have as well we can have it as an arrow function i think and for this it's simple enough to just have it as an arrow function so here this will just return or actually we don't need to the return keyword here it will just return hello world like this now we need to set up our apollo server actually let me close that here i'll say const server equals new apollo server and this takes two options for now the type definitions so you you see there is an option called typedefs and i can say the typedef is our typedefs but since this is es6 we don't need to do that it infers on its own if the key and the value are the same it will take that so and we have as well the resolvers which are called resolvers so this will do like this all right so now that we have our server instance we can actually start our server so we can say server dot listen and we can leave it like that or we can specify a port i'll specify a port and i'll say 5000 and this returns a promise so we need to say that then and we get a result object and there are a couple of things in this result object but we're not going to need them we only need one just um i'll show you so i'll say console.log once the server starts and i'll do backticks and say server running at and an injector variable here a template variable we say result or res dot url so this will log it to the console so that we can control click it and open our server all right uh like i told you just to show you that apollo server actually if you open your node modules and you go down here you'll see that express is installed it's only running an express server in the back we're not going to write any specific express routes but just to show you that it's actually using express uh in in the you know behind the scenes all right so here we can say node oops node index to run our index file and there we go we get server running at localhost 5000 and if we go to our um to our actually not 8000 we need to go to 5000 localhost 5000 there we go we get our graphql playground here we can say query to test out the query that we created we can do control space and it will tell us all the queries that we have right now which are just the say hi right now and you can also go to the schema and it will tell you what queries and mutations and subscriptions that you have obviously we have the just the one right now and of course you can go and it will tell you that this returns a string and explains what the string is of course you don't need that alright so here we can press play and there we go we get hello world simple as that and if we change it or like we can say hello world with a couple of exclamation marks we save and we stop and run the server again node index and we go back and we do control by the way you can do control enter to execute it and there we go we get this has changed now all right so let's actually connect to our database for this we're gonna need mongoose so here let's say const mongoose equals require mongoose so mongoose is the orm library object relational mapper which lets us interface with the mongodb database that we have so here at the bottom actually we need to connect to the database before we start our server so let's do here mongoose.connect and for us to connect we need an actual connection string and we can get that from our mongodb atlas dashboard so here we go to connect and do i have that password still in the clipboard i do call actually i need that password that i copied from earlier so i'm just going to paste it here and then i'll go back go to connect again and go to connect your application and grab this connection string so click copy here and it's better practice that you put these sensitive key data in their own file so here i'll create the file call it config click on gig config.js and here i'll say module.exports equals and i'll export an object i'll have a key db and this will hold the connection string so i'll do a string and paste that and here instead of this tag password i need my actual password so i'll cut that from there and put it instead of this password so that's my user that's the password that's the cluster the cluster address so we can connect to it and i'll go to the get ignore and of course we need to remove the node modules so that it doesn't track that and we need to remove as well the config.js so that if we push this code to a github repository or any or bitbucket or whatever we don't actually push this because this is sensitive data all right so let's save all files and here in the mongoose connect we need to bring that mongodb connection string so here we'll say const or actually we need to destructure it db equals require so from the same directory config.js like this all right so now that we have that string inside of here we need to say mongodb like that and here we need to pass some an object some options we only need this uh use new url parser otherwise it's going to give us some deprecation warning if we don't and this returns a promise so we need to say dot then and we don't need the result there's nothing there but then we actually do this server.listen so here we need to say return server.listen like this and import 5000 and then we need to as well chain this dot then to the end of this and then everything will run the same but except now it will actually connect to the database let's actually as well log something from here to just show that we've connected to the database successfully so i'll say console.log mongodb connected like this let's save uh stop this development server and say node index again all right so i get an error can't find module config.js oh because here it's an actual file and not a dependency so here i'll say node index again and there we go get no mongodb connected and server running at 5000. of course right now we're not doing anything to the database so we we're just connected without performing any operations all right so what i want to start to do now is to create the database models so that we can use them to interface with the database with so here i'll create a folder called models and inside of here i'll create the user model so user with a capital u dot js and this will hold details about the schema mongodb is schemaless but with mongoose we can specify a schema to have more safety when working with our server code so here i'll bring two things from mongoose so const and this structure model and schema with a capital s like this let's say equals require mongoose here i'll say const user schema equals i'll say new schema and here we'll pass it the fields and our user will have a username which will be unique to each user and here i'll say string now we could say on each entry that it's a string and it's required we could specify it here but because we're using graphql as a middleman we can use graphql itself to say that these fields are required or not so we will handle that on the graphql layer and not the mongoose layer so here we'll have a password for our user it's going to be a string as well we're going to have a username actually we've had the username i'm going to have an email it's going to be a string and a created ad which is i'm going to store it as a string you can store it as a date it doesn't make a difference as long as your code works well with it so here we'll say module.export and we need to export our model so module.exports equals model we need to call the model pass it a name so the name of our model will be user with a capital u and the schema it uses is going to be the user schema all right so now we're going to create another model for the post so we'll say post.js and here we'll bring the same stuff the model and the schema so we can copy that paste it here and we'll say const post schema equals new schema and we'll pass it a couple of things each post will have a body which is going to be a string and we'll have a username so who posted this which is going to be a string as well it's going to be the user's username it will have a created ad which is going to be a string now we can as well specify a default value for the created at here but we will do that on the graphql resolvers i prefer to do that on the graphql resolvers so here each post could have as well an array of comments so here we'll say comments and do like this square brackets as an array and here do curly braces to have an object and each comment will have a body so this will be a string it will have a username so who posted this and this will be a string as well and a created add a string as well so after comments we'll have likes it's going to be an array and we could just have user names but you could um it's better to give them a created at as well so that you can have some you know you can have some analytics on your application and know what's going on and when likes are being submitted and all of that good stuff all right so i'll give it a creator that which is going to be a string and even though that mongodb like i said is a schema less and it's a nosql so there's it's not uh doesn't have relations but the rm itself lets us have relations between our models now we don't have to do this but you could link your data models so i could as well say user here and link it to a specific user this post and then here we can say type this is going to be referred to another schema object so we'll say schema dot types like this dot object id and here we'll say ref and we'll pass it the table or the collection which is users so this allows us to later use mongoose to automatically populate this user field if we want using some mongoose methods all right so here we need to export this so we say module.exports equals model again we give the name of the model which is post and we give the schema which is going to be post schema all right now let's go back to our index let's import our post model so here we'll say const post equals uh why i'm separating these because it's it's just general convention that you keep your relative imports here and then your dependency imports up here so here i'll say require and go to the models folder models oops models slash post so now that we have the model uh what i want to do now is i want to create a query for fetching all the posts from the database i'll actually get rid of this say hi and say get posts here so this get post will get all the posts from our database and it's going to go to the collection posts and bring all the documents from there and return them back to our user but before that actually i want to create a post on our database so that we can fetch because there isn't any right now so let's go to our cluster and let's go to collections so here we have no collection right now let's click on add my own data let's create a database i'll just call this merg and collection we're just going to create the first collection call it posts let's click create let's insert a dummy document here it's going to give an automatic id here i'm going to give it a field body and this will say this is a sample post and i'm gonna give it i'm gonna give it another another field click this uh add this plus button here i'll give it a user name and this will say user click the plus button again and give it a created oops created add just give it some gibberish it's just a string after all we're gonna later have our code create these instead of just create them manually of course actually i'm just going to leave it like that say insert all right now that we have our document let's actually fetch it let's go to our code here our get posts let me close this terminal uh our get posts is going to return a type of uh post so it's going to return an array of posts so we do these square brackets and say post which is a graphql type that we haven't created yet so let's create that we will say our post so type post will have a couple of fields so we'll have an id it's going to be of type id like this and we put an exclamation mark saying that this is required we need to have it you will have a body of type string and it's going to be required you have a created ad a required string as well we'll have a username oops username of type string and you will have actually i'm just going to leave let's forget about comments and likes for now and let's keep it like that and here for our query so we have um get posts let's actually create a resolver for it i'm going to get rid of that say hi we don't need that anymore i'll say get posts and as a function like this and here we need to use our post model to fetch these posts so actually i'm going to use async await syntax so i'll add the keyword async before this function and here i'll say try because the thing is is like maybe your query will never fail but if you don't do this if you if your query fails it might stop your actual server which is not good so here we'll say const posts so let's first choose both we'll say await because this is an async operation post our model dot find and uh so yeah this is it it's don't find if you don't specify any uh condition it's gonna find all of them it's gonna fetch all of them so here we're just going to say return posts and here we'll say catch if we get any error we'll say throw new error and we pass it that error all right this should do let's save all files make sure you save all files and let's stop our server and start it again say node index all right it runs without any errors and we go to our local host 5000 you can press this refresh sometimes you need to refresh it to get the new queries and here it's it's having error because this query doesn't exist anymore so we can use the other query which is get posts and it gives us some intellisense so we need to open these curly braces and specify which fields we want so here if we press control space it tells us that we can get these fields which is exactly like the type that we defined so let's actually get all of these fields so select all of them body what else do we have created add and the username and let's click control enter and we get an empty array all right let's check our code interesting let's check our database oh okay i know why my bad i forgot something so let's go to our config right here it says test but this is actually the database name we need to give the database name uh the db name is merg it's and it's not test and by the way even if you don't have a database on atlas and you just give a name here and you perform persistence like you create a document it's actually going to create this database if you have the permissions for it so i'm going to stop the server and run it again and this time it should work all right let's go and let's run the same query and there we go i get the post that we just created and yeah so the query is working all right so this is it for this video hey welcome back to class number two all right you might have heard the terms ui and ux and those have to be good in your application but have you heard this term called dx let me know in the comments if you have if you haven't dx is developer experience and right now we don't have a really good one because a our type type definitions are all in the index and these will grow bigger and our resolvers as well are an index and each time we have to restart our server we have to do it manually let's fix these before we dive into more functionality so these type devs will be in their own file so here i'll create a folder called graphql and here i'll create a file called type defs dot js so here i'm going to cut these typedefs paste them here we need to bring gql so we're going to say const gql equals require you can import it from apollo server as well because graphql tag is just a subdependency of that as well and we need to export this so we'll say module dot exports equals gql blah blah blah all right so here we need to import those so here we'll say cons type defs equals require and we require what is it graphql slash type defs and the resolvers as well and for the resolvers i'm going to divide them we're going to have the resolvers for posts in their own file and resolvers for users in their own file as well because otherwise we're going to have one massive file with all the resolvers so here i'll create a folder called resolvers i've said resolvers like 10 times resolvers resolves i'll create an index js and i'll come back to this and here i'll create a post dot js and uses js and let's go back to our index so here let's cut this actually let's just cut this or just this query remove this and here in the where is it the post let's say module oops module dot exports equals this object and it's going to have a query actually no we copied the query we just paste that in we need the post module or mod model so we'll say const post equals require uh we go back one level actually we go back two levels to model slash post all right and we need a way to combine all these resolvers so here in the index we want to import that post resolver so we'll say const of course it's the default um export so we can name it anything so we'll call them posts resolvers solvers like this all right here we get them from the same directory posts and uh let's import the uh the user's resolvers as well while we're here resolvers even though it's empty right now so we'll save from users and here we'll uh export this um object so let's say module.exports so this object will combine both of them we'll say query for now we have just query from post resolvers so we'll say we'll do the spread operator posts resolvers dot query and here we'll say mutation actually we don't have any mutations right now we'll just leave it like that and because right now we only have this one query all right so now our type devs are there and um our resolvers are there so we need to import these resolvers so we don't need this post model anymore we can get rid of that and say const resolvers equals require and we say slash graphql slash resolvers because uh it's in the index we don't need to say anything more and the names are still the same so everything should work the same we don't need gql anymore here and let's save everything let's stop the development server and actually now i want to install nodemon you probably have heard of this module or a library if you haven't it's just something that starts a node application and whenever we change any file within this directory it restarts the server for us so i'm going to say mpm oops npm install dash capital d as a so it installs as a dev dependency and say nodemon and here i'll write the script for it so i'll say the script start will say nodemon index.js or we can just say index all right i'll save that i'll wait for it to finish okay now that it's done we can just say npm start all right it started then let's test out our query all right oh it's so instant that i think that it's not actually sending it let me make sure yeah okay it is sending that query all right so everything is working the same now we can uh get going with the rest of the functionality so before implementing the rest of the crud functionalities on our posts like creating posts and editing them or deleting them let's actually create ways for our users to authenticate because the create and delete posts actions or resolvers have to be from protected user or authenticated users so let's actually start with registering users so first thing is we add an actual query for or mutation for that so here we'll say mutation or type mutation because this is making a change in our database so here we'll say register and here we can have input from our users as arguments and take that and do stuff with it in our business logic so here we can say that we can take a username a password a confirm password and email but we can create a type for that as well if we don't want this to be a massive line here so i'll say register input like this of type register uh register oops no register input with a capital r like this and i'll create that type here so i'll say and this is not a type this is an input which is a different type of type which is given as an input to um to a resolver for it to return something for us so here i'll say type register oops register input and this will have the four fields so username type string is going to be required a password type string required again a confirm password because again this is for the register form so we need two uh the confirm passwords as well so and we need the email as well we'll say string and it's required all right and this needs to return something so it will return a type user so let's create this user and it's required so let's say type user and this will have an id of type id and it will have an email type string and by the way even if we specify required it doesn't mean that the user has to get these you know this that means we have to return them from our resolver but the user can still opt out from not getting these so it will return an authentication token and it will return what else the username of the user which is a string and the created at all right so let's actually implement this resolver for this register and here i'll go here actually here let's add a mutation field mutation and this will take from the user's resolver that mutation object which we haven't created yet but we will so let's save this and close it let's go to our users here we'll need our user mongoose model so we say const user equals require and we go back two levels to models models slash user and here we'll say module dot exports and we'll export this object and for now we'll have a mutation and here we need to implement our resolver for the register so we'll say register and now this needs to take some input and we have four things that we can get in our resolver arguments so the first will be parent i'll explain these in a second the second is args arguments the third will be context and the fourth will be info most of the time we'll just be using args but parent is it it gives you the result of what was the input from the last step but here it will be undefined because there is no there was no step before this but in some cases you could have multiple resolvers so data goes from one resolver and then it goes to the other and then it goes to the other and then it gets processed in different ways and then returned to the user but here we don't need it so we can just say um underscore like this so it doesn't you know take up any space so arguments here this is these arguments from here it's this register input so args right now for this resolver will have a register input and inside of that we'll have these four fields and here we have context which i'll explain later you'll see what this does and info just has some general information about um some metadata that we actually almost never need all right so here inside of here we're gonna have a couple of steps what we need to do i'm gonna put a couple of to do's and come back to them so the first thing is we need to validate the data so let's say validate user data and this means like we could have empty fields so we need to make sure to to have server validation in case we have some problems like passwords don't match email already exists etc in our case emails are not um unique but usernames are so we need to check for that so we will do a special check for that because we need to check in our database so here we'll say make sure user doesn't already exist and then the first step will be to the hash the password before we store it in our database of course and create an authentication token so an auth token all right so we will skip the validation for now we'll come back to it later and let's first hash the password and return the data to our user for this we're going to install two packages so i'll say npm install first will be b crypt bcrib js and json web token so bcrypt will help us script the password and json web token will help us encrypt encode some data in a token and return it to our user so here we need to get that data that the user sent we can destructure it here but we can as well do it here i prefer this structuring from here so here we can say curly braces to destructure from the args and we need to further destructure the register input so we'll say register input colon and here we'll get our fields so we'll have our username we have an email the password oops password and the confirm password like this let prettier format it and now we have access to these four fields separately so here we'll say we'll edit the password we'll change the value to it to the hashed password so we'll say await because the bcrypt function the hashing function is actually asynchronous so we need to add as well the async keyword here to the function and we'll say await bcrypt actually we need to import it let's import both right now so we'll say const be crypt equals require b crypt js and we'll get the json web token so we'll say cons jwt equals require json web token all right so here we'll say and weight b crypt dot hash and this will take the password and it will ask us for the number of rounds usually 12 is a good number based on what i've seen so const here we want to form our user object so we'll say const new user equals and we'll call new user our model and we'll pass it the data that we have so the email will be email so we don't need to say email username oops user name and the password as well will be password so we keep these fields like that and we need to have a created at so this will be new date and we need to change the to iso string method to convert it to a string so here we'll say const result equals await a new user dot save to the database and now we need to return this data to the user but before that we need to actually create a token for our user so here we'll say const token token equals jwt dot sign and this will take some data like a payload to put inside the token and we want to encode the id so this will be result.id i want to encode the email this will be result.email and the username as well so res.username and uh here let's um we need to give it a secret and let's actually store this secret in the config file as well so we don't have it in our um in a git repository we don't make a mistake by sharing it with people so i'm going to import it before creating it i'll say const secret key like this equals require we go back two levels to the config file and let's go to that config file and create an entry here and say secret oops secret key equals some very secret key i don't know it doesn't matter this will be used as the um key to encrypt your uh encode your uh token so only our server will be able to decode this stuff here i'll give an array of options and actually here the secret goes here so secret key and the third parameter will be some options and i only need the option of expires in to give it a an expiration time which is going to be 1h for one hour so now let's say return here we want to spread the data of our user so we'll say spread res dot underscore doc where our document is stored i want to give the id because it's not by default in a doc so we'll say res id equals rest dot underscore id and we want to give the token as well so let's save all of this and see if this is working let's go to our app and here we can say mutation we can actually do this in a new tab same mutation and this will be register and we'll take a register input which is going to be this object that will have a username oops use the name of user i have a password of one two three through six a confirmed password of one through six and an email of user email.com let's send this oh actually we need to get some fields back so let's open curly braces and let's let's get all of them so the id email token uh what is it um username and what else the created ad right let's send this there we go we get our id email everything our authentication token and if we look at our database and we refresh we see this user's collection was created and it's got one document which has the details for our user cool so we're now successfully registering users but of course right now if we send this request it will register another user with the same username of course we don't want that so let's actually make make sure that this doesn't happen so let's go to our app right here we need to get a user so um so this is done so we can remove this to do and by the way you can get this to do what is it to do highlight extension to have this um highlight that all right so here we'll say const user construct user equals user dot find oops find one and here we need to pass a filter or a condition and this condition will be the username has to be like the username so we can just pass it like this and of course this is asynchronous so we need to say wait and here we'll say if user so if there is a user this is not going to be null if not it's going to be null so if user then we need to return an error because user already exists uh we can just say throw error but we can as well use specific errors from apollo so we we can import those so we say import i'm going to import the user input error this will become useful when we uh it's because later apollo client will be able to recognize the type of error and handle it differently so here we'll say require apollo server and here we'll throw we'll say throw new oops throw new what is a user bad input or input error and this will say username is taken and actually we're going to pass a payload for with our errors that we will use as well on the client so the payload will have an errors object and inside of here it will have a username key and this will say this username is taken this errors object will be used later on our front end to display these errors on on the form and actually right here this info and context we're not using them so we can just omit them we we still have to say to use the parent one to have the access to the args all right let's save this and let's check on our playground and let's send this request and there we go it says username is taken and if i do another username say john um we can keep everything else the same and we send i actually registered john and if i send again it doesn't register john because that username is taken all right let's now implement some validation as well because right now if we just submit some empty fields it's still gonna register the you know a user with an empty username and all that stuff of course we don't want that so let's go here let's create a folder here called util for utilities and i'm going to create a file inside of it called validate validators oops validators dot js and here i'll import a function so here we'll say module.exports or export rather and here i'll call it validate register oops register input and this will take the four fields so username email password confirm password and that's it and they will um do okay this i said this to be an arrow function so i'll do this and so here we'll do const errors equals an empty object for now and we'll say if username dot trim equals an empty string so if username is empty we'll say errors dot username equals username must not be empty here let's copy this let's do the same thing for email so ctrl d here and say email so if email is empty we'll say email must not must not be empty but as well even if email is not empty we need to check if it's a valid email so here i'll say const regex and i'm gonna match this string to a regular expression that checks that this string is an email i'm going to put this in this description you'll find this in the description so now i'm just going to paste it in and here i'll say if not email dot match and we pass this regex so if it doesn't match this regular expression that means it's not it's not in a format it's not in a pattern of an email so we'll say actually not errors errors dot email equals email must be a valid email address like this we need to check the password so we'll say if password dot trim equals uh empty string actually for password we don't add the trim we can have white spaces as part of the password that's fine and we'll say errors dot password equals um password must not be empty and if the password is not empty we need to make sure that the password is the same as the confirm password so here we'll say else or say else if password does not equal confirm password so we'll say errors dot confirm password equals passwords um must match if you've seen any of my tutorials before for validation this is a pattern that i always use so here i'll say return and we're gonna return the errors and a value for valid and this will be object so this valid if it's true that means there's no errors so we'll say object dot keys and we pass the errors dot length so if the length of object.keys of errors is smaller than one that means there is no errors inside of this so the for the data is valid so let's save this let's go to our users and bring this in so here we'll say const validate what is it register input and this is const equals require and go back two levels to util slash validators and actually we need this structuring because it's not the default export and here under here we'll say const and we'll get the valid and errors from so equals validate uh register input and we want to pass all these fields so here we'll pass them like this and we get that data so we remove the todo's because this is done now and here we'll say if not valid then we want to return these errors that means we have some errors so we'll say throw new user input error and we'll just say errors here this doesn't matter but we want to pass a payload with the object errors so with the name errors and with the value of those errors so here we'll save let's check our app and here we send empty fields and we'll check it says validate register input is not a function i just mis misspelled this register let's try again all right we get errors and we get that the username is not um must not be empty and the password must not be empty so if we put some stuff in the username we'll get the password must not be empty and if we put passwords that don't match we get that they don't match and if we put an email that's not valid we get that email must be valid if we revert that change and we put past passwords that match oops we actually go through cool and we get our user nice let's actually quickly implement the login uh functionality actually for this i'm going to create a validator for login data as well so we'll say module dot exports exports dot validate login input and this will take only two things so username and password and then it will have the same as the other one an empty errors object and we'll say we can just copy this and paste it twice so if username then username must not be empty and then if password and password must not be empty this needs to be capital p and here we'll do the same we return errors and and that and now prettier will format it and let's copy that let's go to our users here we want to import it as well so here we'll say put it next to that and of course before we create our mutation we need to add it to our type definitions so here we'll say login we'll take we don't need the type because it only takes two things so we'll take a username of type string and required and a password of type string and it's required as well and you return a user and that's required let's save let's go back here you know mutation we'll say async login oops login it will take so it will take the parent we don't need that so we'll do that underscore and here we'll destructure username and password and remember because we have them straight away as arguments in the type defs where is it here we don't need to actually just destruct from a type all right so here we'll say const errors and valid equals validate login input and we pass the username and the password actually let's uh let's put a comma here so that squiggly line goes away and here we'll say we need to get this user from the database because if it doesn't exist we need to return an error because we can't log in a new user that doesn't exist so here we'll say const user equals await user dot find one and the condition will be the username must equal the username so just by username like that and here it will say if not user so if this user doesn't exist we need to throw an error but this will be a different error this is not an error for the for the fields themselves this is a another error so i'm going to give it its own name so we'll say errors dot general equals user not found and here i'll say throw new oops throw new what is it user input error and i'll just say wrong wrong threads or credentials oops initials and pass an object with the object errors in it else we want to compare this password to the actual password of the user to make sure that the password is correct so we'll say const match and we'll be we'll say await be crypt we'll use bcrypt again to compare them bcrib dot compare and we're going to compare the password to the password of the user so to user dot password and here it will say if not match if they don't match then we want to return an error again so we'll do actually here it's not wrong credentials here it's user not found user not found we'll copy the same stuff here we'll say here it's actually here that's wrong credentials so wrong credentials like that and if we get here that means the user has successfully logged in i mean the password is correct so let's actually issue a token for them so we'll say const token and uh we need to use the same function from here so let's actually make this into its own function let's copy this code and i'm going to create a function here a helper function will say constor function generate token and you will take a user and you will return the this jws dot sign and you will replace res with user and it will return us a token with the with this data so here let's copy this so here we'll say token equals generate token from res and let's copy this let's go up here do the same here but here we called it user so it will generate token from user and it will return the same data that we returned here so we can just copy this and go up here we will return the token except here the user is called user and not response or result all right let's save this and let's see if our validation is working and our red login resolver is working so here we'll say mutation login and this will take a username which is going to be user and the password which is going to be actually let's leave them empty to test out the validation and here let's uh let's get all fields so email token uh username and created at send okay oh because we we have actually a user that's got um that's got a username and a password of empty strings plus i forgot to throw an error if if the valid is false from the validation not even using that value so here before we find the user we want to say if not valid then here we want to throw the same type of error and here we'll say we'll just say errors and pass this errors here let's save and if i go back here i should get some errors okay the development server didn't start okay it started now send the same query and there we go you get errors user name must not be empty and if i put user here that goes away but we still get password must not be empty and we do one two three four to seven that's the wrong password we'll say wrong credentials and if i put the correct password it should log us in and it does cool all right so we're done with authentication this has been a long one but we've done quite a lot now we've refactored our app our dx developer experience is going to be much much better our application is coming together now in the last video we were able to implement the register and login mutations to register users and log them in and give them authentication tokens that they will use to now post and delete posts from our database which we haven't implemented yet but we will in this video will also implement a query for fetching a single post for the single post page in our front end later but before we do any of that i wanted to address this comment by sherman no rot i hope i didn't butcher the pronunciation of your name he's got the picture of the shaman from hearthstone which is pretty cool all right so he says would be nice to show what the say hi function returns in the front end i know it's useless but it shows us how all wires connect uh it's not useless it's actually pretty important to try to understand things on a lower level and what's actually happening behind the scenes uh i will not demonstrate the say hi because that's too basic i will demonstrate the login mutation and guys don't confuse yourself at the end of the day what graphql is is just we're still sending an http request a post request with somebody the only difference is now that graphql processes this body and re replies um responds in a different manner than traditional rest so what i'm going to do is i'm going to demonstrate that on postman so i'll copy this localhost 5000 paste that here and i'll copy this body and let me make sure to change the post to the request to the post request and the body to raw application json and here i will have a body an object and you will have a key query and by the way this needs to always be query even if it's a mutation this key has to be called query and here we'll have a string and inside of that we'll put our mutation but this is not a multiline string so this needs to be on one line let's put this back on one line like this like this and i got my server running so that should be fine all right so the only difference we need to escape these quotation marks otherwise they just end our string so we put the back um slash on them and here we just send our request and there we go we get a 200 response and we get our token and all the data that we got on the graphql playground the exact same thing guys it's just at the end of the day it's just a post request with a query body with your mutation or query inside it you can as well have another field for variables here and you can put those variables there and that's less confusing but we're not going to use this method because even on the client we're not going to send the requests like this and actually you can do this from the client using any http library like axios or anything but we will use apollo client which makes it even easier to interact with our graphql server all right so that's that let's actually jump into the code of our application and implement some more functionality all right let's go to our type definitions and create three more um queries and mutations here we'll have a query called get post and this will take a post id of type id and that's required and in return it will return a post so this will get only one post and here we will add two more mutations and this will be the create post mutation uh to create a post and this will take only a body of type string and that's required and it will return a post and that's required and here we'll have the delete post it will take a post id of type id and that's required and it will return just a string it doesn't matter what it returns as long as it deletes it successfully all right let's save that and let's go to posts resolvers and here we'll add the other resolver for get post so here we'll say async get post and we'll get the parent and we will get from the argument we'll destructure this um post id and here we'll say try and here we'll say const post equals await post the model dot find by id and we'll pass it the post id and here we need to say if post because we could give it like a wrong id or some or an id of a post that's been deleted and that could be null so we'll say if post so if it exists we just returns it return it so return post else we need to throw new error and say post not found and here if the try catch if the uh there was any error we'll say catch error and we'll say throw oops throw new error with the error object all right let's test that out so the server is already running it's restarting for me i'm going to refresh here just to make sure i get all the new queries so here instead of saying get posts and by the way um the playground inference the query if you omit this if you don't say query it will think that this is a query so we'll say get post and we'll pass it the post id of this one post that we have in our database so pass it here and we will get the id body created at and the username all right let's hit that and we get that post and if i give it a wrong id we get post not found and we get this error all right cool so that's working let's work on the create post um resolver so we go to users and here in mutation we go down here is that yeah that's the register so here we'll say async create post or actually let's put this in the um in the posts um resolvers it doesn't make a difference but since this has a lot of code already i'll put it here so yeah so that's not there we go here and we say underneath this query we'll say mutation and we'll say async create post and this will take the parent and it will take so we will destructure the body and inside of here what we need to do is um the way our protected resolver is going to work is that our user will log in and get an authentication token and then they need to put it in an authorization header and send that header with the request and we need to get that token and then decode it and get information from it make sure that the user is authenticated and then create a post we don't want anyone creating a post and i see a lot of people making the mistake and adding this authentication middleware as a middleware for express itself that means that we'll run each on each request even on nonprotected routes the way we're going to do it here we're going to have the third argument in the apollo server which is the context here we'll say context and this will take a call back and here we get anything that's passed from from before this poll server and we get the request and the response from express so we need to say uh request actually we get we get them in an object so here we'll say request we destructure the request and we just want to forward that request so what this will do it will take that request body and we'll forward it to the context and now we can access the request body in our context so if we go back to posts now if we use this third argument context inside this context we will have the request body so we can access the headers and determine that this user is authenticated and we can do all of that inside of here but since we will use this middleware or helper function in multiple routes so we need to put it in its own function so here in the util i'm going to create a new file call it check auth like this and here we will need a json web token to decode the token that we got so we'll say jwt equals require json web token and here we'll say module dot exports equals this function that will take the context and do the following and we also need the secret that we have because we will use that as well to verify the tokens because we used it to encode the tokens so here we'll say const and this structure the secret key uh and this will be equal require and from the same level actually not from the sale level it's back one level config all right so here we need to get this header so we will say const auth header equals because at the end of the day this context will have a context will have an object and amongst many things it will have headers inside of it and inside the headers we need to get to this authorization header and here we'll say the auth header equals context dot actually.request dot headers dot authorization so here we need to check for it because maybe someone didn't send this header so we'll say if auth header now if we have it then we need to get the token from it and a convention when working with authorization tokens that we send this header with a value of bearer space and then we put the token here so what we need to say here we need to get that token itself and we say cons token equals auth header dot split and we split this by uh bearer space meaning it will have two strings the first one is bearer space and the second is the actual token so we need to get the second so we need to get index one because a split returns an array of couple of strings so here we'll say if token because this can as well still not exist so we'll say if token now we need to verify the token and make sure that this we issued this token and is still valid and not expired so we'll say try and because this could fail and we'll say const user equals jwt dot yeah verify and we pass it the token and we pass it our secret key and now we'll say return user so this if this fails it will go to the catch block and we'll say catch error and here we can we can throw any type of error but let's be more specific and let's uh import this type of error we'll say const and we need to import authentication error from not from equals require require apollo server like this and now if we fail in verifying that we want to throw that so we throw throw new authentication error and we will say invalid slash expired token because if this fails it will come here that means it's either invalid or expired or blacklisted as well but we're not doing that in our application now after these if statements we need to throw some errors as well because if this if statements failed um if these if uh conditions failed um that means we don't we either don't have a token or we don't have an auth header so we need to as well tell the user that why this failed so we'll say here throw new error and this will say authentication token must be well actually not provided here was provided but maybe it was the wrong format so we'll say must be and we escape a thing quotation mark and we'll say like this bearer space and token formatted like that and then we will close this and here we need to throw another error if we that means if we didn't get an auth header we'll say let's just copy this and we'll say uh authentication token must be we'll say provided provided or actually authentication header because here if we get here that means we didn't have the header itself all right let's save all of this and let's go to posts and actually get this check auth function so we'll say const check auth equals require oops require and we go back what is it two levels yeah two levels into util slash check dash auth like this now here we will use the context to get the user so we'll say const user equals check auth and we pass it the context now because the way we structured it here that if we don't have a headache throws an error here if the the token is not valid it throws an error here so if there's anything wrong with the token an error will be thrown here otherwise we will get a user and this will return a user which means if we get to this block of code right here after this that means there was no errors that means there is a user definitely here that means we can proceed with this action and allow it and actually create this post so we'll say const new post equals new post we have yeah we have the model we have the model here so we'll say new post and we'll pass it the body like that because we already destructed it from here and we need to pass it the user remember in our post model uh where is it right here uh right here the post we gave it this user we can still attach that id and it will auto populate it if we want to get the user from the post later so we'll say user is user dot id oops id i don't know why it's auto correcting me and here we'll say username is user.username like that and we need to give a created add which is new date to iso string like that now we need to save this post so we'll say const post equals new post dot save and actually i forgot to put a wait because this is asynchronous and here we need to just return this post to return post all right let's see if all of this works and we're checking the uh the thing let's do here a console log just to make sure that we have our user so we console.log user and let's test this out all right so we go here and let's open a new tab and here i'll say mutation create post i want to pass it a body and this body will say this is another post and let's get from it all the fields so create that and the username all right this should fail and tell us that we need an authentication token but it doesn't it says cannot return oh because we didn't add this mutation so here in the index uh we want to say as well that we want the mutations from post resolvers oops what is the what is that resolvers.mutation all right let's save make sure that it started it has let's go here let's send that cool it says authentication header must be provided that's actually a wrong authorization header let me change that so authentication token that's fine but here it's an authorization header although which is actually a misnomer it should be authentication but whatever so if we send okay let's send again it's still restarting the server cool authorization header must be provided so let's provide one so if we just uh slide this up like extend this we can here add some http headers so here we say authorization and here let's put an empty string and see what happens okay i see even an empty string is counted as that it's it's not truthy so let's put something some gibberish and then now it says that it must be bearer space token all right let's put bearer space and then some gibberish that's not actually a valid token it will say invalid slash expired token now let's actually put in a real token so here let's log in again let's copy this token go to create post and here bearer space and we paste that and now let's run it and there we go we get this and the post was created and the username was assigned that user that we logged in with and if we go to get post here let's change this into get posts and get all of them okay let me remove that actually and there we go we get this um another post has been sent and it's added to our database there's one little problem here is that the latest post is big is coming last in the array but we don't want that we want the latest posts to be first and on the array to show them on our website so we can just sort the result from get posts so let's go to the post resolvers and here in gut posts we just need to chain another method here called uh sort and the sort will take a condition and we will sort by created at and to tell mongoose that we want to in descending order we just say 1 let's save make sure that it's restarted i think it's restarted mode nodemon is behaving a bit weird lately all right there we go so another another post now it's first instead of being last all right let's now implement the delete post let's go here let's go down here in mutation we add another one we'll say async delete post and this will take um the parent and it will take the structure the post id from the arguments and of course we need the context as well and here we'll do the same we'll say const user equals check auth and we pass it the context and now even if we have the user this isn't enough because we need to make sure that this user is the creator of the post they want to delete we don't want any user to delete any post they're only allowed to delete their own posts so here we'll simply say if user dot username equals the post dot actually we need to get the post first and we need to wrap everything in a try block so we'll say try const post we need to find that post first is a weight equals a weight post dot find by id post id and then here we put the if statement and we'll say if user the username is the same as post.username that means this is the owner of the post so we just await post dot delete ops delete i hate the word delete here we just after it's deleted we just return the string post deleted successfully and then here else if it's not that means we're like yo this is not your post you can't delete it so we say throw new did we bring that i want to bring authentication error here as well so it's got to check also get the same one from a pulse server copy it and actually this is from the library so i'll put it up there and we'll say throw new authentication error and this will say action not allowed and we need to handle as well if this try block fails so we'll say catch error and we'll say throw oops throw new error error like that all right let's save let's look at our post so we have two posts by user i actually added the two new users let's try to log in with a different user so i'll log in with jane and she has the same password because why not and let's go here and we can actually have multiple mutations so i'll call this create post i mean multiple operations on the same tab so here i'll have the other mutation and you can name it whatever you want i'll name this as well the same delete post and this will be the mutation delete post and it will take a post id and we'll give it the post id of where is it this one that was created by user so we'll try to delete that but the thing is let's try to delete it with the token of jane so this shouldn't be allowed okay so here i will paste that token from jane and hit play and hit the delete post and it says authentication or error action not allowed cool so j can't delete users post but if i go here and press ctrl z it will go back to the token from user and uh or actually let's get a new token because why not so here we'll say user and we'll get that token from user and then go here and bearer and paste that token and press play delete post there we go post deleted successfully and if we fetch all posts again we find that that post has actually been deleted hello class nice to see you again i have missed you have you missed me well actually no wait wait a second maybe you've been doing like the classes in a row and you've done you've just finished class three and you're now here and you're like wait a second i'm just listening to your voice like five minutes ago anyway for me it's been like 24 hours ago since i recorded the last video so i definitely have missed you all right enough of that let's actually crack into this video where we will implement holy implement yes comments and likes all right we'll implement ways of submitting comments and likes to our posts because right now actually if we look at our database right here this is the only post i have and if you look there is a comment and likes array but they're empty but and we can't fetch them with graphql we can't edit them so let's actually fix that okay let's go to vs code or whatever editor you're using i'm going to go to the type definitions and i'm going to close this terminal and keep the server running here in post i'm going to add the arrays for likes and comments so here i'm going to say comments and this will be an array so we do square brackets and we say this is a different type that we'll create and here we'll put the exclamation mark and you can as well put an exclamation mark inside which means this array has to contain at least one element we rarely ever do that there are some use cases but we're not going to do that now we're only going to require that we return an array even if it's an empty array that's fine all right let's say likes as well here will return an array of likes so like and then it's required so let's create these types so here we have the oops didn't mean to do that all right here we say type comment and uh well let's look at our post so yeah this will have a um a body a created ad and a username so here we'll of course we will have an id as well so we'll do id and that's required enough type id we'll have a created add and that's a string and it's required we'll have a username a required string and the body of the comment and that's as well a required string let's do the uh type like this will hold an id and a created ad which is a string and what else yeah username of who actually liked this so this will be a string all right so here we're going to add our mutations to create and delete a comment and to like a post so here we'll say create comment and this will take two things the post id so which post do you want to comment on or does the user want to comment on actually that's a lowercase d and this is a string and that's required and the body of the comment so body and that's a string as well and we will return that post that's been commented on and here we'll say delete comment as well to delete a comment and does this take yeah it will take a post id so post id um id and comment id you can take just the comment id but uh taking the post id provides us the ability to check whether that post is still up or not uh here we'll say post because usually you might have a mechanism where if a post is deleted you delete all the comments and then if you look for a comment that doesn't exist anymore it might cause a problem all right here we'll add another one which is like post so it will take the id and that's it just the id of the post oops id and that's required and it will return that post and notice we don't have a an unlike mutation because this like post will work as a toggle so if we've liked that post we will unlike it and if we haven't liked it we will uh like it from zero from i mean from scratch whatever i don't know what i was going with that all right let's go to posts so here at the bottom we'll add this uh these mutations or actually post is getting a bit massive we have no obligation to put them in like in a specific file we can even create as many files as we want i'll create another one actually for comments here i'll say comments.js and here i'll say what do we need we need the post model so here we will say require and we go back to levels and we go to models slash post and here we'll say module dot exports and here we'll have a mutation key and before i forget uh let's add that to our index so here we'll say we'll import that file i'll just copy this and paste it and replace users with comments and here we'll add that mutation field from the comments resolvers so we'll say comments resolvers dot mutation like this all right let's go back here we have the create comment so we'll say async create create and by the way guys you can have it as error functions it doesn't make a difference i'll use that syntax for now just to show you that you can do that as well so we'll say create comment and that will be an async function and you will take the parent so actually we don't need it so we can just say uh like this just an underscore and we will destructure from the arguments the two things the post id and the body and of course we'll need the context to make sure that our user has actually logged in so here we'll do that arrow and here we need to get our user so we'll say const user equals check auth and he will pass it the context and of course when we get here if you know by now that that means we're logged in so we'll do some basic validation and we'll say if body dot trim equals an empty string that means someone tried to submit an empty um comment so we'll throw an error so we'll say throw not just any error we'll get the user input error so here we'll say const user input error equals require apollo server like this all right so here we'll throw that error through new user input error and it will say empty comment and i'll attach a payload of errors to it with just one error i'm not actually sure i'm gonna use these in the on the client but i'm gonna send this payload anyway uh here we'll say comment body must must not be empty almost said must be empty which is ridiculous so here after the if statement so if it's not empty then let's get this post so we'll say const post equals post dot find by id and we pass it the post id and here we'll say if post oops if post so because it could be null actually i forgot to add a weight here this is a weight because it's asynchronous and here we'll say if post then we want to say post because mongoose turns our um data models into like just json objects and i mean just like normal javascript objects so i can just access the comments array like this post.comments which is pretty cool and here we'll add it to it but we want to add it to the top because it's the newest one so use the unshift method and say unshift and we want to add a body of body so we can just say that a username of user actually we're gonna need just the username from user so we can destructure that and say username like this and here we can just say username cool all right here we'll say created at and this will be a new date to iso string like this all right now we need to save the post so here we'll say await post dot save and we need to return it so we'll return this post so else if the post doesn't exist then we throw uh what is this this is gonna be um is this gonna be an a user input error yeah it is a user input error because yeah because they try to access um an id that doesn't exist and usually our client shouldn't expose an id that doesn't exist and we say post not found and uh yeah that's it for the create comment all right let's save that let's save the index make sure our server has restarted successfully because nodemon has been a bit weird i don't know why it's getting stuck on this restarting all right i had to restart node 1 i don't know why it's doing that all right let's refresh here and let's log in to get a new token because the other token is probably expired it's been 24 hours so here we'll go to so here we'll get posts to make sure that we have this post actually we can do a multiple operations here so they will call this um we'll just call this posts and here we'll do our create comment mutation here we'll say mutation uh comment it doesn't matter what you name it here you just need to say here create comment not post comment and this takes a post id and before because i have the token on the clipboard i want to put the token first here so i'll say authorization as bearer space and paste that token and here i'm going to copy this id and paste it here and i'll do body and by the way this uh this comma is not necessary you can omit it or you can leave it depends on your preference and the body will be new comment on only post i don't know and we will get a post back so we can just get the id the body and let's actually get the comments because now we can have that array the id the created ad the username and the body let's uh hit control enter check auth is not defined oh yeah i didn't import it so here we want to say here const check auth equals require and we want to go back two levels to util slash check auth all right let's save come on node one you can do it yes thank you all right here we can um say comment there we go we get our data and we get the comment and now if we even fetch posts actually we need to add comments i mean it's got it just to make sure with the other um with the other query so we fetch the post there we go our post has a comment and we can even submit another one and uh say another one and say comment and there we go we got our post with two comments sweet let's now um create the delete comment uh what is it resolver yeah resolver here we'll say async i'm gonna close the terminal uh delete com i hate delete comment and of course this will take the parent and the post id and comment id and we'll take the context and here we'll say const username will this destructure the username check auth and we pass it the context get the user from the token find the post oops const post equals await post to the model dot find by id and we pass it the post id and we need to say if post say uh here what we need to do is what do we do oh yeah okay we get the index of um so we find that comment we find the index of that comment in the array of comments and then we delete that at that index and here we'll say const what is a comma let's call it comment index in index equals post dot comments dot find index and of comment i'll say c where comment dot id equals this comment id that we passed to our to our function and here we'll say so because we need to check because maybe some other user is trying to delete some other user's comments so we will say if post dot comments add that index so comment index index like this dot username equals username that we got from this token that means this is the owner of the comment so we can delete it so we'll say post dot comments dot remove oh i mean splice there is no such thing as remove i just made that up so splice comment we start at the comment index and we remove just one and here of course we need to save we'll say await post dot save and did i say oh wait here yeah i did okay we'll se and then we'll return that post else if it's not to the owner of the post this is a different person we'll throw throw new authentication authentication we haven't imported that error and we'll say action not allowed and you notice sometimes we're throwing an error without throwing a um without sending a payload with errors because we don't need to show this on the client because there will never be a delete button for a user that doesn't own that uh that comment this is just a safety check instead of safety net instead of like in case a user actually tries to delete a comment that that's not theirs using some sort of like code all right so here so this is if the post exists so we need to chain an else on this if it doesn't exist we want to throw a new user input error and we'll say post not found sweet let's test this actually uh we need to import this authentication error here actually it needs to be in alphabetical order let's save all right cool nodemon was nice this time all right so let's actually create a new window i'm just going to copy these headers from here create a new tab and paste the same headers here and here we'll say delete actually mutation delete comment and the post id will be let's uh this well we all we have only one post here so post id is this and i can put this on a different line and say comment id is let's delete the first comment so we leave the another one so we'll take this id and then we put the id here and we get the post back so we can say id of the post and then let's just get comments and id and username and body all right let's send this oh it get it gets the post back yeah okay it's working all right so we get the post back when we delete the comment and if we try to delete the other comments so let's take this id and we put it here and we send it and there we go our comments are empty so we removed all the comments that we just posted all right let's now create a way to um get the likes and actually add a like to um to our posts so here in i'm gonna add it to the posts here at the bottom i'll say async like post and this will take so the usual parent which is going to be just an underscore uh post id and the context it's getting a bit repetitive but sometimes it happens like this with crud that you have to write the same code for different resources so here we'll say check auth and we pass context and we need to find the post so we'll say const post equals weight post dot find by id and we pass it the post id like this and of course we need to say if post and here we'll say uh what we need to do is we need to find this like we need to make sure that it exists so we'll say if because we could later delete it you know so what we need to do we'll say if post dot likes dot find a like where the like dot id equals or is it actually no the like username because we don't have access to the id we have access to the username because a user can have only one like on a post so if they have this like already we just delete it so we'll say like this because username so this is this returns a um an object right and if it doesn't find it it will return undefined so it will be not truthy so we'll say if and if this returns if it's true if the returns alike that means we've already liked let's put a comment here we'll say post already liked unlike it and here else that means we don't have a like so it's not liked we'll say not liked uh like post so here we want to unlike it we want to remove that like so we'll say post likes like this equals post dot likes dot filter like where like dot username equal uh does not equal the username so we leave at all of them uh all the ones that don't have the same username as our user so we just remove that one with this username all right and here we need to say await post dot save and then here we need to add a like so here we'll say post dot likes dot push it doesn't matter if you add it to the end or to the beginning because uh we're not gonna show likes based on created that just going to show a number of them so we'll say the username is username and it needs a created ad and that's new date dot 2 iso string and yeah that's it just the username and the date and here we'll say await post or actually no uh this await post because we're editing the post no matter what so this await post can be after this if statement so after we're done we either we remove the like or we added the like now here we will say await post dot save and we'll say return post like this and this is an if else if the post doesn't exist we will say we're not in a block we'll just say like this throw new user input what is this user input error and this will say post not found oh because it's not imported that's why it it's finished with that user input error sweet i think we're done here so this works for both liking and disliking or unlike and rather so and we are returning the likes because we added that to our type so let's actually test this so let's go here and instead of delete comment we will have a different mutation here we'll say like post did our server restart yes thank you nodemon i feel like i should be grateful each time all right here is a post id and it will be this id right here and we'll pass it like this and we want to get the id or just the body and username username i want to get the likes array and from the likes i'm going to get the id and the username so let's submit this cool so we get a like and if we look here just to make sure we fetch posts actually let's add likes here likes and we get the id they create that or just like id and username cool so you get a like and here if i press again that like is gone and if i press it's back i pressed it's gone cool we just uh did the two functionalities in one route or one operation one mutation whatever all right so this is it for this video or actually no let me add because there's some cool thing i want to show you and i don't want to make a video just for that i want to show you how to do a subscription now we're not going to implement it in our front end you can if you want but i'm just going to show you how subscriptions work because they're pretty cool so i'll say type subscription generally people don't use them when like getting new posts or new uh comments and stuff like this because if your app is massive it will be too much traffic and too much bandwidth people use them for polling and for chat apps and whatever i might do like if you want me to do some sort of like pulling up or like chat up let me know in the comments all right here i'll add a subscription and let's call this new post i want the subscription to each time when a new post is created to like um show whoever is subscribed to this that look this is the new post that's been subscribe created all right so in our index we're gonna need something else from apollo server called pub sub which means publish subscribe or publish a subscribe it's a pattern anyway here we'll say const pub sub not like this pub sub like this we'll say new instantiate a an instance of this and we just pass it to our context so we can use it in uh in our resolvers let's save this where do we go let's go to posts yeah posts here um here i want to add so we got to this mutation it ends like here and here we'll say subscription and here we'll have our subscription new post and this will have an object inside of there will have a subscribe uh like this oops what is that subscribe and the inside of here will return or actually let's do it as an arrow function because it will be like shorter the syntax will be shorter so here we'll do like this and it will take the parent and our we have no arguments so we can omit this as well so we can do two underscores and here we need to get the um pub sub pub sub like this here we'll say we'll return pub sub dot async iterator iterator and here let's call this uh i'll just call it a new post new post uh it's the convention to have like all caps like this as a it's a an event type and it's like a type of kind of received type thing i don't know it's just a convention all right so here we want to as well publish because this is the subscription we want as well the publication from where we create a post so right here after the post has been created and saved we're gonna say we have access to our context which holds the pub sub and we'll say context dot pub sub dot what is it publish yes publish publish and we publish a name a trigger name of the same name that we had earlier so new underscore post and the payload will have new post with the value of that post that's been created this one right here all right let's save okay we'll save subscription and our subscription is new post and we'll get the id the body the creator that username comments everything everything we just get the created out of the comments and likes because we don't have even comments right now on likes okay subscription field must return async iterable received undefined ready where are we returns async iterate oh okay my bad here we need to actually add a field subscription subscription and here we want to spread the did i put it in post here i put it in post posts resolvers sorry guys it's the end of the day and i'm a bit tired so these mistakes happen all right let's make sure all right there's something wrong i've crashed post resolver oh it's resolvers save come on oh no demand is being a bit annoying so i had to restart okay there's another problem throw new there's something learning defining resolvers feeling not in schema oh this is not mutation this is subscription subscription like this all right another mistake all right so npm start cool server is running this time it should work we start it and there we go it starts to listen i want the animation to happen so i'm just going to do it on a new tab so do like this there we go so we get this cool animation of the spin and let's try to now create another post so he will say a post for subscribers by the way subscribe if you haven't subscribed yet to the channel nice segue alright so let's send this create post damn it invalid token let's get a valid token let's go here let's add this all right let's send create post and if we go here we see that we got a post here and if we create another one number two we send it create post there we go we received another post you see like we're like now listening using websockets in the background and actively listening to the new post event and each time it publishes a new post we actually get it we can listen on the client and we will get this these posts in real time as they've been posted all right i want to show you one more thing that is kind of useful a lot of the times this time it's not that useful but it's a cool trick that you can do all right so here i could add it here actually no i can't add it here i'm going to add it here what i want to do is on the client later we're going to need a number for the number of likes and number of comments and we can calculate that on our client by just saying the array of comments dot length but we can as well calculate that on the server and send it to the client to minimize the amount of computation that's happening on the client so here we can add two fields say like count like count and that's a number it's required and we have comment count as i make a mistake actually no in a graphql it's not a number it's an int so here it's an int as well and it's required as well and we can get these uh we can actually compute these and send them not through the mutation itself but we can have like um i think they're called modifiers i'm not sure what they're called i call them modifiers so here we can say if we have a name of the type so if we say post and then we do stuff here to change any of the fields each time any mutation or query of subscription that returns a post it will go through this post modifier and apply these modifications which is pretty cool so we can do all sorts of um you know scenarios here so here we will have that field name we'll say like count and we will say that it's an arrow function and it will take the parent we'll need the parent here actually we'll need just the parent because the parent holds the data that comes from the previous step actually let me show you i'll put it as a normal function so like count like this and um oh it takes parent i'm going to console log the parent just to show you clg parent and here what we want to do we want to say return we want to return a value for this like count so what we will return parent will hold that data for the post and it will hold the likes in it so we'll say return parent.likes.length and we will do the same for comment count and for comment count i'm just gonna return the value and not console.log anything because we'll see it from the likes one so i'll say parent and here we'll say no return just parent dot comments comments dot length like this all right let's save this make sure our server starts okay it doesn't oh yeah no no column um no semicolon needed there okay let me start it again okay let's maximize our terminal and let's go here well what happened here let's what what happened to my tabs that's strange and the font size is tiny all right that was definitely not planned so let me put back the font size to 24. and let's go here we'll put the query get posts and here i'll get id body and we'll get the like count and the comment count all right we'll send and there we go we get 0 0 because these don't have any comments on them or actually you know what let's create them so let's say mutation create post and here we'll have a body actually no not create post create comment and we'll have a post id of this post right here and we will have a body that will say comment and we'll just get the id back and we need to actually log in so you say mutation login username is user and password is one through six and get just the token we send this we get the token we go here we add an authorization header with the value bearer space our token and we send our thing and we get that and we send our query here we get that the co we have one comment and the comment count is one cool so it's actually calculating them and if we look this is the value of what parent returns it's actually the post that's been sent so here that's the post these are all the posts so that's the first post and it's got that so this is what the parent is is the data that comes from get posts and if you send any type of query or mutation that returns a post it will have to go through this modifier and add these properties all right let's set this to be a an arrow function to just make it smaller right here we'll do like this remove that remove this remove the return and just do that okay that's fine all right so we are done with the back end i think i think if there's any modification i'll let you know i think yeah this is it for the back end yeah so we're done for the server code i want to tell you that i made one little change in the post resolvers right here in the create post i just added this if statement right here if the body of the post is empty it throws an error because this is a valid a server validation thing that i forgot to do in the series you just add this one if statement all right let's open up our code base using vs code and so here i want to create a folder and put our react app in there but we don't need to do that because we're going to use the create react app to tool and it's going to do that for us so here we'll say npx create react app i'll call this folder client because that's the the client application and the rest of the code on this folder is the server application all right so i'll let that install and i'll be back once it's done all right now that it's done installing let's open up this client folder and uh here i'll clean a couple of things so we'll not be using this logo so i'll delete it we will not be using this index css so i'll delete that i'll delete everything like remove everything in the app css because we're going to be using semantic ui i'll delete this app test file and actually in the public i'm gonna change the title of the app i decided to call this hi world because it's a social media app so i'll call this um hi hi world like this and save that let's go back to the source folder and here in the app i'm going to delete everything inside of here i'll just have a div for now and i'll have a header one says hi on hi world like this of course we'll remove the import to logo because that doesn't exist anymore and yeah let's save all of this and let's see let's start our server so here we'll say npm start and in a different terminal we'll go to the um we'll cd into the client folder and we'll say npm start so now we started the server now we'll start the client okay it says can't resolve index css yes because something is important yeah it's the index js is importing that and we deleted it all right so the app has started and cool we get high world and uh hopefully no errors probably none yes no errors and if we go back to our app i notice if each time i save both the development server of the server and the client are restarting because of nodemon on the server so let's go here and in the package json we don't want nodemon right now because we're not making any changes on the server on the server code so we'll add another script here and say serve and here we'll say just node index and of course now if we run serve let's say npm run serve now each time we make any changes it will not uh retrigger that run in restart the server the uh the server server not the client server all right so should be fine now and here in the app what we need to do right now we want to set up our apollo client our apollo provider and provide our apollo client to our application so that we will be able to connect to our graphql server we could do it in the app.js but i would rather have it in a separate component or and here we'll say we'll call it apollo provider js and actually we need to install a couple of dependencies to get that so here um in a terminal window let's say i'll actually make sure you're in the client folder so cd client and here in the client folder i'm going to say npm install we're going to install a couple of things first is the apollo slash react hooks did i mention we're going to be using only hooks here if you're not familiar with hooks i have a series on hooks on this channel if you want to dive deeper into that so we're going to install apollo cache in memory what we need let me look so we need apollo link http link http and we need apollo client of course so apollo client all right that's it for now let them install and let's go to the provider here this provider is basically going to export a jsx element so we need uh react so we'll say import react from react uh here what we're going to export is a apollo provider that wraps the application the the entire app so we need to import the app into this provider so here we'll say import app from the same directory slash app like this and we need apollo client so we say import apollo client from apollo dash client here we have we import the uh the inmemory the cache in memory um libraries so here we'll say import and what is it called in memory caches in memory cache from apollo cache in memory and usually you'll install a library called apollo boost and it does all of this for you but i've had issues with apollo boost when it comes to authentication tokens and saving them and setting a middleware for checking a token so i'm gonna do the setup myself um here we'll say import it's just a tiny setup just one file that you write and you'll never touch again so here we'll say create http link we need um we need this from um let me type this we need it from apollo link http so here we'll say from apollo link http we're importing a bunch of things this is the last one this is apollo provider so this is the jsx element that will provide the client to our app and this is going to come from apollo at apollo slash react hooks all right so here we'll say const http link we'll just instantiate or actually we need to call that so we'll say create http link and here we'll pass it some options we just need the uri for now and this is going to be pointing to our graphql server so what is the endpoint for our server which is just local host 5000 so we'll say http and here we'll say local host 5000 of course this in production this will be different so bear in mind here we'll create our client so say const client equals new apollo client and here we'll pass a link which is this http link that we created and we'll pass a cache value that will store any um cached data and here we'll just instantiate the inmemory cache so you say in new in memory cache like this call it like that and here we just need to export this provider so we say export default and we'll export apollo provider and this takes a client which is going to be the client that created right here and this will wrap the app so we need to put the app here and now we need to use this in the index js so here we'll say import what is the apollo provider provider from uh same directory apollo provider and here instead of rendering the app we just passed this apollo provider so like this so we don't need the app and actually we don't need any jsx elements here so we don't need react so we can just do that uh let's save everything let's make sure that our app is still running okay so import error apollo provider not exported is it not exported oh here it's apollo provider like that and we need to put it here as well pull up provider let's save all right it runs just fine and if we go to our app it says hi world of course there's no difference but uh by the way did i mention um you need to install apollo dev tools for chrome you can say apollo dev tools chrome and go here and just add it to your uh chrome as an extension and if you're using any other browser maybe you'll find it maybe not i don't know so you just add it to your browser and here if i click f12 actually let me refresh this click f12 uh where is the apollo did i not add it okay for some reason i had to close the dev tools and open them again all right so here in apollo we get this graphq graphical tool the same tool that we get on our server endpoint and here if we say query say get there we go we're getting our queries right here that means our apollo provider in our app is actually accessing the server and if we say get posts i want to get the id and get the body and click control enter and there we go we're actually fetching the posts from our database and uh apollo provider is connected to our server and everything is working fine well hello class and welcome to class 2 on the channel clast so many classes and we're not even using classbased component how did that come to be all right so enough of the nuances so now that we've hooked up our application with uh apollo and by hooked up our application with apollo i mean we set up our apollo provider and we connected our apollo client to our apollo server apollo apollo so before we use any um graphql queries and mutations and fetch any data and show it we need to set up as um our application because we need to set up some basic markup because this doesn't look good alright so uh what i want to focus on this video is to introduce the router and create different pages mainly we're going to create the home and login page page login and register page all right i'm gonna stop talking and start writing code okay so make sure you got your server running at port 5000 and the client running and let's open up a new tab and here let's install uh react router dom so let's say npm install and react uh router and dom and since we're installing stuff i just want to quick say quickly we're gonna be using like i said semantic ui uh it's really cool you can actually install it through the um command line and kind of customize a couple of things but i'm just gonna install it just install the css and install this react integration called semantic ui react very creative and so what we're going to do is we're just okay let's go to get started we're just going to run this yarn add or npm install semantic ui react and we need to install the css as well so we're going to say install semantic ui css so we're going to add those two so here we'll say semantic ui css and semantic ui react let those install and uh here in the app uh js file uh let's bring the router and route so here we'll say import browser router i'm gonna give it an lds router because it makes more sense i'm pretty sure one day they'll change it to just router all right so here we'll say react from react router dom and uh here above our css we want to bring semantic ui um just in case you don't know the reason why because we if we want to change anything uh we will change it through our custom css and the fact that we have it after it's going to override the default styles from semantic ui aka cascading so semantic ui css slash semantic dot min dot css like this so now the css we we have it in our app and we can use the semantic ui react and just use those react components um so here actually here instead of this div we're going to put the router so we'll say router and inside of here we'll have so we'll have our routes so first route will be the home route so we'll say exact path and the path will be to slash component component will be home by the way i just want to say quickly i'm not going to be explaining the kind of the basics of react because this is more of a apollo um course if you want to know the basics to react you can do my 0 to 60 tutorial or you can do anyone else's as long as you learn the basics all right so here's another route is the login route so it will say exact path equals oh not equals actually oh yeah equals i'm confusing myself guys all right so register or login and component will be login of course we'll create these components in a second let's just copy this click here and do register this will be capital r so here it will create a um oh i've already created the folder components but i'll create another folder called pages and inside of here we'll have login.js we'll have home.js and we'll have a register.js here we'll say rfc why is it not working or rcf yeah rcf all right so here we'll say at the bottom export default register and this by the way even though they're functions but you have to have them pascal cased meaning the first letter has to be capital some reason it doesn't work if it's not um all right so here we'll just say we'll just have a header one for now saying register page save let's copy all of this go to the home and just ctrl d here and say home so home page and these are rename to home let's go to the login as well paste this and just say log in here just to have a couple of different pages for now we'll populate them later let's close them let's import them so here we'll say import we'll have home from same directory pages pages slash home and we can just copy this two more times so here we'll say login and here we'll say register all right one thing that i want to do is i want to have a navbar at the top and we can go here in react semantic ui.com and go to right here menu they call it menu and i want to get this one oh no not this one this one this one that looks like tabs looks cool let's actually just copy this entire component just copy that and let's go to our app and i'm going to create a component here call it menu bar they call it menu so i'm going to call it menu why not i'm going to close this terminal so here um this is a classbased component of course we need to change that because we only want functional components so here we'll say function what is it menu bar and i'm going to export it export default menu bar and here instead of component we're going to get use state and right here instead of state like this we will say const active item and set active item equals use state and this will start with an empty string and the way these works uh work is that each menu item you have here has a name and if the active property is true that means it's going to be highlighted that means we're active on this page right now and this name will be rendered as the name of the tab with the first letter capitalized so if this returns true that means if the active item right here has the value of messages the tab messages will be highlighted or the nav link will be highlighted so each time we click one we want to change the active item name to that to the name of that menu item if that makes sense i think it does all right so we need to say this is either a const or a function i'm just going to keep it as an arrow function like that but the difference here instead of setting state we're going to say set active item and just pass it this name so that it changes it and we don't need a render because this is a functional component we just return and we need to remove this parent curly brace here i'm going to remove this segment i'm not going to have any image remove this wrap in div just keep the menu and here we don't need to import segment we just need menu so we've set up our navbar but of course we don't want messages and friends and logout we want um so the first one we want it to be the home so we will give it a name home and the active uh will be will be active when it's home and here we don't pass the on click event will be this handle click but we don't give it this dot because this is not a classbased component anymore we just pass it like that and here we'll have we have a login tab or nav link and this will be login as well and actually i want the login and the logout button or the register button to be on the right so i'm going to put put it inside of this other menu that's positioned on the right so that's the login that's fine and instead of logout we'll have register here register make sure to change this one as well okay let's save let's see what this looks like but we're not going to see it because we have we haven't used it here so let's say here import menu bar from components slash menu bar and we're going to put it at the top here so menu bar so it's going to be on the page regardless of what what page we're in all right let's save everything let's make sure our app is running without any errors it's compiling all right it runs successfully let's look at our app let's refresh okay there's a problem on click this handle effect oh did i not save i did oh yeah i thought i removed this this this okay now it should work all right so we get the menu but it's huge so let's put everything in a container uh so we go back to the semantic ui the container where is it uh right here all right what's cool about this documentation is that you can see as well what it renders eventually so uh let's use it and i want to show you something as well so we'll just copy that and let's go in the app or close this terminal window and here we'll say import container from semantic ui react and let's wrap everything let's cut everything and wrap it in a container component so tab and put everything inside and let's look at our app we have two home buttons let's fix that so here um let's remove this and save all right so we get our buttons uh none of them is active but if you click one it becomes active but we're not browsing to different pages but i want to show you something quickly so we got the container right but don't forget at the end of the day we've linked the css so we can actually just here just replace this container with div and give it a class name of ui container because if you look at the documentation at the end of the day it's just going to render a ui container i did with a class ui container which tells um our css that you know which tells our page that this is from the semantic ui css and in fact we have the same effect here but just don't forget with semantic ui you have to always have this ui thing if you just say div dot container it's not going to work all right we're just going to revert back to using the container component just wanted to show you that and here we want these to be links so these menu items what's cool about these components from a semantic ui react it's an integration so we can still say as and we can have it as a different um component we can have it behave as a different component as well and we want it to behave as a link so we want to import that so let's say import link from brow to dom and here we want it to behave as link so here we can uh pass the props that will be on the link which would we just need two so this is the home we want it to go to just slash let's copy these two and paste them here this will go to slash login because those pages are there if we so if you go to login slash login we will see that the login page is there it's just that they're not linked let's go back so this will go to slash login and this will go to slash register like this let's save all files and let's look at our app all right so we get the navigation but the home initially is not active all right so the way we can solve this is that what i wanted to do is i wanted to be by default on the home and then when we click it changes so we can start by saying home here use state home and it starts there and if we go there to any other page it goes to that one and as well it highlights that one let's make these buttons bigger and let's go here so in our menu we can i think we can yeah we have a property size and by the way you can do control space and you can um scroll up you can see all the properties that you can add of course you can see them on the documentation uh here we have a property size and we have these sizes i think the biggest is massive and i want to give a um a color as well to the active item of teal let's save let's look alright so there for some reason like the biggest size is actually not that big but that's fine that's fine by me the those are big enough all right so it's got this cool teal color um one thing that we need to fix though if you just go to the page slash login like this it's not gonna highlight login it's just gonna it's not it's just gonna set the home as active so what we want to do is we want to each time the menu bar loads it it looks at the link that we're at and the temp there depending on this link we actually set the link active so if this link says login we set this active if this link says slash register we set this to active so let's go to our menu bar and here we can say const path name and we can get this just from the javascript from the window object this is just javascript window.location and the path name and depending on where we we're at this can uh this can be just slash this can be slash about whatever page you're in so uh the way we're gonna determine that we're in the homepage it's not gonna be slash home it's just gonna be slash so we're gonna check for that so here we'll have another variable called just path and we'll say if path name so we'll do a ternary operator equals just slash then we want to set the path to the word home else so colon um what do we do yeah okay so what we do here is that we have slash about for example or slash login because that's more the case in our app we don't want it to set it to a slash login because though that will confuse these items and they will not be active we just want this so we can use the javascript function substring so we'll say path name dot sub dot sub string or actually just sub sdr and we can start at a an index we want to start at the index one which is this one and we want to get the rest of the string so just leave it like that so if it's login it's just going to take this without taking the slash and it's going to set it to that page now we want to as well set the active item to that path so we want to pass it to our use date and of course this will come after this logic right here all right let me remove this comment and save and this should work all right it works so if we go to slash login it it sets that to active and if we go to slash register it says that to active and if we change them they do change and the page actually changes all right so that's that with setting the routes and implementing semantic ui hello class welcome to part three of this series i mean class three i don't know what part is i'm trying to have a theme here by the way if you've reached this file and especially if you've done the server code as well give credit to yourself seriously you're in the one percent of people that are trying to improve and kind of improve their skills and learn more stuff you're like this guy right here you are the hero on a selfactualization and selfdevelopment journey all right so enough of that and let's actually write some code okay so here in the uh merge folder i'm actually not going to open the whole folder anymore i'm just going to open the client folder because we don't need to write any server code anymore so it's less to look at on the left side so i'm going to see the one level back and i'm going to say npm run serve to run the server and i'll open a new tab what is this go away and here i'll say npm start to start the client so here in the home page it's currently empty just says all right it's currently empty it just says home page uh let's let's actually use some query the get posts query and fetch them and show them on this page i'm going to open uh close this client the terminal so it doesn't take space uh here we'll need the use query hook use query we're going to get that from apollo react hooks and actually we need to install a couple things so let me open a new tab new terminal tab and here we'll say npm install make sure again you're in the client folder and we'll install graph graphql and graph graphql dash tag like this and here let's get the graphql tag let's say import and the convention is to call it gql from uh graphql and uh here we need to write this graphql query that we're gonna you know we're gonna use or we're going to i don't even know what you do to a graphql query all right so here we'll call this fetch underscore uh posts underscore query here we'll say g equals gql and we'll put our uh our query here and it's the get posts query and we're going to get uh essentially everything so we'll get the id we'll get the body we get the created ad and we'll get the username and we get the like count and from the likes as well we'll get so let's do like this we'll get the username of of the person that liked we'll get the comment count and we'll get from comments array we'll get the id username and created ad and the body of the comment all right um by the way i've mentioned this before if you want syntax highlighting instead of the gql tag template you can get this graphql for vs code extension and that will do that for you all right let's save let it format what is it not format of course because i need to wrap this in a query tag so do like that and then save all right cool so here we'll um we'll um actually run this query so we'll say uh const and from use query we get a couple of things from them there is loading which is true when we're actually loading and there's data and which has the data so here we'll say equals use query and then we'll pass it our fetch posts query and yeah that's it so here we can just say if data so we have if we have data we can say uh console.log data so we'll see what we get so let's save this let's actually close this terminal because taking too much space or let me close it all right so there's a problem here graphql does not contain uh oh because it's from graphql tag not graphql let's go back let's open up our console and there we go we get an object and it's got four posts all right and our posts are stored in the get posts object because that's how queries and mutations work so what we can do we can um just destructure that so from that we get um get posts and we can even give it an alias which is just post because it makes more sense so here what we need to do we need to iterate through these posts and show them and for this i'm going to use the semantic ui okay we're here where is it we need we need the grid i'm going to use a 3 grid 3 column grid layout so we can just copy this grid tag from here let's go to our home i'll paste this here and we need to close the grid component let's remove these uh three or two columns and here we need to import that so we need to say import grid from semantic ui react i'm going to remove the divided because i don't want that divider line and here i'm going to put another row at the top to put like a title of the page and here we'll say put a header one and say recent posts and here we'll have another row under that row and this will have a column but actually let's cut this column and inside of this row we want to check if we're loading because i want to add like a loading spinner thing and if we're loading so if that's true we do a ternary operator and here for now i'm just gonna put a header one and say loading posts dot dot and then here we'll put colon so else then uh we're gonna actually iterate through our posts so here we'll say uh and the thing is by the way we could this can be null or undefined because data itself is not uh populated so we need to check for it first if it's truthy so we'll say if post so posts and end now we can loop through them so we'll say post dot map and for each post actually what's up oh actually we don't need this because we're already in a javascript block so we can say for each post we want to return the following and uh here we will paste that column back but we're not gonna have an image and inside of here we can put everything that relates to the post but of course we're gonna let's put this in its own component so that we'll have smaller components and uh you know better modularity so here i'll call this postcard because we haven't created it yet and let's pass it the post so we'll pass it a property called post with the value of this post all right let's close this and uh because we're iterating through and in react when we iterate through we need to give a key value to our topmost component or key attribute and this will be the post id because that's unique so we don't have to worry about nonunique keys let's remove this if data console log data and let's save this of course this is going to have an error because we don't have a postcard yet let's import it and then create it so we'll say import postcard from we put it in components so we go back one level we go to components slash post card like this let's create that so post card dot js and here we'll import react and we'll import a couple of things from semantic ui so we'll have the card we'll have the icon and we'll have the label i think that's it for now from semantic ui css react and here we'll say function post card and we'll get the props because we're passing some props down here we need to say export default postcard and here we will say return before we turn we need to get our properties so we can say const so we're going to get the body we're going to get the created add we're going to get what else id username body oh we got body already what do we get like count yeah and so we need to get comment count count like that and the likes all right i think that's it let me look back likes yeah that's it common count and like count yeah that's fine so we get them from props dot uh post or actually let's just copy all of this we can destructure it straight away inside of here so here we'll say from props and from post we're gonna destructor all of this so we don't need to do this expression here all right so here we will return a card and actually we can just copy one card from here just go i have to type everything when it's already here i want something that looks like this i want to get the molly one let's get the second one so all of this card tag copy that our card component all right so here we have our card card content floated right that's fine uh actually yeah that's fine i want to leave that image uh but here instead of this relative path we need to get the actual path of that or the the link to that image so let's do this let's get that link copy it and let's paste it here all right so the header is not molly thomas it's actually the username of whoever posted this post so here we'll put the username and here the the meta will be the created at date so here but the created add date right now is a iso string so we need to format it so let's open a new terminal tab and install moment so let's say npm install moment and give that a moment to install hahaha so here we'll say import moment from moment and um here in the meta we'll say moment and we'll pass it the created ad oops what is that created add and here we'll say dot from now which which we'll do like kind of like an hour ago or five hours ago etc so here let's um in the description this is the body of the card we'll just say body which is the body of the post and here let's remove this stuff and because we're gonna have some different buttons here let's just put a paragraph saying buttons here and let's save everything see if there's no there's something wrong oh okay i did i just didn't save i didn't save when i added this import line at the top okay let's close this okay image is not defined oh yeah because we didn't import image so here image from symantec ui all right cool so we get our posts and um they don't have any margin between them so let's fix that so here let's go back here to the home uh this column right here let's give it some inline styling just say margin bottom let's give it 20 pixels save that uh cool we got some margin bottom and okay so i want to remove this ago because obviously if it's to two hours that means it's two hours ago we can do that by here in the from now we can by default it passes it false we'll pass it through and it will remove that ago all right so just two hours two hours and the thing is these cards are not taking the um the full width of uh of the container div or not the container i mean this uh column div so what we need to do so here in the card we can just add this property called fluid which will let them take up more space cool all right they look better now let's make just like facebook let's make this um timestamp a link into the post itself so here for this uh card meta we're going to say as and it's going to be a link i'm going to give it a property too and this let's do a backticks and we'll say slash posts slash dollar sign curly braces and here we'll put the id of the post of course we need to import link as well so let's import link from react router dom and let's save let's look at it all right so this becomes a link and it takes us there of course there's nothing here all right cool so this takes us to that id etc etc all right so let's actually add these buttons the like and comment buttons so the way i want to do it i want to use this button right here whereas button button button yeah button here i should have opened it already so i want to use this button i think it looks sick so here let's uh copy this first button right here and here in the extra div let's paste it and of course that's the import button from from semantic ui we already have label and icon installed i mean imported and here in this button is going to be as div label position right that's fine but i want this to be a teal because it's the like button and i'm going to leave it as a heart and i don't want it to say like because that's kind of selfexplanatory and here we'll have a label it's not going to be an anchor tag so we'll remove that the color will be teal and instead of this just hard coded value we'll have a number and this will be the like count let's save let's see what this looks like cool it looks uh but it looks like as if we already liked it so i want it to be just um kind of outline only so i think yeah this button right here i think we just need to add it yeah yeah it's just we add basic here all right cool it's uh just outlined because i wanted to because of course we need to later implement when we log in or uh when we're logged in that we can like but when we're logged out i want it to be kind of um outlined like this and when we click it it takes us to the login page right now when we click it it doesn't do anything actually let's add a on click button event so here we'll say on click equals let's call this function like post and let's create that right here say function like post of course for now it's just going to console.log like post like that and we want as well another button for the comment for comments so let's cut that and paste copy and paste it so div that's fine right on click it's going to say comment on post we can create that as well so here we'll say function comment on post it's just gonna console.log um comment on post so here we have comment on post we have a button but the this button i want it to be blue and the icon is to be comments and the label is going to be of color blue and basic that's fine pointing left and here we will have the uh comment count and not the like count all right let's save all right we get the uh this is interesting actually this is a different icon i think i'm meant to type comment not comments yeah okay i was using this icon but actually i prefer the new icon because it has multiple comments instead of just one okay yeah cool so now we're showing the actual comment count and the like count and we're showing these two buttons of course they don't do anything right now they they just print some some logs to our console but of course we need to implement this functionality later to have them do stuff but uh that's gonna come after we handle authentication because of course we need to be logged in for us to be able to like and comment on posts one thing i want to fix though is this um title this recent post so i want to put it in the middle and have some margin to the top so let's go to the home right here let's give this a class so here this row let's give it a class name and let's call this page dash title let's go to our app.css say page title and let's give it a display block and let's say text text align center and let's say font size let's give it some font size uh some bigger font size of two ram and some margin top as well margin top of 10 pixels let's save let's save all files um all right there's something wrong okay let's look at here i don't know here okay the display block is not being applied because it's being overridden by the dot row uh we can just simply say um uh we can add the important thing to it yeah okay now it's fixed all right that's just these minor effects that i wanted to do in the next video we're going to work on logging in and registering users so look forward to that hey class and welcome back i have nothing cringey to say in this intro so let's just get to it all right so in the last class we fetched all our posts and showed them on the home page so it'd be nice to actually now have a login and a registered form so let's do just that all right let's go to our app and here in the register component we're going to use a form so let's say up here import form from symantec ui react and the waveform works if you go to the semantic ui react documentation is that you just put a form and inside of it you put a form field and then inside of that you can put a label and then an input with all the props that you wanted to have or the attributes but there's another way which is better in my opinion to do is that you just have a form input here and you put all those props inside of just this one component so we'll use that approach so here inside of the div here instead of saying just a header one we put a form so let's say form and then we'll have an on submit which is on submit which we haven't created yet but we will and we will say as well no validate because html5 by default tries to validate email fields so here we'll say we'll have a header one saying register and here we'll have our first form field so we'll say form dot field or input rather and here we'll say actually will not close it we'll have a couple of attributes here we'll have a label for the register and it will actually this is the first for a field which is going to be the um the username field so we'll have a label saying username and we'll have a placeholder saying username like this actually this needs to be capital uh u as well uh we'll have a name which we'll use to identify what field this is when we're like changing and submitting stuff so this will be username like that and we'll have a value i'm going to give this actually we can initialize this right now so we'll say const and we'll have values and we'll have set values equals use state and it's going to be um this these uh default values will be a username we'll have an empty string and we'll have a password which is an empty string we'll have an email which is an empty string and we'll have a confirm password which is an empty string as well okay this doesn't make a sense in terms of order doesn't matter that much but i just like to keep it kind of the same order that i'll put to the fields all right so here we'll have the value would be value.username or values.username and here we'll have an on change so on change will be on change which we'll create in a moment so let's close this so this is our first input let's copy this three more times one two three so the second one will be the email so the label will say email the placeholder will say email the name will say email and i should have ctrl d but i'll do in the next one the values as well values.email so here let's click here and ctrl d once and say password and the name click here and ctrl d1 and say password like this with a lowercase p and here let's click here and say confirm password like this and here this will be confirm password like that and of course we need a button for submitting this form so we'll have a button this is a semantic ui button so we need to import it in a second so this will be of type submit because it's a form and let's give it the the primary attribute so that it becomes blue and you will say register let's go up here we need to bring button and we also need to import uh use state from react because we're using it so we'll say use state like that let's now write these uh um on on submit and on change so it will say um const on change equals we'll take an event and it will it's just going to set a set to the values but remember here we need to spread our existing values otherwise it's just going to override it with one key value attribute pair and here we need to get event dot target dot name this is going to be the name of the field because it's going to be this name right here and event dot target dot value to give it that to to give you the value of that all right so that's that for unchanged now we need the on submit so here we'll say const on submit submit equals it's going to take the event and we're going to first of course prevent default so prevent default and here we need to um check and send our actually we don't check we're not going to do any client side validation because we already have our server side validation so we need to straight away send a mutation to our server and uh persist these users if the data is valid so here we actually will actually write our graphql mutation so here we'll say const register user and it will be gql we need to import this as well so we'll say mutation uh register and this will take a couple of variables so it will take a username of type string and that's required we can just copy this just to be like quick so three more times so we'll have a an email a a password a confirm password and here so after this we'll say like that and this will trigger the register mutation which takes a register input if from if you remember our server code and this will have a couple of things and this will have a username it's the same it's the same thing but we need to give them as variables here so username and we can just copy this three more times and here will be an email here will be the password and here will be the oops i need to ctrl d and say confirm password all right so after this is triggered we need to get a couple of fields back so we'll get all of them so the id the email the username the created ad and of course most importantly the uh the token the jwt token of course we need to import gql so let's go up here we'll say import gql from graphql tag and uh we need to as well the use mutation hook so we'll say import use mutation from uh at apollo slash react hooks not common hooks all right so here we'll say let's remove this white space and we'll say const oops const and we'll get a couple of things from here from this so we'll use a radius structuring and let's call this a function add user and we'll have a couple of things from here but we'll just get the loading and here we'll say equals use mutation and we'll pass it our register user mutation and here for the um for the options we'll have a function called update and this will be triggered if the mutation is successfully um executed so this will give us two um a couple of things the proxy that this will we will rarely use it's got some metadata and here we'll have a result this will hold the result of the mutation so here let's just console.log the result for now and see what happens and um i think yeah this is it for now oh we also we need to give the um the variables because this is a mutation we need to give some variables of the mutations we can all we can do here so username is values.username and then attach the other three but since the object of values is the same this that is those values that we want to send we can just say variables is values simple as that and now of course we need to trigger this add user function when we submit our form but the thing is we can't just put it here and we can't put this um above here or can we well actually we can yeah we can just put this above here and so we have access to the add user yeah so you can just add user like this and that will work all right let's um i think this is it let's save let's make sure that we have no errors here we don't cool it says that we're not using loading but we'll use it in a second all right so let's look at our form all right it's way too wide let's um let's fix that so here for our wrapping div we can give it a class name of form container or container like this and let's go to our app.css here we'll say dot form dash container and we can just say width is 400 pixels and let's give it a margin auto so it's pushed to the middle auto let's save let's save all files all right it looks much better now okay let's open up the console window put them side by side and see what happens if we just send yeah if we just send a form empty like that we get uh errors we can't see them here but they're actually encapsulated in the errors object that we can get from this but if we register a new user successfully let's say new let's give some valid data so new and new email.com and here we'll say one through six and oh actually i forgot to say this is of type password so let's quickly change that so here this uh these passwords are where are they oh i didn't even give the type actually so let's give the type to these just for good measure so this one will be type this is the username type text just copy this here we can just give a type of email and for the password we'll give a type of password and we can just copy this one more time and give it to the confirm password a type of password as well all right let's look at our app now if we type something here it's um it's hidden so here we'll say new and the email will be new at email.com and the password will be one through six and the confirm password will be the same thing and we hit enter there we go we get data back which holds a data object which holds a register object because that's the name of the mutation and we get exactly the fields we want all right that's brilliant but what we want to do is we want to redirect to the home page once the user is registered successfully and we want to use that loading loading boolean when we send some data we want it to see like spinning that's really easy with semantic ui what we can do let's go to our form here we can give it a class name and if the class name is loading it's going to be it's going to have a spinner in the middle so here we'll have a actually a dynamic value and we'll say if loading it's the loading that we got from the user mutation then we give it a class of loading else we give it like just an empty class like that all right let's save let's go to our app and here you can see briefly the the loading spinner comes for a second and then goes because like the response comes way too fast but it does have a loading effect all right so what we need to do now is we need to handle um errors because we can we can get some errors from our request and we need to show them on our form so here after the update i'm going to say on error which is this other function or other function that we have and it holds the error and here we'll say um we will say actually what do we do oh we need to actually have some errors in our component and then we set them here if they exist so here we'll say const and we'll have errors like this and we'll have a set errors function equals use state and we'll pass this an empty object like that and inside of here so if we get errors we just want to say set errors let's put a comma here and these will be inside of error dot graph ql errors i get some autocomplete because i typed it before but here graphql errors you can return multiple errors but the way our server code is is written is that we get we give one error and inside of that there's an object that holds all those errors so we will access the first error like this in this array and we say dot extensions extensions which is this object that's inside of it dot exception exception and here we've we have put our errors if you remember when we wrote this code in our server code so here we set those errors to these errors and we can actually console log them just to make sure that these this is what we're looking for so here we'll say console.log and we console.log exactly that and then we set it to our errors but of course we need to show them on our markup so i didn't find a way how to do this with semantic ui react but so i'm just going to use the semantic ui css because we have access to that as well so here we'll have a um a div or just like this dot ui dot error dot message and here we need to put a ul with a class of list and here we need to to loop through our errors and access them but the way our errors work is we get a key called for example username and then we get an error called username must not be empty so we don't need the keys we just need to show the errors so what we need to do is object dot values so we access the values and not the keys of errors because we have that in our state or like set state variable dot map and we map through them so for each value we want to display an ally so we just do like this parenthesis and we'll display an ally since we're iterating through an array we need to say we need to give it an key because we're in react and this key will be the value because these are unique and here we'll say and the what it contains as well is the value of this error and of course this is conditional because we might not have errors at all so let's cut that and here we'll say we can if we check to if we just have errors it will be truthy because we have errors all the time and it's an empty object at the beginning so what we need to check we need to check if this errors has any keys so we'll say object dot keys of errors dot length bigger than zero so if the length of it is bigger than zero then there is some keys and that means we have some errors so let's show this so we'll say and and and we put parentheses and we put everything back in here all right so let's save that and let's go to our app okay let's submit an empty form and right now we should get an error for username for email and for password as well and we do so a username must not be empty email must not be empty and password must not be empty but let's invalidate these as well because it makes more sense to see the ones that are not valid invalidated we can simply do that by um so in the field we'll add this error property so error property which is a boolean so it's either true or false but here we'll give it a dynamic value so for username we're going to check for errors dot username and if that's truthy so we'll give we'll put a ternary operator and say true else it's false there's no error for username so let's copy this paste it here for email and change oops change this to email let's paste it for the password and change it to password and let's put it to the confirm password and change it to confirm password let's save that let's look at our form let's make it full screen and here let's say so let's have no username and let's put a valid uh email so new at email.com and put like i'll put one through six and then here put one through seven so there we go it says username must not be empty and passwords must match so let's fix that that's fixed you get just username and if i put new here and say register just press enter actually the username is taken because we registered that new new user so here we can say new to and the regis oh it says username is taken do i have new tool as well okay so i have a new and i have a new two in the database so i'm just gonna delete those for now and test again let's delete this as well or is it yeah oh that's confusing news here let's delete that oh actually one thing i forgot um so here once we submit and it's successful and we add a user on the update here once we get our successful result we need to redirect to the home page so here we'll say props dot props dot history push and we'll just push the slash which is the home uh homepage and of course we need to take our props as well from the parent component all right so let's save that proxy we don't need to use it so we can omit it and just put an underscore here so let's uh let's go to our app right here and here let's put some valid data so we deleted that new user so we can use this again so let's say new at email.com and let's put one through six one through six register there we go you get a cool spinner and we are logged in and we go to the home page and we get this token back now of course we're not putting this token in any application state or anything for now but the register is working and it's sending a request and we're successfully registering this user and if we check there we go new at email.com all right let's do the same for the login page as well so what we need to do is actually we can copy everything from here from the register page and we go to the login component and paste everything here actually one thing that i want to do is let's put this this on change and the on submit let's put them in a custom hook because otherwise we're repeating the same code across two components so let's copy this um actually let's open up the the side here let's put a create a new file inside a folder called util so util slash hooks and here we'll keep our custom hooks so from the login we can copy the onchange and here let's uh import we'll need use state because we want to store the values here as well from react and here we'll say const export const i've written this hook for the custom hook video that i have so you might be familiar with it so this will be it will take a callback and i'll explain what this does in a second and it will take an initial state and this will be by default an empty object and you will do the following and here we'll have let's let's paste that and then let's copy as well this values from here or like this from here and um spaced it here but this will be actually the initial state so here in the login actually in the register let's fix the register first so here we'll say const initial state equals that and here in the hook if we take an initial state and then we and you use state and we pass it the initial state like that and the own change will be i think the same yeah it's the same so we get an event and we set values these values to that that's fine and then we'll have the on submit so we'll say const on submit take an event and it will oops it will event dot prevent default oops i misspelled default like that and here it will call that callback because the thing is we don't uh depending on what page this used form is used in the callback can be different right i know in our case it's not but we make it more generic by passing this callback and then calling it from here now of course we need to return these values and the on change in the on submit so that we can use them in the in the component so we'll say return and we turn an object with the onchange the onsubmit and the values like that all right so our hook is done let's save it and here in the register let's import that hook so here we'll say import uh what is it called used for actually because it's not the default we need to do like that from go back one level to util slash hooks so here we don't need to say this like that we just need to extract those so we'll say const and we'll get the on change the on submit and the values from use form so this will take a callback uh let's give it the add add user function as the callback and let's give it the initial state which is going to be this so let's copy what's inside of this initial state we can just pass it like that without actually declaring a variable here so here we have those we have the on change in the on submit so we can just remove this and we can remove this so but the problem here of course the the add user is not recognized up here but as well if we take this and we put it underneath here the values up here will not be recognized because they're coming from here so a workaround around this is we can declare a function here say function let's call it register user and this will simply just call the add user uh function which we get from here and then we can pass this as uh this callback right here now you might be wondering what the hell why does this not be um not be recognized up here but this will but the way javascript works is that all the functions with a keyword function in front of them at the beginning of the program are hoisted meaning that they are brought up and kind of read through initially and then even if it's down here but it has the function keyword it's actually recognized up here unlike the const variable functions all right so this should be fine let's we didn't actually see our console log errors but of course seeing the result of what happened we are getting the pro the proper error so we can remove these console logs and let's uh save everything do we not yeah we don't have any errors let's check let's make sure that everything works the same in a login form so we go here all right cool so everything works the same the on submit is working and as well if we submit some valid uh data so you will say i don't know some just random email for now and put one through six there we go registered and we're redirected to the home page so the the hook is working fine now we need to integrate it in the login form so here let's import it so let's say import use form from and go back one level to util slash hooks and here this is login not register oops log in and here we have the errors the same way we'll have a const and this will be let's call it login user and this will call a mutation of a login user which we'll create in a second and update it will let's not console.log that we will push to the home page the same way and we will set the errors the same way nothing changes here and the on submit is the same except it's gonna call uh what is it gonna call it's gonna call the login user from here and then actually no we don't have a lot on submit we're going to use the use form hook excuse me so here we'll have the on change the on submit and we'll have the values from use form and i'll call back so let's make this the callback so here we'll say function uh login user since we already have a login user let's just call this login user callback like that and it will only it will simply call the login user so we'll pass it here as the callback in the login form and the initial state will be a username so we only have a username and a password on the login form it's going to be an empty username and the password will be an empty password so the login user will do that we'll call that and we'll get we'll do the same thing the callback all right so here in our markup we have a form same thing same uh stuff here but for the header we'll say login and for the input we'll have just two inputs so here let's remove this let's keep the password input and remove the email input so here we'll have a username the same stuff nothing changes and the password as well the same stuff nothing changes so here in the button we'll say login instead of register and here for errors nothing changes as well but here instead of register user we'll have a login user and here we'll have the mutation of login and we will remove the email and we'll remove the confirm password and here we'll have the mutation login and we don't have a register input so we can remove that like this like this and we can remove the email and we can do the password like that we can remove this and we'll get the same data as well from the login mutation all right let's save everything let's check if this is working we have no errors or we have an error so register is not defined oh because i'm exporting register at the bottom all right so here we will export login let's save all right cool no errors let's check our app all right login form we get this form and if we log in with empty it says username must not be empty and if we put a username it says password must not be empty if we put the wrong password so i'll put 137 click login it loads and then it says wrong credentials but if i put the correct credentials one through six i click enter and voila we are logged in and we get redirected to the homepage now of course we're not changing the navbar right here because we still have those buttons because we don't have an actually applicationwide kind of context that knows that we're logged in or not which we will do in the next class so look forward to that i shouldn't have had the third coffee coders problems eh okay whatever let's do this hello class and welcome to class five uh so we've done a lot so far we have created the login and registered pages and they redirect us to the homepage if we log in successfully or register successfully but the caveat is we're not doing anything with this data right now because if we log in if i just type in some valid credentials we just receive some data from our server but we're not doing anything with it because for example you can see that our navbar is still saying login and register so we need a way to store this user data globally in our application so that whenever a component needs to know whether we're logged in or not whether we need some permission to do some behavior that's only allowed when we're logged in so that needs to access it aka a global state which we can do through either context or redux or through uh some other stuff we're going to use context because this app is too small for redux because we're only going to manage some user data that's it so let's actually start to make that a reality all right so let's go to our app here i'm going to create a new file inside of a folder called context so call it auth.js because it's going to be our auth context so here we'll import react oops react from react so what we're going to create we're going to create in a context so we'll just actually create this context actually i forgot to get create context from react and here we'll say const auth context equals create context context and here we'll so we'll pass a couple of things our context will hold a user object and initially this will be null and here we'll have a login uh function and this will take some data and we'll do something this is just like kind of a placeholder to have like some sort of like intelligence later it's not uh it's not necessary you can actually emit these two but it's a good practice i think and we'll have a logout which will take nothing and do something all right so here what we need to create is we need to create a reducer and if you don't know about a reducer i suggest you get familiar with the patterns of redux and uh and then you will know what a reducer is i'm not gonna like kind of go in depth it's basically it receives uh an action with a type and a payload and then it determines what to do with those two depending on your functionality of your application so here we'll have a reducer and we'll call it uh auth reducer oops reducer like this and this will take like i said the state actually i didn't mention that it takes the state because it needs to uh change the state and an action and it will switch on the action dot state so on um or rather the dot type not state so depending on the type of the action it's going to do something of course any switch needs a default case and in the default case we're just going to return the state okay state like this now we'll have another case here usually you'd have like you'd put them in variables but we only have two so i'm just going to have them as strings here uh one i'll call login like this and when we log in we need to return of course we spread the existing state and we want to add the user so because we're logging in and we're getting some data and we want to set our user in our state to this data so we'll say action user equals action.payload now i'll have another case which is case logout so here we'll say log out like this so when we log out we simply want to clear the data we want to set the user back to null so here we'll spread the state oops spread the state and say user is null all right so of course we need to use this reducer somewhere and we'll use it in our auth provider so here we'll create a an auth provider so function auth context pro vita like this and this will take a props and i'll tell you later why it takes a props take some props so here we'll say const state and dispatch actually we need to get user the user reducer hook use reducer and the user reducer hook takes a reducer and returns a state and a dispatch and we need to as well give it um so we'll say reuse reducer we need to give it our reducer so the auth reducer and we need to give it an initial state which is going to be a user of null but this is our initial state so now that we have our this dispatch we can use it to uh dispatch any action and then attach to it uh some type and a payload and then that when that's dispatched this reducer will listen to it and then do um you know perform any action according to that dispatched action so here we need to actually write our login and log out functions so that will pass them down to our component tree so here we'll say const login and so the login is just a function that will take some data and actually since i'm using the keyword function a lot in this project i'm just going to stick to that so i'll say function login takes data and here what he needs to do is just gonna dispatch um it's a action with a type of login and a payload oops a payload of this data that you got well actually it would make sense more sense if we name this user data because we'll know what what it is and we can as well here change it to user data even though it doesn't matter it's just a an argument name but but it's more readable like this all right so here we want to have our logout function as well so function logout and here our logout will actually won't take anything and it will dispatch an action with a type um log out and this will not have any payload because that's how logout works all right so here we need to return this provider so we can use it somewhere else so here we'll say return and we'll open a component and say auth context dot provider and now we need to have a value because this is what we need to pass what this is what we're going to pass to our components that are underneath this context provider so here our value will be a javascript object so we wrap it in two curly braces so we'll say uh user is the state.user so we need to pass the user down and here we'll pass the login function and the logout function as well and here we'll do we'll spread props like this because we might get some props from the top down component and now we need to export two things we need to export our auth context because that's what we're going to use from our components to access our context and we need to um export the auth provider which will use in our app to wrap all of our applications so that it would have access to this uh provider to these functions from the context all right so this is what's going to happen when we log in we want to call the login function or this dispatch this login type with this data which will change the data inside of our context and set our user to the user details that we have so that our application will know that we're logged in all right first thing before we go to any login or register page we need to actually give our application this provider so here we'll say import auth provider from uh so from util or not util actually from all context slash auth so here we'll wrap our entire um so we'll cut this and we'll say auth not context provider and do like this and put everything inside of that so everything inside of here will have access to that to that context all right so first things first we need to go to login and here once we're logged in so we get our login data inside of this result.data.login object so we need to hit this login function and actually pass it this data so that our context will set the user to uh to the actual user data so we need to get that context so here we'll say import ask context from we go back one level and we go to context slash auth like this and we need the use context hook so here we'll say use context from react and here at the top of our component we'll say const actually let me close this const context equals use context and we give it the auth context that we imported and now we have access to that context and remember this this context holds a user a login and a logout so we need this login right here so here before we redirect to the home page once we successfully log in we simply say context dot login and we pass it the data which is going to be a result.data.login right here right right here it kind of doesn't make a lot of sense to have it called login so what we can do we can from result we can destructure data and from data we can destructure login and login we need we can give it an alias and let's call this user data now we can just pass user data right here oops what did i copy so we can just pass user data right here which makes so much more sense than just passing result data login okay we can remove this console log because we know we're getting the correct data and let's do the exact same thing from the um from the register component so we go to the register component and here at the top we got our context so we can say import auth context from we go back oops we go back one level to context slash auth and of course we need to use context hook and here we'll say const context equals what is it use context and we give our auth context and we do the same thing right here we can destructure as well here we'll say from result we get data and from data we get register and register and we will call this or actually no i made a mistake from data yeah we open curly braces and we get register register and then we give it an alias and we call it user data so here we'll say context dot the same login even though this is a register but we don't need to have two functions for something that does the same so we'll say context.login because when registering we're logging in users so we'll say context.login user data simple as that all right so now once we log in or register our entire application will have this data inside of the context so let's save everything and let's go to our app to remove that let it reload so now if we log in say user actually can i see the context all right so let's go to the react dev tools let's open this we see that we have a context provider right here and it has actually this is the apollo provider so we need to have the context provider of the auth provider which has a value here so as we see we have a value result user rather of null and a login and a logout function so if we log in successfully here one two three let's actually put seven we log in there we go we got our user and we get our user's name is um actually get a type name because it's kind of um that's strange that looks like a graphql kind of actually graphql has this type name so ignore myself so we get created that email an id and the token and the username so we have this user in our context but of course we're not using that in our application to change the behavior of our application because for example we want to change this to have our username here and we want to have a logout button here so that we can use it to log up all right so let's go here we can close this we no longer need the app so let's go to our menu bar so menu bar and here we need to get our context because we want to show a different menu bar depending on whether we're logged in or not so it will say import auth context oops these typos from i go back to context slash auth and here at the top again actually i've got the use context as well this context and here at the top we'll say const or actually we can destructure from it the user and the logout so that we don't have to type context dot here we'll say use context and we pass it our auth context and um in case you're wondering by the way just quickly i wanted to explain here i didn't want to destructure the log out uh the login rather and just use login here because it's kind of confusing there's too many login words in this component so if by having here context.login if someone reads this code and says context.login it's obvious that this context is a login from the context so it's more readable right i can have it like this like by destructuring it and just having it like this by super confusing so i prefer to leave the uh the context right there just uh just as a heads up all right so what i want to do here is that so let's cut all of this this is the menu that we want to show when we're not logged in all right i'm going to create a variable i'll call it menu bar because the menu bar is going to be dynamic so we'll say const menu bar equals and we'll say user so if user if we're logged in then we want to show something else we want to show this menu that we had this is what we show when we're not logged in but when we're logged in let's actually paste the same menu but we'll change a couple of things so it's the same menu but here instead of home we'll have a button with the username so we'll say user dot username will have uh their name there instead of the home and i want it to always be active so i'll just remove that condition and it's not gonna have an on click but it's going to be a link to the home right so here see here as well on the right let's remove one and keep one and this will be the log out and this will not will never be active because once you log out the buttons will change so it will not have an on click as well or will it actually it will its on click will be the log out so here we'll say log out because once you click it we want to trigger the context logout function and it will not go anywhere so we can remove this as link and to slash login all right let's save that and let's see if that works so we get our context and we look here and we see that oh yeah of course we need to log in again let's say a user and we log in and we log in cool so our navbar changed and now we have user i mean it says user because this user is actually user if i would log in as i see it worked i wanted to test it and i clicked log out all right so the logout work worked because our user is null and if i want to log in as another user like jane now this says jane and now i have the user jane in my context and if i click log out that's removed okay but there's now one problem because right now if i log in and if i just refresh the page we're back to zero we're not logged in again we need some way to persist this we can simply do this by just storing this token locally on our on this device that we're using and then once the app loads we try to fetch a token if this token is there then we set ourselves to logged in else we set ourselves to be uh not logged out i mean the app does it not we're not doing anything as a user all right so in the auth right here we need to persist the uh the token in the local storage once we log in or log out so here once we log in so we'll say local storage dot set item and we can call this token let's call it jwt token and the data will be inside of this user data so we'll say userdata.token and uh yeah that's it well actually here in the logout we need to remove it so here we'll say log local storage dot remove item and the name is jwt token okay now we have this token but we're not we're not actually checking if we have it once we start the app so let's go up here here we can say if local storage dot get item and it's the jwt token item if this is truthy that means this item exists um actually i want to do an extra step here what i want to do because this token stores an expiration date and time right and i don't want to set our app to be logged in if this one hour long token has expired so i need to check whether it's expired or not but this expiration is actually encoded inside of the token so we need to decode it for this we'll um install a library called jwt decode so we'll say npm install jwt dash decode all right let's let that install we can import that we'll say import let's call it jwt the code like this from jwt dash decode all right now we can use this to decode our token so we'll say now that we've got the token actually we can put it in a variable so we'll say const token equals we can just decode it here actually so we'll say jwt decode and we'll call we'll we'll pass it this this token right here so we'll pass it actually makes more sense to call it decoded token here decoded token okay so now that we have our decoded token we can say if decoded token oops what is that decoded token dot exp because this is where that expiration time is stored and this is stored in in like a what do you call like time from epoch uh date string and we need to times it by a thousand because this is like in seconds we need in milliseconds if this is smaller than or lesser than date dot now that means it's actually expired so what we need to do is we need to delete it and we set ourselves to not be logged in so we need to say local storage dot remove item we need to remove it because it's actually expired we need uh not token jwt token like this else if it's not expired we want to set our user to this decoded token data because it's it's a valid token and we're actually logged in uh but how do we do oh actually no i made a mistake here we don't just pass this initial state like this we can create a variable initial state i mean it's not a mistake but we need to have this as a dynamic value okay let's copy that and here at the top we'll have our const initial state as an object with a user that's null initially but once we do this check if the token is expired we remove it and we leave that initial state with a null user with a user that's not but if you if we're not we need to set this user and then so once we get here we actually set our user to this user so we don't set it to no so here we'll say initial initial state dot user i still misspelled it did i misspell that initial state no that's fine all right user equals decoded no again token like that uh these misspells are getting out of hand guys all right so that should do the trick so let's save and let's go to our app make sure actually we don't get any errors we don't let's go to our app so let's go to our console or not console actually application and here in local storage whoa what is all of this i'm just going to delete everything it's firebase stuff all right so here let's log in as user 136. there we go we get a jwt token and if we log out it deletes it all right but now we need to make sure that it's actually fetching this data once we um re reload so now that we have this in our storage let's actually refresh the page there we go if we refresh the page it's actually getting this data and giving it to our context because again if i check in the react dev tools and open this app open the auth provider and the provider of it the context we'll see here if we expand this value we'll see that the user is set to our current user and you see that xp is here and that i don't know what that is is there it's probably something that has to do with some time to live thing looks like to be the same i don't know whatever all right so yeah so that's that for managing um our user state uh we will use this in the well actually i forgot to do something i forgot to handle some edge case because if we now still go to register that page is still accessible now of course that's not good behavior because we're logged in we wanna we don't wanna see we don't want to be able to access the login and the register pages all right let's fix that so let's go to our app for we can do this or actually let's uh make this into its own component because uh we'll make the app uh component massive otherwise or the uh the app file so here in the util i'll create what am i doing i'll close everything i'll create a uh a thing called auth route so this is essentially going to be the opposite of a protected route component what this will do is that instead of these two login and register routes we'll have an auth route that checks if we're logged in and we try to go to slash login or stash register it's actually going to redirect us to the to the um to the actual home page because we don't need to go to those pages if we're logged in so here of course we need react and we need use context because we need to access our context our auth context from react and here we need to import route and uh what is redirect yeah redirect redirect from react router dom and here we'll say const call this auth route or we can have it as a function function uh auth route and this will take um this will take some props and inside these props we'll have a component so we'll pass down our actual route component but let's give this an alias of component with a capital c so that we can use it as a component i know that's confusing but hopefully you'll understand when you see what i'm gonna type later so here we need to get our user so we say const um or actually i need to get to the context so here let's say import let's make space between them and say auth context context from go back one level to context slash auth and here we can destructure our user from use context and auth context so now that we have our user we can check so we'll say return let's return we return a route and inside of this route we'll spread whatever we got passed from um from the uh from the thing that wraps this and then we will do a render prop uh expression here we'll say render and we'll open the curly braces and we'll say props and we'll um do an arrow and then we will check for the user here so oops what is this all right so here i'll say i'll tap this in and we'll say user and then do a ternary operator so if we have the user then we just return a redirect redirect to um to slash like this and then else we will just return that component that we got passed down component and we will give it these our props that we we have received so props and then we close it like this now of course we need to export this actually i need to close this route so like that and here we'll say export default auth oops auth route all right let's save that let's go back to our app and here we'll import that we'll say import auth route from uh the same level util slash auth route and here instead of doing that we'll just say auth route and here as well we'll say auth route and pass the same stuff so what this essentially does is uh we'll do an author out which is this component right here and we'll pass all these attributes right here the exact the path and the component and once we get here and we get our user if we have this user inside of this route we will render oops inside of this wrap we'll actually return it as a redirect which will just if we click it it will just i mean if we trigger it it will just redirect to slash but if we don't have a user we're just going to put that component that we have uh with these props that we just passed down here i hope that makes sense all right so let's look at our app so now that we're logged in if we go to our uh to our login page to log in now we get redirected immediately to the home page and if we go to register as well we get redirected all right so this is it for this class in the next class we will actually start to work on posting data and we will add the post form here and we will be able to add some more posts as this user that we're logged in so now that we've set up our auth context for our application to know whether we're logged in or not now we can use that the information to decide on whether to show something or not one example of this is we're gonna now uh add a post form for us to be able to submit a post as a user from the home page so let's get to that all right let's go to our app make sure you have your server and client running uh i do on mine so i'm just going to close this terminal window let's go to the home page so home and here right here at the top i want to show another column if we're logged in and put that post form in that column so here um before this loading tag here we'll say grid actually no we need to get the user from the context first here i'll say actually here we'll say we'll import the context so import auth context from go back to context slash auth so here we'll actually need to use we need to get the use context hook as well so here we'll say const we can destructure the user equals use context and we'll pass it our auth context like that now now that we have the user so here we'll say if user we will render this markup actually not percentage we'll do and and like this so if we have a user that means if we're logged in let's show this form so here we'll say uh what is it grid dot column that we want to show and let's close that and inside of here we'll put our form but i want to put this in its own component because otherwise this will be massive and we'll have another mutation written as well here on top of this query that we have so here i'll simply say post form and close this tag of course we haven't created it yet but we will so here we'll say import post post form from so here we're in pages so we have to go back one level and go to component slash post form all right let's uh close this let's go to our components and create a file called post form so js and let's say rcf and tab doesn't work oh it's rfc anyway it refuses to work for some reason let's type it manually these snippets sometimes are weird maybe it's interacting with another extension all right so here we'll say function post form oops and it's going to do something and we need to export it as well so export default post form all right let me close that so here what we need to do is we need to actually import the uh the form from semantic ui so it's a import form from semantic ui react and we need our custom use form hook as well so here we'll say import use form from go back one level to util slash hooks so all right let's go to our component here we'll say return and let's open our form this will have a on submit of on submit on submit and let's close that and inside of here we're going to have uh actually let's put a header first let's put a header too saying create a post colon and here we'll have only one field but i'm going to have it as a field because i want the button to be inside of it contained in it so here we'll say form dot field and close this and inside of here we'll have the form dot input element and this will have a couple of props so we will have a place holder holder will say hi world like the name of the app and we'll have a name let's call this body because this is the body of the post we have the non change of on change we'll get this from the use form hook so he'll have a value which is going to be values.body oops dot body and we'll have as well an error which we will handle later or actually we'll we'll handle the error later for now let's just have it like this and let's put a button a submit button so it will be of type submit and let's give it a teal color so color teal let's close that and it will say submit and here let's bring the button as well from semantic ui all right so now we need to use our use form and create these values and unchange and whatnot so you will say const values and on change and on submit submit as you're used to the custom hook we'll say use form and we'll have a callback let's call it create post callback and we'll have an initial state which will just have a body of that's an empty string all right now we need to actually write our mutation to persist a post to our database so here let's write the mutation so here we'll say const what do we call it create create post mutation and we need to bring gql so let's say import gql from graphql tag graphql so here we'll say gql open the template string and we'll say mutation oops all right let me type that down we'll say mutation let's call this create post and this will take a body of type string and that's required and inside of here it will call the create post mutation that we created and it will pass it a body of the value body like that so let's actually get everything that we get back so the id the body the created add the username we've got the likes with everything inside of them so we get the id of the like the username and the created ad and we'll get the like count we'll get the comments and from comments we're gonna get the id the body uh the username and the created at same stuff that we get from uh fetch all posts and here we'll get the comment count as well and yeah that's everything all right so now we need to use this mutation so here uh okay we need the used mutation hook so here we'll say import use mutation from uh at apollo slash react hooks and here we'll say const uh create post and uh we'll get actually the way we handled errors on the register and login page was that and we did we used the on error method and then we set them to local errors but here it doesn't make sense because we only have one error and we don't want we're not going to extra extract it from a deeply nested property so i'm just going to get it like this i'm just going to get it from the um this second parameter so we will say error like that and we'll say use mutation and we'll pass it our create post mutation and we'll pass it our variables which will be the values which only holds the body so we'll have an update and or have i been used i think i've been using the function form so i'll stick to that so update and we'll emit the proxy and we'll have the result and here we'll say um we're just going to console.log the result for now and we need to reset actually the the body field because we want to empty the the body field once we submit it all right this should be uh fine we shouldn't have any errors so let's save and let's look at our app cool we don't have any errors all right let's look at our app okay we get an error now because create post callback yeah it's not defined and on change i'm gonna misspelled something here uh yeah on change like that and we need this callback so this callback needs to be here and it will only call the create post like that actually i forgot to add the function keyword function like that all right let's save okay so let's open our developer tools and uh let's login we log in okay now that we have a token but now if i submit a post of course it's going to fail because it's going to ask me authorization header must be provided now we need to set up our apollo client in a way that once we have a token in our storage we need to get that token get it and add it as an authorization header automatically without having to add it each time we send the request we can do this by using something called uh apollo an apollo link context link context and let's go to the apollo graphql website and so yeah this actually no it's not this page i was looking for a different page apollo link context okay so yeah we'll use this uh set context uh function from apollo link context and the way this works is uh it kind of works like a middleware so it sets a context of this request and kind of modifies whatever you want to like do before that request is pros um kind of forwarded towards the http link so let's install this and actually set it up so i'm going to open a new window and say npm install actually let's cd into the client first and i'll say npm install apollo link context like that so we need to set it up in our apollo provider so let's go to our apollo provider and here let's import that so we'll import the set context function set context from apollo link context and here we'll create this new link and we'll say uh const auth link equals set context and this will have a handler this takes a request and a previous context that we can kind of get data from and edit and forward uh to the next operation but we don't need any of these parameters so we can just emit them and just do like this just an empty empty argument list and here we need to get our token from the local storage so we'll say cons token equals local storage dot get item and remember we named the jwt token so now that we have it we need to set it as a as a authorization header so here we'll say return because this will modify the um modify the current request so here we'll say return and we'll do an object and inside of that there's another object and we have a or actually no that's going to be inside of the header so we'll join object and inside of that we have a headers and we'll add an authorization header so author authorization and we need to check if we have the token because we might not have it so we'll say token and we'll do a ternary operator so if it's the case if it's uh if we have a token want to say bearer and do like a template string so we can add a variable here and then let's put the uh token here else we'll just uh add an authorization header with an empty string uh value now this will kind of merge the existing headers of the request with this uh headers object that we gave so it will just add this authorization header all right of course now we're not using this yet so let's use that or actually let me put this on top of the client declaration here because we need to use it here and here we just need to add concatenate it to this link but it needs to go before the http link so we can say auth link dot we'll use the javascript concat function and say concat and pass this our http link all right this should actually add the token to our request and successfully send any protected api calls all right let's save this and let's go to our app let's make sure we have a token all right we do we have a token and it's uh it's valid i logged in less than an hour ago so now if we say let's go to our network clear everything out and we just send some gibberish we press enter we get a request here all right it says args is not defined let me check the server code okay i added this line for validation last time but instead of saying just body i actually added this args object so let me save that and run the server again and test all right let's test it click submit and there we go we get a 200 response and we get create opt create post and it actually you know returns us the post that's been created so it's successfully been created now of course it's not showing on the front end because we hadn't added any code to uh to do that all right so if we refresh and we fetch the post again there we go that's our post right there now the way we're going to show this post on the front end is we're not going to use context we're going to use apollo cache in memory but the problem with that is if we look at the apollo dev tools if we go to cache you'll see by the way in the polar dev tools you can see right here the queries the queries that we're sending so once the app loaded it just sent this get posts query to get all the posts and if we go to cache there are a couple of things here but if you go to root query you'll see that all the queries that we sent we send are actually stored separately so the get post query right now is caching five posts we need a way to directly access this cache and modify and add this new post that we just added and we can do this uh i hope this time the google search works so let's go to yeah caching data let's go a bit down it's right here yeah direct cache access so what we need to do we're going to access the cache directly and we're going to use now here they're using render props and they're using the client variable or object but we don't have access to that but instead we have access to the pro the proxy object which will let us perform this is a bit confusing but you will understand it the more you use it we actually gonna gonna perform graphql queries on our existing client data instead of actually reaching to the server all right let's actually apply this so let's go to our post form and here on the update instead of just log in the result we want to access this cache so here actually we're not going to omit the proxy we're going to write proxy like that and we're going to say proxy dot read read query and we need to pass a query here and this query will be let's say if you had the po get posts query and you sent it here it will actually fetch the post from the client data that's stored in the cache but the problem here we're already using this query in the home page we want we don't want to type it again so what we can do we can outsource it to its own file so let's copy this entire query from the home page let's copy let's cut it actually and in the util folder let's create a file called graphql.js and here we'll say we'll export it we'll export const fetch post query like that and of course we need gql so here we'll say import gql from graph ql tag now in the home we need to import it and use it so here we'll say import fetch posts query from we go back one level to util slash graphql now we don't need gql anymore so in the home it's going to work the same the same way it did before and in the post form now we need to get that fetch fetch posts uh query so we'll say fetch posts query query from we go back uh one level to util slash graph ql all right so now in read query we just pass this fetch posts query like actually but we need to give it uh to put it in a query variable and we just pass it like that now let's put this in a variable so we'll say const data equals proxy dot read query and we pass that query now all that data that's in our cache is sitting inside of this data variable so but it's inside of an another variable called get post because remember this is this data that we're getting is the root query it's this data right here so our posts are inside of get posts so here we need to edit that get posts entry so we'll say data dot get posts equals now that we have the result here we can just say open a an array and we want to put it at the top because this is the newest post so we'll say result dot data dot get post because this is where our response is stored and then comma and then we'll spread the existing get post so we'll spread the existing posts now of course we need to persist this so for this we'll use proxy.writequery and here we'll say the query is fetch post query and the data will be just this data object right here all right let's save everything actually let's save all files make sure you save all files now let's go to our app okay so it says graphql cannot resolve graphql i misspelled the name of the file here graph graph ql let's save let's refresh no such okay i misspelled it somewhere else probably in the home okay that's uh renamed and here as well it's renamed okay third time is the charm all right cool so now if we go to our cache we see that we have five posts and if we post a new one all right it breaks so it can't cannot read property id of undefined okay because i made a mistake here the data is actually stored in create post not get post because that's the name of the mutation all right so let's save this should work now it did send that mutation but it didn't persist it properly in the cache because i misspelled the i made the gave the wrong mutation name so now if i post one and if we look at the cache so look at the root query we have six posts so if we submit this now it's seven posts and it actually shows so if we say another one it's actually shown on our front end all right that's cool one thing that i wanted to show you is that here when you look at the queries if we go to this post and we go back it sends another query called um get posts but i've set up our server code in a way that each time we send a request from each of the resolvers let's say the create post resolvers is gonna console.log create posts and the other the get posts will console.log that and the getpost will console.log that just for us to see when the these actual resolvers are being hit so here you see we get posts once but in our app in our front end if we go back and if we go back to the home page it sends that query but from our server it doesn't print that again because it's actually sending that query to the client side um cache not to the server side the first one is the only one that's actually being sent to the server but the other two are actually sent to the client side cache just for you to bear in mind if you see this list of queries and you're thinking this is actually sending too many requests to our servers it's not it's just sending that one first request hello my dear class it's nice to have you here welcome to class number seven where we write some more code all right actually one thing that i forgot to uh to do last time is to show the validation error if we actually submit an empty post because if we click submit if we open our console we see that we get an error but we're not showing it to the user so let's fix that let's go to our app let's go to the make sure you have your server running let's go to the post form so here we've already extracted the error object so we just need to go under the form here and we check for it so we'll say um error and end and that means if we have this error then let's show a div with the class of ui so dot ui dot error dot message let's tab this has given us an error because we can't put two uh sibling com elements under one component so we can just do this which is shorthand for fragment and we can just put that code back in and now we can say we can put a ul with a class of list and put our errors and we only have one so we don't need to loop through anything we just put in an ally and inside of that we'll put error dot graph ql errors and we get the first one dot message like that and that should take care of it uh one more thing actually here inside of the input we want to use the error boolean to invalidate the input itself and make it red so here we'll check for error we'll do a ternary so if error is truthy then uh the error is true else it's false all right let's save and make sure we have no errors and i've said error like a bazillion times all right let's check now if i don't type anything and i press enter there we go again post body must not be empty now let's give this some margin because that looks uh that looks weird all right so here let's go let's give this a style just an inline style and we'll say put another object we'll say margin bottom oops bottom uh let's give it 20. let's save let's look at that even if you put spaces by the way it will still be not valid all right cool that looks better okay so actually one other thing that i wanted to add is the transition group because right now if we just post something it just kind of snaps in which doesn't look that good uh semantic ui makes it really easy to use these like really cool like transitions if you look at this leaf how it shows how it leaves and we can control uh no pun intended with the leave and leave we can control as well like the duration of the transition we're just going to use this group transition thing which is pretty cool if we look you just get transition from semantic ui and you wrap everything in a transition group here they're using a divider and size and everything but we'll just use the duration so let's go to our actually you know in the home so home and here we'll get transition from a semantic ui transition so right here where we loop through all of our uh posts we need to wrap all of this inside of a transition group so let's cut to this and then here we'll say transition position dot group and here we'll actually we need to put it in curly braces and we'll paste it back so let's save that let's look at it so if we add another one there you go it doesn't just snap in it just shows kind of like it fades in and later when we delete them as well they fade out and then it kind of moves back all right so in this class we're going to work on these buttons make them actually functional and add like a delete button by the way just as a reminder if you haven't subscribed please subscribe to the channel and hit the bell button so that i will annoy you with every video that i drop i usually post three a week so i'm not going to be that annoying okay all right so let's actually jump into the code all right before we work on the like button i just want to um make this comment button it's gonna have simple functionality which is when we click on it it's just going to take us to the page of that of that post and i want to add the delete button on this side as well if it's our post so that we can delete it all right so let's go here let's go to the postcard so right here this um right here this is the comment uh button we're just gonna wrap the whole thing in a link or can we make the button itself as a link actually let's try that so let's remove the on click and here we'll say as uh link and we'll say two equals slash actually this is dynamic value dynamic value so we'll do backticks we'll do a slash posts slash the id because we already have access from to the id from the props all right let's see if that works do we have link imported yeah we do okay let's look at our app all right cool it works so if we click on that it takes us to the id of that post okay let's add the delete button i'm not going to add functionality but i'm just going to add the dummy button for now for us to have the delete button we need to access the user because of course we need to if we have to be logged in and we have to have this post as our post for us to be able to see a delete button on it so here we'll get the we'll import the alt context so we'll say import auth context from we go back one level to context slash auth and we need the use context hook so let's say here use context context like that and here at the top we'll say const will extract our user or destructure our user from use context auth context so right here we don't need this comment on post anymore and here at the bottom right actually yeah here after the uh the like button we'll do a an expression and we'll check for the user so if we have a user so we're logged in and user.username equals username so what this means the username of the user that we're logged in as if it's equal to the username of this post that means this is the owner so we need to show a delete button on this postcard so we'll say and end like this that means if all of this is true then we'll show the following and the following is a button so button um as div and we'll give it a color of red because the delete button and we'll give it an on click for now this is just gonna like um we'll just have like a callback and it will console.log delete post like that and we'll put a an icon inside of here so icon and the name of the icon is trash which is going to give us a um a kind of a trash bin icon all right let's see if that okay so it vs code auto imported those things for me which is pretty cool so let's save let's look at our app so there we go so user all the posts by user which is the user that we're logged in as have this delete button in them but this delete button looks a bit weird let's inspect it okay for some reason this uh ui button inside has some margin some like negative margin on the side yeah negative three let's uh just override that so this icon we can just say style equals uh oops put an object here and we'll just say margin 0. let's see if that fixes it all right cool we can give this button a floated property so this button right here will say floated and let's give it the floater to the right so it floats to the right all right cool it looks much better now it's floated to the right and we can click it and if you click it it's just going to say delete post of course we'll add functionality later all right so the like button what i want to do with it i want to make it into its own component so that we can have like leaner components like i said more modularity plus we're going to need this button on the single post page as well so that will we don't re repeat code across components so this is the like button uh no not this actually it's this let's copy let's cut the whole thing and here we'll put a like button component like that oops like that and so here we'll import that so we'll import import like like button from i'm gonna put this in where are we in components yeah we're in components so so from the same directory like button now this like button is going to need to access some things because this like button needs to know uh the use um not the username it needs to know the number of likes so that it shows it and he needs to know the likes of this post so it determines whether this user has liked this post or not and it needs to know the idea of the post itself so that it would look in those post we can pass it the entire post but that's not necessary well we can pass it a new object uh with just the id the likes and what else uh yeah the like count the like count like that all right let's save and let's create this new component so here we'll say new file like uh button dot js we'll get a couple of things so react and use state oops not parentheses black curly brackets or braces so let me get use state uh from react uh we'll need link because we could be not logged in and we want to go to the home page if we click this or the login page rather from react oops router dom we'll need the use mutation hook from react from apollo from apollo react hooks and we'll need gql as well to write our graphql query or mutation from graphql tag okay so we'll say function like button it's gonna take the props that we had so from that we'll destructure from the post we're gonna get the id the like count count and the likes all right so here at the bottom we'll say export default like button okay we need to access the user here actually we can just pass it here i mean we can access it with the with with importing the context but it will be kind of easier to just prop drill it will say user equals the user and inside of here using that user object we're going to determine whether we've liked this or not because we've if we've already liked this post we want to show the button okay our app is broken but we want to show the button like kind of filled with green otherwise you want to show it like outlined and as well if we're not logged in we want to show it outlined and if we click on it it takes us to the login page so here we need to determine whether we've liked it or not so first thing we use use effect so actually we need to import use effect so we say use effect and our callback so callback like this will uh check so here we'll say if user so of course we have to check if we have a user first if we're logged in and now that we have the likes we can check and user dot find and let's find a like where the like dot username equals the user dot username so here we'll say like that which means if any of the likes on this post have a username of this user that means this user that we're logged in in or logged in as has liked this post so we'll say oh actually we need a liked boolean as well so here we'll say const liked and set liked equals use state let's just give it a default value of false and here if this is true that means it's like so we'll say set liked to true else set liked to false and here we'll give it a dependency array of the user and the likes themselves if any of these change recalculate the value here we need to return our button so so what we copied from earlier we put it here and i think we're going to change actually we're not going to change much here this will be a dynamic value because we don't want to either fill it or not we want we need to determine whether we've liked this post or not so here we'll say we cut that we'll say const like button button like this equals and uh actually we're gonna put it here so let's just put it now like button now here we need to check for the user so i'll write this and i'll explain it right we'll do a ternary operator and then parentheses so if user and now if liked so another ternary operator and here we'll paste that back in but here instead of basic we're gonna have the filled button because we've liked it so it's gonna be filled so else if we've not liked it let's paste that back in and it's gonna be that it's gonna be the outline button now here outside of this parenthesis we do another colon so else if we if we don't have a user that means we're not logged in so we'll have the same button and it's going to have basic because it's going to be outlined but this should be a link to the login page so here we'll say as link did we import link yes so as link to um this is going to be to slash or actually just like that slash login all right i think that should take care of it uh now one thing of course we need to have an on click this like post we need to have the mutation so let's write the mutation down here here we'll say const like post mutation equals gql gql oh i misspelled that okay gql mutation like post is going to take a post id our server code and it's going to be of type id and that's that's required and it's going to trigger the po like post mutation and we'll pass this a post id of dollar sign post id and we'll get a couple of things and i'll explain later why we got those things and hopefully this time i won't forget to explain because i did this thing last time where i said i'll explain later i forgot to explain that thing all right if i do that by the way you can drop a comment and tell me oh you forgot to explain that and i'll explain it to you in a comment okay so i'll leave that like that and now we need to use use mutation to get that function so here we'll say const like post here we'll get the error actually we're not gonna have any errors so here we'll say use mutation we might have an error but the error would have to be that our token is expired or something and that has nothing to do with the like post so we'll just get the like post function so here we'll say use mutation of course we'll pass it our like post mutation and we'll have some variables and the variables will be uh the post id and that's going to be the id that we have from here from our props all right that should take care of that and that's named the same as this one so that should be fine uh everything here should be fine actually let's save all files let's look at our console okay there's a couple of problems here we need to get button and label from semantic ui so let's say actually up here we'll say import button label and icon from symantec ui react let's save user is not defined oh yeah we need to actually get the user as well from our props uh like post is defined but not be used in postcard yeah okay postcard oh yeah okay so this is useless now let's remove that and let's save no duplicate props allowed in postcard line 30. okay so we're passing we're passing the user oh no hi here okay this should be as the link let's remove the div all right okay cool so oh that's working all right so this one that we've liked is actually filled this one that we haven't liked is empty and if we click there we go it likes and it actually increments it and if you notice if we go to our apollo cache you'll see that it's actually updating okay let's make this a bit bigger cache root query so let's look at the first one right it has zero likes but if i like it now it's actually updating it now you might be wondering how is it updating the cache without us having to say proxy.right query or something like that but the way that's happening is because let's close that if we look at our mutation we're specifying the id of the post that we're getting back so we're getting back a resource of type post and apollo is smart enough to realize okay we're getting a resource of type post and it's got this id that means let's update our uh the post that we have with this id with any of these fields these new fields that we've received so it does it automatically we don't have to do anything which is pretty amazing actually so we didn't have to write any code to change our clientside state one thing that i don't like right now is that if we like a post it kind of stays focused focused when we have to click away for the color to change so let's inspect this and this the ui button okay so the button has this color so let's copy this this is the normal color so if we focus it becomes this dark color okay so it's this rule right right here let's copy this rule all of that okay okay let's go to our app css and here let's paste that and we'll say background color background color and let's take that color again from here it's got that let's paste it here let's save everything all right so now even if it's focused it's going to be that bright color and not the darker color all right so that's working and so that's i think that's it for this video yeah that's it hello class so instead of going to sleep on time tonight i decided to record this video sleep is for the week hey let's hope i don't regret this decision in the morning all right so welcome to class number eight i think it's number eight yeah all right so last in the last class we did these buttons and we uh added functionality for the like button but right now we're going to work on the single post page because right now if we go to it it's just empty so um the way we're going to approach this we're going to we're going to get this id from the url and then use the get post get singular post mutation or rather query and then fetch that post and display it in this page so let's get to that okay first thing is let's create a route for that by the way make sure your server and your client are running as per usual let's go to the app.js and here at the bottom of the container we're going to add another route so route and we'll have exact path will be slash posts slash colon post id like that and the component will be a new page called let's call it single post let's import that up here so import single post oops from pages slash single post okay let's create that so here in pages i'm going to create excuse me singlepost.js and here the usual will get react from react and we'll say function what's wrong with that import okay there's some ts thing for some reason but let's let's ignore that for now let's say single post i'm gonna need the props and i'll tell you why later here let's uh export default single post so here first thing we need to get the post id from the url so we'll say const post id equals and we'll get this from props dot actually this is one other reason why we need props dot match dot params so the url parameters and we call this post id so we'll get that and let's write the mutation right now or the query rather so here we'll say const we'll call this fetch post query this will be gql this would be a good time to import gql as well so here we'll say import gql actually gql from graph ql oops graphql tag and here we'll say query and this needs to take a post id of type id and that's required and this will run the get post query and we'll take a post id that's actually our post id and here let's get everything so id body created add username and get like count i'm gonna get likes and from that we'll get uh just the username and we'll get a comment account we'll get the comments and get from the comments we'll get the id the username uh the created ad and the body yeah that's it let's uh save so that formats and here let's start to create our markup and then and then see what we need so this will be conditional so we'll say let because this depends on whether we're logged in or not so we'll say post markup or actually not not logged in whether we have the data from the query or not yet so we'll say if um actually let me get the get post so we'll get the use query hook so we'll say import use query from at apollo react hooks and here we'll say const and we'll get data and straight away from that we'll get the get post field and here we'll say equals use query and we'll pass it the oops fetch post query and this needs some variables and the variables will be will be our actually we'll do an object and we'll say post id like this meaning it's going to be post id and the value will be this post id right here um we can here do a console log of post id to make sure that we're getting our post id just in case and here so here we'll say if not get post because we might be still loading we'll say post markup equals and here we'll just put a paragraph and say loading post uh feel free to put a spinner here but i'm just gonna leave it as a um as a paragraph for now and we'll say else so else if we have the post uh we need to get all the fields from the post so we'll say const and we'll use destructuring and we'll say id body created at get username what else comments get likes uh like count and comment count say equals uh what is it uh from yeah from get post let's make this wrap so press alt z okay so now we can say post markup equals and we'll use the grid and inside of here of course we will need to import these in a bit but let's uh do a row here and uh right here i want to have the um an image but of course this is hard coded so it's the same like in the postcard component so i'm going to grab this source attribute so i'll just copy that and we'll come back here we'll say so this will be inside of the image tag oops image like that and let's paste that source attribute and i'm going to give this a size of small and let's make this float to the right so we'll say float oops float equals right and we can close it like that actually this needs to be in a column so i'll cut that and say grid red dot column and let's actually give this a width of two and here we'll put our image back and now we're gonna have the rest so the rest will be a grid with a width of 10 because that's the the number of remaining spaces let's remove this image and here we'll have our card so let's put card let's give it the property fluid so it takes up all the width and here we'll have as per usual card dot content here we'll have a header so card dot header this will be the user name so i'll put uh an expression and say username or curly braces but username we'll get meta which is the created art so card dot mata and oops here we'll say curly braces and we'll say actually we need to format it so i will say we need to import moment a moment it will say import moment from moment let's go down here we'll say moment we'll pass it the created at and say dot from now and uh yeah that's fine here we'll say card description scription and here we'll just put the body of the post um underneath these uh this card content let's put a ruler a horizontal ruler to have a line between them and here i want to put the like button and the comment button just like in the card since we have those in their own component we can just attach them here so here we'll say um another card uh content this will be the x we'll give this extra the extra attribute and here we'll say like button we need to import that but let's actually we need to pass the user to the like button so we need to import the um the auth context so here we'll say import auth context from go back one level to um context slash auth and we need to get the use context hook from react so use context up here oops con text and up here we'll say const and we can destructure it we'll say const user like that equals use context and we'll pass our auth context so here we'll pass our user and it doesn't matter if we're not logged in so right here in the like button we're going to say user equals user and we'll pass the post like we did in the postcard but we're just gonna of course pass the id the like count and the likes array so that the button determines whether we've liked it or not and uh here let's close that and let's put the comment button which is not going to do anything for now but we'll make it do in stuff in the future let's give it the basic attribute and or actually no let's make it as a div and here let's say label position equals right so we'll have that um kind of arrow to the left so let's say on click equals for now it's just gonna console.log console.log and let's just say comment on post we'll make this do stuff in the future but for now we'll just leave it like that and inside this button we're gonna have another button so a button this is the basic button because this is the uh kind of cloud thing uh here we'll say color is blue oops and inside of the button we're going to put the icon so it'll say icon um the name of the icon did we use comment or comments so right here yeah comments so we'll keep using the same icon so here we'll say comments let's close that and underneath this button we need the label and we need to show the number of of comments so here we'll say label basic and the color is blue and this label will be pointing to the left pointing left like that and inside the label we're just going to have comment count um here actually we need to show the um the delete button uh but we already have that in the postcard but actually it's not doing anything right now i forgot to add functionality to the delete button because right now it's not actually deleting the post so we can take care of that right now so what we need to do we need to put this delete button into its own component so let's go to the yeah right here so where this button is we can just cut this and we'll say if user and the username of the user is the same as the username of the person that posted this so we'll say here delete button and this delete button is to access the uh post id so that it would use the delete post uh or remove post mutation so here we'll say post id equals we have this id yeah we have this id and id we can just say post id equals id like that and uh we need to pass it um actually i don't think we need to pass it anything here yeah let's just um close it off and here let's say import delete button from uh same directory delete button because remember this is we're in the postcard and here in the components let's create a delete button.js file and here we'll import react and of course we'll import gql from graph ql tag and here we'll import the use mutation hook from add apollo react hooks and uh we're gonna need the button because that's what we copied actually let me make sure let me check what we copied so here i'll say function delete uh yeah that's showing an error because of this i'll just comment this for a second delete button it's going to take the props and let's just export that for now export default delete button let's say return let's put that okay so we need button and icon so here we'll uncomment that we'll say button and icon from semantic ui react so let's go to the bottom here and let's write the delete post mutation so we'll say const delete post mutation equals gql open the tag template and we'll say mutation delete post and this will take a post id of type id and that's required and it will just call the delete post mutation and pass a post id of value post id now we don't need the return um from this we just need to make sure that it runs successfully so we can just leave it like that and we'll go here and use our used mutation hook and get the uh the callback function from that or the trigger function so we'll say um const i'll say delete oops delete post equals use mutation and we'll pass our delete post mutation and here we'll need some variables so inside of this we'll say variables and we'll have post id like that and we'll have an update here update i've we can get a proxy well i don't think we need the proxy actually for now we'll just say update and um the way i want to set up this i want to set it up so we have like a confirm uh model because we don't want to if a user by mistake clicks the delete button we don't want it to immediately click we want kind of like a model to appear that says are you sure you want to delete this post and then when a user then clicks yes i'm sure then it actually deletes it so what i'm gonna do here we're gonna get something called confirm from from symantec ui so get that confirmed but this this has a boolean like whether it's open or not so here we'll uh actually let's get use state as well so bear with me a moment this will make sense in a in a second so here we'll say const confirm open and we'll have set confirm open equals use state and by default it will be false oops false and let's go down here in the um in here so underneath the button we're going to put the confirm so we'll say confirm and here we'll have an open um boolean which will be the confirm open so confirm open like that and by the way this is in the documentation if you want to check check it out and you'll have a an on cancel function and this is when you click so you get this model and it says yes or no and this would happen when you click no so when we click now we just want to close the uh the confirm model we don't want to do anything so we'll just set this confirm open to false so we'll say set confirm open and we'll pass it the value false and we need an unconfirm so on uh confirm and this is so this is when we actually uh say yes we are sure we want to delete the post so we want this to call the uh the delete post function from used mutation and here let's close our confirm this is a problem because we have two sibling components inside one component or rather you know elements so here we can just wrap everything in a fragment so that error is gone now and let's go up here so here in the update uh once the once we reach the update that means the post has been deleted successfully we want to close the model so we'll say set confirm open to false and of course this will not disappear from from our front end because we're not removing it from the cache but let's do this later so i'll put a todo here so i'll put a comment and say to do and say uh remove post from cache so that the change is reflected on the front end without us having to fetch the posts again and um okay so we'll say here oh okay we need to put a comma here by the way this is the to do highlight extension that that highlights the to do all right so i think that's fine or actually here the post id is not just post id it's coming from the props so we need to say uh prop or actually we need to just destructure it so here we'll say post id like that uh i think that's fine so let's save the delete button and let's save the postcard but let's not save the single post and let's go to the pay uh to the app component uh and just remove a comment for a second the route and the import so that we can just test the um we can test the postcard alone let's make sure we don't have any errors okay so set confirm open is not defined because i misspelled that right here that's a capital c save all right cool it's running let's check it out okay so we get syntax error name found something let's check our mutation there's a problem there mutation delete post okay here it's just a post id like that and uh i'm gonna do it like that here all right okay so we get this and if we click on the delete okay nothing happens it doesn't delete it okay there's something wrong okay we want when we click this button it doesn't just say delete post it actually sets the model to to open so we'll say set confirm open to true and let's save okay let's look at our app so now if we click it sets the model to open if we click cancel it just closes it and it doesn't delete it we can just refresh to make sure it doesn't delete it and if we click delete now and you click ok it actually deletes if we open the um if we do f12 when we go to the network and uh for some reason they didn't show up because i didn't open it previously but if i um refresh you see that that post was deleted so if we post a new one and we click here and we delete it of course it doesn't remove it like i said but if we refresh it's actually deleted okay so the delete post button is working so now in the single post we can um we can start to we can put that delete post button and it will work as well okay let's close this terminal and let's uncomment the import of the single post component and uncommented the route let's save that let's go back to our single post so now now here at the bottom right here after this button we can put the delete button so we'll say if user so the same stuff from from single post uh from postcard rather so if user and user dot username equals username which is the username of the post we'll say and and we need to render our delete button so you can say delete button and we're going to import it in a second and we're going to pass it post id equals id oops id like that and let's close that and let's go up here and we'll say oh we didn't even import the like button actually we need to import a bunch of things here so we'll say import oops import like button from go back one level to components slash like button and we can copy this one line paste it one more time and ctrl d and say delete button and we need to import a bunch of things from semantic ui so we get the grid the image the card the button okay so here we'll say port button card um grid image from semantic ui react and let's save okay so we need icon and label as well so we'll say icon and label let's save all right so it says post markup is assigned a value but never used because we need to return it we need to return something actually some markup so here at the bottom we'll say return post markup let's say all right says comment comments is assigned a value but we're not gonna worry about showing comments right now all right so let's look at our post all right there we go so this is a post by user okay flux this is a post by user and we get the delete button so if we click on that okay so it deletes it because it actually deletes it but it doesn't we need to redirect to the home page so you see if i go to the home page that post that was called another one is removed so the way we can do that uh we can pass a call back to the delete button so here let's say callback equals and let's call this delete oops delete button callback let's be let's be kind of uh or delete post expressive with our function naming so here up here we can say function delete post callback we say props dot history push and we'll just go to the home page so we got props so that should work and inside the delete button uh we need to take that call back so here we'll destructure as well callback and so right here actually in the update once the uh the post is deleted we need to call the callback okay but the problem with this actually the callback might not we might not have a callback so we can say if callback we call callback like that because from the postcard we don't actually have a callback so we'll do this if check okay let's check that we have we have no errors we don't so if we go here go to this thanks guys and we click on delete and we click ok there we go actually read our access to the home page and is deleted because if we refresh we see that it's actually deleted all right let's now add this um remove let's remove this post from the cache once it's deleted so let's remove this to do comment and we need the proxy right now so we'll from the update we'll take proxy and we'll say we need that fetch posts query so here let's say import fetch posts query from actually what is that where is that util slash graphql ql if i can talk so graphql like that and uh right here yeah right here before calling the callback we'll say uh like we did for the adding post we'll say const data equals proxy dot read query and we'll pass a actually an object oops an object with the field query and that query will be the fetch post query so now that we got the data we'll say data dot get posts and we'll say equals data now we need to remove a post so we'll say data get posts dot filter so we want to keep all posts so we'll say postwar post.id we want to keep all posts that don't have the same id as this post id that we just deleted and we'll say proxy dot write query and here we'll say query is fetch posts query and the data is data like that okay let's save let's check out our app let's post a new one and now if i click delete and i confirm there we go it's gone and uh if we go to the single post page well by the way the uh we can test the like button so we can like and go back to the home page and it's actually liked so that's working from within this component so from uh from within this page we can click delete post it redirects us and it deletes the post okay so that's it for this video welcome back to class number nine in this series um in this one we're going to be adding the comments on the single post page and allowing users to post them and delete them and all that good jazz all right so let's get to it okay let's go to our code codebase so here in the single post component i'm going to scroll down actually here where this card ends still inside of the column we're gonna do the way we're gonna we're gonna display them is i could put them in a component of their own but i don't see any need in an application this small so we already have comments out of this um thing like destructured from get post which by the way is the reason why we have a warning here because we're not using comments but we're gonna use them now so here underneath the card we're going to open an expression say comments oops not comment count comments dot map and for each comment we're gonna oops not like that yeah like that actually confuse myself for age comment we're going to return the following so the comment is going to be a card of its own and yes we can nest cards so let's give it the property of fluid so it takes all the width and here we'll give it a key of comment dot id which is unique so inside of the card we're gonna have a card content so card content and inside of here we're gonna have the header so card dot header and this will be the username of the of the person that commented so comment dot username like that and underneath here we'll have the meta card dot meta which is when it was posted so here we'll use moments to format it i think we have yeah we have moments because we formatted the date of the post itself so here we'll say moment oops moment uh moment with one m in the middle and here we'll pass comment dot created at and we'll say dot from now like that and here we'll have the card description kind of similar to the actually almost the same as the actual post but this is these are comments so here we'll say comment dot body all right let's save let's make sure there's no errors there shouldn't be any errors cool that warning for comments is gone and if we switch to our app okay this one has no comments we can go to this one has three comments and there we go we get comments and uh yeah i agree with this comment okay so let's make it so that um our comments we can delete and by the way i need to log in here so i'll say user and the password is one through six so let's go back to that one where is it this one so here uh since i'm the user i want to be able to delete this comment so let's go back to code and i'm going to add the button right here inside of the content so here we'll say if user because we already have user from the context we say as well and user.username and equals the comment dot username which means i am or whoever this user is is the owner of this comment so we'll say and and we'll render the following and we're actually just going to render the delete button and we'll pass it the post id and which is the id and we'll pass it the comment id and uh i'll explain in a second which is comment dot id now what we're gonna do we're gonna go to the delete button component so let's go to the delete button and here we're gonna make it so that this can delete a post and it can delete a comment as well and the way we're going to do this we're going to make this mutation right here dynamic let's go down here let's write the delete comment mutation so i'll say const delete oops delete yep that's spelled correctly comment mutation this will be gql open template string and inside of here we'll say mutation and delete oops delete comment and we'll pass it the post id which is of type id and it's required and here i need to put a dollar sign and here we'll say dollar sign comment id and this will be an id as well and that's required and here we'll say delete comment and we'll pass the post id which is going to be the dollar sign post id and the comment id which is going to be the dollar sign comment oops id i'll get the id we get the comments and get the from the comments we'll get the id the username the created ad and the body of course and here we'll say we need to get the comment count and yeah that's fine we can save let's go up here now here what we're going to do is instead of just saying delete post mutation here we're going to put another variable we'll just call it mutation like this and this will be dynamic so we'll say const mutation equals and here here where we destructure post id let's as well destructor um instructor i can't talk guys sorry so we'll destructure a comment id and here what we need to say is comment id uh we'll do a ternary operator so if we want to delete um if you want to put this button to delete a post we're just going to give it a post id and a callback or maybe not a callback and if we want to delete the comment we're going to give both of them so if we have a comment id that means this button is a on a comment and not on a post so we want the uh delete actually no we want the delete comment mutation here if we do have a comment id else that means this button is on a post so we want to use this mutation the delete post mutation now here we can change the function name we don't have to but it's better if we do and i'll call this delete post or mutation because it can be either and we'll do the same we'll say use mutation or we'll pass this mutation whichever one it is and um one thing we need to change by the way here is let's wrap all of this let's cut this and we'll say if not comment id do all of that oops uh paste because if we're deleting a comment we don't want to do this because um it automatically removes the comment and we don't want to remove any posts from our get posts but if we do delete a post then we will not have a comment id then this will execute and everything will run just fine and here in variables we need to also pass the comment id and by the way this is not a problem if we're calling the delete post mutation this will just be ignored in that one and it will be null anyway so here uh i think everything is fine except here we need to change delete post or mutation right right there and let's save this let's go back to our single post save that and let's look at our app so there we go we get a button and if we click it and we say okay there we go it deletes the the comment and with hopefully no errors yes no errors cool all right let's add a input here so that if we're logged in we are able to post uh comments to this post all right let's go here actually right here just above the comments we're gonna say i'm going to open an expression and say if user because we want to be able um we only show the comment input if we're logged in so if we use a if user render the following and we'll have a card as well here it's going to be fluid and before we do any of this let's create the create comment mutation so let's go down here let's say const let's call it um or submit makes more sense uh it doesn't matter this name but so uh submit comment mutation equals gql and here we'll say whoops we'll say mutation and it will take two things the post id uh which is an id and that's required and actually here a dollar sign and here we'll take the body and that's a string and that's required inside of here we'll say create comment and we will pass a post id which is going to be dollar sign post id and here we'll pass a body which is going to be dollar sign oops dollar sign body and we're going to get back a post so here we'll get the id because we need to get the id so that apollo knows which post to update and we need to get the comments because that's what's been updated in this object and we want to get id body created at and username all right inside of here we'll say comment count because that updates as well so we need to get it back and update it and yeah that's fine let's go way up here underneath here we'll say const and will this array destructor the structure submit comment from use mutation and we got used mutation no we don't let's get that use mutation from react polar hooks and here we'll say mutation and we'll pass the submit comment mutation and we're going to have a an object here i have an update function or just a regular function an arrow and here we'll uh what we need to do is actually we need to as well create a comment state variable so we'll say const and i'll have a comment do we have your state actually we need to use state use state and here we'll have a set comment whoops equals use state and the original state of the comment is just an empty string all right so we want once we submit the comment we want to empty the uh the input so here we'll say set comment back to an empty string and we need to pass the variables for this mutation so variables is this object with the post id which is just this post id so we'll leave that like that and with the body of um comment this one right here there's something wrong here i'd put double colon all right that's fine so everything's fine here we just go back to our mockup here and we actually add oops where is it oh right here oh yeah right here it closed itself that's why it confused me all right so here we'll close the card here we'll have a form actually before we need to to have like a sort of paragraph that says post a comment and here we'll have a form uh do we have form yeah we don't so here we'll say form and let's go back down here inside the form we'll have an input um thing is i want to use form input but there's a problem which i'll uh i'll explain later why i'm using just the regular material sorry not material ui semantic ui css i'll explain later so here we'll just say div with a class of ui action input oops input and fluid which is kind of like the equivalent of using field input or input or rather form input so here we'll have a traditional html input and here we'll have a type of text and a place oops place holder and we'll say comment dot dot i have a name we will say just comment like that will have a value which will be the state variable comment we'll have an unchanged on change we can just inline it here we'll say event we'll take an event the event and we'll say set comment to event dot target dot value like that all right let's close this input and here we need a submit button so say button type submit and here we'll have a class name of uh ui button and teal for the color teal and here we'll say disabled if the comment uh if there's no comment there's no nothing written in the input field i want this button to be so disabled to not have to deal with the validation so if comment.trim equals an empty string then this button will be disabled otherwise it will be enabled and it will be clickable and if it's clicked we'll say so we'll say on click submit comment all right here we'll say submit all right that's gonna that should work fine it should trigger the submit comment and that will send a submit comment mutation with the variable comment which has changed because we typed stuff all right let's save this and let's make sure there's no errors there isn't sweet let's go back here and oh that looks weird let me make sure i got everything right oh yeah because everything inside of a card needs to be in a card content so let's cut everything and say card dot content it gives it that padding amongst other things let's paste everything back save let's go back to our app there we go that looks much better now if i write something now this is clickable and if i press enter nothing happens all right let's uh inspect so many errors uh error code 400 response not successful let's check out what happened with the actual so let's go to apollo mutations and we get this mutation the body is okay and the post id is correct um let's try to run this mutation strange post id okay post id variable post that is used expecting type string really uh let's go to our graphql type definitions create comment oh i made a mistake here post id instead of putting that i'm expecting an id i put i'm expecting a string well i'm not going to change it here because for those of you that are just doing the react bit who will you'll be maybe confused or something i'm just gonna go to the um this is just a patch by the way if in an actual app i'm not gonna do this uh fix like this i'm just gonna change this actually not delete it's the create comment or submit comment here i'm just gonna take uh change the type to string all right that work i mean that runs let's go here if i type some some random comment and i click enter there we go it's uh it's submitted and i get it here and i can delete it and i can delete it and if i keep typing comments it keeps adding them without any problem and we have no errors sweet all right so there's one little problem that bothers me is that once we type something and we click enter this gets emptied but this field is still um active like kind of um i can still type stuff i don't want it to do that i want it to be kind of go back to this state blurred all right so and this and here i can explain why i did this approach where i just used an input because now i can give it a reference so we'll say ref equals say comment input ref because i can't give a reference to the form input component of a semantic ui react because that's actually a react functional component all right so let's actually create this reference let's copy that let's go to the top and right here underneath user we'll say const comment input ref equals use ref and initially you'll just pass it the value of null and we need to get user f so here we'll say use ref from react and right here we're just going to say actually not here and the submit comment after we set the comment to an empty comment we're just going to say the reference to that input dot current dot blur like this call it like a function like that and that's going to blur the input once we submit oops once we submit that so right here uh yeah here i'll type a comment and i'll submit it and there we go it becomes the like out of focus like blurred if i do that again it blurs out the comment um comment input sweet i think that's it for this video yeah let me check yeah that's it all right sorry guys by the way if i'm like kind of i sound less energetic and excited about stuff i am excited but i'm really really tired so hello class welcome back so this video is going to be one of two last videos in the series um this one is very going to be a very brief one where we implement popups and i'll explain them in a second and in next one we're going to have a deployment so we're going to deploy both the back and then the front end of our application to heroku so back to the popup thing so what i noticed right now in our app is that most of our buttons are just icon buttons these buttons right here the like the comment delete etc the only problem with this is that there's no text and some users might be confused as to what this button does so what we can do is um introduce these tool tips these popups that if you hover over it tells you what this button does of course you can do many other things with them so the idea behind this is to improve user experience and make your app more more easy to use and more intuitive so there's more complex implementations of popups for example this one right here that shows info about the user actually this could be a cool challenge for you that you can implement where if you hover over this image it tells you since when this user has signed up or you can show any other things and of course this you can embed any html in it you can see here the show your rating and there's some other cool implementations um of the popup uh for now we're just gonna use the basic one to display some text so let's get to that all right so let's go to our code base oops now you my sql let's go to the code base uh make sure both the server and the client are running as per usual i'm going to close this console uh first i want to start with the comment button so here i want to say comment on post when i hover over it so let's go to the postcard and here we're going to import pop up from semantic ui react and let's go so the way it works is that you basically wrap your um your element that you want to use as a trigger when you hover the popup and you put this popup and you put your element inside of the trigger component or attribute and or prop rather and you have your content here which is what the popup says so let's go and actually apply this so we have our button here it's the comment uh button so we can take all of this or actually just type here say popup and the content content will say um comment oops comment on post and here we'll have a trigger which triggers this and the trigger will be all of this button right here so we can just cut this and paste it here and let's close this tag let's save to let prettier format and let's have a look at it so let's go to our app so this is our comment button and there we go we got our popup but i don't like the white popup because our background is already white so i'm going to use the inverted version of it to make it be black with white text so we are right here we can just add this prop inverted and save and go back and there we go i think this is a better contrast for our application all right let's do the same for the like and the delete buttons so i'll start with the delete one so let's go to delete button here let's close that so our button is right here so we can just we need to import popup from semantic ui first so pop up and here we can uh cut this button for now and here we'll say popup and we'll have content and this will say delete post i have a trigger and in the trigger we paste back our button and of course we add inverted to uh have it um be black all right let's save let's look at our delete button and there we go it says delete post um one problem with this though because we're using the delete button for the comments as well and it will still still say delete post here while it should say delete um thing comment we can make take a um a message but for our use case we only have two things so we can have a conditional here so where are we right here in the content we can make it dynamic and what we're going to do is we know if we have a comment id that means we're deleting a comment a comment if we don't it's a post so we can say comment id so a ternary operator so if we have that that means we're deleting a comment so we'll say delete comment else that means we're deleting a post so we'll say delete post like this save uh why is this happening squiggly oh sorry this um this should go on the content my bad not the inverted the inverted is just a bullion prop and here it says delete post and here it says delete comment cool so that's working uh we'll do the same for the like now one thing that i noticed is that we're using inverted each time and we're kind of typing the same thing and it's taken multiple lines of code and we're going to use it in multiple instances so we can outsource this into its own component i mean maybe this is not the best use case for this but this is just to show you a good practice of how to outsource these mini elements that you have shared in multiple places in your app so here we'll create a new file in the util folder and we'll call it my popup call it whatever you want so here i'll say of course we need to import the popup so we'll say import popup from oops from semantic ui react of course we need to react itself here we'll have our function so function my popup i will take props and it will return the popup and our popup is always inverted so let's say invert it here and we'll have content actually we can destructure from the props so we want to pass the content we can pass whatever we want but we only need content for now and we want to pass uh children because that's where the trigger element we need to pass an element for the trigger prop so here the content will be content from props from the props and the trigger will be the children so whatever that's inside of this component here of course we need to export default my popup save this so let's go to the delete button let's remove this import and here we'll have our relative import so we'll say import my popup from go back one level to util slash my popup and here we replace popup with my popup and the content will be the same but we don't need to say inverted anymore and this trigger stuff will be in the children so here we'll have actual content inside of our um my popup element and here we'll put our trigger stuff as a child for this component all right let's look at our app let's refresh just in case and it still functions the same all right let's uh implement the same for the uh what is it the comment button so here we'll remove the popup and actually you can just copy this line from here or from here the import my popup i would have typed it already if i didn't just go to copy and paste it but whatever so here we'll say my popup and here the content will be the same it's static and we remove all that from the trigger and we put it inside my popup here paste just to make sure that it's still working okay it's not working inside of here we need to investigate this so oh yeah actually that's because it's coming from the single post that's a different um it's different it's here it's from here so in the single post let's uh do the same import oops actually i had a different thing in my clipboard so here we'll say my popup from back to util to my popup and let's look for that comment button should be yeah it's here so all of this so we can just copy all of this button and here we'll say my popup and the content will be the same as the other one so comment on post and the um doesn't have a trigger we will just have content child content inside of it and there we go we have comment on post so let's do the same for like let's go to the so that will be here in the actual in a postcard or excuse me in the like button so here we'll import that so import my popup from util slash my popup or your popup so here this like button we can just cut this let's say my popup and here the content as well is dynamic because um it can be for liking or unliking so what we're gonna do is we're gonna say liked and do a ternary so if it is liked the tooltip will say unlike unlike else it will say um like or you can put unlike post or like um post it's up to you all right so we paste back actually this should should be in an expression in curly braces and let's save let's look at our app there we go it says unlike and if i like uh if i unlike it says like again cool it's switching hello class and welcome back to the last class in this series where we deploy our application and have it live on the internet so i might have misled you in the last class by saying that we're going to deploy both the front end and the back end on heroku we're not going to do that we're going to deploy the back end on heroku and the front end on netlify which is something that i've used on this channel before and i've used for personal projects before it's pretty cool it's really easy to start with you just log in with your github and literally like two clicks and you deploy your frontend app and in terms of the back end we're going to use heroku like i said it's really easy as well to get started with i'm not sure if it's to be honest if it's something that people use a lot in production personally i would use something like aws or even google cloud or what is known as firebase uh but i don't know maybe they have some good pricing you can check that out for yourself but for us we're just prototyping just you know it's a hobby it's a project of passion i should say all right so let's actually get cracking okay first things first i noticed that there are certain things that need to be fixed about our in our code base first is i noticed that in the package json here on the server there are certain um dependencies that are for the client so we need to move this to the client so i'm going to do here on the on this on the server level i'm going to say npm uninstall um react router tom semantic ui css and semantic ui oops semantic ui react so we need to move these can i copy from here yeah i can copy from here okay so we need to move this into the client so i'm going to say cd client and say npm install and uh paste that in and that should be fixed so one other thing so in the index i noticed here when we connected a database uh we don't handle like we don't catch an exception or an error if it happens that's not good because um you know this can actually crash your server and your app wouldn't even run at all so here we're gonna say we're just gonna say console.error the error uh it's not going to change a lot but we catch the uh the error if it happens 16 000 vulnerabilities this this npm order is getting out of hand anyway i'm going to ignore this vulnerabilities thing for now um one more thing i want to change is the port so where's the port right here so it says 5000 it's a static port but in actual environments deployment environments we could have like an environment variable that holds the port and we might need to use that instead so i'm going to do i'm going to say here const port equals oops i'm going to take the environment variable so we're going to say process dot env and this is how you um access environment variables uh port like this um or so where's the ore right here the pipe thing or 5000 meaning if this is null we're going to get 5000 and here instead of 5000 we're just going to say port all right so that's fixed um i think we're done with fixing stuff all right so one thing that i'm going to do we can actually deploy both of them um like in one code base like the front end and the back end but i've found certain problems that happen on netlify where if you have like a subdirectory that contains actual app there are certain shenanigans that we could avoid by just separating the client and the server to their own repositories i mean it's better for separation of concerns anyways so i'm gonna do i'm gonna go back to my desktop so i'm gonna cd twice i'm gonna create two files or folders rather directories so make the i'm going to say mang client and mug server cool so we have those repositories uh let's go to our desktop actually i'm going to open this folder so here i'm just i'm going to need the stuff for the server so let's select everything except for client and node modules uh copy that and then in the server um yeah in the merge server here i'm going to paste them and the client stuff everything except the node modules and paste the client stuff here oops paste cool so we got the client stuff here and the server stuff here all right let's create let's start with the server let's create a repository for this on github so oops not here let's go to github and here i'm going to create a new repository i can make it public or private doesn't make a difference so here i'm going to call it moong actually i'm going to prefix it with clast i'll probably delete this because it's not that important people won't need this so i'm going to say mung server and i'm just going to create the repo here i'm going to copy this i'll copy the ssh one it's the same but i think to push you can't do the uh the https one so here i'm going to open up git bash in the server directory i'm going to initialize the git repo actually get in it and here i'll say git add everything get commit oops if i can type all right so get commit i'm gonna say oops just in it i'm gonna now add the remote so i'm gonna say get remote add origin and i'm gonna need to paste that origin so here we're gonna double check say get remote dash v there we go that origin is added so we just now need to push the code so we're gonna say get push origin master all right so that's done so if we go here we refresh we see that our code is here all right let's do the same for the client and then deploy both of them so let's create another repo so here we'll say clast obviously you're going to say something other than clast if you want to say you can say that i don't mind all right so here classed man client create repo let's do the same thing grab this copy it and then go to the client uh open the terminal and here we need to say get in it i don't know why i'm adding that flag and and here i'm going to say get add everything get commit and i'm just gonna say init and here we're gonna say get remote add origin and because i don't have this button this like the inside button on my keyboard i have to like right click and put paste here we're going to say get push origin master and the same thing will happen to this repo for refresh we get our client wait we don't we do we do we get our client code here cool all right let's deploy our server code now so if we go to heroku actually let's create an account so sign up i've already done this but i'm going to show you how to do this so i'm going to put my name i'm going to put my email my class email so gmail.com company name not applicable professional developer united kingdom i'm gonna this doesn't matter it's just for the data collection stuff i'm just going to say no just there create free account and i'm going to now go in a side window and activate my account gmail there we go it says create new password i'm going to create a new password sweet click here to proceed all right so now that we've set up with an account um let's go back here i want to go to the documentation so documentation uh first of all we need to install the cli actually let's go to node and yeah getting started with on heroku with node so here introduction setup we need to install the heroku cli so if you're on a mac you just run this brew command you're on a linux you run this sudo install but if you're on windows like i am you just download this installer so i'm going to install it now yes next next and it's really simple you just install the cli and then you do this heroku login and uh it just opens up a browser window where you confirm your authorization and then that's it you're logged in i'm going to wait for it to install all right so that's done close it and i'm gonna close all this stuff here i'm gonna open bash so here i'm gonna say heroku login press any key to open the browser all right log in you are now logged in i should be logged in now how do i check actually well i think there's like a command to check but i'm just gonna keep going i'm gonna assume we're logged in yeah that says i'm logged in cool so stop that and now we need to get our app started now our app is already started we have the app so i'm going to browse into it so cd desktop and i believe it's smart server yeah server all right so this is our app now we need to push this to heroku so we go to deploy the app so we're going to say heroku create which creates an app now there's a lot of options that you can adjust here to change the name of the app and a bunch of other stuff but i'm just gonna go with the most basic uh deployment right now so in that repo here in the server we're gonna say hiroku create boom so that's done and now we're gonna say get push heroku master so now that everything is pushed okay so that's done now um let's go check our app where do we go actually apps where's apps or maybe in the command so here it says that this is the app so this is the endpoint for the app and let's paste that well it says error check logs so i'm just going to run roku logs okay now i know why because the npm start is using a dependency like a developer dependency i should have fixed that which is nodemon and instead it should just use the node index instead of nodemon that's not available during production so i'm just going to change this to node index and push this and hopefully that will fix it actually i should change it in the other in the other repo or in the other code base so let me open this and here i'm going to go to the package.json and change this start to just node index now let's open the terminal get add everything get commit and here i'll say fixed start script here i'll push to origin master actually i need to push to heroku master as well so get push heroku master all right so it's deploying that again all right so let's check out our app uh actually still deploying it's gonna give us the um the base url in a second there we go so let's click this control click this to open link we'll wait for it now obviously the performance on an actual paid account will be better than this you're not gonna have to wait this much this is just a test account it's just a free account just not charging us anything yet okay so that failed again and i checked the logs again and i made a booboo and it's uh right here so what is it so process existed because where's the error yeah it's right here process failed to point to port because actually apparently port has to be um all uppercase so let's go here let's make another change this could have been way smoother um so right here in the index.js so it's here port is all caps like that sorry about this guys but in real in real production things like this happen all the time so maybe not cutting them is actually giving you a better um a better like view of how things work in the real world so here i'm just i'm not even gonna push to um to github i'm just going to push to heroku master so now it's going to deploy again hopefully this time it works all right so let's control click this base url and i guess third time is the charm all right so we get get query missing but i believe this is just a like a um because this is just our graphql server i believe it's working so if we go to postman open a new tab and here let's send a request to this and as you remember graphql stuff is always a post request so let's go to the body we can use this graphql type of like body here here let's actually send like a get posts query i'm just going to get the body and the created at and start that query sweet we get 200 and we actually get all of our data so our server has been successfully deployed let's actually now deploy the client side of this all right so i'm going to close this close this and let's go to so here oh obs go away so in the client so let's open this now i'm going to make a couple of changes here as well so in the package json uh down down here i'm going to add something called a proxy because this is not on the same server like as the actual server so i'm gonna this is actually not super necessary but i'm gonna add it anyway so the proxy will be the base url of our app so here i'm just gonna copy that and go back and put here paste that and we're going to change something else so inside of our apollo provider the base uri for our api is that deployed app so we're going to paste that here as well so let's push these changes so i'm going to open the terminal say get add get commit and edited proxy and server base url let's push this wait have i added the heroku here actually no there is no heroku what am i saying all right so let's go to netlify and here you can sign up or log in i'm going to log in with my github account i already have like an app here deployed and here i'm going to deploy another one so i'll say new site from git and click github here and it's going to now authorize my github account or have authorized netlife to access my repos so i believe i named it clast monk client yes it's this one and we need the master branch and yeah we need to run actually this is all correct because the eventually when you build the app it's going to be in the build directory not in public actually so here we'll just say deploy site this will take some time you can click here to see what's actually happening behind the scenes in the deployment it's just going to install all the dependencies and build the app and then serve it from that directory that was specified which is the build directory so i'm just going to wait for this to finish and then carry on sweet so that's deployed successfully that's indicating by the indicated by the green color and we open our app and there we go so we get all of our content that's being served from our server and from our database and we get the app and it's fully functional so we can actually log in here if i haven't changed this password yeah it's 136. cool so we can log in we can post stuff it's working exactly like it worked on our machine guys so yes so this video has been a bit rocky has been a bit a bit of like errors i could have cut all this these errors but yeah this these things happen in the real world so yeah maybe it's better that i left them all right anyway thanks for watching guys this series has been exciting it's been uh sorry for the delay for the last video and i hope you've enjoyed it i hope you hope you've learned a lot uh please let me know in the comment sections any suggestions anything you want to learn or anything you want to dig into i'll happily make a video about it all right thank you very much and i hope to see you soon bye