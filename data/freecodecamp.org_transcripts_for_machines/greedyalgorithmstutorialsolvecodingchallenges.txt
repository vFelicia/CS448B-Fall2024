in many software job interviews you will be asked to solve coding challenges based on algorithms and data structures one type of algorithm that can be used to solve these challenges is the greedy algorithm greedy algorithms are used to solve optimization problems and they select the best result at each iteration in this course tanishq uses animations and diagrams to help you understand how to solve coding challenges using greedy algorithms let's say that you find yourself on a square on a green square in a 2d plane there's a voice that comes from above your objective is to maximize the goal because the goal you can get is the gold you keep all right all of this is pretty weird uh why are you on a 2d green square and what is this voice but now the voice continues and says that hey there are three rules that you need to keep in mind and if you follow these rules i'll let you keep the gold alright first rule you can move in any direction up down left or right second once a path is taken there is no going back third the game ends when no more steps can be taken all right so now you're pretty excited you have the rules in hand and you have the objective of maximizing the amount of gold coins you can get of course you're in a 2d plane you should get as many gold points as possible so what you do is you go ahead and follow the first rule i say that now i want to look in all the four directions so we'll go ahead and look in all the four directions and we see this we see that on the bottom square if we reach and if we go to the bottom square we'll get two gold coins on the left we have one and on the right we have three the top sell is a much more interesting cell saying that you will get one gold coin at this point of time you will get one gold coin when you reach this square and this square happens to be a dead end marked by the bold lines all right so now you'll ask the question hey well since there is only one way i can go you know once a path is taken there is no going back let me just go ahead and select three you know i want to maximize the amount of gold i can get and it looks like well perhaps three might lead me to the answer so what you'll do is you'll go ahead and select three and continue on and on your journey and at the end you get three plus one plus seven plus two plus five total gold coins hey looks like a successful run but is it actually the most optimal well the voice is kind of disappointed right now so that makes sense that maybe you have the optimal answer and you see the rest of the grid and hey we indeed found the optimal answer we were able to maximize the good for this particular grid now obviously the voice is kind of disappointed and it does not like this so what it does is takes you and throws you in another grid now we'll do the same computation again we'll go ahead and look in all the four directions and we see it's a similar kind of setup mostly because the voice was lazy to change these four squares but now you'll again realize that hey last time i selected greedily i selected the biggest square that i got i selected the biggest gold coin value giving cell and i just followed the path so let me just go ahead and do that again let me just greedy pick the highest value and hey maybe i get optimal answer once again and so you go on and on and on but hey this time the voice was smarter it only gave you zeros on this path and now it pulls you back again and says hey you know what you missed if you went to the square at 2 if you went bottom then you would have gotten 2 plus 9 which is much greater than three this is an example of the case where thinking in a greedy approach will not work and so you might ask the question hey it worked for the first one but if it is not going to work optimally for all the possible cases why do we even need to think about greedy solutions why do we need to worry about greedy solutions at all well there are two big reasons we should worry about it first it is asked in interviews and second is it general algorithm that you should know because here's the thing life gets complicated and perhaps when you explore every single permutation combination you realize that hey this was too much effort and there might be some problems where you can't even explore every single permutation in combination and greedy in that case comes as a savior because using a gradia algorithm guarantees that you will get a solution it might be the optimal one it might not be the optimal one but at least you'll have a solution all right so what we are going to do is over the next 10 videos that i've made we are going to look at 10 different interview problems all from interview bit and we're going to slowly build up our intuitions on how to proceed with greedy algorithm problems hello everybody and welcome let's talk about the problem bulbs on interview bit we're given n bulbs in total which are either on or off represented by 1 and 0 respectively the condition mentioned in the question says that turning on the ith bulb causes all of the remaining bulbs on the right hand side of it to flip which means that all of the bulbs on the right hand side which were one will become zeros and vice versa the goal of this problem is to find the minimum number of switches to turn all of the bulbs on the constraints mention that the n the number of bulbs can be between 1 and 10 to the power 5 and a of i can be 0 or 1 representing that the bulb or the bit we are looking at currently can either be 0 or 1. all right let's take a test case and try to work out a solution in the case of one zero one this is the test case we're gonna start off with we will also set the initial cost to zero we'll say that uh this cost is going to keep a track of the number of flips or the number of switches that we require to convert everything to once on the bottom right hand side is the logic we are going to use which is already mentioned in the question the question says that if the bulb is on well that's great we'll just continue on but if the bulb is zero that is if the current bit we are looking at is zero then well we have to increase the cost by one and flip everything on the right hand side of it all right so let's try to simulate and see what happens so this is the first element that we get the first bit is one so we'll continue on now in this case we get the bit as zero what does this mean this means that we have to increase the cost by one and we have to flip all of the bits on the right hand side of it including the current one so the zero becomes one and the one on the right hand side of it becomes a zero pretty simple right so now this is the area that we are currently working with what about this third element now well since this is a zero we have to go to the else condition the else condition says that the cost should be increased by one for converting this zero to a one and then we'll flip all of the bits on the right hand side of it since there are none we don't have to worry about it anymore and we have the final array as one one one at this point we note the cost which is equal to two and we'll return this as the final answer now let's try to analyze the time and space complexity of the solution the space complexity is order of 1 since we only ever store this cost variable on the top right however the time complexity is a bigger issue it's order of n square see because for every single bit as we're iterating over the array we'll take order of n time and for every single bit we might have to do another special operation of converting everything on the right hand side of it to be 0 or 1 basically flipping that around so that's order of n time to iterate over the bits and order of end time again if the bit is a 0. so that's order of n square time worst case now this was the naive solution and we were able to write down the knife solution just by using what was given in the question however can we optimize this the optimization of the solution depends on one single logic there's just one thing that you need to know to optimize this relation all right let's take a bigger case and try to work out and simulate what is going to happen in this case we have 0 1 0 1 1 0 1 1. we see that the first bit is 0 so what do we do remember we went in the else case we encounter a certain cost in this case represented by the arrow and because of this cost we were able to convert this zero to a one and we have to flip everything on the right hand side of it so the one becomes zero and the zeros become one so we have one zero one double zero one double zero now in this case we encounter a 0 again well that's kind of a painful thing to do as we already noted the time complexity is out of n squared so since we have the 0 let's go ahead and convert this 0 to a 1 encounter a cost of 1 and convert everything on the right hand side of it to be flipped so the ones become zeros and the zeros become once again now there's something going on there's something very interesting in this slide i want you to pause and ponder what's going on there's one small little detail that you have to figure out all right if you place both of these side by side you'll realize that both of these 0 1 0 1 1 0 1 1 and 1 1 0 1 1 0 1 1 have this yellow part of the string repeated both of them have this yellow part of the array repeated now what does that mean well this means that if you do two flips represented by these two blue arrows that we show if you do two flips everything on the right hand side of it becomes flipped by once and then gets flipped again in essence they get reverted back to their original states think about this this makes sense mathematically as well say that we are looking at an array and we are looking at a random bit in the array somewhere in the middle at this point let's say that the cost is some cost variable that we have stored over here represented in bread now we'll ask the question hey is the cost even or odd is the number of flips we have done even or odd because if we have done even number of flips the bit remains as is the bits get reverted back to its original states so the b becomes b it remains as is however if the cost is ordered we have to flip the bid that's because it has been flipped an odd number of times so 1 becomes 0 and then becomes 1 and then perhaps becomes 0 again so if the cost is odd we have to flip the bit now then what well if we can figure out this part well we can just write down what we did before if the current bit we are looking at is one now we'll just continue else will increase the cost by one all right let's try to code this up so here's the code written and we're of course going to start off with the cost equals to zero and we'll return the cost at the end now we'll see for every single bit in the array we'll iterate over all the bits in the rf we'll see if the cost modulo 2 is equal to 0 that is if this current bit has been flipped an even number of times well b equals to b b remains as is else b equals to not b that is if the bit was 1 it becomes 0 and if it was 0 it becomes 1. and now we can again ask the question as before we can say that if this current flipped bit is equal to one then what well just continue as is and in the else condition we'll increase the cost by one and once we're done with this iteration we finally will have the cost so you can realize that this takes order of n time complexity where n is the number of bulbs and it still takes order of one space since we are not storing anything other than the cost variable all right so this is it for the solution to the problem bulbs on interval hello everybody and welcome by let's talk about the problem highest product on interview build we are given an array of n integers and the goal of this problem is to find the highest product we can get by multiplying three elements we can pick any three elements from the array the constraints mentioned that n the number of elements in the array can be between 3 and 5 times 10 to the power 5 let's take a couple of examples to understand this better when the input given to us is 1 comma 2 comma 3 comma 4 that is we have 4 elements in the array the output we get is 24 and that's because we can multiply 2 times 3 times 4 and this is the highest possible product we can get which is 24. now when the input is 0 comma minus 1 comma 10 comma 7 comma 5 we multiply 5 7 and 10 together to get 350 which is the highest possible value we can get and so we return 350 as the answer now what is one thing that is immediately very clear from these examples the first thing we realize is that we can sort the array and we can pick the top three elements in fact we can write this down and we'll say that you know what one of the observations in solving this question is that we have to take the highest three elements multiply them together and return them at the end now whenever you have these kind of hypotheses whenever you have these ideas it is always a good idea to test them out you have something in mind you have a possible solution in mind try your best to find a test case where this might not work all right we'll take a couple of more test cases and see how this is playing out first we'll actually test this if this actually works so let's say that the case is minus five minus two one zero zero three four five in this case the logic works perfectly because we take the highest three elements three four five multiply them together and get 60 as the answer right so this makes sense our logic is sort of making sense for all of these three test cases so we'll mark this as green and we'll take another test cases as i mentioned it is always a good idea to find test cases for which for which this logic might not work and in this case is the test case minus 5 minus 2 minus 1 0 0 1 1 5. again the array is sorted just for the sake of convenience which is something we'll also do in the chord part but if we multiply one one and five together which are the highest three elements we get the answer as five but this is incorrect and this is because there's something else going on okay now we now that we have this array what is actually the answer well the answer is minus 5 times 2 times 5 giving us 50. and this is the second observation that we need to make recall how when you multiply two negative numbers it becomes a positive number again which means that we have two possible cases that we have to consider push we have to take the highest three elements that's for sure that something we have established is correct for some test cases and for the remaining test cases we have to consider the case where there are two negative values and one positive value as shown in the second test case over here now this second test case gets 50 as the output which is indeed the correct answer all right uh instead of saying two negative and one positive since we are already sorting the array we can say that you know what consider the lowest two and the highest one so either we take the first uh the highest three elements on the right hand side or we take the lowest two on the left and the highest one on the right all right now let's actually talk about the code for the solution here is the code and as i mentioned the first step is to sort the array so a equals to sorted of a which will return me a sorted array and this will be sorted in ascending order so on the line seven i have height three equals to a of minus one times minus two times minus three basically saying that we're going to pick the highest three elements and then this is the second case that i mentioned we will pick the two lowest elements which is a of 0 and a of 1 and we multiply it with the high one so which will multiply it with the highest element on the right hand side of the array now the answer can be any of those cases and so we'll simply return the max of high three and load to high one and that is really it for the code of the solution we can go ahead and submit this and this gets accepted all right so this is it for the solution to the problem highest product hello everybody and welcome back let's talk about the problem disjoint intervals we're given a list of intervals each represented by the start and the end times and the goal of this problem is to find the length of the maximal set of mutually disjointed intervals what does this mean let's take an example to understand this better let's say that the input given to us is 1 comma 2 2 comma 10 and 4 comma 6. so there are three intervals given to us and we have to find a particular permutation and combination of all of them such that we can select the mutually disjoint intervals and we can create the maximal possible set of them the answer in this case comes out too because we're going to select the intervals 1 comma 2 and 4 comma 6 leaving out 2 comma 10. this is the best possible case that we can have now this might look a bit bit cryptic so let's go ahead and visualize this so this is the visualization i've created and uh by the way these do take a lot of time to create so if you like this video be sure to give it a thumbs up if you like the effort i'm putting it let me know in the comment section down below anyways let's go ahead and plot out the uh intervals which is 1 comma 2 2 comma 10 and 4 comma 6 and now we're going to start off with some simulation we're gonna say okay you know what let's go ahead and select the interval one comma two so this is what happens when we select the interval one comma two and now we ask the question hey can we select the interval two comma ten as well and the answer is no in this case because in 1 comma 2 and 2 comma 10 we can see that 2 is being repeated so the point number 2 is going to create an intersection between these two intervals which we do not want right so what we'll say instead is that you know what let's go ahead and skip over 2 comma 10 and let's see what will happen if we include 4 gamma 6 and straight so if you look at both of them these are indeed mutually disjoint intervals and we can get the final answer as 2 for this particular test case now we did leave out 2 comma 10 so let's go ahead and see what will happen in a case when we try to include 2 comma 10. in the case we include 2 comma 10 we have 1 comma 2 and 4 comma 6 both left out and that's because in 2 comma 10 1 comma 2 intersects in the two position and 4 comma 6 is basically embedded into 2 comma 10 so when we select 2 comma 10 we cannot select anything else right so the final answers for both of them are two and one so in this particular test case we explored two different possibilities and we got the best possible answer as two now this what we have done here is twofold the first thing we've done by default is sort these index we've sorted these intervals now this sorting is something that we commonly do in these kind of interval questions so that's one thing that you can keep in mind for later on as well now the sorting thing is also very important for this question and we'll come back to it later but now the second point is that we have in a way made some sort of decision right this question can be boiled down to a dynamic programming problem in a way because we are going to make decisions of whether we want to include 1 comma 2 or not whether we want to include 2 comma 10 or not or whether we want to include 4 comma 6. any time we are making these sort of decisions and we want to look into the future we want to look into the past and we want to figure out okay what's going on this current point of time whenever we want to make decisions we're always going to go for dynamic programming so dynamic programming is going to give you one correct solution is one particular approach that is going to give you a correct solution but that might be a bit too complicated and maybe there's something else going on and before jumping into any one approach it's always a good idea to look at more test cases and see if there is another sneaky observation somewhere hidden and so let's go ahead and try to find out what's going on so i've written another test case which is one of the test cases mentioned in the question itself on interview bit and the test case is 1 comma 4 2 3 4 comma 6 and 8 comma 9 and i've plotted these out again because there are two possibilities that will consider and just a quick aside there can be test cases where there are multiple such possibilities but i've only mentioned two of them for this test case just for the sake of convenience all right so let's go ahead and say that i want to select the interval one comma four i make a decision to include the interval 1 comma 4 so the answer on the right hand side will become 1 in this case now can i select 2 comma 3 i cannot because it intersects can i select 4 comma 6 again no because 1 comma 4 and 4 comma 6 intersect at 4. can i select 8 comma 9 yes i can so let's go ahead and include that and increase the answer count by 1. pretty good right so as soon as we selected 1 comma 4 we sort of created a chain of events that led us to the answer to so 1 comma 4 in a bit drove the solution and we got the answer as 2. now what if i don't select 1 comma 4 and what if i select 2 comma 3 instead so in the second possibility we are going to first select 2 comma 3. now can i include 1 comma 4 no because it will intersect can i include 4 comma 6 yes i can because 2 comma 3 and 4 comma 6 do not have anything in common they do not have any intersections now can i go ahead and select 8 comma 9 as well yes i can and so in this way by selecting 2 comma 3 we were able to get a better answer of 3. now if you also notice as i mentioned 1 comma 4 as soon as we select the interval 1 comma 4 in the first possibility it sort of drives the rest of the decision making and the second case in the second possibility as soon as we select 2 comma 3 it drives the rest of the decision making now what is the difference between 1 comma 4 and 2 comma 3 maybe there's something inside of these both intervals that can lead us to the solution so maybe this interval is uh maybe 2 comma 3 gave us a better answer because it starts later you know uh 2 is greater than 1 so this interval is smaller this interval from 2 to 3 starts from 2 instead of 1 so maybe starting later is a good idea maybe it's a good heuristic to get to a solution or maybe it's not maybe it's the ending times that really matter and because 2 comma 3 ends early we can say that you know what all the intervals that are going to end early are going to give us a better answer now at this point we can't really be sure i mean we just got the hypotheses now let's go ahead and test this out we'll take the first example that we saw the first very first example that we saw which is 1 comma 2 2 comma 10 and 4 comma 6. now which of them is going to hold in this case feel free to pause and see whether starting earlier sorry whether starting later or ending earlier is a better heuristic to get to an answer if you notice 1 comma 2 starts earlier and 2 comma 10 starts later but we do not select 2 comma 10 we do not select the interval which is starting later we select the interval 1 comma 2 which is starting earlier which means the point 1 is wrong but what about ending early we can see that both the intervals 1 comma 2 and 4 comma 6 are going to end earlier than the larger interval of 2 comma 10. so it looks like the first point starting later is wrong and the second point ending earlier is correct and feel free to pause here and ponder of like what this heuristic means this makes a lot of sense because ending early gives us possibilities in the future to work well if an interval ends early right now we can say that it leaves a lot more space a lot more time for other intervals to join in the party but if an interval ends later on if it and if an interval drags on for a long time well then it might block other intervals to join the party which means that ending early is a very good heuristic for this question in fact it is the optimal heuristic now i've already explained the intuitions but there's a formal proof behind why ending early is going to give you the optimal solution now if you're interested in the formal proof is mentioned on my website links down below if you want to check it out but anyways we'll keep this ending early point in mind and we are going to go ahead and implement this logic so here's what i've done so the first thing we'll do is sort the intervals as i've already mentioned in the starting sorting the intervals is always a good idea and so we'll sort the intervals and the key in this case is the lambda function where we input x which is one particular interval and we're going to return x of 1 basically saying that sort these intervals by their ending positions because we want the intervals that end early to come forward first and we want the intervals which end later to go towards the end pretty simple so now what we're going to do is we're going to go ahead and start with the interval a of 0 we're going to interval which started and ended the earliest so a of 0 is the interval we're going to start off with we'll increase the count and we'll set the count to 1 because we're already going to select a of 0 and we'll also set the previous of s and the previous of e in mind which is the previous of start and the previous of n this would make sense in a second now what we'll do is we'll iterate over the elements inside of the array we'll iterate over the intervals giving us the start and the end times of each interval and now i'm going to ask one very important question i'm going to ask the question hey is the start of this current interval i'm looking at is before the ending of the previous interval let me say it again does the current interval start before the previous interval ends that is is there a overlapping is there an intersection between these two intervals because if there is an intersection if this condition is true then go ahead and pass do nothing in this case we don't want to mess with the cases where there are intersections we want to avoid them instead and in the else condition we're going to go ahead and write you know what go ahead and increase account because clearly this current interval that we're looking at is not intersecting with the previous one so which means that we can include this current one right so we're going to go ahead and increase the count by one and we'll also say you know what go ahead and set the previous of f previous of s and the previous of e to be s comma a basically the previous intervals now become the current intervals times all right so this is it for the code of the solution now i know this is one of those questions where the greedy solution ends up giving you the optimal solution and the proof for that is mentioned in the written article on my website links down below in any case as i mentioned before these visualizations do take a lot of time to create so if you enjoy this video give it a thumbs up it lets me know that you find these visualizations helpful and meaningful and if you want more of this kind of content well go ahead and hit the subscribe button i'll see you very very soon hello everybody and welcome back let's talk about the problem largest permutation we're given an array of a random permutation of numbers from 1 to n that is we are given n total numbers ranging from 1 to n both inclusive and we are also given b which is the number of swaps in a that we can make so we can pick any two integers inside of the array a and we can make a swap between them and we can do this kind of swap b number of times the goal of this problem is to find the largest permutation possible let's take an example to understand this better let's say that the input is a equals to 1 3 2 and b equals to 1. now of 1 3 2 we can already see that you know n equals to 3 which is there are three total elements ranging from 1 to 3 both inclusive and b equals to 1 which means that we can make one swap instead of this adding we can pick any two integers once and make a swap between them the biggest and the largest permutation possible in this case is 3 1 2 and that is because we can swap one and three giving us three one two now you can imagine one three two as one thirty two and three one two as three hundred and twelve and so the output is the largest possible permutation we can get out feel free to write down more examples and try this out yourself you won't be able to find any better permutation than 3 1 2 when b equals to 1. all right now let's take a couple of more examples and try to build our intuitions and understanding from it let's say that the input argument to us is one two three four pretty simple permutation right and b is given as one which means that we can make one swap in total now let's actually write this array down once again and now i'm going to ask you the question what is the number that has the biggest bang for its spark what is the number that can change the most is the number four right what is the biggest number possible and so if we can bring four to the front that'll be better than bringing three to the front or two to the front right so what we'll do is we'll swap four and one and that's it and that's the answer for this test case pretty simple right we're basically trying to find the numbers which have the biggest bang for the buck all right let's take another example and we'll try to work out a solution again let's say that the input is three two four one five and b equals to three which means that in this case we can make total of three swaps now how do we proceed to a solution well what is the first thing that we should do we wanna maximize the number we want to make the number as big as possible so what we can do is uh we look at three two four one five and we realize that five is the biggest number five has the biggest demand for its buck right so we can take one b we can take one step and we can bring five to the front that does mean three goes at the end but you know what a number starting from five is going to be much greater than a number spreading from three so we'll make that swap happen okay what's the next step then well since we have three b's we can go for another row and try to look at this again now which number has the most bang for its bug since we already made a swap with five five is already in the best position possible how about 4 now we can go to 4 and we can say that you know what go ahead and swap 4 with the element in its position so after 5 we want to put 4 and so this is exactly what we'll do we'll swap out five sorry we will swap out four bit two all right so now we'll do this and how about this we have five four two one three and now was the next element that we can swap this is the last swap that we can make which element do you think will give the most bang for its buck five and four are already in place and now we only have the largest element three that is remaining which is not in its place right so we'll go ahead and swap two and three and this is the solution for this test case now what is one thing that we observed right away what is the one thing that we realized and we were solving these problems what we realized was that we can greedily replace the higher elements so we can say that you know what if 5 is not in its place if 5 is not in the first position let's go ahead and make that happen let's go ahead and put 5 in the first place and then we'll ask the question we'll ask the same question for 4 we'll say hey is 4 in the right place is 4 in the second place in this test case if 4 is not well go ahead and make that happen go ahead and make that swap and similarly for 3 and then 2 and then 1. now in case b equals 200 well we will have reached a point where we have 54321 so that won't be very useful to us which means that you know the scary constraint given to us that b can be 10 to the power 9 is not really meaningful since the ra is only 10 to the power 6 elements in any case this is the entire logic that we need to solve the problem we can greedily replace the higher elements so we'll make sure the highest element n is at the first position then the second highest element n minus 1 is at the second position and so on and so forth till we get to one all right let's talk about the code the first thing we'll do is set up a couple of variables that we'll need for related now we set i equals to zero since i is a pointer going from the start of the array to the end of the array we need i because in the case of three two four one five i wanted to look at the right hand side column note how five four and three are underlined these are the elements that have been swapped with the other elements on the right hand side which are 3 2 and 2 respectively now these elements are underlined because you can imagine that i is going from the start to the end and i is trying to fix every single number so first we're going to fix 5 and then we're going to fix 4 and then 3 and then 2 and so on and so forth so this max is going to keep a track of of the current n right so this max starts from n and then goes to n minus 1 and then n minus 2 and so on and so forth as you can see here now we also have this d which basically tells us the positions of every single element so dictionary is a dictionary from the value say from five to its current index so in the case of three two four one five the value of the key five is four that's because it's sitting at the fourth index similarly for the value 4 the index is 3 sorry the index is 2 and so on now we're going to say while these two conditions would while b exist while we have any number of swaps left to be done and we still haven't iterated through the entire array so while we're still iterating through the array and while we have swaps remaining to be made we'll do some computation we'll say that first of all get me j now what is j j is the d of max basically j is the location where the highest element is sitting so in the case of 3 2 4 1 5 as i showed in the presentation the in the first iteration j is going to be what j is the location of the maximum possible value now the maximum is 5 in our case so we're going to go ahead and ask the question hey where is 5 and the answer we get is 4 5 is sitting at the index fort now we'll ask the question hey is the current index i the same as the return index j that is is 5 in its right position or not now if it's in right's position well we don't really need to do anything it's already in its right position and we can just continue on as is however if it's not in its right position we'll have to do a swap and so every time we do a swap we'll have to reduce the b by one and what is the swap going to be swap is simply going to swap the i and the j elements right as we saw uh when we realized that you know what 5 and 3 had to be swapped because 5 was towards the end and 5 should be in the start well we wanted to replace 5 with 3 and so 3 will move to the position of pipe now we'll say that a of i comma a of j equals to a of j comma e of i basically 5 and 3 gets swapped this is one more thing that we need to do which is absolutely essential which is to update their dictionary values as well since both of these numbers now are at different indices than they were at before we'll update the dictionary values also towards the end of this while loop will also say i plus equals to 1 basically now we'll increase the i pointer by 1 and we'll reduce the max by 1 and that's because we started off with the maximum value as n then we'll move on to n minus 1 and then so on and so forth at the end after we have made all of these swaps we would have a a that is remaining and this a is something we'll return at the end all right so this is it for the code and that is it for the solution to the problem largest permutation hello everybody and welcome back let's talk about the problem meeting rooms we're given a list of intervals defined by their starting and their ending times and each of these intervals basically represents a single meeting and now we are given a list of meetings the goal of this problem is to find the least number of meeting rooms required so that we can conduct all of the required meetings the constraints mention that n the number of meetings can be between 1 and 10 to the power 5. the constraints also mention that every single time can be between 1 and 10 to the power 9. so let's take an example to understand this better let's say the input we get is 5 comma 10 15 comma 20 and 0 comma 30. what it means is we have three different meetings where the first meeting starts from 5 and ends at 10. so basically you can assume it starts at time some t equals to 5 units and ends at t equals to 10 units then there's another meeting starting from 15 ending at 20 and a third meeting starting from zero ending at 30. now the output of this problem is two saying that there are at least two number of rooms required to conduct all of these meetings and that is because we have to realize that 0 and 30 0 comma 30 and 5 comma 10 are two meetings which intersect right they take place simultaneously which means that we'll need to create two different rooms so that both of them can happen around the same time similar is the case for 0 comma 30 and 15 comma 20. both of them again intersect so we'll need at least two rooms so that the meetings can actually take place all right let's go ahead and expand upon this example and try to work out how we actually got to a solution and simulate what is going to happen so now what i'm going to do is i'm going to create these meetings so we have one meeting from 5 to 10 we have another meeting from 15 to 20 and a third meeting from 0 to 30. now what we can do is we can go ahead and start scanning from the left to the right and so i'm going to create a pointer and this is the yellow pointer that we are going to see and this pointer is going from the start to the end scanning the meetings basically it is going to ask the question hey how many meetings are there currently going on and so the current variable c u r r will start from zero basically saying that there are no meetings at time of zero and as we iterate as we scan through these times we'll go ahead and increase the current which represents the number of meetings going on currently and max is the second variable we need to keep a track of which will tell us how many meetings rooms do we require and the max is going to be the answer at the end so the first thing we'll do is uh we realize as soon as we hit time 0 we see that there is one meeting that is starting at this point of time so we'll need to increase the current by one right so now we can go ahead and say that current equals to one what is the maximum number of rooms are required maximum is just the maximum possible value of current so we'll put one in this place as well now what do we do next well the next thing we realize is that from time zero including time one two three four we will only require one total meeting room and so the current remains one but as soon as we hit time equals to five we'll need two meeting rooms because at this point of time another meeting starts right the meeting from five to ten starts at this point of time so the current increases to two which means that there are two meetings going on simultaneously now what is the max going to be max is going to reflect the changes in the current and become two visible all right so now from the point of time five six seven eight nine we will have two meetings running simultaneously right so the current remains two and the maximum remains two but as soon as we hit time equals to ten the current decreases back to one and that's because one particular meeting the meeting from five to ten has ended right now which means that the current number of meetings going on is one that's the meeting from 0 to 30 which is still going on so we'll still need one room to take care of now what happens from time 10 to 11 12 13 14 will only ever require one total meeting room but as soon as time hits 15 we'll need another meeting room to accommodate both of these meetings simultaneously the maximum stays the same and the current becomes two so then what happens when we move to the time 20 well if current again decreases to 1 since we only have one meeting going on right now and then at time equals to 30 the current decreases to zero basically saying that the meeting that was going on earlier from 0 to 30 has ended so the only thing that is remaining is the maximum which is equal to 2 which becomes the answer now one thing that we have done across this solution is that we're going over every single time stamp so we're going at time goes to zero we're going at time goes to one and two then three then four and five right and we're going to look at every single time stamp we're going to look at every single time and scan across all of these meetings to know which of them is going on as you can imagine that will take quite a lot of time in fact if we have cases like these where we have one meeting from 0 to 10 to the power 9 which is by the way a valid constraint whenever we have these kind of meetings well as you realize 10 to the power 9 is not a feasible way to deal with this right if we iterate from 0 all the way up till 10 to the power 9 will already get a time limit exceeded and that's even just looking at one single meeting what if we have multiple of these kind of meetings that just means that this is not a good way to look at it there's an optimization that's hidden somewhere all right so how do we think about the problem now well let's go back to the nicer example and notice what you have done previously the thing we realized previously was that we only care about the places where the change happens so what it means is we are only going to focus on 0 5 10 15 20 and 30. we don't care about what happens at time equals to 3 or time equals to 7 or time goes to 16 or 24 or 31 or 32. we only care about the times where changes happen we only care about time zero where our meeting starts we only care about the time five when another meeting starts at a time 10 a meeting ends so we care only about the points of times where the number of meetings is going to change so that's central observation in solving this problem in fact what we're going to do is we're going to write down these formally so we're going to say at times 5 15 and 0 we are going to require plus 1 meeting rooms what it means is as soon as we hit time equals to 5 we'll need one more meeting room and if you look at the visualization that makes a lot of sense right so what you've done is we've figured out we have picked out all of the starting indices which are 5 15 and 0 as you can see from the array on the top and we have all assigned them plus one value similarly we have assigned minus one value to 10 20 and 30 because if you look at the array above again 10 20 and 30 are all the ending times basically saying that at time equals to 10 i require one less meeting room because at time it goes to 10 one meeting has ended right so now what we can do is we can go ahead and write them in a better format and we're going to create a tuple of the time comma the change in the meeting rooms required now the next step we're going to do is pretty simple once you understand what's going on the only thing we're going to do is we're going to sort all of these numbers by their times so 0 comes first then 5 10 15 20 and 30. remember this is the way we discussed uh in the initial example as well this is how we are going to look at the problem so what it means is at time equals to zero i'm going to require plus one meeting room so we're gonna have this current in the max variable as before and at time equals to zero i need plus one meeting rooms so the current now increases by one saying that i need one more meeting room than what i had previously i had zero so now zero plus one becomes one what is the max going to be max is going to be the maximum value of current we have seen so the maximum will become one as well this is what happens at time equals to zero now what happens when you move to time equals to five at time equals to five another meeting starts so we increase the current by 1 and the maximum reflects the change now what happens at time equals to 10 a meeting has ended now we don't know which meeting has ended but one of the meetings has ended that means the requirement for the number of rooms has decreased by one the current decreases from two as we saw here the current decreases from two here to one here all right make sense and similarly so on and so forth we can keep on going we can keep a track of the current as how the meeting rooms increase or decrease and change at the end of this iteration you'll notice that the current becomes zero again because all of the meetings that started all of them have ended right now and maximum is again the answer to this problem all right so pretty simple what's going on right let's go ahead and implement this so this is the implementation with this question the first thing we are going to do is create this data array this data list which is going to store plus one so for every single starting and ending element inside of this array for every single meeting i'm going to say you know what data dot append add the value s comma 1 to the data array basically saying that at this start point of time i require plus one meeting rooms the number of meeting rooms the requirement of these meeting rooms increases by one at the same time i'm going to say whenever this particular meeting ends go ahead and decrease the requirement of the meeting rooms and so as i described earlier the next step is going to be sorting all of these values so we can iterate over them in a meaningful way so the time is going to increase one by one and we're going to increase the time and keep a track of the current as well as the answer so i'm going to say for underscore comma b in data basically saying uh i don't care about the time anymore i only care about the change in the current so i'm going to say for every single of these values the current increases by the i so if v is plus one the current increases by one if b is minus one the current decreases by one pretty simple and the next step is then again the writing answer equals to the max of answer and the current basically saying that keep on storing the maximum possible value of current that you can get and at the end we can return this answer so let's go ahead and go ahead and test this out we are going to go ahead and submit this as well all right cool so this gets accepted hello everybody and welcome back let's talk about the problem distribute candy there are n kids standing in line each of them having an integer rating associated with them we have to distribute the candies following two rules first each kid gets at least one candy and second kids with the higher ratings than their neighbors get more candies the goal of this problem is to find the minimum number of candies required to satisfy both of these rules the constraints mentioned that n the number of children can be between 1 and 10 to the power 5. let's take an example to understand this better when the input given to us is 1371 the output is 7 and that's because the candies we can give them are one two three and one respectively let's go ahead and take a look at a visualization to help us understand what's going on better so here what i've done is i've plotted out all the values so the kid of the rating one is present at the first index then the kid of the rating three then seven and then one back again all right so since the goal of this problem is to find the minimum number of candies possible and we have to assign at least one candy to each kid let's go ahead and assign the kid with the value of one one single candy right so this is where we are going to start and now what happens to the kid with the rating three well since the kid with the rating three has a higher rating than kid of the rating one we have to give it more candies now how many more well we can give it three candies or five or ten or hundred or thousand the goal of this problem is to minimize the number of candies we can give so what we'll do instead is we'll just ensure that you know what this kid is going to get two candies which is greater than one all right so this still satisfies the condition mentioned in the question all right so now we move on to the kid with the rating of seven the kid with the rating of seven looks at the kid with a rating of 3 on the left hand side and on 1 on the right hand side and realizes that wait a second i'm greater than both of them now it looks at the kid with the rating 3 and says that you know what since i'm greater since i have a higher rating than my neighbor i should get one more candy than the neighbor so we'll assign at the value three and now what about the kid with the rating one at the present at the very last well we don't have to assign it any more candies than the previous one because this current kids rating is lesser than its neighbors which means that we can go ahead and simply assign it the default value saying that you know what since you are at a lower value we're just going to give you one candy to formalize the logic we have seen up till now we'll write it this way so we'll say that if the rating of the current kid is greater than that of the previous kid then we are going to increase the score by one and we are going to save that score corresponding to that kid otherwise we'll set the score to 1 by default all right so let's go ahead and test this idea out on other test cases to see if it actually holds up or not or maybe it's just a product of this particular test case all right so let's take another example this is the example we have the kids are operating 1 7 4 3 and 1. now as with previous case we're going to assign this first kid the candy of 1 because that is the minimum number of candies we can give what about the kid with the rating of seven well it looks to the left of it and it realized that hey this kid has a candy of one and since i am since my rating is greater than that of the previous one i'm gonna increase the score by one so the previous score was 1 the current score becomes 2 and we're going to save that now when we move on to the kid with a rating of 4 we'll ask the same question hey is this kid having a higher rating or a lower rating than the previous one so now we'll say that you know what since 4 is lesser than 7 this kid's rating is lower than the previous ones we'll assign it the default value of 1 and we follow the similar logic for the values for the kid of the rating 3 and 1. all right so this is the answer we have up till now following the logic we made however this is incorrect and that's because if you realize the right most kid with the rating one gets one candy and that's where it has the lowest rating so we'll have to give it one candy but the kid who is at the second last position with who has the rating three should get actually two candies and that's because in the question it's mentioned that we're looking at the neighbors which means that we're looking at both the right and the left neighbors together now in this case the kid with the rating 3 has a higher rating than that of the kid of the rating one on the right hand side right which means that it should get a greater amount of candy and so the answer changes which means that we cannot simply iterate from the left to the right anymore and we cannot get the answer this way because here's what the real answer is going to look like kid with the rating three is going to get two candies because of the kid of the dating one on the right hand side similarly the kid with the rating four is not actually going to get one candy but is going to look at the kid on the right hand side and say that you know what hey this kid of rating three is getting two candies so i should get more right so this kid will actually end up getting the answer three and similarly we'll look at the kid of the rating salmon and now it goes ahead and looks at both its right and left neighbors the left neighbor says one and the right neighbor says three and it realizes hey wait a second i'm greater than both of them so what i'm going to do is i'm going to pick the maximum of them i'm going to say that you know what this right kid is at a rating of 4 and it's already getting three candies which means that because i'm at rating 7 i'm i'm higher than the kid of the rating four i should get more candies so i'll go ahead and get four candies in total now all of this was to demonstrate the fact that we cannot simply iterate from the left to the right and as we saw in this case the change is sort of propagated from this one kid on the right hand side and the change is propagated from the right to the left make sense this means that we cannot simply iterate from the left to the right and we can't do the same for the right to the left case either because if we just iterate from the right to the left we will just have inverted the problem which means that iterating in either of these directions is not going to be helpful for us we need a way out of the situation we need a better way to assign candies to kids how about this about to start from the lowest rating kids so in this case is the kids of the dating one there are no other kids who have a rating lower than one which means that we can go ahead and assign values of one to both of these kids that's because there is constraint mentioned in the question that we have to assign at least one candies to even the lowest possible writing kids so we'll go ahead and start with this default case right this is the default case keep this in mind as soon as we find the default case we're going to assign it one value all right so now we'll go ahead and ask the question for three now right we're starting from the lowest rating kills and we're trying to move up the ladder so now we are going to look at the kid with the rating three and we are going to ask the same question look at the right and look at the right right and we'll see if the kid if the current kid's rating is greater than the left kids rating then you have to give it one more candy and if the current kids rating is greater than the right kids grating well you have to give it you have to give it one more candy than the right kid now in the case of the kid of the rating three what do we do we look at the left there is nothing we look at the right there is one candy now this current value is going to be one plus one so we'll say that the kid of the rating three is going to get a value of two you will understand this better as we walk through this more so let's go ahead and answer the question what happens to the kid of the rating food right the kid of the rating four looks at the kid on the left hand side which is seven it's greater so we won't touch that but on the right hand side is a kid with a lower rating which means that four can demand one more candy from the kid of the rating three right so it's gonna look at two and be like okay give me two plus one candies now please so this is going to get three candies and now we finally move on to the kid with the highest rating rate we started from the lowest hitting kids and we slowly moved up the ladder and now we are going to look at the kid with the value of seven and what is this kid going to do this kid will look at the left kid gives one candy is going to look at the right kid has three candies and now this kid will realize hey you know what i'm greater than both of these guys so let me go ahead and get myself four candies because that is going to satisfy both the conditions all right so now this should make a lot more sense in fact let's go ahead and take one more example which is a slight bit more complicated example but solving through this should get you to the solution and if you're able to solve this yourself then you've pretty much done the solution for this question all right feel free to pause the video at this point of time and try this out yourself all right cool i assume you paused and solved now let's go ahead and start walking through this test case so the first thing we'll do is start from the lowest generating kids in this case it's two kids on either side who have the rating one so we'll go ahead and assign them one value each right we're going to go and give them one one candy because that is the minimum possible candy we can give like these are bad kids so we'll just give them one candy and tell them to be happy with it now we'll move up the ladder we'll say okay what about the kid of the rating too we look at the left we look at the right now the left kid has a candy of one this guy is higher than that so it needs more candies so we'll go ahead and give it the candy too now we'll go ahead and look at the kids of the rating three what do we do again well look at the right most three value kid right this guy this guy is going to look at the right kid which is lower and the left kid which is at equal value now since it found a kid with the rating lower than i that is the current kids value is greater than the right kids value we are going to the second if condition and we'll say that the number of candies we are going to have to give through this kid is one plus the right kids value all right so now we'll go ahead and give this the value of two what about the second third kid which is uh present towards the middle well we'll ask the same question hey is this kid having a higher rating than the kid on his left hand side no is this kid having a higher rating and the kid on the right hand side well no again it is equal but it's not greater which means that we can go ahead and assign it the default value of 1. we basically undercut the skill okay that's the wrong explanation now okay what about the kid of the rating four okay look on its right look on its left left there is nothing but right you can see that there is kid of rating one so we are going to give it the value of 2 and then for the value of 7 we're going to look at the left and look at the right and what do we see there's 2 either k so just do 2 plus 1 giving us 3. all right so this is it for the logic it's pretty simple what we're going to do is we're going to start from the lowest ratings and we're going to gradually move up the food chain we're going to gradually move up the ladder and look at from the worst kids to the best kids and each time we'll go and look at the left and the right and assign it one more candy if needed all right so let's go ahead and start with the code so n is the length of the array the number of kids we have and data is what is going to be the very helpful part for us so data is just a sorted array of x comma basically saying that okay for this particular kid rating this is its index right that is all i've done so what we are going to do is we are going to sort all of these kids by the ratings but since we are sorting we are going to mess with the array structure right we're going to mess with the indices so we need a way to store the indices and that is why we have this x comma i instead of just x all right cool so now we're going to go ahead and assign one by default to every single kit that's the initial uh assumption in the question we have to assign every single kid at least one values all right so we'll go ahead and assign everyone at least one candidate and now we're going to iterate over the data we'll say that for every single x comma i that is now x is not really important for us but we'll say that for every single i for every single index that you get we'll go ahead and ask two questions hey if i greater than zero basically saying that if there is a kid on the left hand side of this particular kid and this current kid's value is greater than the left kids value well if that is the case then go ahead and do candies of i minus one plus one right if there is a kid to the left of you who is a valid kid then go ahead and take its value and increase it by one only if the current reads current kids rating is greater than the left ones and we'll do the similar thing for the kid on the right hand side and this is just a simple sanity check just to ensure that you know the element i plus 1 actually exists in the area or not pretty simple and towards the end what we can do is we can simply return the sum of all the candies right as you saw the yellow elements are all the candies for every single person for every single kid and so we'll just sum them all up together to get the final value all right let's go ahead and test this out just to see if everything is working correctly and we'll go ahead and submit this all right cool so this is it for the video solution to distribute candies on interview build hello everybody and welcome back let's talk about the problem seeds there's a row of empty seeds and filled seeds represented by a dot and an x respectively the goal of this problem is to find the minimum number of moves required to make the people sit together the constraints mentioned that in the total number of seats including both empty and filled are between 1 and 10 to the power 6. so if we look on the right hand side the input looks like dot dot x dot dot x dot and the output of this question is two now let's go ahead and take a look at a visual explanation to understand this better so we have people two people sitting on the indices two and five and the rest of the seats are empty now what can we do to get to a solution well the question asks us to group these people together so what we can do is we can ask the person sitting at the index 5 to move to the index 3 that we will have grouped together all of the people and we'll get a total cost of 2. why is that that is because the person was sitting at the index 5. so 5 minus 3 gives us 2. basically we're looking at the absolute difference between these two seats alright so two is one possible answer and this is one possible configuration if you go back to the original now we can ask the question hey is there any other better thing that we can do what if we ask the person sitting at the index 2 to move at the index 4 well we'll get the same answer as 2 because 2 minus 4 in the absolute difference of 2 and 4 is still 2. and of course this condition is still satisfied that these people are grouped together at the end so this is a pretty simple test case and there's not a lot of things going on so what we'll do is to get a better insight into the problem to get a better observation and analysis of the problem let's go and take a look at a bigger test case and i know this might look scary but as we work through it this will make a lot of sense all right so the goal of this problem is to group all of these people together so how about this how about i go ahead and assume that all of these people are going to be grouped together starting from the index zero so here's what we'll do we'll ask the person sitting at the index one to move to the index zero this will get a cost of one then we'll ask the person sitting at the index foot to move to the index one so that we can group them together then we'll ask the person at seven to move at two and eight to move at three in this we have grouped together all of the people and we've gotten the answer as 14. however there is no guarantee that this is in fact the optimal solution so what can we do to find an optimal solution if you notice the goal of this problem was to group together the people in other words we're looking at a contiguous segment of people that start from a particular index in this case these group of contiguous people started from the index 0. maybe that is not where we have to start maybe the best most optimal solution starts from the index one instead and so this is what can happen basically we are going to recalculate the cost of moving every single person to their appropriate seats right so one moves to index one four to two seven to three and eight to four make sense and we'll calculate the total cost and now the minimum has decreased the minimum has become ten pretty cool right and now we still don't know whether this is the optimal solution or not so what we can do is we can go ahead and we can go ahead and test out the index two as well right we are now going to start the contiguous segment from 2 and so on and so forth we can keep on doing we can keep on increasing the starting position of the segment and for every single starting position of the segment we are going to calculate the time taken the number of moves taken for every single person we can sum them all up together and we'll be able to get to a solution at the end of this iteration as we have tested out every single index whatever is the minimum we'll return it as the answer all right so let's go ahead and implement this i have implemented this in python 3 and by the way just by the way one of the things that you have to do for this question is switch to python 2.7 because there are some issues in python 3. uh i am not sure what the exact issue is but it looks to be an issue on the interview bit side so we'll skip over that anyways switch to python 2.7 if you're using python all right so first thing we'll do is set up a mod which is one of the requirements of the question and now what we'll do is we'll figure out the indices for every single cross so we'll iterate over all of those uh all of those characters in a basically iterating over all the dots in the x's and we'll ask the question hey is the current character you're looking at is the current character an x because if that is well go ahead and save its index so by the end of this iteration this crosses will have all the indices of x's and that's fine all right so this is the first step now what's the next step remember that when we were looking at the array when we were looking at the case like this we started off from index 0. so let's go ahead and force everyone to go to index 0. what we'll do is we'll go from i will go for i come across and enumerate of crosses we'll do cross minus i this is going to save the number of moves required assuming starting position starting position of the segment is zero right so feel free to pause here and understand what's going on we're looking at the index of one cross and we're going to move it to another index i which is going to be the appropriate index assuming that the starting position of the segment is zero and now we are going to go ahead and find the number of process and we'll say simply say this is one edge case we can simply say that you know what if n equals to zero if the number of cross is zero well there are no people and the entire row is empty just return early and return zero saying that we don't require any amount of cost moving a person here from here to there because there are no person at all all right cool this is a simple test case now we'll go ahead and initialize the answer starting from infinity remember this is the minimum possible answer that we want to get so i'm going to initialize with the maximum possible value and now i'm going to start from all of the segment stars in range of length of a basically whenever i have this kind of so in this case we have an array of limit tenth i am going to assume that a starting segment can be from anywhere between 0 and 10. so this is what i've done i'm going to iterate over every single possible start of the segment for each of these segment starts i'm going to keep a track of the total cost for each segment which is going to start from 0. and now i'm going to say for cross and crosses basically for every single moves required so this is the number of moves now crosses stores the number of moves for every single one of these crosses figure out the difference between this and the start of the segment so this will give you the answer for the current configuration and now we'll do total plus sequence to this value and total mod equals two so basically uh this is like one of the extra constraints the questions is the value can be very large we have to return minimum value mod what is this i think a standard power eight plus 3 all right anyways so this is like an implementation level detail that's why i did not mention in the problem setup that i had anyways once we have this total what we can do is simply assign answer as the minimum value of the answer and the total mod with the mod all right so as we go ahead and iterate through the segment starting points and as we go ahead and iterate through every single one of these crosses we will be able to get an answer so let's go ahead and quickly test this out all right looks to be correct and we can go ahead and submit this so you can see that this says test case easy success but this will fail for hard test cases and that's because of this loops over here you see this loop takes order of n time to run and that's because we are iterating for every single possible segments chart now this takes order of n where n is the number and is the length of the array which is the number of seeds in the row for every single one of those i also have another order of an operation inside of it where i'm saying for every single cross in cross is do something and now the number of crosses in a row can be order of n at maximum right if you have 10 people in the row you can also have a worst case where all of these seeds are fit so this will just be a lot of pain to do and this is order of n nested inside of another order of n giving the total time complexity as order of n square and you can see that the test is hard failed because the time limit exceeded all right so how do we start to think about optimizing this problem i mean this is already a pretty complicated problem but now we're asked to optimize this all right let's go ahead and take a fresh start let's say that this is the configuration we have this is the test case we have now if you look at it can we not say that okay assume 1 4 seven and eight are people standing on these indices right so these are all of these people standing now let's say that the person one is uh standing alone four is standing alone but seven and eight are having an interesting conversation or maybe they're in a party and now they'll go ahead and invite person one and four to join the party now where do you think both of these should land up like they want to all meet up together right that's the goal of the problem we have to group together these people so since 7 and 8 are already at their locations they're going to go ahead and call 4 and 1 to come to their side right so this is one way we can think about it the answer is hidden in clusters of people right so maybe if there is a very large cluster somewhere in the middle then that might attract all of these people and that might minimize the number of moves we take so this is just a heuristic and whenever we have heuristics like these whenever you have ideas of how the solution might proceed go ahead and do your best to disprove it instead of proving it try to disprove it and if you can find a test case where you can disprove it well you can go ahead and build your intuitions and observations more so let's go ahead and take a look at another test case this is a little bit more complicated but it'll do the job so now if you look at it there are like three different total clusters of people there are two clusters in the very beginning two two words middle and three towards the end right so what now well since we said that maybe the biggest cluster is going to attract the most people so let's assume that's the case let's assume 10 and 12 do not move but they're going to invite everyone else so 4 and 5 are going to move to 8 and 9. this is going to take a cost of 4 and 4 respectively similarly we are going to call 0 and 1 to 6 and 7 right so this will take a cost of 6 and 6 giving us a total cost of 20. now in this this case you can see that all of them are grouped together neatly towards the end of the adding and maybe maybe that is the answer we are looking for right maybe 20 is the answer we're looking for but now if we use the brute force solution to verify it we'll find that the test case not actually satisfies the condition is this one the configuration which satisfies this condition is this one we have the starting segment index has two and you can see that the score we get as two plus two for the first two guys zero plus zero for the middle two guys the middle two guys don't move and the last three guys move and come towards this place now what does this hint you at it looks like everyone has come towards the middle of the area right it looks like everyone has come together with four and five although the biggest cluster was ten eleven twelve these four and five guys somehow attracted everyone else so maybe it's the point of middle which is the more interesting observation we can get you know maybe we have to think about it from a middle point of view but now the question is how do you exactly define a middle at this point i want you to pause and figure out what a measure of the middle could be i know all of this has been pretty weird up till now is pretty new stuff but feel free to pause at this point and try to figure out a solution because if you can do it trust me this is one of those kind of questions for which the solution you will never forget you will never forget if you can figure this out on your own all right pause right now if you want to try this out all right so if you go back to school level mathematics one of our chapters we're taught is statistics and when it comes to statistics there are three different very common basic ways of getting to know our data set are three different measures that we use very commonly mean median and mold now mode as we already proved is not going to give us the solution we're not looking at the biggest cluster because 10 level 12 obviously moved towards the middle so mode is out of the picture what about mean and median well let's go ahead and assume that mean is going to give us the answer so what we'll do is we'll take all of these indices of the people sum them all up together and divide it correctly so we'll have a total of 43 divided by the seven people that have there that are there we have 43 as a total divided by seven people that are there and so the mean comes out to six now what this means is the mean means that six is the middle point of the array which means that since there are seven total people there should be three people on the right of six and three people to the left of six however it looks like 6 is not the right answer 5 is 5 is more middle than 6 somehow so clearly mean is not the correct way to look at it what about median instead if we look at median we get 0 1 4 5 10 11 12 and again the middle element in this case is what the middle element is 5 and 5 exactly matches with the perfect the optimal solution it perfectly matches with the optimal solution and so it looks like we are looking at median as the perfect position for these segments so median is going to define us the answer so let's go ahead and write down that instead of going for that large order of n segment start loop what we are going to do is we are going to do something very very simple we are going to say that the segment start is nothing but the median the array now what what area we are looking at we are looking at the crosses array and we'll figure out the n by two element we're looking at the middle element we're looking at the median all right so that is all i've done that is all the change i've made let's go ahead and test this out once and we'll go ahead and submit this all right so this works out anyways i know this was a little bit complicated to figure out the median and the mean thing but now that you know about the median thing keep it in mind for future reference because there are many other questions especially the tricky ones like these which require both knowledge of mean and medium so keep mean and median in mind test them both out in given a test case and see which one works out which one does not and that'll give you a better way to approach the problem and optimize the solution hello everybody and welcome back let's talk about the problem sine minus two holes we're given n minus and n holes defined by these two arrays which contain position of each of the mice and each of the holes respectively and a mice takes one minute to travel one unit left or right the goal of this problem is to find the minimum time after which all mice are in holes so basically the problem is we have to select a mice and assign it a hole so that it can travel from its position to the hose position taking the amount of time which is the difference between them right so i know this can sound a bit confusing so let's go ahead and take an example to understand this better so the first row tells us the positions of the mice and the second row tells us the positions of the holes so what we're going to do is we're going to go ahead and plot this out just for the sake of clarity so there's a mice that exists at position three another mice at position two and one more mice at position position minus four then we have three holes one hole at zero one at minus two and one at four pretty simple right the problem setup is pretty simple now what's the greedy solution over here what is something that you can do greedily well what you can do is assign every single mice the corresponding hole and what i mean by that is if you look at the mice number minus 4 it can simply go to the whole number minus 2 and that's because both of them occur at the first position right when we sort these arrays when we sort the mice array when we sort the whole array we can simply iterate over them one by one so we can say that for the first mice we're going to assign it to the first hole so it'll look something like this and we'll take total of two time because it went from minus four to minus two similarly now we are going to look at the second mice and assign it to the corresponding second hole mice moves from two to zero taking again a time of two and then we look at the third mice and assign it to the third hole and so this mice will go from three to four now if you realize what you've done we have assigned the mice to their corresponding holes why is that correct why will that work can we prove that this will always work and so to prove that this will always work what we can do is we can prove that the mice will never cross each other right because if they never cross each other they will always go to their corresponding holes now can we prove that the mice will never cross each other because if we are able to prove that then we'll be able to prove that our greedy solution is in fact the optimal solution so let's go ahead and take a simpler case where we just have two mice and two holes correspondingly now let's say that the what we want to make these mice do is cross each other right instead of going from left mice to the left hole and the right mice goes to the right hole we are going to say the right mice is going to the left hole and the left mice is going to go to the right one but here's the catch here is the most important thing which makes the solution happen both of these mice are identical i know these mice don't have any identity of their own which means that we can look at their paths and we can make a split in the middle what i mean is this i can say that the left mice takes just a slight bit longer out and ends up at the left hole and the right mice ends up taking a longer route to go to the right hole and now what have we done we are saying that if the mice cross each other that is if they have if they are in this kind of configuration then we can always say that we can split them out this way and these mice will end up taking longer times to get to their corresponding holes which is approved by contradiction because we will never take these longer routes we will always take the shorter most optimal corresponding route which means that the sorting approach will indeed work and the greedy solution is in fact the optimal solution so let's go ahead and code this up the code is pretty simple the first thing we are going to do is sort both of these arrays so we'll sort all of the mices by their positions and sort all of the holes by their positions we're also going to have an answer which we start from 0 and now we're going to iterate for every single mice and every single hole in both of these arrays so all this does is is going to give us an iterable of the first mice and the first show then the second mice in the second hole third mice and the third hole and so on and so forth so we'll be able to iterate over these mice and the holes effectively and now i can simply say that the answer is the maximum of answer and the absolute difference between a and b so which is the time my stakes which is sitting at position a to go to the hole at position b and that is it at the end we can return the answer so that is really it we can go ahead and test this out and submit this as well all right cool this works out so yeah this is it for the solution to the problem assign mice to holes hello everybody and welcome back let's talk about the problem majority element now most of the videos on youtube will try to explain to you the boyer moore algorithm which is from a class of voting algorithms however it is one of those which you need to know beforehand to truly understand it plus if you're given this question in an interview there is no way you can come up with that on your own however i'm going to present another solution i'm going to present a solution which is super sneaky something that you can come up with during an interview and it's not even hard it's pretty simple and it's right in front of our eyes all right without talking too much let's go ahead and get started all right so the problem setup says that we're given an array of integers of length n and the majority element is defined as the element which occurs with greater than n by two frequency the goal of this problem is to find the majority element so if we look on the right hand side we see that the input is 3 2 4 2 2. clearly the majority element is 2 because it occurs with a frequency of 4. and this frequency of 4 is greater than the required frequency of n by 2 which is 3. all right so how can we get started with the solution to this problem well let's talk about the 9 solution what is something that we can do right away what we can do is create a frequency table so we can say the 3 occurs with the frequency of 1 2 occurs with the frequency of 4 and 4 occurs with the frequency of 1. nothing special right we've just created frequencies corresponding to each element and now what we can do is after this step 1 we can take the step 2 as going over all of the keys in the dictionary and finding out their values and if the value is greater than the required frequency of n by 2 well we can return that as the answer so in this case as we iterate over the keys we look at 3 then we look at 2 and we realize that 2 has a frequency of 4 which is greater than the required frequency of n by 2 3. so since 2 has a greater frequency we're going to return 2 as the answer pretty simple right nothing too special all right so was the space time complexity analysis well order of n space is required for the solution because we're going to store a hash map or a dictionary which can take order of end time to generate as well all right so we can go ahead and actually look at the code for this which is pretty damn simple in python so from collections we are going to import counter and counted enough is nothing but is going to create us a hash map or a frequency table and we're going to say counter of a first of all go ahead and create that counter and then use the most common function to get the most common one element so basically get the highest frequency element and the rest is just uh syntax related stuff and this oneliner solution will get you the correct answer that is in fact how i was able to solve this in less than one minute but the solution is not the most optimal because we are going to take order of n space and the followup question an interviewer can ask you is that how can you reduce the space is there a way to make the space order of one can you make the space constant which brings me to the sneaky solution at this point other people will go ahead and present to you the boyer moore algorithm however there's a better solution that exists right in front of our eyes all right so let's go and take a look at the array again this is the same area as we've seen before and the constraint is now written in front of us that we have to do it in order of one space if you think about it we have to compress the entire hash map we have to create compress sort of the entire dictionary that we created which took order of n space earlier we have to compress all of that into somehow this order of one space sounds pretty weird right impossible in fact here's the thing whenever you're stuck in a dead end like this i've explained this by the way in other solutions on my channel as well whenever you're stuck in these weird kind of situations where there seems to be no other way and the space constraint is order of one you have to think in terms of bits go in the binary representations okay you don't look at the numbers now as numbers anymore but they're binary representations here's what i mean instead of looking at 3 i'm going to look at 3 as 0 1 1 which is nothing but the binary representation of 3. again i'm not going to change anything i'm not going to write extra lines of code to convert this this is just how it is stored in memory so we're going to write 3 as 0 1 1 2 as 0 1 0 and 4 as 1 0 and i've written this for all of the numbers now what i'm going to do is something very interesting all right something super super sneaky i'm going to write answer over here and we're going to start iterating now if you realize one thing the majority element is the number which exists with more than n by two frequency right what it also means is that its binary representation will exist more than n by two times right is binary representation itself will have a frequency of greater than n by 2. what i can also say is every single one of it bits will also have a frequency greater than n by 2 which means that if we narrow down and if we just look at say this particular column we see a lot of zeros what does this mean this means that majority element has zeros in this place and that's because this column is overwhelmingly filled with zeros there is a majority of zero over here and remember we're looking for the majority element all of its bits are in majority so what we're going to do is we're going to iterate over all of these columns one by one and we'll build our answer here's what i mean so we'll look at this column and we'll find out the majority element which is either one or zero right we're not worrying about any frequency tables or hash map right now i've just flipped the problem on its own head and now i'm asking get me the frequency of one and get me the frequency of zero that's it just two variables nothing else so we can see that the frequency of zero is overwhelmingly more than the frequency of ones in fact it is greater than n by two this means that the answer the majority element has a 0 in this particular column's position all right what about this particular column that's right we see that this column is overwhelmingly filled with once which means that the majority element has 1 in this place so we're going to write 1 in this answer location and then we'll iterate over to this column again and what do we see there are lots of zeros not many ones the number of zeros is greater than n by two so we'll just keep zero over here and that is it so at the end of the iteration we see that the answer is zero one zero what is the integer representation of this binary number that's right it's 2. we've found the majority element and look at what we did right we just iterated over all of these columns once and say if the number is represented in 30 bits we'll just go over this 30 times so it's like 30 times and just the time complexity right now all right this will make sense a bit more uh once we look at the code but mostly this is the logic what we are going to do is we are going to iterate over these columns one by one and then for every single column we're going to iterate over the numbers and find whether the bit is one or zero and we'll count the number of ones we'll count the number of zeros and we'll be able to guess whether the answer will have one or zero in this place all right let's go ahead and look at the code so we're going to start off with a couple of variables n is the length of the a which is something we're going to require very soon then we have the answer which is set as 0 and this is the answer which we are going to return at the end right so as you remember we start the answer from 0 all right so now what we're going to do is we're going to iterate over the columns one by one so we'll say for b in range of 32 that is for every single bit from 0 1 2 3 all the way up to 32 go ahead and iterate over these columns for each of these columns i want you to keep a track of the number of ones in a column because the number of zeros is simply n minus the number of ones right so we can just keep a track of the number of months to get to a solution and now we'll say you know what go ahead and iterate over all the numbers in a this is an order of n time operation we'll go ahead and write order of n over here now we'll say that you know what if 2 to the power of b this is nothing but 2 to the power of b if 2 to the power of b and num is true that is this entire line means what this lines mean that the current bit b is set in nums if the current bit b is set in num then we can increase the number of ones by one and we'll say that you know what at the end of this iteration if you find that the number of ones is greater than n by two that is there are overwhelmingly a number of ones inside of this column we'll go ahead and make this column of 1 as well so go ahead and set this bit 1 inside of the answer we can also write this as this or operation and we can write it as plus it's the same either way anyways once we're done with all of those columns we would have built our answer one by one and we'll have the answer returned at the end so we'll go ahead and test this hang some of this meanwhile let's talk about the complexity analysis the space taken is order of one since we only ever store a couple of variables and the time complexity is order of n times log w now i know this log w seems a bit off since we're just doing uh you know 32 total uh iterations over for the columns but we have to put this log of w because this 32 is not guaranteed right they can be numbers which are huge which are not stored in 30 or 32 bits they may take 50 bits or 100 bits or 1 000 bits whatever that is so we'll just say log of w as the log of the word size so in this case integers had a size of like 10 to the power 9 which is approximately 2 to the power 30 so we took 30 times n iterations right so it's order of n times log w again i know this is not the most optimal the time complexity can be order of n and space complexity can be order of one with the boy or more algorithm however this is an algorithm that you can come up with even during an interview and the thing we realized and the central observation that helped us solve this problem was that whenever the space constraint is so high whenever the space constraint is very very hard and we are working with these integers and there seems to be no other way out we have to think in terms of bits that is the central us is the central observation in getting a solution for this problem this will not only help you for this problem but other problems as well so keep this idea in mind for later all right anyways this is it for solution to the problem majority element hello everybody and welcome back let's talk about the problem gas station all right here's the problem setup we're given n gas stations in total which lie along a circular route each of them has a of i amount of gas present and to travel from station i to station i plus 1 there is some cost associated with it which is given by the b of i so one quick thing to note is that a of i and b of five are two elements from the arrays a and b both of the size n all right the goal of this problem is to find the earliest station in terms of the indices from where we can travel around the entire circuit so basically you start from a particular index i which is the lowest possible index and that index is such that you can start from i and you can make a journey and go back to i right and we have to return minus 1 if it's not possible let's go ahead and take a look at an example assume this is an example given in the question itself and the answer to this example is the index four all right so index four is an index from where you can go ahead and do an entire circular route and come back at index four let's try to verify this and we'll work around with the problem setup so that we understand what's going on better all right so when we're in the station for when we started the station 4 we have gas 7 and cost 1. what does that mean that means that at station 4 we start from an empty tank and we go ahead and fill in seven units of gas right and now cost 1 says that to travel from station 4 to station 0 remember this is a circular route to travel from station 4 to station 0 is going to take one unit of cost right so it's going to take one amount of gas from it which means that the current amount of gas we have still remaining is going to be 6. so we have we are starting from the station port and once we reach the station zero we still have six units of gas remaining so when we reach the station zero what we'll do is we'll fill up the tank with three units of gas again so that brings up to nine units and then we have to spend four more units of gas again to travel to the next station so we had six plus three minus four total amount of gas now which gives us five right so at station zero we have five units of gas in our tank all right what happens when we go to station one we'll do five plus five minus two five is the current amount of tank we have five is the amount of gas we get on the next station and we have to subtract two as the cost so five plus five minus 2 gives us 8. similarly what happens when we go to the station number 2 we do 8 plus 2 minus 1 giving us 9. and then what about station 3 we do 9 plus 1 minus 9 giving us 1. what next well now we can go back to the station four this is the station we started off from and we went ahead and we did a complete circular loop and we reached back at the same station station four is the lowest possible station that we could have started from that resulted in a circular route so four is the final answer for this test case now how do we think about the solution well the brute force solution says that for every single index you know iterate over the array go for every single index and for every single index run a simulation right so that simulation is going to take order of end time as we just saw and we have to do this for every single index that means that we are looking at a total of order of n square amount of time and perhaps order of one space because we don't really store anything than a current variable right so we need to think about an optimization now before we jump into the optimization which by the way is going to be super simple i have to mention one trick which i learned before this trick has helped me out a lot in questions where there is like a circular route or whenever we have to go in a circular direction and that trick is to simply take this array and copy paste it all right so what i've done is i've copied the array the first part of the area first half of the array right now is the initial thing and the second half is just a copy paste of it all right and i've also mentioned the original indices on the top of them so the index 5 is actually the index 0. now how does this help us well think about it this way because we are going on on a circular route if we start from the index 0 we want to end at the index 0 again but because circular things are a bit more complicated to take care of what we have simply done is we have expanded that out and so now we are going to say when you start from index 0 go ahead and figure out if you can end at index 5 instead if you start from index 1 see if you can end at index 6 because index 6 is nothing but an index 1. similarly if you go to index 4 we just want to ensure that you end at index 9 because 9 acts as 4. so all i've done is simply taken the initial array doubled it so in a way we have avoided the circular thingy problem this makes the solution a lot simpler because the only thing we have left to do now is to iterate over that and that is it all right let me walk you through the solution it'll make a lot more sense so let's go ahead and say that uh 0 is the starting index 0 is the station i'm going to assume which is going to lead me to the station number 5. all right i'm going to assume that so let's go ahead and mark this this is our starting index now this is our starting index we start off with the empty gas tank what do we do we fill in three units of gas and the cost is well the cost is four which means that the current is uh minus one well that is not so good we have three units of gas with us and to go to the next station we require four which means that we don't have enough gas to go to the next station here's a if condition for you we'll ask the question hey is the current lesser than 0 because as soon as the current becomes lesser than 0 let's go ahead and make a full reset let's go ahead and say that you know what this station will not work out for us this question this station is uh is going to give us a negative value we don't want that so we are going to say that if the station is going to give you a negative value just set the current to zero let's just go ahead and restart everything from scratch and so in this case i'm going to go ahead and initialize and i'm going to reset the start to i plus one so we simply move on to the index one as the starting position as you can see by the yellow circle moving now at the index one now at the station one we again ask the same questions we start off with an empty gas tank the current is zero as you can see from the if condition previously we start off with an empty gas tank now we fill five units of gas go to the next station we require two so the remaining is three pretty simple so now we have three units of gas remaining that is we have three extra units of gas and now we can go to the next station with three more units of gas than we had previously so three plus two now becomes five which means that once i reach the next station i'm going to fill in two units of gas which brings me up to five units then i'm going to spend one unit of gas so it brings me down to a total of four units of gas all right pretty simple still greater than zero which means that i can i still have four units of gas surplus i have these extra four units of gas just lying around just in case so now i'm going to go ahead and go to the index three so as soon as i go to index three i see that i have four units of gas i fill in with one bringing me to a total of five now i have five units of gas and the cost to go to the next station is nine which means that the current comes out to minus four because five minus nine is minus four which means that this will not work out either we assume that the starting index of one will work out for us but it did not work out for us so what we need to do is we need to go ahead and reset the start to i plus one right we're gonna reset everything we're gonna say you know what screw the index one screw the index zero both of them that did not work out let's just go ahead and restart all of our computations from the index four so we'll restart the current to zero and set the start to i plus one so we start off from 4 now at this point i want you to pause the video and figure out something missing figure out something that is going wrong all of my explanation up till now has been correct but there is one assumption that is wrong well at least that should look wrong to you that's the assumption over here look at this earlier we considered the index 0 then we considered the index 1 as the starting position and we jumped to index 4 directly we never even considered 2 and 3. so now the question is well why don't we want to consider the indexes 2 and 3 what's wrong with them why not consider both of them right and so this is where the optimization comes into play this is the most important part right we we don't want to go back otherwise it'll just become like we're going to start from every single index and that'll become n square that's pain but because we have this logic of starting from start equals to i plus 1 we were able to jump a couple of indices now again this begs the question hey why not consider two and three here's the thing here's the very very important things is my new detail which matters a lot look at the if condition on the left hand side the condition says that if current is less than 0 then go ahead and make a restart in other words i can say that car only passes a station when the current is greater than equals to 0. what this also means is that as it passes through more and more stations it keeps on collecting more and more fuel that is in a one particular station it is going to collect at least zero amounts of fuel if not more so it might be some positive amount of fuel it's going to accumulate every single station it passes through and if it does not pass through well it goes to the if condition and gets reset it so now we know that car only passes when current greater than equals to 0 and it's going to accumulate more and more field which means that starting from one did not give me an answer right starting from one gave us a negative value of four but if you start from two you'll get even a much more worse value in fact go ahead and try this out yourself if you start off from two you'll get gas two cost one giving a current of one which is already lesser than the current of four and now you have one of current you add it with a gas of one and remove cost nine basically now giving you minus seven so if you start off from two you are going to end up much worse you're going to end up with the current value of negative seven although it does not mean anything different but it's just extra computation starting from one was the best possible option because it was the earliest we could have started and we could have collected a lot more fuel if we started off from one instead of two but hey even one did not work out so how in the world will do work out all right i think that's enough explanation for why we do start equals to i plus one and uh so let's go ahead and do the computation we start from the index four we start from the station four now and we have gas seven cost one what does that mean we do plus 7 minus 1 giving us 6. now we'll go on to the next index with the uh capacity of well of course the tank capacity is infinite but now we have the current s6 and we're going to add it to the gas and remove the cost from it so we'll do six plus three minus four notice one more thing that we're doing remember that we copy pasted the array once right if you can see the nicest five six seven eight are nothing but a copy of one zero one two three 4 and of course you can compare the gas and the cost values as well now all the reason why we did that was so that we could simply iterate over it and get our life get our job done make life easy and it is going to make our life easy because now it's simply going to continue with the same logic we're still going to keep that f condition in mind and we're going to continue forward all right so now we are at the index 5 where the station 5 which is nothing but the station 0 and currently we have 5 units of gas what happens when you go to the next one we do 5 plus 5 minus 2 giving us 8 then we do 8 plus 2 minus 1 giving us 9 then we do 9 plus 1 minus 9 giving us one and finally we'll do one plus seven oh wait as soon as we go to the next station i want you to realize something look at that we have reached the station number four and look at the station that was marked earlier the number station 4 was marked earlier which means that we have gone through an entire loop again the station number looks like it's 9 but it's actually 4 behind the scenes right so now we are again at the index 4 we are again at the station 4. what does that mean what does that mean what the initial question was the question was find the initial index which will find the earliest index such that you can go and loop around once and so we have found that index and so what we can do is we can say if i equals to equals to start plus n n is the length of the array which is 5 in this case so if 9 equals to equals to 4 plus 5 go ahead and return 4 perfect right as you can recall the earlier answer was 4 as well and the current answer we're going to return is also 4 pretty amazing right we did nothing special just two if statements i promise you that is literally it just these two conditions and looping over all these values that is it nothing complicated no special proofs or mathematic or arithmetic you need to worry about all right let's go ahead and code this up now so what we'll do is figure out n which is the length of a basically saying that these are the number of gas stations with us we're going to start the current and the starting both from zero as i mentioned we're going to assume the start as zero this is our starting position assuming that this start will give us the answer at the end we also have current which is going to keep a track of the current value of the gas tank now we are going to iterate for i and g comma c in a star 2 b star 2 okay just a quick aside what this means is simply that i'm going to take this array a and i'm going to copy paste it once again so a is nothing but twice of a it's just a plus a right is the same as a plus a all right sorry and then we do uh b plus b or b times two same thing we'll zip both of them a is nothing but the gas and b is nothing but the cost and now we're going to enumerate over that so as i mentioned the first if condition is saying that you know what if the current index i is equal to equals to star plus n basically you have seen this station before the station is a loop of the previous start that you've seen if that is the case look at the condition over here if that is the case i've just copy pasted it return start again simple very very simple okay nothing special we're doing it's just simple stuff all right and then we'll go to this statement with says current plus equals to g minus e so what it says is whatever the previous current was now you add it to the certain amount of value of gas right i'm going to say uh this is current plus g minus e all right very simple i'm going to take the previous value in my gas in my gas tank add some additional gas g and remove some cost of moving to the next station and then we'll move on to this if condition over here as i already mentioned again simple copy paste if current is less than zero that is if we have not enough gas to move to the next station well that means that we have to reset the current so the current becomes zero and we have to set the start as i plus one basically we'll say everything including i and everything before i and including i is all useless for us let's just reset the start to i plus one all right so if you notice we are returning the start over here now if you can find an answer you'll be able to return it over here but in case you do not find any such answer in case there is no such possible case where you can take an index and loop around the circuit once and reach by the same index well then you unfortunately have to return 1 saying that you know what i reach the end of this for loop which means that there is no way there's any such possible index all right and i'm speaking let me go ahead and actually show you and test this out all right cool this works out and we'll go ahead and submit this and there we go our answer is correct all right so this is it for the solution to the problem gas station these visualizations take me a lot of time to make and if you appreciate them if you appreciate the high quality of my visuals explanations and the solution let me know in the comment section down below and give this video a thumbs up anyways this is it for this video solution and as always thank you so much for watching