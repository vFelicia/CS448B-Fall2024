this guide to building rest apis on NEX js14 goes beyond simple Crut operations teaching how to create multiple mongodb models like users categories posts and comments while also covering how to protect API routes you'll get handson experience in setting up schemas building robust apis and implementing Advanced features such as logging middleware and deployment in this course um jam will help you enhance your nextjs and rest API development skills hello everyone my name is Om I'm a senior software developer I'm building web applications for over 8 years now many people use nextjs for their frontend interactive applications but in this video I'm going to teach you how we can build complete backend and build rest apis using nextjs 14 using App directory structure so these are the topics I will be covering in this tutorial first of all I'll will be creating a new NEX js14 project from scratch after that I will be explaining you guys what are the different fold ERS and file structure recommended by nextjs in order to create apis in our project after that I'll show you how we can connect to the database in this case I will be using mongodb after that I will be creating different models for adding relationship between users blogs and the categories and all the relationship happening between these models for example a category belongs to one user a Blog belongs to a category as well as users and more relationship between these models and this point is going to take a lot of time because we will be creating all the apis and adding error handling in our apis after that I will show you how we can add filtering searching pagination and all of different these things for blogs if you want to add these features in your front end application using these apis after that I will show you how we can protect our apis using beer token it means from the client side when you will be accessing these apis if you don't pass any beer token then it will throw an on a authorized error then I'll talk about middle wees how we can add logging or error handling before any execution of the apis finally I will show you how we can deploy over complete backend in nextjs 14 on versal so during the development of the apis in this tutorial I'll keep on testing all of these apis on Postman in Postman we can create collections folders and then the requests for the get post patch delete and put and I'm going to explain you how we can use Postman in order to test the apis by adding different URLs adding authorization headers how we can add different body data over here and test that out so before starting I just want to tell you guys that I have my personal YouTube channel as well where I create videos on multiple technologies that includes react angular node Express mongodb prompt engineering Docker cicd git GitHub typescript and all these different topics and if I go to the playlist mainly I create videos on nextjs so this video is mainly for the back end if you want to learn about front end in nextjs then I have created all the videos on different topics for you guys in order to become a good NEX gs14 developer so you can check the link of my channel in the description of this video and I would really appreciate if you can subscribe my channel as well so let's get started by creating a new next js14 project I've opened up vs code with an empty folder inside it and and now first of all we need to verify if we have the latest varion of node and npm installed in our system once we have verified I'm going to write a command npx create next app at latest dot I will hit enter dot means that I don't want to create a new folder inside my existing open folder in our vs code so I'm going to go with the typescript es lent Tailwind CSS Source directory no app router yes no for customized default so most of these options are related to front end but I'm going to be focusing on backend side only so our project is created I'm going to clear the terminal out so let's see what we have here this is our main folder app and it includes all the files and the folders for our apis for our frontend routes since I'll be focusing on backend side only so let's talk about the folders and file structure for the back end so inside the app Direct first of all we need to create a new folder API and everything we will be creating on the backand side should be added within this API folder and inside this API folder we need to create another folder let's call it users and the name of this folder will become the part of the URL for this API means that in Local Host we are running the application it becomes Local Host colum 3000 SL API SL users and it will become an API if we create a file file called route. TS inside it we cannot change the name of this file it is predefined by nextjs and inside this route. TS I'm going to show you by creating a simplest API so let's create export const get this is going to be a get request we cannot change its name and let's return some message from inside so I'm going to return new next response from next server and this is my first API okay so let's save this file and I'm going to run my project by running npm run Dev and it will run on URL Local Host colon 3000 now I'm going to open up browser and Trigger Local Host column 3000 SL API SL users and this get request should be automatically triggered get request can be tested on the browser because in get request we are not passing any kind of data to it so in the browser you can see that I have triggered Local Host column 3000 API users and this is the response it has returned so it means that our API is working fine now in order to organize our apis in nextjs nextjs recommend us few folder structure techniques so let's say in our applications we have authentication and users apis and we have the dashboard apis that can include the settings all the analytics all the lists of data that we need to show so if we create all the different folders directly in the API that it can become messy I want to organize the folder structure but I don't want that folder structure to be a part of the API URL so I can do that so inside the API folder I can create a new folder let's say all the authentication related apis it can be the login sign up users reset password forget password should be added within this Au folder now I'm going to move this users folder inside this o folder you will be thinking that this o folder now will become the part of the URL but that's not the case this is for only organizational purpose if I go on the browser and refresh this URL you will see that this API is still working without adding the Au so if we add parentheses around any folder that gets excluded from the URLs on the back end as well as if we create the routes on the front end in next xjs now I'll come back to this file when I will need to create all the get post patch and delete request for the users along with the error handling and curing data from the database before this I want to connect my project with the database for that I'll be using mongodb which I can set locally in my system but I will be using a cloud mongodb provider from the Atlas so you need to open up cloud. mongod db.com and sign up with your email ID after that once you sign up and sign in you need to create a new organization I think that it is going to autogenerate the first organization if it doesn't you can go to the view all organization and create a new organization first of all within the organization it will show you all the different projects if you are new to this it won't show anything so these are all the projects I've already created I'm going to create a new project for over rest API in xs14 so I'm going to click on the new project button and here I can name next4 let's call it mongod DB rest API so this is the name I've given to it you can name anything all right so we should not add actually this is optional I'm going to click on next and uh I'm going to leave it as project owner and click on create project so it's going to take some time and uh I myself want to use this API so that's why I didn't add any email Above So now this project have been created and inside this project I need to create a new cluster so by default it's going to give me these options uh 0.08 per hour dollars I'm going to go with the free because this is just for testing once you want to deploy your project on production then you might want to choose any of these options which you can change later on as well I'm going to leave this default name cluster zero I'm going to check AWS I'm going to select the nearest r region uh where I'm sitting currently so I'm going to go and create deployment so it is I've clicked on that it's going to take some time and create the cluster for me so this is the model that it has opened first of all it has given me this username and this password I can generate a new password I need to copy this password over here which I would need later on when I will be adding it in my project so let's copy it and paste it somewhere I've just opened up a new tab and pasted it over here and uh let's go choose a connection method actually so set up your account so I'm going to click on the create database users first of all and then I'm going to click on choose a connection method so these are all the connection method has given to it so I'm going to click on this driver and uh first of all we need to install this package npm install mongod DP let's stop the project and hit enter by adding this command and now this is the URL that we need from here let's click on this icon and it is going to gets copied and in our project I'm going to create a new file and I'm going to name it EnV and let's name it dbor urri equals to and this is where I will be pasting that URL which I have just copied okay and after that I'm going to go and I'm going to copy this password which I saved actually it already added over here earlier here it was not already added which we had to manually add from here all right so here we have this uh retry wres through W majority app name cluster for now we don't need this app name cluster I will be modifying it in my DB connection code okay so let's remove that and let's save this file let's close it and for now we don't need to care about this page for now let's click on the done and let's click on the database and first of all I'm going to go into the network and here currently my current IP is uh added over here means that the API the data that is added in this database can be accessed from my network only I want it to be accessed from anywhere in the word so I can click on ADD IP address allow access from anywhere so it's going to add 0.0.0 from here and I can click on confirm So currently it is pending and after few seconds it's going to be active so it means that everyone from around the world can access over apis if you want to do that on the production you can do that so I've just done it uh on this DB and you can see that it is active I can click on the database and uh I can go to the browse collection and currently it won't show anything because we don't have any data and I will come back to this page once we have the data we will be performing different crowd ations in our project so first of all in this project I'm going to create a new folder and this is going to be called lib and inside this lib I'm going to create a new file let's call it db. TS and inside this file I'm going to execute the Mongo's Connection in order to connect my project on that mongodb database and the URL is I have already added in EnV so let's open up the db. TS first of all I need to import mongus and I need to install the mongus in the terminal I'm going to write a command npm install mongus hit enter so this is going to get installed once it's getting installed I can import that from mongus okay so let's get that URL from that EnV file so I'm going to write mongod dbor URI equals to process. EnV mongodb URI so this is what I've got after that I'm going to write a function con connect async this URL and then I'm going to check if the connection was already connected then uh we would don't want to connect it again so this is just for error handling so I'm going to get connection state from do connection do ready State okay and then I can check if the connection state is equals to 1 it means that it was already connected I'm using tab 9 a assistant extension in my VSS code so sometimes it suggest me uh the code when it sees uh then I have to hit Tab Key on my keyboard and then it gets selected so this is what happens just now and after that uh I can actually add the connection State equals to two so this is the tab 9 a assistant which is recommending and this is right I can hit tab so now I can go console.log connecting dot dot dot okay and then return after that if any of these conditions get failed it means that we need to connect to our database so I can use mongos do connect and then URI and exclamation mark and the reason it is showing this error that it kind it kind of uh uh thinking that it may be undefined but we know that it cannot be undefined we have added it in our project so I can add exclamation mark after that okay so after this I can add this object and let's add the DB name and uh let's add next 14 rest API this is the DB name I've added and this is the buffer command I'm going to give it value true okay uh we can add console do log connected and uh for the try I need to add the cat block as well in case there comes any error so console. log error let's show the error over here and uh throw the error as well so throw new error and then the error all right um I can actually pass the error and like this okay so it is giving us few uh types scripting so for now I'm going to add this data type any over here okay so that's pretty much it for this particular file and one last thing because we will need to access this connect function in uh our uh API files so I need to export it from here so export default connect all right so for this DB uh that's pretty much it let's close all of these files and I'm going to create a new folder inside this live and I'm going to create create models for users category blog and I'm going to add the relationship between these so hit enter and inside it first of all I'm going to create a new file and I need to create the users model first of all so mongus provide us builtin functions for creating the schema like which properties the users can have like the email username first name last name password full number address so I'm going to go with the minimal data because once you understand how things are going then you can add the more data as you want okay so I can add import and then let's add the schema model models and this is going to be the from okay let's create the user schema and for creating the schema I can use that schema class which I have imported above and inside it I can add an object so let's add an email and email is going to be of type string required true and email should be unique okay after this I need to add the username which I can add so this is going to be type string required true unique true and uh make sure you install the tab 9 AI assistant uh it really helps sometimes okay this is what recommending me so after that it is automatically suggesting whether I might want to add the password and yes I want to add the password so this is why it is suggesting me this so password is like this okay and after this I'm going to add another object so whenever this new user gets created or updated I want to create the created ad and updated at time stamps automatically created in my database so time stamps equals to true and make sure you add this after that I'm going to add the con user equals to the models do user or model and then I'm going to add the user comma and then the user schema and after that let's export this user because this user we will be needing in our API route. TS file including the db. TS uh in order to cury the data from the database whether we want to store the data in the database for post patch or the delete or we want to get the data from the database so I'll come back to this folder I'll be creating more uh models uh like the category or the blogs to add the relationship between this user schema but first of all let's create the apis to create a new user in the database uh to update the user to delete the user and to get the users from the database so let's open up this route. DS file now now I'm going to modify this get request to fetch all the users exist in the database although there are no users in the database because we haven't created any yet and we haven't either created the post request in this file which is going to be responsible for creating a new user so first of all let's modify this get API for the users I'm going to add a tri block and inside it I'm going to write a wait and I'm going to call the connect function so before any operation that we perform to the database then we need to call The Connect function that we have created in db. TS file so I'm going to import it from /lib sdb this is the path of the db. DS file and after that I can actually use users a wait and then I'm going to write user this is the name of the model which we have created and this is going to be imported from at lib models and then the user and if I write dot you will see that all of these different functions are prebuilt provided by mongos and we can use any of these functions find means return all of the users data exist in the database find by ID find by ID and delete find by ID and update so I'm going to go and select the find it is going to return me all the users although uh there are no users but we are going to verify and this connect function is working perfectly fine and the connection to our database is working pretty fine so after that I'm going to return a response return new next response and then I'm going to add json. stringify users and I can also pass the status as well let's call it 200 okay and after that in our else not else actually the catch block error and inside the catch block I can return any kind of error as we want okay and for the await I need to write async over here and this error is going to gets invisible now so I'm going to add error in fetching users and I'm going to add plus error. message and uh lastly I'm going to add the 500 status code this error is showing some kind of message so I'm going to add any data type over here so after making some changes in the back of nextjs I try to rerun the project so npm run Dev in the terminal so it is getting started now I'm going to retrigger this route Local Host colon SL uh 3000 API SL user so let's go over here and let's refresh this particular URL okay so Local Host colum 3000 API users and this is going to gets triggered and I'm going to go inside this DB and I'm going to click on this refresh button so let's see if it creates yes this DB name gets created next 14 rest API and along with that it has created this users model although it contains nothing and this was expected but we have verified that our DB connection is successful and the name of the DB with the name users is also successful so it got this users name from this users. DS file from here by adding s after that and if I go to the db. TS you will see this connected string is visible this is because of the console ninja extension which I have installed in vs code now let's open up the route. TS I'm going to close these two files and uh before creating the post request for creating a new user Let's test this get API in our Postman so you need to download the postman you can also use the postman on the browser or you can download it in your system I've downloaded it I've already signed up with my account uh and here on the left side we can see there's a collection environment and the history so you need to go to the collection and you can create a new collection from here if I click on the blank connection uh then this folder is going to gets created inside it we can rightclick and add a new folder which I've already added you need to add a new folder with the name users okay and inside the users you need to click on the add request once you click on the add request uh a random request is going to get generated within that folder okay let me zoom in yeah so now this is the first get request which I've already added and uh here you you can change the name of this get request and from this drop down you need to select the get okay and after that you need to write the URL of the API that needs to be triggered so this is the same URL which we have triggered in our browser and now let's try to trigger this API in post man so I'm going to click on the send and here you can see that it has created this empty array and it means that over DB is working and connection is successful and these are some default headers you don't need to care about that okay so now I'm going to go and I'm going to add a post request so before that actually nextjs what happens is we use third party services for authentication of the users for login sign up it can be the cler authentication next o Au zero kind authentication uh and that gives us all the information of the session of the loged in user the signed up users but in sometime some cases we need to add the same user data in our own database as well because of the relationship within other models in our application so I've already created the videos on all of these different topics on my personal Channel you can check that out and the reason I'm creating the APS for the users in order to create the users instance from the clerk from the next o from the kind or o zero in our own database as well by triggering some kind of apis all right I hope that you have got some point um now let's go ahead and create the post API in our project now so it is suggesting me whether I want to write this yes I want to write this and let me change the name of it to request and this is going to be of type request okay okay and inside it let's add the tri block and the catch block this is required in every case actually okay so now in the tri block first of all what we need to do in the post request we need to get the data of the user okay and the data of the users can be get from the body in our Postman if I show you over here post user and this is the body and from here I will be passing this email username and password data which is added in our model over here and the same data I will be passing from this Postman okay so in order to receive this data in our post request we can have const body equals to await and then the request do Json and this is going to get the data from the body and after that I'm going to Simply connect to the database so if the connection is already established I've already made a check uh over here that it was already connected so we you don't need to care about that it's going to take time to for the reconnection to the database so uh triggering this connect again in each request uh is not going to cause any problem in terms of performance okay so now we need to create an instance for the users the tab9 AI assistant extension is suggesting me few things so I think this is right but I'm going to explain it step by step to you guys so con new user equals to new user and this is going to take the body okay now I'm going to write await new user Dove okay now this is going to connect to the database creating an instance of the new user with the data we have passed from the client side and this is going to save it in the database and once it is going to gets saved I'm going to return a success response to the client currently our client is either a browser or uh any front end application it can be our current nextjs application as well but we are calling our client as a postman because whoever is calling the API is considered as a client okay so now new next response and uh this is going to give us json. stringify let's add message user is created created and after that let's pass the new user data which is created uh this is uh actually this is the user I I had to call it new user all right and let's add the status as well so over here status is going to be the 200 okay let's add some error handling in the catch block so it is suggesting me something let's click on the tab and uh this is going to return error in creating user along with the error message and status is going to be the 500 so it is fine so I'm going to save the file and I'm going to go in the postman and here I can actually right click add request and this is going to get generated you need to change the name of it select post from here and now I can add SL API slash users okay the same API is going to be responsible for the Post request and the only difference is this method which is the post okay default headers this is the body and uh let's go with the same email username and the password so let's click Send all right so it has returned message user is created along with the user data okay and in order to verify whether this user is created in the database or not I'm going to to go in this and I'm going to refresh this page so let's see if the user is visible in the database or not so it's loading yes so our data for this user is created along with this underscore ID this is the unique ID automatically gets created by the mongodb and email username and password and created at uh this is the time stamp uh because we added this time stamp equal to true in our model so it means that our post request for the user is working pretty fine I'm going to go ahead and I'm going to add uh API for the patch for updating the user let's say user is already added in the database and we want to modify its username or we can modify its uh password okay or any other details the phone number uh so I'm going to go and create a new patch request so this is going to be the export con patch equals to async and this is going to be the request of type request let's add an arrow function okay let's add the try and catch block first of all so we remember that uh we need to check for errors okay so inside the tri block what we need to do we need to get the user ID which we want to update and the new data with which we want to update that user so there are two things okay so I'm going to get the data which needs to be updated from the body just like I've got from here okay and also I'm going to get the user ID directly from the body as well although I can get the user ID from the perams from the URLs but I'm going to get the new user name and the user ID directly from the body so in the tri block I can get the body from the await request. Json Let's uh why it got here let's remove it okay so after that I'm going to get the user ID which I'm going to be passing as a body from my Postman from client and then you username okay so here I'm going to get it from the body so a wait connect again connect to the database before performing anything and I'm going to add some error handling there might be a chance that from the client whoever is building the front end might not pass the user ID they might not pass the username so we need to throw an error we cannot proceed if the um the user ID is not found U or user ID is invalid okay and in order to check the validation of this user ID that uh the that is automatically generated by the mongodb there is a way up so I'm going to go at the top and I can add con object ID equals to the uh require and this is going to be the from dot types doob ID now I'm going to use this object ID to check whether the ID of the user which is being passed from the client is uh in correct format or not okay so let's come over here and uh now first of all I'm going to check if user ID or new user name does not exist okay if it does not exist then I'm going to throw an error uh return a response that invalid uh request I'm going to change the message so this is going to be the ID or new username uh not found any message that you want to add okay status is going to be 400 after this I'm going to check the validation of the ID so I'm going to add the types doob ID dot uh is valid and this is going to receive the user ID which we have received from the body So currently it is saying that types not found so we can add the types over here so this is going to be the types from mongos and now you can see that the error is gone and inside it if user ID is not valid we can actually return uh the similar kind of message as above so I'm simply going to copy this error message and invalid user ID so invalid user ID this is the message I have added so once both of these conditions get false it means that the user ID and username exists and the user ID is a valid user ID then I'm going to proceed and find the user that if user should be existing in the database because user there might be a chance user is not existing in the database so update user equals to await user and I'm going to first check find one and update so it's going to first find whether it exist in the database if it find that then it's going to update that with the following data so I'm going to give it these details okay so underscore I ID and this is going to first find with this ID I'm going to give it new object ID and then the user ID all right and after that I'm going to pass the new username and new equals to True okay and this means that uh whenever the new user gets updated it needs to return the updated user rather than the old user which was stored previously okay so once that is done I'm going to check whether the user got updated or not there might be a chance that it return some kind of error okay so if it returns some kind of error uh then I'm going to uh uh show some kind of message that there might be a chance user not found in the database so let's uh return user actually this is what tab 9 a assistant suggested so let me see return new next response message user is updated user updated status 200 that is fine but before that I'm also going to return new next response and this is going to be the Json let's change the status I'm going to change it to 400 and for the message I'm not going to return the user for the message I'm going to say user not found in the database okay and this is going to return if updated user have some kind of error and this variable is this one okay so now we are good to go with this API I'm going to go into the catch block and I'm going to return some kind of error message error in updating user error do message status is going to be the 500 okay so I've updated that let's save this file and uh let's go and verify what is the username so it is the you new user double2 I'm going to remove the double two and update that let's go into the postman create a new request change the name to update user select patch from here add the same URL because URL is not changing because URL depends upon the folder structure which we have added okay and uh then I'm going to click on the body and you can see that we need to pass user ID which we want to update and user ID needs to be existing in the database currently this is the user ID this at the end it is Fe So currently I don't have Fe so let's first verify if the user ID is correct or not I'm going to click on send so you can see that it has returned me a message that user not found in the database because this ID does not exist in the database this is what I have returned over here okay and these are the two things which we I'm getting from the body and let me copy this user ID and I'm going to paste this user ID over here okay and uh let's new user let's add it like new user only okay the ID is correct and this is the new user now it should be able to patch the username let's click on send and user is updated and uh it has returned this response and this is the response which is being returned from here user is updated let's verify it over here you can see new user double2 let's refresh and see if it gets updated or not so I've refreshed and uh yes so it is updated and username equals to the new user now finally for this part particular API I'm going to add a delete request so let's go down and create a delete API by the way I remember some people have some issues like uh they wanted to write something over here in the body but after selecting the body you need to go and select the raw and from this drop down you need to select the Json and after that you can add the Json object from here all right so let's come back over here and let's add the delete request so it is suggesting me this so I'm going to go with that the tabe 9 AIA assistant is an awesome extension of vs code and let's again add the try and the catch block just like we've been adding above like this okay so inside the try block so in this delete case uh earlier in the patch case I was fetching the user ID in the body let me show you how we can fetch the data as a param as a search param from the URL okay let me show you what you mean mean by that if I go to the delete you can see this is the user ID which I'm passing by adding the question mark user ID equals to the user ID and uh this is how I'm passing from here so let's come over here in order to get that I can use const let's add the search params equals to new URL and then the request. URL okay and let's add the cost user ID equals to the search param user ID so this is how we will receive the user ID from the URL so once we do that we need to validate if the user ID is valid or not actually user ID exists or not okay so we can do that let me copy this one the same thing okay so let's copy if and I'm going to paste this over here here let's remove the username we don't need that and now this is going to verify if user ID is actually being passed from that uh client or a postman to this API or not because without this user ID we won't be able to know which user we want to delete okay and after that we need to verify if user ID is valid or not so tab 9 AI assistant is suggesting Me by going through our patch request so this is what it is suggesting invalid user ID and and I think this is fine so types object is valid user ID so all of these error handlings are very essential to avoid any kind of uh problem in our backend so I'm going to go with this and after this if condition I'm going to connect with the database okay so once the connection is established I'm going to find and delete with the ID which is being received from that URL so I'm going to uh write cost deleted user equals to await user. find by ID and delete okay and inside 8 I'm going to pass new types doob ID and then the user ID so this is something which I've have done so now I need to check uh if there is no error because of this and and uh I'm going to return the response so I'm going to verify if there is no error uh if there is uh error in it then I'm going to user not found in the database all right so I have selected this I think this is fine and finally I'm going to return the response that user is deleted successfully and tab 9 aist and is suggesting me this return new uh response string ify user is deleted and then uh returning the user here okay so let's select that I hope there won't be any error the tab 9 a assistant is not going to give you a correct result always so you need to be careful uh while selecting its code which it is recommending okay and uh inside this catch I'm going to uh return the response error in deleting user okay okay so this has been done let's go into the postman click uh create a new request select delete from here and always try to let's first cut this uh this one and now let's try to trigger that send now it is returning me a message ID or new username not found actually I need to change it ID not found only all right so this has to be the message yes and now let's try to add this one this is not correct user ID but let's try that user not found in the database with this ID so ID is incorrect let's try to get the user and let's copy the user ID from here which is the correct which exists in the database now I'm going to pass this particular ID and I'm going to click on send and user is deleted this is the user which got deleted this is fine and I'm going to first verify by triggering this get request whether it returns a response and it did not return a response so I'm going to uh refresh this and I'm going to verify whether uh it got empty or not so guys there is no result it means that user got deleted successfully from the database which is perfectly fine now we are done with this user API I'm going to create new models for the category first of all and I'm going to add a relationship so that uh user uh should be able to create a category and category should belong to one user so this is the relationship I'm going to be creating okay so let's close this route. TS and inside this models I'm going to create a new file and this is going to be the category. TS all right so inside this category. TS I'm going to be importing schema model models from go const category schema equals to new schema and inside it I'm going to write the title type string and this is going to be the required property and after this model I'm going to add the time stamps equals to true and uh let me come back to this part user after that so after this I'm going to add the category models. category so this is fine whatever suggested by tab 9 and I'm going to export default category okay now I'm going to add a relationship between category and the user so whenever new category gets created I want to store the reference of user that this user created this category okay so I will be passing the user ID and the title while creating a new category from the client or you can say a postman so in order to add a reference I can pass the type column and I can use the schema do types doob ID and I can pass the ref this is going to be the user okay so this is going to add the reference to the user model and the name of this user is refering to this model user Okay so I have created this model now let's close that and inside this API I have this Au and for these categories and the blogs let's say uh on the front end side user have to login first and then user goes to the dashboard and in the dashboard uh user sees all the list of the blogs and the categories so I'm going to organize my apis in a way and I'm going to call uh the after logged in page as a dashboard you can call it anything you want so inside the AP I'm going to create another folder and I'm going to name it again whenever I add parenthesis around the folder name this is not going to be a part of the API route structure so inside this dashboard uh I'm going to add a few routes uh for the categories and the category ID so inside this I'm going to add a new folder so let's add categories and inside the category I'm going to add the route. TS file okay so in this file I'm going to create uh two requests get and post for the patch I'm going to show you how we can create the dynamic API route uh to get the data from that URL for particular ID in order to delete or patch the category uh using an ID of the category okay so now at the top just like I imported uh all of these things at the top so I'm going to import these uh as well in this file as well so connect user uh and then the next response and then the types uh we need user and we need category as well so I'm going to import category and the reason we need user because we want to verify the user ID uh which is being passed uh while creating a new category okay so let's create export const get equals to async and then let's add the request of type uh request Arrow function and inside it just like earlier I'm going to add try catch block all right so inside the try I'm first going to get the user ID from the URL so let's add that so let's copy it from this delete request which we have added so these two lines I'm going to copy and I'm going to paste it over here so this is going to give me the user ID which is being passed from the URL so now I'm going to check if the user ID exists um and I can uh check the user ID is valid or not directly in the same condition as well so I can add the not user ID uh or types doob ID do is valid user ID so if both of these conditions gets true uh then I'm going to Simply return a response that uh invalid or missing user ID so I'm selecting this suggestion from tab 9 a assistant extension and I'm going to invalid or missing user ID and this is the message I have given to it okay so after after this if condition I'm going to connect to the database and I'm going to uh actually get that uh user uh which is being passed so I'm going to add con user equals to await user. find by ID and then user ID okay and so you might be thinking that why I am applying some queries for the user uh because I want category API or any kind of category to be seen by that user who created that category this API should not be called from by any user uh uh who and for those user who have not created this category so if this user ID is exists in the database then I'm going to uh fetch that uh category from the DB so if no user then I'm simply going to return a response so let's select that and this is going to be user not found in the database let's go with that and now I'm going to find the category with the user ID so uh let's go user C categories await category find and uh let's select that but rather than adding directly user ID I'm going to write new types do object ID and then the user ID okay I need to end it with the parenthesis so this is where I'm passing the user ID uh matching the user ID which is stored in the database against this category uh so user ID which is being passed from the client and user ID which is stored in the database so this is where I'm checking if both are matching then it means that uh the category is being fetched by that that user who created that okay so now stringify categories status 200 this is going to return us all those uh maybe categories yeah um all those categories okay so um now I'm going to show some error message error in Fetch categories all right so let's save this and let's go and uh create a new folder inside your collection and inside this folder I'm going to go into the this uh category get categories and we don't need to add anything in the body so here this is where I'm adding this uh API category user ID so let's try and see what happens so user not found in the database let me see if user exists in the database or not so there is no user exist let me me first um create a new user um by the previous details which we had so send and new user is created new user should be fetched and this is the ID of the user go to the get categories let's pass the correct user ID okay so now let's send and now user ID exists in the database but there are no categories now uh it means that we are uh getting the correct response now we need to create an API posts for creating a new category directly over here so in order to create a new category again we need to pass the user ID so I'm going to uh write export const post and inside it I'm simply going to add uh that let me copy it from the top so try and paste it like this okay error in Crea category okay so inside the tri block I'm simply going to copy these two lines because I will be getting the ID from that URL so let's add that and below this I'm also going to get the data for the category which is going to be uh the title of the category okay so this is going to be the cost title equals to await request uh dot Json okay so this is how I've got that and U now I need to check if the user ID exist and user ID is valid or not so I'm going to go up and I can use the same if condition so let's add that and below this if condition I'm going to write the connect up till now you might have understood uh the whole process which I'm following but there are new things coming up uh during this video so stay tuned and keep watching and now I'm going to write const user await user. find by ID so here I'm checking if the user ID exists in the database and if not then I'm going to to show some error message over here just like uh this tab 9 as is suggesting so if no user ID exist then user not found and after that I can create a new category so this is suggesting me uh new category along with the title plus the user ID which is being passed from the URL so I'm going to select that this is almost fine okay uh once that is done let's select that await new category. save this is going to to create a new category along with the user ID which is being passed from the client side when we build a frontend application we take care about uh all the U IDs and automatically we don't need to manually copy paste like I'm doing over here so this is just for elaboration purpose okay so this is the save and now I'm going to return a response that a user is uh successfully created so actually category is created okay so let's save this file let's go let's go to the Post category and I'm going to write the title and the user ID should be added from here but let's go with the wrong user ID let's click on send user not found yes and now let's copy the correct user which exist in the database so usually in front end application user ID is always correct with which we have logged in um so U this is automatically handled so now I'm going to paste the correct user ID let's send and now categories created with the title category one along with the user along with the category ID along with created ad and updated ad for this category now let's go and get the categories from that DB let's click on send and this is the one category which is stored in the database let's go and verify it from here let's refresh over Atlas and it should create another model within the database and you can can see it has created this model categories and inside it it should have this category one title its own ID and the ID of the user which it belongs to the user who created this category and the created at an updated that uh for this particular category now I'm not going to create the patch or delete request directly in this particular file instead I'm going to create a dynamic route means I'm going to uh pass the ID of the category directly after slash not the question mark it won't be a cury param like this it will be a dynamic part of the URL but this value is going to be dynamic this is not going to be fixed okay so if I directly create a folder it will be a part of the URL then how can I create a folder with that is going to accept the dynamic value so the way we can add it is like within the categories we need to create a new folder and this has to be within the square brackets and I can name anything inside it okay now this is going to receive a dynamic value and this is going to be a part of URL and inside it I'm going to create the same file name route. TS and inside this file I'm going to create a patch and the delete request for the category so first of all let's import the required packages so I'm simply going to copy these things from the previous previous file and let's add it over here and now let's write export const patch equals to async request arrow and like this let me change it to request completely and inside it again as always it's always a good practice to write error blocks okay and error in fetching error in updating category okay so now in the try I'm going to get the body the data which needs to be updated so it is going to be the only title because uh the title is the only property exists in the category model okay even if there are more uh properties still we can decide how many properties we want to update now I can fetch the title from the body okay now for updating a new category we need to check that uh which category needs to be updated for that we need to receive the ID of the category and I'm not going to pass the ID of the category in the body and neither I'm going to pass it as a cury param as a search param and instead I'm going to receive it as a dynamic value from the URL okay so in order to do that next CHS give us a way so I can add the context column params any and using these params I can fetch that so category ID equals to context params do category so now I've got the category ID from the URL after that uh I simply uh so for updating there are three things the category ID the data I want to update and I need to get the idea of the user that who is actually trying to update that particular category okay so just like I got uh it in the previous patch I can receive the user ID from the uh search param from the URL like this uh update this is the dynamic value for the category and this is the user ID everything after question mark is become the search cury parm and if if it's not after the question mark then it becomes a value for the URL so here below it I need to validate a lot of things here first of all I need to validate the category ID if it exists and the category ID is valid then I need to verify if a user ID exists and it is valid so first of all it is suggesting me this so if user ID is not found and user ID is not valid then I'm simply going going to return a response that invalid or missing user ID just like I've been doing earlier and after that um I need to check if the category ID is valid or not so for that I'm simply going to add an if condition uh let me copy this if and I'm going to copy the category ID paste it over here and inside it I'm simply going to return a response that invalid or missing category after that let's connect to the database and now let's verify if the category with this ID exist in the database and uh user with this ID exist in the database both of these things are important so let's select this find user by ID if it exists in the database if it does not exist in the database I'm going to check and return a response that the user not found okay and after that uh if category um I'm I can check if category exists in the database category. find by ID uh and uh but not with this I'm going to write another condition so I can write the category a wait category dot find one so find one and inside it I'm going to pass underscore ID category ID because the ID of existing model its own model starts with underscore in the mongodb database and then the user ID okay so here I'm checking that the category which is stored in the database I'm checking this ID and I'm checking this user ID as well that the user ID which is being passed from the client the postman is matching with the ID of the category user value which is exist in the database so now I'm going to show the error message that if category does not exist with this user ID and the category ID then I'm simply going to return a response that the category not found okay so that is fine now next let's see what we have to do now we need to find by ID and then the update we can do that so uh we we already find that above but we can simply uh create that as well but it's always a good practice to keep on checking for error handling so updated category equals to uh a weight category dot find by ID and update okay and and inside it uh let's bring it down inside it I'm going to pass category ID title and new true which is fine this whatever it is recommending us so let's hit enter and now I'm going to Simply return a response category is updated with this category okay and uh for the error error is fine so let's save it let's verify that so this is the category now uh cancel and in this Postman this is the API which I'm going to test this has to be the category ID let me go and send it with the wrong things so user not found this is the first error showing so let's first uh give it a true user ID which is stored in its database so this is the user ID let's put it over here we can also update these query params by going to the params this is the user I'm going to update that okay so now let's send category not found it found user user because we are checking user first in our API that's why it return users first then the category not found with this ID so let's copy this ID and see that we have this name category one and uh let's put the category this is not a cury param that's why it is not showing over here this is a part of the URL okay uh we have updated that and in the body raw Json this is going to be the category one updated and now uh this has to be updated let's send and now category one is updated let's go and fetch all the categories and it has this name category one updated and if we check on the database this title should be updated I'm going to click on this refresh and it should be updated over here as well and yes it is updated which is perfectly working fine and uh let me quickly tell you that uh this name the params do category is referring to the folder name within the square brackets okay and this is uh the purpose of the name naming the Within These square brackets uh otherwise we will not be able to fetch the data from the URL uh but uh square brackets means it will be dynamic value the category text inside it is used to fetch the that Dynamic value using this context. par. category so we are done with this patch finally uh for this particular category I'm going to create a delete request as well for delete I'm also going to receive the param for from the context and request is over here so in this delete request I can actually copy and paste a lot of code blocks for the validations so here first of all I can copy this line that is going to give me the category ID and then I can actually uh within the tri block um I can actually uh we don't need to get the body because for delion we only need the ID okay so now I can copy this let's add it over here but within the tri block okay let's add the catch block quickly so error any and this is going to be the catch block error in deleting the category which is perfectly fine and uh below this we can copy these two validation Logic for the user ID and uh for uh the category ID if these are valid and these are uh existing and being passed from that client Okay so so let's paste that after it and after that I can connect to the database so we can actually uh check the ID if it exists in the database so we are checking if the user who created this category is actually deleting this category okay and this is the check we are performing here so now we can check uh before that we can check if the user ID exists in the database or not so if user ID does not exist in the database we are simply going to return a response that user not found okay and after that uh we can uh show if the category find one and it is going through all the file and it is suggesting us this things this is why I like tab 9 as assistant extension so let's select that uh find one category ID user ID so uh if we have the category exist in the database with this ID which is being passed and it has this user ID which is also matching the user ID which is being passed from our client the postman okay so after that we can verify if the category is not found uh then we can simply return a message uh this one okay so we can modify this message category not found or does not belong to the user okay okay who created that all right so now I can actually go ahead and delete this category if everything is going well uh then uh we can we can uh check if uh go ahead and check this if the if it's correctly deleted uh but I can actually directly write category do find by ID and delete and within this I can pass the category ID not the whole thing like this okay and uh we can receive it in our variable but um I don't think that is required uh because if there is any error over here it will be received over here yeah and now I can simply return a success response that category is deleted okay so let's go into the postman let's go into the delete category and uh this is the these are the wrong details which I've already added so user not found from the update params let's give the correct user ID delete category user ID let's select category not phone or does not belongs to user so let's get the category ID from here delete um and uh let's add it over here let's send and category is deleted let's try to fetch the category no category found and I'm going to quickly create the category because we have verified that let's send it and this is the category ID which we have got back and I'm quickly going to update that for later on purpose okay yeah so this is updated this one is updated and I'm going to close all of these four requests now okay so we are done with this category apis now we need to create a blogs API that is going to have a little bit more relationship uh blogs can belongs to a category as well as it will belongs to a user who created blog and later on we can filter out the blogs based upon the category as well while getting the blogs back uh on the client side okay so before writing the apis again we need to create a new file and I'm going to write log. TS okay and inside it just like with other models I can import and I can write schema model models from mongos okay let's add the con blog schema equals to new schema and here let's add title for the blog this is going to be the string required this is going to be the content rather than content I'm going to write the description this is going to be the type I'm not going to make it required and then this is going to have uh a relationship with the user schema. types and object and then this is going to have a relationship with the category okay so category type schema types and this is going to be the category name which is going to be coming from this one the category okay so let's try to add an object and here I can add the time stamps and after this let's add blog models. blog or model. blog schema which is fine and this is going to give me uh this export default blog so we are done with creating schema for the blog and Bas based upon these relationships uh we are going to modifying some ques because we have two relationships now for the blogs so let's close these files and here uh we have these categories I'm going to create a new folder within the dashboard okay so this is going to be the blogs all right so inside this blogs I'm going to create a route. TS file for get and post requests route. TS so let's import all of those uh required things uh which we've been importing in the previous files I'm simply going to adding those lines next response connect and this is the blog and users and the category so we will be needing these users and the categories uh for the validation purpose in this blogs API okay so now let's go ahead and write the get API request for this blogs so let's write export and the get I don't need this context in this case this is the arrow function starting off with try catch as always so like this okay so now I'm going to get uh the search parms first of all this is going to be from the URL so search params new url request. url okay and uh I'll also keep opening that route for this category and U let's actually for this and I need to get these two lines which I have been adding so this one for the user ID over here and then I need to have the category ID right and then I need to check if user ID exists and it is valid if it is not then I'm simply going to return a response return actually let's copy it from here user ID and let's paste it and just like this user ID I also need to check if the category ID is valid and is being added from the client so once these two condition are added I'm going to await connect to the database and uh let's find the user ID and then I'm going to check just like I've been doing previously if user ID is not existing in the database then I'm not going to let it to fetch the blogs because I only want the blogs to be fetched by the user who is uh who is existing and who have created those particular blogs okay so now I'm going to check if the uh category ID uh actually exist in the database or not so for that uh I've already checked if the category ID exists or not so I'm going to check if the category ID actually exist in the DB if not then I'm going to Simply return a response so category not found if the category is not found okay so after that um I need to fetch all the blogs based upon the user ID and the category ID but I'm not going to directly write find or find all later on I will be modifying this API to add the pagination add some sorting mechanism some search so from front end if user want to fetch the datab based upon the keywords search user want to sort the data based upon ascending descending or adding the pagination logic uh like which page and how many items user wants to fetch or uh the start date and date the range for the blocks based upon the time stamps which are stored for the blogs so for considering that I'm going to change the logic of fetching the data so filter of type any equals to and I'm going to write user uh new type user ID and category new type category ID okay uh there seems some kind of error so actually I don't need two things so now using this filter I can actually fetch all the blogs so await blog find filter uh all the blogs uh based upon this user and this category will be returned now I can simply return uh to the client that these are all the blogs with the status code 200 okay um so I think that is it later on I'll come back to this API when I need to add some filtering altering and all these uh options so let's go over here these are all the get blogs and here just ignore these rest of things I've just disabled that I've added user ID click on send so user not found let's go uh let's try to add all the users let's copy this user ID let's give the correct user ID send category not found let's get the categories category get blogs and uh this is the category ID which is automatically added in these URLs okay so and you can see that this is the API SL blogs this was the API SL categories so this is these are the things um I've added so if I add it here you can see that it is returning blogs with an empty array because there is no blog existing in the database yet but uh if it is returning the empty array it means that our API is is working fine um and here I'll come back to this so I'm simply going to add todo over here uh which is going to help me search out that um I need to come back to this line of code to add some more logic so now let's quickly add uh the post requests okay in this route so con export const post and I don't need this Con context here I would need it uh in my patch or our delete request for that again I'll be creating the dynamic route for this API just like I did it for the category okay so now for the post I will need this URL and I would need those uh user ID and uh the category ID as well within the tri block so now and for posting I would also need uh the body the data which needs to be added in the database for the blog it can it can be the title and the description okay uh but let's put all of these things within the try catch block for error handling okay so let's add error any like this and inside this error in fetching blogs okay so after this I need to fetch the body equals to await request. Json and then I can fet the title and then the description okay from the body now I need to check if user ID exist just like above so let me copy all of these things so this these two things and this one as well actually I would need this one the user not found uh and and then I would need this one as well okay so let's copy all of these things from here and I'm going to come here and I'm going to paste it okay so all of these validations if user exists if category exists uh and category found in the database and category user found in the database so all of these error handlings are required because we want to create a blog against a category and against a user if any of these are missing then we won't be able to create a blog because uh blogs must have to be created by a user and blog must have a category this is the Restriction we are applying but it's up to you you can modify it um a Blog can have uh no category as well but uh I'm modifying it in a way that it must have a category Okay so now uh we need to create a blog and yeah so let's close it like this and inside it I'm going to add the title I'm going to add the description I'm going to pass the user ID and the category ID which is passed from uh the URL from the client okay and once we have created a new instance for the blog I'm going to write await new blog save and after that I can add blog is created blog and then the new blog okay so our API is completed I hope it's going to work let's come here let's go and post a blog so first blog first blog description Let's see we have in this param we have the user ID and these user IDs are old I know that it's going to give me the error so user not found this is what I expected so in the get blogs let's copy the user ID from here post it over here and let's copy the category ID from here so both of these IDs for the category and user are existing in the database which I know okay so now so let's send now the blog is created with this title and the description along with this relationship with the user and the category and we can verify it over here by refreshing it and it is going to actually uh add the blogs model over here in the database as well and it has this title description its own ID and the ID of user which it who created this blog and the category which it belongs to okay and the created ad and the updated ad for this blog and these are going to help us sorting um and based on ascending or descending or based upon the range okay so we are done with this blogs uh one and I'm going to create the dynamic folder now just like I did it for the uh category so I'm going to create a blog within the square bracket and I'm going to create route. TS file so inside it I'm going to import everything which be I've been doing uh in this file so let's copy it let's paste it okay so now let's create a get request so in this particular uh route. file uh so on the front end application there can be a page for getting the data for a single blog okay and uh the blog ID can be existing as a dynamic uh param a dynamic value in the URL so that's why I'm creating the get single blog API in this particular Dynamic route. TS file for again for getting a single blog we need to check if user ID exists category exists uh and also the blog ID exist which will be fetched from the uh URL okay and then if all of these conditions are validated then based upon the user ID category ID I'm going to return the blog so export const get and then the context and yes I would need the context because this is the dynamic route so params callon and any okay and the arrow function and now con blog ID equals to the context. params do blog okay so let's add the tri block so let's add the tri block and also the catch block for the error and uh let's give it type any and this is going to return us the error fetching a Blog this is going to be a single blog okay so inside this try I'm going to get the search parms let me go over here and fetch everything yes so request. URL I'm need user ID and the category ID from that URL let's put it over here and after that I need to validate the category ID and the user ID let's copy it from there and I would also need the blog ID verification that this is being passed from the client side or not okay so let's copy this let's add so let's add the blog ID blog ID and then the blog ID over here as well okay and after that as always let's write connect and then um I need to check if user exists in the database and category exist in the database or not so again I can go over there and I can copy these two blocks of code all right so this is going to check the existence of user ID and the category ID in the database now I'm going to return a single blog so let's write con blog equals to A weit Blog this is going to be the model and Dot find one okay and this is going to take the blog ID equals to this underscore ID user user ID um and like this let's remove the couple of things category and then the category actually we don't need directly like this I can remove it all right so once we fetch that uh we can actually check if there is blog exist in the database with this ID or not so I can simply write if no blog exist then I can simply return a response that blog not found okay and uh once if there is no error then I can simply return one blog okay so I'm done with this API let's go over here let's go into get single blog and uh let's copy the user ID over here and let's copy the category ID I know with these uh user ID and the category ID I created that blog okay and uh this has to be the blog ID currently I don't think this is correct but let's try that out so let's send and blog not found actually user was found category was found but the blog was not found okay so here uh let's get all the blogs and yes these are the blogs let's copy the ID of this blog So currently it is returning the array of all the blogs but from here I'm only returning uh one block okay so here let's add add it as a dynamic URL the ID of the blog which exists in the in the database so on the front end side we have the list of all the blogs which we have already fetched from here by calling this API and whenever from front and side we will be navigating to the particular blog detail page we should have the URL U containing that blog ID or maybe in the local storage or maybe in the local state management system and for that we can fetch the current blog ID and pass it to to this API okay uh and then let's send and now you can see that this is the single blog which is returned from the database so our single fetch API get API for fetching a single blog is working fine now in this file just like I created the uh patch and delete requests I need to create that over here so let's quickly create the patch request first of all so I'm going to first of all copy this first line all right so rather than get I'm going to add the posts okay so inside the post uh just like above I can actually copy this catch block let's try that paste it over here so error creating uh actually not the post this is the patch okay error updating blog okay so inside this just like I've got the blog ID from here I can add it over here and inside the tri block uh I need to get uh the title and description the updated title and description which I want to be updated uh so I can click on the try and uh we can get the user ID from here and let's put that in and before that I need uh to have the search param okay search param and the title and the description from the body okay in this case for updating the blog we don't need the category it's just that the uh the user have permission to update the blog okay so after that uh we need to check if the uh blog ID exists or not uh which is being passed from the client side then we are simply going to return a message invalid or uh Missing user ID and also for just like this we can add a check for the blog ID as well we don't have the category here so we don't need that so just like this we can add the blog ID condition here okay so this has been added now let's write the await and after await we can add the check for the users and the blog just like above so let's copy these two things I'm going to modify the category block with the with the blog and uh this has to be the blog so blog dot find one and this is going to be the underscore ID blog ID and the user is going to be the user ID and I'm going to add the blog so blog not found this is the error message I will be returning to the client all right so after that we need to actually update it so we first need to uh check if uh with the ID and then we can actually check it updated blog await and then blog do find by ID and update and then inside it uh I can pass blog ID title description and then the new true okay once that is done and now we are simply going to return a success response with a Blog updated like this okay so let's save the file let's go to the updated blog let's go to the params we need to pass the user ID the correct user ID so I'm going to copy the correct user ID which is existing in the database from here user ID it is added over here automatically and we need to pass the correct ID for the blog which we want to update all right so this has been updated now let's let's go to the body blog one updated blog one description updated and if I go over here you can see that first blog first blog description I want to modify it so let's click on the send and now it has returned me blog updated let's see if it is updated in the database let's refresh and the title and description of it should be updated and yes you can see that the title and description have this updated keyword at the end all right so quickly I'm going to add a delete request and for delete request we need the same kind of stuff uh the validations and all of these things so I'm simply going to be adding it one by one I don't want to waste your time so this is the line which I've added and now inside it I'm going to add uh this one params blog and here inside the try catch let me add the tri block and also the catch block and it is going to return error in deleting the blog and inside the triy block we can get the search param from the URL like this and after that we can actually uh check if user ID or the blog ID exists uh which is coming from the client exist in the URL or in the body okay uh in this uh you both are in the URL actually all right so after that let's again do the connection and let's again to uh check for the user and then the blog just like we have done above so let's go over here let's copy these two blocks of code let's go down after disconnect I'm going to paste these two things and once that is done I can simply uh run this command await blog find by ID and then the delete okay and then I can actually return a response that the blog is deleted successfully with the 200 status code all right so that is done let's go over here let's click on the delete we need to pass the current blog ID over here the correct one the blogs blog ID this one and the user ID user ID exists here so I'm simply going to add the user ID over here and let's try to send this out so blog is deleted let's verify it from the database okay so no results so blog is successfully deleted okay uh So currently there is no blog found I'm going quickly going to add a new blog over here because I'm going to modify this particular get blogs API uh with different kinds of conditions different kinds of logical uh things like filtering pagination sorting and all of these things so I've opened up this main route. TS file because uh the multiple blogs will be fetched on the main homepage where you want to see all the blogs list okay so this API is returning multiple blocks because we are fetching it using the find okay uh so this is where all the filtering all the searching and all the pagination is going to work so that's why I've chosen this particular API to perform all of these operations so let's go ahead and per and show you that how we can add all of the these things so first of all I'm going to add let's say search functionality or a search keyword all right so let's say on the UI you have a search bar and when you write something on the search bar you want to fetch all those blogs uh which have that keyword uh exist anywhere in the title of any blog if there are five blogs then if title matches in two blogs only two blogs should be returned so let's first fetch it from the client side from the postman just like we are getting it uh the category ID and the user ID so I'm going to write keyword actually Search keywords for the variable equals to search param and the value which is going to be passed uh the key is going to be the keywords from the client side and also for error handling uh for any kind of types scripting we can also add as string for this keyword because the keyword is going to be of typ string from the client the postman okay so once we are receiving this search keyword uh we added this filter object over here which we can keep on modifying before finding the blog okay so for modifying the filters let's first verify if search keyword actually exists okay and and then if filter Dot and mongus actually provide a lot of builin functions for aggregation for checking and or uh and all of these things so I want to check this keyword in the title and then in the description as well okay so in order to do that I can write this dollar sign or uh actually it should be an array okay and then there has to be this object so so title this is going to be receiving the Rex and then the Search keywords and after that I need to pass the options and this is going to be I okay and then we need to have it for the description colum and then the reject and then this option I so this or means that the search keyword should exist either in title or in description and uh this is how it is uh checking it and option I means that it is case sensitive irrespective of case whether it found it in the lower case or the upper case it should still return us the response okay so now that's it we need to add for the search keyword in the title and the description for the blogs I'm going to go over here and these are all the get blocks I'm going to enable this keyword okay now it should be added in the URL you know the keywords and then the first all right so now let's try to get that and now error fetching blocks cannot use reix with string so there seems some kind of error if string filter or array and then the title actually Rex it has to be the Rex not Rex okay let's save it and let's send and now you can see that it has returned us this first block because the first keyword was existing in both title and the description so or means that either in both or in one okay if I try to change it something like AB c d in the keywords now this keyword is not found in both in first and the uh title and the description so let's send this out and you can see that blogs are empty because this key word does not exist so on the front end this is how we can perform the search operation and get the data from that API okay you can create a new blogs and you can test that out in fact let's go over here and let's add the second blog and the second blog description let's send that out and let's get all the blogs uh ABC is not found anywhere uh so let's add the second let's send and the second is found which is newly created which we have just done it okay so now let's move further and here let's get more values we are going to get uh this thing let's remove it it's not always required so now search params doget start date and then start date and then con and date date and then end date okay so now if we have a calendar on the front end and we want to find all the blogs based upon the uh start date uh or end date or a range between start date and end date like return me a Blog which was created between 2023 and 2024 or uh give me all the blogs before uh 202 22 okay or any date or even we can pass the month day and the year as well okay so if we pass one it is going to be a starting value and it's going to return all the blogs starting this value up to the end date okay uh up to the date which is current date today okay so now let's go over here and we can modify this filter just like we have done it and for modifying this let's first verify if start date and end date both exist it means we need to check the range uh we need to return the blocks between this so we can have filter do created at and then this and then mongus provide GTE so let's let's select the tab 9 a assist g means that greater than equals to LTE means that less than equals to so start date so return all the blogs U which are greater than and equal to the start date and less than and equals to the end date all right and I'm going to write else if if start date exists then what happens okay and end it does not exist we don't need to check if end it does not exist because if both exist it will be triggered okay otherwise uh this would not be triggered uh so now I can write greater than equals to only return all the blogs which are greater than equals to up to the current date today okay of the recent date now lse if if end date exists only then we are going to filter with lower than less than equals to the end date now this will automatically be appending and we don't need to modify ify this we just are modifying this filter okay let's remove this todo and now uh let's enable this end date now so end date means that uh before this date all the blogs should be returned I'm going to remove this keyword let's remove this keyword let's send so you can see that the two blogs are returned uh because uh all these blogs were created before this date this is why I've added this end date all right and if I write change the year let's say 2022 I hope that it's going to return empty array because before this dat there was no blog created so let's hit send yes so there was no blog so let's uh for our testing purpose let's add 2025 all right so now this is how it is returning the response what's next uh I want to let's say that you can also pass a sending a sending keyword uh from the URL from the client side uh which you can test yourself but in order to append this filter let me quickly show you how you can uh update that uh this is one small assignment if you are practicing with me during this tutorial uh you can also add uh dot sort and then I can write the created at colon and here I can pass as c not to sorted but sort okay um what happened here actually I need to remove this and you can fetch this value from the search param and put it over here whether it is DSC or ASC and based upon this we can sort this data out okay uh this is something you can do and try yourself now I'm going to add the pagination so how pagination works we have multiple pages one page page two page three and then we have the limit that how many items needs to be visible on a particular page so uh we need to find a formula so first of all I can receive couple of things from the client so I can write the page equals to the search param and then the page um if there is no page returned from the client side then I'm going to set the by default page as one and then the limit has to be 10 okay limit means how many blogs needs to be visible now let's save this file and here let's go down before actually triggering this I'm going to uh actually create a formula for the the skip skip is a builtin function provided by mongus that's why we need to calculate that so skip means that on a particular page how many blogs needs to be skipped so let's say there are 10 blogs on the first page on the second blog the blog will be visible from 11 to 20 on the third page the blog will be visible from 21 to 30 and similar on 11th page blogs number will be visible from 1 to 110 okay so the formula is Page minus one multi by limit okay so it is giving some kind of error so let's see uh right hand architecture must be of type any so for that I'm going to go up so this is giving us a string so I can actually write par and and wrap it around like this okay so it seems it is giving some kind of error let's go down okay so there is no error uh but let me hover over it argument of type string now is is not assignable to it so I can add any to it and any to it and then we have this search ps. getet page actually I'm going to add it like this and remove it from there okay so now the error is gone and we are not getting any error over here so if page is two then 2 1 = to 1 then 1 * 10 = to 10 okay so skip means that uh skip first 10 blocks and start fetching the blocks after this skip value means after 10 so for page two the blocks from 11 will be returned so if page is let's say three then 3 1 2 2 * by limit which is 10 10 * 2 = to 20 and the skip first 20 blogs and start returning the blogs from 21 so the 21 1 to 30 blogs will be returned for page number three so this is the formula now how to apply it over here so now I can write a page and the limit property over here uh actually the limit and the skip okay so first of all skip has to be Skip and then the limit has to be the limit okay so this is automatically going to work I don't have so many blogs so I cannot test that uh I don't want to waste your time so if you have a lot of blogs you have created that you can test that out but if I pass page one limit one if I don't pass it still it is going to take the default values the one and the 10 okay but if I want to modify this I can modify it from the front end U like his like this okay so let's send okay it is going to return the same response because I'm at the page one and the 10 if I change it to page two it should return empty array because on page two the block number from 11 to 20 should be returned so we don't have that much blogs so let's test that out and yes on page two there are no blogs uh that's why it has returned empty array so let's skip it one so let's send this out all right so there are more filtering options provided by you can check out the documentation of and if you want to learn more about the filtering options and all of these things uh then yeah you can go to the docs and uh on my personal Channel I've created a long tutorials on node Express mongodb where I've talked about all the aggregations as well for filtering the data out from the database using mongus Okay so let's save it now next thing we are done with uh all of these apis now I want to talk about middle Wares how we can protect over back end how we can add the middle Wares for logging for intermediate error handling for our apis so let's talk about that we don't need to do anything in these files next thing I'm going to create a new folders but before that let's create a file which is recommended by which is given by next yes we cannot change its name and middleware file runs before every request on the front and side before every route on the back end before every API requests okay so this is something we can utilize to uh add further middle Wares in order for logging error error handling um or other uh API protection rules so I can start off writing by importing this next response from next server and uh after that I can export con config equals to and I can add the matcher that uh it should match and trigger in all the files exist inside the this API folder okay and uh after that I can write export default function middleware request request okay and inside it I can simply return next response do next for now okay and if I go ahead and try this out get users and it's still working and that is fine because I've not added any checks inside it so before that let's go ahead and create a new folder over here and that is going to be the middle Wares actually this is the file I have to create middle Wares uh this has been created I'm going to delete that and now let's create a folder middle bears and inside it I'm going to to create another folder API this is just for organizational purpose because I want to separate out the middleware Logics for the apis and if later on I need to add front end I can add a client folder inside middleware folder so now inside the API I'm going to create Au middleware and I can name anything o middleware dots okay so o middleware is going to be checking that if the beerer token from the client side from the postman is passed or not if it is not passed then I'm going to throw an unauthorized error for all of these apis and I'm going to show you the different checks that we can have like the for users I can keep it public and for categories and the blogs I can keep it protected until and unless the beerer token is not passed there are a lot of token types like if I go to this uh drop down O type and you can see that this is the be token basic o JWT o o uh in nextjs usually when we use the third party services like the next o aujs or the clerk authentication kind authentication Au zero uh they provide session ID client ID and using that we can process our middleware to protect our apis as well as frontend routes in every my video of clerk authentication o zero kind O next o which I've have created on my personal Channel I have shown that how we can protect our API routes uh using their provided method using the cler provided method next or provided method and other services provided method so but this video here in this function I'm going to have a simple logic that in case you are not using third party Services still you want to protect your routes based upon the beerer token or any other token TP type or simple Boolean value you can do that how you can do that in the middleware file so this is uh what I want to add here so now uh let's first of all add cost this is not a real beer token I'm not creating any uh login sign up pages on the front end or the client side but this is going to be I'm I'm mimicking the behavior of the real be token if it exists real or false you can check that out out uh uh then we need to protect our routes if it does not exist uh we are going to uh U not allowed user to access these API so now let's say let's create this utility function first of all so this is the token any Arrow function and inside it let's give it valid token you can validate it based upon your own rules which you are using you can use JWT verification encrypt bcrypt whatever you want and I'm just checking that it is already valid but it should exist actually coming from the client side now I can check if uh not valid token or token does not exist then I'm simply going to return false if uh it is not validated or the token does not exists then I'm simply going to return false otherwise return true okay so now I have this function Au middleware request and then the response let's use only request a return type any and here I can write token equals to request. headers doget and from the client side whenever we pass these kinds of beer token let's say I can add over here this property will be added over here authorization beerer like this okay uh so from the client side we use exos or fetch and in the headers on the client side we can actually pass these values So currently let's remove it and now I can get the beer token from the authorization property and uh this is going to be the beerer and then space then actual token so I can split that out so split with an empty space and the second value from that splitted array okay and then I'm going to return is valid colum validate token uh this is going to be the validate this is what I'm going to be using so valid it and I'm going to pass the token okay this has to be an object actually like this okay so this is will be triggered by this file which I'm just going to import and when this is going to be triggered this is going to get the authorization beer token by splitting that out as a second value and this is token is going to be passed to this utility function and this is going to validate if it's true or false or token exists or not based upon that it is returning true or false now let's use this o middleware in our middleware dots file so let's first of all import that instead direct we can directly use that it will be automatically imported above okay so now let's use const Au result equals to AU middleware from middleware you can see there is automatically imported and then I can pass request to it okay this is the request I have passed to it and from this request it is going to fetch out the headers once it is going to be passed that function is going to return me is valid whether it's true or false now I can actually check if Au result dot is valid then I'm going to return the response new next response stringify unauthorized if it is not is valid means if it returns false then it is not it is going to return us unauthorized otherwise it is going to give me access to all the apis and along with this I can also pass up and and checks as well let's say request. URL uh this has to be the request. URL do includes and then slash API slash blogs okay so uh actually this is request all right so it means that this has to if it is invalid or this is blogs then I'm going to return unauthorized so I'm always unauthorized uh I'm I'm making a check that uh this token is applicable only with blogs okay and this validation is not applicable with the uh other apis like the categories or the users so for now let's go over here let's try to fetch the users you can see that I'm able to fetch the users because this validation for un authorization is only being applicable on this blogs okay if I go to the blogs and try to fetch the blogs now you can see that this middleware executes before every API request that is going to happen all the API request Within These blocks because I've added the checks for the blocks for now I'm just going to show you that uh this is how you can add checks you can U add the blogs slash something like that you can be specific which API should be added along with this BR token validation so for now I'm just going to remove this thing so now it is applicable for all the API request irrespective whether it's user whether it's categories or the blogs okay now if I go to the get user send and now it is unauthorized now how to make it authorized uh let's pass this beer token in the headers then it's going to return me true okay so let's go and select the beerer token from here and I'm going to use beerer and then this is not a real token I'm just mimicking the behavior usually be token is a combination of uh you know uh this this kind of thing now I've passed this brra token now let's send now you can see that I'm able to fetch the value because I'm passing the beer token for for posts as well for update for get categories let's try to get the categories unauthorized let's pass the beerer token like this now I'm able to get the categories from the database okay now this middle Weare is running before every API request this is what I'm trying to explain you guys now let's say that I want to add multiple middlewares for logging I want to log some information in my database that which API request uh was triggered and what was the method type for that API okay so uh now let's go and in the API folder and I'm going to actually not the folder the file and I'm going to add log middleware dods okay and in this particular middleware I'm simply going to export function log middleware request of type request okay and this is going to Simply return the response column request uh request. method append it with with request dot URL okay this is the simple logging and we can modify this logging operations by our own data all these things and now let's log the information uh before every API request that is going to be triggered let's come inside this and I want this loging information for only blogs API and just like I have added this condition I can add this condition for uh logging the information for only blogs API so for that I can actually add uh request do url. includes SL API blogs so it is only going to work with this blog API if you want you can remove this condition as well so now const log result equals to log middleware this has been imported and let's pass the request to it and now I can simply log the result by uh log result. response all right so let's save it now uh let's trigger that out uh this is only going to work for blogs so let's get the blogs let's send unauthorized let's add the beerer token and let's add the value send now I'm able to fetch the blocks let's go over here and now you can see that this is the URL got triggered this is what it printed this is the method type this is the URL it printed uh and we can add more information and this is the uh this is the thing that it has printed actually I think this is the one okay yeah uh so and we can modify this one and uh let's pend yes to it okay and see which URL is this let's hit send and let's come here and yes this is the URL and we have this yes appended after that uh so this is how it is working and we can add as much middleware as we want and if you want to remove this you can remove it and add some more conditions as well and our routing is protected over apis are protect protected um and over logging middleware is working fine so we are done with creating apis now it's time to deploy over nextjs application with this whole back back end of the rest API on the versal so let's go ahead but before that I'm going to first verify if there are no issues in my code because versal run this command npm run build so before deploying that I'm going to verify that if there is no error here then there won't be any error on the versal usually there is no error on versal uh but let's verify that so it's currently building that till now if you have learned something new if you have liked my tutorial uh I would request you guys to check my YouTube channel from the description of this video and do subscribe my channel as well so I think there is no error yes there is no error now I'm going to open up the GitHub and I'm going to deploy my application on versal so first of all let's go ahead on the GitHub and create a new repository and I'm going to give it a name next 14 rest apis uh yes and uh I'm going to leave it public because you will get the link of this repository from the description of this video and uh do give it a star guys so let's not add read me let's leave it by default let's click on the create repository so it's going to gets created and first of of all I'm going to open up this G ignore and I'm going to add EnV file over here I don't want to put EnV here uh I will manually be adding this uh mongod DB URL in my versal environment okay so now let's add get status these are all the changes and uh I'm going to write git add Dot after that I need to commit that out so let's copy this commit command let's add over here and this is committed and I'm going to copy all of these three commands at once so I'm going to add it over here and let's hit enter so this is pushed let's restart okay the page is reloaded and these are all the changes I have just pushed okay and uh there is no EnV file this is perfectly fine now I'm going to open up versal decom and uh I'm going to add a new project and these are the all the uh repositories which I have added in my account I've already added my account inversal uh so now let's go and import this particular repository and before clicking on deploy let's go to the environment variable and I'm going to open up EnV let's let's copy everything from here and I'm going to paste it directly here all right so now uh let's click on deploy okay so it's going to take some time in order to deploy that so let's wait for it all right guys so our project is deployed you can see congratulation and it is showing the default UI on the front end this is the default UI when we create a new nexj project although I did not touch the front end part of next JS so but still it is showing the default UI from the homepage I'm going to go and continue to the dashboard and it is going to give me the URL where our app is deployed this is the URL okay I'm going to open this up and our app is deployed now let's copy this base URL earlier we were using Local Host 3000 and currently we have this one and I'm going to add it rather than Local Host 3000 okay and let's try to trigger this currently it's showing unauthorized uh it means apis are working that's why it is showing unauthorized but uh we need to pass the beerer token so let's go and uh let's get all the blogs okay so but I'm going to replace Local Host 3000 with the deployed instance that we have the next 14 rest API and now let's see because the database is same still it should return on the same data which was returning on the Local Host so let's hit enter it is taking some time because it is a deployed instance so let's see and now guys you can see that it has returned me this data with this deployed URL so our deployment is working and we are passing BR token earlier um on the browser we had this unauthorized let's try to get the users as well because we are passing the beer as well so I'm going to replace the base URL with the deployed version okay and let's hit send and now you can see that it is not throwing unauthorized error in fact it is giving us this URL the the the data in the Json all right guys so I hope that you have learned something new from this video if you have liked my video let me know in the comments of this video and again guys do check out my YouTube channel as well for more videos on nextjs so hopefully I will try to create more videos on free code camp and I would like to thank free code camp for giving me the opportunity to create a tutorial for this channel so guys thank you so much for watching see you