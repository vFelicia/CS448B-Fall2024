I thank you for coming like most of you I used to be a Java developer for ten years our twist TDD design patterns solid principle and then two years ago I joined big panda and I switched to a functional Scala and after a while I realized that the wearer's writing and reading code was very different I was thinking way less and in a good way so my day as a Java developer would look like this I would start with some code and in my mind I have a mental stack and I start to read a function and it might want exception it might not so the thing I have to do is to go with the implementation see the possible exception put it in my mental stack and go on and then I would continue I would read another function that would go to the database and again there might be an exception that might be other kind of errors so I would go to the implementation put this in the back of my mind and continue and again and again so what happen at the end is basically overflow right too much stuff to track and that's something you don't want to do so I'm gonna give you a few techniques to avoid that and we're gonna talk about functions about the data and then about patterns and then we do a quick summary and we have questions at the end so the first tool I'm going to talk about is function signatures the way I think about function signatures this way like a newspaper send a newspaper you have articles and you have titles and a good title should tell you enough about the content of the article you should enough to go and read the full article so a good function signature should be the same way right so let's take a look at this function what's going on here well we have an input it's an int and we have an output you to string so the way to visualize this thing would be like this we have types right it's this circle right ends and strings and we have values and values would be 1 2 3 4 ends or ABC whatever for Strings and the function is simply the mapping between those values right and I don't really need to know anything about the implementation what matters here is the function signature when I see this visual I get the full picture right so let's take a look at this function what's going on here to divide functions it takes two int and it gives me back an int right I'm dividing two values and I give it your back 1 and if I give you 0 I throw an exception so the way to visualize this thing would be like this right so I'll give you 2 is 5 & 5 and you'll give me back one I'll give you 10 and 5 you give me back to write this visual is straightforward but what happen if I feed it 0 what happened to the visual right well this thing happens why there is an hour that goes to some value that is not defined something not natural is going on here this behind the circle right there is the exception thingy and the way right that's a bad function signature right you want why is it bad right why is this function signature bad well it lies it doesn't tell you the truth you have to go and read implementation to understand what it does and you have to keep this exception in the back of your mind and that's only one function imagine a lot of those you have to change those and you have to put on top of your mental stack again and again why you don't want that so the way to avoid that is to use total functions total functions are very simple for every single input they have a corresponding output so the visual is very clean right here we have the increment function I'll give you one you give me back to give you two you're giving back three it's very straightforward the function signature is trustworthy right it doesn't lie to me I can just I don't care about implementation what I care is the signature here and it tells me the truth the trust is back and what okay so let's go back now to the divide function we'll come back to divide function after we're just gonna move to the pure function first this is the same function as before right the Inc function here that's the same it's something different up in here what's different here is it a total function oh yeah it's the same function if I give you one key thing back to but something hell's going on here there is a printing in the middle here right and what is this why it doesn't look so bad right now but it could be anything instead of printing it could go to the database and drop the full database it could launch missiles the point is I don't know from the function signature what this function does again it's lying to me so you have to go you have to read the function and then you have to put this in the back of your mind this thing is called a side effect so you want function data sideeffect free and this functioned I call pure functions right and when you use pure function you think less about the implementation what matters is the function signature not the implementation all right so let's go back to this divide function and it's try to fix it so the way to do it right is to use this container type called either and it will tell the reader of the function that there might be an error in the in the function right what is doing basically it's bubbling up the internal of the function at the level of the function signature this either type will tell you on the left side that's the errors right and on the right side the good value so now as a reader I don't have to go and read the implementation I can just look at the function signature and that's it I get the full picture here right we're going to talk about these container types now with you the most common ones quickly right in the standard library in job in SCARA sorry so one of the most common one is option so I would have a function like that which is middle name not everybody as a mineral name and when I read this function signature it will tell me they might be a return value or they might not right it's all about readability and to express yourself to the reader of this function either right basically this container type just wrap the simple type right that's what we do here you see with this brackety thing e so inside you put the type that you would like to return and here again it will tell you this function might return errors we have a list and this is a little bit different it's talking more about the shape of the output when you read this function right it will tell you you might have multiple output values it's a little bit different than before we don't talk about errors we talk about the shape of the output values and then a future that's also very interesting future will tell the reader of the function that the value that is expecting might be or might not be available right now it's more about when this value is available all right so let's recap quickly we talked about total functions and now for every input you have a corresponding output we talked about pure functions that have no side effect and then we talked about container types right we saw how we fix this divide function with either and you have to when you use all these techniques right you get you enrich your signature right you give a new meaning to your signature think about the newspaper right you want a good title you don't want the reader to go and you read the for article you just want to give him a good headline so good function signatures make you think less about the implementation that's the whole point right the mantle stock thing you don't want to go and read implementation every time that's what I used to in Java always I would just to click on the function everybody is doing this look look it up what is it doing you don't want to do that you don't have to do that when you use total functions when you use pure functions when use container types you have good signatures and you don't have to think about implementation alright now we're going to talk about another property of functions and it's a little bit different this was a big aha moment for me in functional programming it's not so much about if I care about the implementation but more about how many ways could you implement the functions it's very interesting think about writing the function signature and I give you a pen right and it could be 10 pens you don't know how to write this function there are so many possibilities so let's take a look at this function right and this is a parametric function so we have a parametric type a this thing tells you in the bracket what it tells you that you could replace this a with any type could be a string could be alone and int a list whatever that's what you have to think when you see this parametric type and the question is how many way could you implement this thing could you implement this function of course you think total functions pure functions we don't use side effects we don't throw exceptions and we wish treating ourselves not to use all this magic hashcode function to string functions all this stuff that comes from the object Java class right so how many ways 2 3 4 what turns out there is only one way to do it right and what's interesting here is why is that why is there only one way to implement this function so the answer is easy we don't know anything about a this thing is so abstract that I don't know its values if I tell you int right you can draw the circle of ends in your mind and you know the value 1 2 3 4 bit if I tell you a you draw this circle you don't know its values you don't know any function on a so you put into a corner here you have no choice you have to return the input you have only one way to implement that what if I do that what if I enrich the type signature with a container type right with list I'm doing a small thing here I'm just changing this a into a list of a and I'm returning a list of it so what I'm telling to the reader is the shape of the input could be multiple eight and the output could be multiple eyes how is it going to affect the number of implementation how many ways could you implement this function now what did it do to the implementation space well we can implement it a little bit more right you have a little bit more possibilities we can switch the head and the tail we can do some some stuff but not so many right we can't sort this thing we don't have any ordering or nays right we don't sort the list so what what happen here basically we just enrich the function signature with a container type and we get a little bit more of implementation space the way for you to write this function is a little bit more there is a little bit more ways for you to do it and the last one would be to do something like that what would this do to the implementation space of the function what did I do here I just remove the a as a return value and put an int right and think about it again this int you can draw it in your mind it's a circle with the values 1 2 3 4 so how many ways can you implement this well one can written 1 2 3 4 5 the number of ends right so what happened here well what happened let's think about that we just jump here to another dimension of number of implementation that's interesting we started with something very abstract with one a right and we are not in one way to implement it and then we enrich the signature with a list we add a little bit more implementation possibilities but not so much not so much and we finished within and we just jumped to another dimension so what does it mean this thing well this notion is called pyometra City and it's very interesting why is it important to you because when you use a parametric function right the more it's abstract the less way you have to implement it the less possibilities for you to make a mistake right it's like giving you a blank page and I'll give you one thing or if I give you 10 pens so what you have so many choice that you could make mistakes but here when you use permit Rissa tea to more abstract it is the less you have to think about how to implement the function right it's not so much about what implementation is with the function signatures it's more about for you as a developer how to write the code right you have to think less about it makes you think less about your implementation so we talked about functions right about total functions pure functions parametric functions but of course functional programming is programming with functions but we all know that software is not only functions right function like software is about designing data and designing behavior it's beyond functions right there is something else there if you want to build a fullfledged application you can't just start writing functions it's it's not going to work out and is there a way we're going to start with data so is there a way to encode data that would make you think less that we have this property for you as a developer to think less in a good sense right so the way to do it is to use some types some types is a way to encode data so it's very simple here we have a developer trait which is basically an interface and you would have a DevOps which extends this developer trait then you would have a full stacker with a salary net and then you would have an ml developer with a salary in long and what does it really mean this thing right why would you want to encode the data this way why would you want to use this some type button this button some types is also referred as algebraic data types so keep this in mind and why would you want to do that why would you want to use that why is it a good thing well first the compiler will be with you when you use this thing right if I were to function say hi that takes a developer and I pattern match on it if I forget a case the compiler will tell you you forgot the ML case right something that is extremely powerful in Java the compiler will only check the syntax if you forget a semicolon or like a bracket well in Scala it will check the correctness for you something that is very powerful a lot of functional programmers will tell you you know if it compiles it works well comes from that because the compiler is not only checking the syntax but checking the correctness of your code that's why they would say that also this ADT's these subtypes were all the immutable so you don't have to think so much about concurrency bugs shared mutable states you can't change this stuff right this developer you can't really change if you want in your instance of it you have to create a new one so you don't have to think about all this possible mutable short state all right so what about this function the load use of function but you've seen it in a lot of code bases you know these strings everywhere this ends these Long's you don't really know what it is right here this load user could use the ID could use the email you don't know you want to encode your data to make you think less about all these possibilities you want the compiler to work for you and the way to put some domain knowledge in your values right I want this load user function to take an email so the way to do it is to use value classes and basically this value classes is just a simple pattern you wrap your simple type and you extend any var and now you get a nice type right my lord user takes an email what is it doing what is why this thing important because you put in two main knowledge inside your types the compiler now will be behind you to catch you when you make a mistake you don't have to think so much about what these strings don't you know what they mean this doubles is it money is it time no one knows right but if you type it properly with value classes you don't have to think about that all right let's recap we talked about ADT's right about some types and how they encode immutable data and how the compiler will check the correctness of your code when you forget an edge case there is basically basically there is normal edge cases you don't have to think about forgetting and a case the compiler will do it for you we talked about value classes and now how we can just put domain knowledge inside the types so the compiler will also help us to write code that is more correct so all these techniques right about data will make you think less about the correctness you don't have to think so much before the compiler will check the correctness for you something that I believe is extremely powerful and Java doesn't give you right all right so we talked about functions we talked about data and what's left or patterns right the way to design software in the old world would be like that design patterns we all shred it it's what what are these design patterns well the elaborate class hierarchies actually they have the good value right this stuff if you used it you see that it's very valuable all these buttons do emerge in your software you do see them you do see abstract factories visitors and stuff like that but you know they sit in a book somewhere right every team that you worked on I'm sure you've seen it will implement these buttons in a different way also when you start learning those it might have happened to it happened to me you start using them everywhere so what you get is all these overengineered code bases it takes a long time to internalize these patterns so is there a way right and to fit this in your mentor stack all these patterns it is not that easy right so is there a way to design patterns to have patterns that make you think less about that would make you think less right you won't have to fit all this stuff in your mind so let's go back to the function world and try to do patterns at the functional level okay so how would you spot patterns the old way well you would look at your code you will refactor and then you will see a lot of similarities so here is the it's exactly the same thing you have to look at your functions and try to support the similarities right and what are the similarities at the function level Wow the number of parameters the number of outputs the type right if the tides are the same the shape of the functions so here I have 1 plus 1 Aiken can't be least 1 2 3 that I want to come cut with least 4 5 6 so what does all of this stuff has in common let's try to find a pattern here well they have the same number of parameters right I give you 2 inch you give me back one I give you 2 strings you give me back one right so that the same number of time it is also the type is the same right I'll give you int + int you give you back in need that's the type of similarities you have to pay attention now right it's very different from design patterns now you don't look at classes in IR keys you just look at your functions at your types at your parameters and you try to see similarities so this stuff you would refactor it to this type of function right combined ends I'll give you two int you'll give me back one combined strings the same I'll give you two of strings you'll give me back a string something with lists and what is the essence of this stuff right what is what transpire I love this pattern how can you capture that well it's this thing right you can feel it it's one a and another and I'll give you back an h1 type two of the same types and I give you back what and I would you encode this thing in code how would you do that well the way to encode this is to use type classes that's the way to extract the similarities at the function level and type classes are not classes they are trait right it's an interface they are my parameter we see here a and the function that we wanted to extract here this combined thing is here it takes two A's and give you back an A it's very abstract we don't have an implementation but we can fill that this is the right encoding and this is a parametric function that's the tool for the job right a parametric function it's very abstract right so all right now I have this stuff what I do with it right what do I do with this how do I use this thing right it's so abstract well one way to do it would be to implement instances so it's very tedious right it's manual you just doing you and you override this combined with your own type so here we do for internet and we'd be and which supply the implementation for combining to it here we decided to do a plus same thing for Strings right I override this combined method with string and string and I give you back my implementation of it you can also do it for your own types right here I created my own class foo and it takes an INT and a string so I can also implement the combined method for foo right it's my own implementation and I tell you how to do it so we take the first parameter and the second one and we give you back a new foo this stuff also you can pay attention use and places that's the to wait a bit so why we use implicit because we want to summon the stuff and get it magically with the implicitly syntax right it's very nice you see I give a and B I get a B 1 in 1 I get 2 and same thing for food great ok that's a nice refactoring it's very nice but did we really gain anything here did we gain something right from the old way well first of all we don't use la siroque is right all this scary like XML stuff just doesn't exist anymore right we work at a function level right so we talk we don't you we didn't use any inheritance here right we just choose overloading we didn't use inheritance and like design pattern this stuff as a name right one of the strongest aspect of design pattern is the other name so if I'm in a team and I tell my coworker I used an abstract Factory it's supposed to know what it is the same thing with these functions with this pattern these patterns of a name and this combine of all thing which would that we just discovered it's official name is a mano it right so this stuff right all this and that's not the only pattern to it with a lot of these patterns and a mano it it's the same thing you see the combined method is the exactly the same thing right takes two of the same give you back one of the same it's the same trade also it has an empty we will need that later but basically for the plus right for in the empty would be zero right you want one plus zero equal one so you need this so great but you know what well you don't have to know this stuff and you don't have to discover it you can just import them that's something that is extremely powerful right you can do that you can import mono it from cats opens ecology we can also import the instances right you remember I wrote them right for ins for Strings where you don't have to do that anymore from the library and think about it right think about our power for this thing is when you want assign pattern everybody would go to the book and would implemented its own way there is no libraries for design patterns just does not exist here not only you have the check interfaces you also have the instance someone very smart wrote this code for you you just have to take it and to use it right so if I import this stuff I can do the same thing I get this magical combined method on one on the value itself I got this combined method I can just use it one combined one two same thing on string I did not have to write any code distinct em for free right same thing for list 1 2 3 4 5 6 this thing is great and of course that's one pattern but as Rob Norris would say everything sufficiently polymorphic and useful already exist what does it mean it means everybody that worked on these patterns why they already discovered for you ok there is a big community out there that worked on those already and just supply this stuff for you in this libraries you just have to look up the documentation take what you need and put it in your project that's something that is very powerful that does not exist in the old world these design patterns don't have that you don't have this libraries with implementation to use and you can just go and take what you need also because these patterns are so common right is mono there is a huge ecosystem building on top of this libraries all these type classes well you can also get you CDs full class that we define before and I had to write manually the implementation if I want I can use this library called kittens I just imported and it will magically figure out what is my mono it instance it will give you magically this combined method for free right that's very powerful all these libraries work with this functional pattern so you get all this stuff for free and this is an example right you could add what you read about tight glasses it's not only that you get this free thing where it is combined you also get a lot of what's called the right function so let's take a look at our model again the combined method that we discovered is called the function that the definitive function where it's defining the type class but we also have and this the right function here is for example combined all these top you also get free and that's a very interesting I just want to show you the implementation you don't have to implement it right because you get it for free but that's the way to implement it think about parametric City what we talked about before the way I mean not so many right you know you have to use this empty and combined look at this function it's only defined in terms of these two abstract methods right about empty and combined you know you have to use them you know you get a lot of inputs so you know and you have to get one so there is only one thing you can do is to take all these values and holden that's it to write this function is so easy because you don't have so many options that's parametric City in action right there so you can just import this stuff and you get this combined all for free right now I can combine lists alright I can give you one two three I will get six ABC I will get ABC and Foods and it works right so let's wake up quickly about this functional pattern how do you encode functional patterns while you use type classes these type classes of parametric function and also the way to implement these type classes would be to write instances we saw that you can use cats or Scalzi and import it directly into your codebase and you don't even have to write your own instances this thing will give it for free also we saw that we have all these libraries that build on top of all these functional patterns and something very important right all this knowledge all this functional knowledge you keep it with you as opposed to spring or Ivan eight or whatever framework these things does not get all right all these patterns two way to encode functions well these things is forever whatever language you use framework these things stay with you right throughout your career you grow into it and you don't have to think each time when you move to a new team I need to learn this and you to learn that well this stuff is universal right so it's do a quick summary we talked about function signatures now you can use total functions pure functions and container types to write great function signatures so you don't have to think about what is the implementation the mental stack again you want it free of clutter we talked about ADT's right about data and how to encode data in a way that would make you think less about the correctness of your code the compiler will catch all your edge cases and then we finished with design part with functional patterns and now they would make you think less about you don't even have to think about the implement you get them for free from all these libraries you also don't have to think about all these class hierarchies that used to be in this all design patterns you just get them for free from cuts and Scalzi so use this stuff right think less about your code thank you very much