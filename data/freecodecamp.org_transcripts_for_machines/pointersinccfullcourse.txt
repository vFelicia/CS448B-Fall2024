The course you're about to watch is about pointers in C. The course was developed by the excellent instructors from my code school. My Code School is one of the earliest software channels on YouTube, and has inspired many developers and creators. In the description. I've included a link to an article about the channels amazing story. Now let's get to the course. pointer is a very fundamental and important concept in programming. But a lot of beginner programmers find it difficult to understand pointers. So in this lesson, we will try to demystify pointers. And all you need to know to understand this lesson is how to write a basic C program, how to declare a variable and how to do simple arithmetic upon those variables. Okay, so let's get started. To understand pointers, we first should understand how various data types or various variables are stored in computer's memory. Okay, so let us say, this figure in the right here is computer's memory. And when we talk about computer's memory in context of program execution, we mostly talk about the random access memory or the RAM, we often say that my machine has got two GB of two gigabytes of RAM, or four gigabyte of RAM. Now let's say these segments, or partitions that we are showing here in the memory is each one byte of memory. Now in a typical memory architecture in a typical computer architecture of the memory, each byte of the memory has an address. So let's say the first byte in this memory, which we can assume to be the lowest by deep down here has an address zero and the address keeps on increasing as we go towards the top. So we go on like 012. And let's assume this particular address is 201. So the next byte will have an address of 202. And we will go on like 203204, and so on. Now, when we declare a variable in our program, let's say for example, if we declare a variable a of type integer, then when this program executes, the computer allocates some amount of memory corresponding to this particular variable. How much memory it allocates, depends upon the data type, and also upon the compiler. So in a typical modern day compiler and integer is allocated four bytes of memory. Character variable is allocated one byte of memory, float is allocated four bytes of memory and we can have other variables as well. Okay, so as soon as the computer sees a declaration, like this, during the program's execution, it knows that this is an integer variable, so we need to allocate four bytes of memory. Let's say in our example, it allocates memory starting address 2042 address 2074 a. And the computer has an internal structure, a lookup table, where it stores this information that there is a variable a, it is of type integer, and it is located at address 204, which is the starting address of the variable. Now, if we declare another variable, so for example, if we declare a variable named C, which is of type character, now once again, when the machine sees this declaration, it knows that it is a character variable, so it needs one byte of memory. So it looks for some free space, let's say in this case, it allocates the address to 09 the byte 2094 C, and once again, it keeps an entry for it in an internal structure called lookup table, that a sees a character and its addresses 209. Now when we perform some operation with these variables, like let's say if we initialize a to five, when our machine or computer sees such a statement, it looks into the lookup table for this variable A. So it finds this variable a that it is an integer and it is at address 204. So, it goes at address 204 and in these four bytes starting 204 it writes this value five now in reality, the value is written in binary but for the sake of understanding we are writing here in decimal form. Now once again, let's say we have some statements and then again after these statements, we have another statement which increments a Now again, when computer sees that, he has to be incremented, it again looks for this address for a goes to the address and modifies this value at this particular address. So this block of memory allocated for a stores the value six now. Now, all of this is really cool, but can we know the address of a variable In our program, or can we operate upon these memory addresses in our program? Well, yes, you can do so in a C or c++ program using the concept of pointers. pointers are variables that store the address of another variable. And to make you understand about this a little better, I'll redraw a couple of these things. Let us say we have a block of four bytes at address two sort of food that stores an integer variable a. Now we can have another variable, the type of which is pointer to integer. And let us say the name of this variable is P. Now this variable p can store the address of A. And using the properties of P, or using some operators upon p, we can reach a. Now p also takes some memory. So let's say it is stored at location address 64. And it also takes four bytes of memory, we can also modify p to point to another integer. So let's say if we have another integer at address 208, named B and having value 10. And if we change the address in p from 2042208, then P now points to me. Let us now see the syntax of pointer variables and see a normal variable is declared by writing the data type and a variable name. So int a means that we have a variable a of type int. If we want to write a pointer variable that should point to another variable, all we do is we put an Asterix sign before the variable. So P is now a pointer variable that points to an integer. So P is a variable that can store the address of an integer. Now, to store the address of A in p, we need to use a statement like p is equal to ampersand a. Now if we put ampersand in front of a variable, it gives us the address of that particular variable. In fact, it returns a pointer to that particular variable. Okay, so let's try to see a simulation of this. Let's say when we declared the variable A, then it was allocated an address to zero for now we declare an a pointer to integer p, let's say it was allocated at a 64. Now when we write a statement, like p is equal to ampersand A, then P now has the address of A and it kind of points to a. Let's initialize a to some value let's say is equal to five, so we fill value five into a now. Now, what will happen if I print p, what will be the output? Any guesses? Think about it. Okay, so if we try to print p, then the output will be 204 because P has a value to 04. What if we simply try to print ampersand of a ampersand of a also gives us the address of a so this will also be 204. What if we want to print ampersand of P. Now P is also a variable and it is also stored in the memory. So ampersand since it prints the it gives you the address of that variable. So, printing ampersand of P should give us 64 which is the address of P. Now, there is one more important property of pointer, if we put an asterisk sign in front of the pointer, then it gives us the value at the location that it points to. So, what will happen if we try to print star of P asterik of p? Well, it will give us five This concept is called as D referencing because we have a reference or we have stored an address in P and we kind of get the value at this particular address using this operator. In fact, we can modify the value at this particular location by saying something like Star P is now eight star p means value at p and so, the value at p is now modified to eight. So, what will happen if you print star p or print a now the output will be eight by value of p i mean value at address P. So P is the address and star P is the value at address that is stored in P. Okay, so just to reiterate, we define a pointer variable using by putting an asterisk sign in front of the variable name. And if we put an ampersand sign in front of a variable name, we get the address of it. So if we try to print a pointer variable without a strict sign or operate upon it without astrix I We are operating with the address, while if we put an Asterix and in front of the pointer variable and operate upon it, then we are operating the value at that address. So this was some of the basics of pointers. In the coming lessons, we will see some code snippets, where we will see some of the common errors that we make while using pointers. And we will also learn pointer arithmetic and pointers in the context of arrays. So, thanks for watching. So, in our previous lesson, Introduction to pointers, we learned the basics of pointers. In this lesson, we will see how to work with pointers in some real code examples. But before that a quick recap, pointers are variables that store address of other variables. We declare a normal normal variable with a syntax like the data type or the variable type, followed by the variable name, but we declare a pointer variable with a syntax data type and an Asterix sign followed by the variable name, we need an integer pointer variable to store the address have an integer to store the address of say, a character variable we will need a character pointer so the same syntax will be used we put an asterisk sign and let's say the name of the variable is P zero. So C is a character variable and P naught is a pointer to character. And similarly, we can have a pointer to double. And we can also have pointers to a user defined structure or a user defined class also. And to get the address of a variable we write a statement like p is equal to ampersand a now this ampersand works as an operator, that gives us the address of A. And what happens in the memory is something like this. Variable p stores the address of variable A. So in this figure here, PS value is 204, which is the address of a so P points to a and using p we can also get the value of A. So let's say if A is eight, and we use a star operator in front of p, then the star p gives us eight which is value of A. If we try to print stoppie it gives us eight. Let us now try to see some of these in real code. Okay, so time to see things moving in a real C program. Now, what I'll do is I'll play a game with you, I will write some print statements, and you need to guess what will be the output. So what I'll first do is I'll declare an integer variable a, and then I'll declare another variable which will be pointed to integer. And now I'll write a print statement where I'll be printing P. Now, what will be the output of this program? Okay, so let's run this program. Oops, this gives us an error. And if it is too small for you to read, then this is giving an error that the variable P is not initialized. And we are using it without initializing. So that's why the program is crashing. So now I will write a statement p is equal to ampersand a now ampersand of A is nothing but address of A. Now let's run this again. Okay, so this springs and address and how do we know that this is the address or this is the right address that is stored in P. So I'll write another print statement. And now I am printing star p now star operator when it is put in front of that dress then it gives us the value at that particular address. Okay, so what will be the output of the second print statement? So when we done this, the the first line gives us the address that points to and this address is different than the previous address because every time the program runs afresh new addresses are located. But the value at B is some garbage value is some integer that I'm not sure what it is. This is happening because I have not initialized a and all the memories are located for a there is some garbage value there that I do not know about. Okay, so let's initialize a let's say a is equal to 10. And now the second line prints the value of a and now I will write another print statement. And this time I'll print ampersand a. Now what should be the output of this third print statement? And this should be pretty easy to guess. ampersand operator gives us the address And that's why the third line is also the address of A. In fact, that's what we have done here, when we have assigned p, the address of A, we have used operator and percent. Now what I will do is, I will modify the value in a using the pointer P. And to do so I will write a statement like Star p is equal to 12. And this is read as value at address p value at address being pointed by B is now 12. This concept is called dereferencing. So, now, if I try to print a, and let's also put one print statement for a before we modify the value, and let's run this. So the first print gives me 10, which is the value that we had initialized a with and the second print gives us a is equal to 12. Because we modified the value using the pointer. Okay, so one more thing that I'll do here, now, I'll have another variable b, that will have value 20. And now what I'll say is start p or value at address p is equal to b. And the question now is that will the address and P change now 2.2 b? Well, no, unless you explicitly write a statement like b is equal to ampersand b, this reverse operation will not happen, what we are doing here is actually only putting in the address of a the value that B has, but we are not pointing to B. And this will get clear only if we write some more printf statements. So before writing the statement, I'm writing two print statements, one to print the address and one to print the value. And after we write the statement, I'll write two more print statements trying to print the address and value again. So, let us see what output is now okay. So, address of P initially is t 144576 and value is 10. And after the statement star p is equal to b only the value is modified and the pointer still points to a. So a kind of now becomes 20, but the address does not change. Now, one more thing, sometimes we declare and initialize a variable in the same statement. So instead of writing this A equal 10, here, we could simply say that int a is equal to 10. So we can do so for the pointer variable as well, we could simply say for these two statements, one simple statement like n star p is equal to m percent a and we will not need the statement. This one statement is same as saying the earlier two statements, the syntax of declaring pointers some people write this asterisk sign after end and do not write it in front of the variable name. This also works and this is also fine. So you can write int star which which means pointer to integer and then you can write the variable name and this will also work. Okay, so now we will point we will talk about a concept. We will talk about the concept of pointer arithmetic. But before that I'll write this rewrite this declaration and initialization like before in two statements. I like it better this way, it's less confusing. Now I will write two print statements here. In the first statement, I'll print P and in another statement, I will print p plus one. Now is it really possible to do so? Can we really increment and decrement a pointer variable? Well, yes, we can do so. So now let's assume that the address stored in P is something like 2002. So any guesses what p plus one will be? Will it be 2003? Well, no p plus one will be 2006. This is because if p is an integer pointer incrementing it by one unit takes us to the address of the next integer. And because the size of an integer is four bytes. So to go to the next integer address, we need to skip four bytes. So P plus one increments p by four bytes, I'll write another print statement in which I'll print the size of an integer variable. And I'll write something like size of integer is and we have a function and see size of that gives us the size of a data type. So this statement this print statement will give us the size of integer and let's write in the first and third print statement something like address P is blah and address p plus one is a block. So let's now run this and see what happens okay. So the output is address P is 4586052 which is some address. And then we print size of integer is four bytes. So for this Particular compiler, the size of an integer is four bytes and address p plus one is four bytes more than address p, you can try this thing out for a character pointer or a double pointer or a pointer of some other data type. Okay, so we could also increment this by two. And what happens if we increment this by two? Well, it will increment the address by eight. So this will be like 2010 plus two will be 2010. And this 2002 and 2010 is something that I've picked up randomly, just for the sake of example. Okay, so now once again, what if I want to print the value at this particular address, so I'm printing two more lines here now I'm printing that value at address P is and I'll print star p, which gives us the value at that address. And we will print another line that will say that value at address p plus one is and there should be star p plus one, we put the star operator in front of the address Okay. So now what will be the output, okay, so, the output is that address P is some address and value at address P is 10, which is alright, because we had stored the address of variable a in P. Now, next time the size of integer is four bytes, and p plus one is four more than that recipe. and the value at address p plus one is some integer value that I do not know about. In fact, this has some garbage value, because because we do not really have an integer allocated to this particular memory address. And this is one dangerous thing about C using pointer arithmetic using pointer manipulation, you can reach to any address. And sometimes these kinds of operations can bring some unwanted behavior to your program. I recommend trying these things out these snippet of code with other data types like character or float, and the result the results will be similar. So this was some playing around with pointers. And in the coming lessons, we will talk more about pointers. And we will talk about pointers in the context of arrays. So thanks for watching. So far, in our previous lessons, we have seen how to work with pointer variables. So we pretty much understand the basics. In this lesson, we will write some more code using pointers. And we will look through some of these concepts. in more detail using some examples. The first thing that I want to point out is that pointer variables are strongly typed. What it means is that you need a pointer variable of a particular type to store the address of a particular type of variable. So int star or a pointer to integer will be needed to store the address of an integer character pointer will be needed to store that does have a character. And similarly, if we have a user defined structure or class, then we need a pointer of that particular type only. But why do we need these strong types? Isn't it that the pointer variables just store the address of the variable? So why couldn't we have just one type? That will be some generic type to store the address of all kinds of variables? And the answer is that we do not use the pointer variables only to store memory addresses. But we also use them to dereference these addresses so that we can access and modify the values in these addresses. Now, as we know, data types have different sizes, like in a typical modern day compiler and integer, it's stored in four bytes. A character variable is stored in one bite of float is again stored in four bytes. And these variables differ not only in their sizes, they also differ in how we store information in whatever bytes are available for these variables or data types. Let's say we have an integer a and its value is 1025. And this is how it is laid out in the memory each each bracket here is one byte. So let's say this particular byte which is the least significant byte is byte zero, and then we go on like bite one, bite two and by three. Now we also know that each byte in the memory is addressable. Let's say the address of bytes zero is 200. Now these four bytes need to be contiguous let's say the address of byte to byte one is 201. And then we go on like 202 and 203. When an integer is represented in the memory is stored in the memory the leftmost bit stores the information that whether this integer is positive or negative, so this is also called signed bit, signed bit and rest 31 bits are used to store the value. So if you see we have a one at right most bet with place value two to the power zero and at this particular bit with place value to to the About 10. So the overall value that we have in binary here is one zero to five in decimal. Now, what if I declare a pointer to integer P and store the address of A in p by using the ampersand operator, what will happen if I print the value of p, the value of p or the address stored in p will be 200, the address of bytes zero. So we're kind of saying that we have the address of an integer variable starting at address 200. If we dereference this address and try to print asterik P, we want to know the value at this particular address, then the machine sees that okay, P is a pointer to integer, so we need to look at four bytes starting address 200. And then the machine knows that how to extract extract the value of an integer data type. So it really it retrieves the value one zero to five out of this four bytes. Now, if p was a character pointer, then while dereferencing, the machine would have looked at only one byte because a character variable is only one byte. If P was appointed to float, then although float is also stored in four bytes, but the way information is written for float in these four bytes is different from the way information is returned for an integer datatype. So the value printed would have been something else. Let's go write some of this in a real program and see what happens. In my C program, I will first declare an integer A equal to 1025. And now I'll declare a pointer to integer P. And then I'll store the address of A in p by using the ampersand operator. Now I'll write a print statement like this size of integer is, and we have a function size of NC, which gives us the size of a particular datatype in bytes. And now I'll write a print statement like this address is equal to P and value is equal to asterik p with dereference p to bring the value. Now let us see what is the output of this program. No points for guessing this is pretty straightforward. The size of integer is four bytes, the address that we are showing here is some address and the value is 1025. Okay, now I'll do some trick here, I'll declare a character pointer let's say the name of the variable is P zero. Now I'll try to put the same address as we have in P into P zero by writing a statement like this. But this will give us a compilation error because p zero is a pointer to character and p is a pointer to integer. So what we will do here is we'll typecast p to character pointer and then assign the value. And now I'll write two more print statements. First is size of character is these many bytes and use the method size of again and the second is the address is P zero and the value at addresses asterik p zero. So we dereference we try to dereference p zero now and let us see what's the output now, the first line of output a size of integer is four bytes address because we are running the program fresh this address will not be the previous address that was from the previous run this will be a different address by dereferencing the integer pointer we are getting the value 1025. Now the next line of output a size of character is one byte addresses 5373032 which is the same address as we have in the second line, but the value of this time is one. Now why is this value one once again if we write 1025 in binary using 32 bits, then this will be the representation. When we do this typecasting here trying to store the address of P in p zero, then the address of this particular byte the rightmost byte is stored in p zero. But when we dereference p zero because p zero is a pointer to character the machine says that hey, this is a pointer to a character and the character is only one byte. So I look at only one byte to see the value. And if you see this particular byte in binary is one and that's why this output here is one. Okay, I'll write two more print statements now. One to print the address p plus one and the value at address p plus one. Now as we know we can add or subtract in an integer constant from a pointer variable. This is allowed in fact the only pointer arithmetic that is allowed is adding or subtracting some constant integer value to the pointer. p plus one will take us to the address of the next integer. So it will skip four bytes and take us four bytes ahead. Let's say we also want to print p zero plus one and the value at V zero plus one. Okay now let's see the output of this particular program, the address of a this time is 4456036 that's what is allocated for a in this particular run the value is 1025 p plus one is 4456040 if you see this is four bytes more than the address of A, because size of integer is four bytes and p is a pointer to integer So, incrementing p takes us four bytes forward and this value is some garbage value because we have not filled anything in this particular address. So, there is some garbage in the memory which we are picking up now, the address in PS row is also 4456036 which is the address of the first byte the least significant byte of a the value is one now, P zero plus one is 4456037 here we have a value which is one byte more and this is because character is stored in one bytes. Now, the value here is four if you see p zero plus one will take us to this particular byte the address of this particular byte and this particular byte in binary is four this was to show you how things happen in memory when we dereference a pointer variable by using the Asterix operator and also what happens when we perform pointer arithmetic with a particular pointer type. This typecasting of pointer variable from one to another also has some use cases we will discuss them later. Now, we will discuss one pointer type which is generic pointer type it does not correspond to a particular data type and this pointer type is called void pointer and we declared this particular pointer type by using the keyword void and using an Asterix sign in front of the variable name okay now, we can write something like p zero is equal to p we do not need an explicit typecasting here like this, the statement p zero is equal to P is valid and this will not give you a compilation error and because this particular pointer type is not mapped to a particular data type, we cannot dereference this particular pointer variable. So, if you try to print star P naught or astrix p not this will give you an error we are getting a compilation error, we can only print the address. And as we can see here the address is same as the address of A and if we perform arithmetic, if we try to do something like p zero plus one access something like p zero plus one, this is also not possible this will also give you a compilation error, we will come back to the use cases of wide pointers in forthcoming lessons. Let's for now know that there is something called void pointers. So this was diving deep into pointer types, typecasting and pointer arithmetic, we will have a lot of fun with pointers in the coming lessons. So thanks for watching. In our lessons so far, we have seen how we can work with pointers in some of the basic scenarios. But there are some scenarios where pointers can be really puzzling. And once that scenario is when we want to use pointers to pointers. So in this lesson, we are going to see how we can use a pointer to pointer let us assume that this is a logical view of computer's memory and each partition here is one byte of memory Now, we know that each byte of memory has an address, we have drawn the memory horizontally here, let us assume that the address increases as we go from left to right. So if this byte is at address 200 the next byte would be at address 201 and the next byte would be at address 202 and so on. Now let's say in my program, I have declared an integer variable named x and maybe I have initialized it as five and now when the program will run some amount of memory will be allocated for this variable x. In a typical architecture in a typical compiler integer is stored in four bytes, so four byte will be allocated for x. So let's say these four bytes at address 225. This block of four bytes starting address 225 is allocated for x. And the values stored in this block of four bytes for x is five. Now the next thing that I want to do is I want to declare a pointer variable that will store the address of x. Now to store the address of an integer we will have to declare a pointer to integer something like this, we need to put an asterisk sign in front of the variable name. Now, what will happen is that some amount of memory will be reserved for this variable p in a typical All architecture pointer is also stored in four bytes. So let's say we get this block of four bytes at address 215 for P. And now, I want to write a statement like this. So I want to fill in the address of x in P. And that's how p points to x ampersand operator gives us the address of a variable. Now one important thing here, we are able to store the address of x in p because P is of type pointer to integer, if p was of type pointer to character, or pointer to some other variable. And this statement, p equal ampersand X would not have been valid. So if I have to write down the types of these two variables, then x is an integer, and p is a pointer to integer. Or I can also say that that P is int star, int asterik. And y pointer variables are strongly typed. Why do we need a pointer to integer to reference or store the address of an integer? It is because we don't just store the address of a variable in a pointer variable. We also use the pointer variable to dereference that address dress and write some value there. So if I write a statement like this, this value here at address 225. And this x is now modified. Now can I create a pointer to this variable p, which itself is a pointer to integer? Well, yes, we actually we can do so. So let's say we want to create a variable named queue, that will store the address of P. Now what will be the type of this variable, we need a pointer of a particular type to store the address of a particular type of variable. So to store a pointer to integer, we will have to say that, that we want a pointer to pointers, so we will put two Asterix sign in front of the variable name. And now this variable q can store the address of P. So with this first line with this end asterik asterik q, we created q let's say we created q at 205. And now we are seeing that q will store the address of P. So q points to P and the type of Q is int asterik asterik with to be put to Asterix. simple way to read this is that the type of variable x is an integer. So to store the address of x we will need a pointer of type int star. So we will put one star to say that this is a pointer to that particular type. And to store the address of p we will need a pointer to int star so we will put one extra star to say that this is a pointer to int star. And we can go on like this. Let's say we want to declare a pointer to pointer to pointer so int asterik asticus pointer to pointer and we will put one more asterik or we can put these three asterik immediately after this keyword end. Or we can put it immediately before the variable name like we have done in the case of Q here. Let's say we define r as int star star star. So let's say R gets this address to 13 the memory now are is of type int asterik astrick Asterix so it can store the address of int asterik asterik. So, it cannot store the address of X or P all the statements something like r is equal to ampersand Q will be valid. Now, I have translated my previous rough code into a working C program. Now let us assume that this program is working as per this memory sketch that we are showing in the right now I will write some print statements and you need to get the output. So basically you have to assume that these variables x p, q and r are allocated these addresses what we are showing here in the right. So the first print statement that I'm going to write is I want to print as strict p and this one should be simple for you asterik p would be value stored at address in p so this will be six. Now the next statement that I want to print is asterik q. So astrick q will be a value at address stored in Q address stored in variable Q is 215. So this is nothing but the value of p so this will be 25. And now I want to print asterik astrick q so I want to do dereferencing twice. First I want to go to Astra q Astra Q is this address 225 and now I want to look at the value at address 225. So this one will be six we could have avoided writing this paranthesis here We could have said Astrid, gastric que only and that would have also, that would have meant the same. But it's a good practice if we are using this asterik operator to use paranthesis wherever we can do it because sometimes, when we are also using other operators, we are not sure about the proceedings, and we want to avoid unwanted behaviors. Now, what about these two print statements asterik asterik R and Astra gastric asterik r asterik r means value in Q which will be 215. And then further, one more dereferencing will take us to value in p which is 225. And one more dereferencing will take us to value in x which will be six. If you see this is really interesting. From our we are using one asterik operator and we are able to go to Q then we are using das trick operator twice and we reach P and then we are using the astrick operator thrice and we reach x, let's make some more changes in this code and run this in a real compiler. So what I'll do here is I'll write a statement like this. And then after this statement, I'll print the value in x. If you run this now, as you can see, asterik p astrochemistry q and astrochemistry gastric are all these three values are six, the address will not be same as we had shown in the example for obvious reasons. And as you can see, we are able to modify x by doing this chain of dereferencing using this variable r if we would write something like astrochemistry Q is equal to let's say something like this. Now asterik P is also referencing x and astrochemistry Q is also dereferencing x sorry, we are dereferencing here. So any guesses what will be the output of this last print statement? Well, if you see x is incremented by two here. So this was pointed to pointer, I recommend that you write some of this code yourself and play a little bit in the coming lessons we will use pointer to pointer in some real problems scenarios. So thanks for watching. In our previous lessons, we define pointer variables. And we also saw how to operate upon pointer variables how to work with pointer variables in C or c++ program. But we did not really talk about the real use cases of pointer variables in watch scenarios we may want to use pointer variables. So, in this lesson, we will talk about one of the use cases of pointer variables and the use cases using them using pointers as function arguments. And we also termed this as call by reference. So, let's discuss a scenario all Bert is a beginner programmer, and he has recently learned about the concept user defined functions. Now he tries to apply this concept and he writes a simple C program like this, what he is trying to achieve here is that he has an integer variable declared and initialized in the main method and he wants to increment the value in this variable by one. So, instead of writing something like a plus plus or a equal to a plus one, instead of writing a statement like this, he writes a function increment that will take an integer a as argument and inside this function, he is writing a statement like a is equal to a plus one he calls this function increment from the main method passing a as argument and then he prints the value of a now what he is expecting here is that the value of a will be incremented to 11 and hence the print statement will print a equal leaven, but when he runs the program, the output of the print statement is a equal 10. Now, Albert does not understand why this is happening, he has declared a variable a and then he has initialized this variable to 10 and then he is passing the same A to the function increment and the same a is being being incremented by one in this function. So why the value of a being printed is not leaven. Why is it 10 now, what Albert does not understand well, or what he probably forgot, is that whenever we declare a variable inside a function, then we call that variable a local variable, because as such, just using the variable name, we can access that variable only inside the same function in which we have declared the variable. So these two a this a in the function increment and this a In the function main, are actually not the same a, the A in the function increment is another a, when main calls the method increment and passes this a as argument to the function, then only the value of a is copied to this another A, which is another variable local to the increment function. So what I'll do is I'll do couple of modifications in this code to show you a better picture. I will write two print statements in this code. First print statement in the increment method something like this address of variable a in increment is and as we know, if we put ampersand operator in front of the variable name, then we get the address of that variable. And I'll comment out this print and I'll write one more print in the main method like this. And here I print that address of variable a in Maine is ampersand a. Let us now run this and see what happens. Let me also put an end of line after we print the statement. And the output is address of variable a in increment method is printed as 4454460. And in Maine, it is equal to 4454660. This two looks similar, but they're not the same. One is having 4460 and then and another time 4660. What the values are is not important, what the addresses are is not important. What's important is that these addresses are different. If the A in main method and the A increment method was same, these two addresses would have been same. To understand this even better, we will try to understand how things happen in computer's memory when a program executes when a program or an application is started, then the computer sets aside the machine sets aside or reserves some amount of memory for the execution of this program. The memory that is set aside for the application is divided into is typically divided into these four parts that we are showing here one part of memory is allocated to store the various instructions in the program, the computer needs to keep all these instructions in the memory these instructions that we have in the program like increment or declare these variables all these sequential instructions, one part of the memory is one part of the allocated memory is for static or global variables. If we do not declare a variable inside a function in c++ or C then it is a global variable. Now global variables can be accessed and modified anywhere in the program unlike local variables, which can be accessed and modified within a particular function or within a particular code block. Now, the third part of the applications memory is called as stack and this is really important, this is where all the local variables go and we will mostly be talking about stack in this lesson. And the fourth part the fourth part is heap. And we will come to this later in in our forthcoming lessons have these four segments of the allocated memory the text segment, the global variable segment and the stack segment, these three are fixed and they are decided when the program starts executing the application however, can keep asking for more memory for hits its heap segment during its execution only. We will cover all of these things in detail in our forthcoming lessons please do not get scared by these terms. Let us now see what happens when a program executes. Let us say this is our computer's overall memory, the RAM and as we know each byte in the memory is addressable. So, let's say the memory allocated for our program is from address 200 to 800. And these are the various segments of our applications memory and have this let's say address 300 to 600 is allocated for stack. Now there is more memory of course in the ram after address 800 and before address 200 Okay. So from 200 to 800. This part of the memory is assigned for our program, let's say this C program that we have in the left. Now, when a function is invoked, like when the program starts the main method is initially invoked, all the information about the method all the information about the method call like its parameters, all the local variables, the calling function to which it should return. The current instruction at which it is executing. All this information is stored in the stack. So, we will take out from the stack some part for the main method and create a unit which we call stack frame, each function will have a stack frame. Now we have a variable a now memory is allocated for a from this stack frame and the value of a is 10. Now, the main method calls increment function, what happens when main method calls increment is that the machine says that hey, I will stop your execution for some time, I will stop at this particular instruction let me go ahead and finish this method increment. And then I'll come back to the main method once I'm done with increment, now another stack frame is allocated for the increment method and the parameters in increment method like we have a parameter a So, fresh local variables are created corresponding to these parameters and whatever values have been passed are copied to these variables these parameters Now, when we say a is equal to a plus one here in this statement, then what happens that this a which is local to the increment function in this particular stack frame, this is incremented we cannot access a variable it outside it stack frame and now increment finishes when increment finishes the control returns to the main method and what the machine does is it clears the stack frame that was located for increment and main method resumes again So, main method was paused at this particular instruction increment. So, lifetime of a local variable is till the time the function is executing. Now, the next statement in main method is a call to the function print f print F is not a user defined function it is a library function the state of execution of main method is kind of paused and printf is executing now, we often call this particular structure call stack or function call stack whatever function is at the top of the stack is executing and remember this stack is fixed in size. So, if you have a scenario where one function keeps calling another function in dead definitly like in the case of an infinite recursion, then the memory of this stack will overflow and our program will crash okay but that is not relevant for this scenario. So, now, you must be getting a picture of what happens when one function calls another function. This a is in the stack frame of the main method. Main is our calling function and increment is our call function. When we call a function in the calling function, the argument is also known as actual argument and in the call function, the argument is known as formal argument. All that happens is the actual argument is actually mapped to a formal argument. So, when this function called happens a is mapped to a as an actual argument is mapped to another A, which is a formal argument instead of a if we were having an x here, so, we would have written something like in x as is the argument and x is x plus one then a would have been mapped to x. So, the value of a will be copied to the variable x. Now, when we make such a function call, where we basically have one variable being mapped to another variable that value in one variable copied to another variable then such a function call is also called as call by value. So, this is what Albert was doing, making a call by value. And that's why he was not able to get the desired result. But can we get the result that Albert wanted to have all but wanted to use this variable A, which is local to the main method inside the increment function? Can we really do so? Well yes, we can do so, if we use pointers as function arguments. Let us now look at this code. And I'm drawing only the stack here so that I'm able to show the simulation of program execution neatly. Now, what we are doing here is that we do not have an argument which is integer in this function increment we have an argument which is pointed to integer and pointer to integer as we know we will it will store the address of an integer. So now what we are doing is that in the increment function, we are passing the address of a so when the program will start executing the main method will be invoked First, let's say this is the stack frame of the main method. Let's say 300 to 350. This addresses the stack frame of main method and there would be a local variable a. In this main method, let's say the address at which a is stored is 308. This may not be in proportion, but still let's say this is how it is stored. Now when main method calls increment, then a local variable corresponding to the parameter P is created. And this is a pointer to integer and the value that is passed to this particular function. The value that gets stored In this particular Sorry, it's not a function, it's a variable the value that gets copied or stored in this particular variable would be 308 the address of A. So P is pointing to a. Now in this statement here when we say asterik P, we dereference this address, so we are seeing here that asterik P is value at address stored in p. So, we say that increment the value stored at address p by one, the value stored at address 308 gets incremented by one, so, a is now 11. So, now when increment finishes, and we come back to the main method, and the next line gets executed, which is the print statement, then A is now 11. If you run this program, then what gets printed is a equal lemon, such a function call in which instead of passing the value of a variable, we passed the address of the variables so that we have a reference to the variable and we can dereference it and perform some operations is called call by reference. So, if we use pointers as functions arguments, then we are using call by reference call by reference can save us a lot of memory because instead of creating a copy of a large and complex data type, if we just use a reference to it, and using a reference will also cost us some memory but very small amount of memory, then, we are saved from creating a new copy of a complex data type. In the coming lessons, we will see more of the layout of applications memory, and what are things we can do using pointers. So, thanks for watching the concept of pointers and arrays in C or c++ go together, there is a very strong relationship between these two concepts. And in this lesson, we will be discussing this relationship. When we declare an array, let's say we declare an integer array A of size five, then we create five integer variables named is zero, a one a two, a three and a four. Now these five integers will be stored in the memory as a block of five consecutive integers something like this, what we are showing here in the right, if a zero or the first element in the array is stored at address, let's say address 200. And in a typical compiler, modern day compiler integer is stored in four bytes. So a one will be four bytes ahead of a zero at 204. And a two will be at 208, a three will be at 212. A four will be at 216, the overall size of the array would be 20 bytes, and these 20 bytes will be one consecutive block, we are only showing the section of the memory in which a is stored. Sometimes we also show the memory horizontally, something like this, from left to right, we increase the address but these two representations are just for the sake of understanding, let's use the horizontal representation of the memory. And this time, I'll show this memory a little more extending towards the right so that I can accommodate a couple of more variables. Let's say apart from this integer array, I have an integer variable x and its value is five. And let's say x is located at address 300. Now, let's say I have a pointer to integer P and P, I store the address of x if we print p then the value in p would be 300. So, this statement will print 300 and if we dereference P and try to print the address stored in Try to print the values stored in this location p then the value would be five this is fine. But we also know that we can do an operation something like increment or decrement a pointer variable by a constant. So we can do something like p equal p plus one and this will take us to the address of the next integer and because integer is four bytes, so now p would be 304. So if I want to print p now, then the output should be 304. But if we try to dereference p now and try to print Asterix p then we do not know the value at this address. So we cannot say what will be printed. It's like we know that Mr. X lives at address 300 but we do not know who is his neighbor who lives at address through 304. But for this integer array A, let us say I'm writing the same integer array in right here, which is located at address 200. If I declare a pointer to integer P and store the address of the first element by putting an ampersand operator In front of a zero, then printing p would give us in this scenario, the output 200 and printing astrak p would give us. But before that, let's say we have these values in the array, let's fill up some values in the array. So Asterix p would be two. Now if I want to print p plus one, then the address would be 204. And if I dereference p plus one, and try to print this value, then it will be four. And similarly if we wanted the third element in the array, we could do a p plus two here. So using pointer arithmetic makes sense in the case of pointers, because in the case of arrays, because we know what is in the adjacent location, there is one more property of the array, if we just use the name of the array A, then a gives us the pointer to the first element in the array. So we can write a statement like p is equal to a, in fact, we do not even need to take this address in another pointer variable. If we simply print a then this gives us nothing but the address of the first element in the array. And if we want to dereference this and try to print asterik A, then this will give us the value. So if we want to perform something like we want to print a plus one, then this will give us the address to 04 and asterik, a plus one will give us the address of the second element in the array value of the second element in the array. For an element in the array. at index i we can retrieve the address of this particular element in the memory using either ampersand AI, or simply a plus i and these two will give us the address of AI and the value of AI can be retrieved using either we simply use AI, or we can also use Asterix a plus i an Asterix a plus I will also give us the value. Now this is an important concept, we can write ampersand AI or a plus i for each other and they mean the same. And we can write a AI or Asterix a plus AI for each other and they mean the same. The address of the first element in the array can also be called the base address. And a simply using the variable name a gives us the base address of the array. Let us now see some code examples and try to solidify our concepts further. In my program, let's say we have an integer array A. Now as I said, if we simply print a then this should give us the address of the first element in the array. And we can also get the address of the first element in the array by using ampersand operator in front of a zero. If I simply print a zero it will print the first element in the array and we can also print the first element in the array by using Asterix operator in front of the variable name a. Let us now run this and see what happens. And I also need to put an end line after each of these print statements. Okay, so the output is that the first two lines are the same, they are giving us the address of the first element in the array and the second two lines are giving us the value. In fact, if we run a loop like this from zero to index four, then we can print address of the element at index i as ampersand AI or a plus i and we can print the value of if element as a AI and Asterix a plus AI. Now, if we see the output here, this is a fresh run a new run so the address or locations will change. But if we see the address printed in two lines for a zero is same the value is same again for a one addresses same four bytes I had off the previous address and the value is as expected and we can go on like this. Now one more thing even though just using the variable name a returns us pointer to the base address or the address of the first element and we can equate the variable name a against some pointer variable like this. We cannot do something like a plus plus increment the value of a this will give us compilation error. We can do something like p plus plus once we assign a to some pointer variable other pointer variable but incrementing a itself would be invalid. So this As far as how arrays are stored in memory and how the addresses can be manipulated, and how we can access the values using pointers, in the next lessons in the coming lessons, we will talk about character arrays. And we will talk about passing arrays as function arguments. So thanks for watching. In this lesson, we will be talking about one more scenario in which the concept of arrays and pointers go together. And this scenario is when you pass an array as function argument, let us see a code example where we pass array as function argument and try to analyze it, I will write a simple C program in which I will write a function that will give me the sum of all the elements in an integer array, this function will take an integer array as argument, this is one of the ways to pass an integer array, an array in general as argument, this would be the data type and this would be the name of the array. And in the main method, we have declared and initialized an array named a. Now, in the main method, we will call this function sum of elements and pass it the array as argument. And of course, we need to write the body of this function, sum of elements, I will declare two variables I and another variable sum and initialize it to zero, I will be used to run a loop. So, we will iterate through all the elements in the array that is passed as argument. But wait a minute, we do not know the size of this array, is there some way to know the size of the array. One of the ways to find out the size of the array and by the size of the array, we mean the number of elements in the array here is to use the function size off. So if we write something like size of a here in the main method, then this will give us the size of the array in bytes. array has five integers and in a typical compiler, and I know for sure that in this compiler and integer is stored in four bytes, so size of a will return 20. If we want to know the number of elements in the array, then we can do something like divide the size of the size and bytes of the whole array by size of one integer. So we will say size of a upon size of each integer and by the size of a zero would give us the number of elements in the array. And I'll write this particular line below this line the line where we are calling the function sum of elements. Now, what we can do is we could either pass the size of the array as another argument. So that would be cool. And then we can run the loop starting zero till index size minus one and we keep on adding each element to this variable sum. And finally, we return sum. And finally, we will write a print statement something like this, to print the sum of all the elements in the array, let us now run this program and see what happens the output on console is that the sum of elements is equal to 15 five plus four plus three plus two plus one is 15. So, this is all right. Now, what I want to do is I want to modify this code a little I do not want to pass the size as argument here, I want to calculate the size of the array inside this function. So, we will not be passing this sizes argument here. So there will be there will be just one argument the array. So we have this array as argument the array and we calculate the size here as total size of the array in bytes upon the size of one integer in bytes. Let us now run this program and see what happens. Oops, this seems to be some problem, because the sum of elements that we have as output on console here is equal to one it should be 15. And why is it so, explain this behavior, I will write two more print statements, what is the function sum of elements where I will print the size of a and the size of a zero I will be calling these two functions size off upon a and upon a zero respectively. And we will write one more print statements in the main method. It will again be the same thing printing the size of a in bytes and the size of a zero in bytes. Let us now see the output in the method sum of elements size of A is equal to four bytes. size of a zero is equal to four bytes in the method main size of phase equal to 20 bytes and the size of a zero again is four bytes. To understand this concept, why the size of a is four by In the method sum of elements and it is equal to 20 bytes in the main method, we need to dive deep into how compiler interprets an array as function argument. Once again I will draw this familiar memory diagram, the memory assigned to an application or a program is typically divided into these four parts, we have talked about this in our previous lessons for the execution of function calls, we use stack section of the memory, this green rectangle here is our stack. Now, when the program starts executing, first the main method is invoked. So some amount of memory from the stack is allocated corresponding to the call of the main method and this particular section or this particular part is also called the stack frame of a method all the local variables reside within this stack frame. Now, here in main method, we have two local variables one is the array and another local variable is integer total. So, around 20 bytes if integer is four bytes, exactly 20 bytes, in fact, would be allocated from this stack frame for the local variable a the array and four bytes for total the variable total and there would be some more information in the stack frame. Now, when the program execution reaches this particular line, where we make a call to sum of elements, then the execution of main is paused and another stack frame is allocated to execute the function sum of elements. We have talked about this call stack growth and function execution a number of times in our previous lessons, okay, now, this is a local variable, this parameter is a local variable to the function sum of elements it is not this a in the main method, what happens when we make a function call is that the value of this particular local variable in the main method, or we should rather say the value from the variable in the calling function is copied to the variable in the call function. So ideally, we should have one more a local to the function called sum of elements. and the value of a should be copied into this parameter A. So we would have another array named a, taking 20 bytes in the stack frame of some of elements, and it would have the same value same elements as the array in the calling function main. But actually, this doesn't happen, when compilers sees an array as function argument, it does not copy the whole array, what it actually does it, it just creates a pointer variable by the same name, instead of creating the whole array, it just creates a pointer to the data type of the array. So in this case, it will be pointed to integer and the compiler just copies the address of the first element in the array of the calling function. So, let's say the starting address the address of the first element in this array, that belongs to the main method is 200. So, in sum of elements, all that happens is a pointer to integer is created and the value in this pointer to integer is 200. The compiler implicitly converts this int a to something like in Star a, that is this a here in this particular format is not interpreted as an array, but it is interpreted as pointer to integer. So whether you write int space variable name following these brackets, or you write something like in Star space a, they're both the same. We have a term for this, instead of copying the value of the variable, we are just copying and storing the address of the variable. So, we make a call by reference here, arrays always are passed as a reference parameters. And this makes a lot of sense, because arrays can be really large inside so it does not make much sense to create a new copy of the array each time it is unnecessarily using a lot of memory. So for arrays, there is no call by value there is always a call by reference. And that's why this size of a here would give us four as output, because A is a pointer to integer here, while here in the main method is an array. So this format of passing array as function argument where we put these braces to tell that this is an array is actually interpreted something like this by the compiler. You can put an asterisk sign here or you can put an Asterix sign here. It's the same thing. It makes more sense to write it like this. So A is actually interpreted as a pointer to integer. That's why when we pass array as function argument, there is no way to know the number of elements in the array. By using a trick like this, we actually need to pass the size of the array. So I'd rather move this size calculation in the main method and pass the size. And when we run this program, now, we get the output as expected sum of elements is 15. We should always keep in mind that a variable name which is used as an array is different from a variable which is pointed to integer. Even though the compiler gives us some privileges, like we can use the name of the array to get the pointer to the first element, like in this function sum of elements, we could say something like to pass the first element, we should, we could have said ampersand is zero, the address of the first element. But if we just use a instead of using ampersand a zero, then that is allowed if A is an array. But if a is an array, we cannot do something like incrementing or decrementing. It like pointer variables. With pointer variables, we can do couple of other stuffs. And if we have a pointer to the starting address of the array, we can pretty much use it like a variable name for array because II II is interpreted as value at address a plus i. So we need to keep these differences and similarities in mind, it's a little tricky. There is one more thing because the array is passed by reference, we can modify the elements of the array in the call function, and it would refer reflect in the calling function. So let's say instead of calculating the sum total, we want to double all the elements, each individual element in the array. So our code will go something like this, I want to say that AI is now twice API. And we will not return an integer let's say the return type is void. And in the main method, I'll clear all this stuff. And what I'll do is I'll simply run a loop to print all the elements in the array Okay, let us now run this and see what happens. Oops, I forgot to call the function double I must make a call before I print the elements Okay. Let us now run this. If you see the elements in the array are modified each element is twice its previous value, because this is called by reference the same copy of the array is modified using dereferencing. So this was array as function arguments. An important use case of array as function argument is when we work with strings in C strings in C are nothing but character arrays. This concept really becomes important in the context of character arrays, we will be talking about it in the coming lessons. So thanks for watching. In our lesson, so far, we have seen how the concepts of arrays and pointers go together. Now in this lesson, we are going to talk about character arrays, how we can work with character arrays using pointers. When we talk about character arrays in C, we basically want to talk about strings. Strings are group or set of characters, and real world data like names, phrases, and sentences. All of these are strings to us. So these are some of the examples of strings. Character arrays become all the more important because we use them to store strings, and then perform a lot of operations on strings, like modifying a string, copying a string concatenating two strings or finding out properties of strings like finding out the length of a string. To be able to work with strings efficiently in C, there are a couple of things that we need to understand. The first thing that we need to understand is how we store strings in character arrays. To be able to store a string in a character array. The first requirement is that the character array should be large enough to accommodate the string. And what is a large enough character array. A large enough character array is a character array of size greater than or equal to number of characters in the string plus one. So let's say if our string is a name of four characters, like john, then the size of the array should be greater than or equal to five. Now the obvious question would be why do we need space for one extra character? Isn't it that if we layer, character array of size four, we can store all the characters in john j will go at the zero at index, four will go at the one at index, H and n will go at second and third index respectively. So I'm storing all the data, isn't it? Let's try to understand it this way. Let's say we have a character array of size eight. Let's say this is a logical view of our array C, and we want to store the string john, in this particular array, we have indices from zero to seven, and this is an array of size eight. So we can store j at the zero at index o at the one at index H, add to it index and n add the three utter index. So we have stored all the characters of the string john in this array. But if you see we have not stored one information, or we have not stored the information that this particular character, n is the last character in the string, so the string ends at index three. So let's say if we pass this string to a function, and that has to print the string john, or find out the length of the string that we have stored in this array, then how would the function know that the string is only till index three, even though we have not filled anything in these indices at four or five, six and seven, there would be some garbage value there. So either we pass this extra information, or we do something else, to store this information that this is the end of the string in the character array. This is the used part of the string. And this is the unused part, we use a simple design at the end of the string in the next position, we put a null character, and null character has asked by value zero. And we can put a null character at position four in this example, something like this, within single quotes, we put a forward slash and number zero, this is null character. All the functions for string manipulation in C, expect that strings will be null terminated. So this is a rule string in C has to be terminated by a null character. And that's why we need one extra space to store this null character. Let us try to see some running code that will help us understand this concept better. What I have done here is I have taken a character array of size four, and I have filled in the characters, but I have not used any space to null terminated. And then I'm using the printf function, this percentile, so it tells that I want to print a string and then I'm passing this array C. Let us run this program and see what happens. As we can see, there are these bunch of characters that are getting printed after john, this is happening because we have broken the assumption for the printf function that my string that are a string will be null terminated. So that's why this undefined behavior is coming. If we change the size of the character array to five and put a null termination, something like this at fourth index, and then things will be fine. Now even if we change the size of the array to 20 printf function will print till it finds a null character. So it only prints on the first four characters in the array. And it's not just the print function, there are a bunch of functions, we have this library string dot h, that gives us a bunch of function for string manipulation. So all these functions assume that the string will be null terminated. So this is one contract that we have to follow. Let's say we want to use one function str le n string length. To find out this length of the string, I'll print something like this, let's run this and see as you can see, the output is length is equal to four even though the array is of size 20. So string length function also counts still it sees a null character. In our program, instead of writing these characters individually at this positions, we could have used string literals string literals are group of characters within double quotation marks. So we could have written something like this. And this would have initialized C as the string and the null termination for a string literal is implicit, it is always stored with a null termination and memory. Remember, when we declare and initialize a character array like this, this has to happen in one line, we cannot do something like we declare in one line and then we go on and modify this in the next line this will be invalid. We could also avoid writing this size here, and this would have been fine. In this case, the size of C will be five units, five bytes where one byte stores one character. So it would be just enough to store the string john. So if we try to print the size in bytes of C, using The size of function, then size in bytes is five one character stored in one byte. So space has been allocated for five characters, but the length is four, because the null character does not count in the length, if we write something like c four is equal to this particular string literal with four characters, this will give us compilation error, because the compiler will force this particular array to be of minimum size five, there is one more syntax of initialization we can put all these characters as a comma separated list within these braces, but in this case, the null termination will not be implicit, we will have to do it explicitly. And the size of the array has to be greater than or equal to the number of characters here, so it should be greater than or equal to five. Okay, so these are some of the ways to initialize a character array. The next thing that we need to understand is, arrays and pointers are different types that are used in similar manner. Now, what does it really mean? Well, let's say we declare a character array, see one of size six, and initialize it with this string literal. And let's say this is how it gets stored in the memory, or is stored in one contiguous block of memory. So let's say the first character is at address 201 character is of size one bytes, so the next character will be at address 201. And the next will be at 202, and so on. Now c one is the variable name for this whole array. Now what I'll do is, I'll declare a variable, which is a pointer to character, let's name this C two. So let's say we get this variable c two somewhere in the memory, a pointer variable in a typical architecture is stored in four bytes. So this variable will also have some address, let's say this variable is at address 400. I'm just picking up these numbers for example sake, now, what we can do is we can write a statement like this C two is equal to c one. Now even though c one is a character array is a variable name for character array. And c two is a variable which is pointed to character, this particular expression is valid, just using the name of the array actually returns the address of the first element in the array. So what this expression, what this statement will do is, it will fill in the address 200 and C two. So C two now points to the first element in the array. Now, we can use this variable c two, which is a character pointer, or just like C one to read and write into the array. So if I write something like print c two, I, let's say we want to print c Two, one, then the output will be L. and we can even modify the array. Let's say we want to modify the character at zero at index two A. So the string will be modified and will become this, when we write C two I for any position I it is nothing but as strict c two plus i. So C two is the base address, C two plus, I will take you to the address of the eighth element. So in this case, let's say C two plus two will be 202. And if we put this asterik operator, we are basically dereferencing and finding out the value, so these two syntaxes are alternate syntaxes. And even if it is an array name, we can write on these two as substitutes for each other. So this was all the similarity in how we actually use them use arrays and pointers to read and write. Let us now look at the differences. We cannot modify an array with a statement like this, C two equals c one is valid, but c one equals c two is not valid, it does not make sense, this will give you a compilation error, we cannot even say C one is equal to c one plus one, we cannot increment or decrement. This video we'll see what we can do it for C two, which is a pointer variable, we can say C two plus plus so C two now points to the next element. With this statement here, all that will happen is C two will become 201. So instead of pointing here, it's now pointing to this particular element e to traverse an array, we run a loop and we use a local variable let's say I and increment it in the loop if we have a pointer variable, we can just keep on incrementing the pointer and we can traverse the list we can traverse the array, we will keep doing this C two plus plus. So we must understand where we have an array and where we have a pointer and what we can do with which one. Now, the next thing that we need to understand is that arrays are always passed to functions by reference or when we pass arrays to functions, we only pass the base address of the array in a pointer variable and we do not pass a whole copy of the array. The compiler does not let you do do that. And we have talked about this in detail in our previous lesson. Arrays as function arguments. Let us look through some code and try to understand this better. In my code, I have declared a character array of size 20. And I have stored a string of length five in this character array. The null termination is implicit if we are using string literal. Now I want to print this string, but I do not want to use the library function print F, I want to write my own function print, I want to pass this array to the function. And this function should print the string part in a character array. The argument to the function we have talked about this earlier can be something like this to say that we are receiving an array here, but the compiler actually interprets this as this. So the compiler forces that only the address of the character array or the address of any array be received as argument to the function, because arrays are large in size, so it is inefficient to create a copy of the same array for each function. Okay, so let's write the logic now. Now, this print function does not have any idea that this particular array is of size 20, it only knows the base address. So what we can do is we can have a variable I initialize it to zero and we can say something like this, while ci is not equal to null character, we can print the character ci, and then we will increment i. And when we find a null character, we can come out of this loop and print an end of line. Once again, this print function does not know that this character arrays of size 20, it only knows the base address. And that's why in the printf function, when we were not null terminating an array, we were printing all the garbage value even after the array was finished. Because until we get a null character, we do not know where to stop, and we keep on going into unwanted memory locations. Now this code should work. Yes, this is fine. In my code, here, I'm using percent and see here to say that we want to print character, and see if we can also write as strict c plus II as substitute for ci. And that will also mean the same. Sometimes you'll see this kind of syntax. As we talked earlier, both of these syntax as trixi plus imci are valid, they are the same, there is one more thing in our code that we may do, we will not choose to have this particular variable i, we could simply say that while Asterix c is not equal to null, print, Asterix C and then increment c itself. And this code will also work on why this code will work. I leave it as an exercise for you to think in the coming lessons, we will implement more functions for string manipulation. This is it for now. Thanks for watching. In part one of our lesson on character arrays and pointers, we saw how we can store strings in character arrays. And we also saw how we can work with character arrays using pointers in some of the basic scenarios. Whenever we are working with pointers, it's really important that we visualize how things are happening in the memory. So, the first thing that we will do in this lesson is we will simulate the program that we had written in the previous lesson to print the characters of a string and see what goes where in the memory. And we will also look into the concept of string constants and constant pointers. So, this is where we had left in our previous lesson, we have written a function Print to print the characters in a string in the main method, we have a character array of size 20, but we have stored a string of length five in it, we have used a string literal, so null termination is implicit, we have talked about this earlier. So, let us step through this code and see how it is working. Once again I have drawn this familiar diagram the memory that is allocated for execution of a program is typically divided into these four parts these four sections on one part of the memory stores the instructions in the program, we call that the code segment or the text segment, one part one section stores the global variables and stack is where all the information regarding function call execution and all the local variables go whenever we are writing a program whenever we are executing a program we should always visualize what variable goes where or what data goes where and what is the scope of that variable or data okay. So, let us run through this code and see what is happening in the memory. When this program will start executing first the main method, main function will be invoked whenever a function is called some amount of memory from the stack is allocated for the execution. Attack function, it's called the stack frame of that function. So, let us say, this stack frame from address 100 250 is allocated for the main function stack is one contiguous block of memory. So let us say in the stack the memory increases from bottom to top, all the local variables of function go into the stack frame of the function. So, when we declare a character array, or 20 bytes from the stack frame will be allocated for this particular character array. Let's say they're allocated from address 100 220. Each character is stored in one byte, so we need 20 bytes for character array of size 20. Apart from local variables, there may be some more information and stack frame. So that's why we have some more space. And now the control of the program goes to the statement print see, as soon as we make a call to another function from a function, the execution of that particular function is paused at that particular line and the machine goes on to execute the called function, the call function is allocated stack frame on top of the calling function. So print will be allocated a stack frame on top of main function, whatever function is at the top of the stack and at any point is executing main will wait for this function to finish let's say this particular stack frame is from 150 to 170. Main is paused and print is executing right now. Now print will also have a local variable C, but this will be a pointer variable. A pointer variable takes four bytes of memory in a typical architecture. So this will be taking four bytes. So let's say starting address a 154. In this stack frame, we have four bytes for this particular character pointer. So this C in main is actually not the same C in print, the C in main and the C in print are different. They have different scopes, or we could have named this particular variable a or PTR or whatever. But all that happens when we make this particular called to print and pass this see here is that the address 100 which is the base address of the array is passed to the print function and the print function keeps it stores it in a pointer variable. Sometimes it may confuse us when we are using the same local variable name in the calling function and the same argument name in the called function. But we must always understand that they are different. Okay to run through this code further. I'll clear some space here. Now. I'll draw this array c outside the stack here we have an array of size 20. But we are only showing the first six positions in the array from address 100 205. And that's why it is extending towards the right. The sixth character is a null character and the first five characters are the characters of word hello. Now we have this another guy which is C of print, which is a character pointer at address 154 that stores address 100 so it points to the first element of the array. Now let's come back to our program execution. Let's say we are here initially, I'll mark the statement that is executing by this green arrow or Let's name these two guys this guy see but this guy is an array, local domain and this is also c but it is a character pointer local to print. Okay, so now here what we're saying is, while Asterix c is not equal to the null character, when we put this asterik operator in front of a pointer variable, we are looking at the value at that particular address. So at this stage, when C is pointing to the base address as Trixie is H, so this condition is not true, we will go to this line printf that will simply print Asterix C which is h let's write down the output here. So we have printed h so far, and then we say c++. If we understand pointer arithmetic from our previous lessons incrementing a pointer by one unit increments the address by size of the data type that the pointer points to see here is a pointer to character data type and character data type is one byte. So C plus one, c++ is saying C is equal to C plus one. So C now becomes 101. So now c points to the second character in the array. And once again we come to verifying this condition in the while loop as Trixie Is he here it's not null. Now once again we will go inside the loop and print E and we will keep on going like this builder address in this pointer variable reaches 105. Now here, the value at this particular addresses null character so the loop Will not execute, or we will come to this statement to print and end offline and the execution of print function will finish. So this particular stack frame for print will be cleared from the stack will be de allocated. And now main will resume and finished. So with pointers, we should always know what's going where in the memory. Okay, so let us now modify this particular code to learn some more concepts. Or what I'm going to do in my code is, instead of creating a character array of size 20, I'll create a character pointer named C and equated against a string literal in a statement like this. And if you run this program on the output will be the same, what really happens is if you use the string literal initializations to statement of an array something like this, and then the string get stored in the space that is allocated to the array. So in this case, it will go into the stack in this character array of size 20. But if you use the string literal elsewhere in a statement like this, or maybe when we do something like passing a string literal to a function, then in these cases, the string gets stored as a constant during the compile time, most probably it will be stored in the text segment of the application memory, and it cannot be modified. So if you write a statement like this, let's say you want to change the first character of this constant string to a or running this program will give you an error will cause a crash. Okay, coming back to having a character array. Now, if we have a character array, and we are passing on the address of the array to a function, that function receives it in a character pointer. Now, using this pointer, we can modify the data in this particular array. So if I say something like this, we first change the first character to a and then we are printing the characters. And then as you can see, it is possible to do so. Now sometimes we may want a function and just to read a string and not write anything. to force this kind of behavior, we can change our argument to const character pointer. Now if we run this code, this code will give us compilation error, or we can read whatever is there in the array that is passed. But we cannot write to any of the positions, and this code will work fine. pointers are really tricky, and even the most experienced programmers write buggy code when they're using pointers, I recommend that you get your hands dirty by writing some code yourself. That's the best way to learn. So this is it for this lesson. Thanks for watching. In this lesson, we are going to talk about pointers and multi dimensional arrays. As we have seen in our previous lessons, the concepts of pointers and arrays go together. We have already talked about pointers in context of one dimensional arrays, how we can work with one dimensional arrays using pointers. Now let's see how we can work with a two dimensional array or a three dimensional array, or a multi dimensional array in general, using pointers. To understand this concept, once again, we first need to understand how multi dimensional arrays are organized in computer's memory. Let's first go back to the organization of one dimensional arrays in memory. When we declare a one dimensional array something like this, let's say we are declaring an integer array A of five elements, then basically what we are doing is we are creating five different integer variables that we can name a zero, a one, a two, a three and a four as one contiguous block of memory. What I'm showing here is a section of computer's memory, or a let's say is stored in this section of memory, and the starting address of A is 200. As we know each byte in a computer's memory has an address. And if we assume that an integer is stored in four bytes, which is what it takes, in a typical compiler, then the block of four bytes starting address 200 will be a zero, as I'm showing here, block of four bytes starting address 204 will be a one. Next block of code byte starting address 208 will be a two and so on. I'll fill in some values here. We had seen this earlier also in our previous lessons. If we write a statement like this, then this is all right. If I just use the variable name a then name of the array in an expression basically returns a pointer to the first element of the array, because this is an array of integers. So each element will be an integer Hence a returns a pointer to integer. Once I have written a statement like int Asterix p equal a, I can use pointer arithmetic and dereferencing to access all the elements in the array, if I would just try to print the address stored in P and I'm not using full printf statement here, my output will be 200 if I would simply try to dereference p, then output will be two if I would try to print something like Asterix p plus two, then output will be six because we have an integer pointer adding one will take us to the address of the next integer which will be four bytes ahead adding to will take us to the address of next to next which will be eight bytes ahead if we would be printing p plus two it will be 208. And if we would dereference and we would print Asterix p plus two then it will be value six, we have already discussed pointer arithmetic in our previous lessons. Now language gives us this flexibility that we can use the name of the array just like a pointer for all the dereferencing. So instead of doing all of this printing with P if we will do all of this with a it will still be the same. In fact Asterix a plus i is same as AI these are alternate syntax and a plus i is same as ampersand AI both will give us the address of the ayat element in the array. Please remember that even though we can use the name of the array just like pointer for all this dereferencing and arithmetic, it's not seen as a pointer variable. So we can do something like p equal a like what we have done here. So this is all right. But we cannot do the other way we cannot say equal p this will give you a compilation error. So this is pretty much how we would use pointers with one dimensional arrays. Let's now say we want to create a two dimensional array, I will declare a two dimensional array of integers named t something like this. Now, what we are doing here is we are creating array of array, we are creating two one dimensional arrays of three elements each this time be zero and B one are both one dimensional arrays of three integers each. a one dimensional array of three integers would be 12 bytes, if each integer is four bytes in size. So if I have to show this in memory, the first block of 12 bytes starting address 400 will be B zero. And the next block of 12 bytes starting address 412 will be b1. As we had said name of the array returns a pointer to the first element in the array. This time each element is not an integer, each element is a one dimensional array of three integers. So if I would write a statement like this int Asterix p equals p, then this will give me a compilation error, because b will return a pointer to a 1d array of three integers and not just a pointer to integer, the type of a pointer matters not when you have to read the address. It matters when you dereference or when you perform pointer arithmetic. It's really important that we understand this we can define a pointer to a 1d array of three integers like this. And now if I equate this with B, this is all right. equate B with B this time if I would print just p which is same as printing address of B zero, this will be 400 if I will print Asterix P which will be same as B zero, then B zero this time is variable name for a one dimensional array of three integers. So just using the name B zero will return us a pointer to the first in teaser in B zero which will be accessed as p 00. So I'm putting this ampersand sign here in front of P 00. First integer in B zero will be this block of four bytes. Its address once again is 400. Okay, now I have also created three blocks of four bytes each in both v zero and v one and also filled in some values. Now I'm going to write some print statements and I want you to guess the output. What will be the output if I'll try to print B plus one I will write the address of each block of four bytes in the 2d array the address of a block is the address of the first byte in the block. Okay, so what will be the value of B plus one B this time is returning us a pointer to one dimensional array of three integers. So, if I would do a pointer arithmetic like adding plus one, we are moving to the next one the array of three integers. So, we will be moving to address 400 plus size of one dimensional array of three integers in bytes. So, output will be 412 which makes sense because p plus one is same as ampersand B one or address of B one and address of B one is 412 okay now, what if I print Asterix B plus one when we are putting an Asterix signs when we are trying to dereference This is when the type of pointer becomes important B is a pointer to one dimensional array of three integers. So, B plus one is also a pointer to one dimensional array of three integers and when we will dereference we will get this whole one dimensional array of three integers starting address 412 Asterix B plus one is same as B one. So, we will get b one now printing B one means using the name of this one dimensional array B one which should return us the pointer to the first integer in B one. So, astrick b plus one is basically pointer to this integer at address 412. Once again this output will be 412 all these expressions Asterix p plus one or B one or ampersand v one, zero are returning us pointer to integer okay now you need to get up because I'm going to give you some tough ones to decode what will be the output if I will print Asterix B plus one plus two, take some time and think about it. Asterix B plus one as we saw above, will return an integer pointer to first integer and B one to the integer at address 412. Adding to here is performing pointer arithmetic because Asterix p plus one is a pointer to integer storing this address 412 adding to is basically going to the address of next to next integer, which will mean skipping eight bytes and and going to reference in teacher at address 420 as strict B plus one in this expression can be written as b one simply be one because they are substitutes for each other their alternate syntax. So this is same as B one plus two. And once again, these expressions are returning pointer to integer they are returning pointer to this element B one two. That's why we can also say ampersand B one two, all these three once again are seen. Let's do one more print. If you can get this one right, I can say that you're good working with two dimensional arrays using pointers what will be the output for this expression as trick of Asterix, Asterix of Asterix B plus one what will be the output for this expression? Think about it, whenever you encounter an expression with pointer arithmetic and dereferencing then you must go step by step here B is returning us a pointer to one dimensional array of size three one dimensional array of three integers and dereferencing it will give us the one dimensional array. So asterik B as we know will give us B zero asteroid B is same as B zero. Now B zero in my expression, because B's row is named for a one dimensional array returns me a pointer to the first integer in the one dimensional array. So b zero returns a pointer to integer we will get appointed to this integer at address 400. Now, what will happen if you will add one to an integer pointer, it will take you four bytes ahead to the next integer it will return you a pointer to the next integer. So we will get a pointer to this integer at address 404 astrick b plus one is basically ampersand b 01. And with this final dereferencing we can get rid of this ampersand. So the overall expression will be p 01 which is three for a two dimensional array b i j where b is named for my two dimensional array and i and j are some indices can be written as Asterix of B i plus j and once again p AI can be written as as strict SOF B plus i. So these three expressions are same. I would recommend trying all of this in real code. So far this discussion has been about working with two dimensional arrays using pointers. We will stop here for this lesson. In another lesson we will play with some real code And we will also discuss how we can work with an array of further higher dimension like a three dimensional array. We will also discuss passing of arrays to functions through pointers. This is it for this lesson. Thanks for watching. In our previous lesson, we saw how we can work with two dimensional arrays using pointers. Now in this lesson, we will see how we can work with arrays of further higher dimensions like three dimensional arrays using pointers. We will also see how we can pass multi dimensional arrays as arguments to functions because that's one scenario where pointers once again will come into picture. I will start with a quick recap of what we have discussed in our previous lesson. Whenever we create a multi dimensional array, and let's pick up the example of two dimensional array that we had created in our previous lesson, we must think of the multi dimensional array as an array of arrays. Array basically, is a collection of similar things of similar objects. So a multi dimensional array is basically a collection of arrays. This array B here is a collection of one dimensional arrays of three elements each, we have to one dimensional arrays of three elements each, what I have tried to show in this figure is how array B will be organized in memory, I have assumed that the starting address of the array is 400. Each cell storing and teacher here is a block of four bytes. As we know each byte in computer's memory has an address, I'm not drawing all the bytes partition for all the bytes, I'm trying blocks of four bytes each. And that's why I'm writing only the starting address of each block, you can imagine a block of four bytes something like this, the starting address is 400. Let's say each partition here is one byte. So the next byte has address 401 and the next one has address 402. And the next one has address 403. Overall, this first block of 12 bytes, that will that contains these three integers two, three, and six that I'm showing in yellow here is my first one dimensional array that I can call B zero. And this next block of 12 bytes is my second one dimensional array of three integers that I can call B one. So we have two one dimensional arrays in our collection, we have two collections of three integers each in our collection, and everything is organized in one contiguous block of memory. Now let's look at this B zero is from byte address 400 till 411 we have three integers and we have four bytes for each integer. The first integer that we can access as element at zero at index of B zero is taking four bytes starting address 400 the next integer that can be accessed as p 011 element of B zero will take next four bytes starting 404 and the next one will be v 02 element at index two of P zero. And similarly we will have four bytes for zeroeth element of v one four bytes for one element and four bytes four element at index two of B one as we had seen in our previous lesson when we just use the array name, then it returns us a pointer to the first element of the array. Here B is a two dimensional array it is an array of one dimensional arrays of size three. So b will basically return us a pointer to one dimensional array of three elements pointer to one dimensional array of three integers. In this statement, I have declared a variable which is pointer to one dimensional array of three integers and the name of the variable is be a statement like this is all right, a statement like this will not be alright because b will not return a pointer to integer B will return a pointer to one dimensional array of three integers. Now I will write three print statements that I had also written in our previous lesson. I'm not writing the complete syntax for printf. Okay, so once again you need to tell me what will be the output if we would print these three expressions we have p Asterix B and B zero. Well for all these three, output will be 400. here when we say B just using the array name B will return us a pointer to the first one dimensional array in B the type of a pointer variable is relevant only when we are trying to dereference or perform pointer arithmetic. But if we will just try to print the address stored in the pointer variable it will be the starting address address of the first byte of a block of memory. So if we have a pointer to this one dimensional array that is storing two, three Six, then it's addresses 400. Now when we did an Asterix B, which is same as B zero, we data friends and now we have got the complete one dimensional array B zero. Now if I use B zero because b zero is a one dimensional array, we will get a pointer to the first integer in B zero, so we will get a pointer to bs 00 in this block of four bytes starting address 400. Once again if we would just print the address, then the starting address of this block is 400. That's why the output here is 400. Even if I would print ampersand bs 00, the output will be 400 B and Asterix B are both returning us pointers, the difference is that B is returning a pointer to a one dimensional array of three integers while Asterix B is returning a pointer to an integer, when we are just printing the address both these objects the complete one dimensional array B zero and the first element in B zero have the same starting address. So the same starting address will be printed the type of pointer plays a role when you try to dereference or when you try to perform pointer arithmetic. We had also seen in our previous lesson that B IJ can be written as Asterix of B i plus j if b II for some value of i is a one dimensional array, then b i will give us an integer pointer will return us an integer pointer to the first integer in bi then adding j is basically performing pointer arithmetic and getting a pointer to integer at index j in one dimensional array bi and then finally this dereferencing is getting the value of that integer. Once again be I can be written as Asterix B plus i B is a pointer to one dimensional array of three integers. So b plus I will also return a pointer to one dimensional array of three integers and T referencing this particular dereferencing will give us the one dimensional array and the name of one dimensional array returns us a pointer to the first element in the array. So this once again will be pointer to integer. By now if you clearly understand how all the pointer arithmetic and dereferencing is happening in these expressions, then it's not very difficult to understand how things will be for say a three dimensional array. Now let's say we have created a three dimensional array named C we have an array of three cross two cross two or three dimensional array is basically an array or collection of two dimensional arrays. So if I have to show C in memory, I will show it something like this, I have assumed that the starting address of C is byte addressed 800 the first 16 bytes starting address 800 is my first two dimensional array, I am assuming that each integer will take four bytes. So all these cells in yellow are part of the first two dimensional array. The next block of 16 bytes starting address 816 is C one and the next block of 16 bytes starting a 32 is C two, we can further break down the two dimensional arrays into one dimensional arrays. The first two integers in c zero are part of the first one dimensional array c 00. And seven and nine are part of C 01. The first integer in C 00 can be accessed as C 000. And we can go on like this. Okay, once again, we'll play the same game, I will write some print statements and you need to guess the output. This time just using the array name C will give us a pointer to a two dimensional array of integers of size two cross two. So we can write a statement like this I have declared a pointer to a two dimensional array of integers of size to cross to hear the name of the point that is B if I would just print p or C here and I'm not writing the complete printf statement once again my output will be 800. Now if I will perform a dereferencing and try to print Asterix C then this will be seen as c zero and c zero is a two dimensional array. So we will get a pointer to the first element in c zero. All these expressions are returning us a pointer to one dimensional array of integers of size two and the address printed will be 800. Remember C is of type pointer to 2d array of two cross two and Dear friends in ones is giving us point at a one dimensional array of two integers, C is returning us pointer to two dimensional array of integers c itself is an array, there is difference between the two types okay for c c ij k where i j and k are some indices can be written as Asterix off c ij plus K and now once again we can write C ij as Asterix of C i plus j and the overall expression will look something like this and we can go ahead and write C i as Asterix of C plus i if you are able to understand how I have derived these expressions, if you are able to understand all the pointer arithmetic and dereferencing in these expressions, then you are good working with multi dimensional arrays using pointers. I want a quick answer for this one what will be the output for this print statement? Well c 01 means we are going to this one dimensional array that has these two elements seven and nine. And when we are using the our namc Is it a one we are getting a pointer to first integer in this one dimensional array pointer to this integer seven, adding one we are doing pointer arithmetic to an integer pointer So, we will go to nine and data referencing will give us integer nine. In fact, this expression is same as C of 011. Now, what will be the output for this print statement aspects of C one plus one c one will return us a pointer to one dimensional array, the first one dimensional array in C one, this block containing integers three and four, adding one is performing pointer arithmetic and going to the next one dimensional array, it's going to this one dimensional array containing six and one. And now dereferencing is basically getting the one dimensional array from the pointer. And if you just use the name of the one dimensional array, you get a pointer to the first element in one dimensional array. So we will get a pointer to this integer six, output will be 824. This block of four bytes storing address storing integer three is 816. Next would be next will be a 20 and next will be a 24 we can try out these expressions in a real program. I'm writing this simple C program I have created this three dimensional array see the data filled in is same as we were showing in the example. In the first printf statement I'm writing I'm trying to print c astrak, c c zero and ampersand c 00. All of these are pointers. And if I will just use person D address would be printed. When I'm running this code as you can see the output for all these four expressions is same. Any guesses for what will be the output for this printf statement, this expression is nothing but c 001. The output for first printf is different because this is a different run of the program and in each run, the assigned address will change. But whatever the address is, it will be seen for these four expressions, I would recommend trying out all the different expressions that we were decoding earlier in a real program like this. Okay, the next thing that I want to talk about is passing multi dimensional arrays has function arguments. I'm going to declare a function and let's name this function f u n c. And I want this function to accept a three dimensional array as argument. So what do I do? If I wanted a one dimensional array as argument I could have given something like this. But as we had discussed in one of our previous lessons, this syntax is only a syntactical sugar it is interpreted like this by the compiler. A fresh copy of array is not created for a function call, only a reference to it in the form of a pointer is created. So now if in the main function, I have an array of one dimensional array like this, and let's say the return type of this function is void, I can make a function called passing a like this and this will be fine. Now let's say we declare a two dimensional array of two cross three. And now we want this function to receive to take a two dimensional array as argument. Now as we discussed, he will Her return has pointed to in teacher but B will return us a pointer to array of three integers one dimensional array of three integers for this particular definition of p. So, for the function to take this array p as argument definition should be something like this argument should be something like this, either we can write this or we can write something like this, only the first dimension can be left empty the other dimension has to be specified. And now I can pass B, there is something interesting here, if I would declare a two dimensional array something like this, let's declare a two dimensional array x have to cross for now, I cannot pass x to the function, because x will return pointer to one dimensional array of foreign teachers, while this function is supposed to receive one dimensional array of three integers, if x is defined something like this of dimension five cross three, then passing x is fine. Now, if we want to pass this three dimensional array, then once again we need to see what pointer types he will return. So, C will basically return a pointer to two dimensional array of two cross two. So, we can either use a syntax like this or something like this and then we can pass c. So, this is how things will be for any multi dimensional array, except the first dimension all other dimensions will be enforced. One common mistake that people do is for a two dimensional array, they try to use pointer to pointer something like this. And for a three dimensional array, they try to use something like this, which just won't work. So, this is pretty much what we wanted to talk about pointers and multi dimensional arrays. Thanks for watching. Memory is one important and crucial resource on our machine. And it is always good to know the architecture of memory, the way operating system manages memory and the way a memory is accessible to us as programmers. In this lesson, we will discuss the concept of dynamic memory and we will see how to work with dynamic memory using C or c++ the memory that is assigned to a program or application in a typical architecture can be divided into four segments, one segment of the memory is assigned to store the instructions that needs to be executed. Another section stores all the static or global variables the variables that are not declared inside a function and that have the whole lifetime of an application they are accessible anywhere during the whole lifecycle of the application as long as the application is running, one section of the memory is used to store all the information of function calls and all the local variables and we have also talked about stack in our lesson on call by reference local variables are declared inside a function and the live only till the time the function is executing the amount of memory set aside for these three segments the text segment the global variable segment and the stack does not grow while the application is running. We will come back to why we use this fourth segment heap in a while, let us first understand how these three segments of the memory are used. When a program executes, I have a simple C program here we have a function square that gives me the square of a number we have another function square of sum that is given two arguments x and why and it returns us the square of x plus y and in the main method, I'm just calling this function square of some passing it two arguments A and B. Let us now see what happens in the memory when this program executes. Let us say this rectangle in green here is memory reserved as stack and this rectangle in Orange is the memory reserved as statical global variables section when the program starts executing first the main method is invoked when the main method is invoked some amount of memory from the stack is allocated for execution of main and this total is a global variable. So it should sit in this section. The amount of memory allocated on stack for execution of main can also be called the stack frame for the method main all the local variables arguments and the information where this function should should return back to all this information is stored within this stack frame. The size of the stack frame for a method is calculated when the program is compiling. Now, when main calls square of some method, that's right shortcut s four s four squared off some, then a stack frame is allocated for the call to square of some all these local variables x y Zed will set in this particular stack frame. Now, sum of square calls square, let's again put a shortcut here for square. So, another stack frame for Squire and it will have its own local variables at any time during the execution of the program, the function at the top of the stack is executing and rest are kind of paused waiting for the function above to return something and then it will resume execution I have drawn this play and pause button here in case you do not understand Okay, so, this total is a global variable it sits here in this section global variable because it is not declared and declared inside a function, we can access it anywhere. And then we go to this particular statement where we call square of sum and square of some calling square. So right now, this is our call stack. This program may not be the best way to implement this logic, I have written this program this way so that I can have some nested methods calling each other let's say right now, we are at this particular statement we are executing executing this statement. So, at this stage calls a call stack will have these three methods. Now, when this method finishes, we will return back to this particular statement. As soon as Squire function will return, it will be cleared from the stack memory and now some square of some function will resume. Once again when square of some finishes, the control will come back to this particular line to line total is equal to square of sum and main will resume again. Now main we'll call printf. So once again printf will go to the top of the stack printf will finish and the control will come back again to main and now main will finish and when main finishes program will also finish. So in the end, our global variables will also get cleared, there was no need in this program. To keep this variable total as global, we should assign a variable as global only if it is needed at multiple places in multiple functions, and it is needed for the whole lifetime of the program. Otherwise, it's a waste of memory to keep it keep a variable for the whole lifetime of program execution. We had kept one global variable in this program just to understand the cost concepts. Here, I must point out one more thing, when our program starts our operating system allocates some amount of reserved space, let's say always allocates one MB of space as stack, but the actual allocation of the stack frame and the actual allocation of the local variables happens from this stack during runtime. And if our call stack grows beyond the reserved memory for the stack, like for example, if a method a calls b b call C and we go on calling and we exhaust the whole space reserved for the stack, then this is called Stack Overflow and in this case, our program will crash. One common case of Stack Overflow is when you write a bad recursion and your program goes infinitely into recursion. So, as we can see, there are some limitations of stack the memory set aside for stack does not grow during runtime application cannot request more memory for stack. So if it is one MB then if the allocation of variables and functions in stack exceeds one MB our program will crash for the allocation and de allocation of memory onto the stack happens by a set rule when a function is called it is pushed onto the stack on top of the stack, when it finishes it is popped or removed from the stack it is not possible to manipulate the scope of a variable if it is on the stack. Another limitation is that if we need to declare a large data type like an array as local variable then we need to know the size of the array at compile time only. If we have a scenario like we want to decide how large the array will be based on some parameter during runtime, then it is a problem that stack for all these requirements like allocating large chunks of memory or keeping variable in the memory till the time we want. We have heap like stack applications he is not fixed. Its size can vary during the lifetime of the application. And there is no set rule for allocation and de allocation of memory. A program can totally control how much memory to use from the heap till what time to keep the data in the memory during the applications lifetime and he can grow as long as you do not run out of memory on the system itself. That is a dangerous thing also and we need to be really careful about using heap For this reason, we also sometimes call heap, free pool of memory or free store of memory, we can get as much as we want from the heap. How heap is implemented by the operating system Language Runtime or the compiler is something which can vary which is a thing of computer architecture. But an abstracted way of looking at the heap as a programmer is that this is one large free pool of memory available to us that we can use flexibly as per our need. heap is also called dynamic memory and using the heap is referred to as dynamic memory allocation. And let us now see how to use the heap in our C or c++ program. I will clear this code in the left and I will draw one more rectangular block here for our heap. There is one more thing that I must point out before moving forward. He is also one data structure. And if you do not know about this data structure heap yet, you will learn about it in your data structure course. But this nomenclature here has nothing to do with the heap data structure. The term heap here is being used only for the large free pool of memory. heap data structure does not come anywhere in this context. This term often confuses a lot of people when they know about heap data structure. Stack is also one data structure but the stack segment of the memory is actually an implementation of stack data structure. But heap is not an implementation of heap data structure. To use dynamic memory in C, we need to know about four functions malloc calloc, realloc and free to use dynamic memory in c++ we need to know about two operators new and delete. These four functions can also be used in c++ because c++ has backward compatibility, it is only a superset of C, but c++ programmers mostly use these two operators, new and delete, we will see some code examples and try to understand how things happen. When dynamic memory is used, let us first pick up some code example in C, let us write a C program. I'll clean up some of this stuff in the right one MB first tag this was just an assumption. In reality the size of the stack will be decided by the operating system and the compiler, it is a thing of architecture. Coming back to the code. If we declare a variable like this, then this variable is a local variable it goes on the stack memory for this particular variable a will be allocated from the stack frame of the main method. Let us say we want to store an integer on the heap to reserve or get some space allocated on the heap, we need to call the malloc function something like this, the malloc function asks for how much memory to allocate on the heap in bytes, when we say malloc and passes pass as argument size of integer then we are saying that hey give me a block of memory which is four bytes four bytes is the typical size of an integer. So one block of four bytes will be reserved or allocated on the heap and malloc will return a pointer to the starting address of this block and malloc returns a void pointer. Let us say the starting address of this block of four bytes is 200. So malloc will return us the address 200. Now we have a pointer to integer p, which is a local variable to main. So this will be this will be allocated in the stack frame of the main method. We have done a typecasting here because malloc returns pointer to wide, sorry, void pointer, and p is an integer pointer. Now p stores the address of this block of memory which is 200. So we have got some block of memory on the heap, which we want to use to store an integer. Right now we do not know what's there in this particular block of memory. If we want to fill in something here, we need to dereference this location using the pointer P and then put in some value. In fact, the only way to use memory on heap is through reference. All the malloc function does is look for some free space in the heap book set or reserved set for you and give back the pointer and the only way you can access this particular block by keeping a pointer variable which will be local to function. Now, let us write something like this, after writing 10 in this particular block, I will go ahead and make one more call to malloc. When I make one more call to malloc, one more block of four bytes is allocated on the heap. And let us say the addresses 400 for this block. Now, the address that is returned by the second call to malloc and restore this address in the variable p. So, what happens is that P is now pointing to the address 400. The next line writes 20. at this address, we allocated one more block and we modified that recipe to point to this block, the previous block will still set in the heap. This memory we're still consuming, it will not be cleared off automatically. At any point in our program, if we are done using some particular block of memory which is dynamically allocated unique using malloc. We also need to clear it because it is unnecessary consumption of memory which is an important resource. So, what we should have done here is that once we were done using this particular block of memory at 200, we should have made a call to the function free any memory which is allocated using malloc is cleared off by calling free and to free we pass the pointer to the starting address of the memory block. So, now with this code, this first block of memory will first be cleared and then we will be pointing to another memory address. It is the responsibility of the programmer to clear anything on the heap if he has allocated it and does not need it any further. So if you see in terms of the scope of the variable, anything allocated on the heap is not automatically D allocated when the function completes like on the stack, and it does not live, it does not need to live for the whole lifetime of the application like a global variable, we can control when to free anything on the heap when to deallocate anything on the heap. If we wanted to store an array on the heap, like let's say we wanted to store an integer array, then all we do is make a call to the malloc asking for one block of memory equal to the total size of the array in bytes. So, if we want an integer array of 20 elements, then we will make a call to malloc asking 20 into size of int which will be for number of bytes. So what will happen now is that one big contiguous block of memory for 20 integers will be allocated on the heap and we will get the starting address of this block. So we kind of get the base address of the array, the speed will point here to the base address of this block. And then in our code we can use this 20 integers as P zero p one, p two and so on. As we know, P zero is same as saying value at address P and P one is same as saying value at address p plus one, this is what it means. One more thing, if malloc is not able to find any free block of memory is not able to allocate some memory on the heap, it returns null. So for error handling, we need to know this. And we need to write our code appropriately malloc and free the use of malloc and free a C style code. If we want to write the same code, same logic in c++, then there is not much difference. Instead of using these two functions malloc and free, we will use two operators new and delete and write our code something like this. So instead of using malloc, they are using the new operator here. And instead of using free we are using delete here. If we want to allocate an array, we use something like this where we put the size in brackets here. And if we want to free an array, we use this particular operator delete and two brackets, sorry, one bracket. With c++ we do not have to do all these typecast things like malloc returns void and we need to typecast it back to integer pointer, new undelete operators are type safe. What it means is that they're used with a type and return pointers to a particular type only. So here we will get a pointer to integer only, we will be talking about dynamic memory allocation and other library functions in more detail in the coming lessons. So thanks for watching. In our previous lesson, we learned the concept of dynamic memory allocation, we learnt about stack and heap in the context of applications memory. In this lesson, we will be looking at various library functions available in C for dynamic memory allocation. We will look through these functions. In some code examples. We will be talking about three functions that allocate block of memory on the heap. And these functions are malloc, calloc and realloc. And we will also be talking about one function that D allocates a block of memory on the heap and this function is three. Let us first talk about malloc. This is the most frequently used library function for dynamic memory allocation. And the signature or the definition of this function is something like this. This function as argument asks you for the size of the memory block in bytes. This data type size underscore t if you are not aware of it is a data type that stores all the positive integer values. So, you can think of this particular data type as unsigned integer data type, the size cannot be a negative value it cannot either be zero or a positive value. And to force this kind of behavior, we use this particular type. And this function malloc returns a void pointer, we have talked about word pointer in our previous lessons malloc returns a void pointer that gives us the address of the first byte in this block the block of memory that it allocates. So using malloc, you kind of say that, hey, give me a block of memory with these many bytes. Let us say what we have here in the right is the heap section of memory available to us. Each of these partitions are one byte. As we know each byte in the memory has an address, let us say this bottommost byte has the address to 00. And the next byte is 201. And we go on increasing towards the top, I'll mark these among the address of some of these bytes. Let's say in our code, we make a call to malloc something like this, that, hey, give me a block of memory. That is four bytes. Let's say we store the address returned by malloc in a void pointer variable. Now let's assume that this particular rectangular block that we're showing here in the read is what gets allocated against this call to malloc These are four bytes the starting address is 208. So what will be the address and P if we want to print the address and p, then what will be the output, the output will be 208. This is cool. Using malloc, we are able to allocate some amount of memory deserves some amount of memory. But why do we resolve memory, we reserve or allocate memory because we want to store some data there. So we do not want to just randomly allocate some number of bytes. So although it is correct to write a statement like this, in practice, we would not do so in practice, we would first calculate how much amount of memory we need to store our data. So let's say we want to store an integer, just one in teacher. So I need memory blog equal to the size of one integer. So we typically use the function size off, which returns us the size of a variable and bytes to figure out the size of the data type. And then we typically multiply this particular value returned by size of by the number of units that we need. So if we need just one integer, if we need memory for just one integer, and this is good, if we need memory for 10 integers, we would write something like this, give me 10 into size of integer. integer is a primitive data type. Sometimes you may know that I know that size of integer is four bytes. So I can write something like 10 into four here, but it's not a good practice to do. So, size of a variable depends upon the compiler. And we will also be using malloc to allocate memory for complex data types. So we must use malloc. Like this. Total number of bytes should be written as number of elements into size of one unit, one unit of the data. Let's say if you want to have space for three integers, I have picked up three so that I have enough enough space to allocate memory in the figure that I'm showing here. Let's say this block of 12 bytes is allocated because size of integer is four bytes typically, so the starting address would be 201. Now, how do we fill in data here, if you see malloc returns a void pointer and void pointer as such cannot be dereferenced you cannot write a statement something like asterik p is equal to two. This is incorrect, you cannot dereference a void pointer wide pointer in fact is only used as a generic pointer type which is normally typecasted into a pointer type of a particular data type. And then it is used because malloc itself is a generic function to allocate some number of bytes in memory in heap. It does not care where whether you are allocating this memory to store character or to store integer or to store any other data type. It simply returns a void pointer to the starting address. To be able to use this block of memory we first need to typecast this void pointer into a pointer of some data type. So here we will write something like Hanes Star p, instead of picking up a void pointer, we pick up a pointer to integer because we want to operate with integers, so to dereference, we need an integer pointer type. So we do the typecasting here of the void pointer pointer. And now this statement is valid. If we want to assign some value to the second element, second integer in this list, then we will do something like we will dereference the address p plus one, let's say we write the value four here. And if we want to access the third integer, then we will write something like this. Let's set the value of sex here. By asking for a memory block. For three integers, we are basically creating an array of integers with three elements, we could also write this as strict p as P zero. And we could also write as strict p plus one as p one. And similarly as strict p plus two SP to the mean the same. All the manipulation on dynamically allocated memory happens through pointers, you have a pointer to the starting address. And then if you want to go to the next element in the array, you increment the pointer. And this is how things happen. We have two more functions that allocate block of memory. Let us now talk about calloc. The signature or definition of calloc is something like this calloc also does the same stuff as malloc, it is only a slightly different calloc also returns void pointer. But calloc takes two arguments, instead of one argument, it takes two arguments. The first argument is the number of elements of a particular data type. And the second argument is the size of the data type. So with malloc, if we have to declare an array of size three, an integer array of size three, we would say three into size of int. With callot, we would say something like this, the first argument is how many units of the data type you want, or the number of elements. And the second argument is the size of data type in bytes. There is one more difference between malloc and calloc. When malloc allocate some amount of memory, it does not initialize the bytes with any value. So if you do not fill in any value into these addresses allocated by malloc, you will have some garbage there. But if you allocate memory through calloc calloc sets all byte positions with value zero, so it also initializes the memory that it allocates to zero. The third function that we want to talk about is realloc. If you have a block of memory, dynamically allocated block of memory, and if you want to change the size of this block of memory, then you can use realloc. The definition or the signature of this particular function is this function takes two arguments. The first argument is pointed to the starting address of the existing block. And the second argument is the size of the new block, there can be a couple of cases in relock, the size of the new block that we want may be larger than than the size of the previous block. In that case, machine may create an entirely new block and copy the previous data, whatever bytes was written in the previous block into the new block, if contiguous or consecutive memory is already available with the existing block and the existing block may also be extended. Let us now look at some code examples and see what we can do with these three functions. And we will discuss the function three in our code itself. I'll write some C code and look at some of the use cases in which we can use dynamic memory allocation. The first use cases let us say we want to declare an array. And we want to first asks the user the size of the array and then we want to declare an array exactly of this particular size entered by the user. So let's say I have a variable n and I write a print statement like enter size of array and then I input this number n from the console. Now I want to declare an array of size n only. So can I do something like this? Well, no, this particular value in the braces cannot be a variable this will give you a compilation error, we need to know the size of the array we cannot know the size of the array during runtime. In such a scenario, we can allocate the memory dynamically. So we will write something like in Star A is equal to and we will make a call to malloc to allocate a memory block equal to the size of an integers. And this will again give a compilation error unless we typecast this particular the return of malloc to integer pointer and now we have an array of size n and we can fill in some data into the dynamically into the elements of this dynamically allocated array. Let's say we want to put data something like first element is one, and the second element is two, and so on. So we will write something like a i is equal to i plus one, we can print the elements in the array. Let's say we want to pick up size of array as then. Okay, so the output is as expected, we have 10 elements from one to 10. If I give size of array as let's say 25, then this is what we get, we get all the elements till 25. If we wanted to use calloc, instead of malloc. Here, the only change in this code would be that we would use calloc here, and we would have two arguments, and would separate out as first argument and the second argument would be size of int. And this program will run around seamlessly. There is one more difference between malloc and calloc. If we do not use this initialization, then with calloc, as you can see, all the elements are being printed as zero, they're all initialized to zero. But if we were using malloc here, then these elements are not initialized, there is some garbage value at each of these indices in the array. So this is one difference between malloc and calloc calloc initializes fills the value zero into each byte while malloc doesn't do this initialization. I'll rewrite this initialization loop again. And now we will talk about free any memory that is dynamically allocated remains allocated till the lifetime of the program till the time the program is executing, unless you explicitly D allocated and to deallocate memory allocated using malloc and calloc or relock, we have the function three and to the function free, you just pass the starting address of the memory block as argument. Now what will happen if I free a, if we free a then the data from that memory is erased, it may or may not be erased, it actually depends upon your compiler or machine. But that memory will be available for a location against another call to malloc. Let's say let's see what happens in this case when we are printing after freeing that particular memory block, I give array sizes five and as you can see the elements being printed here, there is some garbage value being printed. If this tree was not there, we would have printed elements 12345 as initialized. Now the obvious question would be even though we are freeing the memory here, we are able to access that the value at that particular memory location using the statement when we are using AI the element at index i Well, that is one dangerous thing about pointers. If you know the address, you can look at the value at that address. But you should read and write to that address only if that address is allocated to you. What if that address is not allocated to you like in this case? Well, you do not know what you are reading or what you're writing. And what we have here it will have, it actually depends upon the compiler and the machine. In my case, let's say after freeing we try to access the third element a two and try to push some value there. Let's see what happens if we run this program. Let's give size of arrays five again, if you see even after free, we are able to modify the value at this particular address a two part on some machine such a program may cause our program to crash, we should always be sure to use the memory that is allocated. Otherwise, it's like shooting in the dark. We do not know what will happen. We will not talk about Maria Alok. If we want to modify the size of a memory block. Let's say we have a memory block to store n elements in an array. And we want to extend it to maybe we want to double the size of the array. Or maybe we want to reduce the size of the array to half. For such scenario we use real lock and call to Ria lock will be something like this. Let's say we take another pointer variable b then to relock we pass the previous pointer a and size of the new block. So the new block is two into n into size of int and we'll have calls to of course do the typecasting here okay now what this call will do is it will create a new memory block of size to n and copy the values in the previous block in the previous memory block a into this new memory block. how realloc works is that if the size of the new block is greater than the size of the previous block, then if it is possible to extend the previous block find some constitutive memory with the same block. Then the previous block itself is extended. Else. A new block is allocated and the previous block the content from the previous block is copied and the previous block is d allocated this will become further clear if I write this print statement. I'll print the previous block address stored in a and the new address stored in B and I'll also print all the two elements in B now, and I'll print each element in the array B in one single line. Let's say size of there is five again. Okay, so the previous block address is 9920128. And if you see the new address is also same. So it was possible to extend the previous block only. And in B, the first five elements are from a and rest five elements are garbage value. If we wanted to reduce the array size to let's say, half the same block, the previous block itself will be reduced. So let's say I want to print the previous block now, the n elements. Now as you can see, the first two elements are copied one and two, they're not copied, in fact, they are there already, the rest three are de allocated. When we divide five by two, we take only the integral part. So we kind of deallocate the space for three elements here. In fact, if we give the size to be zero, here, all that will happen is that the complete block four a will be de allocated. So this statement will be equivalent to using free upon a. In most cases, we will put the return address by realloc into the same integer pointer. so we can write instead of writing B here we can write a also, we can also pass the first argument to realloc as null if the first argument is null, and the second argument is size. And let's say we want to create something like a new block, with address starting at a stored in B, that is the first argument is null, then this is equivalent to calling a malloc. This only creates a new block does not copy anything from the previous block. So realloc can be used with the right arguments as substitute for free as well as as substitute for malloc. This was all about malloc, calloc, realloc. And free, we will see more code on dynamic memory allocation in the coming lessons. So thanks for watching. In this lesson, we will talk about pointers as return types. For functions. A pointer is just another data type. It's just that a pointer stores the address of another data type. So it is quite possible for a function to return pointer. But we must understand the use cases in which we may want to return a pointer from a function. So let us try to understand this. I'll get started by writing some code. Now I want to write a very simple C program. Initially, I want to write a function ad that will take two integers as argument and sum these two numbers and return the sum. So let's say we declare another variable c and c is equal to a plus b and the function returns C. Now in the main method, I'll initialize two variables. Let's name these variables x and y, let's say x is equal to two and y is equal to four. And we will have another variable said, which will be the return of this function ad. And we will pass x and y as arguments to this function. And finally, I'll print something like sum is equal to Zed. No prizes for guessing the output here. I'll modify this code slightly. But before that, I want to talk about this concept once again, that x, y and Zed are local variables to main function, and a, b and c are local to add function. And what really happens when we call the add function is that value in this variable x of Maine is copied to variable a of add, and value in y of Maine is copied to b of ad. And what if we named these variables in Maine, A, B, and C instead of x, y and Zed if we run this code output will be the same. This time, what we will say is that the value in a of Maine is copied to a of ad and the value in B of Maine is copied to b of ad, this a in Maine and this a in AD, they are not the same. You can verify this by printing something like this. I'm printing the addresses of these two A's in my code. And as you can see, our address of A in Maine is something like 2883032 and in AD it is 2882792 so they're not the same. That means these variables are not the same they are at different memory addresses and the names of variables are local or specific to a particular function. In our example, here, the method the function mean can be called calling function and the function ad can be called called function. In this particular call, when we are saying that c is equal to AD and passing a and b, and this call where a and b in Maine are getting copied to a and b in AD. This is called Called by value, this can be called a call by value. Now, what I want to do is instead of passing by value, I want to pass the addresses of these two variables. So, I want to say that I want to pass address of A and address of b to the add function. So, the signature of add function should be such that it should receive the addresses. So, I will say that, okay, it takes two pointer to integers A and B. And now, we can access the values at these addresses by using this Asterix operator which is used to date reference and address. Now such a call is called call by reference, a and b are integers local to main function and in the function ad, A and B are not integer variables, A and B are pointer variables pointer to integers. So the type is different. They're not in their int star. But at the end of the day, they are also variables which are local to the function add. It's just that they're not integers. And now I'm using these two variables which are pointer to integers to access these two variables a and b in the main method, and to do so we use the asterik operator and now this code should also work. I'll write a few more print statements inside this function add. I have tried to print a and I have tried to print Astra K. And initially I was printing ampersand A. So now ampersand a should give us the address of the pointer variable a should give us the address of A in Maine because that is what this variable stores and asterik A should give us the value of A in Maine let us see. And the output. As you can see here, the address of A in Maine is 3537612. And address of A in AD is something else, but the value in a of ad, which is the address of a of Maine is equal to 353762. So the first and the third line are same. And using the address we are printing the value, which is equal to two I had a spelling mistake here. Now I'll clean up some of these print statements coming back to our function ad we are returning this value C and once again in the main method we are collecting this value seen another variable which is C of main why not do something like pass the address of this C in add function. So what we will do now is we will say that we want to return a pointer to integer from this function. And here we will return ampersand see now ampersand operator when it is put in front of a variable it gives us the address. Now of course here we will have to collect this particular address. So we will have to define a pointer variable. Now this would be okay. And when we are printing, we will have to print the value at address being pointed to by this pointer variable. So what we just did was, what we just did is we modified this add function to return a pointer to integer there are two syntax, we can say int and then put this Asterix sign or we can say int and then put this Asterix and in front of the function name, ad and what the syntax are valid. Now this function is returning pointer to integer. Let us run this program and see what happens. Well, let me also strike off this print statement here. Okay, so the output seems to be all right. Now have you got some logical error with this code already? If you haven't, stay with me for some time. Now what I want to do is I want to write another function, a simple function that will print hello world. So I'll name this function print hello world. And in this function, I'll write a simple print statement. And now before I print the sum, what I'll do is I'll call this function print hello world. And let's see what happens now. Oops, this looks weird. Some is not correct. Now, I just saw that it was coming fine in my last run when I did not call this print hello world. What happened? So let's try to understand what really happened here. I'll come back to this family a diagram of various sections of applications memory, and the memory that is allocated to a program is typically divided into these sections, all the local variables, and the information about function call executions goes into the stack. So let us run through this code. Let us simulate this code and see what's really happening in the memory. For each function calls some part of the memory from the stack is allocated for its execution. We call this the stack frame of that method or that function when the program starts executing for The main method is invoked. So in the stack frame, some memory will be allocated for main function, and all the local variables of main function will live inside this stack frame. Let's say the starting address of this stack frame is 100. And the end address of the stack frame is 130. And we will have three local variables created here, A, B and PTR. a and b are integers and PTR is an integer pointer, let's say is at address 100, b is at address 112. And PTR is at address 120. I'm just making these assumptions. Now when the main method will come at this line will where it is calling ad function, its execution will pause and now memory will be allocated for the execution of ad at any time whatever function is at the top of stack is executing main method will wait for add function to complete and return. So here I should say a is equal to two b is equal to four. And now add comes here in the stack, let's say add gets memory from 130 to 160. And add also has three local variables a B and C A and B are pointers to integers, the value of a will be 100 and the value of B will be 112. Let's say their addresses his addresses are 130 140 and 144. Once again these are just random assumptions. Now see is calculated as asterik A plus asterik b A is pointing to this location and B is pointing to this location asterik is value at address stored in a and astrick B's value at address stored in B so this C will be six here these two values will be added. Now this add function will return the address of its local variable C which is 144 and finish its execution. So this PTR will be 144 and now the memory that is allocated to add function will be de allocated. Now this memory above address 130 can be used for other function calls. And even though this variable pointer PTR stores the address 144 stores the address of this particular block it kind of points to this particular block. The data here is not guaranteed because this memory has been de allocated. Now we come here to this print hello world. And now a memory from stack will be allocated for print hello world. Above this stack frame of main method. This is main. So let's say that print HelloWorld gets this memory block from address 132 address 150. But there is no local variable in this print hello world function. But still function call execution involves storage of some information. So now this section from 130 to 150 is for print hello world, I'll write pH Ws shortcut for print HelloWorld. And it has been overwritten. So this block at 144 no more stores a value of six. So when we come here at this print statement to print the value at this particular address, we get some garbage value. Now the obvious question would be why did the diode Why did we get the right value, when we were not making a call to print hello world, I would say that I just got lucky maybe because I did not call any other function after making a call to add my machine did not overwrite or erase the data at that particular memory location. But when I made a call to print HelloWorld that memory got used. If you see we have passed the addresses of these two variables a and b of Maine to add function, but that is all right because called function always comes above the calling function in the stack. So anytime this called function is executing calling function will be in the memory. So if ad is executing main is guaranteed to be in the memory. So addresses of variables in Maine will be accessible to add. But if we try to return a local variable from the call function back to the calling function, like if we want to return a local variable from add to main, then when that function finishes and the control returns back to the calling function, that memory has already been de allocated. So it is okay to pass something from bottom to top in this call stack. Or I should rather say that it's okay to pass a local variable the address of a local variable from bottom to top in this stack but it is not okay to return the address of a local variable from top to bottom in the stack in the call stack. I hope this makes sense. So now the obvious question would be what are the use cases in which we may want to return pointers from functions and well if we have address of some memory block in the heap section or some memory block in the global section, then we can safely return that address Have these blocks because anything in the heap has to be explicitly de allocated we control it's D allocation unlike stack. And anything which is in the global section, a global variable lives, for the entire lifetime of the program, I can use malloc or new operator in c++ to get some memory on heap. So, if I modify my code something like this, I will declare this C as a pointer to integer and get some space allocated on the heap using a call to malloc. Now malloc is a library function that returns a pointer, but it returns a pointer to an address which is on the heap. So, we get a memory block and using this pointer variable now, we can write this value asterik A plus astrick b at that particular memory block and then we can return this address C which is the same address that malloc returned us, but we are safe now because we are returning address of a block which is on the heap and and not on the stack and this will work now. Now in this code, let's say this call to malloc gives us this block at address 500 in the heap see now is only pointing to this block and using C we have written this data here this value six and now when add finishes, the address returned by the add function which is address 500 is still valid and we still have the data there and it will not be de allocated anything on the heap is explicitly has to be explicitly de allocated. So while returning pointers from functions, we need to be careful about the scope, we must be sure that the address is not reused to store something else or the data is not cleared from that address. In most cases we will be returning pointers to memory that is allocated on the heap, or memory that is in the global section the global variables section. In our coming lessons one place where we will be using pointers as function returns in our code is implementation of linked list data structure. So this was pointers as function returns. Thanks for watching. In this lesson, we are going to talk about function pointers. function pointers, as the name suggests, are used to store address of functions. So far, we have used pointers mostly as variables that would store address of other variables. Basically, pointers are data types that can be used to store the address of some data stored in computer's memory, or in other words to point to or refer to some data. And it doesn't always have to be a variable data could be stored as constant also. And we use pointers not just to store the address, we can dereference and get the value at whatever address the pointer is pointing to. Now we are saying that we can have pointers that can store address or functions or in other words can point to functions. And we can use a pointer to function to dereference and execute the function. And this is really interesting. Some basic questions would pop up what really would be the address of a function. And even if we can have pointers to functions, what are the use cases in which we may want to have them? There are really interesting use cases of function pointers, but we will talk about them later. Let's first try to understand the core logic here. Once again, I have drawn this familiar diagram, the memory that is allocated to an application or a program can typically be divided into these four segments. We have talked about this quite a bit in our previous lessons. Okay, now a program is basically a set or sequence of instructions that you would give to the computer to perform a task, we can write our program in a high level language like C or c++, but at lowest level in its architecture, computer understands and executes only binary, any instruction that has to be executed by the computer has to be encoded in binary. Of course, there will be some rules for encoding. So what we do is we write our program or set of instructions in a high level language like C or c++, and we pass it to a program called compilers as input and corresponding to the source code compiler generates what we call machine code, or executable code, which is instructions encoded in binary. Something like what I'm trying to show here. compiler basically takes one or more source files. Let's say the program that I have written here is in a file named program dot c. Now a compiler for C language will take this file as input and create an executable file that will have the machine code on a Windows machine executable file has extension e x e, an executable file will be stored in disk drive or some secondary storage device. Whenever we say memory, just memory in context of programming, we mean the random access memory or RAM that we also call the main memory or primary storage. So whatever applications memory we're talking about here will be a chunk of main memory. A program or application gets a chunk of memory only when it starts execution. When the application finishes execution, this memory is claimed back. What really happens is that when we run a program, when a program starts execution, some amount of memory is allocated to it. And that is what we are calling applications memory. Here. The cold or text segment of applications memory is basically the machine code or instructions copied from the executable file. Instructions are not executed directly from secondary storage. Therefore, they are first copied to main memory, and then only they can be executed. During program execution, we need memory not just to store instructions to be executed, but also to store a lot of data that we would work upon in a program. These other segments are mostly about storing and managing data. What I'm going to do now is I'm going to zoom into the code or text segment, let's assume that each instruction in machine language takes four bytes. I'm trying to show the section of memory storing the instructions here, each partition here is a block of four bytes and addresses increasing from top to bottom. So, we have instruction zero at address 200. And the next instruction is at address 204. And the next is at 208. And so on, instructions in a program are executed sequentially. Only Exception will be when instruction itself will say that hey go to or jump to this other instruction at this particular address, which will happen in case of function calls. For example, if instructions 01 Nat address 200 is currently executing By default, the next instruction to be executed is instruction 02 at address 204 unless instructions 01 itself is something like go to instruction 05 at address 216 which will happen in case of function calls. A function is nothing but a set of instructions stored in one contiguous block of memory. Let's say this block containing instructions five till eight is a function. I'll name this function if you and see one. Basically, a function is a set of instructions to perform a sub task in memory a function will be one contiguous block with some instructions, the address of a function what we also call entry point of a function will be the address of the first instruction in the function. In this example here, address of function one is 216. a function call in machine language will basically be an instruction to jump to entry point of some function to jump to first instruction in a function. Now we will not go any deeper into architecture now this is good enough to understand function pointers. When we say function pointers store address of functions, we basically mean that function pointers store the starting address or entry point of the block of memory containing all the instructions in a function. Let's now see how we can create and use function pointers in a C or c++ program. I am going to write a simple C program here. The first thing that I'm going to do is I'm going to write a function named ad. That will take two integers as argument and return the sum of these two integers. And now I'm going to create a function pointer that should point to this function add. The syntax to create function pointer is, first type in the return type of the function to which this pointer will point at will return int so I typed in int, then after space within paranthesis, type in Asterix, and then name of the variable so I'm creating a pointer named P. And now once again within paranthesis. Type in all the argument types of the function to which this pointer will point. argument types in function declaration should be exactly the same as in the function to which this pointer will point. Because both arguments in add function are int, we have two ends in the declaration of function pointer also, to initialize function pointer and fill in the address of a function we can use a statement like this. As we know ampersand operator gives us the address of something. This statement p equal ampersand ad will fill in the address of ad in P. So P now points to AD. And using p, we can execute this function ad. What I'm going to do here is I'm going to declare an integer variable named C. And now I'm going to write a statement like this. What I've done here is first I have used the Asterix operator to dereference and get the function. And then I have passed arguments just like I would do with a function name. So I've passed two integers two and three. And if everything is alright, the output of this printf statement here should be integer value five, when I run the program, this is what I get. So, this is really cool, we just used a function pointer to refer to a function and then execute the function. One thing about the syntax of function pointer declaration, we are putting the identifier or name of the pointer within this paranthesis if we would not use the paranthesis then it will mean that we are declaring a function that will return a pointer to integer in this case, if I would write something like this, I would write a declaration something like this, then this is declaring a function that would return a pointer to integer we can have an Asterix just before the function name or we can have an Asterix just after int these two syntax are same, but if I would put this within paranthesis then this is declaring a function pointer. Okay, a few more things. In this initialization Here we are using this ampersand operator. Even if we do not use this ampersand operator, it will mean the same just using the function name will also return us address of the function or in other words and appropriate pointer to data friends, instead of using this paranthesis and Asterix operator with function pointer name, we can simply use the function pointer name and this is good enough. So we can use function pointer name or identifier just like function name, as you can see the output here is as expected. So, we have two possible syntax for both referencing and dereferencing you can use whichever you like the second one is more famous, one final thing to be able to point to a function type of the function pointer must be appropriate. So in this declaration of P here if I would change it something like this, then this function pointer is meant to point to a function that should take two integers as argument and should return void add function is returning int, so P cannot point to add this will give me compile ation error. Once again, if I will change the declaration something like this, if I will have only one argument in the declaration of function pointer, then P cannot point to add. Okay, now let's use some more functions with different signatures and try to execute them through function pointers. I'm writing this function print hello, it will simply print hello on screen. And we will have to declare a function pointer like this. And then we can initialize the pointer and fill in the address of this function. And now we can execute the function through the pointer. Let's see what the output is. This looks alright. Now let's say we want to say hello to someone and I'll change the signature of print hello, to take a string as argument the declaration of a function pointer will also change and while calling we will have to pass a string upon running this program, this is what I get. And this is also looking fine. So this is pretty much how we can create and use function pointers in C or c++ function pointers are used in a program in interesting scenarios. They have interesting use cases. We will talk about the use cases in next lesson. This is it for this lesson. Thanks for watching. In our previous lesson, we saw what function pointers are. And then we wrote a simple program to understand how we can create function pointers in C or c++ program. But we did not discuss the real use cases of function pointers, real scenarios where function pointers can be useful. So in this lesson, we are going to talk about the use cases of function pointers. All the use cases of function pointers are around this concept that function pointers can be passed as arguments to functions. And then a function that would receive a function pointer as argument can call back the function that this pointer will point to. To explain this better, I will have to write some code. First of all, I'm going to write a simple function named a dysfunction. No argument returns void and simply prints Hello on screen. Now I will write another function named p, this function takes a function pointer as argument PTR should point to a function that should take no argument and should return void of function like a. Now in B, I will simply use this function pointer PTR to call whatever function it's pointing to. Or in other words, I can say that I will call back the function passed to me or given to me through PTR. In the main function, I will declare a function pointer. And this function pointer should also point to a function that should take no argument and should return void. I will initialize this function pointer p with address of A. And now I will call this function be passing it this function pointer P. Let's run this program and see what happens. Hello is getting printed on screen. So, basically function a is getting executed, a is getting executed through this callback. In the main function instead of writing these two statements, I can simply write a statement like this and this should be good enough, because name of a function we had discussed this earlier also returns a pointer. So, this one statement is same as previous two statements, when reference to a function is passed to another function, then that particular function is called a callback function. So, a is a callback function here, it can be called back by B through the reference through the function pointer. This statement where we are calling the function through function pointer is a callback, we are still not doing something very meaningful here. What's the point in calling a indirectly through B in this code, this is not making much sense. So let's now look at a scenario where using a function pointer and callback can make our life easier. I have a simple scenario, I have a list of integers in an array, and I want to sort this list in increasing order of the value of integers. To do so I will write my own sort function, I'm writing a function named sort that will take an array and number of elements in the array, the function will take an integer array, here I can write a and then brackets or I can write Asterix a these two are alternate syntax, I will use simple bubble sort algorithm, I have renamed this function as bubble sort. In bubble sort, we make multiple passes on an array. And in each pass as we go from left to right, as we go from lower indices to higher indices, we compare adjacent elements. And if the element at lower index is greater than the element at higher index, while comparing adjacent elements, then we swap the elements, this inner loop is a pass on array. And this outer loop is basically saying that we will make n passes after first pass the largest element in the list will bubble up to the highest index, and in the next pass, the second largest will bubble up to its appropriate position, this will go on and it finally in n passes, the complete list will be sorted. If you want to refresh bubblesort. There is a link to my code schools lesson on bubble sort in the description of this video. In the main function I have called bubblesort function passing it array A, and then I'm printing all the elements in a and hopefully elements should be printed in increasing order. The output is as expected, we have a sorted list here. Okay, now let's say I want to sort my list in decreasing order of the value of integers. So what change should go in my code here? Think about it. The only change will be in this comparison logic in this if statement, while comparing the adjacent elements. Now, I will say that if the element in left is smaller, if the element at lower index is smaller than swap, or basically, in 10, push it towards higher index, comparing adjacent elements and swapping is basically pushing smallest or largest element towards higher indices. With this condition. With this comparison, we are pushing the smaller number towards higher index. Let's see the output now. As you can see, I'm getting the numbers in decreasing order. Now my list is sorted in decreasing order of the value of integers. Now let's say I have a requirement like this. Sometimes in my program, I want to sort a list of integers in increasing order. And sometimes I want to sort a list in decreasing order of the value of integers. So what all can I do? Think about it. One thing that I can do is I can write To start functions, the first sort function to sort in increasing order and another sort function to sort in decreasing order. But if we will do so there will be a lot of duplicate code, the two functions will be same, except just one character this less than sign, or greater than sign. Writing duplicate code has a lot of disadvantages. So can we do something better. Another thing that we can do is we can pass one more parameter to the sort function to say whether we want the list sorted in increasing order or decreasing order, we can have a flag, let's say when flag is one, we will start in increasing order and when flag is zero, we will start in decreasing order. Using this approach, we can avoid writing a lot of duplicate code. What I'm going to do is I'm going to use a function pointer. Sorting off a list is always done on basis of some ranking mechanism. So based on some property, we should be able to compare elements and say that they should come first and they should come later, the core logic in sorting will always be the same. Only the ranking mechanism or comparison logic will change. What I'm going to do is I'm going to decide which element is greater in rank and which element is lesser through a function, basically, I will perform this comparison through a function, my function will take a function pointer as argument, my sort function will take function pointer as argument, the callback function, or the function that this pointer should point to, must take two integers as argument, it should compare the two integers, and then it should return back an integer. It should return one if first element has higher rank zero if the elements are equal, and minus one if second element or second argument has higher rank. And let's say the element that has higher rank will go towards the end in sorted array towards higher indices. These are my assumptions while designing this sort function. Now I'm going to use my callback function for comparison, if AJ and AJ plus one are now passed as arguments to this callback function, and we get one, so this condition will be true, we will swap in this condition because AJ will have to be higher in rank for this comparison function to return one. So we will try to push a j towards higher indices. Let's now try to use this particular implementation of bubblesort, I will have to write a callback function first, I have written a function like this. Now in main, I can just use the name of this function that will return me a function pointer and pass it in this call to bubblesort. In this comparison function, I have not written a statement to return zero if elements are equal. Equality doesn't matter in the logic, so far equality also I will return minus one. Let's first run this program and see the output. This is what I'm getting the numbers are sorted in increasing order. Now I will change the comparison logic a bit, I will return minus one if a is greater than b. So basically, I have changed the ranking mechanism, the element with lower value is now ranked higher, and will go towards the end of the array. This is what I'm getting upon running the program. The array is now sorted in decreasing order of the value of integers. This is a really good design because now our sort function can sort a list of integers based on any ranking mechanism, we can have one callback function for each ranking mechanism. I will take one more example. Let's say we have a list of integers with both positive and negative values in it, I have modified a here a now has both positive and negative values, this time I want to sort this array in increasing order of the absolute value of integers. So the negative sign will not matter, we will just take a mod and then compare this array upon sorting should rearrange like this. To be able to sort I will have to write a comparison function. Last time, we had modified the same compare function, but actually we should be writing one comparison function for each sorting scenario. So I will write a new function this time, I will write a function named named absolute compare. I have included a reference to math dot h library and I will use a BS function from this library that will give me absolute value of an integer. If absolute value of a is greater than absolute value of b, then it's ranked higher, I should return one else I should return minus one. Let's now use this function to solve This array, I have a minus spell error here. Okay, instead of passing this compare function, I will now pass absolute compare in this call to bubblesort. This basically is passing a pointer to absolute compare function. Let's now run this program and see what happens. This is what I'm getting the elements are sorted in increasing order of their absolute values. The bubble sort function here can take only an array of integers, but we have a library function that can take any array. So it's further generic. This library function is in STD lib dot h library. And it's named q SOT q SOT for quicksort and to this function you should pass an array and it can be any array it can be an array of integers or it can be an array of characters or even a complex data type or structured first argument will be the array second argument will be number of elements in array, third argument will be the size of the data type. So if this is an array of integers, I need to pass size of int, size of data type in bytes size of function gifts, size of any data type in bytes. last argument should be a function pointer a pointer to compare comparison function signature of the comparison function should be like this, it should take two constant void pointers as argument and return an integer. Why word pointers? What pointers are generic pointers, we can typecast them to a pointer of any data type. And this is the specification of Q sort function, it should be passed a pointer to such a function, so it will be able to call it back. Let's write the comparison function. You can think of this as a reference of first element passed as a void pointer to get the element. If it's a list of integers, I'll first have to typecast the void pointer to int pointer. And then I'll have to use the Asterix operator to dereference and get the value, we will do the same to get the value of second element, this function must return any positive integer, if A is ranked higher, a negative integer if A is ranked lower, and zero if both are ranked same, we can simply return A minus B and it will mean the same. If A is higher in value, A minus B will be positive. And I'm trying to create a simple comparison function here that would rank and integer with higher value as high. So basically this comparison function can be used to sort the array in increasing order of value of integers. So, like I said, returning positive value means a is ranked higher returning negative value means B is ranked higher with this comparison function, if I would simply pass this to Q sort and after the call to cusat print the value in this array, this is what I will get as you can see the list is sorted in increasing order of the value of integers. If I will change this comparison function to return b minus a. So element with lesser value integer with lesser value will be ranked higher, the list will be sorted in decreasing order of the value of integers. And if I will use abstract absolute value of A minus absolute value of b, this is what I will get. Remember, in this comparison function, the two elements to be compared are being passed through reference, their addresses are being passed through a pointer. The const keyword here means you cannot modify the address in this pointer variable. We are having to use void pointer because of generic design of Q sort function. Remember q SOT can sort any array, not just an integer array, it's just that you will have to give the comparison logic. Okay, so we just discussed one of the use cases of function pointers. This whole idea of callback is used in a lot of interesting design scenarios. One more thing where this concept of callback makes our life easier is something called event handling. If you are curious, you can check the description of this video for some resources on event handling. This is it for this lesson. Thanks for watching. In our previous lessons, we have learned the concept of dynamic memory allocation we have understood what is stack and what is heap in applications memory. Now in this lesson we are going to talk about one situation which is caused by improper use of dynamic memory or the memory on the heap and this situation is memory leak. A quick recap of some of the concepts that we have discussed in our previous lessons. The memory that is allocated for the execution of an of a program or what we can also Call applications memory is typically divided into these four segments or these four sections. One section stores the instructions in the program that need to be executed. This section is called the code segment or the text segment. Another section is used to store the global variables the variables that are not declared inside functions and have lifetime of the whole application. Another section of the memory is used to execute the function calls and store all the local variables this section is called stack. The size of these three segments that code segment the global variable segment and the stack segment are fixed and decided when the program is compiling. That is at the compile time. And the fourth section, which is called heap, or dynamic memory does not have a fixed size, heap can grow as per need. As we know, we get memory from the heap by making a call to malloc function in C. And when we are done using that memory on the heap, we make a call to the free function to deallocate or free that particular memory. In c++ apart from malloc. And free, we can also use the operator new to get some memory and the operator Delete to free that memory. memory leak is a situation when we get some memory on the heap, and do not free it when we are done using it. So our application is actually holding on to some unused memory on the heap. But why do we call this situation memory leak? And why does it happen due to improper use of dynamic memory only due to improper use of heap only and not some other sections of applications memory, we will try to understand this through one simple program. So what I'll do is, I'll write one simple program and show the simulation of its execution in the memory. To explain these concepts. In my C program here I'm going to write a very simple betting game. And the game is that we have three positions and three cards, jack, queen and king. Initially jack is at the first position key queen is at the second position, and King is at the third position. And then computer shuffles these cards so that the positions of these cards is changed is randomized. And now the player has to guess the position of the queen, he has to bet some amount of money. Let's say it's virtual cash. And if he wins if he predicts the position, if he guesses the position of Queen correctly, he takes away three times the amount that he had back. And if he loses, he simply loses the bet amount. Let's say the player initially has $100 of virtual cash, and he can play as many times as he wants until he runs out of cash. So let us now implement this game. The first thing that I want to do is I want to declare a global variable named cash that at any point will store the virtual cash available with the player initially he has $100 of virtual cash. And then in the main method, I will declare a variable named bet. And I will write code something like this. While cash is greater than zero, while player still has some cash, we will ask him to bet something and we will take this input in this variable bet using scanf. For negative scenarios like bet equals zero or bad being greater than the cash available, let's say we will break out of this loop we will end our game for all of the conditions let's say we will make a call to play function. And of course, now we will have to write the play function we will be passing bet to the play function. So that will be an argument. And now in the play function I will declare a character array of size three. And initially, we will have the character j at the first position to say that there is a jack at the first position J is for jack and similarly Q is for Queen and k is working. And now the computer must perform a randomized shuffling. So we will write a print statement like this. Now we need to find a logic to make a random shuffle of cards. One such logic is that we can make a call to random number generator function in C to use the random number generator. First, we will make a call to s RAND function and pass it an argument something like this. I'll come back to what I'm doing here in a strand by making a call to a strand. Now let's say we run a loop five times and we will choose any two random positions among 01 and two and swap the letter said these positions in the array. Let's say these positions are x and y. Now when we make a call to RAND function, we will get a random number but we want a number between Zero and two, zero and two included. So we will take a modulo by three so that we either get zero or one or two. So we will take two such random positions with statements like this. And now, what we can do is we can swap the characters at these positions. So we will use a temporary variable First, we will store the character at position x in temp, and then we will do something like this. I'm short of space here. So I'm writing three statements in the same line. Okay, so now the swapping is done. So we are swapping or shuffling characters or two positions, five times each time, we are picking up two positions x and y are randomly by making call to RAND function and taking a module by three. So this will guarantee us that x and y is between zero and two. That will be valid positions by making a call to RAND function, we will get the random numbers but we also use this s Rand once and pass this time null, the return of time function in random number generation, there is something there is one concept of seeding the random number generators, so we are passing seed to random number generator, we will not go into the details of random number generation now. Now what I'll do in the proof play function is I'll have a variable named players guess. And I'll ask the player to guess the position of Queen and then I will use scanf to take the input. Now if the player is correct, then the character at that particular position in the character or a C, and the position will be one minus what the player inputs, because the player is inputting one, two or three that will map to 01 and two in the array. So if the character is Queen, he has one. So his overall cash will be incremented by three times the amount else he has lost, lost, and his cache will be decremented by the bet amount. So in the case of when we will write a print statement like this, we will say that you have one and the result is this and your total cash, right now is this. Remember, cash is a global variable. And we will print something similar if the player loses. Finally, our play function is looking something like this. And we have also moved this variable cash at the top. In the main method, I've added two more print statements initially. Let's now play this game and see what happens. What I have done is I have compiled this code and created an executable named game dot txt. And now I'm going to run that executable. So this is asking, what's your bet. Let's say we want to bet $5 on position one, and I lose my balance now is $95. Let's bet again, this time again, I lose. And I can go on playing some losing again and again. Finally, a win after long time, I can go on playing this game, but I want to show you something else, I have opened the task manager of Windows. And here. As you can see, this highlighted row is for game dot e xe. The third column here is the memory consumed by this executable game dot e xe you will have to see this in full screen. Now as I go on playing the memory consumption here, the memory that showing you is not increasing, it's always 340 8k. Now I'll go ahead and make some changes in my code. What I'll do here is this particular character array that I'm creating as a local variable in the play function. Right now it's created as a local variable, so it will go on the stack. Now I want to create a character array on the heap. So what I'll do is, I'll write a statement like this, I'll declare a character pointer named C and then I'll use malloc. To fetch memory to store three character variables. In c++, we could have said something like this, we could have used the new operator. And now I'll set a value at z zero at index as j, one at index Sq and two at index as K. So we have created an array on the heap and c is a pointer to the base address of that array C is still a local variable, but now it is a pointer to character and we can still use it like array. The rest of the code will just work fine. Let us run this code and see what happens. I have opened the task manager and I'm running the executable. Watch for the memory consumption of game dot txt. I will make some bets as you You can see right now the memory consumption is 340 8k. I just kept on playing and after some time the memory consumption is 480 8k, it has shot up. And if you will keep playing this game further, after some time it will shoot up again, or maybe after some time, but it will shoot up for sure. So why is it happening, or why was it not shooting up when See, the character array was not on the stack, not on the heap and it was on the stack. Let's try to understand, I have drawn sections of applications memory here. And let us now see what really happens in the memory when we are playing our game. As we know from our previous lessons, all the information about function call execution goes into the stack section of the memory. Anytime a function is called some amount of memory from the stack is allocated for its execution when the program starts executing. First, the main method is invoked or called. So let's say some amount of memory is allocated for the execution of Maine. This is what we call the stack frame of a function. So this is stack frame of Maine and all the local variables of Maine will sit inside this stack frame in our code we had a local variable named bet, so it will go here and we had a global variable named cache. So initially, let's say main function is executing when we play our game main function makes multiple calls to play function. And what really happens when a function makes call to another function is that that particular function is paused and memory is allocated for the execution of the called function. So main will pause and play will start executing and play will go on top of main in the stack. Now, we had a couple of local variables in play all will go in this stack frame i x y players guess and for the case one when we had the character array C on the stack itself, so it was not created using a call to malloc the character array C will also sit in this stack frame. Now when the execution of play function will finish control will return back to main and the memory that was allocated for the execution of play function will be reclaimed. Anytime a function call finishes, the memory that it is allocated on the stack is reclaimed. So there is one stack frame corresponding to each call. And as soon as that call finishes, that memory is claimed back. Now main will make another call to play because we will play multiple rounds. So play will again come into the stack and it will be cleared again when play finishes. As you can see, all the local variables get cleared each time the function call finishes. For anything on the stack, we do not have to worry about its deallocation it happens automatically when the function call finishes. Now let's talk about the second case when character array is created on the heap using a call to malloc function. Once again we will make multiple calls to play function. Now, what will happen this time is that we will not create the array on the stack, we will still have a variable named c a local variable named c but this variable will not be of type character array of size three, this variable will be of type pointer to character and we will make a call to malloc function to create the array on the heap and this local variable which is a pointer to character will only point to this particular memory block anything that is on the heap has to be accessed through a pointer variable. So here we have created the array on the heap and we have kept only a pointer variable on the stack. Now when the call to play function will finish the memory allocated for the execution of call to play function will be reclaimed. So all the local variables will go away. But this memory on the heap will lie unused and unreferenced and it will not get d allocated anything on the heap has to be explicitly D allocated by making a call to free function or by using delete operator and think about it we will make multiple calls to play function as we play multiple rounds of our game. And each time in each call to play we will create one such memory block on the heap that will lie unreferenced and unused when call to play function will finish. If we will play our game 100 rounds then we will have hundreds such unreferenced and unused memory blocks of three characters and the heap. heap is not fixed in size. And our application can claim can get more memory in the heap section as long as our system itself is not running out of memory. And if we are not D allocating this unused memory on the heap via depleting and wasting memory which is an important resource. Our applications memory consumption will only keep on growing with time. memory leaks are really nasty bugs to have in your program. Anything unused and unreferenced on the heap is garbage. In C or c++ we have to make sure as programmers that garbage is not created on the heap memory leak is nothing but growth of garbage in the heap. in languages like Java and C sharp garbage is automatically cleared From the heap, so a programmer does not have to worry about freeing or D allocating the memory on heap, which is a cool feature to have. It avoids memory leak. In this example, we were creating an array of three characters on the heap. What if we were creating an array of 10,000 characters and not freeing freeing the memory after we were done using it, at the end of the function, the memory consumption would have shot up like anything. Coming back to my code here, what I have done is, I have created a character array of size 10,000 of 10,000 characters here, my logic would not change, I'll just use first three positions in the array. I'm just trying to show you something. And at the end of this particular function, when we are done using this array on the heap, we are making a call to the free function, passing it the address of this memory block this array see, our program will just work like before. But let's run this and monitor the memory consumption once again. Once again, I'm showing you the task manager and I'm playing the game. Let's make some bets. Now watch out the memory consumption of game dot txt. For howsoever Long You will play the game, the memory consumption will shoot up. As you can see, it's 350 6k. And it's not shooting up for me even after playing for a long time. And it is not shooting up because we had used free to D allocate the memory when we were done using it at the end of the function. Remember, we had created an array of size 10,000. And if we were not using free then the memory would have shot up like anything the memory consumption would have shot up like anything. But because we are freeing at the end of the function, it's not going up there is no memory leak. So finally, to summarize it, memory leak is improper use of dynamic memory or the heap section of memory that causes the memory consumption of our program to increase over a period of time. Remember, memory leak always happens because of unused and unreferenced memory blocks in the heap. Anything on the stack is de allocated automatically and stack is always fixed in size. At the most we can have an overflow in stack. So this was memory leak in C c++. Thanks for watching.