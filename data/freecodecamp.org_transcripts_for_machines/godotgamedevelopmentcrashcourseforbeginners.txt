Welcome to this engaging crash course on creating your own platformer game with Godot 4.0. Omar Zaki created this course. This beginnerfriendly course is perfect for those who are new to game development and want to learn the ins and outs of the Godot game engine. Throughout the course, you'll learn everything from setting up your first 2D scene and animating the player to designing enemies and incorporating UI elements and implementing gamesaving features. By the end of this adventure, you'll have a solid foundation in Godot 4.0 and the skills to create your very own captivating platformer game. Welcome everyone to this course. In this course, you'll be learning a variety of different topics including animating the player, the parallax background. We're going to be going through saving and loading. We're going to also be able to create a very simple but nice AI mob that's going to have nice control on it. And then lastly, we're going to have collectibles. And as a bonus, which actually it's a bonus in the beginning, we'll be going through tile maps and how to set up a tile set. In our animated player, we'll be going through a few different topics. So we'll have animating sprite, we'll have an animation player, and we'll be going through physics. Simple physics. In the parallax background, we will be doing parallax mirroring and we'll be discussing how to actually properly do that. In the saving and loading, we are going to be using a very nice Godot builtin function, which is going to allow us to access files. And then through that, we're going to be also creating JSON files with it through dictionary. So we're going to be discussing dictionaries as well as how to convert that into a JSON file. And for this simple mob AI, we're going to be going through area 2b. This is a very powerful tool in Godot that I would very much suggest you learn very quickly. It's very, very useful for a variety of different things as you will see as we kind of go along in the course. And lastly, collectibles. We're going to be going through timers, which is just a simple timer. And then lastly, we have tweet. tweet is a very simple way to animate things in Godot. And I'll be going through a few ways to do that, and it'll be very fun. So stay tuned for that and it'll be really exciting. Okay, so the first thing we're going to want to do is obviously download the actual engine, right? And so Godot is actually very unique compared to other engines where the download process is actually very, very simple and very quick. So all we're going to have to do is download Godot. We're going to have to go to download latest. We're going to go. We are going to use Godot 4. If you're watching this video and you go to four points, something is out, you can download that. It shouldn't be too different. It should be pretty much the same. Now Godot 3.5 and previous versions might be slightly different in the code. So I wouldn't suggest downloading them. I would suggest downloading 4.0 and further. So let's download 4.0. We just click that, download this. We will get a zip file. So let's minimize this and see what we get. Let me close that. So this is the zip file you should get. If we open this up, we will see two things. We will see the let's actually just drag these out and see what we have. So I'm not going to replace this. I'm actually going to skip that because I already have it. So we have Godot 4. This is for the Windows version. And then we also have the console. Now we don't need the console. So we're going to delete that. And now we have the Windows 4 stable. We're just going to launch that. And there you go. That's good for downloaded. As you can see, it was very quick. It took a minute. And that's a lot easier than Unity or Unreal Engine. So the next thing we're going to want to do is actually create a project. So now, as you can see, these are my projects. So if you want to create a project that will always show up here, we have the about, we don't have to worry about that. We have asset library projects. We're not going to worry about this either, but it might be useful for you later on. Maybe once you finish watching this video, essentially, this is a public repository for people who actually use the engine and make their own projects and want to share it with fellow developers. So if you want to actually download your own demo or upload your own demo, that would be here. So there is also a website you can do that, which should be really cool. But this is also built into the Godot engine. So aside from that, we're going to be going to local projects. This is going to be on your actual computers. So we're going to go hit new project. We're going to choose where we want this first. And I'm going to put this in my desktop. So you can choose whatever you want to put it. And let's name this new platformer game. And here, we are going to have to create a folder. So we have the option create folder. It has created a folder on the side, as you can see right above my head. And now we have a few different options. We have forward mobile compatibility. Now, what are these? So forward is essentially for 3D graphics, you can read it. It's basically just for 3D. If you're doing a 3D game, you do forward plus if you're doing a 2D game, you would do mobile. Now it's not only for mobile because it does support desktop, but it is basically just for 2D. And compatibility, I believe is still in kind of beta testing and has a few bugs. And it's but it's basically for 2D as well. So I would suggest we're just going to be using mobile. At the time of this video, if none of these are available, if they change a little bit, just look for the one that's more suited for 2D. But obviously, this is just the renderer. So we're not going to worry too much about it. And for the version control, you can just go click none. And that's it. So now let's create an edit. And it's going to create our project. There we go. And we're left with a complete blank slate. And as you can see, our screen is completely blank. Let me explain. Let's go through a few things. So on the top, we have 2D and 3D. So as you can see, when I click the three, it shows us kind of a 3D plane and we have four or three planes, right? So we have the blue, red and green. And that just signifies that we're in a 3D plane. And if we go to 2D, well, everything kind of becomes 2D. So we also have script. We don't have any scripts, yeah. So they're completely empty. We have asset library. That's essentially the library that we guys saw before. This is things that is it's basically a public repository. It's very useful. But in the moment, we're not going to use it. Okay. Next up is the actual scene. So let's just started with our actual scene. So in order to actually run something, we need a scene. What is it? What is a scene you might ask? Well, a scene is essentially something that we save in our project. So on the left here, we can see that there's a bunch of nodes and things. So what we're going to do is we're just going to click 2D scene. We're going to rename this by doubleclicking. We're going to type main, we're going to click control S, and we're going to save it into our main folder. So this is our main folder, which is res dot slash slash whatever. And there we go. We now have our main scene. Now we can go to the top right. You see a run project or a five. We can click that and we're going to select current. And this will just run our project into main. And so now we've run our first project in good. Awesome. Next up is going to actually be adding things to that scene. So what do we want to do? Well, first of all, we have to plan what we actually want to do, right? So the first thing we're going to do is we're going to actually create a menu screen. So to do that, we're going to add buttons. And when we go into the top left, we have it plus five. What is this? This is an ad child node. So Godot works in nodes. If you don't know what nodes are, they're basically just objects essentially that we can add to our scene and edit things really easily. So on the top here is a 2D node, a 2D node is something that just holds a position and is allowed it allows us to have a 2D thing on our screen. So next up, we're going to just add to this node where we're going to add is we're going to add buttons. So that will be under the control section. If we go to a canvas item, you'll see that we have two things we have control node and control. So these are, this is going to have me most the stuff that we're going to be using. So we have a bunch of cool things that you can look through. We have animated sprite, audio listener, back buffer, bone, we don't have to worry about these ones. CPU particle, that's for particles. Those are very complicated. So we're not going to worry about them too much. We have camera 2D and a bunch of other really cool things. So the first thing we're going to do is we're going to find our button that we want to add. And if you can't find it, like I can't find it right now, we're just going to search it up. So we search a button, and we have a few different options. So the first thing is to look through them. So we have button, check button, color picker button, menu button, option button, link button, and texture button. And of course, my kind of favorite touchscreen button. So this is really good for mobile. So we're not going to touch this. And next up is our button. This is one of my defaults. And now we also have texture button. Texture button is usually used essentially for something. Let's say you've created a texture of a button outside of Godot. Like you have a UI expert who has created a button for you. And you want to use that in your Godot product. This is the node that you would use. But for us in this project, we are going to be using a standard theme button or a button. So let's create this, let's add it. And if we zoom in a little bit, we can see our button and kind of just make it a little bigger and zoom back out. And we can kind of drag it to the middle. And now what we can do is add text to it on the right. So on the right, we can see that there is text and we can just add to it. And we can now see that we can add text and we can have play. So let's add two buttons. So to duplicate it, what we can just do is control D or you can just right click and control duplicate. So this one will be the play button. So let's say, rename that to play, this will be our quit button. So we're going to rename this to quit. And right here, we're just going to drag this down. We're going to type the text as quit on the right. So you can see the text has changed the quit. And if I zoom in, I should be able to see both of them now. So the first thing we're going to do is add a script to the main. So to add a script, as you on the top left above me, you should be able to see it attach a new script. And what we're going to do is we're going to look at these. So we have templates. And essentially, what we want to do is just add the template node default, this is going to basically add a completely new script that has nothing on it. The language at the moment, we only have GD script. If you want more languages, I'm pretty sure you have to export that or import that into Godot. But we're not going to do that, we're just going to be using GD script. And the path that we wanted, you can change that here, if you have more folders, however, we don't have any folders yet. So we're just going to save it in main was created. And now we're going to save. And now we're going to do is we're just going to delete these, we don't need any of those functions. So now all we need is extends node 2D. So let's go to our quit button. And what we'll do is we'll go to the scene and click our quit button. And on the left or on the right, sorry, we have inspector node and history. So inspector essentially allows us to change all the settings of the actual button and how it looks, all those things. So we have layout, we have transform, we're able to change the transform of it, the size, position, scale, rotation, we can rotate it around. I would definitely recommend if you don't understanding this, definitely play around with it. It's really cool to kind of just play around with things and see how it works. We have tool tip, this is actually kind of cool. If you hover it, it'll perfectly explain it. It's essentially when I hover it, it'll give me something. So let's type in this is quit button. Now, if I play this, and I hover it, it'll give me a tool tip, it'll say what this is, this is the quit button. So we don't want that in our game. So we're just going to remove that, but it is very useful for other various things, right? We have focus, a bunch of other things that you might not understand, but that's okay. So for now, just kind of play around with things that you might understand. And let's move on. So the next thing we're going to do is go to node. And now in here, we have signals and groups. So groups, we're not going to use. However, there are good videos on it, I would definitely recommend learning it. It is a very powerful tool in good. So aside from that, we're going to we have signals. That's what we're going to be focusing on and using. So signals are essentially, when I click the button, I want something to happen. If I want something to happen, I have to send a signal. So I have to send the signal from this button to the script. So how do I do that? Well, I do that here. So how do I actually do that though, in here? So what I can do is I basically look through all these signals and look for something. So this will tell me this will send a signal when the button is pressed, this will send a signal when the button is goes down, this will send me a signal when the button goes up, etc. So there's a bunch of different things that are in here that are very useful. So the first thing we're going to do or we want is pressed. So we want to check if the button is pressed. To do that, we do is double click it, we double click pressed, this will pop up. And now we can just connect it to our main script. So we just we don't have to show you anything, we just press connect. And now in here, we now have a function that goes from quit to script. So in here, what we'll do is we'll actually program the quit function. So to do that, we're just going to say get tree dot quit. And now all we have to do is play and test it. Awesome, we now have a quit button that works. So every time I play and I quit, click the quit button, it will now quit our game. So that is how we create a super simple quit button. All we have to do is get tree, this is will essentially get the entire tree and then quit. So actually explain that a little bit better. So when we play our game, we have on the left, we have remote or local and remote. So local are the things that I'm locally changing, I'm changing in here, right? When I play the game, remote is like the actual thing that is happening in the game, right? So here's our main function that we have. And if I have something else, it'll also be in here. So root is the root of the entire game that I have. Now above this, that what it doesn't show is tree, it's not really above it, but it's more so everything. So the this entire thing is tree. So what we're doing in our script is we're getting the tree, and this entire thing, and then we're going to quit, right? So that's how we essentially use quit the game. Awesome. Next up is play, we want to actually have a play button. So to do that, we're going to have to create another scene. So here on the left, right next to my head, you should be able to see main dot scene. Now we want another scene that will be our world. So this is going to be our world. So we're going to save it as world, we're going to save it, we're going to save it here. And now next to my head, you should be able to see world. So we're going to basically take our play, we're going to connect it to our main, and we're going to go to world. Now I want you to try connecting the signal into your main function, and pause the video. So pause the video, try that. And if it doesn't work on pause the video, and I will now do it. So let's do it. So let's go to press, let's go to the node signal pressed, and let's connect it to our main. So in here, we now have our play press button or function, or a signal. Sorry. Now, what do we want to do? We want to change the scene. So how do we do that? Well, there's a function where we can just say get tree, let's say get tree, and then we will say change scene, then to file or to packed. Now there's two different options, which one we're going to do, we're going to do to file to practice something different that we don't usually use. So we're going to do to file. And we're going to go to the world scene. So essentially, what we're doing is we're getting the tree, and we're just going to change our scene, which is the main into the file world, right? So we can see our world here. And another way to change this, just a quick tip, if you wanted to change this, maybe you chose the wrong thing, what you can do is highlight it, or just delete it. And we can select the actual thing that we want, like world, and we're just dragging it in. Or a third option is copy path, and copy paste it, as you can see, that's the path of the world's file. So now what we can do is we can, let's actually just be able to differentiate this by going to our world. And what we'll do is we'll add a node, we'll just add the label. So what a label is, is it's just text, it's basically just a label that actually adds, adds text to our screen. So we'll say this is the world. And then we'll save this, we'll play. And now what we can do is press play. And now we change to this is the world. So we've changed our scene to the world scene. Awesome. All right. So the next thing we're going to want to do is download this asset pack. This is going to be the art that we use for our game. So the first thing we're going to do is click download. You don't have to pay, you can say no thanks, take me to the downloads. And we're going to download all four of these. Once you click download, it'll prop you to take download it to a location, download it to wherever you want. And then we can close that tab. And as you can see here, I've exported all the files that we need. You can do that very fast by just selecting all the files, right clicking and compress or sorry, extract each hard drive to separate folder. And then from there, what we're going to do is select all four of these files, open up the project that we have, and we're just going to take all of them and drag them in. So once you've dragged them in, as you can see, I've already done that here. They're my four files. And once you've done that, that's it. Now all we need to do is make sure that the pixelation is proper. So in order to do that, here, we can see the pixelation is proper for the good deal icon. However, for you might not be look like that. So to fix that in our project settings, what we're going to do is we're going to go to filter settings, and then we're going to search up texture. And then we'll be prompted to rendering textures when on select the filter setting. But now we have textures selected here in the default textures filter, you can see mine is nearest. However, the default is linear. So we're going to want to change that to nearest or you're going to want to do that. All right. And now let's close that. And now we can see that it's pixelated for you, at least. And if you're not, if it's not, we can actually look at the texture in each node, each node will have its filter set to inherit. Inherent means we're just going to take the project settings, which we just set. However, I can change it to linear or nearest or whatever you want. However, I'm just going to keep it as inherent or I'm just going to leave this node because we don't need it. Next up, we're going to delete the label because we no longer need that. Instead, what we're going to do is we're going to get started on our player and background. So the first thing we're going to do is we're going to create our player first. So in order to do that, we have to make a character body 2D. So we're going to have this as a separate scene. The reason is because it's going to inherit this scene. And I'll explain that just in a second. So first, let's create a new folder for this guy and call it player. And then let's save it as player. So rename the node to player dot scene. So if you're wondering what TSCM stands for, it just means it's a scene. Next up, we're going to add actually, let's not add the script just yet. Let's look at this error. What does this error say? Consider adding a collision shape 2D or collision polygon 2D as a child to define its shape. This node has no shape as it can't collide or interact with other players or things. So that is true. We now have to add a collision shape. Here, you can read this error as well. It's basically just saying we haven't given it a shape. So now we have a character body 2D and its shape. So here, we can actually define the shape. We'll give it a capsule. We can zoom in and look at the capsule. So let's now add our sprite. So let's take a look at our files and look for our player should be in here. We'll look under PNG. Going to go to sprites. We can find player. And there we go. Now we have a player. And here we can see that we have a bunch of sprites. So here, now what we can do is take is find animated sprite 2D. We'll basically add a animated sprite. And we're going to sprite go to sprite frames and make a new sprite. All right. So from here, what animation 2D or animated sprite allows us to do is basically organize all this. There's a different way to do this. However, we're going to be getting into that in a bit. So the first thing we're going to do is add all the animations we need. We're not going to use all of them. We're just going to use idle. Run. And for now, those are the three that we're going to use. So for idle, all we should be able to do, I believe, is just drag this in and drag and drop it. So select all of them and drag and drop and jump. What we can do is just take all these and drag it in. So now we have up and down. And next, we'll go to run, drag all these and pop them in. The next thing we want to make sure that we're looking at, or one tip real quick is if you were sprites or sprite sheet like this, what we can do, so we have a sprite run, what we can do instead, here, let's make a new run animation, or we'll do crouch. So let's look at, let's say this is crouch. So if you have a sprite sheet instead of separate files, what you can do is go over here to this add frame from sprite sheet, select it and find the, nope, that's the house. We want to find the file that we're looking for. So then we'll click PNG, sprite sheets. And now what we can do is, let's actually do the hurt though, because we might actually use this later on. So let's look zoom in by control zooming. And now what we can do is actually just this on the top left, we have horizontal and vertical. So for our vertical, we only have one, right, for the horizontal, we have two. So now we can select both the frames and add those two frames. And now we can see here, there's our hurt. So it's actually changed this name to hurt, or we'll actually change this to death. So that will be our death animation. Okay, next up, we're going to actually take a look at animating these. So to do this very quickly and simply, we want to first actually make sure our player can do stuffs and move, right? So let's go to our player, rename it player, go to script, we're going to add a script, we're going to use the template that Godot actually gives us. This is a new addition to go to four. So it's very useful. So let's just create it, we're not going to do built in. If you do built in, the file will not save here, it will just be built into the actual node, which we don't want we want the path to be able to edit it later on. And look it up. So let's not have built in, we're going to use the template and all this create. And now what we should have is a nice default template for our code. And now what we can do is go to our world, we can add our player by actually finding our player. So let's find our player, drag him in. And there we go, we now have our player. Now what we want to do is actually add floor. So to do that, we're going to add a static body, a static body is a physics, physics body for 2D physics, which is static or moves only by script. So this is useful generally for two things, either, you know, a floor or use for four walls or and floors, or a platform that you might want to move yourself using code. So those are pretty useful things to use for this static body. And again, we have to add a collision shape for it. And for this one, it's actually very easy to create what we can do is just drag the collision shape out. And that is our collision for the player. So we can now just save this as our floor. What we can do though for the wall is we can just duplicate this by saying control D. We can control the collision shape. And well, now what we have to do is make sure we actually make it unique. Why? Because what happens if I control D, if I duplicate it, if I edit this one, it actually edits the original one as well. So in order to change this or fix this, we're going to go to the shape on the top right and make it unique. So now when I edit this, it won't edit the first one. So now what we can do is duplicate this one and drag it over here. And that's our wall. All right, let's now also add a panel. A panel is basically just a block of sprite essentially. It's just a block panel that we can actually draw with. This isn't a good way to actually make a floor. We're going to add a legitimate floor later on. But for now, this will act as our visible floor. So now when I play, we can go play. And here's our character is showing their hurt animation. But that's okay. But now we can walk and run or walk, stop, idle and jump. Awesome. And we didn't do anything. We didn't even look at the code. But now what we can do is go back to the player code and take a look at it. So let's go through this and understand a little bit. So first, we're setting a few variables. We have speed, jump velocity, and gravity. Gravity is essentially just the gravity default that the project is using. The jump speed is negative 400, or jump velocity, sorry, and speed is 300. Now let's take a look at the actual code as to what is happening. So physics process is a function that is essentially called every physics second. So it's called, I believe it's like six or six hundred or six thousand times a second, something like that. It's a lot. So it's being called quite a bit. And next, so it is passing through delta. So if not is on floor, we're going to do this. So what does this mean? If not on is on floor, meaning if we're in the air. So if we're in the air, we're going to actually add velocity, right? So we're going to add velocity to the y direction. We're going to add it as gravity times delta. So essentially, we're just making the player get pulled down if we're jumping, or if we're in the air, right? If we're not on the floor, we're going to pull them down to the ground. Next up is when I see if we're jumping or if we were asking the player to jump. So this is going to check the input. So input is action just pressed UI, except this is a default input that we'll actually edit later on. But that's okay for now, we'll leave it at that and is on floor. So we can only jump if we're on the floor. And then we jump, right? So this is how we jump by making the velocity equal to negative 400. And this will just essentially make it negative 400. And then we're going to get pulled back down, right? Okay, next up is the direction. So what is direction? This is essentially going to look for our direction in the x in the axis. So get access input dot get access is just going to check which two keys are being pressed. If UI right, sorry, if UI right is being pressed, we're going to have direction is equal to one. If UI left is being pressed, it's going to be equal to negative one. If it's neither, it's going to be equal to zero. So if direction, meaning we have something, then velocity dot x is going to be equal to direction times speed. So this is going to be actually moving us. Otherwise, we're going to be moving our velocity dot x or current velocity to zero times speed, or using the speed acceleration essentially. This is basically going from whatever number we're at. So let's say like 400 to zero in the speed amount of time. And then next up is our function movement slide. This is a built in function that Godot has that allows us to move and actually slide along our floor. So now let's animate. So let's actually take a look at how we can do that. The way we can do that is by, let's see, let's add a ready function. So to do that, we can say funk ready and let Godot complete our sentence for us. And then we can say get node animated sprite dot play idle. And we're going to play our idle animation. So make sure that it's it is spelled correctly because it is also case capital. So if this was not case capital, it would not work. It'll give you an error and it'll tell you to fix it. So let's play and see what happens. So that is my idle animation. There we go. However, when I move, it doesn't do anything. So let's fix that. So now what we want to do, there's a few things we're going to actually do real quick. Instead of get note here, what we're going to do is we're going to set our node outside a function. So we can access this node everywhere. However, that's not going to work because let's fix this error first. So that's not going to work because when I tried to access a node outside of a function, this isn't really going to work because we want to essentially access it on runtime. So what we have to do is say on ready variable animation, and that'll fix it. So now we can access that animation node, right, which is this node in a ready function or anywhere else. So now what we can do is say, let's say in the direction, we can say anim dot play. Was it run? Believe it was run. Let's double check what we wrote in our animation, sprite frames yet run. So we're going to play the run animation if we are running. So otherwise, what we'll actually do is look here and we'll say idle. So if we're actually moving, we'll play run. If we're not moving, then we'll play idle. So now let's look at what we have. So let's play. So we're not moving. So we're playing idle. Now let's start walking. And as you can see, our player is starting to run. However, there's a few different issues. Now the first issue is going to be the actual animation. And you might think, okay, now what I can do is say, okay, what I can just say, anim play and jump. Right. And now when I jump, it'll actually animate my jump. Right. So when I play, you play, it'll the jump. However, it's not. Why? Because what's happening is it's going, the physics process does not care what this animation is currently doing. When I call this function play, it doesn't matter if it's playing something else. It's not going to finish that animation. It's just going to play it right away. Right. So what's happening is we're playing this animation. Right. We've checked that we clicked jump. We're going to play it. However, what's happening is we're going to keep going down the code. We're going to see that the direction is either true or not. If it's not, that means we're going to play idle. If it is, when we play run. Now, one of these two is essentially going to override this. So there's actually a better way to essentially animate things in Godot. So what we're going to do is we're going to delete all this. And we're going to delete this too. We're going to keep this on ready function. And we're going to go back to our 2D sprite. And we're going to do two things first. So the first thing is we're going to actually add a camera 2D, because our game is actually really, really big. So there's a few different things we can actually change the window. So the window is really big at the moment. It's kind of the default. There's a few different things we can do. We can go to the project settings, we can go to window display, and we can change the viewport width and height. However, this isn't going to actually change the legitimate screen, because this is just going to change here. Let's actually test it and see what happens. So if I divide both by two, it's going to essentially divide the actual screen. So here we can see the, if we go back to world, we can see the blue marker, that is our actual screen. So it's moved, right? It's gone smaller. However, when I play, it now looks like this. So our window is a lot smaller. So we're not going to be doing that, we're going to reset these. What we're going to do instead, we're going to go to our player, we're going to take our camera, we're going to enable it, and we're going to zoom in. So we're going to zoom in, maybe at like 1.6. And if you want to separate these two, you can actually click the keychain guy, and that'll unlock these two. So they're no longer linked, but I want them both to be linked. So we're going to just link it like that. All right, next up, make sure that it's enabled, and let's play and see what we have. So let's play. And now our player is looking a lot smaller, or it's actually zoomed in, and we can see our player, clearly now. Okay, so the next thing we're going to do is we're going to actually use animation tree and animation player. So in good dough, we have a few different things to animate things, whether it's animated sprite, animation player, and animation tree. Now animation player is a very good tool that most people use, and animation tree is a much more powerful tool that I like to use. So we're going to be going through both of them. For now, we're going to be using animation player first, and then we'll kind of transition to animation tree and see how that works. So the first thing we're going to want to do is go to animation, create an animation for each one. So we'll go idle, run, jump, we'll add the depth one as well. Okay, so from here, what we can do is we can actually, there's a few different things we can options we have. So the first option is we can find our player. And as you can see, when we try, so let's say we're when the idle, so let's try going idle. And if I try dragging this in, nothing's going to happen, right? I can't drag this into our animation player like I did in the animation sprite. However, because the way the animation player works is essentially the animation player allows us to take a key or a property of something and change it over time. So what this means is if I'm in my animation, I can change the camera zoom. So if I go to zoom, I can animate the zoom, I can key this, and then change it to another position on over one second, right? So what we generally would do is take the sprite and animate it that way, right? So a good way to generally do this is have a big sprite sheet and just do it in that one eye that once sheet. However, we don't have that we do have a few sheets, but that's still too many. So what we'll do instead is we'll use the animated sprite to actually do this. So the way we do this is actually a bit freaky and good. What we have to do is select the animated sprite. We have to go to animation. And now we will see the key. Now if you don't do this, what would happen is if you try to select the animated sprites and go here, it might be a bit tricky to actually select the animation. So you have to select the animate the animation itself from using the tab on the bottom, not the animation player. A lot of people will generally take the player and then select the animation player to edit it, right? So when I select the animation player on the node, I can now see the keys I can edit. However, if I try to do that with the animated sprite, it won't work because it's going to change the node that is selected to animation player. So what we need to do is make sure the sprite frames is open down here and then move to the animation player, the animation, right? So now what we can do is go to animation, select idle, go back to animation, and then key that. So we're going to key this. We don't have to create reset track. So now we've changed the animation to idle. Now what we can do is we can zoom in a little bit. We can take our frame here, zoom in a little bit, we'll go to, yeah, we'll leave it at point one, we'll go up a frame, and we're basically going to manually animate this by going up a frame. And that's it. So we've, we've put all the frames in there. Okay, so now what we have is the animation playing idle. So let's test this. Let's actually click this key auto play on load. This will automatically start playing idle. And we're going to want to loop this. And then we're also going to make the time 0.4. So it's going to go from 0 to 0.4 and then loop. So let's play and see what we have. All right, we now have our animation playing idle. So we can still move and everything plays idle. So it's working pretty nice. So now let's do that same thing for jump, or sorry, not jump, run, let's do that for run. So let's make sure we select our animated sprite. We go to jump or run, and then animation. And we're going to key the animation. I'm going to key the frame. I'm going to go to 0.1, make sure this frame next frame is selected. Again, next frame, next frame. And again, you have to do this manually and essentially select each frame manually. All right, from there, we're going to change this to 0.55. So we're going to go from 0 to 0.55, loop this. And then for the jump, what we're going to do is actually we're going to add another animation and call this fall. All right, from the jump animation, what we'll do is we'll take the animated sprite, we'll go from jump back to animation, more time, we have to key this, then we have to key the first frame, and then we'll go to fall, key the jump, because that jump frame is there, we're going to go to frame one, key that, and that's it. So that's our fall animation, essentially. Okay, now that we have everything set up, we have idle frames, all that, we can now access all the animations through through code. Right, so the way we can do that is say, instead of anim here, what we can do is say, on ready anim, actually, we'll just remove this item, we don't need the animated sprite anymore. So instead, what we can do is say, animation layer, so we're going to auto load the animation player and not the animation sprite, the animation player is accessing the sprite, so we no longer need it. So now what we can do, we're going to do the exact same thing, if in direction, we're going to say, anim.play, run, and make sure that it's selected, it's written properly. So we have run. So now we play item by default, and then we can start running. Awesome. Okay, now that we've run, we went now want to do the other animations again. So it's the same thing as animated sprite, but now we're going to just add it all in. So here, this is going to be idle. And then again, this is going to be jump. So let's copy paste that and just put jump. But now when we play, obviously, we still have the same problem as before. So when I play, it doesn't show the jump, etc, etc. And I don't change directions. Okay, so let's do the jump and all that stuff first. So let's think a little bit. What are we actually doing when we jump? Well, we're changing the velocity dot y, right? When I move right and left, I'm only changing the x axis, right, the x velocity. But when I jump, I'm changing the y axis of the velocity. So now what we can do is essentially check to see if the velocity dot y is zero or not. If it's zero, that essentially means I'm not in the air. That also means I'm not I'm on the floor, right? So what I can do is say if velocity dot y is equal to zero, then we can run. Alternatively, you can do not equals zero something something else, but I'm just going to do is equal to zero. So now we'll do this for the idle and the run. So now, leave that should be it. So now what we should be able to do is check to see what we have. There we go. So now I can jump right, stop idle and jump. Okay, now let's actually look at the fall. So in the fall animation, what we can do is do the same idea. However, what's happening with the velocity of y is here, we set it to negative 400. All right, so we basically shoot it up. And then what are we doing? We're adding gravity to it. So we're going to start adding to it. That means we're going to essentially make the velocity greater than zero, right? So here, it's going to be less than zero. And here, it's going to be greater than zero. So what we can do is ask it, if it's greater than zero, what we'll do is we'll play the fall animation. So now when I play, I jump idle and fall, right? So now it's going to see if I'm going down, if I'm starting to go down, it's going to start playing the fall animation, right? Okay, awesome. Next up is going to be looking at the actual sprite. So how do we change the direction? Well, what we can do is basically check for the direction. So let's actually take a look at this. So let's print the direction and see what I get. So sorry, let's actually do this outside of this function. Let's do it right here. So we're always printing it. So let's print this, let's play. So it's printing zero. If I start going to the right, it's going to print one. If I go to the left, it's going to start printing negative one. So what I can do is I can do something with that, right? So I can actually say, let's say, if direction, whoops, we can just, we'll say direction is equal to one, then what we can do, or actually we'll do negative one. We'll say, whoops, get node animated sprite, lip h equals to true. So if you don't know what this does, if we go to our animated sprite, here, we can now see a flip h function or a property that basically allows me to flip it. Okay, so let's go back to our script and add that, right? So now we also have to flip it back, if our direction isn't negative one, right? So we're gonna have to say false, if it's not negative one. However, this is also going to be true if it's zero, right? So if I play, it's always going to start facing to the right now, if that's something you want, you can totally do that, or you can just say, L if direction equals one, then we can just flip it this way, it'll just check for these two conditions, and then it'll just leave it on the other thing. So if I face the left, it'll face the left, if I face the right, it'll leave it on the left, left, etc. Right, so now we have a nice moving animation player. Okay, let's just firstly fix up the collision. So let's change this up a little bit, let's stop the game. Let's go to our player, and let's play our idle going here, we play idle. So let's take our collision shape, and actually try to make it match. So let's turn off the grid. What we can do if you have this issue is we can lock the animation sprite. So let's do that and lock that. And now let's try to change the collision shape a little bit. Okay, there we go. So we now have a nice collision shape for our player. So now when I play, we now have a nice moving player on the floor, that jumps and runs and all that stuff. Awesome, we've now created our player with animations and everything. All right, so the next thing we're going to doing is creating a background. So good actually has a very nice built in system for this. So the first thing we're going to do is creating a new node, we're going to create a terra lacks background, here we go, this one. And then we're going to add era, Lex layers. Okay, so the layer essentially is going to add pictures in each layer. And then it's going to kind of go through that motion. So let's actually just do it. And then I'll explain it after. So the first thing we're going to want to do is look through our sprites and kind of find what we want to use. So the first thing we're going to use is the background, the very, very back. So we're going to use this guy, we're going to set it up and just put it in the back. We're going to save this as BG, we'll save it in the main scene. We'll use this as a parallax layer. So now what we'll do is we'll go there. And now we'll duplicate this and we'll take this guy and we're gonna, we're not gonna actually will delete it. And then what let's look at some other things we can use, let's use this one. But now we can kind of drag this in. And unfortunately, there's only one of these. So what we'll do is we will just duplicate this a few times. So we get like this, kind of move it up a little bit, try to make it a bit nicely. There we go. Okay, and now let's take those two, duplicate those, move it again, and move it. And that is it. Let's duplicate one more time. All right, there we go. Okay, this is going to be a bit awkward, but it should work. Okay, so what we're going to do is we're going to use the motion, we're going to go to motion and mirror. So this is going to be a bit awkward because the background here, parallax layer is going to be at 1152. So we'll go to the xaxis, 1152. And now as you can see, it's been duplicated there. Now, however, for the, for the other one, we're going to want to duplicate it right around there, which will, if we zoom in, it'll be, we can see 1232. So now we can see that it's been duplicated one more time, and it's all the way on the right. So now what we want to do is go to our parallax background, we'll rename this to BG, the entire thing, please, there we go. And we'll add a script. And here, this is actually very simple, not much code, we'll take a variable, we'll add that. And then we're just going to add a function process, delta, and we'll say scroll offset dot x minus equals scrolling speed times delta. So what this is going to do is basically send our offset to the left. So let's play and see what we get. We have to actually add this, let's add it to our main scene. So let's go to background, and let's add it here, and then see what we get one more time. Awesome, we now have a moving background, and it should get duplicated infinitely. So let's wait a second to see how fast, how far it goes. Okay, hopefully you've kind of noticed that it is infinite. So it gets mirrored every whatever pixel that we put, right? So those were the mirrors that we put. And now let's close that. Let's actually move this down a little bit. Let's take all these and just move it down slightly. So it's on the bottom of the screen. Awesome, let's actually make sure we pixelate it properly. There we go. Next up, what we can do is we can change the scale. So the scale, let's actually unlink this, and we'll scale this to what we'll do point seven. So what this is going to do is basically make it go slower than the background. So now we have the front going a bit slower than the back. So now we have a nice little parallax background where this front goes a little slower than the back. And lastly, what we can maybe do is look to add something else. We can maybe look to add plans. What is this? We could add this, but we're not going to, we're just going to delete that. And but you guys got the idea, you can kind of add whatever you want to the background. We can maybe add a house here. Let's duplicate the parallax layer here. It's on the bottom. Let's put this find house here, delete the back. And then we'll put this one actually behind the grass. So we'll have it kind of over here hiding in the back. And what we can do is just duplicate this and kind of put a few in different place spots so that we have a bit of variety. Awesome. Whoops. Let's take these guys and just lock those so I can't move them. I'll take that and move it right there. Awesome. We now have a little bit of variety. So now we have houses in the back and things in the chair in the front. So let's change the houses one more time. Let's name this houses. Let's change the motion on this. Let's make it, we have to unlink this and let's make it 0.5. And let's play one more time and see what we get. Awesome. We now have a few houses that go slightly slower than everything else. In fact, if you don't want to, you can just make this zero and it won't move at all. So if you do that, they just won't move. But it's up to you. You can do whatever you want. And I encourage you to be creative with the parallax background. You know, it has a very nice parallax background and a way to do this. So let's close this. Let's go to our world and let's add our background in there too. In this one, we're going to actually make something slightly different. So what we'll do is we'll put this to the top and we're going to make it local. This what this is going to do is essentially add it to our scene. And now what we're going to do is delete the houses. We don't want those. We're going to delete this and that's it. So now we have our actual background of the sky and everything in our actual scene. So now when I play, this is what we get instead. So now what we can do is look to actually add the ground. So let's delete this ground. And now what we'll do is we'll just add a what is it called? We're going to add a grid map or a tileset. So we're going to search up tiles map. We're going to create this. Let's add it to the top. What we're going to do is we're going to go to the top right. We're going to see tileset. We're going to say new tileset. The tiles will take a look at it a second. But what we'll do is we'll also have to find the tileset we're going to use. So let's use this one. So in sunny land phaser project, we can find this tileset. There should be a few, there's actually a few duplicates. So you're going to have to kind of look for whatever you want. There's a lot of props as well that we can look at. There's layers, which is cool. Sprites, spray sheets. Let's take a look at the spray sheet. No, we don't want that. Okay. So we're going to be using this tileset. Okay. So let's go in here. We can click the tileset and go here, go to the tileset on the bottom. So we want to edit the tileset and not the tile map. And we're just going to drag this tileset in. And that's it. So now what we can do without doing any auto stuff, we can actually go to our tile map. We're going to select the tile that we want. And now what we can do is just draw. A faster way to do this is selecting the rectangle. Now we can kind of zoom out and just draw like this. We can drag and drop like that. That's fine. And then what we can do is just fill in the dirt to go here like that. And now we have a dirt ground, which is actually what we want. Let's make this a little prettier. Okay. And that'll be it for that. So let's lay and see what happens. Well, if you might already realize what happens is nothing. We're going to go through the floor. So what we want to do is actually add physics to the layers. And the way we can do that is by going to the tile map, we'll go to the right side. We'll add element to the physics. Let's go to the tile set. What we're going to do now is we're going to go to paint. We're going to select property. We're going to edit the physics layer. And now what we can do is add a physics layer to each tile map set itself or each tile. So now I click it, that basically added a collision shape to it. And that is the collision shape. You can edit it very uniquely if you want. But we're not going to do that. We're going to keep it as a block. So we're just going to control Z and leave it like that. But if you do have like a slanted slope, you can do that by just doing this right by having a slant. I don't believe we have any of that. Well, we do right there. But we're probably not going to be using that. We have one there as well. But it's up to you. We have one there as well. So that's cool. We can maybe use that later on. Okay, so now let's see what we get. So let's play and see what we got. Awesome. We now collide with the floor. So let's actually go over here. Let's delete the panel and let's fill in our dirt a little bit because you can kind of see the bottom. Awesome. And now what we can also do is I believe we should be able to add walls. So let's actually add a collision to the wall as well. So let's go over to the tile set. And we're still in the paint. So let's just add a collision here. Let's add it to all of them. We can pretty much add it to all of these. And let's go back to our tile map. And now we can add a wall on the side. So if we go to terrain, sorry, we have to go to map, open upper map, and let's draw. So let's actually what we can do is create a long ground, much more dirt under it. And then what we can do is actually add the wall. So let's add a wall that basically shows that we're finished moving. We can't go any further. And let's add some dirt. There we go. And let's do the same on the other side. We can do over here. We'll do like one little wall here. And we shouldn't have to add anything after that, because I'll show you guys how to actually make sure our screen doesn't go off. So here, you can see that I can see from the left. Now, if I want to limit my camera, it's actually very easy. What I can do is go into my player into my camera. And there's a limit section. Now the left, right top is basically this part. So the left is this guy. And the left, I want to set it to zero. The top, I want to set it to zero as well. So this will basically limit it to those two points. So now in my world, when I play, it'll limit it to the top right of that corner. If you want to limit it to the bottom as well, you can totally do that. You can limit it like under here, if you don't want to see the dirt, or if you don't want to draw that dirt, that's totally fine. All right. Now that we have that, let's take a look at some monsters that we can make. So let's create a new node. We're going to make a kinematic body, which is not kinematic character body to change the name. Let's add a collision shape to it. So we don't get that error. And then let's give it a shape. We'll give it a little capsule. Let's zoom in. And let's add a animated sprite. This one is going to be a lot simpler than the actual player. So it's going to be a lot easier. So we can just do an animated sprite and no animation. Hopefully, we'll go through it together and see what we end up with. So let's close all these and look for our frog you guys that we want. So here we have frog jump and frog idle. So let's go to the animated sprite. Let's go in here. Let's have, let's erase all this, say idle. And then let's add no. Let's see what else we have. And this little awesome guy kind of walking. We have a little enemy death. That's awesome. We can probably use that. Okay, let's add the jump in here. We can't do that. We have to actually, now we can use the animated sprite. So let's go here to the add frames. Let's find this guy. So let's actually look up here. So sunny sand files. It'll be in here PNG sprite sheet and frog jump. If I zoom in, it should just be three and one. And I can just select all of them. And let's go to idle. Let's go here and add the idle. This one will be four in one. We can just do that and select all of them. And now we can kind of move this guy up a little bit. Let's turn off the grid snap or grid. And let's move it into the middle like that. Let's save this as frog. We're putting in the main world. Let's save. And now what we can do is also add, let's add the death animation for now as well. So let's add death. Let's load the death animation. So here we have one, two, three, four, five, six, six horizontal and one vertical. Let's select all of them. There we go. And now what we can do is go to our frog, rename it frog and save it as frog. And we're not going to have a, we're not going to have a template this time. Instead, we're going to select the default. What it's going to do is just create this. We'll remove all this. Let's go to 2D. Let's go to our capsule. In fact, actually, let's change this to a square because there's something else I want to do later on. Let's add it like this, just like that. And now what we can do is we're going to add a area 2D. Now what an area 2D is is essentially an area for detection, as well as physics and audio influence. So what we can do here is we can add a collision shape to it. And we can add a circle. And this will essentially act as our player detection, detection. And now what we can do is add a node where we basically say if a body entered connected, we'll do something. So now we can also say if body dot name is equal to player, then we'll do something, then we'll say, rent player. Because what this is going to do is we're going to ask, there's a lot of bodies that generally will enter this area. So if there's another frog that enters the area, that will count as a body. So we don't want to chase another frog, we want to chase the player. So the way we can do that is by checking the name of it. So if we can say dot name is player, make sure it's always case capital or case sensitive. So we can copy paste it just in case, then we'll print player for now. So let's go to our scene, let's go to our world and actually add our frog. So let's go over here, add our frog and let's play. And he's not moving obviously, but let's see what happens. I got to stop printing that thing. Let's stop printing the direction. So we actually see what's happening. Let's try one more time. But now every time I enter him, it says player and obviously, as you can see, we're on top of him. So let's actually add some gravity to him. So we can see here, this is how we add gravity. So let's actually go to that. Let's go over here. Let's add a physics process function and add gravity. So let's add a comment to let's say this gravity or frog. And we have to actually set the gravity. So let's also do that. Let's bring this guy into the frog. So now we can add gravity to the frogs. So now what we can do and check is take a look at our project. And our frog will not fall. Why is that? Let's take a look, velocity plus equals gravity. Okay, so here, I just realized we have to add move and slide for it to actually fall. So let's go to play. And now our frog actually falls to the ground. So because now he actually has gravity. All right, so the next thing we're going to want to do is actually do something when the player enters. So what we can do is essentially look for the player. So the first thing we want to do is go to our 2D and organize this a little bit. So let's add a node, duty. And this will be for the player. Let's add this in so we can actually need that player. And then let's add another node. Let's add a node to duty and say mobs. And we'll basically add frogs to this mobs. And now what we can do is go from the script, and we'll drag in our player. And this is the path to our player. So what we can do here is say, let's say very little player outside. And then inside of here, we'll say player equals this. So that that is the path to the player. Now what we can do or look to do is say player dot position or global position. All right, let's print this and see what we get. Let's say print global position. So now we're going to be able to actually find our player by getting his global position. And we have to actually convert it to a string because this is a vector. So let's play one more time. Or not. Global position dice felt wrong. Okay, so this is actually getting a string. So we need to actually make sure we get the node. That's why. Okay, so we don't actually have to convert it to a string, I don't believe. So let's try this. This play enter and it'll print our position. So what we want to do is actually find the direction in which player the player is in a response to where the player is or where the mob is, right? The way we can do that is basically saying variable direction equals, we're going to take the player direction, player dot position minus self dot position, right? So you don't actually have to say, let me make sure I put that in right position. You don't actually have to say self, but it's nice kind of see that self dot. And then we're going to normalize this by saying dot normalized. And now what we can do is say if direction is greater than zero, we're going to actually only look at the dot x direction. So we'll say dot x is greater than zero. What we'll do is we'll actually see which direction it's in. So if it's greater than zero, that should mean we're on the right. Now, if we're on the other side, we'll say else and say, let's print this and say left. So now what we can do is print this or play and see what we get. So when I do this, I'm on the right. But if I enter from here, I'm on the left. Awesome. So now what we want to do is we want to actually be doing most of this on the other side. Right. So what we can do is basically take all this and add it to the physics process. However, this might not work perfectly because what we want to do is actually, let's make sure we're not indented improperly here. There we go. What we want to be doing is basically chasing only if the player is here. So what we can do is add another variable and call it chase and we'll default it to be false. Right. So now if we enter what we can do is say chase equals true. Now we want to be able to do is say if chase is false, then we'll stop chasing. Right. So now we can say is go to the area to the node and we'll say body exit. And we'll copy paste all this and just say false. If it's if the player left the area, right, and make sure it's indented properly, otherwise we'll get an error. Awesome. And now we'll be what's going to be happening is it's only it's always going to be getting the direction of the player, but it'll only chase if chase is true. So now we can do is say in here, we'll say if chase is true, then we'll actually chase. So let's print chase chase, right. Okay. And to do that, what we can do is actually very simple. We'll just change the velocity of the actual rock. So to do that, we can just say velocity dot x equals direction dot x times speed. So we have to actually make sure we set the speed. So let's go over here and set the speed to 50. Awesome. So now that we have the direction and the speed, we can do that. And what we can do is we can actually just do this outside of the direction. However, the direction is useful, because what's going to be happening is we're going to want to flip the actual character, right? So what we can do is say, in here, let's actually add this right here, let's do this, let's add all that. And then we'll say if chase is true, then we'll do all this. And then if the direction is on the right, what we can do is we're not going to change the velocity, we're going to say, yet node animated sprite dot flip h equals boss, right? Because on the right side, I'm sorry, we want it to be true, because he's facing the left by default. So true. And then on the other one, if he's facing the left, then we'll make it false. So here, we'll make it boss, just like that. Okay, great. So now let's play and see what we got. Then you can see he's chasing us whenever we enter. So hopefully if I exit, it should stop or not. Okay, let's take a look at what's going on. Okay, I see, we got to actually reset the velocity. So if it if chase is not true, what we'll do is we'll say velocity dot x is equal to zero. So let's play and try one more time. And now when I go in his area, he's going to chase me but I leave, he's going to stop because the velocity is now zero. Okay, next up, we are going to basically animate it. So what's happening here, if chase is true, then we'll get node and play the animation. So we'll say get node animated sprite dot play. What did I name it? We got to make sure I type it right jump. We'll say play jump. And then if it's not true, then what we can do is play idle. So let's play and see what's going on. All right, so by default, he's playing the little frog thing. So what we can do is kind of slow that down, make it look a little better. So let's go into our idle. And what we can do is copy this by saying control C and then copy paste it a few times after. So now what it'll look like a little better, it'll kind of do that little frog thing and then pause for a sec. Now what we can do is enter, it'll start jumping and running towards us. Let's increase the area a little bit because it's kind of small. All right, let's take a little bit we got. All right, I think we got our restarted in order to for it to take effect. There we go. So now it's chasing us. And when I flip, it'll start chasing us towards the other side. Awesome. So now what we can do is we're going to add another player detection or another area to make this invisible. We're going to add another collision shape, basically, we're going to duplicate this, we're going to say player death. We're going to go to, we're going to make this visible. We're going to actually create a new thing. So let's actually just reset this and create a rectangle. So let's put this on the top. Now this is very important that we actually make this collision proper. And we want to put it on the top of the frog right here. Like that. And now what we can do is we can, we have to disconnect these, then reconnect them because we've changed the name. So it's going to chase, make it a new one. And then what we'll say is, we'll check to see if body dot name is equal player, then what we can do is basically just Q free. Now what Q free will do is just delete the player. So we're delete the frog itself. So now what's going to happen is we're going to jump on top of the frog. Hopefully I can do that. There we go. And then he dies. So what we can do instead is play the animation death. So let's do that by saying get node animated sprite and play death. Now you might notice this might not be perfect because something's going to happen. It's going to delete right away. It's not going to work. Let's try one more time. There we go. It didn't play the animation, but it did. What happened is it did. However, it's queuing free right away. So what we can do is say await, animate, we have to get the node, get node animated sprite. And then what await does is it's essentially going to wait for something to happen. It's going to wait for a signal. So the signal we're waiting for is if we go to player death, we can go to sorry, animated sprite, we can see that there's a bunch of signals here. We're going to look for the animation finished. So we can type in animation finished. And we don't have to type it in like this. We just have to type it in like that. And now it'll wait for it to finish. And then it'll queue free. So now if we go to the death, okay, it's five FPS. That's fine. Let's play. And see what we got. So let's have him chase us. Hopefully it works or not. Okay, so what was happening, what the reason why it's not playing death is because we are always going to be overriding it with this. So what we want to do is we want to go over here and say, if get node, we'll say if get node dot, what was it? I think it was animation is equals, yeah. Then we're going to do this, we're going to say not equals death. And that should hopefully work. So now we're going to also add this to the jump one. So let's add it here. Make sure I don't have any errors. Okay, so we just had to restart the game and it'll work. So now we can see that it's playing and then it'll play idle. And then when I jump on top of it, it's going to play death, but it's going to constantly play it. So what we can do to fix that, it's actually very simple, we go over here and turn off the loop in the death. So it'll finish and then it'll queue free. So let's try one more time. Okay, we got to make sure that we have the idle selectable fix that in a second. I'll show you how to fix that play. We'll jump on top of them to play the death animation and disappear. Okay, so the first thing we want to do is let's make sure that we're always playing the idle at ready. So let's say function ready, we'll say get node animated thingy, majiggy and play idle. So now that'll always default to the idle animation by when we are in the ready. So here, another thing we want to start doing is two things. Let's start. That's first, make sure that he's staying still. And then let's also say chase equals false. I actually don't think we need to make the velocity equals zero, we just remove that and say this. And now when he's chasing us, and then when I jump on top of him, he'll just explode and die. All right, let's make the explosion slightly faster. So let's go here image sprite and we'll go to death and say 10. And we'll do like, let's do eight. I think eight is good. And now let's also add something so that when the player hits him, he also explodes, but does damage to the player. So to do that, what we're going to want to do is add health to the player. So let's add health. Hey, there we go. And we'll say equals 10. Now we want to actually be able to see that. So let's add a UI for this. So let's add a canvas layer. And this canvas layer is going to act as our UI. So let's add UI, and we name it as UI. Didn't mean to do that. Let's add a label to print out our HP. And this, let's rename it to HP. We're going to add a script. It's going to be built in because this is very simple. Let's go to the process function. And what we'll say is text equals get node. We want to get the player dot health. Let's make sure we type this all out properly. We get the node. We're gonna say this, and then we're gonna convert it to a string. And then let's also add a text that says, whoops, HP, we'll say HP for now. And then add a space and then maybe something call in there. So that way we have HP and then the player's health. Okay, so now in our 2D scene, let's move this guy a little bit to the left. And then let's go to theme override, we're going to go to font, not font size, here we go font size. And let's create increase it a bit. So let's say HP. So we can see HP right there, let's increase the size just slightly so we can see it. And then we're also going to change the color to font. So we're just going to make that true. And let's play, and let's see what we get. We now have our HP on the top. Now what we want to do is basically add a go to the frog. And now what we're going to do is we're going to duplicate the player death. And we're going to say player a legend. Now this guy is going to actually be very simple. We're going to lip him. Let's actually go to the animated sprite let's play the idol. So we can see the frog. Let's go to the collision, let's make it unique. And what we're going to do is when I make it slightly bigger than the collision shape of the actual frog. So we want to do it like that. But not too big because this if the player touches this, they're going to explode and damage the player. So let's do this. And let's actually add a collision. Let's add the the thing to it. So the signal, so let's disconnect it and then reconnect it because we changed the name. And then again, we have to check if it's the player. And this one is actually very simple because all we can do or have to do is just do the exact same thing here. So let's copy paste this. And then we'll just say body dot health minus equals let's say three. So it'll damage the player by three. In fact, what we can actually do is take all this and let's actually create a separate function and say function death. And let's add it in there. And then I can just call death from here. And then I can also call death from here instead. So now we shortened our code quite a bit. Okay, let's play. And so what we got, let's play. If I jump on top of him, I don't take damage, but now I play again. And I run into him, I take damage. So you saw that HP went down by three. Awesome. We now have a really well platform. It's pretty cool. We can now jump around and run away. And if I jump on top of him or hit him, I take damage. So if you want, you can increase the area where as much as you want. So you can kind of increase it like this. If you'd like, kind of increase it above. Just like that. It's up to you. So we can do that, whatever you want. So I would encourage you to play around with the collisions. So it's very important that we actually have that the proper collisions. So one more thing we're going to want to do is in our player, let's actually go to the process function. And we'll add a new thing where we're going to say if health is smaller than zero, or we'll say smaller than or equal to, then we're just going to queue free because, you know, we don't want our player to exist, even though our health is low, right? And then we can do is go back to the main menu. So we can say, get tree dot same scene to file and go back to the main scene. So in here, nope, that's it. Let's add a few more frogs. So we can duplicate this a few times and kind of just drop them wherever you want. Make sure they're in the world. There we go. And now when we play, and I hit them all, and I die, I go back to the main scene. All right, now that we've pretty much got the base of the game, next up, we're going to be working with a few new concepts and good old. So let's just make a new folder and call it global. And this is basically just going to hold any global folders or things that we have. So it's not just going to be a global variable, a global script. So we're going to make one script called game. I'm going to go over here, I'm going to duplicate this and call it utils per utility. All right, in the game folder, we're going to go over here, we're going to delete all this and just call it or we're going to write variable. And let's see, what do we want as a global variable? Let's say player HP equals 10. No, not key 10, just 10. And then variable player MP is equal to five. Or actually, we'll say player or just gold equals 10 or zero, because gold should start at zero, not key zero, silly kiddo. All right, next up is we're going to have to actually make this global. So how do we do that? Well, in good old, there's actually a very easy way to do that, which is actually just to auto load it in the project settings. So head over to the project settings. In not in general, we're going to go to the top, as you can see right here in auto load, we're going to click this path over here, we're going to go to global and find our script, we're going to open it, and we're going to add it, make sure you don't forget to add it. Next up, we're going to do the same thing for utils, so we're going to add that and add it. And now we have both of these auto loaded and now they are enabled. So let's hold over to the utils and delete this as well. So let's take a look at what actually happened in good old. So when I play, here's our game, but we can see in our remote section on the top left, we have root and we have game utils and main main is our actual game, right? That's what we're playing on. That's the background, the play quit button, etc. And these are the two files that we just loaded. These are the two scripts that we just loaded. They're technically scenes, but they're also a script, right? It's technically it's actually a script, though. So that way we can now access these things globally from anywhere. And I'll show you how to do that in just one second. So next up is the saving and loading. So we're going to go through some file access in Godot. So Godot has a built in file access functionality. And it's very, very good. And it's very simple. So we're going to go through this together and work through this easily. So the first thing we're going to have to do is we're going to create two variables called safe path. And we're just going to say, we're going to give it a string empty string for now. We're just going to have the safe path. So for the safe path, what we're going to be doing or using is going to be res at safe game.bin. So what this is going to be doing is if you look at res, we can see that here, this is also called rest. So this is basically going to save it in that folder. Now usually, if you're actually releasing this game, you should do users. This is global, it works on Windows, and I believe Android, and I believe iOS. So for the sake of this video, we're going to be doing res, but you can you should and can use users instead. All right, next up is we're going to create two functions. One is going to be the save game function. Let's pass for now. And then let's make another function called load game. All right, and let's pass in here so we don't get an error. Okay, the first thing we're going to do in our save game is we're going to have to create a file. So to do that, we're going to say, fair variable file equals file access dot open, safe path, and then we're going to write. So this is essentially going to be able to allow us to create a file. This is going to be a temporary file in the actual function. This is the actual file. This is this is actually where we make the file. All right, but this is going to allow us to create a temporary file to actually write inside inside of it to actually save, right, because here we're trying to save. So we should be writing, right? So if you actually think about this in load, we do the same thing, but we're just going to read instead, we're not going to write it, we're going to read. So it's going to be the exact same thing, but we're just going to read instead of writing it. So next up, there's a few different ways and things to do to actually save the way the way I like to do it is to save it kind of as a JSON file. And the best way to have a JSON file is to have a dictionary. And so to make a dictionary is actually quite easy. We can just say variable data is going to be going to have a semicolon here. And this is going to allow us to specify what it is. So this is going to be sorry, data, just dictionary. And I'm going to say equals and brackets. And that's going to allow us to actually state our dictionary, you don't have to actually have this, I believe you can just remove this and just have it like that. And it'll say it's a dictionary or good old assume it's a dictionary, but this allows to actually say that 100% for certainty, this is a dictionary. Okay, so the next thing we're going to want to do is make the keys and the actual value of those keys. So the first thing we want to do is we want to save our player, player HP. And to do that, we can access it by saying game dot player HP. And the key we're going to save it as is the exact same thing. So we're going to say player HP as player HP. So that's usually how I make the keys. So sorry, we're gonna have a semicolon here, not a comma. And then to write another one, we're just going to have a comma there. And then instead of player HP, we're going to say gold as the key. And then we're going to also save it as gold. There we go. So now we can save two values in a side of a dictionary is a super simple and fast way to save a file instead of saving everything manually or saving one at a time. This is just going to allow us to save everything inside of a dictionary. And then now we're just going to store it inside of a JSON. So first, we have to actually convert it to JSON. So to do that, again, we have built in functions to do that nicely. Good old for has updated. So now we can just say JSON string is going to be equal to JSON dot stringify data. So this is going to just basically take our data, our dictionary and stringify it. Right. And now this is this is the easy part. We're just going to store it. We're going to say file that store line. And that's it. So now we this should actually work. So now what we can do is let's go to our main, let's go to our function here, let's add a function, say ready. And then we're going to say utils dot save game. And I just copy paste it. So now when I play it, it's going to save the game and hopefully it doesn't air awesome with no errors. And now what we can do is we can actually open this up. And we can see that we have save game dot bin. And if we open this, oh, I can bring it over. There we go. There's our notepad. So you can open it in notepad. And you can see here's our values. Here's our JSON data string that we made. So we have gold and player HP. So now we can close this, we don't need it minimize that. And that is how we save. Now how do we load? Well, it's actually very similar. So all we have to do is check if the file exists. So if file access file is this safe path equals true, or we can just say, if it there, I like to always like to specify if it's equal equals to true, not just have it there. But it's up to you. That's more of a coders preference. Then what we'll add is say, if we have not reached the end of file, so this means end of file reached, we have not reached that, then we're going to start loading. So this is where we actually load. So first thing we have to do is actually create a like string a file. So we have to actually read the file to do that. We say variable current line equals JSON parse string from file dot get line. So this is going to allow us to essentially parse the string and actually read what's inside of that JSON file. So next part is we just load it and to do that, all we have to do is say, if current line, we can actually just say game dot player class is equal to current line at this. So the current line will essentially take all the values that we have inside of the file and convert it into a good dough readable thing. So good dough will actually be able to read it. And then good dough will just load it in by accessing it through the array. So this is the key to that dictionary. Sorry, it's not an array to dictionary. And that'll, that's the key to that dictionary. Right. And so this is going to access to this guy, right? So the saved value that we have. So let's try this out. So one note is good dough three used to have to close it. So I think you used to had say file close, close, it's still there. But we don't have to do that anymore, though, which is actually really nice. Because if you would forget to do that, then a bunch of things would happen. So here, let's try saving it. So let's save and then load load game. So now that we've loaded it, we have, we will now save and load. This is basically the way to what did we do here, player class. We have to load the player HP, right. And then save the gold, make sure it's capitalized. All right, let's try one more time. Okay, so this is a fast way. When I save and load, this is a fast way to basically overwrite our all our data and reset it to zero, essentially. So now what we can do is we can comment that out. And now let's go to our frog. And in our death, what we can do is say game dot gold, plus equals one, or let's do five, and not key five. Oh my god. He five. And then we'll say utils dot save game. So every time we kill a frog, we'll get five gold and we'll also save the game. So let's actually print our gold. So let's go over here to our UI. Let's duplicate this and rename this to gold. And a quick way to make sure that we don't blunder this up is we have to make sure that the script is unique. So this script and this script are the same. So they've taken the same script. So we have to make sure that we go to one of them, any one of them, and make it unique. We can do that by going to the bottom right and just saying make unique. And now when I click it, and I save it, it'll now save it as its own unique file. Right. So these are built in scripts. So it's not gonna we're not gonna be able to find it, but they are here and there they are on the left. And now what we can do is change this up to gold. So we can change this to gold. And then instead of printing the health will plant gold. And we have to actually make sure to say that this is from the global function gold. And now what we can also do is actually change this to be a global function and say game.health. And we can also say, oh, no, we can just leave that. But we have to make sure that this is player HP. We'll also have to replace it in our player and frogs. So here, where do we do damage? We do damage. Here we go, body.health instead of body.health minus equals three, what we'll do is we'll say game.playerhealth minus equals three. Alright, lastly, we have to go back to our player and make sure that the health is actually going to look at the game.player health. And now we should be able to just delete this health. We don't need it. Alright, we'll just make a few lines there. Alright, there we go. So now what we can do is just play and test it out. So let's play. Let's go to play. We have to move our gold. Otherwise, we're not going to be able to see it. So let's go back to our world and actually move our gold down. And this should update automatically. So if I go back to my player, there we go. There's our gold. And now when I kill something, it gives me five gold. And now if I close it, I don't have to save or anything. Because every time I've killed a frog, it saves already. So now let's play and see what we get. There's our 15 gold. We've already gotten 15 gold because every time we killed it, it saved that goal. So let's take a look at our folder. Let's take a look at our file. So here, we can open this up, and we can see that the goal has changed. It is now 30 and our player HP is also 70, right? Or seven, sorry, because we reduced it by three and we got hit. Awesome. So our files now work. That is great. Alright, the next thing we're going to do is collectibles. So far we have frogs and let's take these frogs and just let's drag all of them and just move them to the right a little bit. Let's actually move them a little further. And then here, we're going to have some collectibles. So let's do that. Let's close this. And let's add a new scene. Let's close the player and frog. We don't need that anymore. And let's go to other node. And we're going to create an area 2D. This is going to be the perfect thing for collectible because this is essentially just going to check for a player, right? So let's add another collision or another node and a collision shape. And let's give it a shape, a circle. And here, I think an animated sprite is probably perfect. And I will explain why in a second. So here, I think we all we have is cherries. I think that's the only thing we have. Yeah, that's all we have. So let's go to animated sprite. Let's create an animation for it. Let's actually go into the animation. We'll just say idle. And let's just drag all these frames in. And there we go. We now have our cherry. Let's actually play it. So we can do that by doing that. And now what we can do is make sure that we just actually we can just keep in the middle like that. That's fine. And then let's actually try to give it the proper shape. So let's actually lock this, take the collision shape and kind of give it a nice shape here. All right, let's save this as cherry. Let's create a new folder. We'll say collect doubles. Save it. Let's go to area to name it cherry. We'll add a script. We'll go to node, we'll create it. And now what we can do is save this. And then we're going to delete all this. We're going to go to cherry, I'm going to node, and say and body entered. And this is really easy, because we can just say if body dot name is equal to player, then we can q3. And I would, I hope you would assume you know what we're going to do. We're just going to add to our gold. If you want to make a cherry like stat, you can do that, but I'm just going to add to our gold. So let's add five. And now let's go to our world scene. And let's close all this. Let's go to our collectible. Here it is and drag that in. Let's create a new node or a new container for that. So this is going to be our collect doubles. All right, let's add that in. And there's going to be a very good reason why I'm going to be doing collectibles is because, so let's play. When we play, what is happening? I do I know what's happening. What's happening is our players HP is below zero. And so when I go to that scene, it's going back to them in many. Okay. So here's our cherry. When I collect it, it q freeze. Okay, so that's cool. But how do I make it a little nicer, a little smoother. So it kind of feels more like a game. Well, good. It has this really nice thing called tween. So what we can do is we'll tween it. So instead of just queuing free right away, what we can do is we're going to say get actually we'll say variable tween equals get tree dot create tween. So here we have timer and tween will do timer in a second. But for now, let's do tween. And then what we can do is say tween dot tween property between property, there it is, we're going to tween the property. So what this is, as you can see, we can see a few things that we can add. So object property, the node path, final value, and then duration, you can't really see it. But that's what it says duration. So the object is which object do we want to tween? Well, we want to tween the cherry, right? So self, right? Or we can actually say get node, whatever, and then drag this in. But we could just say self in this case. All right. And then the property node path. So the property is the well, the property, right? So the position in this case, right? So we want to between the position. So position. And then what is the final position that we want it to be? Well, we can say position minus vector to 0, 150. So what does this mean? Basically, the final value is going to, we're going to take the original value, subtract 150 to the y axis, why, why are we subtracting and not adding? Well, because if you can actually look here, so if we zoom in a little bit, it's hard to see. But if you kind of pay attention on the left hand side, you can see negative five, negative 10. And it goes upwards in negatives, right? On the x axis, you can see that it's negative on the x axis here, just normally, and then goes positive in the y and the x axis on this side, right? Now in the y axis, it's reversed, right? So Godot actually does this. And so we need to make sure we subtract and not add. Okay. And then the duration will be like, I don't know, one second. And then this is the perfect part. Instead of saying cue free right away or waiting or creating a timer, what we can do is we can say between dot we call back. And then from here, we can actually say something so call back the callable is a function or like something that I want to do. So in this case, I can just say cue free. Now it in this case, we don't actually call the function, we just call or call the function with brackets, we just say cue free like that, and we can delete that. And now when we play, I play, and now it goes up, it takes about a second, it goes up 150. That's a little too much. So why don't we do like 50? Let's play around with this number. Let's play. It goes up about 50. That's a little it's not bad. But let's try one more time. Let's do let's do a point three. And then for this, we'll do like 25. Alright, let's play one more time. Let's see what that looks like. Okay, awesome. That's not bad. And we've kind of started something. But now what there's something else I could do? Well, I could interpolate the property of something else. And if you're thinking, you could make it invisible. So this is actually a very good trick is to do two things at once. We're going to tween two things, essentially, we're going to tween the position to make it go up. And then we're also going to tween the visibility. So if you go to visibility, we can see modulate is a thing. So we can modulate this to become invisible slowly like that. So it looks like it's disappearing. Right. So to do that, we basically copy paste this, we want to say self, instead of position, we're going to say modulate, modulate, we have to make sure we spell this right. And we're going to do the a. So we're going to say modulate to zero. So we're going to just take all this and say zero, because we're going to take our modulate a so modulate this guy, the value, and we're going to take it from 20 to 25, 55, sorry. And we're going to go all the way to zero. Now the duration, we might want to do, and we'll do a point three, let's see what we get. So let's play. And see what we get. All right, so there you go. So now it kind of looks like it becomes invisible as we collect it. Why don't we create, let's play around with these a little bit. So let's do like 35. We'll do 0.2, 0.35 for that. And I'm play. All right, there we go. Now, something you may notice is it's hard to notice, but it doesn't start becoming invisible, essentially, until this is done. So this goes, and then this goes. So the total time is about 0.5. So what we have to do is essentially create another twin, we have to say tween one, and then make this here. And then let's play one more time. Or yeah, we're going to want to tween after that. So let's play one more time. Sorry. And let's see. There we go. So now it actually looks a little better. So it looks like we're actually becoming invisible over time. Now you can play around with these numbers. I will right now, you can see me playing around with them. And there you go. That's a pretty nice tween collected. Okay. The last thing I want to teach is timers. So let's take a look at timers. So let's go to collectibles, let's create this. Let's delete all this. Now what we'll do is there's two options. We can either add a timer node, right? So here, or we can actually create a node or a tween timer. So we can say here, get tree, no, we can't say get tree, we can say create timer, but not outside of here, it has to be inside of a ready function. But we're not actually going to do this, we're just going to use the node instead. So what we're going to do is we're going to actually delete this cherry. And the reason being is because what we're going to do is we're going to spawn in children. So we're going to be learning two things, timer and spawning in the children. So from here, what we're going to do is we're going to say variable cherry equals load, no preload. And then we have to find the cherry. Oh, look at that. It's right there. So you have to find the path of the cherry. So if you don't know where it is, it doesn't, if it didn't pop up for you right away, that's okay. What you can do is go to the cherry on the left, you can either drag it in, right? So you can take it, drag it in, and it'll give you the path. Or what you can do is go right click. And there should be a copy path or control shift C. All right. And then you can see here, if I go over here and try to copy paste over it, it'll work fine. But then you have to make sure it's as a string. Okay, next up is a ready function. Let's actually, no, not a ready function. What we're going to do is we're going to now connect a signal from the timer. So if you go to the timer and go to the signals, we can see the timeout timer, the time out function, we're going to connect that to the collectibles. So let's go here. And what we're going to do, I just realized I spoke cherry wrong, we're in here, what we're going to do is we're going to say variable cherry, keep saying cherry with an a cherry temp. And then we're going to say cherry dot instantiate, this is essentially going to allow us to actually create it. So we're going to create this thing, we're going to have it in our hand. Now, to actually do something with it. So if we've essentially taken this cherry and put it in our hand, now we want to actually add it into the scene, right? So to do that, all we have can do is say add child, and then we're going to add the cherry temp. And that's it. So let's play. And so what we got, well, we're not going to get anything because we have to actually start the timer. So if you go over here to the right, we can see auto start and we have to turn that on. So let's do that. Let's play. And nothing happens, obviously. So let's go to remote and see what's happening. So we can see here, we have a bunch of cherries. They're being created. But what's happening, we need to actually do something with it, right? So if you actually added them, it's hard, it's hard to see, but maybe I can play around with this. You can see them at the top left, it's very hard to see, but they're at the top left. What's happening is that all these cherries that we've created are at position zero. So what we can do before we add it, we can say cherry dot temp dot position equals vector two. And from this, we have to actually kind of look at the position. So we'll say 296. So we'll say 296. And then the position will say 100. Okay, let's play and see what we get play. And now we can see the cherries are up there. Let's actually lower it a little bit, because it's really high up. We want to say, I'm not sure why it's not doing that. Let's do this as 400. Try one more time and see where the ring created. Oh, that's why this is the excess is not the Y axis. I mixed them up. My apologies. I just try one more time. There we go. And now it'll be created on the floor. But there's a problem. As you can see, they're always being spawned in that one position. So let's create it on the ground, but randomize it throughout the ground, right? So to do that, we can go over here, we can say variable rng dot equals random number generator dot new. Now, what is this? We can say, one more thing we'll say is random, random equals round dot f, I believe it's rng. Yeah, rng dot random i. And then the random i, let's take a look at what this does. Now, if you ever wonder what something does, if you kind of see a function like this, and you don't know what it does, we can do this is a very great tip. If you hit control, hold control, and then hover the thing, the function, and click it, it'll take you to what it is. Okay, so random i returns a pseudo blah, blah, blah, between zero and something something. That's not exactly what we want. In fact, we look right below that, we'll see something a little better. Randy range, this will allow us to go from something to something. So this actually works a little better for what we want. We don't want a completely random number all the way to this number, because that's a really large number that I'm not even going to try to say. So let's go back here. And instead of Randy, we're going to say Randy range. Awesome. Now what range do we want this from? Let's say 10 to 400. So this will essentially give us a random range between 10 to 400, and then place it anywhere from 10 to 400 on the x axis. Let's go back to our script and actually use this as the x axis. I will almost put in the y axis again, silly me. All right, let's play. And now we can see it's somewhat more randomized. There we go. So now it's actually more random, and it's being spawned in properly. And one other thing you can do is change the timer, you can change it to like three seconds, four seconds, whatever you want. And that's it. That's the timer. And we've learned how to use the timer. And we use how to add children. So this is actually a very good tool to use. We can always add children. One other tip you can do. So let's say, let's actually, this is completely for educational purposes, isn't actually going to solve anything, but let's create a note here. And let's say I want to spawn all my children here instead. But let's say, let's say you're spawning mobs instead of a cherry, right? What I can do is I can say get node. And then I can add those children to that node instead. So I can do this. So get node node 2D, add children, share time. So it'll add all the children here instead of collectible, right? So when I play, let's go to remote, let's actually play and see what's happening. Let's go back to world, go back to collectibles, cherry, cherry. Well, there we go. So now we can see all our chairs are being added to the node 2D. Awesome. That's it for the cherries. Hey, and that's the end of the course. I hope you guys really enjoyed this course. It was a lot of fun doing it together with you guys. And if you guys would like to see more content like this, definitely check out my channel. It'll be in the link down below. And if you guys want, I have a discord that you can definitely check out and join. If you need any help with this course, I will always be around to try and help. I have a bunch of other series as well on my channel. So definitely go check those out, such as an RPG series, a farming series where we kind of go through how to kind of recreate some different variety of farming games. And I believe I also have one that's kind of like an action survivor.io game. And so that one's kind of interesting. And recently or soon I will be releasing a 3D RPG series. That'll be a lot of fun. So definitely go subscribe to my channel and check that out. And if you guys like good, definitely use it for all your future projects. It's a lot of fun. And it's really simple. And Godot is always growing. And it's really cool to see that. So definitely check that out. And I will see you guys around. Hopefully. Bye bye.