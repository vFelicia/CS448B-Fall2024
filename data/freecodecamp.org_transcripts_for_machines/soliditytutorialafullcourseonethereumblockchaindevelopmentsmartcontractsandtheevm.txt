hey everybody this is gregory from daf university so i'm so excited to be on free code camp today to teach you how to become a blockchain developer i'm going to take you over the shoulder and teach you how to write ethereum smart contracts with a solidity programming language for the blockchain and you don't even have to know anything about solidity or blockchain to follow along so i've compiled this multipart tutorial series into one massive video for free codecamp and you can follow along with the code examples step by step on my website there's an article that i'm going to put a link to down in the description below and finally if you're serious about becoming a blockchain developer you need to join my free training on my website over at daffy diversity dot com forward slash boot camp and i'll also put a link to that down in the description below solidity is the main programming language for writing smart contracts on the ethereum blockchain it's a contract oriented language which basically means that you know smart contracts are the main way that you organize code and like store data and write all of your programming logic and you know it's a high level language for implementing these smart contracts it looks a lot like javascript and you know python and c plus plus as you see right here and it's used to run on the ethereum virtual machine which is basically you know uh the thing that runs the code on the ethereum blockchain so solidity is statically typed um as opposed to a dynamically typed language and it supports stuff like inheritance libraries and lots of other stuff so enough of talking about solidity let's actually jump in and start writing some solidity code this is a website that allows you to write solidity smart contracts in your browser and you know it has a text editor here and allows you to compile them and deploy them and run them and that's exactly what i'm going to use for this tutorial uh you won't have to download anything on your computer you won't have to install anything you can just visit this website to use remix and we'll write the smart contracts that way so in order to do that i'm going to go over here to this browser folder you can see the file browser over here this is some basic smart contracts that come preloaded inside of this ide i'm just going to create a new one here i think i can just create a new file this will be a solidity file we'll call it my contract and we're going to write a smart contract inside of here i'll do this by first declaring the version of solidity that we want to use we do that like this we say fragma solidity and i'm using carrot to specify a version greater than the one we want to use and i'm going to say version 0.4.24 i'm going to end each line like this with a semicolon and next i'm actually going to declare the smart contract so before i do that i'll explain a little bit more about what a smart contract is you know smart contract is code that gets executed on the blockchain in this case this is going to be the ethereum's blockchain since we're using you know solidity for this ethereum smart contract and this smart contract is kind of be kind of like a microservice out on the web it's going to be accessible to everyone on the blockchain they'll be able to you know see this smart contract they'll be able to use it they'll be able to read and write data with it and actually you know execute any code that we write inside of here so it's going to be public and that's kind of why i call it like a microservice it's more it's more than just a class like in an objectoriented system or something like that it's actually something that's publicly accessible so it's going to look something like a class though because that's how we're going to actually you know keep all the code inside of here so i'll show you how to do that we'll call we'll start by saying contract say my contract and i'm open this with some curly braces and it'll notice that the editor closes this automatically for us which is really nice and what i'm going to do first is just show you how to read and write a value from a variable inside of here now like i said earlier solidity is a statically typed language so we're going to actually have to declare the type uh the data type of the variable we want to store so in this case we're just going to store a string and we'll declare a string we'll say value now let me explain something about this value this value is going to represent you know a variable that belongs to this entire smart contract so this isn't like a local variable it's actually a variable that this entire contract will know about and what that means with a smart contract is that data is actually going to get stored on the blockchain in storage so if we set this value we're actually going to be writing data to the blockchain that's different from a local variable that i might just you know set inside of a function that would be you know local to that function scope and would you know disappear instantly once that function is called instead this value is actually going to be you know stored on the blockchain so let's create a way to uh just read this value so i can do this by writing a function in solidity like this we start with the function keyword and i say i'm just going to call the function get it's going to get this value and we'll say we'll just open the braces for now i'm going to write some more code here in a second we can see some warnings coming up but i'll fill this out more we'll say just return value okay and that's a really basic way to do this i'm going to add some more to this i'm going to say this is also public all right which basically is setting the visibility of this function that's what that's called and solidity is setting the visibility so that knows that this function can be called by anyone who has access to the smart contract on the blockchain not just inside this contract so i'm also going to set a return value say returns uh string all right that makes our warning disappear down here and i just tell our function that we're always going to return a string data type and we know that's the same data type as value because we declared it here now i'm also going to look at this warning down here which says this function state mutability can be restricted so basically what this is saying is in solidity now in this newest version since we're not actually changing this value we're not changing anything inside this function we want to add an additional modifier here which just says view all right and that makes that warning go away so now i'm going to set a new function or write a new function that's called set let's say function that's going to allow us to set this value say set and say string i'll say value all right and i'm also going to you know set the visibility of this function we're going to call it public which means that anyone will be able to set this value on the blockchain and i'll say value equals this value that we're passing in all right let me explain that i'm using value as an underscore here because i want to differentiate between this value that's getting passed in and the value that's referenced here now inside of here you know this value without an underscore is referencing this you know state variable that we set up earlier that's actually getting stored to the blockchain and this value sliding knows that it's just a local variable because i passed it in and i you know prepended it with an underscore like this and also notice that i declare the uh data type of the function argument we need that inside solidity because it needs to know the type of the data that's getting passed in all right and now we have a way to actually read this value and set it the next thing i'm going to show you is how to set this value whenever you deploy the smart contract or whenever it's generated for the first time and i'm going to do this with a constructor function so if you're familiar with other programming languages where you might write you know classes or something like that you might be familiar with a constructor function which is basically a function that's called whenever this contract is instantiated or in this case it's going to be whatever the contract is created or whenever the smart contract is deployed to the blockchain and in the newer versions of solidity we do that like this we say constructor and we just you know say it's public and we can you know write code inside of this constructor that gets called whenever this contract is created and we'll say you know value we'll just set it as uh you know my value all right there we go so that's a complete smart contract that you know sets this value whenever it's deployed so it will have some sort of default value and then we'll have you know some functions that allow us to read that value from the blockchain and then we'll have a function that allows us to create that value as well so now i can go to this tab over here in remix and i can compile it we can select the compiler version and i'm going to say let's see here 0.4.25 we'll start to compile it and see what happens all right and now what i'm going to do is actually run the smart contract you'll see some options over here i'm just going to say javascript virtual machine which basically what that's going to do is give us a test block chain in the browser so we don't have to connect to a blockchain of any kind we can just you know compile this and run it and deploy it inside of our browser which is pretty cool and it's going to give us some you know free ethereum accounts over here i don't worry if you don't quite understand what all these values mean just yet that's okay i can explain those more but for now we're going to just keep my contract and we're going to deploy it all right there we go it's deployed so now what i can do is click on this little down arrow here and we can see the functions that are available to us in the smart contract we can see the set function and the get function you know these are the functions that we created over here the set function is going to allow us to update it and the get functions allow us to get it so i'll click get and we should probably see the value that we created inside the constructor we set it here so let's get it all right there we go it's my value and we can see some activity in this log down here we can see that we there's a call to mycontract.get and now let's set it so i'm going to enter the quotations for the string and i'm going to say new value all right let's click set all right and we can see that worked so you can see the transaction history over here let's get the value all right it's new value there we go that's a complete smart contract that allows you to get instead of value on the blockchain now let me explain what's going on here this is a list of transactions that are occurring on the ethereum blockchain so the ethereum blockchain is made up of you know bundles of records that are chained together into blocks that are make up the blockchain and you know the basic units of all those blocks are these transactions so we can see transaction receipts we can actually click the down arrows here we can see all the details those transaction receipts and i've got other videos on this channel that kind of talk about that in detail if you want to know more about that just feel free to look for those all right that's it guys that's how you can write your first smart contract in the solidity programming language again that's supposed to be just a high level overview of solidity and how to get started writing your first smart contracts and using the programming language itself and using the remix ide in your browser to get started easily without having to download any tools or anything like that the first thing i want to do in this video is actually update the smart contract code that we wrote in the last video to support the newest version of the solidity programming language which is 0.5 0.1 i believe now you can actually see the compiler version over here has changed and in the last video you know we wrote this smart contract and there's some actually some compilation errors you can see over here on the right so you have to update this code to support the newest version of the solidity programming language and i want to go i wanted to go ahead and do this i wanted to go ahead and support the new version of solidity so that when i make more videos in this series um they'll be up to date and you'll have the newest version so let's see what we need to do we can read the error it says basically the data location must be memory and that's actually the error in both cases so all we need to do in this case is actually just return a memory here and then whenever we're passing in the value a string we actually need to put memory here as well all right actually that needs to be before value my fault and now we there's go away so we will select the newest compiler version we'll say uh let's do the latest complete version 0.5.1 start to compile and hopefully the compilation will work yep it worked so let's go to run and we'll deploy and see if it worked so get the value yep it worked awesome now let's move on to the next part of this tutorial where we'll actually cover the content for this video which is going to be you know the basic data types and data structures and solidity and how you can use them when you're developing your own smart contracts so i will change some values in here to kind of show you what that is the first thing i want to talk about are you know the different ways we can work with these state variables right so the first thing i want to mention is you know we had this string value here that we declared we set it here inside this set function and we had this getter function where we read that value right so solidity has a shortcut where i don't even need this function i can actually just read uh this string value for free i can actually get this function for free take this out and just declare this public that's that's declaring the visibility of the uh state variable here actually probably goes before so i'll save that and i'll compile it and i'll run it and we'll see that a get getter function called value the same name as the state variable was exposed to us by the smart contract and we can see it works just the same way as the other function did so that's a really nice way to save yourself from writing extra code you can just get that function for free exposed to the public interface of the smart contract whenever you store your state variables that way okay so the next thing i want to talk about inside of here is actually you know we could set this as a default value we don't necessarily have to put you know my value here in the constructor we could just say this right we could take this away oops take this away and we will um run that again let's just clear this out deploy all right and we can uh actually sorry compile it first deploy it again get the value and we can see it's my value we can also set this value as a constant if we don't want it to change um you know if we don't want to allow a user to set this value if we want to stay the same we can just say constant all right that actually declares a constant we have to remove this function we can't update this value at all solid t won't let us do that so we could just do that i'll deploy this again and we can still see our values here as my value so yeah that's how you would add a constant to your state variables or make your state variables constant now let's look at some other data types and solidity let's just change this name we'll call this like string value all right let's just deploy that we can see this instance here again string value all right it's my value now let's explore some other data types we can say uh boolean type we'll say bool public is equal to i'm going to remove this constant for now um my bool equals true all right so this just accepts true or false we can deploy that see this oh my bull right it's true string value is my value say uh or my string just save that just for fun and we can also see that you know we support data types like um integers so integers can be signed or unsigned so what does that mean uh well we can do a default int which would be public my int equals one right so we can deploy this and see let's actually just clear this out sorry deploy this and see my int is equal to one so the difference between uh an int and a uint or an unsigned integer uh is that an integer can be signed in a or sorry uh yeah an integer can be signed and a unit can be unsigned so what does that mean well basically an int can be negative so i can do minus one all right and deploy that that's a signed integer it has a sign in front of it it can be positive or negative and a uint can't so we'll deploy that uh clear these out and see my uint all right and my int all right yeah so negative one can work for an int and uh they can't do negatives on unsigned integers you can also specify the amount of bytes or bits um in an integer so we can say you went eight black equals my unit eight sorry equals like all right oops let's do a small number and we can see my unit eight all right and so if we do you ant here it defaults to 256 i believe uh unit 256 public my unit okay so that gives you a basic overview of all those basic data types um i don't want to bore you with all the pedantic details of this kind of stuff but this is helpful to know if you like the next thing i want to show you is an enum so what is an enum and how do you use it well an enum is basically an enumerated list that's going to allow us to keep track of um you know a set list of things in our contract so i'll show you what that means so basically i can declare an editing like this i'll say enum state and i'll give it some options here i'll say waiting ready active all right and this is going to allow us to keep a list of these three states inside the smart contract we'll be able to reference this to see what the current state is and it'll give us some options whenever we're updating the state and like checking against this so i'll show you an example we'll actually store this like this we'll declare state public state this right so basically this is going to give us um a public uh we're gonna be able to access this publicly with that uh getter so inside of here i'll do a constructor i'll say constructor i'll say public say state equals state active all right so i'll go ahead and set the default state to active right so actually let's do this let's do waiting and then i'll say i'll create a function to activate it and i'll say activate and say public state equals state dot active so we can actually choose sorry we can choose this value out of this enum list and update the state to that value all right so whenever we call this function it'll change the state to the active state and let's get a function that checks to see if the state is active we'll say function is active and we'll say public view returns boom all right we'll say return state equal to state dot active so that's we'll do inside here we'll just check to see if the state currently is active all right so let's see if you have any errors looks good um i will compile this all right we'll run deploy and all right let's check the state so is the state active all right no it's false so that's that's true it's not active um it's in waiting so let's actually check the state so state is zero so zero corresponds to the first uh item in this list zero which is waiting and i'll click activate all right so actually called the activate function um which you know updates the state to active let's see if it's active yep it's true and let's check the state so now the state is 2 which is 0 1 2. all right so that's an idea of how you use enums um let's look at the next concept that i wanna show you the next comment i wanna show you is uh let's do let's do structs so structs are basically a way for you to define your own data structures inside solidity we'll do that like this we'll say uh we'll create a struct right here we'll call it person it's a struct person and we'll give it some look at some some characteristics we'll say string uh first name and string last name okay so basically what's going on here is this allows us to basically model you know our own sort of arbitrary data i'm just going to model a person with this struct that's going to have a few attributes it's going to have a first name attribute that's going to be a string and a last name attribute that's also going to be a string and we can put these structs inside of like arrays and mappings and things like that i'll show you that here in a minute inside this video but for now just know that we declare that we've defined this new data type person inside the smart contract with a struct that's going to have a first name and a last name okay so let's actually uh create a function that allows us to instantiate a new person create a new one and we'll actually keep track of a bunch of these person structs inside of a people array all right so let's do that like this let's say let's let's keep track of a bunch of different persons so we can create new ones we'll say person this will be an array public people all right so let's see what's happening here people's estate variable here and it's in a it's public so we can read it outside the smart contract and it's an array here of these data type person right so we declared the data type first which is person which we defined here with struct it's an array that you know contains these person structs it's public and it's stored with the people state variable so we can add people to this array or person structs to this array like this so create a function say function add person it's a string uh this is a solidity five updates uh memory or 0.5 sorry first name and then we'll say string memory last name we'll say public and we'll do this inside here say people push so push is you know a function we can call an erase to add a new item at the the to the array and we'll push a new instance of this person struct so we can um create a new instance like this we just call person right and we pass in these attributes so say first name oops sorry name and last name all right and what we can do here is well yeah we've added it let's go ahead and do it so let's just let's just compile this a minute um i'll deploy this all right so let's see what happens so people um it's going to add the person add person oops sorry let's do the first name so first name will be dap last name will be university add person okay awesome so that didn't give us any errors now how do we read this person out of here that's a good question so we added this person to an array um but this function you know whatever we call this person or sorry this people function it's not going to return the entire array of people that's because this is uh you know we don't know the size of this array is in solidity and we have an array of unknown size it's not going to return the entire array so basically we need to reference uh the person by id so whenever we get this function it expects an argument which is going to be the index of the person inside this array so for example we know we added one person in there so we will add people we'll say zero all right there you go dap university so what happens if we reference you know a person that doesn't exist say a person you know one people it's gonna give us an error it's an invalid opcode error that's because there's no one in there at position one so how do we how do we like you know how do we fix that problem let's keep track of that like this so basically we would keep an internal count of the people we'd say something like this unit 256 people count okay and that's going to basically have give us a counter cash that will increment every time a person's added so we can say something like um people count plus equals one all right and we do that after i guess all right save that deploy and now we can uh actually make this public oops sorry as before let's try it again so now we can add the person dap university add person and we can see uh people count is one so we would do one minus that people all right dap university we do one minus that because it's a zero based index which means the first item you know is an index zero and the second one's index one etc etc the next thing i want to show you is how to do a similar concept here but model it a little differently so instead of using an array we're actually gonna use a mapping so what is a mapping a mapping is basically like an associative array so instead of having you know just an array um and we know that each index of the item in the array we can actually associate it to a value so that's that's like a like a hash table or a hash map or a hash and other programming languages that you might be familiar with or basically you can reference things by you know a key value it's key key value pair so instead of having people like this instead of being an array um i'm going to change it down here i'm going to say this is going to be mapping mapping uint person okay so uint is going to be the key and the person is going to be a value so this mapping is like i said an associative array that's going to take a key value pair the key is going to be an unsigned integer we'll treat this like an id so it'd be kind of like our database lookup where we have an id and then a record so this is going to return kind of like a record like a person record or a person's struct in this case it'll be public and it'll be people and it is kind of a fair comparison to compare this to uh a database because you know we're blockchain kind of is a big database and these structs are you know getting stored in storage on the blockchain with this mapping all right so person string first name last name and we'll do add person so when we need to modify this function we'll still take the first name we'll still look at the last name but we're going to put this in the mapping instead of the array so i'm going to move this people count back up here we're going to want to keep track of this just like we did earlier so we know how many people are in this mapping but we'll add it to the mapping like this we'll say people um people count this will be our id so if it starts at zero which it will do this all right people count plus equals one that'll be the new id of the person that's going to go in here so this will be person number one the first time we add this we'll say this is going to be a new person it'll be uh we'll give it a we'll give this an id we'll say uh unt id okay people count and then we'll say first name and then last name all right and we'll take this out all right let's see if that worked clear this out um deploy the contract so we'll do first name is dap university the ad person okay so see people count is one now and we'll go to people this time it won't be uh based on the array index it'll actually be on the id so we can actually reference person one all right we'll do people one there we go dappy diversity so let me explain a couple more things about structs while we're here um you know we need to keep track of this people count because there's no way to know the size this mapping and solidity uh basically any key that doesn't have a value set for it's going to turn a default value which is going to be like an empty struct here so if i do like you know person no 10 or like 99999 to people it's usually going to return default values so what are the default values for the struct person id for uint is going to be 0 and then these blank strings for first name and last name so that's why we need to have a person count so if you were going to use this like as a data storage um and you wanted to like show all the people or all the persons and your in your people mapping in your app or something like that reading for the smart contract you want to know how many are actually in there and you want to do that with a counter cache um so that way you know if you wanted to basically like the same thing with with those variable size arrays like if you wanted to get all the items you need to first make a call to find out how many there are that's what you use the counter cache for and then you basically create a loop to read out each one one by one so yeah it's it can be kind of a pain but uh that's sort of the state of things and what you have to do i'm going to go ahead and pick up where we left off in the last video i'm going to use this you know my contract that we built where we added a person a person struck to this mapping of people if you haven't seen that last video go ahead and check that out it's not necessary but you can probably follow along with this video if you want to what i'm going to do now is show you a little more about these modifiers like public and things like that i think we talked about that in the first video but i'm gonna go just a little further so what i can do is you know show you another modifier which is basically like internal um so that's different from public you know public is a function that can be called uh you know the public interface at the smart contract you can see you know the public functions listed here on the side so go ahead and create a private function or an internal function excuse me it'll say function uh we're just gonna take this people count and wrap it in its own function to show you how that works we'll say uh increment count we'll just make this a function and we can call it uh internal that's a different modifier we'll just take this people account we'll paste it inside of here all right and we'll just say increment count call that function and we'll run it see the smart contract we'll add the person we'll say dap oops dap university and i'll click add person and there we go it incremented the account you can see the people count has been changed you can say joe blow and the accounts changed so that's a way that you can you know use other functions that are going to be internal and we can see this increment count function isn't uh added to this list over here it's not exposed to you know things outside of the smart contract external callers can't use it so that's an example of you know other you know types of visibility of functions and solidity let's talk about function modifiers so we can add you know more you know words and terms to the end of this function to change how it behaves and i'll show you an example so we're going to create our own custom modifier actually inside of this smart contract so that only certain people can call this add person function all right so what i'm going to do is basically you know make this smart contract have an owner or like an admin and we're going to say that only the owner can call this ad person function and any other account connected to the network you know whenever they try to you know add a person they won't be able to and that'll show you how we can add an extra modifier to this function to make that happen basically we'll just add a modifier to the only the owner of this smart contract can do that so first we need to well actually that'll just look like this we'll say only owner that's what the modifier will look like now this only owner modifier doesn't exist yet so let's go ahead and create it all right so we'll do that like this first we need to keep track of it owner we'll say the owner is you know address i'm not sure if we talked about this in the data types uh video but you know an address is a data type inside of solidity you know like an address that's on the network an account so this will be the address we're just going to declare it here we're not going to set it just yet we can set it like this we can do it inside the constructor well actually nothing that just yet um so that would be the owner we basically just create a modifier like this we say modifier see only owner looks like a function and what we'll do inside of here is write the logic that makes sure that you know whoever's you know calling the smart contract is the owner so that's what we're defining here only owner and only owner so how do we do that how do we say the person who's calling this function is the owner of this smart contract well we're going to compare it to this owner right here but how do we know who's calling the function well solidity has a global keyword called msg which basically stands for the function metadata that's passed in we're not actually going to pass in any metadata here it's going to be implied so basically we have access to msu.sender and this is basically a special uh you know thing inside of solidity that tells us the account you know this address who called the function and basically we can just say you know is this person the owner we can just you know compare equality of the person who's calling the function with this owner that we're going to store here in a second all right and if they're not we actually want to throw an error right so this is going to show you another concept in solidity about error handling so we can throw an error in solidity like you know i think earlier we had some errors happen like here's an error we actually want to trigger an error if this person um you know it's not the owner we want to we want to revert the transaction and we do that like this we say require um sorry msg.sender is equal to the owner so basically anything inside of this require um if if it evaluates to true then this passes if it evaluates to false then this will throw an error we basically are saying require that whatever you put inside of here is true all right and then after this we can basically just do this all right and now our um only on only one modifier is complete so basically now we have this modifier that's you know defined here and we add it here and basically say if the person who is you know calling this function is the owner uh then you know we can actually run this function and if they're not we're going to you know create a failure we're going to revert the transaction and also whoever's doing this you know whatever like this code runs they won't pay this gas fee all right so now we need to set the owner and i'm just going to do that inside of constructor we'll use msg.sender as well say function constructor and we'll just open this curly braces and we'll say owner equals to msg sri msg.sender sorry i don't need the function keyword here and we also need to make this public all right so i'll save that so whenever you deploy the smart contract like you know this constructor gets run and the msg.send is actually the account that deploys the smart contract and they're going to get set to this owner state variable right it's address owner and basically that same you know address is the only person that's going to be able to call this add person function all right and if they um you know this code will run and we'll add a person and if we switch accounts to some other account over here then it won't work so let's just try that deploy this we will uh you know deploy with this account so let's change to that account we'll add the person actually i don't know if it deployed that account or not let's try it again so make sure on the first account we'll deploy all right we'll add a person we'll say dap university add the person all right let's see here all right it worked people count is one now we'll say you know joe blow and we'll change accounts to this one and we'll try to call it again add person and we see it as failed and the people count has not changed at all so it worked so we've kept track of the owner and we say only the owner can do it now while we're here i'm going to show you a little code formatting that i like to do sometimes this is getting kind of long and sometimes you know if you're like me and you have a text editor with a whole bunch of panes open i like to keep my columns kind of short sometimes especially with solidity and it kind of makes it easier to maintain these functions when the arguments are getting long and using git and things like that sometimes i will just break these up like this all right and then i'll actually put the modifiers if you have a bunch of modifiers sometimes this makes it easier to read and also when i'm writing my own solidity source code i only use two spaces i don't use four uh but yeah that's sometimes how i break these functions up so i can see the function name and then the arguments um then i can see the modifiers and then i can actually see the code that gets executed inside here and it can make your smart contract kind of long but it can be sometimes this will catch you if you have too many you know if you have three visibility and modifiers on here sometimes it can be kind of tricky so i like doing this all right so next i'm going to show you how to work with time and solidity okay so what we can do is basically compare time and solidity and instead of um this saying only owner can do this let's say you can only call this function if a certain time has passed so let's pretend like you know this is uh a contract that is only open at a certain time so we'll say instead of only owner we'll say only while open only while open all right and this opening uh state is going to be determined by a time so once we've passed a certain time in history in the future then we'll let you call this function if it's before that we won't do it so that's really useful if like you're building a crowd sale or something like that that has an opening time like an ico smart contract and you say hey we can only let you contribute ether like after you know the first of the month well you just figure out what time that is and say hey you know if you make a contribution before then we'll throw an error so i'll say only while open all right and instead of requiring that uh msg that sender is the owner right we're actually going to just take this out we're gonna say uh we're gonna make sure that the current time is uh in the future beyond a certain like uh opening time so let's do uint 256 opening time all right so how do we do this well we need to set this opening time somehow all right so the opening time is actually expressed in seconds and you know inside solidity or these time stamps are expressed in seconds inside solidity and you know seconds of what well it's epic time which if you're not familiar with that it's um a concept in computer science that's like the epic is a is a specific time i can't remember the actual date it's like a date in the 60s or 70s or something like that um and basically we just add seconds since that point in time in history so this is the current epic time stamp is this many seconds uh since the epic time and i guess there's probably a link here where you can read more about that yeah the unix epic clock um yeah i'm sure you can get on wikipedia and figure all that out but basically uh this is the current epic time and it's changing so we use these seconds values so this is like the current you know epic timestamp we'll say this all right so this is how we could set this and it's you know uh 256 is going to store this big number of seconds since that time stamp and that's going to be our opening time and so how do we compare that to now so how do you get now in solidity well there's no perfect way to do it but the best way is to get the current blocks timestamp all right so how do we do that well just like msg there's a global variable in solidity called block dot and we can say block dot timestamp all right and we can say is the block dot timestamp is it greater than or equal to the opening time all right so basically if it's after the opening time we're gonna let you call this function and if it's not um then we won't all right so let's give this a try i'm going to update this time stamp let's refresh it let's see this is the current one i'll paste this in here so 15 i'm going to add 60 seconds so a minute um so i'm going to deploy this and it will be uh it shouldn't work right now so we can try to call add person i'll try to add dap university okay we'll add person and we'll see that it reverted okay and now we can check the time stamp we're not there yet so i'll just pause the video wait for this to pass 75 i think that's the actual time yeah 75 all right i'll pause the video pause the video giving us plenty of time we're past the timestamp you can see it's 793 and we're at uh 775. so let's deploy it again oh actually let's not deploy it again let's just do joe blow add a person and it worked so that's how you can use um time and solidity you can get the current time and set of time value with seconds and so that's what i'm going to call today guys i hope you all like this video let me know how you're enjoying these solidity videos let me know if i missed anything or if there's something you want to learn or if you're just not liking them that's okay too just let me know down in the comment section below let's use the same my contract example that we've been you know using throughout this tutorial series and you don't necessarily have to have been following along with every video in this series you can kind of just pick back up with this one probably so yeah let's go ahead and jump in and start programming what i'm going to show you first is how to write a function that accepts ether so basically like how can we send ether in when we call a function and do stuff with it so i'll show you how to do that first we'll create a function called buy token say by token and this function is going to kind of emulate what happens in an ico uh like a crowd sale or a presale or something like that on ethereum where you're buying erc20 tokens i'm not gonna like code out an entire erc20 token smart contract right here or you know cut out a crowd sales smart contract i've got several other tutorials that show you how to you know codrum cryptocurrency on ethereum with you know build an erc20 token step by step and a real world crowd sale things like that so you can check out those other videos if you're interested but uh what we're going to do is basically create this uh function called buy token it's going to simulate what happens it's not going to do everything but at least give you an idea of how that works so we'll call this you know buy token and inside here what we basically want to do is buy a token and we also want to send ether to the wallet so what's going to happen is someone's going to call this function and they're going to send ether when they call this function and when they do we're going to issue them a token and then the wallet is actually going to receive the ether that they sent in when they call this function so i'll show you how to do that first i'm going to create um a way to track the tokens and basically all this is going to do is you know track this person's balance so we'll use a mapping for that we'll say mapping and again uh if you didn't check the other videos the mapping is like an associative array where we have key value pairs so we'll say address will be the key and the value will be an unsigned integer all right and this will be public all right this will give us a function for free that'll allow us to read this value and we'll just call this uh balances so what we'll do and when we buy a token we'll basically just say balances of whoever called this function so if you'll remember from the last videos in the series we we get that value with msg.sender this is the account that's calling this function and we will just increment this count by one now this is not really fancy um you know we're basically just saying whenever you call this function you're going to buy one token we're not using a rate of redemption or anything like that this is just to kind of show you how this works this is not very sophisticated um but basically that'll just increment your balance you know inside this token uh contract by one whenever we do that we want to transfer funds that are sent in with this smart contract to a wallet all right so how do we do that well first we keep track of a wallet uh we'll just declare a state variable here we'll say address wallet and we want to send funds to this wallet okay and we do that like this and i'm actually going to show you something in a minute that's going to be a solidity 0.5 update so if you've been using previous version solidity we have to make a change here i'll go back to that in a minute but anyways let's uh transfer funds to this wallet we'll do that like this so we'll say wallet uh transfer and we want to transfer in the funds that are sent by this function uh sorry transfer the funds that are sent in by this function to this wallet so how do we do that well how do we actually know what the the value is that's getting sent in well just like msg.sender msg has another property called value so i can say msg.value all right and that's going to tell us exactly how much ether or whey is sent in by the person who's sent this function so i'll show you how that works so that's going to do is take the ether that's sent in with this you know function call and transfer it to this wallet right here now there's this is not complete there's a lot of things that actually need to change in order for this to work properly you can see these x's over here uh these you know compiler errors so the first thing we need to do is uh set a wallet let's do that inside a constructor we'll do that whenever we deploy the smart contract so we'll say constructor we'll say address wallet we'll say public and we'll say wallet is just equal to the wall we pass in all right so we're still getting errors now let's see what they are the first thing we need to do in order to make uh this function accept ether well actually first we need to make it public so that people can call it let me say public all right so now people will actually be able to call this function and send ethernet stuff like that and in order for people to in order for this to accept ether we have to add another modifier here which is payable all right and if we don't do that this won't allow us to send ethereum with the transaction so this is how we declare that this function will accept ether okay now here's a new solidity update it requires explicitness whenever you're declaring an address that can accept ether inside of a smart contract and we do that like this we say address payable wallet all right and then likewise we say address payable wallet whenever we pass this function into the constructor all right so that should be a working implementation if we want to see so let's deploy the smart contract and try it out i will uh you know take one of these addresses and we'll take the second address here in the list and we'll use that as the wallet we'll actually check its balance here in a second um so we'll deploy the smart contract we need to pass in a wallet whenever we deploy just paste this in click deploy all right looks like it was successful let's try to do the buy token function okay it's just going to buy one token for us so make sure we've got the first account the list selected by token all right looks like it was successful let's check the balance of this oops actually pasted in the wrong address uh pasted in the second address so let's try the balance again all right it's one all right now all that did was actually uh transfer you know all that did was buy a token it didn't actually transfer ether to the wallet and that's what we want to show so in order to like send ether in and actually transfer funds to the wallet uh we do that like this we'd change this to ether i'm going to send one ether in with this transaction where we call the buy tokens function we'll do that from this account and we'll click uh buy token all right boom so let's check the balance again all right the balance is two now let's see what happened we can see that the ether value decreased here from you know 99.9 to 98.9 it actually took ether out of our wallet because we sent it in with the transaction and we can see that the second account in the list uh which i used as the wallet whenever we deployed has been credited with that ether so our smart contract worked it actually sent you know the uh value that we sent in with this to that account all right so the next thing i want to show you is how you can create basically a fallback function in solidity this is what it's called at least that's what i've seen it called i'm not sure what the official name is but basically it's going to be like a default function that you can um wrap this in so whenever you just send ether to the smart contract it executes a function you'll see that a lot like icos where you know they have an address posted and they say hey send ether to that smart contract and it'll actually buy the tokens for you now this is just a kind of pseudo code implementation again of like a a purchase function uh you know real ico function functionality would be much more complex than this but uh you get the idea so do this fallback function we'll do like this we'll just say function all right and we'll say external payable and we'll just wrap this with the buy token function all right so here's a new modifier i don't think we've used yet which is external so that's different from public because public can be called you know inside of our smart contract as well as outside but external can only be called outside so we don't want to like call this you know inside the smart contract somehow so now if we just compile this again and deploy uh i'm going to paste the wallet in here deploy we'll see you have a new function just called fallback um and we can basically just uh do that like this so we'll just send them on ether from account number one call the file back and it worked we can see our account balance went down this one up and the balance of first count should be one yep it's one so now i want to show you events inside of solidity so what do we use events for so events are a way for external consumers to kind of listen for things that happen on a smart contract so basically external consumers can subscribe to events on a smart contract and uh you know wait for something to happen so we'll do inside of this buy token uh function we'll actually trigger an event that lets you know anyone connected to the blockchain really to know that a token has been purchased from the smart contract if they were to listen for it so i'll create an event like this do it up here let's say event purchase and i'll just say uh i'll break this line right here oops i'll say address uh in oh yeah a buyer and i'll say uint 256 amount okay so that's how we declare an event just like that and inside of this function whenever the token is purchased we'll trigger it and we trigger the event like this we say emit purchase and we pass in the buyer we pass in the amount so the buyer in this case is msg.sender you know the account that's calling this function and the value in this case is just one semicolon all right so there you go now another thing you can do with these events um you can create an index like this indexed okay and that will allow you to you filter events that are only from certain buyers so basically like if you wanted to only listen to events from the smart contract that uh you know a certain person uh did a certain account or maybe even just you you could subscribe based on a specific address so i'll show you how that works all right let's compile this and run it i'm going to take the uh wallet paste it in here play all right now we'll call the buy tokens function um we'll send in one ether oops all right it worked now how we know the event worked so we can look inside of this transaction here see the log and we can see uh right here here's the log and inside this log we have some messages and this basically is is the event we can see uh the buyer listed here and the amount see the buyer was this address and here's the amount so what are events for really there's there's two kind of main use cases for events you know because um of the asynchronous nature of the blockchain you know if you're building an application that um uh you know if you're building an application that talks to the smart contract you know you might you you might call a function like by token like if you're writing a javascript application you might like call this function and then you know you your application would just know that you called this function but you might want to actually wait for this to finish and execute wait for this event to be emitted so you can basically wait for that and subscribe to this event um and filter for only ones you know that are applicable to you and whenever that happens you know you can you can wait for that to happen and then you know reload your application state whenever that event's been triggered so that's one popular use case another use case is you can get the entire event stream from a smart contract like this so you could basically see all of the purchase events because they're you know listed in these logs they're actually listed in the transactions uh you know that are contained in the blocks of the blockchain and that's a way to see all the purchases that have ever happened inside a smart contract like this i'll go ahead and use the smart contract that we were working on in the last video as the basis for this one um so in this video we're going to be talking about how to use multiple smart contracts in the solidity programming language um you know two different ethereum smart contracts one that will talk to the other and i'll also show you how to like write uh you know parentchild relationships with smart contracts we'll have uh what's about inheritance you know a a contract that inherits from another one so i'm going to go ahead and clear out some of this code from the last video to kind of get it where we want it to be the first thing i'll do is um let's see here we'll basically what we'll do is we'll go ahead with this scenario where we're still going to buy a token but instead of you know keeping track of the balance inside this smart contract we'll actually move it to a token contract uh to you know kind of separate concerns a little bit so actually tell you what let's go ahead and create the token smart contract like this and again this is going to be a really just basic uh you know it's kind of almost like pseudo code example it's not going to be a full erc20 token but this will just give you an idea of like what's going to happen when you know two smart contracts call one another at a very simple example so we'll say contract erc 20 token and again if you want to see more you know videos about erc20 tokens i've got plenty on my channel so i say string name so we're going to have a state variable that keeps track of the name here let's actually make this public and we'll do a mapping we'll just basically move this balances mapping up here take it out of this contract and we're going to um extract this balances you know increment here and put it into its own function so we'll just call this function mint say function uh mint i'll make this public and inside of here we're just going to do this we'll take this balances and increment it here just like that and also we can rewrite this just to say plus plus which will increment by one refactor that a little bit make it a little nicer a little cleaner all right and now you should be able to clean up this little bit take these comments out let's see here let's actually simplify this we'll take this purchase event out we don't need all this that was mostly to show you how events worked in the last video i just want to simplify the code a little bit so that it's easier to follow along with all right so inside of here we want to mint tokens inside of this contract so you want to call the erc20 token from this buy token function so how do we do that well you know we created this smart contract in the same file so because this is in the same file uh this contract knows that this contract is here before we compile it and deploy it so the source code you know this one will know about this one so we can basically uh be explicit and tell this contract that we want to mint tokens in this contract so in order to do that there's a couple things that we need we need to know the address of this contract once it's deployed because you know this will get deployed and this will get deployed and we'll have two separate addresses and then my contract needs to know about the erc20 token contract where it is and then we'll basically just reference that smart contract with the address and we'll basically get an instance of it kind of and then we'll just call the mint function on it all right so there's a twostep process the first is we need this contract's address and then we need to instantiate this contract and then i guess really the third step is we call the mint function so first we'll get access to this token address let's say address token all right we'll make that public uh so we'll just say token it's equal to token that we pass in and we will uh keep track of it here say address token all right we can also make this public if you wanted to so now that we have the address we need to basically get a instance of it so we can do that like this like i said this contract source code knows about this erc20 token here so basically what i'll do is say i'll create a new one so i can say erc20 token all right and we're going to basically instantiate it and we do that by passing in the token address that we've kept track of here so it can be explicit which i think solidity 0.5 requires this to be explicit so i'll say address and i'll say token all right so that will uh reference this ert20 token it's actually deployed it knows about this source code and then it's going to get the deployed token from the blockchain like this and now we can use this token to call the mint function so i'll show you a couple ways of doing this the first one is we can store this to a variable like this you know when we create variables and solidity we you know whenever we declare them we must uh specify the type first so the type is going to be erc20 token contract and this is a local variable it's not a state variable so i'm going to prepend it with an underscore just kind of a convention so again it's not necessary for solidity but i do this a lot you'll see this you know all over the place and now we can mint the token like this we just say token dot mint all right so now we can call this buy token function from this smart contract and it will you know use this you'll call the mint function to from the smart contract so let's check it out all right we'll run it so first we have to deploy this in two steps since there's two smart contracts in this file we'll deploy the erc20 token contract first we'll deploy it oh sorry i'm actually going to uh use the javascript vm we'll deploy it all right and now we can just copy the address of the smart contract that was deployed down here um from the transaction receipt let's say contract address and then now we'll go to my contract and deploy it so it's asking for a wallet and a token address let's paste in the token address the second argument and the first argument i'll just get the wallet so i'll just copy the basically this the second account from here so we'll do this account alright and deploy okay and now call the buy token function boom we can also see the token address here and now we'll say uh take the balance of our current address that we're connected with to see if it worked all right so why is that why is it zero well i'll show you why well first this was successful the buy tokens function worked it actually did call the mint function here but it's confusing because our uh you know balance from the account that we did it with is wrong so i'll show you what's right all right so let's go let's let you guess as to why this might be wrong well instead of leaving a suspense it's got to do with msg.sender here okay so this can be a real gotcha when you're programming in solidity and you want to call you know a smart contract function from another smart contract so earlier when we built this we call this mint function directly like if we go here and click mint right and now i click balance it goes up by one but if we do it from here you know we can click it again buy token let me see it's working but our balance doesn't increase at all but if i demand here it does increase that's because msg.sender in this case is the address of the contract that called the function not who sent it okay now that's kind of tricky so we can actually get the address of the person who sent the initial transaction instead of msg sender we also have access to tx.origin all right and that will actually mint functions for whoever initiates you know initiated this transaction so if we call mint function directly on the smart contract it'll increment our balance uh and if we call it from the smart contract it'll also increment the balance of the person who called this buy token function so that's a real gotcha when you're you know programming with multiple smart contracts and solidity that i wanted you to know about now i'll show you how this works so i'll deploy the token first we'll deploy it all right and i'm going to uh deploy you know my contract next say my contract and we'll paste in the address okay it'll be the uh wall address and we'll also paste in the um smart contract address like this all right we'll deploy it now let's uh try to buy tokens again we'll do a buy token all right it worked so now let's go look at balances of uh this account we're connected to you know account 33c this is account uh 33c we'll do balance and it's one if we mint tokens here as well it also increases so that's how tx origin works um you know it's different from msg.sender it's always the person who originated the transaction even if a smart contract is calling the function so i wanted y'all to know that because it definitely definitely can be a gotcha whenever you are programming smart contracts that talk to one another all right so i'll show you one other thing before i move on uh there's a shorthand here so whenever we met this token we can do this we can we don't destroy this token as a variable we can just say erc20 token and then just call the min function on it directly like this and that was the exact same thing so i want to walk you through all that but i just wanted to show you that that's uh also a nice clean shorthand valid way of writing this in one line instead of two okay so now i do want to talk about the next topic which is how to inherit smart contracts so inheritance so having a parent and a child relationship now we'll create a token that inherits from this basic you know erc20 token to do two things so we'll keep this functionality the same um and what we'll do is basically give out you know give this token you know the second token down here um we'll give it its own characteristics so we'll give it its own name and we'll also override some of the minting functions to you know wire up some of our own behavior in our own sort of pseudo token that we're going to create so i'll say my token all right so that's what this will be this mile token will inherit from this one and we do basic inheritance just like this we just say is erc20 token so let's customize this token i mean the first thing we could do is basically override the name we could say string a public name we could set it to something you know default like my token right and that would uh technically override this right that'd be basic inheritance because if we defined it a second time uh it would override whatever's in this parent class or parent contract and that shows you how that works but it doesn't really give us a whole lot of extra functionality so let's show you how this works in a different way so i'll set the name inside this parent contract like this we'll say constructor say string memory name say public and i'll say name equals name right so basically we'll just have a constructor function that's roman this contract is deployed and we'll take a name and we'll set it to the state variable here so we can actually override this whenever we deploy our own smart contract like this we can say instead of just storing having the hard value we can also inherit that uh let me do like this instructor string memory uh let's see name and i can say erc20 token name and that'll pass the name in from this constructor along to this all right and let's say public let's say we also wanted our token have a symbol you just say string memory oops symbol okay and we'll just say symbol equals to symbol we'll say string public symbol all right so that's a way for us to accept our own you know argument to our own constructor but still take constructor parameters from the parent contract and i'm going to break this up like this to make it a little easier to read i do this a lot in my you know production smart contracts i break up the lines like this so it's easier to read all right so that's how you you know override constructors like that now inside of here let's override this mint function as well okay let's basically add some extra behavior we want to preserve this minute function we still want to keep track of the balance but we also want to just do some extra stuff let's keep track of the people who actually own the tokens so first we'll say i'll keep an array of owners we'll say address this will be array of addresses say public owners all right and then we'll say we'll keep a counter cache with the people who own the token say uint 256 owner count all right and now we will update these values in our own min function so we're going to create a mint function that basically preserves the functionality of this but adds some additional behavior so we say that is going to be function mint so we're going to override it say public okay so first thing we want to do is call this mint function so that this you know behavior is preserved we just say super mint all right and now we say owner count plus plus we say owners push msg.sender okay and that is basically going to um call the met function the parent contract to uh update the balances then it will increment the number of people who own the token right here and it will um add them to the array of owners okay all right so now let's just compile it run it and so when we do this we don't have to deploy two smart contracts all we have to do is deploy this one so you can say your rc20 token see the string actually let's do this let's do my token so string name will be my token and symbol will be mtk deploy all right so let's call the mint function all right it worked so let's see the balances of the current the current address that we're connected with we'll say balance is this okay all right we'll do the uh name my token and the owners of the first person in the list is our address and a symbol okay all right and we could also make this public if you want to read the owner count all right guys so that's how you inherit smart contracts in solidity i'm going gonna be talking about two different topics in this video that are somewhat related the first topic is uh libraries how to use them in solidity and the second topic is math you know how to do math in the solidity programming language and these are somewhat related because you know we use libraries to uh manage math functions all the time in solidity um is a really common use case so i figured i would just record both of those in the same video so you know what is a library if you're not familiar you know library is basically a way uh to organize code that can be reused in multiple places inside your project so that's one of the main reasons we use libraries essentially to dry code up so if you're not familiar with dry dry that's an acronym for don't repeat yourself right so basically if we have a function that we want to use in multiple smart contracts we could define inside of a library and then use that library to use that function and that way if that function ever changes the change is absorbed by any place that we use it so how do we declare a library in solidity well like this first we use the library keyword say library and i'm going to call this library just math okay so in the earlier videos you know i said that you know smart contracts um are the main way that we organize code inside of solidity uh you know it's called a contract oriented language and that's true but we also have libraries where we can you define functions inside of here and store variables and things like that and that's another way to organize code inside solidity but really at the end of the day a library belongs you know inside of a smart contract so it can get called and used you know libraries don't have the full behavior of a smart contract they don't really have storage in and of themselves they don't um you know you can't inherit from a library things like that so it's not really like a smart contract at the end of the day it's meant to be used inside of a smart contract so we can define a function inside a library like this i'm going to create my own divide function say function divide all right i'll just leave this here for a second so why we want to use divide function well i'll show you let's create an example inside of my contract where we would you know basically just do some math first of all we'll declare a value we'll say unit 256. say public value we'll just store the value here and now i'll actually store this value up but we'll we'll compute it so we'll say function i'll say calculate and we'll take a value we'll say you went we'll say value one i'll say unt value to say public and inside of here we'll basically just set the value to whatever the calculated value is we'll say a value one divided by value two now this is a basic way to do division inside of solidity we just use this operator here it's the division operator so why might we want to use a library for this well you might notice a problem it's value two what if value two is zero right there be a problem with this we get some sort of uh exception because you know we can't divide by zero and that's a really common use case for a library basically we can write some code inside of here that prevents this divide by zero error we can actually stop the function before that happens so basically we could do like this we could define this function and say divide is equal to you know the input let's say you went 256 let's just say a you went 256 b we'll say internal pure returns you want 256. and we'll do the division inside of here say require that b is greater than zero that's the first thing we'll do we'll take the denominator and make sure the denominator is greater than zero so that we don't divide by zero then we'll actually create a return value of c which is c divided by b or the numerator divided by the denominator and we'll just return that value return c sorry this is supposed to be a so now we can actually use this divide instead of this divide here as a safer way to do division inside of solidity that's a really common use case for a library so how do we do that how do we take this function out of this library and uh use it inside this calculate function like this well we can say math dot divide and then just pass in value 1 and value 2 and we store the output to value just like that all right now i'll erase this all right now let's try to run this code so whenever we deploy this i'm going to select my contract instead of math and whenever this is decompiled and deployed um it knows that my contract depends upon math so it's already going to get compiled and deployed automatically we don't have to deploy this first and then this this in the whole compilation process of this file the math library at least the part that gets used is going to get compiled because it's dependent upon right here so let's try this first we can see the value is 0 and we'll say value 1 is say 100 and value 2 is 10 all right okay that was successful we see the value is 10. now it happens if we try to divide by zero calculate and we get an error just as we expect you know we can also do some other values just to make sure it works say 144 divided by 12 should also be 12. yep all right so that's how you uh you know that's a basic example of how you import a math function from a library now there are a few other ways we can do this you know instead of having this uh library just at the top of our file here we can actually move it to another file and import it inside of this file so we can clean this up and we're only looking at one you know sort of unit at a time we like to look at the smart contract we don't have to look at this library so i'll show you how to do that we'll go over here to our browser and we'll create a new file we'll call this math does so well all right now we'll just copy the math library from here we'll actually just uh copy it with the solidity programming language declaration and we'll paste it in here save now we can require the file just like this we say import we use double quotes math so well all right and notice i use the dot to indicate the current directory forward slash then the file name which is math.sol followed by semicolon all right that'll do the same thing so we can go back to here and deploy this say math sorry go to my contract and deploy and we'll see say 188 and 9. all right there we go that's doing integer division that's why it's uh has no remainder okay so that's how you import a library from another file in solidity now i'll show you one more thing i want to introduce you to a really common library which is called safe math which is put out by open zeppelin you can go to that repository here if you want to read more about it basically it implements a lot of uh helpful functions that i use a lot when developing smart contracts and doing math they've you know um they they solved a lot of problems like guarding from overflow and things like that um and so i use this library a lot so it's a really common use case for me i'm going to show you how to use that library inside of here because it works a little bit differently than how we implemented our math library so i'm going to delete this file and create a new one say safe math i'm just going to copy the code here from github click edit and go oh sorry not edit i want to do raw i'm just going to copy all that go back to remix and paste this in here all right now let's actually change the selective programming language version so 0.5.1 i think it should probably be up to date oops yep looks good all right so let's save that go back to my contract instead of importing math we'll do safe math all right and instead of you know calling a library like this we're gonna do a different way all right and this is pretty cool so we can take all these functions in here like multiply and divide and subtract and add we can actually call them on unsigned integers directly all right and we do that like this we can say using safe math for unit 256 all right now that's pretty cool i'll show you what that does instead of doing this we can basically say uh value one div value two there you go that's pretty slick so let's try that uh go to mic on track we'll deploy click this value value uh one would be 144 and value 2 is 12. all right value it's 12. there we go say 133 33 by 11. yeah 100 divided by 10. there we go awesome all right so that's all i got for this video today guys again you can find all the code examples of this on my website over at dap university dot com forward slash article forward slash solidity tutorial i'll put a link to that down in the description below and again if you're serious about becoming a blockchain developer you need to join my free training on my website over at dappydiversity.com forward slash boot camp alright until next time thanks for watching dap university