hello thanks for tuning in this is a recording of an online training session which was a beginner level class on the node.js runtime this was a freestyle interactive no slides just me typing good and talking about it so let me apologize in advance for all the speech fillers I did however cut out the pauses and the not useful parts so you can watch the whole training here on YouTube in one video it's 2.5 hours but it's also available at Gia's complete dotcom /gs and 19 where i split it by topic into many videos you can also use the timestamps links in the description to navigate to the different sections if you think of any questions while you watch this please feel free to join the JISC complete slack channel I just complete that comm slash help and ask us there I hope you enjoyed this class and please share it with your network if you know anyone who plans on exploring nodejs let's get started so this is a beginner class on node so uh no assumptions about what you know about no this is your first steps you know I might be assuming that you know a little bit of JavaScript and I am definitely assuming that you know programming in general so depending on on your skills you might be you might be overwhelmed or you might be disappointed with the content we all have different skills and this is natural but I hope most of you will learn a few things anyway the class is recorded so if you're lost in the class go fill the gap in your knowledge and come back and watch the recorded class so my name is Sam Urbana and I have been doing an ode for a while currently I do note on the back end and I do react on the front end but before that I did a lot of other programming languages I did some tickle Ruby I did a lot of pee sequel but now it's all node so and I am a really big fan of node and everything all the libraries that make that are added on top of the JavaScript language which itself is very flexible and it can do whatever you want it to do so if you want to see the stuff that I do I put links here feature links on on this website and also I publish everything I do on juice complete calm so there are video courses books interactive labs and a lot more Jes complete calm by the way is a node project so this is written in node and react on the front end so I have been hacking on this platform and it's really fun so no no this node is really funny well at least for me so let me set some expectations about the class today before we begin so this is not going to make you an expert on node right this is just your first step so just to get you familiar to raise your confidence in the platform and to get you started on the right path to learning node because I think a lot of people learn node the wrong way they focus on the packages that that comes with node or like that the thirdparty packages that are very useful but I think there is a big benefit in to learning the internal you know the the raw runtime before you go and use the packages and and that knowledge is gonna make you make your use of those packages much better so uh the one thing that you need for sure is you need node so so if you have a node version let me make this a little bit bigger if you have a node version that is 10 or higher you're fine I think it will be fine too but if you have an older node version so go ahead and install node I encourage you to always experiment with the latest and greatest always have the at least the latest LTS release but I actually do my development on the current version even if it's an odd number because odd number they're not gonna be LTS so the way this works is even numbers are LTS which is long term support odd numbers are not so right now we don't have any odd numbers this is an even number but it's not LTS yet it goes into LTS maybe in a few months right so LTS will become no 12 will become LTS and they start with node 13 which is not LTS it's experimental but always try to have the latest node so that you get to start exploring the new features that come to language and so that you detect problems going away because once you have the latest if you using something that is deprecated you're gonna get warnings and it's just so much better overall but definitely you have to test your systems on the LTS that is that you're gonna use in production right so for example just complete comm is running right now on this LTS so even though I develop I'm and I add features on 12440 if I have it I still locally I still switch things to the LTS and test things on LTS just give the whole system I go on the LTS before releasing a big release so there are tools for you to switch around so if you're on Mac you should definitely have homebrew homebrew is just the best way to to this one the missing package manager from node the best way to install node and install many other packages around node but there's also nvm so nvm and there's a version for it for Windows as well is note version manager so if you have nvm install now you can install node and you can install different versions of node and you can switch between these versions with the press of a command so you get to experiment with many versions of node and that's that's great so what is what is node exactly so when you have the node command when you install node you get three commands you get the node command you get the NPM command and you get the npx command all of these comes built in with node so node is a wrapper around v8 so v8 if you're not familiar with v8 v8 is the JavaScript engine not the juice the JavaScript engine man the a JavaScript the JavaScript engine that powers chrome itself so I am in Chrome right now and if I go in here and open up the console and put in any JavaScript so map the random for example this is a JavaScript function this is the JavaScript standard library and chrome just executed that JavaScript it did that through v8 so they extracted everything JavaScript from chrome into this v8 engine and of course every browser has its ancient a different engine so IE has a chakra there's chakra there's spider monkey and and a few of them now this is different then executing a browser API so for example if I do document dot get element by ID right and or get element by whatever that is that is Dom API that has nothing to do with JavaScript it just have a JavaScript interface so the this is a JavaScript object document is a JavaScript object but get element by ID is an API on that object same thing for things like set timer set timeout set interval these are just functions that gives you access to the browser API these are not JavaScript so set time app is not implemented by v8 it's implemented by the browser itself so when you get the browser you have two things you have v8 that runs everything JavaScript and you have the browser itself that runs everything DOM and scrolling for example a handle scrolling and handle resizing all of these events are coming from the browser but here's the thing everything runs in a single thread so if you have a big giant for loop in here that takes for a billion times that loop is gonna block the browser from doing things like scrolling so if the for loop is running the background the user cannot scroll your page so it is important for you to understand that this is a single threaded environment however the browser gives you an API a synchronous API is to do things asynchronously so that you don't have to block as a single thread that you have the exact same story is note so note just like the browser is also a wrapper around v8 so you get to execute so if we have the note command just type in the note command node and you get into this node that we call grapple mode run eval print loop and it's the exact same mode that you get when you open the browser's console this is also a rebel mode so in here you can just do math dot random math dot random and you get the exact same thing so this is through node right but note we really didn't do anything here know just pass this command to v8 and v8 executed math dot random v8 old node what the result of math.random is and note printed it to our screen right here so it's going back and forth between node and mv8 so the question is why can't we just use the eight directly you can of course but no it comes with a lot of other benefits around the the core standard library right for example there is let's say nationally to be server you can just start using an HTTP servers there was a package here called HTTP and it gives you access to starting and HTTP server and just like HTTP there is a lot of them in fact let's take a look at all of them right away so I'd like to point your attention to a very very important key on your keyboard ready it is the tab key which is above the caps lock right this tab key is important because of the discoverability it gives you discover discoverability powers so for example if you are if array is a javascript class right and it has many methods if you tap DoubleTap on array dot so just do array dot and double tap you get everything that the available on array this is this is a great discoverability because I don't have to look up the things that you can do especially if you have an object like a mystery object that you don't know what it is right so if you have give you em and you don't know what M is you can just see all the methods that you can do that look like em is an array because I get to join and split than Keys and splice and reverse so it isn't the radio everything I can do and if you double tap on an empty screen on an empty line you get everything that you can start with so all the JavaScript classes you'll see here all the JavaScript classes because you know it's a wraparound JavaScript but also get everything that is note so you see HTTP HTTPS everything that starts with a lowercase letter most of the things that start with a lowercase letter here are built in node so libraries that just come with node you don't have to install them those are things that you can just start using so node is not a product from chrome node is an opensource community managed project but it uses a product from Google which is v8 so v8 is Google Google manages v8 and a node uses v8 and it uses other stuff not just v8 for example it uses open SSL and a few other libraries like that also you can use node with other VMs so you don't have to so there's an experiment or a project where you can use node with chakra which is the chakra core the ie thing you know the powers IP edge so you can run node without v8 with using chakra core but by default when you install node you get the node that's wrapped around v8 ok cool so this list here is really important in fact I would say if you want a master node you have to learn every single item on this list I still I'm still learning new stuff because new stuff comes all the time but most of this stuff is JavaScript so if you are not familiar with things like date function not a number errors object reflect simple these are JavaScript things week map modern JavaScript right it buffers array integers array floats are a map promise regular Express Shen's weeks that all of these are modern JavaScript that you get to use out of the box with note and the other stuff that I'd like to point out to the things that we will explore today we so console is is a the same library that the same you know object that you have in your in your browser's console and they try to mirror the exact same interface for it in node but console is notit's not v8 it's written in node and it's in the browser it's not v8 it's the browser itself so today we're going to talk about console we're going to talk about the module object will mention path will mention timers we're going to talk about timers in general we're also gonna talk about HTTP maybe a little bit of net so there's a question what is M p.m. how is it related to u node we're gonna talk about that so you're running node.js on shell on Mac what I should run on Windows command prompt yeah so on Windows you can run the CMD I would recommend that you instead of CMD that you install PowerShell so power fell by in Microsoft is just a much better terminal than CMD and by the way there is a new terminal coming to Windows so that is gonna be much better right but PowerShell is the way to give for now what is the IDE tool to cold the IDE that I'm gonna use is called vs code so it is probably the most popular editor so if you wanna run anything I'm working on we're gonna use it today and I would recommend that you use it now in fact it on Windows I vs code will give you a better terminal so you can use the terminal in vs good instead of using you know the command prompt or anything all right what is I term to so I turn to is just a replacement for the built in terminal it's just a little bit better than the built in terminal has better team ox integration but you don't have to use it but get put only less explore it if you if you see node is not a recognized command that means you have to fix the path so you have to put the node that was installed in the path so we talked a little bit about node rebel right node also is a commandline tool so if you do node H you get everything that you can do in node as a commandline tool we see a lie of node so this is this is the CLI that's gonna run a script in general but it also you can use it with other options so you'll see the usage here node options and then you give it a script if you want it to run a script another another usage is node inspector we'll talk about that how to inspect a script in node and all of these options just scan through them they're handy I'd like to point out one particularly or a few particularly helpful options if you want to check the syntax of an ood file and not run it just check the syntax see if you want to execute don't use e use P because P is execute and print so I'll sure let's let's explore that so if I have no P and you just give it any JavaScript and it will execute it and print it right away so that p is for print a handy to just do things really quick and and you and the other one that i'd like to point your attention to is v8 options v8 options so if you do v8 options what you get is a big list of all the options that node can pass to v8 so let's let's explore that I'm gonna pipe it on less so that we get at page by page so if he ate options so in here you're gonna see a lot of things right you're gonna see harmony flags you're gonna see tracing flags and this listed like 400 or 500 options that you can do and and these are options that note pass directly to v8 so if you wanna change the way v8 be change the or a little optimization of the way v8 behaves or or change some experimental flags right if you want to experiment with you know webassembly right here there's a flags from rep assembly so most of these options are actually advanced I just want you to know of them so you can come to these options and and and search if you if you're looking to do party some something particular with with the like something advanced like like for example if you're if you're to work with the garbage collector in the a drive v8 has a garbage collector you have some options here to control the garbage pointer to expose the garbage collector to manually run the garbage collector so you'll come here and see all the options that you can do alright cool another thing that you should be familiar with is node environment variables so when you run a node process right when you run the node command whether you put in a file or you just run it with you know the rebel mode well what I did here is I started an operating system process right a process with a process ID and node I exposed this process object so there's a process object that has a few methods a lot of methods actually and this process object is basically the interface between your node environment and the operating system environment so if you need to read anything from the operating system or if you need to write anything to the operating system then you use this process object so it's the interface so this interface for example exposes the environment variables so all the environment variables that you have in your system just with process the in this give you access to everything invite in the environment that you have which is a cool way to customize your notes session so you just put something in the environment hopefully I don't have any passwords in here you put something in the environment and you can just access it in node right including things like you know including the builtin environment variables so so so the builtin environment variables are special environment variables that if you set them if you set them then you you get to change the behavior of note however before I talk about that let me show you how to control the environment is this is this is important so let's say no P and let's let's print process the end the user user is a standard environment variable right so this is the user that I'm using if you want to change that all you need to do is just specify a different user right and no it will just use a new value that you put in here instead of you know that's set in value because I changed the environment variable before executing node and of course I can do export or step on Windows to change it for to change it forever you cannot change there's a very good question from Amith you cannot change the environment variable through process the end it's not it's readonly things although you can actually change it so you can do you know equal tests but this will not change the environment variable here okay so I think if you do that right and try to echo a dollar sign user after that it did not change it so node will not tell you that oh you can't change it it's not really immutable but you get a copy you don't you get a copy of the object all right so let's keep going if you have so if you want to change some kind of behavior I'd like to point your attention to a few of these environment variables one one one handy in particular is note debug so if you do if you use a library like for example HTTP and you'd like node to debug more information about what it's doing in HTTP you can you can do something like this so you can note debug I think you just do HTTP and then run your node command and this will tell node to debug more information when it uses the HTTP library so very handy when you start running into problems you can change its a path so this is another important one that we're gonna talk about we're gonna actually talk about that next it is how to control how no discover modules so let's go ahead and jump into the more serious mode which is to run node in to run a script so I'm gonna create a directory so node I'll just do 0 6 19 and I'm gonna go into this directory not this one and I'll just run vs code on this directory to start exploring things and I'll actually let me just do everything in vs code so let's see I'll have the terminal in here yes good and make it bigger so if you have vs code you can use the terminal built in terminal otherwise you can still use the other terminal so I'm gonna do is I'm gonna create a file in here and call this file index dot JSP things in index Tijs so don't worry about yes lint for now so in here you can do anything that we just did so you can do math dot random right and now math at random and you can execute this file however it will not output anything because it just executed executed a value so this is not rebel node so if we execute node index that yes it will do nothing output nothing because we're not a rebel mode now we're in script execution mode which means if you want to output something to the operating system the operating system that's running the process then you have to use the interface to the operating system for example you can do process so process the STD out don't worry about the syntax dot right and in here you would do math dot random and it will probably not work because right expects a string so let's try that I think it will not work yep did not work because right here expects a string so what do you do well you can change this to two string so in here what I did is JavaScript this is a JavaScript expression I just made it interesting let's make sure this is working yep this works so this is a JavaScript expression right and I fed it to a node API so this is a node API process the STD I'll write is a node API now of course this is very raw a you know lower level because you have the console object the console object is also supported so I can do math dot random through the console object and that is going to output it as well and then it's a lot easier I didn't have to cast it into a string I did not have to put a new line after the output it actually colored it differently so console.log is another node API and actually if you go find the source code to a console dot log for node you'll find that it uses process the STD out there right so there are many many ways to do things there are lowerlevel api's and higher level API what if you console dot log an object what if we console the log process for example process is an object what's gonna happen well it's gonna it's gonna print a huge this is the default behavior for console to log it will print a huge object and go through all the nesting so everything that you can do on not just the first level properties for process but everything in it including arrays and all the environment variables right so this is not a very handy output what what do you do to make it handy well you can use other higherlevel api's for example the dirt one might be a little bit better let's actually the third one is exactly the same but the dirt one accepts depth I think or like it accepts an object and in here you can say depth is zero I think so let's try that yeah so it gave me only the first level so without any nesting what is the first level of properties that you have on process object so this is a cool trick where you can start exploring so it did not expand the big things that you have in process so this is me executing a script right so we're gonna talk about how node does this magic how does it execute a script can you turn on the buggin for all libraries using no debug I don't think so I think you can I have a comma separated list so you can do like FS and paths but usually you want to debug one library because if you turn on everything there will be thousands and thousands of debugging lines and it's not really helpful alright so I am going to ask you a question and let's pretend that we are in an interview and I'm interviewing you for an old position so I'm gonna ask you an interview question I am gonna so you know the about the you know function X right and function X and we're gonna call it and function X is gonna console.log arguments so arguments is a special keyword that present everything that you pass to X as an argument right so let's pass X three arguments so one seven and nine so what is arguments in this case if I execute this code it will be one seven and nine now you'll notice that arguments looks like an object not an array that's because arrays in JavaScript are just objects they're just special objects where the properties are numeric just like that so it is this is an array all right cool so you understand that right now my question is what is gonna happen if I just console.log arguments without any function what is the output in this case so that's your first interview question tell me what is the output in this case and if your answer is going to be undefined you're gonna be surprised arguments in this case is another array there is an array here with how many arguments with five exact arguments so what are these five arguments and why is arguments working here arguments is something that you get in a function right why is it working top level not what we're not in a function and what are these five arguments that you get this is core knowledge in node so the reason arguments worked is because node has this concept of wrapping wrapping modules right so this is what it does it wraps your code in a function so you get this if e by default you everything you do in node gets this if e if he is immediately invoked function expression immediately invoked function expression so you get this if e by default no just does this wrapping automatically and it also does other stuffs for example it returns something from your from your file we're gonna talk about that but just in general I want you to know that you get this if e by default this is why arguments work so kind of like this no it has this Fe and it executed it immediately that's what you get and the arguments that you get are mod one of them is module one of them is exports one of them is a file name and learning so let's actually take a look at them real quick I think I'm missing one yeah so require is the first one what exports is the first one yeah exports is the first one I think and then you get required and then you get module exports is the first one then acquire then module you can actually take a look at them if you just do if you require module you can take a look at the wrapper require module dot wrapper you see that require module dot wrapper require module dot wrapper so this is exactly what you get exports require module filename and earning this is the actual wrapper that you know uses it's exactly that all right cool so here's the thing if you if you have two files right so we're gonna have another file in here index 1 and index 2 index 1 and index 2 GS and I'm just gonna split them split down alright so you've got index 1 and index 2 right what I want you to know is that every function every file that you initialize gets this magic Fe right so if I if I constant log exports in here right experts is something that you get from the arguments right and I console.log it in here these exports are different right they're not the exact same object although if you execute them they're exactly the same it's an empty object right but this empty object Oh index to save this empty object that you get in index to analytics 1 these are different objects they're not exactly the same object why because they're coming from an argument that no passes to your iffy function so that's important so all of them are different right exports require module file name and their name file name is of course the name of the file that you're executing and their name is the name of the directory where your file is that you're executing so you need to learn about exports and and acquired these are two basic things in in node this is the node you know module dependency system so next we're gonna talk about these two in rebel mode you don't have arguments because you're not really executing a file this is when you execute a file this is how node manages files and modules how is console.log working when you run node file name as console.log is available only in browser yes console lock is available in node so node tries to mirror the browser's API right so when it comes to input and output not so there's no time you can't do document you can't in here you can't say oh look anywhere really you can't say document document dot get element by ID that is not going to work why because you don't have Dom so this will tell you undefined some kind of error document is not defined right so it's not exactly the browser however node opted to implement things like console like set timeout and many and a few other things that exist in a browser environment but they're not JavaScript right so these api's are built in node and their implementation is different than the implementation of the browser so and v8 has nothing to do with them v8 is just gonna organize the execution of functions and callbacks but these these api's are not cool that's why so if you go grab the source code of node you're gonna find the console object and a lot function in the node source code right not in v8 and not for any browsers okay cool no questions keep them coming so we're look we're learning about this iffy function if he wrapping function right cool so what is exports exports is an object that you can change so exports is a mutable object so we can say exports dot answer is 42 and you can put any number of properties on exports and when we execute this file exports is gonna be whatever you define it so it's just a special object that is available globally for you it's also an alias to module duck exports so if I do module the exports the another answer then I am changing the exact same property so you see how I changed it here and I change it it bear so exports is just an alias to module the exports cool and here's the thing node when it manages a file it returned module exports so whatever you put on exports that would be the return value of the index file the index module now why is this handy because another file might require your module so let's call this module one this index is your module right and you want index two to use your module to use index what you do is you require you just use require and you pass in a string and you say index two is gonna require index one Dodge's just like that index two is gonna require in this one so note what's gonna happen and in here I'm not gonna console.log I'm just gonna console.log let's console.log in index dot yes right let's pass a lot of an index digest so just by requiring index if I execute index two what can happen is note is going to look at this find require and it will require this file so it will execute this file so I'm gonna get the console log message although I'm executing index two so that's that's the story of require but here's how it's helpful it's helpful because require gives you access to whatever this module the export things is returning so whatever you put in module the exports you get it in here so in here you get an object index I'm just gonna call it index and I'm just gonna log index so guess what index is going to be index after index that in in index digest this here you get the exported module so this is module two exports so whatever you put on module the exports or its alias exports you get it out when you require a file so require is dependencies module dependencies it's similar to import and export in JavaScript in fact you can also use import and export and I'm going to show you how that because this is new this is new in node you get to use exports and imports all so any questions about and this exports business because that is that is core knowledge all all the packages out there that are written for note they use this syntax they use exports and require all right cool so I'm going to clean all this and just console.log hello and in here I am going to require index that yes and I'm gonna execute the file that's requiring so this will output hello right cool here is your second interview question what's gonna happen if I do that if I require index three times what's gonna happen so go ahead and try and answer this will output hello one time what why the output hello one time and not three times right and the reason is note has this required function in node has some magic caching it doesn't evaluate the file every time you require it it evaluated once and then the second time it reads it from the cache so this is why in a in an application say to react application or an angular application you require react all over the place you require angular all over the place multiple files are gonna require react or angular or view and only the first require is gonna actually do the work the second require will just read it from the cache so well another interview question is what if I do want this file to console.log hello every time I require it and the answer is you really can't you require you get cash that's just that's just the reality however you can delay what you execute in the file by making it return a function so remember module to export right module the export is our API so instead of having the console.log directly you can't have it export a closure you can have an export a function closure and you execute that function every time you want it so if I make module de exports into a function and I'm gonna use error function in here but you can just use a regular function and I make this function console.log hello instead of that now I have delayed execution now every time I require index dot yes what do I get every time I require index suggest I get back a function it does not have any code it will just cache the function reference and I can just execute this function that I get back from index that yes so if I do that and I execute this I get hello three times so we use this trick a lot in node we make Lee module exports a function and we execute the code in that function so it's a little bit of delayed execution what gets cached is the function itself not the function execution cool alright so there are many cases where you get me you want to execute something in a file multiple times right so this is how you do it you always execute a function in fact if you need the file to have multiple capabilities what you do is you make it export an object and in the object you have your capabilities you do like function one function to function three right so this is another way to export API so how would you do that how would you invoke function one now what you get back is an object right it's not a function it's an object and because it's an object it's an object that has F one I can do dot F one right dot F one because it's an object and execute F one right and this will work as well so whatever you put in here this require is just gonna use it right so and you can put anything right you can put primitive values you can put arrays objects or you can have like a proxy anything that is supported by the language you can use it as the exports value in your and you get to use it exactly as we define it right whatever you have we have an object has an f1 property so I'll just cut like get the f1 property and then because the f1 property itself is a function I can execute f1 right so there's nothing magic in here it's just JavaScript mixed with the API that no gives you to require functions now this is a little bit different than the importexport syntax that is that is native to the JavaScript language right this module require business is nodes way to do module dependency and it existed since day one in node so like ten years before JavaScript decided to have a module dependency as well now the problem is you have two systems one has been used for ten years and the brandnew one that everybody is gonna start using because it works in browsers as well so what do you do well here's what you do you really understand require module to export as to understand it really good because you're gonna have to deal with packages that are written in this sentence for at least five to ten years into the future if you're working in node project but in your own parting a node project today I would recommend that you use the import/export syntax not the required syntax now they have different implementation and I'm gonna tell you about that in just a little bit just so that you aware but I'm going to show you the importexport n tax first so let's go ahead and do that so let's do this exact same example but instead of working with require let's do it with with important export right so here's the thing if you have node twelve right if you have node twelve you can use import and export out of the box it's actually supported but remember that it's not LTS so no twelve is not Althea's yet what's the MV m LS system no twelve so nvm use system MVM LS remote while we're talking about it I'm just gonna get the latest and greatest node which is V 1214 and I'll use that so MDM install this thing and this will install the latest so what do you do here is you create a package that JSON file to start managing your dependencies right let's actually name this m1 and m2 because they're kind of different so m1 and m2 and I'm just gonna call em two in here m1 m1 that is N 1 and n 2 so exact same example I just named them in m1 and m2 instead of what I had before all right and and you can run them with the latest node so this syntax is not going anywhere so although we have node V 12 now we can still run m2 and we get the exact same behavior so export and require is exactly the same but what I'm to do is I'm gonna change this into important export but to do that I need the package JSON file so what is a package that JSON file a package that JSON file is the file that you can use to manage meta information about your node projects so every node package out there has a package that JSON file to tell you its name its version its get repository how to run things in it so you create a package that JSON file with the NPM command so what NPM is the node package manager and we're going to talk about it in the next hour after the break but for now the first step is to use the NPM init command to create a package dot JSON file that we can use to control things in nodes so @p a minute and this will ask you a few questions us or it can detect if you do Y which is for yes it says just try to detect whatever you can detect from this this object and just give me a package JSON file so this will create a package of the JSON file using the name of the directory using a default version it will try to find if you have git installed it will to find the get remote that you have it just detects a few things so in package that Jason you get to specify information about your package so for example if you put your name on the package so that when you push it people know if you want to have keywords so people can find your package in the search you can use this meta information so there is a new by the way the only two required properties in package that jason are just name and version these are the only required everything else is optional so the new the new property that you can use here on package that jason is the type property and if you specify your type as module instead of commonjs so the other one I think is common common jazz which is the name that is that we use for you know the require exports thing but if you specify your type as module then node will switch gears and just assume that you're just gonna use your ECMO script modules all over the place so there's no require and exports in fact I think if we try to execute it now it will not execute it will not be happy it will say well I actually executed that does not work oh we need a flag so we need the experimental modules there you go see so this flag is actually gonna go away when node goes into LTL I'm not sure when they're gonna remove it but they will remove it but this is this is how node is gonna behave when it switches to the ECMO script the ASM module loader see this is now the ESM module loader so it tells you I don't know require because I'm assuming that you are in um in a neck massager right you're not in a node module you're an ECMO script module which means you cannot use exports you cannot use require so what can you use you use export default and in here you pass in the object that you'd like to export so it's kind of similar to what you did but in here where we have a little bit of different syntax export default so instead of module de exports you do export default and instead of require what you do is you import you use the import keyword so import m1 from dot slash m1 dot yes well import m1 from the slash in Monda yes and now you get to do m1 dot f1 and execute that three times so you'll see a little bit of different syntax but it's basically the same module dependency so this works right you get a warning that it is experimental but it's really just it works fine they're just making sure that the API is stable so it is the exact same thing except there's no require there's no module the expert cool now we have a big question what is a module so that is an important question what is a module so I'm gonna give you the short answer and I'll give you the long answer after the break so the short answer is a module is just a file it's just a bunch of code lines of code in a file but it can also be multiple files right and we get to we now we need to understand what happens when you require or import a module I'll just I'll just use import in here what's gonna happen when you import not a local file so in here what we imported is a local file right and one what happens if you import say HTTP from HTTP what happens if you do that because this is not local because there is no even this this dot slash means a file on the same level trying to file a find a file on the same level or a folder on the same level so if you don't have duck slash or dot dot slash that means go find this in a special somewhere and this special somewhere is what we're going to talk about next is called the node modules directory and I want to tell you how node modules tie in to NPM and other package managers and how things work magically now HTTP is a built in module so it doesn't really go and look for it in the node modules directory it just take it from the builtin core the comes installed outofthebox with known but if you do import from Express for example which is a package that you can use to replace hdtb then you need to have Express installed this is not a thirdparty package they said this is not a builtin package it's a thirdparty package so you have to install it you have to let NPM install this before you can use it so we'll do that right after the break so can we have a library of components and import it as a module for another project definitely the answer is big yes that's how node works in fact when we import HTTP what we're importing is a small library of things that we can use and you can explore this right away by console logging HTTP so let's take a look at what we get when we import HTTP and in here we're just gonna execute m1 format from now on m1 and you get a library a little library object with a few methods so there is status codes for example all the HTTP status codes are here so if you want to look them up all you need to do is HTTP status codes you get a few important methods and and objects and classes in here and the most important one is create server so HTTP that create server creates an HTTP server that's what we're gonna use next if you have node 10 this is not going to work what we're doing here import HDB is not going to work so you have two options either upgrade to node 12 and use that or you can use the ESM package and this is how you do it you add cam installed ESM and this will download ESM from the internet and place it under a node modules folder so we're going to talk about that in just a little bit a place ESM under a node modules folder you see that and what you what you need to do to run things with the sm is instead of experimental modules you do or yes em are yes i'm so on more time re sm so this will work on node ten and eight and everything is just a shim around experimental module so you don't have you don't need no twelve and it is it works actually really good so that's our ESM so two new things just happen we use the our flag what is our so our is you require a module before you execute your code so that's our is kind of like a wrapper that you can inject a module into your system before node executes your actual module which is m1 degeus so that that's that's our and ESM is just a package that we downloaded so we can now import ESM from node modules so before we talk about HTTP I wanna I want to talk about node modules right so if you import let's say you want to import from like or just import and you pass in something you import something right what happens here is when you put something what node looks at something here there's something string and it figures out that this is not a builtin library right it's not part of the builtin library it's also not a local file because you know it doesn't start with dot slash or dot dot slash so if it's start with dot slash or dot dot slash that means it's a local file go find it locally where we're importing but because it does not start with dot or dot dot slash that means it's not a local file so know by default will tell you that I don't know what something is cannot find module something because it looks under node modules so it tries to find something dot yes under node modules so if we go to your node modules and we put something dot yes and we and we do something we do and we put anything here in digest so this is just a test so what I did is I put something just under node modules and guess what now I am importing something and there is something that is under node modules it will find it so there's no magic here it just looks for things under node modules that's that's what node does right and you can actually make this into a folder instead of a file so you can have a folder called something under node modules you can make a folder and name it something and put your code under this folder and by default node looks for index dot yes under the folder so just a test here from a folder right and you and if you import something here right you I can import the folder and it will look for the index that you has file under that folder and that's exactly how note resolved your external dependencies so if we npm install lodash for example if we npm install lo hello is a javascript library that you can use it has a lot of cool utility functions that you can use in in our missing JavaScript you can use them so what MPM does is it just places let's refresh this it places lo just like I did for something it places lo under your nose modules directory that's what IPM does it has nothing to do with import and export it just download slow and put it under the node modules folder in your project then here we can import lo because it is no module it is under node modules then it is something that I can just import and import directly means just execute so I'm not really interested in anything that the library returns like whatever the library exports right but if you want to not use whatever the library exports and you have to give it a name usually lo we do import underscore from lo and now we get to do use the lodash functions for example we can sum in the range so this is one two three and it will summon array of course we need to console.log that so you want to put it in a console log m1 and it is not working is it at all get it put it in a race it doesn't some an argument it will summon irate okay cool so this is how we use external libraries we use NPM to download them and place them under the node modules folder then we use node package management to import them into the project and use their API in in the project that's how that's the story of node packages and how to use them in general how do I make my library available for people to use it as imports in their project very good question what if our something that yes is turn turns out to be handy and we want to make it available for other people to use it what we do is we publish it under NPM now or we publish it under a repository in general right but if I want to publish my something that you ask all I need to do is I need to help make it have a package.json and then I can just NPM pop lish this this thing NPM publish now to publish NPM you have to have an account with NPM and NPM GS comm right and it has to be a valid package and you have to have the right to push through this package if it's a new package if NPM doesn't have a package named something already so the name is unique then it will allow you to push it but if you're trying to push through a package that exists you need to have rights to it so they need to add you as a contributor to that package and of course you can publish to github directly github in fact if we look for lodash in here github low low right you can actually install low directly from github or let's let's let's talk about Express so I'm gonna I'm gonna do that for you next Express not here Express Express is a framework a web framework that you can use to replace STD so we're I'm gonna install Express from github directly so the minute you push something to github it's available for people to use it with their node projects so let's use let's MPM Express from github so when I do in here NPM install Express just like that that will install it from the NPM registry it will not install it from anywhere else because I'm doing NPM install the default is the NPM registry but if I use this expression here which is you know just Express the GS / Express instead of Express NPM will detect that you mean go get express from github by default this expression means oh this looks like you know older slash repository so it must be from github so what it what exactly does it do it will get the exact latest commits the one that happens 25 days ago so it will give you the latest and greatest of Express so it's not the published package so the final published package was in NPM if you go to NV MGS comm and you look for Express this has expressed this is this is the package that you get if you just install it directly from Express and the final package was 417 one and it is 25 days ago so it looks like they match but if someone pushed something to get to Express today and then you do did NPM install Express / Express you get the exact same commits that happened today not the actual final published package but this is how easy for you to get something from github so if you push your package to github you can get it github also has a package registry that they're working on so you can install things from github directly as well but the package has to exist exist somewhere you have to publish it somewhere right all right cool good questions keep them coming how does the repository validate the authors right to upload very good question so you'll have to have some kind of authentication and by default it asks you for to login so there is you create an account with NPM j/s and you login with an email and password so if you do npm publish you will ask you for you log in it you log in and password but you can also use SSH keys if you want to say you know just like you push to a github repository and just like how github validate that you have commit access to that repository using a succession education but you do need to authenticate somehow and after you authenticate because they know your identity they're gonna do the authorization they're gonna validate in their system does this person have the right to push to this repository or to this package alright great questions keep them coming so we were talking about import and export so I think that is that is basically all the time we have to talk about node modules and import and export because we need to explore other things in in the node ecosystem so if you have any questions about what we did so far before we move on about all the import and export stuff the require the the ACMA script modules the node modules directory package jason and how these things work together definitely now is the time to ask them but otherwise we're gonna explore the HTTP package so we're gonna create certain fact I'm gonna call it server Dodge's I'm gonna create a server here so I'll delete everything I'll just keep server degeus and I don't really need any of those things so I'm gonna show you how to get rid of them and then just delete everything and just keep oh man we have a lot of stuff that came from Express but I'll show you how to clean this up so what I'm gonna do is I'm gonna create a server not here sorry in here we're gonna create server JS file and we're gonna execute the server digest file so in here we're gonna pass a log hello node and we're gonna execute so what are we executing here is just oh man no it's zero sink yeah all right I'm gonna just execute no re SM and server digest we're gonna actually create a web server in here and we're gonna do it first natively with node and then we'll do it with Express all right so are we gonna talk can modules be installed globally yes so if you want to install a module globally all you need to do is npm install dash G so that G flag means install this module globally for example I want to have a module to create a react project or create react app create react tab is a candidate for something that you want to have globally because it just creates a react app for you it's not really part of a dependency like lodash or Express you don't depend on it you just use it to create something another module that is a good candidate for a global is es lint you won't have es lens in all your node projects so maybe just manage it globally although it is probably a better idea to manage things locally even for even es lint because you want to make sure that the whole team uses the exact same version and they don't depend on a global dependency so I would avoid global dependencies unless you know it's a thing that you use globally for everything it's a command basically unless it's a command that gives you about a binary executable command just use local dependencies so let me mention a few more things about packaged on Jason we're limited on time but I'll talk a little bit more about it so one thing that you can do is use scripts so probably the most important part of package that Jason for me in a big project is the user scripts in fact if we go I'm gonna show you a sneak peek into the package that Jason for the J's complete project so let's take a look at the package that JSON this is the Jas complete calm this is packaged in JSON for J's complete that form and you'll see that I have so many things under the scripts directory see that all of these are a tasks that we use to run things J's complete some of them are development tasks so things that we do for development and some of them are production tasks the things that we do for production and these are different so any any person who uses who works on the J's complete project they know exactly how to start a dev process they know exactly how to bundle things for dev they know exactly how to send all the gist drops emails or update all the email templates or log things in production so these texts these tasks are unified let me know we always have to do it this way so how do we do that in in our project so let's let's create a task so for example instead of always doing node our ESM server yes right and if you if you bring someone new to the team you have to tell them oh you have to use or ESM in our project instead of doing that you can have a start script you can say you know what we're gonna put this in a start script so the start script is node art ESM server yes this is how you start our system and now it's a global knowledge because all I need to do is NPM start because I can run the script directly NPM start I don't have and if you bring someone new to that table they know they they know to look for NPM start right because you know it's a it's a global language there's what can I do for this project well you can start it and boom hello node it is running the Ari sm server so you will have a lot more in here for example what do we do to test things right maybe are we using mocha are we using just where where do we look up the tests so maybe that will be like oh just just under you know star star type or whatever things that you do and now you can do NPM test and it will run just now I don't have just installed so this will tell me where what is just I don't know just but you get the idea so these are special commands that you can do with just NPM start and NPM test but they're equivalent to doing NPM run start so NPM start is equivalent to doing NPM run start it's just a special one that has a shortcut but in general if you do something like let's say I want to do it dev start not not just start or prod how do you start for production for example how do you start things for a production well in production I'm gonna use the I'm gonna use node in the equal production for example and then do not know re SM server that yes right so I slightly different to run things in production then in development right so you have a different tasks for production run and if you want to run this task then you have to use npm run prod start because it doesn't have a shortcut so at 10 p.m. run prod script in fact these things are called run scripts because he uses in with npm run cool you can also use yard so if you're using the yarn yarn is gonna run into yarn will funny so you don't need to do yarn run so it's a little bit different in how the package manager is using so since I mentioned npx I want to quickly talk about MPX so MPX is NPM xcubed right so let's say you wanna NPM install G create react app create yak tab is just an example so don't have worry about it in fact I'm gonna use react so so react was just another one that I use and if you if you have we actually install then you can do react new I think project this is the command that you get react full react react full so you get a binary react full new project and it will create a reacts full project for you so this is the command that you can use but this will install reacts full globally and then use it right so a month from now if I come back to the project and I do another react full command react full new project to then it will install then I will use the exact same reaction package that I installed a month ago if I want to get the latest and greatest every time I use the react Ville command instead of NPM install global I can just use npx react ville and then invoke the and px react for new project and what this command is going to do it will install a temporary copy of react ville so it will download the temp copy of react ville use it and then delete it so I don't have a local copy anymore every time I want to use the react Ville project I can just download it with MPX in one command and it will download the latest and greatest and then use it use the command that comes with it because the command matches the the package name cool so this is MPX to install something globally and download it but it's also available if you if you're in your project if you have something that you need to execute for example let's say that we installed dev so I'm gonna install G this is another thing that we need to talk about and I'm gonna install the eslint right es lint so D means development dependency it means we don't really need it in production this is just in development so if I do D it will it will put it not under dependencies but rather under dev dependencies you see that so when you run things in production if you have this production flag if you have note n equal production and you run things with the production flag it will not install the dev dependencies right it will just ignore them it will only install the local dependencies because the eslint is not something that you want to have in production yes light is a good quality check that will check things while you develop developing them but here's the thing because just because we npm install the eslint doesn't mean that we get to execute the es link command there is no es linked command where is the es link command the es link command is deep under the node modules folder under dot bin so you can you can execute it from node modules been yes lint and and this will execute the node the es link command fine so it's it's not under it's under node modules right because NPM just install things under the node modules folder so if you want to execute it without figuring out where it is or you know how to execute it you can't just use the MPX command here as well and PXE eslint and this will try to find it under the node modules folder for you so MPX is a handy tool to do that that comes with with NPM of course if you have yarn you can just do the same thing with the arm so you're in just one command and it will you do that it will find the package for you now if you put things in in a in a script so if here we do check for example and we do es Linde NPM is also smart enough to figure out that so check in here to figure out where to look for es wins so we can just NPM check I mean run Jack right and it will also work as well so it will execute the ps1 command all right so this is dependencies dev dependencies and scripts very important things in package that Jason if I delete a dependency from package that Jason would it eliminate it from the project very good question in fact let's go ahead and delete lo right so if we delete lo because we not we're not gonna use it it does not eliminate it from and by default and still under node modules so the package that JSON file is just a documentation of what dependencies were installed but lo is still under the node modules folder right so I will it go away if I do NPM install so if you do NPM install it reads everything that you have in package that JSON and it gives you all the missing dependencies right but it does not remove the you know the dependencies that you do not depend on anymore so this is just the NPM be I think yarn behavior is different but here's the thing you should not really do it this way if you want to kill the dependency you should do NPM uninstall lodash NPM uninstall lo so this will remove it from the node modules and it will remove from packaged that Jason so my advice is do not touch dependencies and dev dependencies manually in your package to Jason you can only change the meta information you can add scripts manually that's fine it's just dependencies and dev dependencies make them go through the NPM command itself right this is just the advice unless you want to change the this weird character here the caret character which means give me anything that is compatible with three three so basically so three three would be fine here three four would be fine but not four so it says like give me everything that is compatible with three so it might give you minor version as well so if you want to change this and say you know what I want this dependency to be exact do not when you update your package always use the exact same dependency and not give me any a new version or give me just the patch so there are like special meanings for all these some things but this is a bit advanced these you can change them if you want to you can also just say star in here which means give me the latest and greatest even if it was es m5 I don't care just give me the latest so a major minor we call this you know that the semver string and this is the semper version here so major minor and patch so you have to learn about sin Verte and how how to manage those alright so we'll go ahead and talk about a HTTP next so this is how you create a node web server you import HTTP from HTTP and then you do HTTP dot create server so this API is from note STP duck crate server and it's gonna teach us a few things about about node so what you get back from here depends on the API so you can name it anything right in here you can name it anything so you don't have to stick with the API this this name here has to be create server because that's the function the API exposes but here we can name it anything usually I name this server right so this is the server and you make server listen on some kind of port so we make it listen on port 3000 for example so this is the API to create a web server now if you npm start because that's the script that we put the npm start you'll notice that node did not exit the process did not exit right I did not go back to the terminal command and this is because of the listen so if I kill the listen and read this again it will create a server and then it will exit I am back to the terminal right it did not it did not continue running so it is important for you to understand that node will only continue running if it has a reason to continue to run right if it has a reason to continue to run and that reason is do we have any asynchronous calls that are listening do we have any handlers for example I can have a set timeout set timeout is a timer right that we can run say after five seconds so it gives in here in milliseconds and let's just do nothing right set timeout after five seconds just for just to keep node busy for five seconds so because there is a reason for node to stick around for five seconds when we run this code node will not exit for five seconds and then after the five seconds it will have no reason to stay running and it will just exit right so that's extremely important note processes will exit if they don't have a reason to stay running so for example if in here if we do server that listen which is a reason for node to stay running forever right because it's listening right it's listening forever so it's a reason for it to start just to stick around forever but if this listen function deep internally through an error if there's an error then that error is gonna make the process crash and exit because there's no reason for note to stick around there's an error so that process the state of that listening server is so Note will crash from exit so what does that mean for you in production that means is note by itself the note command by itself is not enough in production because if you're just running a single node process in production that process might crash and exit at any point so you'll have to monitor this process and you'll have to have a cluster of processes and maybe even a cluster of servers if you need to so that if one process crashes and exits another process is automatically started because it is normal for a node process to crash and exit and if it has no reason to stay around it will not stay around alright now this server is listening when we emit you will not exit unless there is a crash and error right it will not exit but it is doing nothing right it's just listening there is no handler for what to do when an HTTP connection comes in so this is an HTTP server right so there is no information about what to do when an HTTP connection comes in so right now it will probably say undefined if we try to access anything if we go to localhost localhost and we go to port 3000 right it will probably not do anything waiting for localhost and it will timeout because there is no instruction but here's the thing the HTTP server received the request it just did not handle the request and the way it does this is through the event the events concept so everything is handled with events so when when I hit that localhost port 3000 in the browser I the the HTTP in the server object is going to emit an event that says oh I received a connection what should I do with it so to handle the connection I just handle the event I do something like server dot on and I specify the event that I'm interested in which is a request for Connect I don't know I don't know what it is I think it's request we'll see and in here you get what you do stuff in here so what do you want to do on request now if you don't know what the event is you can so so here's the thing if if if you're using a library like typescript for example which I recommend that you check out then you'll immediately get all the discoverability of everything because server is a typed object and we know all the events on it we know all the stuff in it but if you don't if you don't have this signature around then just look at the documentation know the API documentation czar really really good so you just go to the node API and you look for HTTP and you look for the on the on socket that on connect you look for connect there's no there's a lot of in here but I think what we're looking for is request right so you'll find that the request event here right and you can feel like find examples what is happen this is the event request right and here's what you get when you handle the event request you get a request object and the response object right and this is exactly what we're gonna do here we're gonna get a request object and the response object this is when I handle the request so in here you can do anything to new computations you can go ask the database for information whatever you need to do this function here which we call the callback function but it's really more like a handler function in this case is going to be invoked every time there is a request every time I put on localhost port 3000 and hit enter that's a request right so let's console.log a request and let's response send something so hello HTTP so this is how you do it response that's the dot right not send response dot right hello HTTP and then response the end now don't worry about the API yet this this will eventually learn because these things the response object here is a stream we need to stream information this is why we needed to do that in for the HTTP protocol to say oh I'm done but I want to show you that response that right now we need to restart this process every time you change something in a node project you have to restart node know does not have the development mode outofthebox so you have to restart it and now if I go to localhost port 3000 I will see hello HTTP so the message that I wrote Suresh tcume and note how I did all of this without any libraries I'm not using Express I installed Express but I'm not using it I'm just using the builtin HTTP library now if you look at the terminal for the thing that we just did you'll notice that we have two requests not just one request although i refresh the browser just once I ask for that page just once so for some reason this handler is being called twice every time we request so why well you need to discover why so to discover why maybe you can print information about the request why am I doing this request and I know that there is a request that URL that you can use to figure out what URL is being requested so now if we go back and write and we have to restart the server remember we have to restart the server if we go back and refresh the browser once and go back to see what requests are being made here Oh check it out so we're requesting that and we're requesting the fav icon so the browser is requesting the Fath icon by default that's chrome just trying to find the fab I come for that website so you have to be aware of these things right that you invoke the the request every time there is a request from the browser and the browser might do requests internally for its own rendering write an apple an iPhone might request the you know I'd the Apple compressed icon for the tablet and Apple compressed icon for the iPhone right it will request the four things actually so you have to handle these right now how do you handle right how do you say Oh what should we do if the request is I have I can request we should serve a small image so you would need to come in here and because of how limited this library is you would need to come in here and say something you know what if the request that URL is to have icon then do something different right you would have to do something like this to handle routes basically right maybe in here you just want to respond response not right nothing no I don't have a 5 icon else else right hello HTTP right so now the 5 icon is not gonna get any response where previously it got a string response right so you'll have to you have to have extra logic to deal with routing basically because this is a very raw HTTP package that has no no you know rich API for dealing with routes or dealing with files what if you want to send the file to the browser right what if I want to go to like you know give me slash a dot PNG right if I want to get a file an image I don't have a way to do that I have to use a different library to read the image from the operating system and then write the binary information that I get by reading the image from the operating system into the response stream in here so you have limited capabilities but everything is possible you can still do that you can still read from the file system and and and use the the the node response stream to write to it but there is a better way for dealing with this which is to introduce a library specialized in that kind of stuff all the basic needs for you when you do a web server and that library the most popular library is Express so Express GS is well it's really a framework around web servers and every all expect no developers to be familiar with at least one web framework and Express is just the popular one out there so how to use Express that's what we're gonna do next but before we do that before we do that you might see this handler written in a different way instead of server the on request you might see it in here directly as a parameter to create server so this is just a different syntax that you can use without dealing with the dot on request kind of thing so so actually hides the dot on request thing but I don't like this syntax because I I need you to learn that this is an event right and just like requests there are other events there's connect and disconnect and and many other events and node packages are really burst into this event nature so everything is an event emitter we call server here an event emitter so and you probably need to learn your own event emitting skills you have to be able to create an event emitter and listen to and make it emit events and listen to events because this this this observer model in general we call this the observer model you observe something on something else and it allows you to abstract your libraries so that they don't depend on each other they just send messages right and you listen to messages and you act on four messages so this react fullness for the in the observer model is really handy and this is why it's all over the place in in in note by default note has a limited mechanism to to handle asynchronous calls which is the callbacks and we should probably talk about it a little bit after after in the third hour I'm going to talk a little bit about callbacks and promises in general because this is this is shifting from node into modern JavaScript but in the next five or ten minutes let's explore Express so here's how you a server would Express instead of importing from HTTP we don't need an HTTP you import Express from Express now what do you get here when you import Express you get a function so if you go to the source code of Express you'll see that the toplevel import is a function just like the function that we used when we were testing you know the multiple calls so if you want to use Express and I'm just gonna comment out everything here just to keep things just for Express if you want to use Express you because it's a function you just call it and by calling a function what you get back is a server instance so basically just like you know the create server function this Express function toplevel is equivalent to the create server function all right so the listen is actually exactly the same you just listen on a port so 3000 just like that you listen on a port 3000 just like you did for the HTTP API but the route handling is a little bit different right the route handling is a little bit different so instead of doing server dot on you would do server got get and this takes in an actual route get slash and this will give you access to request and response right so similar to dot on now it's but it's now get so and you get access to request and response just like that but you also the response is a wrapper around the raw stream response that you get from node so in here you can do other things you can do send or send file if you want to this does not exist in you know the regular actually to be library so in here I can even send an object if I want to send an object so message is hello HTTP so you see how hello express right because now we're in Express so you have some and you don't have to do response that end send is gonna deal with this so it will abstract some of these complexities in here and also you get to be very clean in the way you define your routes because now I can also do fav icon have icon ICO in fact I can do fab icon star so if you call five I conduct PNG I'm gonna respond to this route there's like globbing going on here in the routes so this and in here you would send file you know the file icon whatever the path does have icon so you send the file directly in here right and and express is gonna deal with reading the file from the file system and streaming it to the requester see how this rich API is it's really still basic but it gives you some capabilities to just do features out of the box instead of having to deal with this complexity here but it is a wrapper around the raw HTTP in fact what you get here this listen method is exactly it's just forwarded to the HTTP listen method because express itself is just a wrapper around the built in HTTP framework that you get with note now we didn't really talk about the difference between import and export and require there is a slight difference and and that you need to be aware of which is import is statically evaluated while required is dynamically evaluated so what does that mean that means import is always top level you can't for example import something inside another function you can't do that you can't import something inside the function that is invalid JavaScript syntax why because import is statically evaluated while you can totally require something inside a function when if it's note is why I require you can require something inside a function because require is dynamically evaluated and then cached so that's a big difference between import and export between import and require now what if you want to dynamically import something with echo modules not with note if you make the decision to use a coma script modules and you want to lazily import something basically you still have the option because there is an import function as well so ACMA script has an import function which behaves kind of like require in in in how it you can dynamically call it and it gives you back a promise so what this gives you back is a promise now this is how import is different than required which is required although dynamically evaluated it is synchronous so require is synchronous while import is asynchronous so we're gonna talk another five minute break and come back top of the hour and talk about synchronous and asynchronous talk about callbacks and promises and I'm well I'll go over some lore of lore of the modern features in JavaScript that you can use out of the box in nodes and it will make your code for node better and then we'll leave some some some time for questions because I'm pretty sure you're gonna have some all right so no requires not really better than import but it is just different capabilities so if you want to have something synchronously imported then you can have a wrapper around this import something it's just require existed before Xmas script decided on this import export syntax and its future is probably that it's gonna exist in node but it's not the way to go but not for a few years we still need a few years to stabilize this import/export but I would say starting node 14 no one is gonna remember I require everyone is just gonna use import and export and the reason is this is going to work natively in the browser so you can take the code as is and it will work in the browser and the browser is gonna do this the smartest thing to try to fetch things in parallel from locations so you would have to import from an edge to actually be URL of course you would have to import from like github.com slash Express and and things will work just like that and you me too bundle things because right now when we ship things to a browser we need to bundle them we need to bundle them into one file so that the browser can understand them but in the very near future and by nearfuture I mean it is possible already but it's still experimental but it's probably next year or the year after that we will just ship the same code to the browser and the browser will work all right so what is bundling really quick bundling is when you take a frontend pack a frontend application that exists over many files and and you pack them into a single file we call this bundling and then you ship a single file to the browser so before we talk about callbacks and promises a little bit more about events let me let me tell you about so if you have if if you if you wanna when you develop your node applications you're gonna be editing files often right and having to restart things is gonna be is gonna get annoying really fast because it's a running server right if you have a running server so let's keep this running a way to keep the server or any file running is to do process the STD end resume now this is advanced but don't worry about it so if I have a server that's running and I want to change things having to restart to the server is annoying so what you can do is you can use tools to watch the files and trigger or restart on save and one of them is node 1 so we get NPM install dev node 1 node mom for nude monitor and all you need to do is just switch your node command to use node mod instead of nodes so instead of node here node mod and then it will auto restart things for you when you save the files so now that we're running with node mod if I change the string and just save it will automatically restart note for me so this is handy in development so because otherwise it's gonna be annoying you can hate it of course there are a few other tools you can use p.m. to itself you there's a forever NPM package though there's plenty of packages to do that the thing and this is general in terms of note in general when you need you need a single feature you have a lot of options to pick from for example a web framework like Express there are hundreds of them not not tens hundreds of them and and and every one of them has different advantages and disadvantages so you're gonna you're gonna have to make decisions on what libraries to use and I would and there are some guidelines on how to pick a library but I would go for the popular library that is maintained and tested so try to see if libraries maintain the tested and oh and it's responsive or it's closing issues on github its responding to issues on github and also take a look at the code so don't be afraid of the code and take a look at how the library is written and are they using clean code practices are they using good things like typescript for example that's a good sign if the library is using typescript in its code base that means they care about you know tithes they care about their API all right so this is node mom now let's talk about callbacks and promises so I'm just gonna kill this restart so it's a clean exit nothing to do and what I'm going to talk about is the callback pattern that you're gonna see so if you have a function that is wired for the callback function let's let's use the execute command so if you want to execute a command from within your node process you can use child processes what we call the child process library child process so this is how you use the child process you just require I mean import import something from the child process and I'm going to talk about this syntax in just a little bit so you import something from child processing you use it now you have a few things that you can import from child process I'm gonna import the exact method the exact methods from child process so this exact method takes two arguments or three I don't I'm not sure we'll check the API if we need to the first argument is the command to be executed so let's LS / right this is the command to be executed so I'm gonna execute LS / from within node from within node and it gives you access to the output through a callback so this is the callback that it will invoke so in here you get a function so the callback is just a function I'm using arrow functions here but you can use a regular one and I think it gives access to out and error I'm not sure maybe it gives X so I have no idea what the API is but the documentation to the rescue so let's go look up child processes child processes and go for exec what is the API for exact command options callback so you need to get comfortable reading by the way this this weird syntax that they use for documentation so this weird syntax means this exact command takes the command which is a string and then it takes an optional options so these square brackets around options mean they're optional and also it takes an optional callback and the options is an object so you can skip it the callback is a function and these are the three arguments that you get their STD Adam stpierre I would name them exactly the same so error STD out STD air these are the things that you get now I'm not focusing about the API itself what I want to focus on is the callback mechanism in here so if I'm interested in the output I just do STD out right so if I execute this file with NPM start because it's why are we some and everything then we will get a module not found child process as a child processes child process oh I misspelled it so its child process and check it out boom I see the LS / the output of that last slash you see that so x AK executed LS slash and then it gave me access to the SD be out now if the command have STD error it will give me access to us TV error instead but why do we have two errors there's an error here and then there is an STD in here and the reason is this error is related to the callback itself not to the command right so it depends on how you deal with it but the callback pattern in general is that there's always an error first argument this is the callback pattern this is what happens if we have an error in executing the command not an actual error from STD error itself not an because every command might also result in an error right every every string that you pass in here might result in an error in that case you get it an STD air but also exec itself might might have an error maybe it's executing a command over as SSH and network is slow so there's plenty of ways for a command to fail so you always get this error first argument and you have to handle it because if you don't handle it the error is uh swallowed them it's not cached it's not cached and that means you have a bug so because the command is gonna continue to run STD out will probably be undefined and because he did not handle the error so you always have to handle the air what do you want to do if there is an error right what do you want to do if there's an error and depends on how this module is used you have to do something you can for example throw there this is the safest thing you can do is throw the error again because if you don't it's not again it's not cached at all and it will just go silent but throwing an error will make that process will make the error poeple up to the consumer of this of this module you can also say you know what if there's an error here something serious it happened and I don't know and I didn't want to risk it I'm gonna process that exit I'm gonna make the process crash on exit because I don't know what happened so I'm gonna make it crash and exit with a status code of 1 which means this is not a clean exit we don't know what happened and error happened and let's just crash and exit because you don't want to have a process running in an unknown state and when you get an error you kind of have an unknown state because you don't know what there is if you want to handle some kind of error you can you can have an if statement here it says oh if the error is kind of this kind you know one kind or another kind if the error is file not found or command not found I'm gonna deal with it right but otherwise process and exit this is how you handle error you should crash the process and exit and then the monitor is gonna start a new process that does not have this error state all right so this is the error first the error first callback signature is that the callback itself is the last argument to the host function so we call this the host function right it might have a series of commands and then the callback is a function that is the last parameter for that the function is gonna receive it so it's the the last parameter for that function and then the callback itself has three parameters error STD out and STD I mean at least at least one parameter which is error and then you get the data through the second and the third and the fourth parameter if if they exist right so it's we call this pattern the error first callback pattern and this is what existed in node since day one and it's still and it's still supported today but there is a different pattern today which is to use promises instead of this callback mechanism so if exec was a promised based function then this is how you would use it you would say exact and you give it the command LS right and this gives you back the SDV act just like that just as if it was not asynchronous the reason we needed callback here is because exact is asynchronous it needs to go to the operating system instruct the operating system to do something and then take results from when the operating system is done which might be a few seconds later and then do something with the results so this is an asynchronous function so it's not synchronous I cannot just I cannot I cannot do that I cannot call it synchronously I have to call it asynchronously but if exact is promise based then I can await or first let's do that then I can do dot then yeah let's just do a wait so I'm not gonna like we don't have time to talk about that then and you should really just use awake anyway so you just await on exact but to await on a function you have to wrap it in an async function so you would do you would like define a main function for example and you label it as async right and then you call the main function because this is a thing so you cannot just await on something you have to await on something inside an async function but this is a cleaner than the other part here the other callback mechanism here because callback has many problems and the probably the most famous problem is how when you start making operations depend on each other you would have to start nest callbacks so you would nest callback to in callback one you would nest callback three in callback and we call this the Pyramid of doom you know the callback help problem but that's not really the most important problem at that callbacks the most important problem about callbacks is that you lose control when you have when you do things in a callback because unless you have trust in the system unless you have trust that exact is gonna actually invoke the call one time right then you don't have control you don't know exact might call your callback five times I don't know you don't have control over that while here you have a little bit more control you have a little bit more trust that this exact is a promise and because it's a promise it's gonna either resolve or reject and it's gonna resolve or reject only once so by moving it into a promise based API you have a little bit more trust into how this API is gonna behave and this is especially important if you're using something that's not builtin not exact if you're using something from Express to not builtin so you're really relying on the maintainer zuv Express package the people who are wrote the code for the Express package you're depending on their coding skills right and you never know but if they give you the interface as a promise then you get back a little bit more trust because you know the promise is an echo script you know a built in JavaScript thing that is going to either resolve or reject and it will do that either of these once so you have a little bit more trust and also you have a little bit more control into the flow of the program you get STD out and you can do something after a speedy out and if you want to nest dependencies you can just do them in line you don't have to nest callback functions you happen you don't have to do anything so it's much cleaner and better way to just handle asynchronous in general so here's my advice to me unless you have to deal with something that only supports callbacks and nothing else do not use callbacks always use promises now here's the thing exact is not a promise based function so this will not work if we try to console the log STD out it will not work because because actually no it did not work it gives me an error here a big error and I did not handle the error right you remember that I did not handle the error so in here I got some kind of object child process it's not really the output them interested in so how do you make it how do you promise if I this how do you make it into a promise well luckily note has a tool it's called you tell you tells you tells liking so if this comes builtin and one of the utilities the utility functions is is promise if I so you can call you tells the promise of I and you pass an exact and it gives you back a promise fight version of exact so we can make it like exactly the promise version in here right and in here since we have a promise of I'd version of exact now we can use the promise if I'd version of exact and things will work fine unless you tells is it you tell yeah there you go so we got STD out it looks like it returns back an object so it's util not utils it returns back an object right and this object has STD out and it has STV error right so if you have an object like this and you want to extract the STD out all you need to do is destructor the STD out and now we're back into the same the same thing that's be beyond cool now what about STD air and air so STD air is just another one so if you want STD error you get it here STD error if you want error itself that's a special case because now we're using a promise that means we have to we have to use the promise API to work with error so we can we can do that we can do dot catch in here because this is a promise and this will give you access to the air or you can do the following you can use javascript native error caching mechanism you put everything in a trycatch statement so you put your code in a trycatch statement and this will give you access to the error that happens when you execute stuff so in here you would do something with there and here you will process the exit if if you catch something that you know that you're you know you're unfamiliar with or or just throw it again report it and throw it and ignore it whatever you want to do with the error right so this API is better on so many levels and and again the the the two main important levels here are trust and control but also imagine that you want to do asynchronous calls in in a loop like if you want to do a loop and every iteration of the loop you have to do an asynchronous call if you're doing it with callbacks it gets ugly because you have to define the boundaries of your loop manually you have to keep it counter and and and check the counter to do things in the loop but if you want to do the asynchronous operation that is promise based in a loop all you have to do is just stick it inside the loop and things will just work so there are many benefits now some api's are promised by default right so every light every decent library out there now supports promises right including node itself node itself is going to support promises so you would do something like slash promises for example and it will give you a version that support promises outofthebox now they're working on that the the FS the FS module for example have a promise based API so if you look up the FS module which is something that you need to explore which is have to work with the file system in node so if you look up FS in here fastest them how to read files and write to files and create copy files and rename files and delete directories this is the biggest module in node right and it is the most used module because we work with files a lot right but if you look at it you'll see that it has a promises API so you don't even need to promise if I things you get promises out of the box and and many other libraries support both callbacks and promises they support callbacks for backwards compatibility but they also promises because that's that's the direction where we're going with asynchronous with asynchronous calls now if you notice I didn't really use the promised API I didn't do dot Ven or duck catch I just used async await right because it's just so much better dot then so the promise it sells gives you back the trust but async away gives you much better flow control so you flow your your your code in in a better way you control what happens with your code so you and you don't need to nest functions right so there's much benefits to async await so that is it about callbacks and promises so if you have any questions about that shoot up now callback some promises both of them really are limited in terms of handling handling multiple events right handling multiple events so there are there this is appropriate here because we have a single event this asynchronous nature here is a single event that we need to execute a single command and get back a single output right but what if we have like a monitor of commands what if we are monitoring the memory for example right we're monitoring the memory this application is using we would need to pull many commands on an interval we need we need many events right or we're monitoring the memory and we're interested in knowing what's gonna happen when it reaches certain thresholds like after 100 me 200 me right so if you have an asynchronous operation that has multiple events this is where you need to use an event emitter you need to use an event emitter and using an event emitter is straightforward because it comes it's supported in node itself so this is this is something that you need to get familiar with you import event emitter from events this is also builtin you import event in metal from events and you create an event emitter an event a matter object using this syntax new event emitter and now you can if it emit events you can say okay FET the matter I'm going to emit this event just let's call it change something has changed you can you can omit any event right you can omit the same event multiple times right and to listen on these events and do something you just do the on method just like the server because the server is an event Mary you just do on change and what do you want to do on change well let's just console.log something has changed right console.log something has changed so this is the syntax for event emitting right now here's your interview question what's gonna happen when I execute this code and your answer is will I see this three times because I emitted three times and then I'm listening to the unchanged event and the answer is no you will not see it at all why because I started listening after I emitted the three events right I started listening after I emitted the three events and the order here matters so if we change the order to put the listen first listen and then emit three times then you'll see something has changed three times so the order matter in fact everything here is synchronous there's nothing asynchronous yet however what you can do is you can start emitting things asynchronously for example let's do let's do a set interval and emit something has changed every second right now we have set interval that runs every second and in here we can you know emit some emit event event emitter dot emit change right so in here now what's gonna happen is if something has changed is gonna be emitted every second and our handler is gonna call it our handler is gonna be called so this is our handler basically we're handling this event by just constant logging it right so this is what you use if you have multiple events going on you would use an event emitter and here's the thing everything in node is based on this event emitter logic so when you get an HTTP server or when you get a stream right if they're all event emitting object right so the you remember when we did server get and we did that and we get request and response right we did request and response and we did something with request and response guess what server is an event emitter request is an event emitter response is an event emitter they all have events and you can listen to these events and you can make them emit events right can we make the emitter use async/await instead of a callback yes you can in fact this is supported if we the not async/await in general but an event emitter is also can be consumed as a generator because this is this ties into the generator concept in JavaScript right because JavaScript has this generator concept so if you wanna if you wanna look that out if you want more information about that look up generators in in JavaScript and have to consume new event emitter objects in node through the generators and X all right so this is all the time we have for events I'm gonna try to cover a few more topics in modern JavaScript but definitely keep that questions coming because I know there's a lot of information here I just want you to dick to get a taste of everything that you can do in node and really tease your knowledge into the the capabilities that you have built in before even installing anything like Express or lodash the other big thing that you need to learn here before I switch gears into the modern JavaScript just review is streams so you need to learn about streams in node and streams are big in them so what what are streams in general so streams are like they're kind of like array of data but instead of having this data over space you have it over time right so it's not available all at once it's not available for you in memory you're just getting it over time so every time you have a chunk we call it a chunk right a chunk of data becomes available and you can use it in your stream and after a while you get another chunk of data and you can use it in your stream so what our stream is good for they're good if you have huge amounts of data that you need to process in your code if you need to process a huge amount of data in your code you have to do it with streams but here's the thing here's the general advice I'm gonna give you you should just use streams all the time even if you have to process small amounts of data because they because you never know when the data is going to grow and you never know what's gonna happen in that case so streams are basically just like pipes yes and you can pipe streams on each other so an example of handling data that you should do through streams is the HTTP example for requests are asking for an image right if a requester is asking for a file in general you should really use streams to handle that you should read the file as a stream and write the file as a stream so when you do that your application will not consume the size of the file in memory so let's say you're you're trying to serve a 1 gigabyte video file in your web server right if you don't use streams you will buffer one gigabyte of data in memory and that's how much memory your node process is gonna consume but if you're using streams you can get these chunks you know 660 kilobyte at a time or whatever the default chunk size is and you get chunk one chunk and stream it to the requester and they get to play while your stream binary data because it's supported right video streaming is supported but this is how you do it you stream at one chunk at a time you do not send the whole thing you do not buffer the whole thing you do not send the whole thing now note comes stream ready out of the box so the note the note HTTP package is stream ready because everything is streams and all the wrappers around it our streams ready so when you do duck send file for example in Express Express is gonna do the right thing and stream it you just need to be aware that you're dealing with streams you're not dealing with buffers you're dealing with streams in general and and when you run into problems you'll run into stream related problems right you have to be aware of that so if you get any errors about chunks and you know stream interrupted or one stream is slower than the other right because if a stream is slower than if the sending stream is lower than the receiving stream then the streams have to do it have to do some you know back pressure kind of thing so there's a lot of science around streams you just need to know that you're dealing with streams all the time you can also create your own streams in node using the stream package that comes builtin and you also get streams out of the box for example there is the zip package there is the crypto package that you get in node and these have functions that work with streams so if you want to gzip something or unzip something if you want to encrypt or decrypt something you get to do it with streams because all of these work on can work on large data you never know if the thing that you want to encrypt is small or big if it's bigger than you know a few megabytes you should definitely use stream this is why by default you should use stream so there are a few types of stream but the most important the most interesting type is the transform stream the transform stream so there's readwrite there is duplex stream but really the most interesting type is the transform stream which is what you get when you use the zip and crypto is where you get one source one readable source and you write to a writable destination so you read from a readable source and you write a writable destination we call these transform streams all right cool the other thing that I want you to explore and I'm gonna give you some resources at the end for what's next but the other thing that you want to explore is scaling in general so how to scale a node application because if you can't scale another application you should not be right you should not be running milli right node has scalability out of the box like builtin and the way it does this is through the cluster module so the cluster module gives you a way to load balance a few processes together and you should always run your node application in production under a cluster you should not run a single process even if your server is only capable of running a single process that single process should be a cluster so your server is gonna have is gonna run as many processes as it has a virtual cores right so you so for example this machine and we can look at the virtual cores here using OS the CPUs which is a function dot link so this particular Mac machine has 12 cores right which means I can run 12 note processes and the operating system is gonna be fine with it right and they all can run in parallel so if I'm running a production server here I would have a cluster of 12 processes all running the same thing and I would have a load balancer that balanced between them and the same process is gonna monitor 12 processes and it will automatically start a new process if one crashes and we can also do a zero downtime restart by restarting one process at a time so we're worst at one process and wait until that process finishes any pending requests you know and then when it's done we'll start a replacement so we call this zero downtime restart so there's plenty of things that you can do and you can do it all through the cluster module but it's kind of like the story of you know HTTP and Express you know the raw versus rich API so instead of cluster you can use the PM to package or something similar PM 2 is just one of the one of my favorite packages and this is what we use in J's complete it is a wrapper around the cluster module and it gives you rich features out of the box with just a few commands so that's not only take a look at PM if you want to run a node application in production I would strongly recommend that you started with PN so we just take a quick look at the big list that we started with and see if we missed anything important I'll mention a few things here but I I kind of want to show you the inspection it's important how you debug new applications so this is this is definitely on the list but I'll mention a few things here DNS if you want to do DNS enquiries eval something should never use write this actually it's JavaScript path if you want to work with you know paths on the operating system so if you want to look up a file you need to specify a path however paths are gonna be different on Windows than they are on Linux and Mac so if you want to do it in an operating system agnostic way you do it through the path the path module here read line if you need to actually write a CLI command then you need to take input from the user you can use this read line method there are few utilities that we didn't cover but really it util is kind of going away because things are coming natively to the language right so util was just a replacement but there's definitely a few things that you can do here what's what else what else crypto domain don't use that events again is the most important net we didn't really talk about net and net is big so that if you want to do any TCP programming in node if you want to do TCP communication and socket communication you would use this builtin net library if you interface with v8 you can use v8 this this package v8 gives you a few methods to access v8 directly assert is something that you get out of the box which is kind of like a very mini assertion library that you can use in your tests so this would replace this is just like chai for example it has a few built in assertions that you can use FS is huge right this is the file system OS is read information from the operating system stream if you want to create streams not if you want to use them if you want to create streams you would use this stream package string decoder if you are using binary information and you want to decode it into a string you would use this one Z Lib if you want to zip things and unzip things oh this is all builtin you don't install anything this is all builtin power right which is really great and finally query string and URL if you want to work with with parson and format URLs all right so there's plenty of things for you to to learn you got yeah you kind of have to learn like the capabilities of all these packages and of course I skipped everything JavaScript but there's a lot of JavaScript in here I want to show you how to debug a node application so let's say that we have we have an array and we wanna a map and like be equal aid up map and in here let's say we want to function and in here we want to return e times e so some kind of some kind of code that we need to debug right and console the log B so this this debugging thing that I'm gonna show you is gonna work no matter what even if you have a server running you can debug node with with the following so if I'm running this server node server that is cool things are worth working so we have a bug here like we're passing a plus B instead of star we don't know like what is going on and I need to debug what is going on why is it not doubling the elements instead of why is it doubling the elements instead of squaring them and I need to debug that so what I can do is I can run node with inspect you just do note inspect just like that node inspect server dodged as a sorry node inspect server digest inspect surfer that yes and this will this will run the file through the inspector but this file does not run forever right because it does not run forever it will exit so although we run it through the inspector we also exited and the inspector accident so what you can do is instead of inspect do inspect BRK which means inspect and break on the first line so don't don't exit inspect and break on the first line so what this does is it will create a WebSocket server listening on this URL and you can use a dev tool kind of tool to connect to this web socket and issue commands for node to you know break on a breakpoint or go to the next line or go you know jump over step over a function the thing is chrome support this out of the box all you need to do is go to chrome inspect and it will see all the listening processes right here so you see my node server that justice right here all I need to do is click inspect and it will give me ready for a dev tools for my node script right there and I can do everything I can do in the dev tools that I use with my you know frontend application I can resume script execution step over go here step in to inspect the variables local in this case is one and then step next one he is two and the return value is that everything that you have in the very rich dev tools experience you can use it with node just with the dash dash inspect or dash dash inspect BRK and you can set breakpoints and set expressions call stack watch expressions everything right so how cool is that right very very very cool and every time you pause in here you can do manual operations on on the variables that you have so this is inspection with with nodes just use the that just use the chrome dev tools integration with the dash dash inspect now if you need to inspect a node application on like a server where you don't have a graphical interface you can use the dash you can use the inspect itself so if you just do inspect not inspect if you just do inspect you get a terminal debugger so you can debug here in the terminal and you see how it stopped on the debugger one I thought I had it stopped right here and you can debug everything you can go into I think you can have to type rebel and now you can debug things in in the rebel and you can type in and you can control see to exit the rebel type and help to see what you can do in here you can have commands to break point and continue and and watch things and all the this so we call this a terminal debugger and it's handy if you're debugging things in production on a server where you don't have a graphical user interface and there's a case where it only happens in that server and it you can't reproduce it locally so that terminal debugger is something that you can use as well all right cool so there is a lot of modern JavaScript that you need to to learn if you if you want to work with node projects and the reason you need to learn these modern JavaScript is that everyone is using them so you look at any node based project and the project that is gonna be you know any if you're if you want to join a team they're probably using modern JavaScript now I wrote a lot about modern JavaScript I'm gonna try and find the three article so in the J's complete library jobs I think it's JavaScript for react all the jobs you need to use before react so I wrote this for react but it really applies to everything so I am kind of like focusing on and this is free you can just read it here I just complete I'm focusing on the features that are specific to react but for node you need all of this and more so that is the whole subset that you need to learn so I'm just gonna go over really quick and just mention what's important what's really important in modern JavaScript that you need to know block scopes are good not very important oh that we have a list here arrow functions yes we use this all the time they are a little bit different but what's important for you to understand is how they behave in terms of closures right so error functions and closure and this is this article is your first good step into understanding these but you get an expand on that after that literal notation not really new but we we do a lot of stuff expressions destructuring another big one here is these structuring so I'm gonna quickly tell you about it so this is the D structuring syntax that we have here this we use D structuring with arrays and objects and so this is what Airways this is with objects destructuring with objects and its really equivalent to doing this here so the D structure in ovaries is equivalent to what I did here you just take the items as they are positioned in the array and you give them local names in the scope in the local scope you give them names in your local scopes and that works for object properties and array items by their position right so very very very big we use destruction all the time because it's a much better syntax you can also use it in function parameters so you can D structure a function parameter if that parameter is an object or an array you can D structure the properties that you're interested in right there inside the function parentheses where you define the parameters of the function alright spread and rest the three dots operator the three dot syntax here is magic if you use it with destructuring like this it's a rest operator basically you're capturing the rest of the array elements after the structuring the first one into another array so you use it to capture part of an array or an object and you can also use it later on to spread an array into another array so in here the three dot operator is spreading array one in two array two and introducing more items into already do and I'm spreading object two into another object you spread one object into another object cool so this is this is the spread syntax another important things is promises and async await so I told you a little bit about it this is more details here about promises and async await and we also talked about module important export a little bit more details here about named imports and named exports and default imports and default experts and the rest of this article here is just not modern JavaScript but more geared toward react so in react we use a lot map filter and reduce we use conditional expressions and we if you need to use timers you would need to use set time and set intervals there's some examples here about that so I do want to leave a few minutes for any lastminute questions but I'm gonna give you a little bit more what's next so I have this is not completely free but I'm writing but I think parts of it are so I'm writing this complete intro to node.js which is going to be a mini book for for you to start with nodejs it covers a lot of what we cover today in more details so this is a good next step if you want to venture into that and after that I have the node beyond the basics book which is gonna be a huge one I'm still working on that so it will hopefully be published in in the next few months but this is really the advanced book after you're done with just the basics this is what are you actually gonna learn no this is where you learn the modules and the eventdriven architecture in the stream that a child process and how to scale will cluster so deep dive into the node concepts that we mentioned today and there are a lot of them there's a lot of details now you can learn all of this through the official documentation just read the API documentation in fact this is how I learned stuff is just by reading the documentation in here and the examples are not too bad it's just when you when you put big things together and work through the context example that you relate to it's a lot easier to learn so that's what I'm doing in the next few months is I am fleshing out the beyond the basics book to have like one place where you can learn all the advanced stuff about node runtime itself not note packages but no runtime itself so I don't cover things like Express or lodash or socket IO I don't cover any packages I'm just focusing on what you get built in outofthebox with node and the capabilities that that gives you so you can build your systems on top of them because if you can avoid introducing a new package to your dependencies you should so you should not really bring in low just to summon array because you can summon array in three in two lines of in one line of code in in modern JavaScript right so you should avoid getting a dependency unless like your whole system is designed around that dependency for example you're using react you would have react as a dependency but think so many times before you introduce the dependency and if you can do it natively you should do it natively first all right cool so we're coming to an end so I'm gonna leave some time for questions so if you have any final last minute questions now is the time we've got seven minutes left so we have we can we can handle that so I'll give you a few minutes to type any questions that you have and I'll see which bits of JavaScript should you avoid if in node if possible oh man that is a big question so what should you avoid in node and the answer is not there's nothing special in node you should avoid bad JavaScript and JavaScript has a lot of bad parts right now modern JavaScript solved many of these bad parts right so you don't really have to deal with them but you should for example always use strict right so this is one thing so use strict is important so if you go in here by default node does not use strict by default so I can define a variable without var for example and that's bad you should not do that you should not be able to define a variable without far because JavaScript is gonna do the hoisting thing and confuse your code so this should not be allowed and you can put use strict in your in your files just use strict and this will make you know the strict mode this will activate the strict mode outofthebox for you but a better way to just adding this use strict everywhere is just to instruct node to always use strict and you there's a flag for that you can just do use strict and this flag is actually v8 so if you do use strict and you try to define a variable with that far that tells you you cannot do that a is not defined what are you doing if you want to define a variable you war or consulate right so this is a form of protection against bad practices in JavaScript is to always use strict and if you're using a bundler like for example if you're using babel by default babel is gonna use strict for you so or if you're using typescript for example you can tell type scripts you always use strict all the time assume strict mode and type scripts gonna give you errors into using type scripts into using a nonstandard or like bad practices in fact i would definitely advise you to explore typescript next because typescript is gives you a huge value but the problem is it also comes with a lot of package for you basically that you need to you need to deal with types you need to deal with missing tags you have to define you have to add write extra code but give it a few weeks not a few days give typescript a few weeks and after a few weeks of working with typescript you're gonna see the value typescript is on is next on my list of things to write about so we use typescript at JS complete and it is a huge value for us so in fact my next Pluralsight course might be on typescript and now definitely there will be in the future a book about typescript so try to use the good practices and try to have a type checker in your system but there's also es lint es lint is big so if you can't use typescript if it's a big decision for you just start with es lint and start with recommended rules for your system so es let is another code quality tool that you can use and it's it integrates into your editor so if you do something bad es lint is going to complain right away in your editor and it can also auto fix bad problems some bad problems for you so definitely take a look at es lint and configure your system to have you know the amended rules like for example a recommended rule is to always use semicolons this is recommended rule you should not write your javascript without semicolons unless you have in your flow something that will fix that most cases for you and warn you if you do you know if you if you do something like this because javascript is gonna assume you want to do that without a semicolon right so definitely yes lint is something that needs to be in your flow even if you're using typescript right es length is just a different different category of protection against you know what you should not be using in your code so I'm gonna stop at this point thank you all for attending and see you in other sessions