Data structures and algorithms are an important aspect of every coding interview. This algorithms and data structures course will teach you everything you need to prepare for placements, coding interviews, and logic building. This course walks you through multiple Java algorithms, data structure problems, and their solutions with stepbystep visualizations so that you're actually learning instead of blindly memorizing solutions. Dinesh Varyani created this course. He is an experienced cloud engineer at Google. Hello, friends. Do you want to learn data structures and algorithms through animations and implementation so that you can correct the coding interview? Hi, my name is Dinesh Varyani, and I am your instructor for this course. I have over 10 years of experience as a fullstack developer. Through this course, and by other means, I have helped over thousands of students just like you to improve on data structures and algorithms. So through this course, you will learn about singly linked list, doubly linked list, circular singly linked list, arrays, stacks, queues, binary tree, binary heaps, graphs, matrix, tries, tries, we will also look into its implementation by coding the algorithm in IDE. And what else? You will get much more than that through this course. So, friends, what are you waiting for? You can go to this playlist link provided in the description of the video where you will find all the videos that are part of this course. I update this playlist daily. So the only help I need from you is in case you like any of these videos, then please share this playlist with your friends and colleagues. And please subscribe to my channel. It will only motivate me to add more and more videos into this playlist. So friends, let's move ahead and begin this course. Thanks. Have a nice day. Hello everyone. So in this section, we will discuss about a basic introduction to data structures. So what is data structures? So if you see, it is a way to organize the data. Now what do we mean by that is when we want to program anything and we have a huge amount of data. So we basically take the help of data structures to organize the data into the memory. So why we organize the data? It is because after organizing the data, it becomes very easy to process it. Now what do we mean by that is, if we have an organized data, we can very much efficiently access and process it. So here let's say if we take an example. Let's say if you go to a library where you find these unorganized books. Now if someone asks you that bring a book related to algorithms from this unorganized books of let's say any particular author. So now you can see that as books are unorganized, there is a problem. Because in order to find a book related to algorithm for a particular author, you need to find that book in this unorganized books. So it will take a lot of time to find that book. Now let's say if this unorganized books are basically organized like this on a particular shelf. And now if somebody asks you that go and find a particular book related to algorithms of a particular author. So it would be very easy for you. You will just go to that particular section where the books related to algorithms are kept and you will just find that book. So here you can see that books can be related to the data. And when we organize these books, you can similarly relate it to the data structures where we are simply organizing the data so that it becomes easy to process it. So this is the basic introduction about what is data structures. Now let us see what are the types of data structures. So basically there are two types of data structures linear and nonlinear. Now when we talk about linear data structures, they have the data elements arranged in a sequential manner. And they are arranged sequentially so that each member is connected to its previous and next element. And as they are connected sequentially, it becomes easy to traverse them. And usually the traversal is a single level. Now these type of data structures are very easy to implement because they are stored sequentially in the memory. So some of the examples of the linear data structures are as follows. So here if you see array, linked list, stack and queue. So these are the linear data structures where the elements are stored sequentially and mostly they are single level. So the other type of data structure is nonlinear data structures. So if you see by this term nonlinear we mean that the data elements inside these data structures are not in sequence. They are basically connected to one another through different paths. And as in linear data structures they were single level. Here they are basically stored in multilevel. And as they are multilevel so in order to traverse each and every element in this nonlinear data structure takes some amount of time. Now as they are multilevel in order to traverse each and every element in this nonlinear data structure is bit difficult. And compared to linear data structures they are not easy to implement. So some of the examples of nonlinear data structures are tree and graph. So here if you see if we take an example of an array the data is arranged sequentially and it is basically in a single level so we can traverse it sequentially. So it is very easy to implement. But here if you see that nonlinear data structures are multilevel. So here it is an example of a tree where the topmost element is the root. So here if you see these data elements are connected through multiple paths and they are in multiple levels. So here we discussed about the data structures and we also discussed about the types of data structures which is linear and nonlinear. In linear few examples are array, linked list, stack, queue and in nonlinear we have tree and graph. So in our upcoming videos we will discuss more about the array, linked list, stack, queue, tree and the graph data structures. So I hope you like this video Thanks have a nice day. Hello everyone. So in this section we will discuss about a basic introduction to algorithms. So what is an algorithm? So if you see the formal definition of algorithm an algorithm is a set of instructions to perform a task or to solve a given problem. So what do we mean by set of instructions is that let's say we are given a problem so there would be a sequence of steps or there would be a set of instructions if we follow that our given problem will be solved. So let's say for example we are aware of a recipe book so it is nothing but a collection of recipes in which each recipe provides and step by step instruction to prepare the food. So let's say if someone asks you that provide me the recipe to prepare a tea so basically the steps inside that recipe would be the first step would be that we need to boil water second would be put tea in the teapot the third step would be that put that boil water into the teapot so after adding the hot water the fourth step would be that as we have hot tea so we just put that hot tea into the tea cups so the fifth step would be that do you need sugar so there is a choice if yes then put that sugar into the tea cups and if no then do nothing and the last step would be stir, drink and enjoy the tea so here if you see that this recipe of preparing a tea is very much similar to an algorithm which is nothing but set of instructions which help us to solve a given problem so here let's say we take an example that we want to print the average of 3 numbers so we are given 3 numbers and we want to print the average of it now let's say you want to write an algorithm to solve this given problem so the steps you would provide would be first you will perform the sum of 3 numbers stored at sum into a variable by name sum divide the value stored in sum by 3 and store the value into a variable average and finally print the value stored in the average so this would be the sequence of steps which you would perform to print the average of 3 given numbers and this set of instructions is nothing but an algorithm so here if we transform these 5 steps into the code then here we have a method find average where we are given 3 numbers a, b and c so we perform the sum of 3 numbers here we store it in a variable sum so here we are storing it here then we are dividing the sum by 3 so whatever the value is there in sum we are dividing it by 3 we are storing the value in variable average here and finally we are printing the value stored in average here so this sequence of steps is nothing but an algorithm and usually when we are given any particular problems we derive this sequence of steps and we try to implement it in particular language and write the logic around it and finally after performing all the steps properly the given problem is solved so friend this was the basic introduction to algorithms in our upcoming videos we will discuss the algorithms and data structure in great detail I hope you like this video thanks have a nice day hello everyone so in our previous section we discussed about a basic introduction to algorithms and data structure now in this section we will mostly discuss about the analysis of algorithm so what do we mean when we say analysis of algorithm so before that we saw in our previous section that an algorithm is a set of instructions which we use to perform a task or to solve a given problem so when we talk about analysis of algorithm this set of instructions are very much important and why they are important because in order to solve a given problem there can be several different algorithms so our analysis mostly deals in finding the best algorithm which runs fast and takes in less memory so why we actually do that because let's say we are given a problem and we have 2 to 3 algorithms to solve that problem but out of the 3 algorithms one algorithm let's say takes 1 second the other takes 5 seconds and the third one takes 10 seconds and similar with the memory so we usually do analysis of those 3 algorithms and we take that algorithm which takes the less time because if we take an algorithm which takes more time then slowly our system will degrade and we have these performance issues so let's say for example we are given a problem to find sum of first and natural numbers so then natural numbers would be 1, 2, 3, 4, 5, 6 and so on so 2 over method we are given a value n and we want to find its sum so let's say if we input n equal to 4 so the output we get is 10 that is 1 plus 2 plus 3 plus 4 so 1 plus 2 gives 3 3 plus 3 gives 6 and 6 plus 4 gives 10 so this is the sum of first 4 natural numbers and similarly let's say if we input n equal to 5 then we get output as 15 so when we do 1 plus 2 we get 3, 3 plus 3 we get 6, 6 plus 4 we get 10 and 10 plus 5 we get 15 so this is the sum of first 5 natural numbers now let's say we want to solve this problem and let's say we have these two programmers who come up with their own algorithms so Ramesh comes with one of the algorithms and Suresh comes with yet another algorithm so here Ramesh is trying to find the sum of first and natural numbers using the mathematical formula which is n into n plus 1 by 2 so here let's say if we input n equal to 5 so it will be 5 into 5 plus 1 by 2 so 5 plus 1 is 6 6 divided by 2 is 3 and 5 into 3 gives 15 so this is the mathematical formula which is directly using to find the sum of first and natural numbers and here Suresh has written one algorithm which is what we discussed in our previous slide that 1 plus 2 plus 3 plus 4 plus 5 so what he is actually doing is he is creating a variable sum initializing it with 0 and he is providing a for loop which starts from 1 so here i equal to 1 and this i will go till it is less than or equal to n and once this statement gets executed we are simply incrementing i by 1 so let's say if we input value of n as 5 so the start sum will be 0 so the start sum will be 0 so when this for loop will start execution i becomes 1 and we check that 1 is less than 5 or not so it is less than 5 then we simply add 0 with 1 because some initial value is 0 so 0 plus 1 becomes 1 and 1 is assigned to sum now after this line we increment i by 1 so i becomes 2 we check whether 2 is less than 5 or not so 2 is less than 5 the value of sum is 1 so we do 1 plus 2 we get 3 we assign 3 to the sum now then we increment i by 1 so i becomes 3 we check whether 3 is less than or equal to 5 or not so it is less than or equal to 5 so now as the value of sum is 3 we do 3 plus 3 we get 6 we assign 6 to the sum now so sum becomes 6 then we simply increment i by 1 so i becomes 4 4 is less than equal to 5 so sum value is 6 we add 4 to it so 6 plus 4 gives 10 and 10 is assigned back to sum and then we again increment i by 1 so i becomes 5 we check whether 5 is less than or equal to 5 or not so i is less than or equal to 5 so sum value is 10 we add 5 we get 15 we assign 15 to sum and then we increment i by 1 so i becomes 6 so now you can see 6 is not less than or equal to 5 so this for loop terminates and whatever value we have in sum we simply return so the value of sum is 15 we return 15 so friends here you can see these are the two algorithms which can solve our problem of finding the sum of first and natural numbers but there is no way to figure out that which algorithm is better than other so in order to determine the best algorithm among these two algorithms we usually check two things one is the time complexity that how much time these algorithms are taking to complete and another is the space complexity that how much memory this algorithm is taking to complete so here in this section we discussed about the analysis of algorithm and its formal definition in our upcoming lecture we will discuss more on what is time complexity and what is space complexity i hope you liked this video thanks have a nice day hello everyone in our previous section we discussed about the analysis of algorithm and we also discussed that there are two complexities which decides that how best is the algorithm so one is the time complexity and the other is space complexity so in this video we will discuss about the time complexity of an algorithm so what do we mean by time complexity so in the simplest terms that is the amount of time taken by an algorithm to run so lets say we have written an algorithm and we try to execute so when that algorithm finishes the amount of time taken by algorithm determines our time complexity so here usually an algorithm takes in an input and in order to process that input some amount of time is taken so an efficient algorithm will try to process the input very fast and a non efficient algorithm will take some more time to process the input so this processing of input by an algorithm helps in determining the time complexity so here in our previous example where we have these two programmers Ramesh and Suresh who have written these two algorithms so here the input is same for both the algorithms but here Ramesh is calculating the sum of first and natural numbers using the mathematical formula which is directly putting the values inside this formula and returning the sum of first and natural numbers whereas here if you see that whatever value of n we are providing we are simply running this statement that many times so in for loop it is running from 1 to a value less than equal to n so here let's say if the value of n is very large this statement will run that many times so the time taken by this algorithm will be somewhat more than this algorithm because here we are processing an input based on a for loop where where this line is executing n number of times and here we are simply using the value of n into this formula which is directly returning the sum of first and natural numbers so definitely this algorithm will be more efficient than this algorithm because the time taken by this algorithm will be less as compared to this and we will also discuss more about how to calculate this time complexity in much greater detail in our upcoming videos but for time being we just analyze that this algorithm will be much better than this algorithm because here there is only one statement which is a constant statement and here we are iterating in a for loop where this line gets executed for n number of times because this loop goes from 1 to less than equal to n so let's try to execute this code in Eclipse and see that how much time these algorithms are taking so friends here you can see that we have written this both the algorithms and inside our main method we are simply calling this find some method now here what we are simply doing is when we run this main method we are storing the current time in this variable then we are executing our find some method and at the last we are again calculating the current time and we are simply subtracting this time so we can get the time taken by this algorithm and if you see it gives the time in milliseconds so if we run this algorithm with a very large value of n you will find it will take almost no time because this is only a single statement where we are providing this value of n into this mathematical formula so if I run this so this is the sum of first and natural numbers of 99,999 and here you can see the time taken is almost 0 milliseconds now let's say if I comment this part and I uncomment this so now if I run this algorithm again so now this algorithm will be executed so here you can see the answer is the same but the time taken is almost 2 milliseconds so here you can see that though we have these 2 algorithms which solves our problem we usually do the analysis of the algorithms to get the best algorithm out of the options and also calculating the time taken by algorithm by this is also a not good idea because this depends on machine to machine so it is just giving us a rough estimate about the time taken by these algorithms but when we do analysis of algorithm there are different mathematical tools which can help us determining the time complexity of an algorithm so this was all about the time complexity of an algorithm I hope you liked this video thanks have a nice day hello everyone so in our previous video we discussed about the time complexity of an algorithm and we will discuss more on this in our upcoming videos so in this video we will discuss about the space complexity of an algorithm so the first thing which comes into our mind is what is space complexity so in simple terms you can say that space complexity is basically the amount of memory or space taken by an algorithm to run so friend let's say we have these 2 algorithms written by 2 different programmers Ramesh and Suresh now in order to determine which is the best possible algorithm one constraint is the time complexity which we discussed in our previous video the other is the memory required to process the input by an algorithm basically helps in determining the space complexity so usually we even measure that how much space this algorithm is taking and how much space or memory this algorithm is taking and whichever is taking the less memory we simply choose that algorithm because when we run these algorithms with a system having so many users it may happen that our memory gets exhausted so we try to fit in the best possible algorithm which takes less memory so here when we calculate the time and space complexity we never go into the exact numbers there are certain mathematical tools which help us in determining the time and space complexity of an algorithm and we usually term them asymptotic analysis of an algorithm in our upcoming videos we will discuss more about the asymptotic analysis and its notations and we will also discuss how we can use those mathematical tools to determine the time and space complexity of an algorithm I hope you have liked this video thanks have a nice day hello everyone so in our previous videos we discussed about the time complexity and space complexity of an algorithm we saw how time and space affects the performance of an algorithm but usually we don't go by the exact numbers that how much exact time an algorithm is taking or how much space in numbers an algorithm is taking so usually there are mathematical models which help us in determining the time and space complexity of an algorithm and the analysis which deals with those mathematical models we term it as asymptotic analysis so what do we mean by asymptotic analysis asymptotic analysis helps in evaluating the performance of an algorithm in terms of input size and its increase so lets say we are given an algorithm with certain input size we use this asymptotic analysis and determine the performance of an algorithm so this study also help us in determining lets say if the input size is less then how much time the algorithm is taking and if we increase the input size then how much time or space the algorithm is taking so usually when we do this asymptotic analysis we dont actually measure the actual running time of an algorithm this analysis simply help us in determining that how time and space taken up by algorithm increases with the input size so as we already discussed that if the input size to an algorithm is less then less time and space will be required by the algorithm to process that input and if we slowly increase the size of the input usually the time and space will also increase so this asymptotic analysis help us in determining that increase and also when we perform this analysis there are certain notations which we need to know to perform the asymptotic analysis so we will discuss about the asymptotic notations in our upcoming videos so in this video we simply discuss about the basic introduction to asymptotic analysis in our upcoming video we will discuss about the asymptotic notations and the types of asymptotic notations I hope you like this video thanks have a nice day hello everyone in our previous video we discussed about the asymptotic analysis and we also discussed about its basic introduction that asymptotic analysis help us in determining the runtime complexity and space complexity of a given algorithm so usually this asymptotic analysis is being done by asymptotic notations so what do we mean by asymptotic notations? so if we see the definition of it asymptotic notations are the mathematical tools used to describe the running type of an algorithm in terms of its input size so here we will discuss more on these mathematical tools that what are those and how it helps in determining the running time of an algorithm so in order to understand about this asymptotic notations we will take an example let's say you go to a car showroom where you want to purchase this car so mostly you will look into the design of the car and to the salesman you will ask one most important question what is the performance of car in 1 litre of petrol that how much this car travels in 1 litre of petrol so basically the salesman will never give you an exact answer he will simply give you the numbers based on certain conditions the car is running so he will simply tell you that if you are running this car on highway where the traffic is very minimum this car can give you 25 km per litre and if you are running it in a city where the traffic is max it will give you 15 km per litre and let's say if you are running for some amount of time in city and then in highway which means you are encountering an average traffic so it will give you around 20 km per litre so these are the 3 answers which salesman might give you when you ask about the performance of car in 1 litre of petrol so when we talk about an algorithm this asymptotic notations give us this rough idea that how an algorithm will be performing in certain situations so here the asymptotic notations help us in determining the best case average case and the worst case so you can simply relate this analogy to these conditions that best case would be that if you are driving on a highway the average case would be that you are driving in both city and highway and the worst case would be that you are simply driving in the city so this is how asymptotic notations provide us an in depth description about the running time of an algorithm in terms of its input size so in our upcoming videos we will discuss that what are the asymptotic notation types and how we can use those types to determine the running time of an algorithm in terms of its input size I hope you liked this video thanks have a nice day hello everyone so in our previous video we discussed about asymptotic notations and we also discussed that how asymptotic notations help us in determining the running time of an algorithm in terms of its input size and we also discussed that asymptotic notations help us in determining the best case, average case and the worst case and we also saw an example of a car that how the performance of a car in one litre of petrol differs in different situations so similar analogy is being performed on the algorithms where we determine the best case, average case and the worst case so there are types of asymptotic notations which determines these three cases so here you can see that there are three notations for performing the running time analysis of an algorithm the first notation is the omega notation which is being denoted by omega symbol the second is the big O notation and the third one is the theta notation so let's discuss about the omega notation first so if you see the definition of omega notation so this notation basically expresses the lower bound of an algorithms running time now what do we mean by lower bound of an algorithms running time so basically lower bound means that for any given input size this notation determines the best amount of time an algorithm can take to complete so by best amount of time we mean the lower time so therefore we denote it by lower bound and this determines the best case of an algorithm because omega notation provides us the best amount of time an algorithm can take to complete so as you already discussed that this is the best case analysis of an algorithm so what do you mean by best case let's say for example if you have written certain algorithm and if you say that algorithm takes 100 seconds as the best amount of time so what do you mean by that is that 100 seconds will be the lower bound of that algorithm and the algorithm can take more than 100 seconds to complete but it will not take less than 100 seconds to complete so the best case analysis takes the lower time and provide us with the information that a particular algorithm will take minimum let's say 100 seconds but will not take less than 100 seconds it can take more than 100 seconds but as the lower bound is 100 seconds it will be the best case for that algorithm so this notation is very least used because we are not interested in finding the best amount of time algorithm can take but this notation basically provides an information that what's the minimum resources we need to learn this algorithm the other notation is big O notation so this notation expresses the upper bound of an algorithm's running time now what do you mean by upper bound? upper bound means that for any given input size into an algorithm this notation determines the longest amount of time the algorithm may take to complete now what do we actually mean by the longest amount of time let's say for example that if we say that certain algorithm takes 100 seconds as the longest amount of time so 100 seconds will be the upper bound of that algorithm in big O notation the algorithm may take less than 100 seconds but it will not take more than 100 seconds so this is very opposite of the omega notation so when we say that 100 seconds is the longest amount of time that algorithm may take to complete then that would be the upper bound the algorithm may take 90 seconds, 80 seconds but it won't take more than 100 seconds so this notation is mostly used because we are very much interested in finding the maximum amount of time the algorithm may take to complete so that we can optimize that algorithm to whichever time we want so here the big O notation basically provides us the worst case analysis of an algorithm by worst case we mean determines the longest amount of time the algorithm may take to complete moving ahead the third notation is the theta notation now this notation basically expresses both upper bound and the lower bound of an algorithm's running time so what do we mean by both upper bound and lower bound it means that for any given input size to an algorithm this determines the average amount of time so basically the average case analysis is being determined by the theta notation so for example if we say that certain algorithm takes 100 seconds for the first run, 120 seconds for the second run and 110 seconds for the third run and so on so theta notation gives an average of running time of that algorithm so it basically determines the average of the upper bound and the lower bound of an algorithm's running time so this notation is also very leastly used because there are very rare use cases where we actually determine the average time taken by algorithm to complete so in this video we discussed about the three asymptotic notations which are being used to determine the running time of an algorithm and these three notations also determines the best case the average case and the worst case analysis of an algorithm I hope you have liked this video thanks have a nice day hello everyone so in our previous video we discussed about the best average and the worst case analysis of an algorithm and we also discussed about the three notation and we discussed that big O notation is the mostly used notation in analysis of the time and space complexity so in this video we will look into the analysis of time complexity in big O notation and we will also see certain rules in computing the big O notation so in our previous videos we discussed that big O notation provides us an upper bound of an algorithm's running time by upper bound we mean the longest amount of time an algorithm can take to complete so let's see some rules and assumptions when computing the running time of an algorithm using big O notation so let's say we are given a machine so we assume that it's a single processor machine so let's say the algorithm we have wrote, we are running it on the single processor and this processor is executing the algorithm sequentially now in an algorithm if we see any assignment operation then we simply assume that it can take one unit of time so this one unit of time can be anything, let's say one millisecond one nanosecond we simply term it as one unit of time so if we encounter something like this so we pretty much assume that it may take one unit of time if we encounter return statement we take it as one unit of time so something like this will be taken as one unit of time if we encounter arithmetical operation we take it as one unit of time so something like x plus y x minus y x divided by y x multiplied by y and many other operations we simply take it as one unit of time that this operation will require a single unit of time if we encounter any logical operation we simply take it as one unit of time so something like x and y x or y negation of x, negation of y x or operation so everything which deals with logical operation takes one unit of time and basically other small and single operation we simply take it as one unit of time now as we are computing the bigger notation of an algorithm based on the input size so we basically assume that we have a very large input size so let's say the time taken by algorithm comes out to be n2 plus 3n plus 1 so here n is nothing but the input size so here you can see that time is proportional to n2 plus 3n plus 1 so which is a polynomial equation so here what we actually do that in order to calculate the big O of this polynomial equation we assume that we have taken n as very large so if n is very large we can simply drop the lower order terms so the lower order terms would be 3n and 1 because n2 contributes more in determining the time taken by algorithm to run so we simply drop this lower order terms n2n2 we denote as O of n2 which is nothing but denoting it in the form of big O notation we simply say the time complexity comes out to be O of n2 so similarly there is one more rule we drop the constant multipliers so for example let's say the time taken by an algorithm comes out to be 3n2 plus 6n plus 1 where n is the input size so here you can see that 6n plus 1 is usually dropped because they are lower order terms as we are taking n as very large but here you can see that it also contains the constant multipliers like 3 6 so usually as n is very large we also drop the constant multipliers so here after dropping the lower order terms like 6n and 1 we also drop this 3 and we simply denote it by O of n2 so we deduce the time complexity in big O notation by following these simple rules so friends in our upcoming lectures we will apply these rules and we will compute the time complexity of few of the programs so that calculation of big O notation becomes more clear to you I hope you like this video thanks have a nice day hello everyone so in our previous video we discussed about the rules related to big O notation so now let's apply those rules and calculate the time complexity of a constant algorithm so here you can see that let's say we are given this piece of code where we are getting two integers we are doing the sum of it and we are returning the result so here you can see that these are the line numbers here where second and third line are the statements which get executed and here is a simple table provided with the line number and the operations getting performed on each line and the unit of time taken by each line so here we start with the line number 2 so here we are simply taking in two integers doing its sum and assigning it to the integer variable result so if we apply the rules which we discussed in our previous video so here first we are accessing x so it will be one operation then we are accessing y so it will be the other operation then we are doing the sum of it so this will be one more operation and then we are assigning it to the result so this will be one more operation so here we are simply performing four operations and we also discussed in our previous video that these four operations will take four units of time because we are providing one unit of time to assignment to arithmetic operation if we are accessing any variable so like that so line number 2 takes four units of time to execute this statement now let's see for the line number 3 here we are accessing the result so it will be one operation and then we are returning the result so it would be the other operation so there are total two operations and we know that when we are accessing a variable and when we are returning we provide one unit of time to one operation so total it will take two units of time and when we take the total time taken by this piece of code it will be 4 plus 2 which is 6 and usually if we see 6 is nothing but a constant because here whatever value you take of x and y it will always take a constant amount of time which is 6 so here time taken is nearly equal to a constant amount of time so similarly if we see this piece of code let's say we are passing in an array and we are passing in an index and we want to simply get the value stored at that particular index so here you can see that accessing a value of an array from a particular index takes in a constant amount of time so the time taken by this piece of code will be constant now irrespective of how many elements are there in this array let's say if array has 1 lakh element still it will take the constant amount of time and if the array has 1 element still it will take the same amount of time so therefore this is a constant algorithm so we simply denote the time complexity of such algorithm as o of 1 because this is the constant and usually in bigger terms we denote the constant by o of 1 and if we see the graph of this constant algorithm so here you can see the x axis denotes the volume of data so here you can think of it as the number of elements in this array and the y axis denotes the execution time which is the time taken so here we already discussed irrespective of number of elements or the volume of data inside this array the time taken will be always constant so we simply denote it as constant algorithm which takes constant amount of time even if the volume of data increases so in this video we discussed how we can calculate the bigger notation of a constant algorithm I hope you liked this video thanks have a nice day hello everyone in the previous video we discussed how we can calculate the time complexity of a constant algorithm so in this video we will now discuss how we can calculate the time complexity of a linear algorithm so here let's say we are given this algorithm and this algorithm basically finds some of the first and natural numbers which we also discussed in our previous videos so here we are given a value n so let's say for example if we take value of n as 3 so we want to find the sum of first 3 natural numbers so we start the sum with a value 0 we then apply a for loop where i is equal to 1 and we provide condition that i should be less than equal to 3 so at the first step value of i is 1 so 1 is less than equal to 3 so this condition comes out to be true so in the for loop we do 0 plus 1 and assign 1 to the sum and after this statement gets executed we do i plus plus so now i becomes 2 then we check whether 2 is less than equal to 3 or not so here 2 is less than 3 so then we do 1 plus 2 because value of i is 2 which gives 3 and we assign 3 to the sum now we again increment i by 1 so i becomes 3 and 3 is less than or equal to 3 so now we do sum of 3 plus 3 which is 6 and we assign it to the sum and then we increment i by 1 so i becomes 4 and we check this condition so 4 is not less than equal to 3 therefore this condition comes out to be false and this for loop terminates and we return the sum as 6 so here let's calculate the time complexity of this algorithm so here we have provided a table where we have marked the line numbers which actually gets executed and take some amount of time so if we start with line number 2 so here you can see that we are creating an integer variable sum and assigning it to value 0 so this will only take one step so the operation will be only 1 and the unit of time would be 1 so now we will count the operations at line number 3 so here you can see in the for loop we are creating an integer variable i with a value 1 so this would be one operation now here you can see that we are accessing n so this would be one operation we are accessing value i this would be the second operation and then we are comparing them so overall for one execution of this for loop this takes 3 operations so we need to calculate how many iterations this for loop will make so that depends on this incrementation here so let's say value of n is 3 so when i was 1 it took 3 operations then we incremented i to 2 so when i became 2 it took 3 more operations and then we incremented i by 1 so when i became 3 it took 3 more operations and then we again incremented i so i became 4 and here you can see that it took 3 more operations just to verify that i is less than equal to n or not so in total this statement executed 4 times we provided a value 3 and it executed 4 times so therefore when we have provided value n this will get executed n plus 1 times and as there are 3 operations in each step so the total operation would be 3 into n plus 1 so then we move to i plus plus so in i plus plus what we actually do we access value i we increment it by 1 and then we again assign it back to i so accessing i takes one operation incrementing it by 1 and assigning it back to i takes 3 operations so for the one iteration of this for loop this takes 3 operations so now we simply count that how many times this i plus plus will get executed so let's say if we take n equal to 3 the first time it executed it made i plus plus and i became 2 then we executed to make i 2 plus 1 which was 3 and finally we made it 3 plus 1 which is 4 so here you can see that for n equal to 3 this got executed 3 times so if we take value of n this will execute n times and as this takes 3 operations per iteration for n times it will take 3 n operations so here we are simply adding 1 to 3 into n plus 3 into 1 which is 3 and then we are doing plus 3 n so it will become something like this 1 plus 3 n plus 3 plus 3 n so the total unit of time it will take is 3 n plus 3 n 6 n 1 plus 3 is 4 so 6 n plus 4 so now we will see the time taken by the step 4 so here we are accessing i which is one operation we are accessing sum which is 2 operations which is 3 operations and we are assigning it back to sum which is 4 operations so for one iteration of this for loop it will take 4 operations and we know that this for loop will execute n times because i is travelling from 1 to n so this line will get executed n times so here in total it takes 4 operations multiplied by n multiplied by n so the total unit of time it will be 4 n so now we will calculate the time taken by line number 6 which is accessing sum and then returning the sum which is 1 plus 1 so total time would be 2 so if we add this unit times we get the total time would be 1 plus 6 n plus 4 plus 4 n plus 2 which will be equal to 10 n plus 7 unit times and also in our previous video we discussed that while calculating the big O notation we usually ignore the lower order terms because we assume that value of n is very large so after ignoring the lower order terms and we also discussed that we ignore the constant multipliers so here we ignore 10 also so the time complexity comes out to be O of n which means that time is directly proportional to the value n which is nothing but the input size so if we plot the graph of the execution time on the y axis and the volume of data which is n on the x axis we find that time is proportional to n so here you can see that if we plot this graph it will come in a straight line because the execution time is proportional to the number of input size which is nothing but our volume of data so as volume of data will increase the time taken by this algorithm will increase so this comes out to be a straight line so this is how we denote the time complexity of O of n which is a linear algorithm I hope you have liked this video thanks have a nice day hello everyone so in our previous video we discussed that how we can calculate the time complexity of a linear algorithm so in this video we will discuss that how we can calculate the time complexity of a polynomial algorithm so here we are given an algorithm and we are also given an integer n now what we are doing in this method is we have provided a for loop which goes from i equal to 1 to less than equal to n and it gets incremented by 1 for each iteration of this for loop and for each iteration of the outer for loop we have again provided a for loop which starts from j equal to 1 and goes till j is less than equal to n and it also gets incremented by j++ and inside this inner for loop we are simply printing the value of i and j on the console and after this inner for loop gets executed we are printing end of inner loop and after this outer for loop gets executed completely we are printing end of outer loop so here you can see if we run this code let's say for value n equal to 3 so here you can see that this gets printed on the console so in our previous video we also discussed that this outer for loop will go from i equal to 1 to i less than equal to n which is 3 so it will get executed 3 times the outer for loop and for each execution the inner for loop will also get executed exactly 3 times because j is also starting from 1 and j is also going till j is less than equal to 3 so here you can see that what it gets printed on the console so for i equal to 1 inner for loop gets executed n times so here you can see i equal to 1 i equal to 1 and i equal to 1 so for i equal to 1 the inner for loop will get executed n times where j will go from 1 to 3 so here you can see j equal to 1 j equal to 2 and j equal to 3 and after inner for loop gets executed end of inner loop gets printed which is here and once it gets finished the execution point reaches here does increment of i by 1 so i becomes 2 and we know that 2 is less than 3 so therefore again the inner for loop will execute from j equal to 1 to j is less than equal to n and this will get printed 3 times because the inner for loop will get executed n times so for i equal to 2 the inner for loop gets executed from j equal to 1 to 3 then we print end of inner loop here and then again i gets incremented to 3 and for i equal to 3 the inner for loop will again get executed 3 times and then here we print end of inner loop and then we again increment i by 1 so i becomes 4 and 4 is not less than equal to n so therefore the condition breaks and finally we print end of outer loop so here you can see that for each iteration of outer for loop inner for loop gets executed that many number of times from j equal to 1 to j is less than equal to n so here in this example as we have taken value of n as 3 so you can simply think that outer for loop gets executed 3 times and inner for loop will get executed 3 into 3 times which is 9 so here you can see that this statement gets printed 9 times for each value of i inner for loop gets executed from 1 to 3 for i equal to 2 it gets executed 1 to 3 for i equal to 3 it gets executed 1 to 3 so usually this statement at line number 4 gets executed n square times so let's see how many operations are getting performed on each line so for line number 2 so in our previous video we already discussed that how many times this for loop will execute so this assignment integer i equal to 1 will get executed exactly 1 time we are accessing i, we are accessing n and then we are comparing so this will get executed exactly n plus 1 times because so when we are providing value of n as 3 so when i becomes 4 this condition will come out to be false so therefore we provided value n and this will get executed exactly n plus 1 times this is the same stuff which we discussed in our previous video and then this i plus plus will also get executed 3 n times so this for loop will execute n times so it will take 3 n times and if we do the sum of it it will take 6 n plus 4 unit times now let's see about the operation taken by the inner for loop so here you can see the condition are exactly same so here we know that it will take 6 n plus 4 unit time the inner for loop because j is also getting started from 1 and it will also go j is less than equal to n and we are simply doing j plus plus so here line number 4 will get executed 6 n plus 4 unit of time but this for loop will also get executed multiple times based on the execution of outer for loop so if outer for loop runs n times the inner for loop will run n times of the outer for loop so which will give us 6 n square plus 4 n unit time of execution moving ahead at line number 4 we are accessing i we are accessing j and we are printing so there are total 3 operations and how many time it will get executed you can see for value of n equals to 3 it got executed 3 square times which is 9 so here the total operations would be n square times 3 which will give us 3 n square the line number 6 which is end of inner loop will get exactly printed n times so here if n was 3 it printed 3 times and for n time it will get printed n into 1 times which takes n unit of time and the line number 8 will get executed exactly 1 time so if we add all the unit times we get the total time would be 6 n plus 4 plus 6 n square plus 4 n plus 3 n square plus n plus 1 and if we add the n square terms and n terms and then the constant it will become 9 n square plus 11 n plus 5 so here as we assume that we take value of n to be very large we ignore the lower order terms and we also ignore the constant multipliers so we remove 9 also so if we want to represent the time complexity of this algorithm it would be O of n square because rate of increase of time is getting directly proportional to n square and if we plot the graph with time versus the input size it will give us a parabolic curve where execution time will increase by n square so here you can see that as volume of data will increase the execution time will increase n square times because time is directly proportional to n square so this is the graph for a polynomial algorithm so here you can see that this is a really bad algorithm because execution time is drastically increasing with the input size so usually we try to avoid the nested for loops because for each outer for loop inner for loop gets executed that many number of times so which you can see by the operation at line number 3 so here you can see based on the condition provided here inner for loop gets executed n times the outer for loop and also friend similarly let's say if we had one more for loop inside the second for loop this would have gone to n cube times based on if the condition here provided are same so it would have taken O of n cube time so which is also a polynomial algorithm and which is also really bad so here in this video we discussed about how we can calculate the time complexity of a polynomial algorithm I hope you like this video thanks have a nice day hello everyone so in this section we will discuss about the array data structure we will see a basic introduction to array and then we will discuss that how we can create an array, initialize an array and assign some values to an array so friends what is an array so here let's take an example of a chocolate box so you must have seen a chocolate box having these chocolates separated by the partitions and the containers so when we actually see it for the first time we get few things in our mind the number one is we can tell that it's a collection of chocolates or a box of chocolates and all the partitions which are holding this chocolate you can see they are adjacent or we can say they are contiguous because they are very next to each other and here you can also see that each partition has two neighbors except the first and the last one for example the second partition has one neighbor to its left and one neighbor to its right but the first and the last one they have only one neighbor for the first it is the right and for the last it is the left and when we receive this pack of chocolates the size of this box is fixed and cannot be modified so any chocolate making company will first create this box and based on how many chocolates they want to add into this box they will create that many partitions and once this box is created it cannot be modified and also we saw that these partitions are very adjacent to each other so therefore they are also indexed and can be determined by its position so looking at the box we can simply number a position and simply can ask that okay I need four chocolate or four chocolate because we know that these chocolates are very adjacent and they are inherently indexed so friends similar analogy can be applied over an array so here you can see that this is an array having four elements so we can say it is a collection of data elements of a particular type and here you can see that all the partitions which are holding this data have contiguous memory locations so they are very next to each other we can also see that those partitions have two neighbors except the first and the last one and we can also deduce that once we create an array we need to provide a size so when we provide a size we are given with an array and once it is created we cannot modify it so if you want a dynamic array there is some complex logic behind it which we will discuss in our upcoming videos so for now you can have an understanding that an array can hold some data elements and the size to hold the data elements is fixed and we cannot modify it and here you can see that these partitions have contiguous memory locations therefore each partition comes with an index so for an array of 4 elements usually the index starts with 0 and ends with number of elements inside this array minus 1 so which is the length of the array minus 1 so whenever we create an array basically we have an index associated with it which starts from 0 dimensional array it ends with the complete length of this array minus 1 so let's say length of array is 4 because we have 4 elements so the last index would be length minus 1 which is 4 minus 1, 3 so from this was the basic introduction to an array data structure that how it holds the element and how they are very much next to each other and basically they are indexed so this indexing of array also help us in accessing the value inside that container so we can simply do array of 3 and we will get the value stored at the third index so this is also one of the advantage of having the index data structure so for in this video we saw a basic introduction to an array data structure in our upcoming videos we will see that how we can create an array initialize an array add values to an array I hope you like this video thanks have a nice day hello everyone so in our previous video we discussed about a basic introduction to an array data structure so in this video we will discuss that how we can perform declaration and initialization of an array so here when we say declaration of an array we will first discuss about the one dimensional array so the one dimensional array can be declared via syntax we can provide a data type then we can provide the variable name and then we simply provide the square brackets so that we can come to know that this is an array so this is the one way the other way is we can provide any data type and along with that we provide the square brackets and then comes our variable name so for example let's say if we want to declare an integer array so we can simply provide int and then we can provide our own customized variable name so here I have just given it as my array and then the square brackets and similarly we can do something like this that int square brackets and then we provide the variable name so here when we declare an array in Java we can use both these syntaxes the most preferred use syntax is the second one because we can simply deduce that this is an array of integer data type by just looking at the int and the square brackets so this is the mostly used syntax to declare an array moving ahead now let's see how we can initialize an array so by initialization we mean that when we initialize an array we are simply providing a memory to the array elements so that now array can store the collection of data into it so the syntax for the one dimensional array is something like once we declare an array what we saw in our previous slide in the next step we can do we can give the variable name and we can use the new operator to initialize an array and then we need to provide the data type along with a size so we also discussed that when we create an array we need to provide a size once the array is initialized we cannot modify the size so by this statement we are actually telling that provide as an array of this particular data type whose size is whatever the value you have provided here so once this line gets executed we are provided with an array of fixed size and certain memories associated with this data type so that now we can use this array and store our data elements so for example we can write something as we have declared my array in our previous slide we can say my array equal to new the data type and in the square bracket we can provide the size so this will initialize an array of size 5 so we can add 5 elements inside this array and also friend usually we perform the declaration and initialization of an array in one go or in one step so the syntax for that is we can just combine the declaration and initialization in one step as we simply give the data type then square brackets then variable name equal to new data type for which we want to create an array and then the size the size and we can also use this syntax data type the variable name with the square brackets and then we can simply provide new data type and the size associated with it so for example we can simply create an integer array something like this so here using new operator this will create an integer array of size 5 so that we can store 5 integers inside this array so this is the other syntax so the most preferred syntax is the first one so just by looking at the statement we can come to know that this is an integer array because usually the square brackets are alongside with the data type and also friend there is one more way to declare and initialize an array along with its data elements is we can write integer square brackets, variable name and we can simply say curly brackets and we can simply provide the actual data along with it so here you can see that if we know that what data we want to store inside is an array before and then we can simply use this syntax so it will directly initialize this array with proper values such as 5, 4, 3, 2, 6 at index 0, 1, 2, 3 and 4 and here you can see it deduces the size by counting the number of elements we have provided inside this curly bracket so here as we have stored 5 elements this integer array will now have a size of 5 so in this video we saw that how we can declare and initialize an array with various syntaxes in our upcoming video we will discuss that how we can add an element or update an element inside this array using the index position I hope you like this video thanks have a nice day hello everyone so in our previous video we discussed about how we can declare and initialize an array so in this video we will go a step ahead that after declaration and initialization of an array we will see how we can add or update the elements in an array so friends here you can see let's say we have this method as array demo having few statements so when we execute these statements in Java we will see what happens to this array data structure so when we call array demo method so here you can see at the first line what we are doing is we are declaring and initializing an array of integer type having a size of 5 so when this line will get executed you will see that we have this variable name my array which is referencing an array of size 5 so you can see 5 partitions here and this array will also have a proper index starting from 0 and ending at length minus 1 which is 5 minus 1 which gives 4 so here you can see this array object is created inside the heap memory and using my array we have this reference which is pointing to this object so you can consider this reference as a remote control where using my array we can simply control this array inside the memory so using this variable and the indexes we have we can simply store or update the element inside this array so how we can do that let's see its demonstration so let's say at the first position we want to store our integer having value as 5 so how we can store that that we have this variable name and when we do square brackets and we provide this index so we are telling to this array via this remote control that please add 5 to index 0 so inside this partition here you will get a value as 5 and also friend before that when we initialize or create an array using this new operator you can see that initial values of the integer came out to be 0 so when we initialize an array this object doesn't know that what value this array could hold so it simply assigns the default value so for integer the default value is 0 and similarly let's say for other types such as float double it would be 0.0 for long it will be 0 for boolean it will be false and for a proper object it will be a null value because those are the default values for primitive and nonprimitive data types so here after giving the value 5 at index 0 we can access the index 1 via this index and we can assign the value 1 so it would look something like this that 1 is being stored here and similarly we can store it at index 2 value 2 at index 3 value 10 at index 4 and now friends you can see that we have assigned all the values inside all the containers now let's say if we want to update any value so we can simply access it the normal way and assign a new value so here at this line we have added 8 at index 2 here so if we again call this with a different value so 9 will over at this value and 8 will be gone and 9 will be at its place so this is just an update to an array and friends at the last step what we are doing is so here you can see that this integer array is of size 5 and we know that index starts from 0 so the last index would be 51 which would be 4 and now friends here what we are doing is let's say if we access my array and do something like this 5 so here you can see the 5th index is not there and if we try to assign a value 7 to it so once this line gets executed at runtime you will get this exception in java which says that array index out of bounds exception and it also gives a message saying index 5 out of bounds for length 5 which means that the length of this array is 5 which is the size and index 5 is basically out of bounds because in an array index starts from 0 so the last index would be length1 which is 4 so it simply says that index 5 is out of bounds for length 5 so this is the most common exception which we actually get when we try to work with an array data structure because sometimes it might happen that we wrongly access an index which is not present inside an array so friends this was all about adding or updating elements in an array now let's go to Eclipse and see the demonstration of this code I hope you liked this video thanks have a nice day hello everyone so in our previous video we discussed about how we can create initialize an array and we also discussed how we can add or update elements inside an array so in this video we will see the demonstration and working of the code which we discussed in our previous video so here we have this class array util and which has one utility method which prints the array on the console so this method we will be discussing in our upcoming videos in great detail so for timing just think that this will print the contents of an array so we have this method array demo so let's see the working of that code which we discussed in our previous video so at the first step what we did was we created an integer array we gave it a name as my array so we can provide any name and let's say we provide a size as 5 so from here we can see that this will actually create an array which would be of integer type and the values this array will hold will be the default values and these default values will be decided based on the data type and here we can see let's say if we call array demo method so when this main method will run this line will get executed and this array will be created with default values so let's say if I call print array here and we pass my array to it so here this method will be called and the contents of this array will be printed so if I run the main method now so here you can see it printed 0 0 0 0 so because we created an array of size 5 5 times 0 was printed because this integer has default value of 0 so for each partition this array had it stored a value 0 into it so friends in our previous video we also discussed that we have this my array which will be acting as our remote control to modify the array object inside the memory so what we can do is let's say we want to add a value of 5 at index 0 so this would be the syntax and similarly let's say I fill all the values for each and every index say 0 1 2 3 and 4 and let's say I give a different value 5 1 8 2 and 10 and if I call the print array method here after assigning this few values and if I run the code now you can see all the default values which were getting printed as 0 0 0 0 0 have been updated by 5 1 8 2 10 and let's say after assigning a value 8 at index 2 which is here what we can do is let's say I want to update this and I want to update it by 9 so I can do simply like this and if I run the code now again so you can see that only at index 2 the value was updated from 8 to 9 and also friend let's say if we try to access an index which is not in range of this size so let's say if we try to access an index which is not present inside the array let's say 5 and if we give a value let's say 26 and if I run the code now so friend here you can see that we got an exception saying array index out of bounds exception giving an index 5 saying that 5 is out of bounds for this array so here if you see when we do my array so the index starts from 0 and ends at size minus 1 which is 4 so here you can see that this array will go from 0 1, 2, 3, 4 so these are the indexes which we are using it here to access a particular container so that we can store these values so this array data structure inherently has this one variable by name length so if you want to know what is the length of any particular array we can simply use this value my array.length so let's say if I print this on the console and if I run the code now so here you can see it printed the length of this array as 5 because we have created the integer array of length 5 so usually when we get an array and if we want to just know what is the length of that array we can simply use this variable we can give the variable name.length and we will get the length of that array and similarly let's say if we want to access the last element of an array so what we can do is we can simply say my array and here you can see the last index is actually length minus 1 which is 4 so here we need to give the value as my array dot length minus 1 so here my array.length will give value as 5 and when we do minus 1 we can get the last index of this array and in order to access that element we need to provide the name of the array and then square brackets and inside the square brackets we can provide the actual index for which we want to access a particular value so if I run the code now you can see that it printed 10 because 10 is the value hold by the last index of this array and also similar to this what we can do is we can also create an array something like like this where we actually know what this array could hold so we can simply give the values as 5 10 8 and let's say 10 so this array will hold these values at the respective index starting from 0 1 2 3 so the length of this array is 4 and the index goes from 0 to 3 so if I print this array now and if I run the code you can see it printed 5 1 8 10 which are the elements present inside this array so friend in this video we saw few operations related to an array but how we can create an array and how we can add or update values inside this array I hope you like this video thanks have a nice day hello everyone so friend in this lecture we will discuss how to print elements of an array in java so here most of you know how to print elements of an array in java the only reason we are discussing this algorithm here is because in our upcoming lectures this algorithm will be mostly used so let's see the demonstration of algorithm by an animation so friends here you can see that we have this public method by name print array which takes in an array and to this array will iterate its element one by one using the for loop and will print its content on the console so let's see the demonstration of this algorithm so let's suppose we call the print array method by passing in an array so let's say we pass this array having 5 elements as 5 1 9 2 and 10 moving ahead so in the first step what we do is we take out the length of an array and store it in an integer variable n so here if you see as the array holds 5 elements so when we will do array.length the value 5 will be stored in n so it would look something like this the value of n is 5 moving ahead now friends in order to print each and every element of an array we need to iterate this array from the first index to the last index and as we know that the index of array starts from 0 so the value of i will be 0 because this is our starting point and we will iterate in a for loop till i is less than n so here if you see i will start from 0 and it should go to 4 so we want this loop to go from i0 to i4 so therefore we have provided this condition that i should be less than n it means for the last index 4 should be less than 5 because when i will be equal to 5 then we know that i has crossed the boundaries of this array therefore we will get an exception so we will iterate till i is less than n so here we will start with i equal to 0 so if we see in this array then i is pointing to the zeroth index moving ahead now in order to print the elements on the console we are doing system.out.print and in order to access the value at this particular index we do array then we provide this square brackets and inside that we provide the index for which we want the value so on the console it will print 5 because i is pointing to the zeroth index and array of 0 will give value as 5 moving ahead now we will increment i by 1 so i becomes 1 and now i will point to the index 1 and here we will check whether 1 is less than 5 or not so this boolean condition comes out to be true so the for loop executes and then we will simply print the value at first index which is 1 so it would look something like this moving ahead we will now increment the value of i by 1 so i will become 2 and it will point to the second index we will simply print the value at the second index which is 9 so it would look something like this moving ahead we will again increment the value of i by 1 so i will become 3 and it will point to the third index we will print the value we will print the value at the third index which is 2 so it would look something like this moving ahead we will again increment the value of i by 1 so i becomes 4 and it will point to the fourth index now and we know that 4 is less than 5 therefore the condition in for loop comes out to be true and then we will print the value as index 4 which is 10 so it would look something like this now we will increment i by 1 so i will become 5 so friends here we can see that 5 is not less than 5 therefore the condition in for loop comes out to be false and as we have iterated each and every element and printed it on the console we will simply exit this for loop and at the last step we will simply do a print line so which will bring the cursor to print stuffs on the console to the next line so friends this was a demonstration that how we can print the elements of an array in java so here we iterated each and every element using for loop from the start index to end index and we printed the contents of array on the console so now let's go to eclipse and see the demonstration of this code I hope you like this video thanks have a nice day hello everyone so friends in our last lecture we saw that how we can print the elements of an array in java and we saw the animation of the algorithm now in this lecture we will code the algorithm and we will see it's working through main method so here I will be creating one method as public void and will give the name to it as print array so this method will take in an array let's have integer type so now our task is to print elements inside this array on the console so what we do is we simply iterate each and every element of this array and print it's content on the console so in the first step what we do is we simply take the length of the array and store it in an integer variable n so why we do this because in order to iterate this array we will provide a for loop and we know that array starts from the zeroth index so we want to know that what the size or the length of the array so that when we are using the for loop to iterate this array we can give a range that iterates the for loop from start to end so the value of n is nothing but our end point so then we will provide a for loop and inside it for loop we will start our iteration from index 0 because in an array the storage of elements starts from zeroth index and we will traverse till i is less than n so let's say array is n elements so it will be distributed from the range of 0 to n1 so therefore we need to traverse from 0 to n1 so therefore we are providing this condition that i should be less than n and then we will simply do i++ each time in order to print the elements of an array on console we simply provide the system .out .print and inside this print method we will simply take out the value stored at the ith index and print it on the console so i will traverse from 0 to n1 so when it will start from zeroth index it will print the value stored at zeroth index then we will do i++ then it will print the value at first index and similarly at the last it will print the value stored at n1th index and after forlow we will simply provide the print line so this is the code to print the elements of an array on console so here now let's see the working of this code through main method so first we will create the instance of arrayutil class so now we will call the print array method by passing in an array so here we will call print array and we will simply pass an array so let's say we provide 5 elements whose value would be 5 1 2 9 let's say 10 so friends here we have created a new array and using these curly brackets we have provided that this array should have 5 elements and we are directly passing this array to this print array method so now let's run this code so here you can see that it printed 5 1 2 9 10 by iterating over the array one by one using this for loop so friends in this lecture we saw the working of this algorithm that how we can print the array elements on the console I hope you like this video thanks have a nice day hello everyone so in this video we are going to discuss that how we can remove even integers from an array now let's suppose we are given an array of integers we need to return an array with even integers being removed so for example let's say we are given the array such as 3 2 7 10 6 5 so here 2 is even integer 4 is even integer 10 and 6 are even integers now we need to remove those even integers and only return the odd numbers which is 3, 7 and 5 so let's see the demonstration of this algorithm step by step so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here is the algorithm which will help us removing the even integers from an array so the method name is remove even it takes in an array and returns an array in which the even integers are removed so let's say we take the example of the array having 7 elements 3 2 3 7 10 6 5 and let's say when we call remove even method by passing in the array this method actually starts its execution now how we can remove the even integers from the arrays first we actually count the number of odd integers in the array and why we count the number of odd integers is because we need to return an array having only odd integers by removing the even integers from the given array so at the start odd count is 0 now we provide a for loop and we traverse the array elements 1 by 1 so starting from i equal to 0 which is 0 index we go till i should be less than array.length so array.length is 7 because there are 7 elements and less than 7 means up till 6 so at the start i is actually less than array.length so friends how we can find the odd integers inside these arrays we can take the value at any particular index if we divide it by 2 and if the remainder is not equal to 0 it means it's an odd element so friends we know that even integers are 2 4 6 where if we divide the element by 2 let's say 2 divided by 2 so we get the remainder as 0 so the even integers when divided by 2 give remainder as 0 and if we take the odd integers 1 3 5 if we divide 3 by 2 we get remainder as 1 if we divide 5 by 2 we get remainder as 1 so if the remainder is not equal to 0 it means it's an odd integer so we will take the help of this modulus operator which will directly provide us the remainder and if it is not equal to 0 we will increment the odd count so at the start we get 3 3 divided by 2 will give remainder as 1 1 is not equal to 0 so therefore this condition comes out to be true and if the remainder is not equal to 0 we get remainder as 1 1 is not equal to 0 so this condition comes out to be true we will increment odd count because 3 is an odd integer so here it becomes 1 we will increment i now array of i which is 2 2 divided by 2 will give remainder as 0 so therefore this condition comes out to be false so this statement is skipped and we reach here again so we do i plus plus i becomes 2 now 4 divided by 2 will give remainder as 0 because 4 is divisible by 2 so this condition comes out to be false we will increment i again i becomes 3 so this condition comes out to be true now 7 divided by 2 will give remainder as 1 and 1 is not equal to 0 therefore this condition comes out to be true we will increment odd count because 7 is an odd integer we will increment i 10 divided by 2 will give remainder as 0 so this condition comes out to be false we will again increment i now 6 which is the array of i divided by 2 will give remainder as 0 so this condition comes out to be false we will again increment i now 6 is equal to 6 and it is less than array dot length because array dot length is 7 so this for loop will run so this for loop will run one more time we will take 5 5 divided by 2 will give remainder as 1 1 is not equal to 0 so therefore this condition comes out to be true we will increment odd count it becomes 3 now when we will increment i it will become 7 and 7 is not less than 7 so this condition comes out to be false and for loop will terminate so here you can see that when we traverse each and every element in the array we figured out that 3 7 and 5 are 3 elements which are odd and we need to return these 3 elements by removing the even integers from the array so therefore the array which we want to return will have only 3 elements which will be the odd integers so we will create the result array we pass in the odd count because we have calculated the odd count through this for loop so the result array will have only 3 elements now here we will create one index starting from 0 so this index will help us filling the result array so it will simply traverse the result array now here we will again provide a for loop which will iterate the array like we did here from i equal to 0 to i less than array.length so i starts from 0 now why again we are iterating the array and here providing the same condition to find out the odd integer is because once we find out the odd integers we will simply assign that value to the result array at a particular index so at the start 3 divided by 2 will give us a remainder as 1 so 1 is not equal to 0 so therefore this condition comes out to be true so it means we have found one odd integer so we will assign the value in the array at the ith index which is the zeroth index which is 3 to the result array at the index 0 so 3 will come here with this assignment now after we have assigned one value to this index we will increment the index because we need to fill the next value so index becomes 1 we will increment i 2 divided by 2 will give remainder as 0 therefore this condition comes out to be false and we skip this element we will again increment i i becomes 2 so value at second index is 4 4 divided by 2 will give remainder as 0 so this condition comes out to be false we will again increment i i becomes 3 now the value at third index which is 7 7 divided by 2 will give remainder as 1 1 is not equal to 0 therefore this condition comes out to be true it means we have found our second odd integer which is 7 so we will assign the value 7 to the result array as index 1 so 7 comes here we will increment the index we will increment i 10 divided by 2 will give remainder as 0 so this condition comes out to be false so friends here you can see that whenever we are encountering a even integer we are simply skipping that value and we are traversing ahead so when we increment i i becomes 5 6 divided by 2 will give remainder as 0 so this condition comes out to be false we will increment i 5 divided by 2 will give remainder as 1 so this condition comes out to be true because 1 is not equal to 0 it means we have found our third odd integer so we will assign 5 to the result at this particular index which is second index so 5 comes here and we will increment index so as we have filled all the values we will again increment i so when we will increment i 7 which will be going out of the boundaries of this array so this condition comes out to be false because 7 is not less than 7 so this for loop will terminate and at the end we will simply return the result so here you can see that we have removed the even integers from the array and we are returning a new array having only odd integers so when this was all about this algorithm the main idea behind this algorithm is to figure out the odd integers so we can take the number and when we will divide it by 2 if the remainder comes out to be 1 it means it's an odd integer and if it comes out to be 0 it means it's an even integer so why we calculate the odd count at the start because we need to find the length of the new result array so that we can create this new array of 3 values because the odd count is 3 and then we can perform the same steps again we will figure out the odd integer and we will simply assign that odd integer to the respective indexes 1 by 1 and at the end we will simply return the result so friends i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw an animation in which we discussed an algorithm that how we can remove the even integers from an array so in the problem statement we were given with an array of integers and our task was to remove the even integers from the array so in that video we saw the animation of the algorithm and in this video we will actually code the algorithm and we will test its working in the main method so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here in our previous videos we have discussed how we can print an array and in this video lets say if we are given with this array of integers and we want to remove the even integers from the array so the output would be 2, 4, 10 and 6 will be removed so it will give us 3, 7 and 5 so here you can see 2 is even integer, 4 is even integer and 10 and 6 are even integers so we need to remove those elements and return an array having only odd integers so now lets code the algorithm which we also saw in our previous video lets say I provide the method name as remove even so this method will take an array of integers and it will return back an array of integers in which the even integers will be removed so here the basic idea we do is first we count the number of odd integers in the array so for that we create an integer variable oddCount and then we simply traverse the array using a for loop so while we are evaluating oddCount we will see later so here how we can figure out whether an element is an odd integer or an even integer we simply take that element we divide that element by 2 and if the remainder is 0 it means its an even integer and if the remainder is not equal to 0 it means its an odd integer so here if array of i if we do mod 2 and it is not equal to 0 it means its an odd integer so 3 divided by 2 will give remainder as 1 so 1 is not equal to 0 it means its an odd integer so this modulus operator is helpful in determining the remainder so if remainder is not equal to 0 it means its an odd integer so we will simply increment oddCount and if it is an even integer then we simply skip so after knowing the number of odd elements what we do is, as we need to return an array of integers having only odd integers we will create a result array of size oddCount because we need to return these 3 elements so this oddCount after traversing each and every element will have value 3 because there are 3 odd elements 3, 7 and 5 so we need to return this array having 3 elements so we will create this result array of 3 elements so this is the reason we are evaluating oddCount here now after creating the result array we need to fill this result array with the respective odd elements so first we will create an index variable starting from 0 and then we will again iterate the array and we provide the same condition what we have done here so here if element at ith index mod 2 if it is not equal to 0 it means its an odd integer so we need to put this integer into the result array so in order to put the element into result array we need to find the index that where we need to put in the result array so for that we have created this index variable so this index variable starts from 0 so lets say if we encounter 3 so we need to put 3 at the 0 if we have encountered 7 then we have to put in the next index and if we have encountered 5 then we have to put in the next index so we will use this index variable to keep the track of these positions and after placing the odd integer at a proper index we have to increment the index as well because after putting 3 lets say at 0th index 7 will cover index 1 so we need to increment index as well and that will simply return the result so here you can see if the element at the height index is even we are doing nothing we are simply skipping it and if it is an odd integer then we are taking that integer placing into the result array at a proper index and then we are incrementing the index as well so now lets test its working in the main method so first we will print the original array if i run the code now you can see it has printed the original array now we will call remove even method we will pass the original array and it will return back a result array now this result array will have only odd integers so if i print it again if i run the code now so here you can see it printed 375 it has removed the even integers 2, 4, 10 and 6 so friend this was all about the implementation of this algorithm i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss how to reverse an array in java so friends lets suppose we are given an array and our task is to reverse the array so for example lets suppose we are given an array of integers having values as 2 11 5 10 7 and 8 so when we will reverse this array of integers it would become 8 7 10 5 11 2 which you can see below so friends lets suppose we are given a numbers array whose length is 6 that is having index from 0 to 5 and we want to reverse this array so here is an algorithm to reverse an array so lets see the demonstration of this algorithm step by step so in order to call the reverse array method we pass in the numbers array which we actually want to reverse we also provide a range in which we want to reverse the array so here as we want to reverse this complete array we give the start position at 0 and the end position numbers dot length minus 1 so here you can see the length of the array 6 and minus 1 becomes 5 so the end index is 5 because we want to reverse this complete array so when we call this method by passing in the numbers array which we want to reverse the value of start is 0 and the value of end is 5 so friends start and end is nothing but the range between which we want to reverse an array so the idea behind this algorithm is we usually take two pointers one is the start pointer and one is the end pointer so here you can see currently the value of start is 0 so we simply refer to the index 0 and the value of end is 5 so we simply refer to the value at index 5 so the values which start and end hold are nothing but the indices of the array which is nothing but the range so here we actually want to reverse this array from the start position to end position so let's see it's working so in the first step what we do is we actually provide a while loop and the condition we provide in the while loop is we check whether start is less than end or not so here value of start is 0 and value of end is 5 so here in the condition in while block comes out to be true so friends what we actually do is we simply swap the value at start index with the value at end index because we want to reverse this array so we actually reverse this array by making swap pairwise between start and end index so here in order to swap these two values first we will create a temporary variable to store the value at the start index so it would look something like this so the value at start index is nothing but 2 so we are storing it in temporary variable moving ahead now as we have stored this value in the temporary variable we can simply assign the value at end index to the start index so it would look something like this so now value at index 0 is 8 moving ahead and now we will simply assign the value stored in temporary variable to the end index so it would look something like this so the value in the array at the end index now becomes 2 moving ahead so friends here we have swapped these two values which are being referred by the start position and the end position so after we have swapped these two values now we simply increment the start by 1 and we decrement the end by 1 so here we are incrementing the start by 1 so as start is holding the value of 0 it becomes 1 so now it will refer to the index 1 moving ahead and then we will decrement the end by 1 so as end is having value of 5 now it becomes 4 and now it will point to the 4th index in the while loop we will again check whether start is less than end or not so here you can see value of start is 1 and value of end is 4 so therefore the condition in while block comes out to be true and now we will simply swap these two values which are being referred by start position and end position so first we will store the value of array at start index into the temporary variable so now time becomes 11 and then we will simply assign the value stored in array at index 4 to index 1 so it would look something like this that the value in array at start index now becomes 7 moving ahead and now we will simply assign the value in temporary variable to the end index of the numbers array so it would become something like this that the value in numbers array at the end index becomes 11 moving ahead now as we have swapped these two values we will simply increment the start by 1 so the value of start is 1 now it becomes 2 and now simply start will point to the index 2 moving ahead and will simply decrement the end by 1 so currently the value of end is 4 so it will become 3 and now end will point to the index 3 moving ahead now again condition in while block comes out to be true because 2 is less than 3 so now we will swap these two values so we will assign the value at index 2 to temporary variable so now temporary variable is having value as 5 and then will simply assign the value at index 3 to index 2 moving ahead and finally we will assign the value in the temporary variable to the numbers array at the end index so it becomes something like this and finally we will increment the start by 1 so start becomes 3 and now it will point to the third index moving ahead and then we will decrement the end by 1 so end becomes 2 and it will point to the second index so now in while block we will again check whether start is less than end or not so here you can see the value of start is greater than end so therefore the condition in while block comes out to be false and also friend here you can see that is array is completely reversed so friend the idea behind this reversal algorithm was to actually take the two pointers one would be the start position and one would be the end position and we simply kept on swapping the values and then incrementing the value of start by 1 and decrementing the end by 1 so we performed this operation till start was less than end so as soon as start becomes equal to end or greater than end then we have actually reversed the complete array friend here we saw an example with an array of even number of values so we actually swapped in pairs but if it took an array of odd numbers of element then also this algorithm will work fine because because the middle element will always retain its place when we are reversing an array so friend let's go to eclipse and see the working of this algorithm so friend in our previous tutorial we saw the demonstration of how to reverse an array in java so in this tutorial we will actually code the algorithm for reversing an array so here I have created one class by name reverse array and this class has a starting method print array which will actually take an array and print its elements on the console and in the main method I have taken the same array which we discussed in the slide so initially if I run the code now you see it prints the values in the array as 2,11,5,10,7,8 and now we will write the code to reverse this array so we will create a static method public static void reverse this method takes in the array which we want to reverse and it also takes the range that from which position to which we want to reverse the array so it actually takes the start position and the end position between which we will reverse the elements of the array so the first step will provide a while loop and we will iterate till start is less than end and in this value we will simply swap the values at the start index and the end index of the array so first we will create a temporary variable and to this temporary variable we will simply assign the value at the start index of array and then we will simply assign the value at the end index to the value at start index and finally we will assign the value of the temporary variable to the end index of the array and then we will simply increment the start by 1 and decrement the end by 1 so friend this is the algorithm to actually reverse an array now lets test its working in the main method so here I will call reverse method by passing in the numbers array and the start position is 0 and end position is numbers.length minus 1 so between this range the array will be reversed and finally we will print the array so if I run the code now so friends here you can see initially the array was having values at 2, 11, 5, 10, 7, 8 so after reversing this array it became 8, 7, 10, 5, 11, 2 so friend in this tutorial we actually coded the algorithm to reverse an array in java I hope you liked this video thanks have a nice day hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss how to find minimum value in array so friend lets suppose we are given an array having few elements so our task is to find the minimum value in array so friend below you can see the algorithm to find the minimum value of an array so the name of the method is find minimum which takes in an integer array and which returns back an integer value which is nothing but the minimum value of the array so friend lets see the demonstration of this algorithm step by step and we will take the input array which is given in this slide so friends in first step what we will do we will create an integer variable and we will give it the name as min so this min variable will always hold the minimum value of the array so at the start what we do is we simply take the first element of the array and we will mark it as the minimum value of the array so here min will have value as 5 and at the start we will treat the first element as the minimum value of the array so friends the basic idea behind this algorithm is now we will provide a for loop which will start from the index 1 and which will go till the last element of an array and inside this for loop we will compare each and every element of the array with the min value and lets suppose if we find any value of array which is less than the min value we will simply update the min with that particular value so we will start this for loop with i equal to 1 so here the value of i basically represent the index of the array and we will check whether i is less than the length of the array or not so here you can see the length of array 6 and 1 is less than 6 so the condition in for loop comes out to be true so in the if block now we will check that whether the value at index 1 is lesser than the min value or not so here you can see 9 is not less than 5 therefore the condition in if block comes out to be false now we will increment i by 1 so i becomes 2 so now we will compare the value at index 2 which is 3 with the min value which is 5 so here you can see 3 is less than 5 therefore condition in if block comes out to be true so for an inside is array we have found a value which is less than the min value so at this step we will simply update the min with the value which we found as the minimum value so now min will become 3 so after this assignment our new minimum value becomes 3 now we will again increment i by 1 so i becomes 3 we will compare the value of array at index 3 which is 15 with 3 and we will check whether 15 is less than 3 or not so here you can see 15 is not less than 3 so the condition in if block comes out to be false we will again increment i by 1 so i becomes 4 and then in if block we again compare that value at index 4 which is 1 is less than minimum value or not so here you can see the value at index 4 is 1 and we know that 1 is less than 3 therefore condition in if block comes out to be true and we have found one more element which is less than the minimum value so here in the if block we simply update the minimum value with a value which we found to be the minimum so now min will become 1 so after this assignment our updated minimum value would be 1 now we will simply increment i by 1 so i becomes 5 so now here we will compare the value at index 5 which is nothing but 2 with the minimum value which is 1 so we will check whether 2 is less than 1 or not so here condition in if block comes out to be false because 2 is not less than 1 because 2 is not less than 1 and then we will simply increment i by 1 so i becomes 6 so when i become 6 we know that i has crossed the boundaries of the array so the condition in for loop comes out to be false and the for loop terminates so after the for loop completes whatever the value min will hold it would be the smallest value of this array so at the last i will simply return this minimum value which is nothing but 1 so from in this tutorial we actually saw the demonstration to how to find a minimum value of an array now let's go to eclipse and see the working of this code hello friends in our previous tutorial we actually discussed how to find a minimum value in an array we saw the demonstration of the algorithm step by step now in this tutorial we will actually code the algorithm and we will test its working in the main method so here i have created one class by name main and here i have created one class by name main in the main method so here i have created one class by name main array with a main method and here i have created one array which we saw in the slide and then i have initialized this main array class so let's write the code to find the minimum value of an array so first i will be creating a public method whose return type would be the integer and the name of the method would be minimum now this method will take an array and we have to find the minimum value of this array and we will simply return it from this method so friends in the first step what we will do we will simply provide an edge case we will check that whether array is null or not so if array is null or array.length is zero we will simply throw an illegal argument exception stating that invalid input so here if the array is not equal to null and array.length is not equal to zero then we will create one integer variable we will give it name as min and we will assign the first value of array to it so here min will hold the minimum value of array and here we are simply assigning the value of index zero to min and treating it as a minimum value so now we will provide a for loop and we will iterate over each and every element of array starting from one and we will iterate till the end of the array so inside this for loop we will simply provide a if condition and we will check that value of array IH index is less than min or not so if the value of IH index is less than min we know that inside the input array we have found a value which is less than the current min value so inside this if block we will simply update the min value to be the value of IH index and after iterating over each and every element and checking this if condition when the for loop terminates we simply return the min value so friend this is the algorithm to find the minimum value of an array now lets test its working in the main method so here after creating an array and initializing this class we will simply call find minimum method and we will pass array to it and whatever value this find minimum returns we will simply print it on the console so if I run the code now you can see it printed one so here you can see one is the smallest value inside this array so if I change the value to lets say zero and if I run the code now you see it printed zero because zero is the smallest value inside this array also friend if I pass null and if I run the code now you see it printed illegal argument exception saying that invalid input because we have passed null value for an array if I pass integer array array length is zero and if I run the code now you can see it again printed invalid input because array length is zero so friend in this tutorial we actually coded the algorithm to find the minimum value of an array and we also tested its working in the main method I hope you like this video thanks have a nice day hello everyone so in this video we are going to discuss that how we can find the second maximum value in an array so here we are given an array of integers we need to return the second maximum value now we have provided the array with some integers and the second maximum value and the second maximum value exists so for example we are given an input array 12, 34, 2, 34, 33, 1 so here if you see the maximum value is 34 here we have duplicate 34 so the second maximum value is 33 we have to return the second maximum value so despite we have duplicates value we need to return the second maximum value which is 33 here and the constraint is the second maximum value exists so we will be given with an array of some elements in such a way that the second maximum value will exist so lets see the demonstration of this algorithm step by step so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon to never miss any update now here is the algorithm to find the second max so when we will call the method findSecondMax and we pass in the array having 6 elements 13, 34, 2, 34, 33, 1 so friends the idea behind this algorithm is we create two variables one is the max and another is second max the maximum value in the array and the second max will hold the second maximum value in the array and using this for loop we will figure out which is the max and which is the second max and at the end we will simply return the second maximum value so at the start what we do is to max we assign the minimum integer value so that when we will compare max with the actual array value we can compare it safely and here integer.min value is actually equal to minus 2 1 4 7 4 8 3 6 4 8 so this is the integers min value which we are assigning to the max so if we have the lowest value and if we compare it with any of the value of the array then we can figure out that whether this max needs to be changed or not and similarly to second max we assign the integers min value so max and second max start from integers min value now we will provide the for loop which will iterate from i equal to 0 to i less than array.length so i will start from 0 index 0 is less than 6 which is array.length now we will take the first array value which is at 0th index which is 13 so we will compare that whether 13 is greater than our current max or not so as the current max is the minimum value of the integer 13 is actually greater than max now what it suggest is we need to update max to 13 because we have found one maximum value in this array till this point so this condition comes out to be true it means we have found a maximum value now here we need to update 13 to max because we have found a value which is greater than max so max will become 13 but before updating this part array of i to max when we will update array of i to max max will become 13 but but as max has changed to a new value whatever the max old value was it will become our second max so for example let's say if second max would have been 1 and max would have been 2 and let's say array of i is 13 for example so before assigning 13 to max we need to assign 2 and max because after this assignment second max will become 2 and max will become 13 so here as max has been updated to 13 whatever the value max had that will become our second max because that value is lesser than the actual max value so therefore we need to be careful while updating the max to array of i before updating max to array of i we need to assign the old max value to second max because this max will now become our second max so currently max value is integers min value and second max is also integer.min value so when we will assign max to second max the value won't change it will be still integer.min value and now 13 will be assigned to max so this value will be assigned to max so max will become 13 and when we are doing ahead we will increment i i becomes 1 1 is less than 6 now 34 is greater than max which means 34 is greater than 13 max value is 13 so 34 is greater than 13 so this condition comes out to be true and we know that when we will update max to 34 we need to assign the old max value which is 13 to second max so here before updating max to 34 we will assign its value which is the old max value to second max so second max will become 13 because this value comes here and max will become 34 moving ahead we will increment i i becomes 2 2 is less than 6 so friends here you can see that if we would have given an array of these two elements then max would have been 34 and second max would have been 13 so these two steps are critical when we will update max to any actual array value we have to assign that old max value to second max because as max is actually changing its value its old value will become our second max so currently array of i which is 2 it's not greater than 34 which is our max value so therefore this condition comes out to be false and the else part will be executed now why this else if condition is provided because let's say here value would have been 14 for example instead of 2 it would have been 14 so 14 is not greater than 34 and then we have provided else if condition where we are checking that there could be a possibility that 14 is actually greater than 13 which is our second max it means we have to update second max to 14 because if a value is not greater than max but this value can actually be greater than our second max so therefore after this condition we have to provide an else if we need to check whether array of i is actually greater than second max or not so currently 2 is not greater than 13 which is our second max so this condition comes out to be false we will increment i i becomes 3 3 is less than 6 which is array dot length now here you can see this is one critical step array of i is 34 34 is actually equal to max but not greater than max so this condition comes out to be false now in the else part the first if condition 34 is greater than 13 which is true and if it is true but still we can't update 34 to second max because we need to provide yet another condition in the end part which will check whether array of i should not be equal to max it means it is checking for the duplicate max value so let's say our max is 34 and if we have found 34 again so we have to compare this array value 2 over max and they should not be equal array of i should be greater than second max which is true but 34 should not be greater than the max which is 34 so this is false the overall condition with this end operator comes out to be false so therefore though 34 is greater than 13 which is this condition still we won't update 34 to second max because 34 is actually our max value which we have figured out here so therefore this overall condition comes out to be false we will increment i i becomes 4 4 is less than 6 now here you can see array of i which is 33 33 is not greater than 34 which is our max so this condition comes out to be false in the else if part 33 is greater than second max which is 13 so 33 is greater than 13 and we need to compare whether 33 should not be equal to max so 33 is not equal to 34 so therefore this condition is also true so therefore now we have found one contender which can be our second max which is 33 so this condition comes out to be true we will update second max to 33 moving ahead we will increment i i becomes 5 5 is less than 6 so this condition is true array of i which is 1 1 is not greater than 34 so this condition comes out to be false array of i which is 1 1 is not greater than the second max which is 33 so this condition comes out to be false and overall condition comes out to be false we will increment i so it will go out of the array boundaries i will become 6 so 6 is not less than 6 so therefore this for loop will terminate now and at the end we will return the second max which is 33 so friend this was all about how to find the second maximum value in an array i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we will discuss that how we can move all the zeros to end of an array so here we are given a problem that given an array of integers write a function to move all zeros to end of it while maintaining the relative order of the non zero elements so friends for example you can see that we are given with an array of integers 0 1 0 4 12 now our task is to move the zeros to the end of the array and we have to move it such a way that we have to maintain the relative order of non zero elements so here you can see that the first non zero element is 1 then its 4 and then 12 so we have to move this both 0 to the end of the array in such a way that this order is maintained 1 4 12 so the solution would be move the zero after that the first non zero element is 1 then 4 then 12 and both the zeros are at the end so lets move ahead and see the algorithm for it and we will see the demonstration of the algorithm step by step so here you can see that we are provided with this algorithm where the method name is move zeros which takes in an integer array and a value n which is nothing but the length of the array so when we will call move zero method and lets say we provide this array having the elements as 8 1 0 2 1 0 3 going from index 0 to 6 so therefore the value of n will be 7 because there are 7 elements moving ahead so here the idea behind this algorithm is that we usually take 2 pointers and lets say we provide name to it as i and j so one pointer basically focuses on the non zero elements and the other pointer focuses on the zero elements and when these two pointers where one is at non zero element and the other is at zeroth element we simply perform a swap so here you can see that we are starting from j equal to zero and i equal to zero and in this algorithm j will basically focus on the zeroth elements and i will focus on non zero elements so here you can see that value of j is zero so we are simply representing it as like this but it is basically storing an integer value zero moving ahead now friends as you want to travel each and every element of this array and try to move zeros to the end of the array we need to traverse complete array so we have provided a for loop where i will start from zero and this will go till the end of array where we provide this condition as whether i is less than n or not so value of n is 7 so i will travel till 6 and after each iteration of this for loop we will simply increment i by 1 and we also discussed that j will focus on zeroth elements and i will focus on non zero elements and we will perform the swapping of elements when j will point to zeroth element and i will point to non zeroth element so let's see the demonstration of this algorithm step by step so here value of i is zero and i is also less than 7 so the condition for loop comes out to be true so the first step we check that the value of ith index is non zero or not so here you can see the value of i is zero and the value at zeroth index is 8 so therefore this condition is true and we also check whether value of jth condition is equal to zero or not so here you can see value of j is also zero so the value at zeroth index is 8 therefore this condition is false and we also know that when this both the condition will be true then only we will perform the swap but currently the second condition comes out to be false because the value at zeroth index is 8 which is not equal to zero so we simply move ahead the value at jth index is 8 which is non zero so therefore we simply increment j by 1 so j becomes 1 and why we are traversing j by 1 because we need to find a value at any particular index which is zero so that j could reach there and we can perform this swap moving ahead now we will increment i by 1 so i becomes 1 and 1 is less than n therefore this condition also comes out to be true so for loop executes we check value at ith index is zero or not so value at ith index is 1 which is not equal to zero so this condition is true and we also check value at jth index so the value at jth index is also 1 but this condition comes out to be false because it is not equal to zero so therefore the condition in block comes out to be false and we check whether value at the jth index is zero or not so here you can see the value at jth index is non zero therefore this condition comes out to be true and we simply increment j by 1 so j becomes 2 now we will again increment i by 1 so i becomes 2 and also here you can see the value of i which is 2 is also less than 7 so therefore this condition also comes out to be true and for loop executes now here you can see the value at ith index is basically equal to zero therefore this condition comes out to be false and we don't evaluate this condition because of this AND operator so this if block condition comes out to be false and we are checking the value at jth index is zero or not so here you can see the value at jth index is zero so therefore this condition also comes out to be false because we have encountered zero and j should focus on zero the elements so that we can perform a swap so this condition comes out to be false and j stays at the same position now we will again increment i by 1 so i becomes 3 and 3 is less than 7 so for loop executes so here you can see that now we have encountered an interesting situation where j is pointing to zeroth element and i is pointing to a non zero element so this condition where the value at ith index is not equal to zero so this condition comes out to be true and the second condition also comes out to be true because j is pointing to value 2 and the value at second index is zero so therefore this condition also comes out to be true and overall if condition comes out to be true so now this if block will execute and we need to perform this swap so we are creating this temporary variable to store one of the values so we are simply storing the value at ith index into the temporary variable so 2 is stored into this temporary variable because we need to perform the swap so somewhere we need to store this value and now we are storing the value at jth index to the value at ith index so value at jth index is zero and we are assigning this zero to value at ith index so it would look something like this that zero will be assigned to the ith index moving ahead and finally we will assign the value showed in temporary variable to jth index so it would look something like this so here we have simply swapped these two values and after this swapping we again check that value at jth index is equal to zero or not so here you can see the value at jth index is 2 so we simply traverse j by 1 so j becomes 3 now we will again increment i by 1 so i becomes 4 and 4 is less than n therefore for loop executes so from here you can see the value at ith index is 1 which is not equal to zero so this condition is true and the value at jth index is equal to zero so this condition is true and the value at jth index which is zero is equal to zero so this both condition comes out to be true and when both condition comes out to be true we know that we have to perform a swap so we will store 1 into the temporary variable we will assign the value at jth index which is zero and we will simply assign it to the value at ith index so it would look something like this the zero has been assigned to the fourth index moving ahead and then we will simply assign the value stored in a temporary variable to the jth index because we need to perform this swap we again check what's the value at jth index so here you can see the value is 1 so 1 is not equal to zero therefore this condition comes out to be true and we will increment j by 1 so j becomes 4 so friends the whole idea behind this check is that we need to traverse j so that it reaches to any zeroth element so that we can perform a swap so here the value at jth index is nonzero therefore we are incrementing j by 1 so j becomes 4 we will increment i by 1 i becomes 5 and 5 is less than 7 so this condition comes out to be true and now here you can see the value at jth index is 0 the value at jth index is 0 so this condition is true but this condition is not true because value at ith index is equal to 0 so this condition comes out to be false and this if block will not get executed and now as j is pointing to the zeroth element so this condition also comes out to be false we will increment i by 1 so i becomes 6 and 6 is also less than 7 so the for loop will execute so in the first condition we will check whether value at ith index is 0 or not so here you can see the value at ith index is 3 3 is not equal to 0 so this condition comes out to be true and then we will check whether value at jth index is equal to 0 or not so the value at jth index is 0 therefore this condition also comes out to be true so we need to simply perform a swap so we will store 3 into the temporary variable and then we will swap 0 to this position by assigning value at the jth index to the ith index so this will become 0 and at the last step we will assign the value 3 to the jth index so 3 will come here and here we will simply check whether the value at jth index is 0 or not so value at jth index is nonzero so therefore this condition also comes out to be true so we increment j by 1 so j becomes 5 and here we will increment i by 1 again so i becomes 7 but now here you can see 7 is not less than 7 so the condition in for loop comes out to be false and this for loop will exit so after this for loop will exit so here you can see that this array had two 0 elements in the between and we have simply moved them to the end of an array by maintaining the relative order among the nonzero elements so when this is one of the simple algorithm to move the 0 elements to the end of an array now let's go to IntelliJ and see the working of this code so friends i hope you like this video and in case you have liked this video then please like, comment, share and subscribe my channel thanks have a nice day hello everyone so in this video we will simply code the algorithm and we will see that how we can move the 0 elements to the end of an array so here you can see that i have created on classes move 0s so this class is on main method and it calls the array demo method so where we have created this array which we also saw in our previous video and we have this one method print array which we already discussed in one of our previous videos so if i run the main method so here you can see it simply prints the array on the console as 8 1 0 2 1 0 3 so these are nothing but the elements of array which has 2 0 elements so we need to move this 2 0 elements to the end of the array by maintaining the relative order of the non 0 elements so let's code the method so we will create public void we give the method name as move 0 and as we discussed in our previous video this method will take 1 integer array and 1 value n which is nothing but the length of the array and we also discussed the idea behind this algorithm is we take 2 pointers let's say 1 as j which will focus on 0th elements and 1 pointer is i so here i will focus on non 0 elements and as we want to iterate each and every element of this array will provide this for loop where i will traverse from 0 and it will go to a value lesser than the length of the array which is nothing but the value n and after each iteration will simply increment the value of i by 1 so in for loop what we do is we provide a if condition and here we will check the value stored at ith index is not equal to 0 because i will focus on non 0 elements and if the value at jth index is equal to 0 because j will focus on 0th elements so if these 2 conditions are equal then we will simply perform a swap by taking a temporary variable so here we are assigning the value at ih index to this temporary variable and then we are simply swapping the value at jth index and storing it on the ih index and at the last step we are taking the value of the temporary variable and storing at the jth index so this will simply swap the value of the ih and jth index and after we perform swap we will provide one more if condition where we simply check that value at jth index is not equal to 0 so if the value at jth index is not equal to 0 we will simply increment j by 1 because that is not the value that j is focusing on j will only focus on the 0th elements so this is the condition so friend this is the algorithm to move the 0th elements to the end of an array now lets see the demonstration of it now after printing the array we will simply call move zeros will pass the array and will pass the value of ns array.length and after moving the 0 to the end of the array will simply print the array again and if i run the main method again so friend here you can see that initially array was 8 1 0 2 1 0 3 which had 2 0 elements and after we perform this algorithm where we are moving the zeros to the end of the array the value stored was like this 8 1 2 1 3 where both the zeros came to the end of the array and even the relative order of the non zero elements remain the same with 8 1 2 1 3 8 1 2 1 3 so here we simply coded an algorithm where we moved the zeros to the end of the array so friend this was all about this video in case you have liked this video then please like, comment, share and subscribe my channel thanks have a nice day hello everyone so friend in this lecture we will discuss how to resize an array in java so friend as you all know that when we initialize an array we provide a size that how many elements this array can hold and this size we have to provide when we are creating an array object but sometimes what happen that we don't know that how many elements can be there in an array at the time of initialization so therefore doing the resize of an array is a very common operation in many algorithms so for example when we use ArrayList inside the ArrayList we create an array of default size and when we add elements to that default size it gets stored in an internal array and as soon as we try to add one more element so internally what happens a new temporary array is created with a size more than that of the original array and then all the elements are copied from the original array to this temporary array and finally the original array points to this temporary array so friends now let's see the demonstration of this algorithm so here is the algorithm and let's say we have this array whose length is 4 because it can store 4 elements and here you can see that all the elements inside this array are filled so therefore there is no more additional empty space left to add more elements and if suppose if you want to add more elements what we do is we simply call this resize method by passing in an array and we provide a capacity that how much more elements you want when this resize is done so let's say we call this resize method by passing in the array and whatever the length we have let's say 4 we simply want to double the length so we pass the capacity as 8 so now this method will be called with the capacity as 8 and by passing this array moving ahead so friends once we initialize this array we can't add more elements to it so what we do is we create a temporary array for whatever the capacity we provided so here we will create a temporary array whose capacity or size would be 8 so now this temporary array will range from 0 to 7 storing the added elements which is nothing but the capacity of this array moving ahead now friends as we have created this temporary array our other task would be to copy each and every element of this array to this temporary array so in order to do that what we do is we provide a for loop which starts from 0th index and goes to the array.length1 index so here value of i will be 0 when this for loop starts it will simply point to the 0th index and we know that value of i which is 0 is less than 4 so therefore this for loop will execute and in the for loop what we will do we will simply copy the value stored at the ith index which is the 0th index to the temporary array at the ith index which is 0 so here what we are simply doing we are simply copying this value which is 5 to this temporary array at 0th index so it would look something like this so phi is copied here so now we will move ahead now we will increment the value of phi so i becomes 1 it simply means that we can use this i to point to the 1st index and value of i which is 1 is less than 4 so this for loop executes and now we will simply again copy the value at ith index which is the 1st index to this temporary array at 1st index so it would look something like this moving ahead we will increment the value of i by 1 so i becomes 2 it will point to the 2nd index now now we will copy the value at 2nd index to this temporary array so it would look something like this the 3 is copied from the 2nd index to temporary array at 2nd index moving ahead we will again increment the value of i by 1 so i becomes 3 so it will point to the 3rd index now and we know that 3 is less than 4 therefore this for loop will execute and finally we will simply copy the value stored at the 3rd index to this temporary array at the 3rd index so it would look something like this moving ahead we will increment the value of i by 1 so i becomes 4 and we know that 4 is not less than 4 so this condition comes out to be false so therefore for loop will terminate which actually makes sense because we have copied all the values of our original array to this temporary array so this for loop will exit and at the last step what we will do is here you can see that this temporary variable is pointing to this array object in a heap and our array is pointing to this object in heap so now what we will do whatever the value stored in this temporary array will assign to our original array so it simply means that we are reassigning this array to this array so it would look something like this that now this array will point to this temporary array which is nothing but pointing to an array object in heap so friends after this resize method gets executed our original array is pointing to an array having size as 8 but here you can see that there is issue with this code once the resize method gets executed completely here you will find this array will also get garbage collected because the return type of this method is void and we are not sending the value stored in this array from this method therefore whatever we did here will be garbage collected finally so instead of keeping this resize method as void what we should do is we should keep the return type of resize method as integer array and here after assigning the temporary variable to array we should return the value stored in the array variable so that whatever the value is returned from this method and whoever is calling this method should actually get a reference to this object in the heap memory so this is one step which is very much important and we must do that we should return the array after resizing it and also friend here you can see that we even don't need to do this reassignment here what we can directly do here is as we have copied all the elements from the original array to this temporary array and this temporary array has capacity of what we have passed we can simply return the value stored in this temporary array instead of assigning it to array variable and returning the array variable we can simply return the value stored in this temporary variable so friend this was the demonstration of how to resize an array using this animation now let's go to Eclipse and see the working of this code I hope you like this video thanks have a nice day hello everyone so friends in our previous lecture we saw that how we can resize an array through an animation now in this lecture we will code the algorithm and we will see its working inside this main method so in our arrayutil class here I will be creating one method as public void and I will give the name to this method as resize now as we discussed in our previous lecture this resize method will take the array which we want to resize and it will take the capacity to which we want to resize so this is nothing but an integer value so what happens here is let's say our array has size 4 and we want to resize it to 8, 10, 16 or whatever value we want we simply pass it here so in the first step what we do is as we have already created this array of a particular size we can't directly resize this array to this capacity so what we do is we first create a temporary array having the sizes the capacity we provide now after creating this temporary array what we do is we simply copy all the elements of this array to this temporary array so in order to copy all the elements of our original array to this temporary array what we do is we simply provide a for loop and inside this for loop we simply iterate each and every element of our original array so here you can see this for loop will iterate with a value of i as 0 and it will go till the length of our original array minus 1 and inside this for loop what we'll do is we'll simply assign the value stored at i as index of our original array to our temporary array at i as index so when this line will execute what it will do is it will go to our original array it will take the value from the i as index and then it will go to our temporary array to i as index and simply copy the value from our original array from the i as index to the temporary array at i as index so this copy will go from the 0th index and it will go to the last index of our original array which is array dot length minus 1 index so after we copy each and every element from our original array to this temporary array what we do is at the last step we simply assign the value stored in the temporary array to our original array so when this line will execute the temporary array which we created here which was pointed by this temp variable now our original array variable will point to this temporary array which has capacity of what we have provided here so after this method gets executed the original array has been resized to this capacity because at the last step we are simply assigning the value stored at the temporary variable to the array variable so initially this temp pointed to an array in an heap which had this capacity now what it means is our array will point to this array in heap so from this piece of code simply resizes the array so lets see the demonstration of it i will just copy this array initialization and i will just command this print array call here we will create an array we will give it a name as original and we will simply paste this part here so our original array has the size of storing 5 elements so lets say if we want to store more elements so we cant store here so then we have to resize this original array so what we do is here i will simply provide a sysout and here i will simply print the size of original array and lets say i provide a value as original dot length so friends if i run the code now so here you can see it printed the size of the original array is 5 now friends as we want to resize it what we do is we simply call the resize method we pass in our original array and lets say we want to resize this array to a capacity of lets say 10 and lets say we want to resize this array to a capacity of lets say 10 so we pass the value of capacity as 10 so friends after resizing the array we will simply print the size of original array after resize now what happens when i call this again the size of the original array after resize and i simply print original dot length so what it should print? it should print 5 or 10 so friends here it looks that we have resized this original array to a capacity of lets say 10 we have even copied the contents so we usually think that when we print original dot length here it should give the answer as 10 but if i run it you will see that it gives the answer as 5 so we have passed this original array here but when this method gets terminated this temporary array and everything will be garbage collected and when our call will reach this point the original array will be still pointing to this so what we do here is we have to return this array from this method and instead of void we have to give return type of the integer array so that here we can get this array as we are returning it from here and we can store it in the original and finally we can print the length of this original array and here if i run the code now you can see that now this original array is actually pointing to this resized array so friend this is one of the most smallest mistakes we usually make because we know that java is passed by value so we are passing the value stored in the original array here we are doing resize on this temporary array and this array variable and if you are not returning it back then this all will be garbage collected and our original will be pointing to this array only so here we are returning this array we are storing it here so now we have actually reassigned it to a different array by this line and when we printed the length of this original array now it gave the value as 10 and also friend what we can do is here instead of assigning it to array we can even return something like this because we have copied the content of this array to this temporary array so instead of assigning the value of this temporary variable to array variable we can directly return something like this and if i run the code now you can see it again printed the size of the original array after resize is 10 so here now we have actually resized this original array so friend this method is used very frequently in many other data structures which involves the array internally so friends i hope you like this video thanks have a nice day hello everyone so in this video we will be looking into a problem find the missing number in an array so here let's suppose we are given an array having n1 distinct numbers and basically in the range of 1 to n we need to find the missing number in it so it is a very famous interview question where you will see that we are given with numbers from 1 to n so this n could be let's say we are given with this array here you can see that there are 7 numbers ranging from index 0 to 6 so it is basically the array.length which is 7 and here you can see the range is from 1 to n so here you can see in these 7 numbers we are given a range from 1 to 8 and 1 number is missing in this so we need to find that number so for example here you can see 1 is present 2 is present 3 is present 5 is not present 6, 7 and 8 are present so basically we are given n1 distinct numbers which you can see here and 1 to n is the range so here it is from 1 to 8 so here n is 8 and in the array we are provided with n1 which is 7 numbers so we need to find 1 missing number so here the output would be 5 so this is the missing number from range 1 to 8 which we can see in the array so let's see how we can solve this problem so one constraint is we need to find it in O of n time complexity so let's see how we can find the missing number in this array so here you can see there is one mathematical formula which can help us in evaluating what's the missing number in the array so the mathematical formula is something like the sum of first n natural numbers which is 1 plus 2 plus 3 plus 4 till n is given by this formula that we simply do n into n plus 1 by 2 so for example if we want to do sum of first 4 natural numbers so we can do 4 into 4 plus 1 by 2 so this will give us 4 into 5 by 2 which is 20 by 2 which will be equal to 10 so here you can see 1 plus 2 will give 3 3 plus 3 is 6 6 plus 4 is 10 so this is the formula which help us in evaluating the sum of first n natural numbers so we will use this formula and find the missing number in the array so for example let's suppose we are given with this 4 numbers so if we do array.length we will get 4 numbers and as we are getting 4 numbers the range will be from 1 to 5 so here you can see the 4 numbers are 1, 2, 3 and 5 so the missing number is actually 4 so now how we can find the missing number is first the number of elements are 4 which are present in the array we do plus 1 to it so 5 will be the actual final range so what we will do here is we will use this formula to calculate the sum so we will get 5 into 5 plus 1 by 2 so this will give us 30 by 2 15 so the sum of first 5 natural number is 15 and in order to find the missing number what we will do is we will iterate this array 1 by 1 we will pick each element and we will simply subtract it from the sum and after subtracting all the elements whatever number will be left that will be our answer this is the sum of first 5 natural numbers and if we are subtracting 4 numbers from it the left over sum would be our missing number so for example first we encounter 1 so we do 15 minus 1 we get 14 then we encounter 2 so we do 14 minus 2 we get 12 then we encounter 3 so we get 12 minus 3 9 and then we encounter 5 so we do 9 minus 5 which will give us 4 so this 4 will be our answer so here you can see that this formula is very helpful in many coding problems and this is one such problem so here the missing number is 4 which we just evaluated using this mathematical formula now lets move ahead and see the algorithm for it so here you can see the algorithm is very simple so lets see the demonstration of this algorithm step by step using this array so before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so lets say we call find missing number method with this array and here you can see the size of this array or the length of this array is 7 ranging from index 0 to 6 so if length is 7 we know that the range would be from 1 to 8 and we need to find one missing number in it so first we evaluate total number of elements present in the range so if we do array.length we will get the numbers present in this array and if we do plus 1 because this array doesn't have that number which we need to find so we simply add 1 so n will be 8 and now we will use the formula and calculate the sum so it will be 8 into 8 plus 1 by 2 it will give us 8 into 9 by 2 which is 9 into 4 which is 36 so sum will be 36 and now we will iterate the array 1 by 1 using this for loop and inside this for loop we will subtract each number from the sum and at the end whatever the sum is left that will be our answer so lets see how first we get number 2 when we subtract 2 from sum sum becomes 34 then number becomes 4 34 minus 4 will give 30 then number will become 1 20 minus 1 will give 29 then number will become 8 29 minus 8 will give 21 we encounter 6 21 minus 6 will give 15 now number becomes 3 15 minus 3 gives 12 and at the last number becomes 7 so 12 minus 7 will give 5 and then this for loop will end and whatever the value is left in the sum that will be our missing number so here you can see 1 is there 2 is there 3 is there 4 is there 5 is not there 6, 7 and 8 are there so at the end we will simply return 5 so this question is frequently asked in the coding interviews and if you come up with this formula and in particular n into n plus 1 by 2 which is sum of first and natural numbers then you can easily figure out what is the missing number so friend this was all about this question I hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw an animation to find the missing number in an array where we were given an array having elements from 1 to n and in that one element was missing so our task was to find that missing number so in our previous video we actually saw the demonstration of this algorithm step by step so now in this video we will actually code the algorithm and we will test its working in the main method so here in our arrayutil class here I will be creating one method as public static let's say we give the method name as find missing number so this method takes in an array and it returns the missing number so the return type is int so here assuming the array is proper and it has various elements which are ranging from 1 to n and there is guaranteed one number is missing in the array and we need to find that missing number so at the start we first evaluate the value of n which is the last number of our range from 1 to n so that is evaluated using array.length so this will give us the length of the array and it has one missing number so we will do plus 1 to get the last number of the range and after knowing the value of n what we will do is we will use the mathematical formula to calculate the sum of first and natural numbers so here int sum we will use the formula as n into n plus 1 by 2 so after evaluating the sum of first and natural numbers what we will do we will iterate the array 1 by 1 and as we need to find the missing number what we can do is we can subtract each element from the sum and whatever the sum will be left that will be our final answer because this formula is giving us sum of first and natural numbers and among those first and natural numbers in the array we have n minus 1 numbers so if we subtract n minus 1 from the sum we will be left with the missing number so here we simply do sum equals sum minus number and after this for loop we will simply return the remaining sum which will be our missing number so now lets test its working in the main method here we are given with an array so here you can see the length of the array is 7 but the range is from 1 to 8 and we need to find the missing number so we will call find missing number we pass in the array and if i run the main method so here you can see it actually returned number 5 from this method it means 5 was the number which was actually missing so here you can see 1 is there 2 is there, 3 is there 4 is there 5 is not there 6, 7 and 8 are there so friend this problem is asked in many coding interviews where we can use 1 single for loop and this mathematical formula to evaluate the missing number from the range 1 to n i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so friends in this lecture we will discuss that how we can check that a given string is a palindrome or not so friends what is a palindrome string so a palindrome string is a string when we do reverse of it and compare it with the original string they both are same so for example let's say we are given a string madam so if we read this string in forward direction we get madam madam and if we read it from backward we get madam which is the same so therefore this string is a palindrome string so let's say we are given a method in which we are passing a string it should return true if the string is palindrome or it should return false if the string is not palindrome so friends in second example you can see that we are given a string that if we read it in forward direction we get that and if we read it from backward direction we get taht so here you can see that if we reverse that and if we compare the reverse string with the original string they are not equal therefore this string is not palindrome so friends let's see the demonstration of the algorithm step by step so here you can see that this is the algorithm where we are calling the method as palindrome and we are passing in a string and if the string is palindrome or not we are simply returning a boolean value that if a string is palindrome we return true and if it is not then we return false so let's say we call this palindrome method and we pass a string as madam so by looks of it you can see that madam is a palindrome string because if we reverse madam and compare it with the original string they both are equal so let's see how we can figure it out that whether madam is a palindrome or not so string word will hold the value as madam so friends in this algorithm what we do we take two pointers one we place at the start and other we place at the end and we just compare these two characters and if they are same then we move first pointer ahead and the last pointer backward and then we compare the second character with the second last character and if they are equal then we simply move ahead the first pointer and move backward the last pointer and similarly we keep on checking the value stored at these two pointers and if anytime these values are not equal we can come to know that the string is not a palindrome string so friends here in order to compare this string character by character we first convert this string to char array so in java string has this method to char array which returns a character array so it would look something like this the character array will store one one character at each index and it is in form of an array moving ahead so we will initialize the first pointer we will give it a name as start and it will start from the zeroth index so value of start is zero and we will also initialize an end pointer whose value will be word dot length minus one so here on a string if we do word dot length we get the length of the string so here we will get the length of the string as five because there are five characters and when we do minus one it simply means that this pointer will point to the last index so end value will be four five minus one will give four so friends we have got our two pointers and one is at start and other is at end now we will start comparing the character stored at start index and the end index using this while loop so this while loop will run till start is less than end so if the start becomes equal to end or more than end then we know that we have traversed this complete string so currently you can see that start value is zero and end value is four so therefore the condition while loop comes out to be true so friends we know the palindrome property that if we read the string in forward direction and if we read the string in backward direction both the string should be equal so friends means the first character should be equal to the last character second character should be equal to second last character and it should go on till we reach a midpoint and if any of these characters are not equal then we can come to know that string is not palindrome string so here we are comparing the character stored at start index and character stored at the end index so which is these two characters and we are checking that whether they are equal or not so if they are not equal we can straight away written false that string is not palindrome string but here if you see m is equal to m therefore the condition in if block comes out to be false so we have compared the first and the last character now we will proceed ahead to compare second character with second last character so for that what we need to do is we need to increment start and decrement end by one so here we will increment start by one so start will become one and then we will decrement end by one so end becomes three we check whether start is less than end or not so one is less than three therefore condition in while block comes out to be true and here we simply check that whether character stored at start index and character stored at end index are equal or not so as value of start is one it will point to this character and end is three so it will point to this character so we are simply comparing this character with this and here we know that these two characters are equal therefore the condition in if block comes out to be false and then we will simply increment start by one and decrement end by one so start becomes two and end becomes two so here we can see start and end will point to index two which is D and this is the only index left now and if we check whether start is less than end so here we can see two is not less than two therefore condition in while block comes out to be false and we don't compare this because even if we compare D with D we know that those are equal but as this is the only character left if we read the string from this point or if we read the string from this point this character will be at the same position so therefore we never check for start equal to end we simply do start should be less than end so here condition in while block comes out to be false and while loop terminates and as soon as while loop terminates if our execution point reaches here we know that the string is palindrome because we have compared every character from start to end so we finally return true therefore string madam is a palindrome string so for now let's see whether that is a palindrome string or not so here we call this palindrome method providing a string as that we will convert this string to character array by calling 2 char array method so it would look something like this let's set character array having length as 4 storing each character in each of the index of this array moving ahead we again create two pointers one starts from the beginning and other starts from the end so we create two integer variables start will give it a value as 0 and we create integer variable end which points to the last index and in order to get the last index we do word dot length minus 1 so word dot length is the length of the string which is 4 if we do minus 1 we get the third index which is this so end becomes 3 moving ahead we see whether start is less than end or not so here we can see 0 is less than 3 so condition in while block comes out to be true so now we compare the value at start index and the value at end index which is these two characters and we check whether they are equal to or not so if they are not equal then we can simply return false though string is not palindrome but here you can see t is equal to t therefore condition in if block comes out to be false so now we move start pointer a step ahead and we move end pointer a step backward and then we will compare these two characters so start becomes 1 and end becomes 2 so we check whether start is less than end or not so here we can see 1 is less than 2 so the condition in while block comes out to be true and then we will simply compare the value stored at the start index with end index so here you can see that h is not equal to a which means the condition in if block comes out to be true and we come to know that string is not a palindrome string because this should have been equal to make it a palindrome string but here h is not equal to a therefore condition in if block comes out to be true so finally we return false from this point that string is not true from this point that string is not a palindrome string so in this lecture we saw that how we can check that whether a given string is a palindrome or not we saw the demonstration of algorithm step by step now lets go to eclipse and see the working of this code I hope you like this video thanks have a nice day hello everyone so friends in our last lecture we saw that how we can check that whether a given string is a palindrome or not we saw the algorithm using an animation so in this lecture we will actually code the algorithm and we will test its working in main method so here I will be creating one method as public and we will test it in main method so here I will be creating one method as public and as we want to check whether a given string is a palindrome or not the method which we are creating should return a boolean value that whether a given string is palindrome or not we also provide the method name as is palindrome and into this method we provide a string lets say we give the name to it as word so friends here we are not seeing any edge cases so in order to check whether the given string is a palindrome or not what we do is we first convert this string to a character array by using the method provided in string class as 2 char array so this method returns a character array so whatever the characters are stored in this string it will be now in form of an array where each index will store one character also friends in last lecture we discussed that we are using two pointers to check whether the string is palindrome or not so one pointer will start from the beginning so to start we are providing a value as 0 another pointer will start from the end and to this we provide the value as word.length and then we will provide the value as word.length and in the last lecture So, word dot length minus one will give us the last index. So, now we will start comparing each character at start and end index. So, we will provide a while loop and we will iterate in this while loop till start is less than end. So, inside this while loop, the first step we do is, we check that whether character at start index is equal to character at end index. So, if they are not equal, then we can straight away come to know that string is not a palindrome. So, here we will simply return false because as you are starting comparing first index with the last index to make string palindrome, those two characters should be equal and if they are not, then we can simply return false. So, friend after doing this first comparison, what we do is, we move start a step ahead and we move end a step backward so that after comparing this, we compare the second character with the second last character, then third character with third last character and similarly till start meets end because we are incrementing start and decrementing end. Also friend, here you can see that when the value of start will be equal to end. This while loop will terminate and we know that inside this while loop, we never got any chance that character at start is not equal to character at end. So therefore, once while loop terminates, we can come to know that string is palindrome and will simply return true. So, friend this is the algorithm to check whether a given string is palindrome or not. So let's test its working in main method. So here we will create instance of string util class and here we provide a if condition, we simply check by calling this palindrome method and we pass the value as let's say madam and if it comes out to be true, then we simply print the string is palindrome or else we print the string is not palindrome. So friend if I run the code now, so here you can see it printed the string is palindrome because if we reverse madam and if we compare with the original string, they both are equal. Now friend let's say if I provide the string as that which is not a palindrome string because if we reverse the string, we get t a h t which is not equal to our original string. And if I run the code now, you can see it printed the string is not palindrome. So friend this lecture we wrote the code to check whether a given string is a palindrome or not. We tested its working in main method. I hope you like this video. Thanks have a nice day. Hello friends, welcome to my new data structures and algorithm in Java tutorial series video. Friends in this tutorial we will discuss how to create a singly linked list in Java. So friends here you can see a simple singly linked list. In our previous tutorial we discussed what is a singly linked list. We discussed singly linked list is a data structure which actually stores collection of data. It contains sequence of nodes. So here you can see that there are four nodes having data as 10, 1, 8, 11 and you can also see the first node is being referred by the head. So this head node actually holds complete linked list and it is also the first node of the singly linked list. And you can also see the last node whose next always points to null because it signifies that it is the end of the list. We also discussed the node is having two properties. One is the data property and one is the reference to the next node in the list. So friends let's see a demo to how to create this singly linked list having the data as 10, 1, 8 and 11. So friends here is the code which can add few nodes in the singly linked list. We will also discuss the other ways to insert the nodes into the singly linked list. So let's see the demo of the code step by step. So friends when we initialize the singly linked list it contains instance variable head which is of type list node and when we initialize the singly linked list usually head points to null because at the initialization of the singly linked list there are no elements into the list. So at first head points to null moving ahead. Now in this step what we do is we first create a new list node and we pass the data into it. So here we are creating a new list node and we are passing the data as 10. So it would look something like this. Here you can see the data is 10 and whenever we create a new list node it next points to null and also here you can see when we are creating this new list node we are assigning its value to the head. So currently head points to null and after this assignment it would look something like this. So now head will point to this first node which is having data as 10 and its next is pointing to null. Moving ahead and in this step we are again creating a new list node and we are assigning its value to the list node by name second. So it would look something like this. That second is pointing to a list node having data as 10 and whose next is pointing to null. Moving ahead now here similarly we are creating third list node having data as 8 and we are naming the variable as third. So it would look something like this. The third is pointing to a node having data as 8 and whose next is pointing to null. Moving ahead and now we are creating a list node having data as 11 and we are assigning its value to a list node by name fourth. So here you can see the list node fourth is having data as 11 and whose next is pointing to null. So this is how a list node is created. We create a list node by passing into data and whose next always points to null. So friends in order to create a singly linked list what we do is like we connect all these four nodes together and form a chain. So this chain is built something like this. We connect first node to second, second to third, third to fourth like that. So in order to achieve this what we do is here we know that head points to a node having data as 10 and whose next is pointing to null. So in order to connect these two nodes what we do is we assign the value of second to heads next. So here you can see second is pointing to node having data as 1 and head next is pointing to null. So if we assign the value of second to heads next. So instead of pointing to null now it will point to second node because second is pointing to this node moving ahead. And now in this step what we do is we assign the value of third to seconds next. So here seconds next is pointing to null and third is pointing to a node having data as 8. So whatever value is in the third we assign it to seconds next. So it would look something like this moving ahead. And in the final step what we do is we assign the value of fourth to thirds next. So this fourth list node is pointing to a node having data as 11 and whose next is pointing to null. So we simply assign the value of fourth to thirds next. So it would look something like this. So now finally the third node is pointing to a node 4. So friends when method ends all these three nodes go away and as head is an instance variable of the singly linked list it is holding this complete list together. So friends let's go to eclipse and see the working code. So friends in our previous tutorial we created a class by name singly linked list. And to this class we provided an instance variable of the type list node by name head. So here the instance variable list node by name head will actually hold the linked list for us. And friends we also created one static inner class list node in our previous tutorial whose constructor only took the data part. So now let's move ahead and create a singly linked list what we actually saw in the slide in the previous tutorial. So we will create a main method. So inside this main method first we will initialize the singly linked list. So friends as soon as we say initialize the singly linked list the value of head is null. So here we will create the four nodes what we actually saw in the slide in the previous tutorial. So to head we will assign newly created list node having data as 10 then we will create a second list node having data as 1 then we will create a third list node having data as 8 and finally we will create a fourth list node having data as 11. So friends here we are having four nodes. Now we will connect them together to form a chain which is nothing but our singly linked list. So in order to form a chain we will first assign the value of second to heads next because currently head next is pointing to null. So so this would make structure something like this. Moving ahead we will connect second with third by assigning value of third to second next. So it would make structure something like this. And finally we will assign the value of fourth to thirds next in order to connect third and fourth. So third next will assign the value of fourth to it. So it would make structure something like this. So here you can see that we have connected all these four nodes together. So it would look something like this that 10 is pointing to 1, 1 is pointing to 8, 8 is pointing to 11 and finally 11 next is pointing to null because there are no more nodes we have attached to this fourth node. So friends this is how we connect the nodes of a singly linked list together. In our upcoming tutorial we will discuss a more generic way to insert the node into singly linked list. I hope you like this video. Thanks have a nice day. Hello friends welcome to my new data structures and algorithm in Java tutorial series video. Friends in this tutorial we will discuss how to print elements of a singly linked list in Java. So friends let's suppose we are given the singly linked list having four nodes with the data as 10, 1, 8 and 11. So in this tutorial we will discuss how we can print the data of the elements of the singly linked list. So below you can see the algorithm of it. So currently in the console you will see no output. So let's see the demonstration of this algorithm step by step. Now on the first step what we do is in order to print the elements of the singly linked list we need to traverse each and every node one by one and we are given the head node which is the first node of the singly linked list. So we actually start traversing from this first node only. So in order to start traversing from this head node what we do is we temporarily create a list node which points to this head node. So the name of this list node is current and we assign the value of head to it. So it would look something like this that we are having a list node by name current and it is pointing to head. Moving ahead. Now in this algorithm we encounter a while loop and in while loop we place a condition that whether current is equal to null or not. So why we put this condition because once current is equal to null we come to know that we have traversed the list completely. So therefore we come to know that there are no more elements left to be traversed. So initially now as current is pointing to this first node we know that it is not null. So therefore condition in while loop comes out to be true and the code inside the while loop executes. So the first step what we do is we simply print the data associated with this current node. So it would look something like this. The data associated with this current node is 10. Moving ahead. So friend as we have traversed this node now it's time to move to the next node. So in order to move to next node what we do is. So friend if we assign the current next value to current what will happen is as current is pointing to this first node having data as 10 now it will point to the second node having data as 1. So here simply what we are doing is current next is pointing to second node and this value we are assigning to current itself. So it would look something like this. By this assignment we are simply traversing current to its next by assigning current next value to current. Moving ahead we again check whether current is equal to null or not. So here you can see as current is pointing to second node it is not equal to null. So the condition in while loop comes out to be true. And we simply print current data on the console. So current's data is nothing but 1. So it would look something like this. Moving ahead. So friend as we have not traversed the second node now we need to move to the third node. So the only way to move to third node is current's next because current next is pointing to this third node. So if we assign current next value to current current will now point to the node having data as 8. So it would look something like this. Moving ahead. So friends here again current is pointing to node having data as 8. So it is not equal to null. Therefore the condition in while loop comes out to be true. And then we simply print the data associated with this current node which is nothing but 8. Moving ahead. Now we simply assign the value of current next to current to traverse to the fourth node. So it would look something like this. Moving ahead. Now again we know that current is not equal to null because it is pointing to a node having data as 11. So therefore the condition in while block comes out to be true. We then print the data associated with this current node which is nothing but 11. Moving ahead. And then we simply traverse current to its next. So current is pointing to this fourth node and its next is pointing to null. So we simply assign the value of current next which is null to current. So it would look something like this. Moving ahead. So friends we already know that the list is traverse completely and we have printed all the nodes of the singly link list. So now the current is pointing to null. So in the while loop we check whether current is equal to null or not. So here you can see current is equal to null. So the condition in while block comes out to be false. And we know that when this condition comes out to be false the list is completely traversed. So now the statement in the while loop doesn't execute. And in the last step we simply print null. So on the console it will print something like 10 is pointing to 1, 1 is pointing to 8, 8 is pointing to 11 and 11 is pointing to null stating that after 11 there are no more nodes. So friends this is the algorithm to demonstrate how to print the elements of a singly link list. Now let's go to Eclipse and see the working code. Hello friends in our previous tutorials we have actually created this class by name singly link list. We also created a list node class. And in our previous tutorials we also created 4 nodes and we connected them together. So here they are connected in the form as 10 is pointing to 1, 1 is pointing to 8, 8 is pointing to 11 and 11 is pointing to null. Because here what we have done is head next is pointing to second, second next is pointing to third and third next is pointing to fourth. So in this way they are connected to each other. And in this tutorial we will write the code which will actually demonstrate how to print the elements of a singly link list on the console. So here first we will create a method as public void. We will give the name of the method as display. Because it will be printing the elements of a singly link list on the console. So friends in our previous tutorials we actually saw the animation of this algorithm. So here now we will code this algorithm. So first we will create a temporary node by name current. And we will assign the value of head to it. And then we actually saw in the animation slide there was a while loop into which condition was that we were checking whether current is equal to null or not. So if the current was not equal to null we were printing the current's data on the console and then we are traversing the current to its next. So here we will print current's data on the console and then we will simply traverse current to its next by assigning current next value to current. And once the current is pointing to null we know that we have reached to the end of the singly link list. So there are no more nodes left to be traversed. So in the final step we will simply print value as null. So friends here we have already connected these 4 nodes together. Now let's test that whether they are actually connected or not. So we will simply call this display method and we will run the code. So friends here you can see it printed 10, 1, 8 and 11 because this head is having data as 10 and it is pointing to second node whose data is 1 and second is pointing to the third node having data as 8 and 8 is pointing to the fourth node having data as 11. And finally fourth next is null so therefore it printed null over here. So friends this is how we actually print the elements of the singly link list on the console by traversing one node at a time. I hope you like this video. Thanks have a nice day. Hello friends welcome to my new data structures and algorithms in java tutorial series video. In this tutorial we will discuss how to find length of a singly link list in java. So friends let's suppose we are given a singly link list having 4 nodes with data as 10, 1, 8, 11. Now in this singly link list head is pointing to the first node and as you can see the last node is pointing to null and we also know there are 4 nodes into this singly link list. So in order to find the length of this singly link list below is the algorithm for it. So let's see the demonstration of this algorithm step by step. So in the first step what we will do we will create an integer variable count which will hold the actual count of the number of nodes in the singly link list. So friends initially the value of count will be 0. So it would look something like this moving ahead. So friends now we will define a list node by name current which will point to the head. So it would look something like this that as head is pointing to this first node now current will also point to the first node moving ahead. So friends in order to find the length of this singly link list we need to traverse each node one by one and we need to increment the count by one. So friends in order to traverse each node one by one we will provide a while loop and in while loop we will provide a condition that current is not equal to null. So when the current is equal to null we can come to know that list has reached its end and there are no more nodes left to be traversed. So here you can see current is pointing to this first node therefore it is not equal to null therefore the condition in while block comes out to be true. So in the first step what we will do is increment the value of count by one moving ahead. So friends as current is pointing to first node so we have already counted this node. So now it is time to move to its next node. So here you can see current is pointing to this first node and current next is pointing to the second node. So in order to traverse current to its next node what we will do is simply assign the value of current dot next to current. So it would look something like this. So friends here we simply assign the value of current next to current. So therefore now current is pointing to the second node having data as one moving ahead. So now we will again check whether current is equal to null or not. So here you can see this current is pointing to the second node having data as one therefore it is not equal to null. So the condition in while block comes out to be true. In the first step we will simply increment the count by one moving ahead and as we have traversed this node now it is time to move to its next node. So here you can see current is pointing to the second node and its next is pointing to this third node. So in order to make current traverse to this third node what we will do is simply assign the value of current dot next to current. So current dot next is pointing to third node therefore we will assign this value to current. So it would look something like this. We will now again check whether current is equal to null or not. So as current is pointing to its third node therefore its not equal to null. We will again increment the count by one and then we will simply move current to its next node by assigning current dot next value to current. So it would look something like this. Now again current is not equal to null therefore condition in while block comes out to be true. We will increment the count by one and then we will simply traverse current to its next node by assigning current dot next value to current. So here you can see current is pointing to its last node and its next is pointing to null and as we are assigning current dot next value to current therefore now current will point to null. So it would look something like this. We will check whether current is equal to null or not. So here you can see now current is equal to null therefore condition in while block comes out to be false and we also know that we have reached to the end of the singly linked list. So now there are no more nodes left to be traversed. So in the final step we will simply return the value of count which is nothing but four and we also know there are four nodes one two three and four. So friends let's go to eclipse and see the working of this algorithm. So friends in our previous tutorial we created one class by name singly linked list. So this class demonstrated how we can implement a singly linked list in Java. We also created one display method which actually printed the singly linked list on the console and in the main method we also created few nodes what we actually saw in the slide. So if I run the code now. So you can see the singly linked list has four nodes with the values 10 1 8 11 and finally its points to null. So there are four nodes in a singly linked list. So friend in order to find the length of the singly linked list we will first create a method and we will give it a name as length. So this length method will return an integer value which will be nothing but the count of the number of nodes in the singly linked list. So in the first step what we will do we will provide a condition and here we will check that if head is equal to null then we will simply return 0 because in a singly linked list if head is pointing to null then we can come to know that the singly linked list is empty. Moving ahead we will create an integer variable count and we will assign a value of 0 to it. So this count variable will be actually holding the value of number of nodes in the singly linked list. Moving ahead we will create a list node by name current and we will assign the value of head to it. So the current is pointing to head node and then in order to traverse each and every node of a singly linked list we will provide a while loop and inside this while loop we will provide a condition that if current is not equal to null so if current is not equal to null we know that there are nodes in the singly linked list and if current is equal to null then we can come to know that we have reached the end of the singly linked list. So in the first step we will increment the value of count by 1 because as we are in the while loop we are actually traversing a particular node of a singly linked list so we are incrementing the count by 1 and after incrementing the count by 1 we will simply traverse current to its next node by assigning the value of current dot next to current and finally when current is equal to null we know that we already traversed this singly linked list completely and there are no more nodes left to be traversed. So we will simply return the value of count. So friends in the main method let's test the working of this length method. So here we will simply print the value of length. We will call the length method and if I run the code so friends here you can see that we had a singly linked list with the 4 nodes 10, 1, 8, 11 and finally we printed the length of the singly linked list which is nothing but 4. So friends in this tutorial we saw how we can find the length of a singly linked list in Java. I hope you like this video thanks have a nice day. Hello friends welcome to my new data structures and algorithms in Java tutorial series video. Friends in this tutorial we will discuss how to insert node at the beginning of a singly linked list in Java. So friends here you can see below is the algorithm to insert a node at the beginning of a singly linked list in Java. Friends let's suppose initially singly linked list is empty therefore when singly linked list is empty we know that head points to null because there are no nodes into the singly linked list. So friends let's suppose you want to insert a node into a singly linked list whose data is 11. So we pass in a value to this method let's say 11. Now we want to insert this node at the beginning of a singly linked list. So here is the algorithm for it. So let's see the demonstration of this algorithm step by step. So when we call this method we pass in the value as 11. So friends as you want to insert this node at the beginning of a singly linked list what we do is first we actually create this new node and in our previous tutorial we also saw that how we can create a new list node. Actually create a new list node by passing in the value into the constructor. So here a new list node will be created by name new node whose value will be 11. So it would look something like this. So here you can see the new node is pointing to this list node whose data is 11 and whose next is pointing to null. So friends now we want to insert this new node to the beginning of the singly linked list where currently head is pointing to null. So in the next step so friends as you want to insert this new node to the beginning of this singly linked list we know that head always points to first node and if you want to insert the node to the beginning then we are inserting the node just before the head. So in the first step what we do is currently new node next points to null. We assign the value of head to new nodes next. So it would look something like this. That as head is pointing to null new node next is also pointing to null and friends here you can see as head is the first node we are inserting it just before that. So in order to insert this node just before the head we have to point new node next to head moving ahead. So in the last step what we do is as we have inserted this node at the beginning of the singly linked list we know that now head should point to this node because we know that head points to the first node of a singly linked list. So we simply assign the value of new node to head. So currently head points to null and new node points to this list node. So therefore now head will point to this list node. So it would look something like this. So friend after we have inserted this new list node to the beginning of this singly linked list. Now our singly linked list has this one node. Now let's suppose we want to insert one more node having value as head. So we call this algorithm again. In the first step we simply create a new list node by passing in the value as head. So it would look something like this. That new node is pointing to a list node having data as head and whose next is pointing to null. So friends now we want to insert this new node at the beginning of this singly linked list. So by that we mean that we want to insert this node just before the head. So in order to insert this new node just before the head there has to be some link between these two. So in the next step what we do is as new node next is pointing to null we simply assign the value of head to new nodes next. So it would look something like this. That new node next now points to head and which also makes sense because we are inserting this new node at the beginning of this singly linked list which is nothing but just before the head. So we are doing a head and the last step what we do is as we have inserted this new node in the beginning head should point to this node. So we simply assign the value of new node to head. So it would look something like this. So friends after we insert this new node having the data as head the linked list has now two nodes and here you can also see that whatever the node is inserted it is now at the beginning of this singly linked list. So friends let's suppose we insert one more node to this singly linked list with the value as 1. So this algorithm again get executed. In the first step we will create a new list node. So it would look something like this. That new node is pointing to a list node having data as 1 and whose next is pointing to null. Using a head as you want to insert this new node at the beginning of this singly linked list we have to make a connection from this node to the head node because we want to insert it just before the head. So what we do is whatever the value is there in the head we simply assign it to new nodes next. So here you can see head is pointing to a node having data as 8 and new nodes next is pointing to null. So now new node next will point to a node having data as 8 moving ahead. And as we have inserted this new node at the beginning of this singly linked list we know that head should point to this node now. So we simply assign the value of new node which is nothing but the node having data as 1 to head. So it would look something like this. So friends here we saw the demonstration of this algorithm by inserting 3 nodes at the beginning of this singly linked list. First we inserted 11 which became the first node of the singly linked list. Then we inserted 8 and then we inserted 1. So friends now let's go to Eclipse and see the working of this code. So friends in our previous tutorial we created one class by name singly linked list and we implemented the singly linked list into this class. We also implemented a display method which was actually printing each and every node of this singly linked list. So friends let's write a method which will insert a node into the beginning of this singly linked list. So first we will create a method insert first. So we have created one method by name insert first because we are inserting this node to the beginning of this singly linked list and this method takes in an integer value which we actually want to provide to the list node which we want to add to the beginning of this singly linked list. So in the first step what we do is we create this list node and to the constructor of list node we pass in the value. So after this step a new node is created. Having data is whatever the value we have passed. So in order to insert this new node to the beginning of the singly linked list what we do is to new nodes next. We provide a value which is stored in the head and in the last step what we do is we simply now point head to this new node. So friends this is the method which insert the node to the beginning of the singly linked list. Now let's test its working. So first we will insert a node having value as 11 and we will simply print the singly linked list on the console. So here you see singly linked list has one node having data as 11. Now let's say we insert 8 and we also insert a node having value as 1 and if I run this code now. So friends here you can see the singly linked list contains 3 nodes now. First we inserted 11 and then we inserted 8 to the beginning of the singly linked list. So 8 came before 11 and finally we inserted a node having data as 1 which came just before the 8. So friends this is how we insert the node to the beginning of the singly linked list in java. I hope you like this video thanks have a nice day. Hello everyone welcome to my new data structures and algorithms in java tutorial series video. In this tutorial we will discuss how to insert a node at the end of a singly linked list in java. So friends below you can see the algorithm to insert a node at the end of a singly linked list in java. So here in this tutorial we will see the demonstration of this algorithm step by step. Here the algorithm basically insert the node to the end of the singly linked list. So let's suppose at that start that singly linked list is empty. So if the singly linked list is empty we know that head will point to null because there are no nodes into the singly linked list. So now let's suppose we want to insert a node having data as 11. So to the method we will pass the value as 11 and this code will be executed. So in the first step what we do is in order to insert this value into the singly linked list we first actually create a list node by passing in the value to its constructor. So it would look something like this that a new list node is created whose data is 11 and whose next is pointing to null. So now we will insert this new node into the singly linked list at the end. So first here in the algorithm we check that whether head is equal to null or not because if head is equal to null then we know that singly linked list is empty and there are no nodes. So therefore currently singly linked list is empty because head is pointing to null. So the condition in if block comes out to be true. And in the if block we simply assign the value of new node to head. So new node is pointing to a node having data as 11 and we want to insert this new node into the singly linked list at the end. But here as the singly linked list is empty therefore in the first step what we do is we simply assign the value of new node to head. So here as head is pointing to null after this assignment head will point to this node having data as 11. So it would look something like this and we will simply return from this method. So friends here we inserted one node into the singly linked list at the end. So initially the singly linked list was empty but now it has one node where head is pointing to this node. Moving ahead let's say we want to insert one more node having value as 8. So we will pass this value into this method and the first step will simply create a new list node by passing in the value to its constructor. So it would look something like this. That new node is pointing to the node having data as 8 and whose next is pointing to null. Now we want to insert this new node to the end of the singly linked list. It's nothing but just after the node having data as 11. So friends now we want to insert this new node to the end of the singly linked list and here you can see that singly linked list has only one node. Therefore this node having the data as 11 is the last node of the singly linked list. So now after this node we have to insert this new node. So we again check whether head is equal to null or not. So currently you can see the head is pointing to the node having data as 11. Therefore the condition in if block comes out to be false. So here we simply create a temporary node by name current and we will assign the value of head to it. So it would look something like this. That current is now pointing to the node having data as 11 and head is also pointing to this node. Moving ahead. So friends now we actually provide a while loop. So why we are providing this while loop is because in order to insert a new node to the end of the singly linked list we need to traverse from head to the end node. So once we reach the end node we can simply assign the value of the last node next to point to this new node. Therefore we start from the head node as current is pointing to head and we iterate in the while loop till current dot next is null. So friends when current dot next will be equal to null. Therefore we can come to know that that is the last node of the singly linked list. So friends in the while loop we provide a condition that current dot next is not equal to null. So here if you see current is pointing to the node having data as 11 and its next is pointing to null and we also know that currently in the singly linked list there is only one node having data as 11 and its next is pointing to null. So therefore the current is pointing to the last node. So therefore the condition in while loop comes out to be false because current dot next is equal to null. So as the singly linked list has only one node therefore this node is the first and also the last node of the singly linked list. So as we are on the last node of the singly linked list in order to insert this new node to the end of the singly linked list what we do is we simply assign the value of new node to current next. So here you can see new node is pointing to the node which we want to insert and current next is pointing to null. So if we assign the value of new node to current next it would look something like this. That current next is now pointing to a node which we want to insert into a singly linked list at the end. So friends when this method gets executed we know that we have inserted this new node to the end of the singly linked list. Now let's suppose we want to insert one more node having value as 1. So this code will be executed again. In the first I will simply create a new list node by providing in the value as 1. So it would look something like this. That new node is pointing to a list node having data as 1 and whose next is pointing to null. We check whether head is equal to null or not. So here you can see head is pointing to a node having data as 11 therefore it's not equal to null. So friends in order to insert this new node to the end of the singly linked list we have to start from the head and we have to reach till the last node of the singly linked list. So in order to perform this step we simply create a temporary node by name current and we start it from the head by assigning the value of head to current. So it would look something like this. That current is pointing to this first node having data as 11. Now we will simply provide a while loop and traverse this current to the last node of the singly linked list by providing a condition that current.next is not equal to null. So in the first step we see current is pointing to a node having data as 11 and its next is pointing to a node having data as 8. Therefore current.next is not equal to null. So the condition in while block comes out to be true. So in the while block we simply traverse current to its next position by assigning current.next value to current. So here you can see current is pointing to this node having data as 11 and its next is pointing to a node having data as 8. So we will assign the value of current.next to current. So it would look something like this. That current has simply traversed to its next node because we have assigned the value of current.next to current. Moving ahead we will again check whether current.next is equal to null or not. So here you can see current.next is equal to null and here we also know that singly linked list has two nodes. So the node having data as 8 is the last node of the singly linked list. So we have traversed the current to the last node and now we can simply insert this new node to the end of the singly linked list. So here the condition in while block comes out to be false because current.next is now pointing to null. And in the last step we simply assign the value of new node to current.next. So new node is pointing to the node which we want to insert and current.next is pointing to null. So if we assign this value to current.next it would look something like this. That current.next is now pointing to the node having data as 1. So friends once this method gets executed we know that our singly linked list has now three nodes. So here we started by inserting a node having data as 11 then we inserted a node having data as 8 and then we inserted a node having data as 1. So you also saw that we are actually inserting this node to the end of the singly linked list. So friends this was a demonstration of the algorithm. Now let's go to Eclipse and see the working of this algorithm. Hello everyone. In our previous tutorial we actually discussed how we can insert the node at the end of the singly linked list in Java. So in this tutorial we will actually write the code and test the working of the code. So friends in our previous tutorial we actually created one class by name singly linked list. So friends in this class we actually wrote the code for the implementation of the singly linked list. So now let's write the code to insert the node at the end of the singly linked list in Java. So here I will be creating one method as public void insert last because you want to insert the node at the end of the singly linked list. So we will provide a value to this method. So here in the first step as we discussed in the slide that first we will create a new node and we will pass the value into the constructor of this list node. So after this step a new node is created and now our task is to insert this new node to the end of the singly linked list. So here in the first step we actually make a check that whether head is equal to null or not. So if head is equal to null we know that singly linked list is empty and there are no nodes into the singly linked list. So we simply assign the value of new node to head and we simply return from the method. So here if the singly linked list is empty we simply assign the value of new node to head because after the insertion of this new node this would be the only node into the singly linked list. And if the singly linked list is not empty then we will create a temporary node by name current and we will assign a value of head to it. So here in order to insert this new list node to the end of the singly linked list we need to start from the head and we need to reach to the end of the singly linked list. So in order to start from the head and reach to the end of the singly linked list we create a temporary list node by name current and we start from the head. And then we will provide a while loop and to this while loop we will provide a condition as current.next is not equal to null. And inside this while loop we will simply iterate current to its next position. So once we reach to the last node of the singly linked list we know that its next points to null and as we want to insert this new list node to the end of the singly linked list after while loop we simply assign value of new node to current next. So friends here we started from the head node and we reached to the last node by providing this while loop and we traversed current from first node to the last node of the singly linked list and once we reached to the last node of the singly linked list we simply assigned the value of new node to current next and so the current next refers to this new node and this new node is part of the singly linked list. So in our main method let's test its working. So we will simply call insert last. So here we have called insert last 3 times but first we are inserting the value 11 and then we are inserting a value 8 and then we are inserting a value of 1 and then finally we are displaying the singly linked list on the console. So if I run this code now. So friends here you can see first we inserted 11 and then we inserted 8. So 8 came just after 11 and then we inserted 1. So 1 came after 8. So it is nothing but inserting the node at the end of the singly linked list. So friends in this tutorial we actually saw how we can insert a node at the end of a singly linked list in Java. I hope you like this video. Thanks have a nice day. Hello everyone. So in this video we will discuss that how we can insert a node in a singly linked list at a given position. So here you can see that in this problem we want to implement a method which will insert a node in a singly linked list at a given position. In this position we are assuming to be valid and it will start from 1. So for example here you can see that we are given let's say with this singly linked list and now let's say if you want to insert any node at a given position. So here we are assuming that position to be valid it means that position should lie from 1 to whatever is the length of the singly linked list. And here we are starting it from 1 which means if you want to insert a node at position 1 it would be the first node and if you want to insert at position 5 then this would be the last node and in case if you want to insert in between of these nodes the position would be the number where you want to insert. So let's say if you want to insert at position 3 and we are given with this singly linked list so here you can see this is position 1, 2 and 3. So what we are trying to do here is we will insert node here and this node will get shifted ahead of the node which you want to insert here. So let's go ahead and see the demonstration of this algorithm step by step. So before we start in case if you are new to my channel then please subscribe to my channel so that you never miss any update. So now here you can see this is the algorithm to insert a node at a particular position. Now let's suppose if we are given with this singly linked list having only two nodes. So we will apply this algorithm on this singly linked list and let's say if you want to insert a value 8 at position 1. So the second parameter is position and this is the value which you want to insert. So here you can see that whatever the value we have passed which is 8 here it's nothing but our data. So in the first step what we are doing is we are creating a list node having data as 8 because we want to insert this node at position 1. So it would look something like this that node is pointing to a list node having value as 8 and its next is pointing to null. Now here you can see that there are two cases in if and else. So if position is 1 it means you want to insert this node at the beginning of singly linked list which is just before our head. So currently this if block condition comes out to be true. Now as you want to insert this node before head what we have to do is as node is pointing to this list node its next should point to head because we want to insert this node before head so this nodes next should point to head. So in the first step we are doing that we are assigning the value of head which is this node to nodes next. So currently node next is pointing to null so after this assignment nodes next will point to head. So it would look something like this that now node next is pointing to head moving ahead. So here you can see that node next is pointing to head but as head is pointing to the node having value as 10 which is our second node we need to reassign this head to this node because in order to insert a node before head which is the position 1 after insertion head should point to that node or else when this method will get exit this node wont be part of our singly linked list so we need to assign head to this node so that this node comes into the singly linked list. So we are simply assigning the value of node to head so head is pointing to the second node now it will point to the node which you want to insert and here you saw that after inserting the node at the beginning this was our position 1 initially at position 1 was this node which shifted towards right and this node came into position 1. Moving ahead now lets suppose if you are given with this 3 nodes and you want to insert a value 7 at position 3. So here you can see this is position 1 this is position 2 and this is position 3 so we want to insert node here and once we insert node here this one will be shifted a node ahead because we want to accommodate 7 between 10 and 1 because this is the third position so lets see how we can do that at the first step we will create the node with the data as 7 we check whether position is equal to 1 or not so position is not equal to 1 so the else part will be executed. So friends now idea behind this algorithm is we want to insert a node at position 3 so this is the position 3 which means we want to insert this node between this node and this node so that once this node is inserted our new node is at position 3 so in order to insert this node at position 3 what we have to do is we need to traverse somehow to position 2 and then we can break this link and instead of pointing to node 1 we can point to our node 7 and node 7 will point to 1 and by this way our node will be inserted between 10 and 1 and will occupy position 3 so lets see how. So here we will create a list node previous because we want to reach somehow to this node which would be previous to our node after insertion so we will start from the head so previous will point to head and in order to reach to this node we will keep the track using the count variable so value of count will be 1 at the start which signifies that we are already at this position and then in order to traverse to a node previous to our position 3 we will provide a condition as count should be less than position minus 1 so position minus 1 will be 2 and here you can see that we have already taken up this place so count is 1 so currently count is less than position minus 1 which is 1 is less than 2 so this condition comes out to be true so we will simply traverse previous to its next node by assigning previous dot next to previous so currently previous is pointing to this node its next is pointing to this node so we will assign previous next value to previous so it would look something like this that now previous will point to its next node moving ahead will increment value of count because we have traversed previous to its next node count becomes 2 now here you can see 2 is not less than 3 minus 1 which is 2 and we also know that we have reached to position 2 and now we can simply use its next pointer to simply insert this node into the singly linked list at position 3 so this while loop condition comes out to be false now here what we will do is as we want to first break this link so at the first step what we do is we simply create a list node current we will assign a value of previous dot next to it so as we want to break this link so we can't directly break this link because if we break this link the nodes after that will be removed from the singly linked list because there would be no reference so at the first step we are simply creating a temporary list node by name current and we are assigning previous dot next to it so that whatever the nodes are after that will be hold by current so previous next is this node so now current will point to this node so for now we need to perform two steps in order to insert node between 10 and 1 the first thing we need to do is as node next is pointing to null and we know that after its insertion it should point to this node because that way it will be inserted in between of node 10 and 1 so at the first step what we are doing is as current is pointing to this node we will assign the value of current to nodes next so here node next is pointing to null so after this assignment there will be a linkage from node next to current so it would look something like this moving ahead and at the last step what we do is we simply break this link and we can safely break this link because the rest of the list is being hold by current so how we can break this linkage previous is pointing to this node its next is pointing to this node so if we assign nodes value which is this value to previous next so it would look something like this that now previous next is pointing to node by this assignment and why we have performed this step is because we want to insert this node in between 10 and 1 so there was one linkage between 10 and 1 so we break that linkage we assigned previous next to node and node next to current so here you can see that if we stretch this singly linkage ahead so it would look something like this that 7 will come in between 10 and 1 and here you can see that that is the position 3 where we actually wanted to insert our node this is position 1 2 and this would be over 3 so it is nothing but inserting a node somewhere in the middle of the singly linked list so friend 1 last case remains is we want to insert node at the last so that will also be inserted via position so here you can see let's say we are given with the singly linked list having only two nodes 8 and 10 so this is position 1 and this is position 2 now if you want to insert a node at the third position so it would be nothing but inserting the node at the end of the singly linked list and here we are assuming that position should be valid so if we call insert 7 comma 3 7 is our data and 3 is our position at the first step will create the list node having data 7 and its next pointing to null we check whether we want to insert it position 1 or not so currently we want to insert it position 3 so this condition comes out to be false now in the else part we perform the same steps which we saw in our previous slide if you want to insert it position 3 we need to somehow traverse to position 2 so that we can use this link to insert this node so we start previous from the head and in order to keep the track of the position and where to insert the node will create an integer variable count starting from value 1 because we have already taken up this value in the while loop we provide the condition as count should be less than position minus 1 position minus 1 is 2 and as count value is 1 therefore the condition in while loop will come out to be true in the first step will simply traverse previous to its next node by assigning previous next value to previous so it would look something like this will increment count so count becomes 2 and now here the condition in while loop comes out to be false because position minus 1 is 3 minus 1 which is 2 and 2 is not less than 2 so this will signify that previous is one step behind our position so here you can see previous is pointing to position 2 and why we need a previous position is because as it is a singly linked list we need to somehow use previous next pointer to simply accommodate our newly created node inside that so at the first step what we are doing is we are simply assigning previous next value to a temporary list node current so previous next is pointing to null so current will point to null now as you want to insert this node what we saw in our previous steps node next should point to current so after this assignment it would look something like this that node next is pointing to null so friends here you can see as we are inserting this node at the end of the singly linked list these steps are pretty much generic to accommodate both cases inserting in between and inserting at the end now at the last step we are simply assigning value of node to previous next so previous next is pointing to null so it means we want to reassign this value to this node because we want to insert this node at position 3 so it would look something like this so now head is pointing to node 1 node 1 is pointing to second node and second node is pointing to third node which is our position 3 and this node is pointing to null because we have inserted this node at the end of the singly linked list so it would look something like this so here we discuss the cases where we want to insert the node at a particular position of the singly linked list I hope the information provided in this video is useful to you and in case if you find this useful then please like this video and in case if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day. Hello everyone so in our previous video we discussed that how we can insert a node at a given position in a singly linked list so in this video we will code the algorithm and will test its working so here in our singly linked list class which has an instance variable head of type list node here I will be creating one method public void insert now this insert method will take two things one is the position where we want to insert and let's say there is the value which you want to insert for that particular node now here we are assuming that this position is valid and it is not crossing the boundaries of our singly linked list so those edge cases you can handle it by comparing the value of the position that whether it is less than zero or it is greater than the length of our singly linked list and basically you can assign a default value to position and proceed ahead with the algorithm or you can simply throw an exception so here we are assuming that position is a valid position and starting from one so for example if we are given with the singly linked list let's say one having this three nodes so one would be our position one four would be at position two and five would be at position three so let's say if you want to insert a value six at position two so after this method gets executed it would become something like one at position two it will come six then four and then five so it means we have inserted value six between one and four because one is at position one and after our insertion six should come at position two so this method will perform three cases if position is one it will insert at the beginning of the singly linked list and it will also insert in between or at the end of the singly linked list so let's see the code for that so assuming the position to be a valid position at the first step we will create the node which you want to insert whose value would be the value which we have passed to our method now after creating this node which you want to insert we will provide a if else part in the if part will check whether position is one or not so if position is one it means you want to insert the node at the beginning of the singly linked list so in the if part what we do is as head is pointing to the first node which is also position one so now head should point to a newly created node after the node gets inserted so in the first step what we do is as node next is pointing to null we want to point it to head because we want to insert this node before head so node next should point to head and after node next is pointing to head in order to make node part of our singly linked list and to insert at position one we need to assign the nodes value to head so now head will point to node which would be at position one and which would become the part of our singly linked list so this is the case one and for the rest of the cases we'll see in the else part so in the else part let's say if you take this example and we want to insert a node at position two so here you can see that initially the linked list let's say it's one four and five and if you want to insert a node at position two so it would become something like this after the insertion so here what we are doing is this linkage we are breaking between one and four and we are assigning it from one to six and then six to four so there are two assignments one is we are reassigning this linkage from one to four to one to six and then from six to four so there are two assignments which we need to do now as it is a singly linked list in order to reassign this value we need to somehow reach to node one which is previous to the position where we want to insert the node so let's say if we want to insert node at position two we need to somehow reach to position one and using its next we need to assign it to our node which you want to insert so in the else part we'll create a temporary node at previous because we want to somehow reach to a node previous to this position where we actually want to insert our newly created node so we'll start from head and as you have already started from head we'll create a integer variable count we'll assign it a value one because this count will help us in traversing to position minus one so in a while loop we will provide a condition as count should be less than position minus one and inside this while loop till this condition fails we will keep incrementing previous to its next position by assigning previous dot next to previous and we'll simply increment count by one one position so when previous will reach to position minus one this while loop will terminate and after this while loop gets terminate what we do is we create a temporary list node by name current and we assign a value as previous dot next to it so here let's say if we have reached here so two current we are assigning previous next which is value four because we need to reassign it to six if we break this linkage and reassign it directly then four and five will be removed from the singly linked list because there is no reference to them so at the first step we are simply creating this temporary reference so that the rest of the singly linked list is intact now after assigning previous dot next value to current we can simply remove this linkage and assign it to our node which we want to insert so here what we do is we do previous dot next and we'll assign a value of node to it so now this linkage is gone and it will point to six now we need to do one more assignment as this node next should point to four because we want to insert node six in between one and four so that it comes to position two so for that what we do is we do node dot next and assign a value current to it because we know that current is pointing to previous next which was this node so now six next will point to this node and this way with this three step you can see that we have inserted our node in between node one and four and after this assignment you can see that six is now inserted at position which we wanted which is position two in this case so from this is the code to insert a node in a singly linked list at a given position so now let's test it's working in the main method so here in the main method i will comment this part and let's say after creation of singly linked list head is pointing to null because here you can see that at the start head is pointing to null so here what we do is let's say we insert a node at position one value as three and then let's say i print it on the console the singly linked list using the display method so if i run the code now so here you can see it inserted at position one which is the first position having only one node three pointing to null now let's say what we do is at position two we assign five and if we run the code so here you can see at position one was three so position two we got value five and now what we do is let's say at position one we insert value two so now here you can see at position one three is already there and if we are doing this it means two will come before three so if i run the code now so here you can see two came before three which was our this case so now let's see the else part let's say i insert a value four between one and two so we'll do two and if i run the code now so here you can see initially singly linked list was two three and five and when we did that four came in between two and three which is the position two which we actually wanted now here after this insertion you can see there are four nodes two four three five and let's say if you want to insert at the end so the position would be value five because four nodes are already there so here what we do is at position five we want to insert value seven let's say if i run the code so you can see seven inserted at the end of the singly linked list which is position five so friends here we saw different use cases at the first step the singly linked list became something like this and when we inserted five at position two it became something like this and then we inserted value two at position one so three got shifted ahead and our singly linked list became something like this i'll just copy this part so it would be two two it became something like this because two inserted at position one and rest of the singly linked list shifted by one position and then we inserted four at position two so it became something like this it was like this so at position two four came and rest of the list nodes were shifted by one position and here you can see that we had this four nodes already so at the position five we inserted seven so it became something like this i'll copy this seven so which is our this case so friend this is how we actually insert a node in a singly linked list at a given position i hope you have find this information useful and in case if you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so in this video we will discuss that how we can delete the first node of a singly linked list so let's see the code and it's working step by step using an animation so here you can see that let's say we are given a singly linked list having three nodes with data as 10 1 and 11 where head is pointing to the first node and let's say in our singly linked list class we have created this head as an instance variable and we have written one of the method in that class which will manipulate this singly linked list so here you can see that this is the code to delete the first element of the singly linked list so let's see the demonstration of this method that how it manipulates the singly linked list and deletes the first node so when we call delete first method you can see it has a return type of list node so what it will do it will delete the first node and it will return from this method so when we call delete first the first step we check is whether head is equal to null or not because if head is equal to null it means head is pointing to null and there are no nodes to delete so we simply return null so currently you can see that head is pointing to a node having value as 10 so therefore this condition comes out to be false and the execution point reaches here now here what we do is we create a temporary variable which will also point to the first node of the singly linked list because head is always pointing to the first node now why we are creating this temporary variable is because when we delete this node we need to return it from this method so we are creating this temporary variable of type list node and whatever the reference value head is holding we are simply assigning it to the temporary variable so as head is pointing to this first node after this assignment there will be a temporary list node which will also point to this node moving ahead now if the temporary list node is pointing to the first node of the singly linked list after its deletion the linked list will have only two nodes and head should point to the second node now because when we delete the first node the linked list remains with the two nodes and the second node becomes our new head so we need to traverse this head to the second node so how we will do that we will simply assign the value head.next to head so head is pointing to this node its next is pointing to the second node so once we assign head.next to head it would look something like this that now head has simply traversed the second node and as head has traversed the second node we can safely delete this first node moving ahead so here you can see that head is pointing now to the second node and this will be our newly singly linked list because you have deleted the first node but if we return this temporary list node directly from this method these two nodes will also get returned along with this temporary list node because there is still a linkage here so what we do is in order to break this linkage we simply assign null value to temp.next so temp is pointing to this node and its next is pointing to the second node so we need to break this linkage so after assigning null it would look something like this you can see we have completely separated the first node from the singly linked list so at the last step we simply return this temporary list node and after deletion of the first node now our linked list has only two nodes with a new head pointing to the second node which has now become the first node of the singly linked list so friends let's say if you want to perform delete first again so we call delete first again on this singly linked list having two nodes so it would look something like this we check whether head is equal to null or not so head is pointing to this node therefore condition in if block comes out to be false we again create a temporary list node which will point to the first node of the singly linked list because we are assigning the value of head to it after assigning this value we simply traverse head from this node to its next because we want to delete this node so by assigning head.next to head head will not point to the second node of the singly linked list then we'll simply break this linkage here by assigning null value to temps next and finally we'll return the temp so now our singly linked list has only one element so by calling this delete first two times we have deleted two nodes which were at the beginning of the singly linked list so let's say we want to delete this node also so we'll call delete first again we check whether head is equal to null or not so your head is pointing to this node therefore it's not equal to null so this condition comes out to be false we create a temporary list node pointing to head something like this and then we'll simply traverse head to its next because we want to delete this node so by assigning the value head.next to head what will happen head is pointing to this node and its next is pointing to null because this is the only node left in our singly linked list so now head will point to next which is null we simply assign null to temp.next to break this linkage but as it is already pointing to null it would look something like this and we can return this temporary node because we have deleted it completely so now our singly linked list has no elements and head is pointing to null so if we call delete first again we first check whether head is equal to null or not so here you can see now head is equal to null so therefore this condition comes out to be true and as there are no nodes left to be deleted we simply return null so friends this was the algorithm to delete the first node of a singly linked list we saw that singly linked list had three elements at the start we called this method delete first four times to delete this all the nodes from the singly linked list so now let's go to eclipse and see the demonstration of this algorithm step by step i hope you like this video thanks have a nice day hello everyone so in this video we'll write the code to delete the first node of a singly linked list so here you can see that we have the singly linked list class having an instance variable head of type list node so this head is responsible for holding complete list in our previous lecture we also saw the different operations such as length where we can get to know the length of the singly linked list and even we can display the data which is being present in the singly linked list we also discussed about the insert first method and insert last method so let's say if i run this code now so here you can see that we have inserted four nodes eleven eight one ten and then it's null so here we have inserted this four nodes and we have displayed the singly linked list here so let's write the code and see that how we can delete the first node of a singly linked list so here i'll be creating one method as public list node delete first so here you can see that after deleting the first node we'll simply return it from this method so as we discussed in our previous video that in delete first the first condition we check is we see whether head is equal to null or not so if head is equal to null then we simply return null which means that singly linked list is empty and there are no nodes left to be deleted we can even throw an exception from here but for time being i'm returning null and then we also discuss that after if condition we create a temporary variable and we point it to the head so here you can see that why we have assigned the value of head to temp because after deleting the first node we have to return this list node from this method and also head points to the first node of a singly linked list so for example let's say we want to delete the first node from the singly linked list so head points to 11 and once we delete 11 head should point to 8 now because there are three more elements left so head should point to 8 so here after assigning head to this temporary variable now we can simply move head to its next position by simply assigning head.next to head so here as head was pointing to 11 now it will point to 8 so now after placing head to its correct position we can simply delete the first node by assigning null value to temp.next in order to break the linkage between this temporary node and the rest of the list and finally we can return the deleted node so this is the code now let's test it's working so here after display what we'll do is we will simply print the deleted nodes data so here what we'll do SSL. we will call delete first method so this will return us the list node which we have deleted and then we can simply print its data and then after deleting the data what we can do is we can again print the singly linked list and if i run the code now so here you can see that we removed the first node which is 11 and we printed its data here and then after deleting the first node the singly linked list was left with 8 1 and 10 so similarly let's say if i remove one more node and if i run the code now so here you can see that when we called delete first for the first time 11 was removed then we called it second time so 8 was removed which got printed here and finally when we did display so the linked list was printed as 1 and 10 because we have removed 11 and then 8 so friend this is how we actually delete the first node of a singly linked list i hope you like this video thanks have a nice day hello everyone so in this video we will discuss about how to delete last node of a singly linked list so here you can see that this is the algorithm to delete the last node of a singly linked list so let's say we are given a singly linked list having these three nodes and we want to delete the last node of the singly linked list so here the singly linked list can contain n number of nodes and here if we take this example where head is pointing to a node having value as 10 10 is pointing to 1 1 is pointing to 11 and finally 11 is pointing to null so there are three nodes and if we apply this algorithm when we call delete last first 11 will be deleted and we will be left with two nodes and if we again call delete last then one will be deleted and we will be left with one node if we again call delete last then the only node left will be removed and simply returned from this method so in our previous video we saw that how we can delete the first node of a singly linked list so there as head pointed to the first node it was very easy to delete the first node of the singly linked list but here as we want to delete the last node we need to somehow traverse to the second last node and remove this link to delete the last node from the singly linked list so in order to achieve that what we do is we create two pointers one by name current which travels to the last node and one pointer by name previous which travels to the second last node so as current travels to the last node previous travels to the second last node and why we need the second last node because in order to free the last node we need to break this linkage here so we need to traverse somehow to the second last node break this link to make this node free so this is the algorithm for that now let's see the demonstration of this algorithm step by step so when we call delete last for the first time we first check whether head is equal to null or not so head is pointing to this node so this condition is false and we also check whether head dot next is equal to null or not now why we perform this check is because let's say if the linked list has only one single node so this node next will point to null and this will be the only node in the singly linked list so we don't have to delete anything we simply have to return the head because this is the only node which we want to return from this method so currently head dot next is also not equal to null therefore this both the condition comes out to be false and now as we discussed we create two pointers current and previous so we start current from the head by assigning the value head to it so it would look something like this and as head is pointing to the first node its previous node will simply point to null moving ahead now friend as you want to delete the last node we need to provide a while loop so that we can traverse current to the last node of the singly linked list and previous to the second last node so here if you see in the while loop we are providing condition that iterate till current dot next is not equal to null so here when current will reach to the last node its next will point to null so this while loop will terminate when current dot next becomes null so as current is pointing to this first node and its next is not equal to null therefore this condition comes out to be true and while loop executes so before moving current to its next node what we do is we simply assign current's value to previous so that previous is one node behind the current when current travels to the second node so in the first step we simply assign the value of current to previous so it would look something like this now as current is pointing to the first node previous will also point to this first node and in the second step we simply move current by one position by assigning current's next value to current so current next is pointing to the second node so now current will point to the second node so here you can see we have traversed current to the second node and previous is just one node behind it so this is all we do in the while loop till current reaches to the last node and previous reaches to the second last node so let's see how we again check current dot next is equal to null or not so current next is not equal to null this condition comes out to be true and before moving current to its next position we make sure previous is at current's position by assigning current's value to previous so it would look something like this then we simply move current to its next position by assigning current dot next to current so current dot next is pointing to the third node so after this assignment current will point to this node moving ahead now friends here you can see that we have these three nodes but in singly linked list there can be n number of nodes so the only idea to delete the last node of the singly linked list is we need a reference to the second last node of the singly linked list so that we can remove this linkage so now here you can see current has reached to the last node and previous is on the second last node so here the condition current dot next not equal to null comes out to be false because current next is pointing to null so this while loop terminates which makes sense because we have traversed till the last node using the current pointer and we also know its second last position using this previous pointer so after this while loop the next step we do is we assign a null value to previous next and why we do so because we want to break this link so that this last node can be freed up so previous is pointing to the second last node its next is pointing to the last node and we want to delete the last node so we break this link by assigning null value to previous next so it would look something like this and finally we return the current so after the deletion of the third node we are left with two nodes so let's say we again call this algorithm head is pointing to the first node so it's not null and head dot next is pointing to the second node which is also not null so this condition comes out to be false we again create current in previous nodes by assigning head to current and null to previous so it would look something like this current points to the first node and previous points to null and then we provide a while loop because we want to traverse current to the last node and previous to the second last node so first we check whether current dot next is equal to null or not so current next is this second node it's not equal to null so the condition in while loop comes out to be true and while loop starts execution before moving current to its next we assign current value to previous so that it is just behind the current so it would look something like this let now previous is pointing to this node because current is pointing to this node and now we'll simply traverse current to its next position by assigning current dot next to current so current is pointing to this node its next is pointing to the second node so after this assignment it would look something like this and again in while loop we'll check whether current dot next is equal to null or not so here you can see that this singly linked list contains only two nodes and current is actually on the last node and previous is on the second last node and as current next is pointing to null current will be pointing to the last element of the singly linked list so this condition comes out to be false and while loop exits and now we'll simply assign null value to previous next because we want to break this link so that this node can be freed up so it would look something like this that null is assigned to previous next finally we return current so now we are left with only one node so let's call this algorithm again so here you can see head is pointing to first node which is not null so this condition is false but head dot next is pointing to null head dot next is pointing to null which signifies that singly linked list has only one element because head is pointing to the first node and its next is pointing to null so therefore this list has only one node and if we want to delete that we don't have to do anything we simply return head so friend this was the algorithm where we discussed that how we can delete the last node of the singly linked list we also discussed that how current and previous pointers help us in deleting the last node because in order to delete the last node we somehow need to travel to the second last node and once we travel to the second last node we simply assign null value to its next so that the last node can be freed up and can be returned from this method so friends now let's go to eclipse and see the demonstration of this algorithm i hope you like this video thanks have a nice day hello everyone so in our previous video we saw the demonstration using an animation and we discussed that how we can delete the last node of a singly linked list so in this video we will see that how we can code a method to delete the last node of a singly linked list and in one of our previous videos we also saw that how we can delete the first node so let's say i just comment out the delete first method and if i run the code now you can see we have inserted these four nodes using insert last method and the singly linked list contains 11 8 1 and 10 which are four nodes and which got displayed using the display method now let's say we write the code to delete the last element of a singly linked list so here when we call delete last for the first time 10 will be removed because it is the last element of the singly linked list so here i'll create a method as public list node delete last and after deleting the last node we'll simply return it from this method so in our previous video we discussed that the first thing we do is we simply check that whether head is equal to null or not and we also check that head.next is equal to null or not now why we do it because this condition head equals equals null will signify that singly linked list is already empty and there are no nodes to be deleted and head.next why we do it because if head.next is null it means the singly linked list is only one element so what we do is we simply return head so if the first condition is true null is returned and if the second condition is true the head is returned because this is the only node in the singly linked list so this is the if condition and after that what we do is in order to delete the last node we need to somehow traverse to the second last node and remove the linkage so how we can achieve that in our previous video we discussed that we can create two pointers one is the current which will start from head and other is previous which will be always be previous to current and why we do so because once current reaches to the last node previous is already at the second last node and we can simply remove the linkage by using this previous node and finally return the last node which got deleted so here at the start current points to head and previous points to null null and then we need to provide a while loop so that we can reach to the last node of the singly linked list so the condition we provide here is we simply check whether current next is equal to null or not so if current next is equal to null it signifies that we have reached to the last node of the singly linked list because last nodes next points to null so inside this value what we do is we move current by one position and before moving current to one position ahead we simply assign current's value to previous so that previous always remains one node behind the current so that when current reaches the last node previous is at the second last node and once we get the location of the second last node we can simply remove the last node from the singly linked list by simply putting previous.next equals null so this breaks the chain of the singly linked list from the last node so here what we do is we do previous and assign the value current to it and after this assignment we simply move current to its next position by assigning current.next to current and this while loop goes till current reaches the last position and previous reaches the second last position so after this while loop terminates one last step we do is we do previous dot next equals null because this will break the chain between the singly linked list and the last node because previous is pointing to the second last node and its next is pointing to the last node and we want to delete the last node so we simply assign null value to previous next so this will break break the chain and finally we simply return the current because you have deleted this node so we simply return it from this method so now let's test it's working so here we have this list of four nodes 11 8 1 10 so let's remove the last node of the singly linked list which is 10 so i'll just uncomment this part and instead of delete first i'll do delete last because we are removing the last element and then i'll simply print the singly linked list again if i run the code so here you can see that initially the list contains four nodes then we call the delete last which removed the last node and returned from this method and then we simply printed its data which came out to be 10 so here you can see the 10 is the last node of the singly linked list and after that i again printed the singly linked list which came out to be 11 8 and 1 because 10 is already removed so similarly let's say if i remove one more data and if i run the code now so here you can see first 10 got removed by this method and then when we called again delete last one was removed so the singly linked list now has only 11 and 8 10 and 1 are removed so for in this video we saw that how we can delete the last node of a singly linked list i hope you like this video thanks have a nice day hello everyone so in this video we will discuss that how we can delete a node from a singly linked list at a given position in our previous videos we saw that how we can insert a node in a singly linked list at a given position so now we'll see that how we can delete a node from a given position in a singly linked list so here you can see let's say we want to implement a method to delete a node at a given position so for example let's say if we are given with this singly linked list and we need to write a method delete which will take in a position and we are assuming the position to be valid which means it should lie in the boundaries of the singly linked list and which should start from one so let's say in this singly linked list if you want to delete a node at position one then that would be this node which is the first node of a singly linked list so we are assuming that it should start from one and let's say if you want to delete a position three so this is position one position two portion three so this is the node which you want to delete and we are assuming the position to be valid here so let's say our singly linked list has four nodes and if we pass position as six then either we need to throw an exception or we can assign a position to a value which points to the last node of the singly linked list so based on these two assumptions let's see the algorithm so before we start in case if you are new to my channel then please subscribe to my channel so that you never miss any update so let's say if you are given with this singly linked list having three nodes so there arise three cases where we can delete a node from the singly linked list one would be if we provide the position as one then we are telling that we want to delete the first node of the singly linked list and let's say if we provide position two then we are saying that we need to delete the second node which is between node one and node three and as we are assuming that we are starting from position one with first node here node having data as eight will be position one this would be position two and we want to delete this node and after this deletion node having values eight will not point to this node it will point to node one and the third case would be let's say if we want to delete the last node so we'll pass the position as three this is position one position two and position three so this node will be deleted and the second last node which is this node will point to null after this deletion so let's see these three cases so let's say if you want to delete the first node so we simply provide a position as one so in the code we simply check whether position is equal to one or not so if position is equal to one then if part will be executed and in order to delete this node which is being referred by head what we simply do is we simply assign value of head dot next to head so head dot next is the second node so we'll simply assign head dot next value to head so now head will point to the second node so it looks like this so as we are deleting the first node head is pointing to that node so we can't directly delete this node because if we directly delete this node then the rest of the nodes will also get removed so first we do is we simply assign head dot next value to head so that the rest of the singly linked list is being referred by head because after deleting this node our singly linked list will become tan one and null so once this assignment is done this node is being not referred by any other node so this will be garbage collected so it looks something like this that now our singly linked list becomes head is pointing to node having value as tan and node having value as tan is pointing to a node having value as one moving ahead now let's say if we are given with this singly linked list having four nodes and let's say if i want to delete any node in between of the singly linked list so let's say if we call delete method with value as three which means we want to delete the node at position three which is this node now friend as it is a singly linked list in order to delete this node we need to somehow traverse to its previous node so how we can traverse to this previous node is let's see the algorithm we check whether position is equal to one or not so position is equal to three so this condition comes out to be false in the else part as you want to delete the node at position three we need to somehow reach to position two so what we do is we simply create a temporary list node by name previous we'll assign a value head to it so it will simply start from the first node and our task is to make it reach to a node having value as position minus one so here as we have already started with head we will create a count variable having value as one because this count variable will help us reaching previous to a node just previous to a position from where we want to delete this node which is this position so we need to provide a while loop and in this while loop we provide a condition as count should be less than position minus one so position value is three and if we do minus one it becomes two so one is less than two so the condition in while loop comes out to be true and inside this while loop we simply traverse previous to its next position by assigning previous.next to previous so previous next is pointing to this node so after this assignment previous will point to its next node via this reference so it would look something like this and as we have incremented previous to by one position will increment count by one so count becomes two now we'll again check whether value of count which is two is less than position minus one or not so three minus one is two so two is not less than two so this condition comes out to be false and while loop will terminate and here you can see that as you want to delete the third position we have reached to position two via this while loop so after this while loop now our task is to delete the node at position three now as you want to delete this node and after its deletion this node next should point to this node because we don't want to remove this node along with this node we only want to remove this node so our task is to break this link and create a link from this node to a node after the node which you want to delete so at the first step what we do is we can't directly remove this link here because if we remove this link then this complete singly linked list will be garbage collected and in order to reach this node we also need a pointer to this node as well because if we have pointer to this node then we can use its next value to reach this node because we want to somehow assign previous next value which is this value to this node so at the first step what we are doing is we are creating a temporary list node having value is current and we are assigning previous next value which is this node so it would look something like this that current is pointing to previous next and after this it becomes very easy to delete this node as we discussed previous next should not point to this node it should point to this node the node next to our current so what we do is we simply assign value current dot next to previous dot next so here you can see current next is pointing to this node and previous next is pointing to current so we need to break this link and we want this link to point to current next because if we break this link and we assign it to this node then this node can be freed up easily so when this assignment will be done current next value which is this node will now get referred by previous next so it would look something like this that this link will go away and previous next will now point to current next so it would look something like this now previous next is pointing to current next because we want to free this node from the singly link list and after this assignment when this method will get complete we know that current was part of this method as a local variable so now current will be simply garbage collected because there won't be any reference to this node after this method gets over so it would look something like this that it would be deleted and now if we rearrange it it would look something like this that now node 10 is pointing to node 1 so this was the case when we deleted a node which was between the singly link list so now let's say if we are given with this singly link list and we want to delete the last node which is at position 3 so we'll call delete method we'll pass the position as 3 and the algorithm remains the same at the first step we check whether position is equal to 1 or not so position is equal to 3 so this condition comes out to be false now as we want to delete the node at position 3 we somehow need to traverse to position 2 so for that we create a temporary list node previous which starts from head we create an integer variable count which starts from 1 so now in order to reach to a node which is previous to node which we want to delete we simply provide a while loop so now here you can see this count variable will help this previous to reach to a position which is just before the node which you want to delete so we provide condition as count should be less than position minus 1 because we have initialized already count by 1 and previous is already pointing to head so here you can see that value of count is 1 if we do position minus 1 we get 3 minus 1 which is 2 so 1 is less than 2 so this condition comes out to be true and inside this while loop we simply traverse previous.next node by assigning previous.next value to previous so previous is pointing to this node and its next is pointing to this node so after this assignment previous will point to second node via this link we will increment count by 1 count becomes 2 and now here you can see this condition comes out to be false because 2 is not less than 2 so this value will terminate and we know that we have reached to a node which is just previous to node which we want to delete which is at position 3 so at the first step what we are doing is we are simply creating a list node current which will hold the value of previous.next so previous.next is this node which we want to delete so current will point to this node and now using previous and current will simply break this link and will assign this link to current.next because we want to free this node so we can only free this node if we break this link so here what we do is we simply assign value of current.next which is null to previous.next so this link will go away and previous.next will point to current.next so after this method gets over here you can see current was a local variable so this node won't be referred by any other node so this will be simply garbage collected and our singly linked list will become a list having two nodes 8 and 10 and the last node will be removed so friends in this video we saw that how we can delete a node from a given position in a singly linked list i hope you have find this information useful and in case if you have find this information useful then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so in our previous video we discussed about that how we can delete a node from a singly linked list at a given position so in our last video we saw the animation of the algorithm step by step now in this video we'll actually code the algorithm and we'll test its working so in our singly linked list class which has a head of type list node as an instance variable here we have coded many methods which are part of singly linked list now here i will be coding the method as delete which will take in a position and based on that position that particular node will be deleted from the singly linked list so let's say i give the method name as public void delete which takes in a position so friends here you can even return the list node which you just deleted via this method but i am keeping it as void and here we are assuming that position is valid and starting from one so let's say for example our linked list has few nodes such as three four seven eight and let's say nine now here you can see the linked list has five nodes three four seven eight and nine so three is at position one four at position two seven at position three eight at position four and nine at position five so let's say if we want to delete the node from position one so this node will be removed and then linked list will have this these nodes if we want to delete a node which is in between then let's say if you want to delete node as three so seven will be deleted and the remaining list will be three four eight and nine here four will simply point to eight and seven will be removed from the singly linked list and let's say if we want to delete the last node so here you can see as there are five nodes and if we pass the position as five then nine will be deleted so let's see the algorithm so based on our assumptions that position is valid and starting from one we provide a fls condition the first step we check whether if position is equal to one which means if position is equal to one it means that we are simply removing the first node of the singly linked list so here as head is pointing to the first node after its removal head should point to the second node so we'll simply assign head dot next value to head so for example here if you see head is pointing to node three and if you want to delete the node from position one then after node three gets deleted our singly linked list will become four seven eight nine because head will now point to four so we can simply do head equals to head dot next which will assign the next value which is this value to head so this is the first case so in the else part we will see that how we can remove a node from a singly linked list which is in between of these nodes or at the end of the singly linked list so both these cases will be covered in else part so here let's suppose if you want to delete the fourth node which is at position four now the idea behind this algorithm is which we also discussed in our previous video when we did for the insert here what we do is in order to remove eight from the singly linked list we need to break this linkage from seven to eight and instead of seven pointing to eight seven should now point to nine and once seven will point to nine eight will be removed from the singly linked list so in order to break this linkage we need to first reverse to this node which is just behind this node because we need to use this reference remove this reference link and make sure that seven now points to nine so in order to reach the previous node from eight what we do is we simply create a temporary list node previous and we started from the head and then we'll provide a while loop so that we can reach to this node so how we can reach to this node is we will create a counter variable and as previous is already pointing to head we'll assign it with one and now using count and position we will reach to this node so in the while loop we provide condition as count should be less than position minus one so when count is less than position minus one this while loop will keep on iterating and with each iteration we'll simply traverse previous to its next position by assigning previous.next to previous and we'll simply increment count by one so friends when previous will reach to node seven the value of count will become three and here you can see we pass the value of position as four because we want to delete eight so four minus one is three so three is not less than three so after this value will terminate in order to assign sevens next to nine because we want to break this linkage here what we do is we first reach to eight and how we can reach to it is here you can see previous is already pointing to seven because we have reached to seven in this while loop so here we'll create a temporary node current and we provide the values previous.next so this is the previous and if we do .next we will reach here so current will point to node having value as eight and now as we want to point seven next to nine what we simply do here is to previous.next which is currently pointing to eight we will assign the value as current.next because current next is pointing to nine so now sevens next will point to nine instead of eight via this line so after this line nine this link will be gone and there will be link from seven to nine so eight once this method gets terminated eight will be garbage collected so this is the code to delete a node from a singly linked list from a given position so in our main method now let's test it's working so here in our previous video we discussed about the insert method so let's say if i run the code so you see the currently the linked list has five nodes two four three five seven so we'll use the same linked list and we'll delete the first node the node in the middle and the last node so here if i do delete one which is at position one so this is the singly linked list which we saw while running the program so two will be removed so let's run it so here you can see it printed four three five seven because two got removed and now let's say let's say now linked list has four three five seven and we want to remove node five which is at position three because two is already removed and we are removing five which is at position three so we'll call delete with position three so now it should print four three seven because five will be removed so here you see it printed four three seven now we have four three seven and let's say we want to remove the last node which is seven so four is at position one three is at position two and the last node seven is at position three so we'll again call delete with position three and if i run it should print four and three so here you can see it printed four and three so friend this is how we can delete a node from a singly linked list from a given position and here we are assuming that position should be valid that it should lie into the boundaries of our singly linked list so friends i hope you have liked this information and in case if you like this information then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to search an element in a linked list in java so friends in our previous tutorial we discussed how to create a singly linked list and also we discussed about the few of the concepts associated with the linked list so in this tutorial we will discuss how to search an element in a singly linked list through a java program so here you see that there is a simple linked list having say four nodes with the data as 10 8 1 11 and we are giving a head which is pointing to the first node so let's say suppose we want to search for a key having a data with a value 1 so looking at the linked list we can see that the third node has a data with a value 1 so in order to search this key there is an algorithm for it which can search this key into this singly linked list so let's demonstrate this algorithm quickly so in order to search this key into the singly linked list what we'll do we'll first create a node which will name as current and this current will point to the head so which is the first node of our linked list now moving ahead so idea behind this algorithm is we will traverse the singly linked list completely till the end and we'll check for the data and we'll match it with the search key and if it is if they are equal then we'll return true and if they are not then we'll return false in a while loop we'll place a condition where the current is not equal to null till then loop this so currently we see this current is pointing to the first node so it's not null so we'll it will go into the while loop and it will check that whether current.data is equal to the search key so currently the current.data points to 10 because the data inside this first node is 10 so we'll check that whether 1 is equal to 10 or not so it's not equal to 10 so this condition comes out to be false and we'll go to next step so we will just traverse the current to its next so if we if you see this current points so first and its next points to the second node so we'll traverse the current to the second node moving ahead so again in while loop we'll check whether current is equal to null or not so here current points to the second node so it's not null so it enters the while loop and then we'll check whether current.data is equal to the search key or not so here current.data points to 8 and we'll check that whether 1 is equal to 8 or not 1 is not equal to 8 so this condition comes out to be false and we'll go to the next step so the next step is so what we'll do we'll just traverse the current node to its next so if you see the current points to the second node and its next which is this points to the third node so we'll traverse it to the third node and then again we'll execute the condition in while loop we'll see that current is not equal to null because it's points to the third node and we'll go inside the loop and here we'll check whether current.data is equal to search key or not so current.data which is equal to 1 here we see that search key and current.data are equal so we have actually found our element so what we'll do so we'll just we'll just return true and we'll print a message as that search key found so similarly if we see the negative condition that whether suppose we want to make a search for the key having a value 12 so looking into the list we see that 12 is not inside this linked list so we'll see the algorithm of it so first we'll create a current node which will point to the head so below we'll check whether this current is equal to null or not and similarly we'll see whether this current.data is equal to search key or not so for the first iteration it's not equal so we'll simply traverse the current to the second node we'll again check whether current is equal to null or not so we see this current is not equal to null so this while loop executes and current.data is also not equal to search key so we'll just traverse the current to the third node and similarly we'll again check whether current is equal to null or not so as current points to third node so it's not equal to null so the while loop executes and we'll check whether current.data is equal to search key or not so one is not equal to 12 so again this condition fails and we'll just so we'll just traverse the current to its next node which is the fourth node and again we will check whether current is equal to null or not so it's not equal to null we'll check current.data is equal to search key or not so current.data is 11 and search key is 12 so they are not equal so we'll traverse the current to its next so now here you see that last node's next point to the null so the current dot next is null so we'll assign null to this current so it will be something like this so now current points to null and if we now execute the while loop so we'll see that whether current is equal to null or not so current is equal to null so this while loop condition breaks out and will simply return false that search key not found so friend this was all about a demo now we'll see how we can code this in java so we'll go to our eclipse initially in our previous tutorials we we created a singly linked list which say if i run the program so this singly linked list was something like this 10 8 1 and 11 and then null so in this tutorial we'll first code the algorithm so we'll create a public method public and we'll give a return type as boolean and we'll create a method say find and to this method we'll give list node the head and integer say search key so basically this method takes in a head and the search key so our first thing will be if say let's say if head is equals to null so suppose we have a linked list where head points null so we'll just return false and then we'll say code whatever we discussed into the slide so we'll create a current node and make it point to head so now we'll give a while loop so inside this while loop will say current not equals to null so we'll iterate till current equals null so inside this while loop will provide a condition which what we discussed in the slide as when current.data equals search key then just return true and after if we'll just traverse the current to its next node so current to current will provide current dot next value and if the current reaches the end and the search keys not found will just simply return false so into our main method what we'll do we'll create a if condition and let's say here we'll say singly linked list dot find and to find will provide head and provide a value one so one is into the singly linked list so we'll provide a value one and we'll set out as search key found or we'll say else search key not found so we saw that the linked list which we created in our previous tutorial has the value as 10 and 1 and 11 so first we are considering the positive case we know that one is in the list so we'll just run the java program so you see it prints the search key found because one is in the singly linked list now let's say suppose you want find whether the linked list contains the value 12 or not so we know that it doesn't contain the value 12 so if i run it so it prints search key not found so friends in this tutorial we'll discuss how you can search an element in a linked list through a java program hope you like this video please like comment share and subscribe my youtube channel you can also visit my blog the link is provided in the description thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to reverse a singly linked list in java so friends suppose we have a linked list with node say 10 8 1 11 and we provide this linked list as an input so after its reversal the linked list becomes something as 11 1 8 10 so basically it reverses the list so here 10 8 1 11 gets reversed and becomes 11 11 1 8 10 so let's see this algorithm through a demo so here we see a singly linked list having four nodes say 10 8 1 11 and where head points to the first node so in order to reverse this singly linked list here is the algorithm so we'll see how this algorithm makes this singly linked list reverse so the first step of execution would be we'll create a list node by the name say current and a value of head will be assigned to it so so currently head points to the first node so similarly the current will point to the first node which is 10 and moving ahead then we'll create one more node which will point to null so the name of this node would be previous moving ahead we'll create a node by the name next and we'll assign a null value to it so the basic idea of this algorithm is to traverse each node one by one and and apply some logic to reverse the position of the nodes so in order to traverse each node one by one we'll apply a while loop and in while loop we'll place a condition that till current becomes null we will iterate this while loop so here we'll see this current points to first node and it's not null so this while loop executes and then what we'll do here we see this next point to null so we'll assign the current's next node to it so if you see current points to the first node and its next point to the second node so we'll assign current's next value to the next node so then it will become something like this moving ahead here you see the current next which is this pointer it points to the second node and previous points to the null so idea is to break this pointer and provide it a null value so we what we have done is we will do current dot next and we'll assign a null value to it so it will look something like this so moving ahead and to our previous node we'll assign a value which current holds so it will be the first node so it will become something like this moving ahead and then to simply current will assign the value which is in the next so after the first iteration if i rearrange this nodes it would look something like this so this is the condition with the first while loop now we'll again execute the while loop and we'll see that current is equal to null or not so current points to the second node which is not null so this while loop executes then we'll perform the same steps so here we'll provide the current's next value to the next node so here current next is the third node we'll assign current next value to the next node and similarly to current next we'll provide the value which is present in the previous so so here if you see that current next pointer points to the third node so we'll remove this link and we'll assign it what the previous holds so here previous points to the first node so we'll do something like this so the current next now points to the previous which is the first node so moving ahead to this previous now we'll assign the value current and so moving ahead now we'll simply assign whatever the value present in the next to the current so the current traverses to the third node we'll again iterate the while loop and we'll check whether current is equal to null or not so here current points to the third node which is not equal to null so this loop executes and similarly now we'll assign current next value to the next so it will look something like this moving ahead and to current next we'll assign to the previous so it becomes something like this moving ahead will make previous point to current and finally we'll make current to point to the value which next points so it will traverse the fourth node and again we'll check whether current is equal to null or not so it's not equal to null so now next points to current next so so here current next points to null therefore the next value pointing to null moving ahead and to currents next we'll assign the previous node value so it will look something like this and will traverse previous to point to current so it will look something like this so finally we'll assign current the value of next which is null so now we'll again execute while loop and we'll see whether current equals null or not so here current equals null so therefore this condition comes out to be false and the while loop breaks out so the last step would be to return the previous so this previous becomes our new head so if you see the initially head pointed to 10 and then 8 1 11 and now as previous becomes our new head so now the linguist is reversed so the first node is 11 second is 1 third is 8 and fourth is 10 and then it points to null so here previous becomes our new head and we exit our algorithm so friends let's go to eclipse and see demonstration of this algorithm so friends in our previous tutorial we created one singly linked list so here if i just remove this part and if i run this job program so you see we initially we have created a singly linked list having the nodes as 10 8 1 11 and they are interconnected so let's reverse the singly linked list so in order to reverse the singly linked what we'll do we'll create a method whose return type is the list node and we'll give a method name as reverse so this reverse method will take the head of the singly linked list so we'll say list node head now the first step would be we'll simply check whether head points to null so if it points to null we'll return the head so if head equals null so we'll simply return head and moving head will code our algorithm so we'll create a list node say current and assign a value of head to it then we'll create a list node previous and assign a null value to it we'll create a list node next and assign a null value to it and now we'll create a while loop so the condition and while loop would be current not equals null so here while loop execute till current becomes null so here to our next we'll assign the value as current dot next and to current dot next we'll assign value as previous to previous we'll assign the value which current holds and finally to our current we'll assign the value which next variable holds and the last step would be to simply return previous because previous becomes our new head so we'll return the previous so this is the algorithm so let's see its demonstration so here i will call the reverse and provide the head and list node so whatever is the return from this reverse method will be our head of the reverse list so we'll simply display it now so we'll run this program now so here you see initially the list was 10 8 1 11 and last node was pointing to null and now it becomes 11 1 8 10 where 10 points to null so so this is how we can reverse a singly linked list in java so friends hope you like this video please like comment share and subscribe my youtube channel you can also visit my blog the link is provided in the description thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to find nth node from the end of the linked list in java so friends given a linked list and a value of n we need to find the nth node from the end of the list if suppose this is the linked list having the nodes as 10 8 1 11 and 15 so they are total five nodes and given the value of n is equal to 2 so it means we have to find the second node from the end of the list so if you see the second node from the end of the list is say 1 2 so 11 is the second node from the end of the list so if this is the input then you can see the output would be the second node from the end which is 11 now let's see the demo of the algorithm and it's working so friends here is the linked list having the nodes as 10 8 1 11 and 15 and suppose we are given the value of n is 2 it means we have to find the second node from the end of the list here you can see that this is the algorithm for it so let's see the demo of the algorithm so first we'll create a main pointer which will be pointing to the head and if you see the head points to the first node therefore there would be a main pointer which will point to the first node moving ahead now we'll create a reference pointer which will also point to the head so this is the reference pointer which will point to the first node we will create an integer variable by name count and we'll assign the value zero to it so currently count is zero so friends the idea behind this algorithm is in order to find the nth node from the end of the list what we'll do we have taken these two pointers both of which are pointing to head so if we take the reference pointer we'll make this reference pointer to move n positions so when this reference pointer has traversed the n positions then we'll move main pointer reference pointer together till reference pointer encounters null so when that reference pointer will encounter null the main pointer would be the nth position from the end of the list so let's see how this algorithm works when the value of n is true so currently this while loop will work till the value of count is less than n so currently if you see the value of n is true and the count is zero therefore the count is less than n so it will execute the while loop and now we will just traverse the reference pointer to its next position so here we will assign the reference pointer's next value to the reference pointer so reference pointer points to first node and its next point to the second node therefore assign the reference pointer next value to the reference pointer so it will look something like this moving head will increment the value of count and now again this while loop will execute because count is less than n and similarly we'll move the reference pointer to its next that is assigning the reference pointer next value to the reference pointer and then we'll increment the value of count so now count becomes 2 so now the value of count is not less than n if you see the value of n is 2 and count is 2 and 2 is not less than 2 therefore the condition in while loop is comes out to be false therefore the while loop breaks out and our execution reaches the second while loop so at this point the reference pointer has moved the two positions from the head and in this while loop what we'll do will move both pointers the reference pointer and the main pointer together till reference pointer encounters the null value so the condition inside it would be this while loop will execute till reference pointer is not equal to null so currently the reference pointer is not equal to null therefore the condition in while loop comes out to be true so first we'll simply traverse the reference pointer to its next value moving head and now we'll move the main pointer to its next value so we'll assign the main pointer's next value to the main pointer again the reference pointer is not equal to null so this while loop will execute will traverse the reference pointer to its next value and similarly we'll move the main pointer to its next value that is by assigning the main pointer's next value to the main pointer so again this while loop condition will be evaluated and you can see the reference pointer is not equal to null therefore this while loop will execute now reference pointer will move to its next value and similarly the main pointer will move to its next value so now once again the boolean value in the while loop will be evaluated and currently if you see the reference pointer points to the null therefore the condition in while loop comes out to be false and this while loop breaks and finally if you see the main pointer is at the second position from the end of the list therefore we'll return this main pointer because this is the second note from the end of the list so friend this was the demonstration of the algorithm let's move to eclipse and see it's working so friends in my previous tutorial i have created this singly linked list class having an instance variable which stores the head and having an inner class which is the list node if you want to see it's working then you can watch my previous tutorials so so in this tutorial we'll write a method which will fetch the anet node from the end of the list so first we'll create a method and the return type of it would be list node let's say we give the name of the method get anet node from end so this method will be taking a value of n now first we'll check if head is null null then just return null then we'll check that if let's say value of n is less than equal to zero so value of n is less than equal to zero then we can throw an exception say throw new you can throw a legal legal argument exception and we'll pass the string as say invalid value n equals moving ahead so first we'll create a list node having name as main pointer and we'll assign the value of head to it similarly we'll create another node which is the reference pointer and we'll assign the value of head to it then we'll create a integer variable count having value as zero now we'll create the while loop which we saw in the slide so while and we'll give condition as count will less than n and we'll simply traverse the reference pointer to its next value that is we'll assign the reference pointer next to reference pointer and we'll increment the count by one and here now let's suppose the linked list has three nodes and if we provide the value of n as say five therefore this reference pointer might reach to a null value so before this we can even if we can check that if if reference pointer is null then we can simply throw an exception we can throw an illegal argument exception we can give string as n is greater than the number of nodes in list so here if suppose reference pointer comes out to be null then the value of n is surely greater than the total number of nodes in the list moving ahead we'll create another while loop and in this while loop we'll provide the condition as ref pointer should not be equals to null and we'll simply and here we'll simply assign the reference pointer next value to the reference pointer and we'll traverse the main pointer to its next value and finally we'll just return the main pointer because this will be pointing to the nth node from the end of the list so if you see that this is the code for getting the nth node from the end of the list and if you go to the main method then i here then here there is a list having five nodes with the value as 10 8 1 11 15 and if i run this it will print the list so here it's 10 8 1 11 15 so there are total five number of nodes so let's say if i do nth node so i just created a list node by the name nth node from end and if i call this method okay the nth node from end and if i pass the value as say 2 and if i print and here if i print at nth node from end is dot data so now if i run the program you can see it prints 11 because 11 is the second node from the end of the list and suppose if i provide the value as say negative value say minus 1 then it throws an exception saying that illegal argument exception say invalid value of n which say invalid value of n which is equals to minus 1 and suppose the total number of nodes are five and if i give the value of six which and i wanted six node from the end of the list and if i run this so you can see it will throw illegal argument exception saying that six is greater than the number of nodes in the list so friend this was the working of the algorithm which we saw in the slide hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to remove duplicates from sorted linked list in java so suppose we are given a sorted linked list so if you see then the linked list has five nodes having the data is 1 1 2 3 3 so this is a sorted linked list but you can see that there are duplicates into it so you can see one is duplicate and the three is duplicate so in this tutorial we will discuss how to remove these duplicates from the sorted linked list and if you see the output then the output would be like one two three and all the duplicates will be removed so let's move ahead and see the demo of the algorithm so here if you see we are given the linked list which is sorted and having nodes as 1 1 2 3 3 and this is the algorithm which will remove the duplicates from this sorted linked list so let's see working of this algorithm so in order to remove the duplicates from the sorted linked list first we'll do we'll create a list node which will point to the head moving ahead so the basic idea behind this algorithm is we will traverse the linked list through this current pointer and we'll check whether this data of this current node is equal to data of its next node and if they are equal it means we have encountered a duplicate and we will write the logic to remove that duplicate node so here if you see we'll iterate this completely based on this condition so the condition would be the current should not be null and current dot next should not be null so here if suppose the current node reaches this last node so current dot next will be null it means there is no more nodes to traverse therefore this condition is required so let's see how this algorithm works so first this condition will be checked there whether current is equal to null or not so current is not equal to null because it is pointing to the first node and current dot next should not be null so current dot next is also not null because it is pointing to the second node therefore this while loop condition comes out to be true and it will encounter a if statement and here we will check whether current node data is equal to current's next data current data is one and current's next data is also one therefore they are equal so this if statement condition comes out to be true and we have encountered a duplicate so here if log will be executed and in order to remove this duplicate what we'll do we will assign current next next to the current next so here if you see current next points the second node so we have to remove the second node therefore we have to break this point and we have to assign it to the second node so this is the statement for it we will assign current next next to current next so it would be something like this so now current next points to current next next and as this node has no reference therefore this would be garbage collected so moving ahead so now again the condition in while loop will be evaluated so here current is not null and current's next is also not null therefore the condition in while loop comes out to be true and while loop will be executed so now we'll check whether current's data is equal to current next data so current data is one and current next data is two so they are not equal therefore the if block condition comes out to be false and the else will be executed so it means that both the nodes like current and current next are different nodes and they are not duplicate therefore we'll simply traverse the current to its next node and now once again the while loop condition will be evaluated so current is not null and current's next is also not null therefore the while loop will be executed and now we'll check whether current's data is equal to current next data so current data is two and current next data is three so they are not equal so it means that data into both the nodes are different so else condition will be executed and we will assign current next to current so we will simply traverse the current to its next node so now once again the while loop condition will be evaluated and here you can see current is not null and current next is also not null therefore the while loop condition comes out to be true and now it will be evaluated whether current's data is equal to current next data so current data is three and current next data is also three so they are equal it means that we have encountered a duplicate here and we have to now remove this node having the value as three therefore in order to remove this node we have to first break this pointer and we have to assign this pointer to current next next so current points to three and its next points to three and its next points to null therefore we'll assign current next next to current next so it would be something like we'll remove this pointer and we'll assign current next to current next next which is null and as this node has no reference to it therefore this would be garbage collected and now once again the while loop condition will be evaluated so current is not null but current dot next is null so if you see current next points to null therefore this while loop condition comes out to be false and it makes sense because we don't have any more node true traverse therefore this while loop condition breaks out and if you see then we have removed the duplicates from the sorted linked list so head points to one one points to two and two points to three and three points to null so the output would be something like this so friend this was the demo of the algorithm now let's go to eclipse and see the working of the code so friends in my previous tutorials i have created a class by name singly linked list so in this class we have this instance variable which holds the head of the linked list and it is private inner class list node which will be holding the nodes in the singly linked list and if you want to see the working of this code then you can watch my previous tutorials so here we have simply created a singly linked list and we have inserted few nodes having the data as one one two three three and if i run this class so it will print the linked list as one one two three three so this is the singly linked list which we saw in our slide and it has duplicate as one and three so let's write the code to remove this duplicate from sorted linked list we will give return type as void remove duplicates so this is the method where we'll write the code to remove the duplicates from sorted linked list so first we'll provide if conditions say if head is null then simply return from this method and next we'll code the algorithm which we saw in the slide so we'll create a list node by name current and we'll assign the value head to it then we'll create a while loop and we'll provide the condition as current not equal to null and current dot next not equal to null and inside this value we'll provide if block as if current data is equal to current dot next dot data so this is the condition to check whether adjacent nodes are duplicates or not so if they are duplicate then we'll simply remove the duplicate node by current dot next and we'll assign the value to it as current dot next dot next and we'll provide a else block as so suppose the adjacent nodes are not same then we'll simply iterate current to its next version by assigning current's next value to current so friends this is the code to remove the duplicates from sorted singly linked list now in the main method i will simply call the remove duplicates and let's again print the linked list so if i run the code now so here you can see initially the linked list was 1 1 2 3 3 and after removing the duplicates it became 1 2 3 so friends this was the code to remove the duplicates from sorted linked list i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to insert a node in a sorted singly linked list in java so friends let's suppose we are given as sorted singly linked list having four nodes say 1 8 10 and 16 and suppose we want to add a node having data as 11 to it friends here we want to insert this node such a way that the sorting order is maintained in the linked list therefore in order to insert this new node into this sorted singly linked list then here is the algorithm for it so currently you see the head points to first node having data as 1 then it goes to 8 10 16 and we want to insert the node having data as 11 and we want to insert in such a way that after insert the sorting order is maintained in the list so let's see the working of this algorithm step by step so in order to insert a new node in a sorted singly linked list first we'll create a list node by name current which will point to the head so here if you see the head points to the first node therefore the current will also point to the first node then we'll create a temporary node which will point to null so this while loop will execute till current is not equal to null and current data is less than new nodes data so we'll see this algorithm step by step and after we complete this value you will come to know that why these conditions are needed so here if you see current should not be null so current is pointing to first node and it is not null and current data so current data is 1 here and new node data is 11 so 1 is less than 11 therefore this while loop condition comes out to be true so in first step what we'll do we'll assign the value of current to temp so current points to the first node therefore when we assign the current's value to the temp it it becomes something like this so now temp points to the first node and then we'll traverse the current to its next node by assigning current.next value to current so current points to first node and next point to the second node therefore we'll simply assign the current's next value to current so it would be something like this so now current points to the second node moving ahead now again current is not equal to null and current data which is 8 is also less than new node data which is 11 therefore this while loop condition comes out to be true and we'll assign current's value to the temp so it would look something like this and then we'll simply traverse current to its next position by assigning current.next value to current moving ahead so again current is not equal to null and current.data which is 10 is also less than new nodes data which is 11 therefore this while loop condition comes out to be true and we'll simply assign current's value to the temp so it would look something like this and then we'll simply traverse current to its next position by assigning current.next value to current moving ahead so now current is not equal to null and if you see current data so current data is 16 and new node data is 11 therefore current data is not less than new nodes data therefore this while loop condition comes out to be false and this while loop breaks so if you see we have traversed current to the node which is just greater than the value of new node and we have also kept a temporary node which is just behind the current node so the idea behind keeping this temporary node is once this while loop breaks out then we need to insert new node just between 10 and 16 because 11 is the value between 10 and 16 so in order to put the node between 10 and 16 we need this temp node because this pointer will now be pointing to new node and new node next which is pointing currently to null will point to current so in order to insert this new node into sorted singly linked list what we'll do first we'll first make new node next point to current so new node next currently points to null so instead of pointing to null now we want to insert it between 10 and 16 therefore this next should point to 16 and if you see current points to 16 so we'll simply assign the value of current to new nodes next so this is the step for it so it would look something like this so new node next points to 16 which is also referenced by current moving ahead now in order to insert the node between 10 and 16 temp next points to 16 therefore we need to break this link and we need to assign this link to new node so what we'll do we'll assign new nodes value to temp.next so temp.next currently pointing to current will break this link and we'll assign it to new node so it would look something like this and finally when we align this linked list it would look something like this so you see we have inserted 11 just between 10 and 16 and also after insert the linked list has maintained its sorted order therefore we'll simply return the head so friend this was the demonstration of the algorithm now let's go to Eclipse and see the working code so friends in my previous tutorials i have created a singly linked list class which has an instance variable of type list node which is actually the head of our linked list it also has a say inner class by name list node which helps us in storing the data in the linked list so in order to know more about its working please watch my previous tutorials so in this tutorial we will simply write a method which will insert a node in a sorted singly linked list so i'll just create a method public and i will give a return type to it as list node so let's argue method name is insert in sorted list this method will take an argument of integer by name value so this value will be stored as a part of node into the sorted singly linked list so first we'll create a list node for this value so i'll give the name to it as new node and then we'll give a condition as if head is null then simply return this new node here moving ahead we'll create a list node current which is saw in slide and we'll assign a value head to it then we'll create a list node by name temp we'll assign null to it so first we'll create a while loop so in this while loop we'll provide a condition as current not equal to null and current dot data is less than new node dot data so we'll iterate till current is not null and current data is less than new nodes data so in while loop first step would be we'll assign the value of current to temp and we'll simply traverse current to its next value so basically these are the two statements which we'll be providing into the file loop and after while loop gets executed we know that that current now points to a node which is just greater than the new nodes data and temp points to the node which is just lesser than the new nodes data therefore first step would be to new node next we'll assign the value of current and then to temp next we'll assign the value of new node and finally we'll just return head so friend this is the method by which we can insert a node into sorted singly linked list so here if you see in the main method currently there are four nodes by data is 1 8 10 16 so they are the same what we saw in the slide so if i print this singly linked list you can see it print as 1 8 10 16 and null so therefore currently this is in sorted order and let's suppose i call the method insert in sorted list and give the value as 11 so friends once this method is executed it will insert 11 into sorted singly linked list so i will just print it again and if i run the program so currently it was a sorted linked list and after insertion of 11 the sorting order is still maintained so this is the algorithm by which we can insert a node into sorted singly linked list so friends i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to remove a given key from singly linked list in java so here if you are given a singly linked list having five nodes say 1 8 10 11 and 16 where head points to the first node and if suppose we want to delete a key having the data as 11 so currently if you see the fourth node has data as 11 therefore we need to write an algorithm which could delete this fourth node from the singly linked list if you see below the algorithm for it so let's go over to the algorithm step by step so first we'll create a list node by the name current and it will point to head so here current points to the head then we'll create a list node by name temp and it will point to null so this temporary node points to null then we'll traverse the linked list in a while loop and we'll iterate the linked list in such a way that current should not be null and current data is not equal to key so here current points to first node and it's not null and current data which is 1 is not equal to the key 11 therefore the condition in while loop comes out to be true so in first step what we'll do we'll simply assign the value of current to temp so current points to first node therefore now temp will point to the first node and in next step we'll simply traverse current to its next position by assigning current next value to current so current points to first node and its next points to second node therefore we'll assign current next value to current moving ahead here current is not equal to null and current data so current data is 8 and it's not equal to 11 therefore the condition in while loop comes out to be true so here we'll simply assign the value of current to temp and current points to second node therefore the temp will point to the second node now and we'll simply traverse current to its next position by assigning current dot next value to current moving ahead now again current is not equal to null and current data which is 10 is not equal to 11 therefore the condition in while loop comes out to be true we'll simply assign current value to temp and here if you see current points to third node therefore temp will now point to the third node and now we'll simply traverse current to its next position by assigning current dot next value to current moving ahead so if you see current is not equal to null but current data so current data is 11 which is equal to key therefore condition in while loop comes out to be false because current dot data is equal to key therefore the while loop breaks out and and we have traversed the current to the node which we want to delete so here we will check whether if current is equal to null and if current is equal to null it means that we have traversed complete linked list and we haven't found the key therefore we'll simply return from the method and if you see current is not null therefore the condition comes out to be false so finally in order to remove this node which is pointed by current and having value as 11 we need to break this link so the temporary node which we have created earlier was used to hold the previous node position so that once we found the node having the value as key we can simply delete it through the temporary node so currently if you see temp dot next point to this current node so we need to simply remove this link but if we remove this link then the node after current will also be removed therefore we need to assign temp's next value to current's next value so if you see temp next points to current and current next point to the node having value 16 therefore we'll simply assign current next value to temp next so it would look something like this first this link will be removed and when we assign current next to temp next it would look something like this so now you can see temp next points to the current next node and once this method get executed then as current is a list node on the stack it would be garbage collected and finally when we rearrange the link list it would look something like this so friends this was the demo of the algorithm so let's go to eclipse and see the working code we'll also see few of the edge cases there so friends in my previous linked list tutorials i've created a class by name singly link list and this class has an instance variable list node by name hand which holds the data into our singly link list and it has also a private inner class by name list node so this class is responsible for holding the data into the singly link list and if you want to see the working of this code you can watch my previous tutorials so in this tutorial we will simply code the algorithm which we saw in the slide so let's create a method public void delete node so i've just created a method by name delete node and it will take a integer values a key so based on this key we'll remove that node which holds the value of key so in first line we'll just create a list node by name current and we'll assign the value head to it then we'll create a list node by name temp and assign a null value to it we need to code an edge case which we not saw in the slide so that edge case first if suppose head data matched with the key then we need to handle it separately so we can write if so in if condition we can say if let's say current is not equal to null and current dot data equals key so it means that we are handling the case where head data is matching with the key so in that case we need to simply shift the head by one node so to head we'll assign the value as current dot next and we'll simply return from the method so moving ahead we'll now create a while loop which we saw in the slide and the condition would be current should not be equal to null and current dot data should not be equal to key so in first step we'll simply assign temp the value of current because this temporary node will hold the position of the previous node to current and now we'll simply traverse current to its next node and after the while loop we'll give a check whether if current is equal to null that means we haven't found the key in the singly linked list so we'll simply return and suppose if current is not equal to null then then current points to the node we're having the data equal to key therefore we need to remove that node so the temp node is just the node previous to current so we'll assign current dot next value to temp next so what this will do temp dot next currently point to current but as we need to delete this current node we'll simply assign current next value to temp next now in our main method let's see it's working so i've created a linked list which we saw in the slide and if i run the program now you can see the linked list has five nodes as 1 8 10 11 16 now let's say we'll delete the node having the key as 11 and we'll again print the linked list so if i run the code now so here you can see initially there are five nodes and after deleting the node having the key as 11 you can see the linked list become as 1 8 10 16 and the node which was in between 10 and 16 was removed so for this was the tutorial based on deleting a node with a specific key i hope you have liked this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to detect a loop in a linked list in java let's suppose we are given a linked list having six nodes say 1 2 3 4 5 6 and which contains a loop so here if you see the head points to the first node first node points to the second second points to third points to fourth points to fifth, fifth point to sixth and six points to third therefore you can see that this linked list contains a loop as three points to four, four points to five, five points to six and six points to three and again it goes on and if you see below is the algorithm to detect whether a linked list contains a loop or not so let's see the demonstration of this algorithm step by step now in the first step we are simply creating the reference of list node by name fast pointer which is pointing to head so it looks something like this so here you see as head points to this first node now fast pointer will be referring to this first node moving ahead we'll also create one slow pointer which will refer to the head so it would look something like this moving ahead now friends we are encountering here a while loop so the basic idea behind this algorithm is in order to detect this particular loop in a linked list so what we are doing here is we know that fast pointer and slow pointer both are pointing to head so therefore they are at the start position now the basic idea behind this algorithm here is we will move slow pointer one step and we will move fast pointer two steps and if suppose the linked list doesn't contain the loop then we know that the last node should point to null therefore we are traversing fast pointer two steps and slow pointer one step because if linked list contains a loop then there will be a situation as slow pointer is moving slowly and fast pointer is moving fast so the fast pointer will never encounter null value and there will be a situation where fast pointer will meet the slow pointer because of the loop nature so here in while loop we are placing a condition as fast pointer should not be null and fast pointer next should not be null now here we know that as the linked list contains a loop therefore the fast pointer will never be null and we are checking that fast pointer next is not equal to null because as we are traversing fast pointer by two positions we need to make sure that fast pointer next is also not equal to null and in while loop you can see we are assigning a value of fast pointer next next to fast pointer as we are traversing it two steps so we need to make sure that fast pointer next should not be null because if it is null then we will encounter null pointer exception therefore the condition we are placing is fast pointer should not be equal to null and fast pointer next also should not be equal to null so currently if you see fast pointer is pointing to the node first having data as one and its next is also not null therefore the condition in while loop comes out to be true so in the first step what we are doing we are just traversing fast pointer to two steps so here if you see we are assigning fast pointer next next value to fast pointer so here fast pointer is pointing to the first node its next is pointing to the second node and its next is pointing to the third node therefore here we are simply traversing fast pointer by two positions so it would look something like this so we have simply traversed fast pointer by two positions moving ahead now here we are simply traversing slow pointer by one position so we are assigning slow pointer next value to slow pointer so slow pointer is currently pointing the first node and its next is pointing to the second node so we are simply traversing it by one position so it would look something like this and then we are simply checking that with a slow pointer is equal to fast pointer or not so we are doing this step is because there will be a situation where fast pointer will traverse all the nodes and again meet the slow pointer because the linked list contains a loop and there is no end to the linked list so currently slow pointer is pointing to the node second and fast pointer is pointing to the node third therefore they are not equal so the condition in if block comes out to be false and now we'll again check that whether fast pointer is equal to null or not and its next is equal to null or not so fast pointer is pointing to third node therefore it's not equal and fast pointer next is pointing to fourth node therefore it's not equal so the condition in while loop comes out to be true and then in the first step we are simply traversing fast pointer by two positions so here if you see fast pointer next is pointing to the fourth node and its next is pointing to fifth node so we are simply traversing fast pointer from third position to fifth position by assigning fast pointer next next value to fast pointer so it would look something like this moving ahead then we are simply traversing slow pointer by one position by assigning slow pointer next value to slow pointer so it would look something like this moving ahead now we are again checking whether slow pointer is equal to fast pointer or not so you can see slow pointer is pointing to third node and fast pointer is pointing to fifth node therefore they are not equal hence the condition in if block comes out to be false now we'll again check the condition in while loop so fast pointer is currently pointing to fifth node therefore it's not null and fast pointer next which is sixth node is also not null therefore condition in while loop comes out to be true so in the first step we are simply traversing fast pointer by two position and here you can see we are assigning fast pointer next next position to fast pointer so fast pointer next is six and its next is three so we are simply traversing the fast pointer from fifth position to third position so it would look something like this moving ahead now here we are simply traversing slow pointer by one position by assigning slow pointer next value to slow pointer so slow pointer is pointing to third node and its next is pointing to fourth node so we are simply traversing it by one position so it would look something like this moving ahead we are again checking whether slow pointer is equal to fast pointer or not so fast pointer is pointing to third node slow pointer is pointing to fourth node therefore they are not equal so the condition in if block comes out to be false and now we are again checking in the while loop that fast pointer is equal to null or not so fast pointer is pointing to third node therefore it's not equal and fast pointer next which is fourth node which is also not null therefore the condition in while loop comes out to be true now we are simply traversing fast pointer by two positions by assigning fast pointer next next value to fast pointer so here fast pointer is currently pointing to third node and its next is pointing to fourth node and its next is pointing to fifth node so we are simply traversing fast pointer from third position to fifth version so it would look something like this moving ahead now we are simply traversing slow pointer by one position by assigning the slow pointer next value to slow pointer so slow pointer is pointing to fourth node and its next is pointing to fifth therefore we are simply traversing it by one position so it would look something like this moving ahead and now we are checking whether slow pointer is equal to fast pointer or not so friends here slow pointer is equal to fast pointer therefore we are very much sure that this linked list contains a loop so the condition you see in the if block comes out to be true and we simply return true because we have identified that this linked list contains a loop so friends here we saw the demonstration of the algorithm now let's go to eclipse and see the working code so friends in my previous tutorial i had created one class by name singly linked list now this class has a list node by name head which is an instance variable and we also created one inner class by name list node you can watch my previous tutorials in order to understand more about how to implement a singly linked list so in this tutorial we will write a code which we saw in the slide and see it's working so first i will create one method as public boolean and let's say i give method name as contains loop so basically i will write the code inside this method contains loop and it will return me back a boolean value that's whether the linked list contains a loop or not so in the first step we'll create a pass pointer reference variable and we'll assign the value of head to it in the second step we'll create a slow pointer and we'll assign the value of head to it moving head now we'll create one while loop which we saw in the slide and we'll provide condition as fast pointer should not be equal to null and fast pointer next should not be equal to null and in the while loop we'll traverse fast pointer by two positions so we're simply assigning fast pointer next to next value to fast pointer so we are simply traversing fast pointer by two positions and then we are simply traversing slow pointer by one position so we are assigning slow pointer next value to slow pointer and then we are providing an if check that if slow pointer is equal to fast pointer then simply return true and it means we have identified that the linked list contains a loop and after the while loop if suppose we haven't found any loop then we simply return false so friend this is the algorithm which detects whether the linked list contains a loop or not now we'll also create one more method which will actually create a linked list having a loop so public void create a loop in linked list so in this method we'll create few nodes we'll assign them in such a way that it will create a loop inside a linked list so friends in the slide we saw an example where the linked list contains six nodes and which was forming a loop so i will simply replicate that example here so for that i will create list node say first equals new list node and i give value as one now i will create five more list nodes so i'll just give them values two three four five six and i'll change the name as second third fourth fifth sixth now as we saw in the slide that head points to the first node therefore we'll simply assign value of first to head and we also know that first next was second second next is third third next is fourth fourth next is fifth fifth next is sixth and in order to create a loop the example we saw in the slide was sixth node next refer to the third node so here we simply assign value of third to six next so six dot next and we'll assign value of third to it so this will create a linked list containing a loop where first is pointing to second second is pointing to third third is pointing to fourth fourth is pointing to fifth fifth is pointing to sixth and sixth is pointing to third so it will create a loop now in the main method let's test the working of this algorithm so in the first step we have simply created an instance of singly linked list now in the second step i will call this method create a loop in linked list so create so after this method they executed the head will be pointing to a linked list containing a loop so in the third step we'll simply print the output of contains loop on the console so here so here we'll simply call contains loop method and whatever the outcome of contains loop is we'll simply print it on the console so currently you can see the linked list which we have created in this create a loop in linked list method has a loop so the contains loop method should return true so if i run the code so you can see it return true because the linked list which we created in this method had a loop now here suppose i don't assign the value of third to six dot next so if i come in this line then we know that this linked list is not containing a loop so if i run the code now you can see it returned false because here we have break the link in the linked list which was actually making a loop so friends this was the algorithm to detect whether a linked list contains a loop or not i hope you like this video thanks have a nice day hello everyone so in our previous video we discussed about that how we can detect a loop in a singly linked list now in this video we will see that how we can find the starting point of that loop so for example so here you can see the let's suppose we are given with this singly linked list which contains six nodes one two three four five and six but here you can see that from three it goes to four and from four it goes to five from five it goes to six and from six it again goes back to three so here you can see that there is a loop in this singly linked list so in our previous video we saw an algorithm where we detected the loop in a singly linked list so this is the code for that now in this video we will see that how we can find the starting point of that loop so currently if you take this example then three is the starting point of that loop because from three loop starts and ends at three only so our task is to find the starting node from where the loop starts so from this algorithm contains two parts one is the detection of the loop and the second part is to actually find the starting point of the loop so the first part of detecting the loop we discussed in our previous video so in this video we will see that how we can find the starting node of the loop in a singly linked list so friend let's see the demonstration of this algorithm step by step but before we begin in case if you are new to my channel then please subscribe to my channel so that you never miss any update so friends here you can see this is the first part which we already discussed in our previous video where what we did was we created two pointers one was the fast pointer another was the slow pointer we started both the pointers from the head and in order to detect that whether the singly linked list contains a loop what we did was we moved fast pointer two steps and we moved slow pointer one step so why we actually do that is because in case if the singly linked list doesn't have the loop the fast pointer is moving twice the speed of slow pointer so fast pointer will reach to the end of the singly linked list but if the singly linked list contains the loop then as slow pointer is moving slowly fast pointer will cross over this loop perform n number of cycles and it will meet slow pointer in one of these nodes because there is no end to the singly linked list once the point reaches beyond the starting of this loop so in our previous video in this while loop if slow pointer meets fast pointer we actually returned a boolean value true stating that we detected a loop in this singly linked list and we actually returned from this method but in this algorithm when we find a slow pointer is meeting to fast pointer inside this loop then we actually called yet another method which provides us the starting node of the loop so this demonstration of detecting the loop and finding the meeting point of slow pointer and fast pointer as we already discussed in our previous video so here i will be quickly demonstrating it so here we will start fast pointer and slow pointer from head now in while loop we are providing two conditions that fast pointer not equal to null and fast pointer next is not equal to null so why we are providing this condition is because if fast pointer equals null then it means the singly linked list doesn't have any loop and there is an end to this singly linked list because we are traversing fast pointer inside this while loop and at some point fast pointer is pointing to null it means that we have reached to the end of the singly linked list and the next condition fast pointers next should also be not equal to null because here if you see in this line we are traversing fast pointer two places by assigning fast pointers next next so here if fast pointers next becomes null then we'll encounter a null pointer exception here so here we are providing this condition to simply check that whether fast pointer next also should not be equal to null so currently fast pointer is not equal to null its next is also not equal to null so this condition comes out to be true in the first step we are moving fast pointer by two nodes by assigning fast pointer next next value to fast pointer so fast pointer next will make it reach here and its next will make it reach here so it would look something like this moving ahead and as we discussed that we are moving slow pointer by one position so we are simply assigning slow pointers next value to slow pointer so slow pointer will come here moving ahead currently slow pointer is not pointing to fast pointer because here you can see fast pointer is pointing to three slow pointer is pointing to two therefore the condition in if block comes out to be false we again reach to the while loop where we'll check whether fast pointer is equal to null or not so fast pointer is not equal to null and its next is also not equal to null so the condition in while loop comes out to be true now we move fast pointer by two steps by assigning fast pointer next next so fast pointer will reach to node five and slow pointer will reach to node three slow pointer is not equal to fast pointer this condition is false fast pointer is not equal to null and its next is also not equal to null we move fast pointer by two steps by assigning fast pointer next next to fast pointer so fast pointer will reach to node three and we'll move slow pointer by one step so it will reach node four this condition is false because slow pointer is pointing to four and fast pointer is pointing to three fast pointer is not equal to null and its next is also not equal to null we move fast pointer by two steps by assigning fast pointers next next value so fast pointer next is four and its next is five so it came here we'll move slow pointer by one step so slow pointer will reach here so friends now here you can see that slow pointer is met to fast pointer at this node so it means we have detected a cycle inside this singly link list by using two pointers fast pointer and slow pointer so friend this algorithm is also known as fluid cycle detection algorithm now when we get the meeting point of slow pointer and fast pointer we go into the if condition and here we will call a method as get starting node and we'll pass the slow pointer there so now it would look something like this that call will reach to this method where we'll still have the reference to slow pointer which is pointing to the meeting point of slow pointer and fast pointer so friends the idea behind this algorithm to find the starting node of the loop is at the first step what we do we again create a temporary list node we start it from the head and we already have reference to the meeting point of slow pointer and fast pointer so now what we do is we simply provide a while loop we move slow pointer by one step and we move temporary node by one step and in the while loop we provide the condition that perform these steps till slow pointer is equal to temp so when slow pointer will be equal to temp this while loop will terminate and when slow pointer will equal to temp at whichever node this condition comes out to be true that will be our starting node of the loop so here we will move slow pointer by one step and we will move temp by one step so currently here you can see slow pointer is not equal to temp because slow pointer is pointing to five and temp is pointing to node one so this condition comes out to be true now inside this while loop as we discussed we move both the pointers one one step so first we move the temporary node by assigning temp dot next to temp so now temp will come here and then we'll assign slow pointers next value to slow pointer so slow pointer is pointing to five its next is pointing to six so now slow pointer will point to six we check whether slow pointer is equal to temp or not so slow pointer is not equal to temp because temp is pointing to two and slow pointer is pointing to six so the condition in the while block comes out to be true we move temp by one step so it will reach three we move slow pointer by one step by assigning slow pointers next to slow pointer so it will reach here we check whether slow pointer is equal to temp or not so here you can see that slow pointer is equal to temp because they are pointing to the same node so this condition comes out to be false and at the last you can see that we have actually found the starting node of this loop which is three so wherever temp and this slow pointer will meet that node will be our starting node of the loop so from this method we'll simply return this node which is three so from this algorithm is floyd's cycle detection algorithm so now one question comes to our mind is that when we found the meeting point of the fast pointer and slow pointer and we created two pointers temp and slow pointer and made them move one one step in this while loop and when they actually met we are simply saying that that is our starting node of the loop but what's the proof that this cycle detection algorithm given by floyd works so friends in our next video we will see that why this algorithm works because currently we have simply demonstrated the algorithm and we have found our starting point of the loop but we don't have any proof that whether this algorithm actually works or not so in our next video we will see that why floyd's cycle detection algorithm works so friends i hope you have liked this video and in case if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so in our previous video we discussed about the floyd's cycle detection algorithm where we saw that how we can detect a loop in a singly linked list and how we can find the starting node of the loop so friends here if you see that in one of our previous video we saw the algorithm of finding a loop in a singly linked list where we use these two pointers fast pointer and slow pointer and we made fast pointer move two steps and slow pointer by one step and we provided this condition that fast pointer should not be equal to null and fast pointer next should not be equal to null so in case if the singly linked list doesn't had this loop then fast pointer must have reached to the end of the singly linked list but if the singly linked list contains a loop then inside this while loop there will be a point that fast pointer will meet slow pointer because of the loop so here we return true if the singly linked list had the loop or else we returned false so now in this video our task is to find the starting node of the loop so here you can see i will simply copy this method and as the algorithm of the first part remains the same here we need to return back the starting node of the loop we can give any name but here i am giving start node in a loop and here when the fast pointer will meet slow pointer so in our previous video where we saw the animation this meeting point is very important so let's say if there is no loop so here we simply return as null and if there is any loop because slow pointer is meeting to the fast pointer then we'll call one method here which will return as the starting node of the loop and we'll pass the slow pointer to it because this meeting point is very important so i will create one method so friends now here in order to get the starting node of the loop what we do is as we already have this meeting point so this becomes our first node and we also create one temporary node and we point it to the head so now here we have two nodes one is the slow pointer and other is the temporary node where temporary node is pointing to the head of the singly link list and slow pointer is pointing to the meeting point of slow pointer and fast pointer which we saw here and that point will be inside the loop so friends here now what we do is we move slow pointer by one step and we move temporary node by one step and that we do in the while loop so we make them move one one step till they meet and wherever they meet that node where they meet will be our starting node of the loop so here in while loop we provide the condition that keep on iterating and moving temporary node and the slow pointer by one one step till slow pointer is equal to temp so if they are not equal to each other then we are simply moving temp by one position and similarly we are moving slow pointer by one position and when temp and slow pointer value will point to each other this condition will come out to be false and at the end will simply return the temporary node so this temporary node will be our starting node of the loop so this is what floyd cycle detection algorithm states that wherever this temporary node and slow pointer will meet that node will be our the starting node of the loop so friends why this algorithm works we will discuss in our upcoming video but for timing you just think that this algorithm works so here now we'll call this method and we'll test it's working so here you can see that in one of our previous video we already created a loop using create a loop in linked list method where first point to second, second pointed to third, third pointed to fourth, fourth pointed to fifth, fifth pointed to sixth and here you can see sixth pointed to third it means there is a loop and this is the same example which we discussed in our previous slide as well so here we know that there is a loop in a singly linked list if we call create a loop in singly linked list so from head this singly linked list will start and there will be a loop so i'll just comment this part so here i have simply uncommented and we are simply calling create a loop in linked list and let's say we also call the contains loop method so that will return us a boolean value so first i will simply run that part and here you can see that it returned true so it means there is a loop in that singly linked list now what we'll do here we know that the starting point of the loop is list node third having data as three so after we figure out that there is a loop what we do is we simply call the method start node in a loop here what we do is we simply print the data of the returning node so here you can see it printed three which is the data of the node from where the loop starts so friends here the only idea we need to remember is after finding the meeting point of slow pointer and fast pointer we keep the slow pointer at that position only and we create a temporary pointer which will start from the head and in the while loop we simply move both the pointers by one one step and keep checking that whether temp is equal to slow pointer or not so when temp will equal to slow pointer this while loop will terminate and that node where this both the pointers will meet will be our starting node of the loop so friend currently we haven't seen that why this algorithm in our next video we will see the mathematical proof that why this algorithm works which is named as fluid cycle detection algorithm so friends i hope you have liked this video and in case if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so in this video we will discuss that why fluid cycle detection algorithm works so friends in our previous video we saw that how we can detect a loop in a singly linked list and we also saw that how we can find the starting node of that loop so the algorithm which we saw it was just a code which usually works but there was no proof that why this algorithm works so in this video we will see that why a fluid cycle detection algorithm works so friend let's suppose we are given with this singly linked list so here you can see that singly linked list contains nine nodes one two three four five six seven eight nine and if you see that from the sixth node the loop starts and the last node points to the sixth node so therefore this loop starts from here so basically in order to detect that whether this singly linked list contains a loop what we do is we simply create two pointers one is the slow pointer another is the fast pointer and usually started from the head now what we do as the name suggests the fast pointer moves two steps and slow pointer moves one step when we perform these steps in iteration that fast pointer moves two steps then slow pointer move one step so friend if this singly linked list doesn't contain loop then fast pointer will reach to the end of the singly linked list where last node next will point to null and if there is a loop then fast pointer will keep on traversing here and slowly slow pointer will enter the loop and fast pointer will meet the slow pointer somewhere in the loop so first let's see how it works we moved fast pointer by two steps slow pointer by one step we moved fast pointer by two steps slow pointer by one step fast pointer by two steps slow pointer by one step now here from here fast pointer reached here because this is the first step this is the second step slow pointer by one step fast pointer by two steps so friends here you can see that that slow pointer is still completing this tail of the singly link list but the fast pointer has already completed one circle and based on number of nodes and the size of the loop there can be possibility that when slow pointer will enter the loop fast pointer must have completed x number of cycles. So here you can see now we will move slow pointer then we move fast pointer by two steps so it will reach here, slow pointer here. Now as we started our Algorithm with fast pointer we are moving fast pointer by two steps and then our iteration will end with slow pointer with one step so slow pointer will reach here then we will again do a while loop and fast pointer will reach here and then our iteration will end when slow pointer will reach here. So friends here you can see whenever iteration will end with the slow pointer we see that Now slow pointer and fast pointer are meeting at this node. So front there could be a possibility that based on number of nodes and the size of loop there could be a possibility that before meeting the slow pointer fast pointer must have completed this cycle x number of times and similarly slow pointer must have completed this cycle let's say y number of times before meeting at this node. So the first part of the algorithm is detecting this loop. In case if fast pointer meets slow pointer then we know that there is a loop. So this is the first part of floyd cycle detection algorithm. The other part is to find the starting node of this loop. So after finding the meeting point of fast pointer and slow pointer what we do is we keep slow pointer here and we move a temporary pointer from the head. And now this time we move slow pointer one step and temp also by one step. So what this algorithm will tell us is if we move both the pointers one step when temp will reach the start of the node slow pointer also will reach to that particular node. And basically in code when they meet to any node that node will be our starting point of the loop. So let's see how we move temp by one step, we move slow pointer by one step. If we again move temp by one step, slow pointer by one step, we move temp by one step, slow pointer by one step, then again we move temp by one step and slow pointer by one step. So friends here you can see that based on number of nodes here in the tail and in the loop you saw that slow pointer started from here and it completed one cycle and reached to the same point here. And now if we move temp by one step it will reach here and if we move slow pointer by one step it will reach here. So this algorithm tells that at whichever node these two pointers will meet that would be our starting point of the loop or the starting node of the loop. So now there are two parts of the algorithm one is of detecting the loop that is the meeting point of the slow pointer and fast pointer and other is the finding of this starting node. So here if we draw this singly linked list let's say something like this that this is a tail and this is the loop and let's say they meet at this point. So here you can see we are denoting this tail with the value m and fast pointer comes inside the loop it goes and performs few cycles and reach here and slow pointer also performs a lesser number of cycles and finally meet it here or it could be possible that slow pointer doesn't complete any cycle and simply meets here. So we are giving this distance as k and the complete length of this loop let's say we are denoting it by n so this is the current picture from where we will start our proof. So let's say we are assuming that fast pointer and slow pointer meet here if they meet here then this singly linked list must be containing a loop at the start we are simply assuming that let's say they meet here. So the distance travelled by fast pointer would be let's say we denote it by df so the fast pointer will start from here it moves m distance and there could be possibility that fast pointer travels this loop let's say x number of times and once it performs a loop it will come to the starting point only and then it goes k distance and meet the slow pointer so we can simply write the distance travelled by fast pointer as m plus the n is the length of this loop and cf is an integer which can be like 1,2,3,4,5. So we are not sure that how many cycles fast pointer will perform so we are denoting it by a constant cf which would be an integer so it can make one cycle it can make two cycles it can make three cycles so in order to calculate distance we are multiplying n by cf plus k so if the cycle starts from here it will reach back here and then it goes k distance so this is the k distance and similarly distance travelled by slow pointer let's say we denoted ds it would be m plus let's say this slow pointer also performs some of the cycles around this loop and we don't know how many cycles it performs so we denote it by cs so this is also a constant basically an integer value multiplied by the length of the loop plus so if it starts looping from here then it performs one loop or let's say cs loops and then it will travel k distance and meet the fast pointer here so plus k so now as we know that both the pointers are starting at same point and meeting at this point so the time both the pointers will be same and as fast pointer is moving two steps and slow pointer is moving one step so the distance travelled by fast pointer will be twice the distance travelled by slow pointer so let's say distance travelled by slow pointer is x so if fast pointer is moving twice the speed of slow pointer then the distance travelled by fast 2x. So if we substitute these values in the x and 2x it would be something like this. x will be equal to m plus ncs plus k and 2x will be m plus ncf plus k. So here the constants are different cf and cs which are nothing but the integer values. So m plus n into cf plus k. Now what we do is, we simply subtract x from 2x. So we simply subtract this equation from this equation. So what we get is, this x will get cancelled out with this x. So only one x will remain. So here you can see m will cancel out, k will cancel out and if we do n into cf minus n into cs taking n common, it would look something like this. n into cf minus cs. So this would be the equation which will be coming out. So here you can see that based on what equation came out, if we closely observe this equation then here you can see that this x is equal to n into cf minus cs. So here you can see n is constant because this length of the loop will remain the same. And cf minus cs are nothing but integers. So there will be a value for cf and cs when multiplied by n will give us a distance x. So here you can see that if we substitute some of the values in the left hand side and in the right hand side, let's say for cf and cs and x and n. So you will find that this equation is solvable. So which proves that this equation is derived when we assume that they will meet at this point. And if they are meeting at this point then there will be a loop inside this singly linked list. So you can try to substitute many values here and you will see that you will find the solution of these equations. So this proves our first point that how we detect that there is a loop in a singly linked list. Now we will see that let's say this is the meeting point and if we move the slope pointer by one step and temporary pointer one step then why they actually meet at the starting point of the loop. So this will be our second part of the algorithm which we need to prove. So here we go via same analogy that distance travelled by fast pointer is df m plus ncf plus k and distance travelled by slope pointer will be m plus ncs plus k. Now here what we do is this is also we discussed that distance travelled by fast pointer will be twice the distance travelled by slope pointer. So which means df will be twice ds because fast pointer is moving twice the speed of slope pointer. So the distance travelled by fast pointer will be twice the distance travelled by slope pointer. So if we substitute these values we will get m plus ncf plus k equals two into m plus ncs plus k. Now we will multiply two inside this and we will get 2m plus 2ncs plus 2k. Now what we do is we will take m this side so if we take it this side it will become minus m minus k and here we have 2m and 2k so 1 1m and k will be subtracted and here if we take 2ncs here so it will be ncf minus 2ncs. So this equation after solving it will look something like this that ncf minus because we are taking this side so it will become minus 2ncs. This m we took it here so it became 2m minus m so it gave m and k we took it here so it became 2k minus k which gave us a value k. So friends here you can see that m is the length of the tail of the singly linked list and k is the distance from the starting node to a point where the fast pointer and slope pointer meet and n is the length of the loop. So friends here you can see it will take n common so it would look something like this and here you can see from the starting point till this point this value is k and total value of this loop is n. So if we denote this small semicircle as or the arc as let's say r like this. So over this equation what we do is we take k this side so it becomes n into cf minus 2cs minus k. So friends to k what we can write is so here you can see that k plus r will be equal to n because k is till this point and r is till this point and if we add them we will get n. So what would be the value of k it would be n minus r so if we denote n minus r instead of k it would look something like this n minus r came here now we will multiply minus into this bracket so it would look something like this minus n plus r and now if we take n common from these two terms we will get something like this cf minus 2cs minus n so we are taking n common so it will become minus 1 bracket plus r equals m. So friends here you can see that this n is the length of the loop and cf minus 2cs minus 1 here cf is an integer cs is also an integer and minus 1 is a constant so what does equation denotes so here you can see m which would be a distance by the temp and it will reach the starting point and here you can see that if you are starting slow pointer here then this equation if we travel this much part n into some integer value so that would be the number of loops where n will be multiplied by let's say some integer value or it can come out to be 0 so for timing let's suppose this equation comes out to be 1 so it means if you are starting slow pointer here it will perform one loop and will reach the same point and let's say if this equation comes out to be 0 so it will stay at this point only because this complete part will be 0 and if we take this value that 2 3 4 and if you are starting it from here so it will travel like this but it will always reach to this point only because it is starting from this point so this part is telling us that if we are starting the slow pointer here and whatever the value this equation comes in the bracket it will always make it reach to the this point only and here you can see if we travel plus r after making few cycles by this equation slow pointer will reach here only and if it travels plus r then it will meet the temporary because here you can see m is equal to some loops plus r if temp will move m steps the slow pointer will has moved some number of cycles and it would have reached here and then it would have moved plus r so it would have meet m here so which means that based on our values here from this point if slow pointer travels let's say 1 cycle 2 cycles 3 cycles it will reach here only and meanwhile m would have reached somewhere here because they are moving at same speed 1 1 step and finally when it would have traveled r it would have made it somewhere here which would be the starting node of our loop so this equation tells that m is equals to some loops by the slow pointer plus r so if we are starting from this meeting point the slow pointer it would have performed some loops and it would have reached here only and then based on our this length which is r if would have traveled r then it would have reached the starting point of the node and it would have met temp so this equation is telling that if we are dividing our loop in k and r terms and the total length of this loop is n so we need to simply prove that slow pointer if it is starting from here then whatever distance it travels it should meet the temporary node when temp has performed m steps so here you can see when temp has performed m steps which is this part of the equation that would be equal to and into an integer multiple so it would be it is starting from here it makes few cycles it reached to the same point and then it is traveling simply plus r so if it is traveling plus r it would reach to the starting point of the loop and where it will simply meet m because m is equal to this equation so from this proves that from the meeting point of the slow pointer and fast pointer if we travel slow pointer by one step and temp by one step so wherever they will meet that will be our starting point of the loop so from this proves that why Floyd cycle detection algorithm works in case you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so in this video we will discuss that how we can remove a loop from a singly link list so friends in our previous videos we saw that how we can detect a loop in a singly link list and after detecting the loop we also saw that how we can find the starting node of the loop and we demonstrated both the algorithms using Floyd cycle detection algorithm and we also saw the proof of Floyd cycle detection algorithm that why it works so based on similar concept we will see that how we can remove the loop from the singly link list so before we start in case if you are new to my channel then please subscribe to my channel so that you never miss any update so friends here you can see that suppose we are given with this singly link list which is having a loop starting from node 3 so here 3 is pointing to 4 4 is pointing to node 5 and 5 is pointing to node 6 and node 6 is again pointing to node 3 so here you can see that there is a loop and our task is to remove this loop so the only way in which we can remove this loop is if somehow we reach to this node and we break this link and once we break this link and if we assign it to null then it will become a singly link list which will not have any loop so friends the idea behind this algorithm is it's very much similar to what we discussed in our previous videos that we create two pointers we name them fast pointer and slow pointer both starting from the head from here and then we provide a while loop so inside this while loop what we do is we move fast pointer by two steps so here you can see we are assigning fast pointer next next so for example if suppose fast pointer is here its next is this node and its next is this node so we are moving fast pointer by two steps and we are moving slow pointer by one step so once they will reach inside this cycle and if the singly link list contains a cycle there will be a situation when slow pointer and fast pointer will point to the same node which will prove that there is a loop in the singly link list so this idea we have already discussed in two of our videos so the first part is to find that meeting point of slow pointer and fast pointer so we will quickly go over the algorithm to find the meeting point of slow pointer and fast pointer so here we are starting both fast pointer and slow pointer from head and we are providing a condition in while loop as fast pointer should not be equal to null and fast pointer next should not be equal to null because here we are traversing fast pointer by two steps we have to provide this check because if fast pointer next comes out to be null then here we will get a null pointer exception so we are providing this safe check here so currently fast pointer is not equal to null and next is also not equal to null so we will quickly go over this demonstration because we have already seen it in our previous videos we have moved fast pointer by two steps and we will move slow pointer by one step and after we perform one iteration we simply check that whether they are pointing to the same node or not so currently they are not so after second iteration this is the situation and still they are not pointing to the same node still slow pointer and fast pointer are pointing to different nodes so friends now here you can see that both slow pointer and fast pointer are pointing to node 5 it means that there is a loop and our if condition slow pointers equals fast pointer comes out to be true now which will signify that there is a loop so in the second part of the algorithm which is what we want to remove the loop so here now we will call remove loop method and we will pass in the slow pointer and once this method will end this loop will be removed and we will simply return from this method so here as we have passed slow pointer so it will still point to node 5 because this is the meeting point of the fast pointer and slow pointer so friends in one of our previous video we discussed that how we can find the starting node of this loop where what we did was we created a temporary variable we started it from head and then we had moved temp by one step slow pointer by one step and where they would have met that was our starting point of the loop and we also proved the algorithm mathematically that why moving temp by one step and slow pointer by one step in a while loop will make them meet at the starting point of the node so this algorithm we proved in our previous videos so you can watch those videos so here we'll apply the same analogy we start from the head which would be our temporary variable and slow pointer from the meeting point of slow pointer and fast pointer now here we are providing a while loop so when we were actually finding the starting node of the loop our while loop condition was that perform the iteration till slow pointer meets the temporary node and inside this while loop we were moving both the pointers one one step but now here you can see that as singly link list contains a loop and we want to break this link so we don't have to go till the starting point we have to go a node before that and we have to remove this link so the only way to reach node 6 is instead of comparing slow pointer with temp here we are simply comparing slow pointers next to temp next because we know that when slow pointer will reach at node 6 temp will reach at node 2 and the both pointers next will point to the starting node of the loop so therefore we have to break this while loop at dead point because we have reached slow pointer to a node which is just before the starting point of the loop so let's see how so currently slow pointers next is not equal to temp next because temp next is pointing to node 2 and slow pointer next is pointing to node 6 so the condition in while block comes out to be true we move temp by one step so temp goes to its next node where we assign temp dot next value to temp and similarly we will move slow pointer by one step by assigning slow pointer next to slow pointer so slow pointer next is node 6 so now slow pointer will point to node 6 now friends here we again check whether slow pointers next is equal to temp next or not so slow pointer next is node 3 and temp next is also node 3 so therefore this condition comes out to be false because slow pointer next is equal to temp next so this is the only minor difference between finding the starting point of the loop and finding a node before the starting point of the loop and why we need a node before the starting point of the loop because we need to break this link and the only way to break this link is if we have reference to this node so therefore here the only difference between the two algorithm is this condition if you want to find the starting point of the loop then this while loop condition becomes slow pointer not equal to temp and if you want to find a node before that then you have to provide this condition that slow pointer next is not equal to temp dot next so here this condition comes out to be false and while loop will terminate so at the end in order to break this link what we'll do is we simply assign null value to slow pointers next so it would look something like this the slow pointer next is pointing to node 3 so this link will go away and now it will point to null so friend after this assignment you can see that our singly linked list which had a loop in between not will end with a null value so friend this was the demonstration of the algorithm step by step I hope you have find this information useful and in case you have find this information useful then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so in our previous video we discussed about but how we can remove a loop from a singly linked list we saw an animation of the algorithm so in this video we'll write the code for that and we'll test its working in the main method so here in our singly linked list class which has this instance variable head of type list node so here inside this class I have demonstrated so many algorithms related to singly linked list so here you can see the last algorithm we discussed was how to find the starting node of the loop where we first created the loop then we simply check that whether there is any loop or not and once we found that there is a loop we wrote the algorithm for finding the starting node of the loop and we printed its data on the console so here you can see that we used a simple example which we also saw in our previous slide that we have created six nodes first second third fourth fifth sixth where all the nodes are connected to each other and the last node is connected to node third so node six was connected to node third which created the loop in the singly linked list so head pointed to first node first pointed to second second pointed to third third pointed to fourth fourth pointed to fifth fifth pointed to sixth and sixth pointed back to third so there was a loop and the starting point of that loop was node third so if I run the code now which we already discussed in our previous videos so here you can see the starting point of that loop was at node three where we printed its data on the console so in this video we'll look into algorithm where we'll simply break the loop which means that from node six to node third will break this link and then sixth node will point to null so let's code the algorithm so friends here you can see that this algorithm of removing the loop from the singly linked list has two parts one is to detect the loop and part two is to actually remove the loop so here in our previous videos we already discussed that how we can detect a loop in a singly linked list using floyd cycle detection algorithm and we also saw the proof for that algorithm so here when fast pointer will meet the slow pointer then instead of going and finding the starting node what we'll do is we will remove the loop so the first part of algorithm is pretty much the same i'll paste the code here and instead of returning the list node as we are not returning anything we will make it void we'll name the method as remove loop and rest of the part remains same till the cycle is detected where fast pointer is equal to slow pointer which we already discussed in our previous videos we'll remove this return null and here instead of going and finding the starting node of the loop what we'll do we'll simply create a method as remove loop and we pass in the slow pointer and once we remove the loop we'll simply return from this while loop or we can break the while loop so here i'll be creating one private method as remove loop which will take in a list node slow pointer which is we are calling this method from here and inside this method we'll actually write the code to remove the loop we also discussed that how we can find the starting node of the loop so the idea of finding the starting node of the loop and to remove the loop is pretty much the same with only small changes so i'll copy this part so here we have this slow pointer which is nothing but the meeting point of fast pointer and slow pointer and we pass slow pointer into this method so we have this slow pointer here and inside this remove loop method we are creating this temporary variable which will start from head so friends when we discussed that how we can find the starting node what we did was we made slow pointer move one step and we made temporary pointer move one step inside this while loop and when they met so temp became equal to slow pointer so at whichever node this both pointer met that node was our starting node of the loop and we proved this algorithm in our previous videos so similar concept is applied here here the only change we do is we simply check whether temp dot next should not be equal to slow pointers next so why we have provided this condition is here this condition will make us reach to the starting point of the loop but we don't want to go tell the starting point of the loop we have to just go a node before that because as it is a singly linked list in order to break this chain we have to go a node before the starting point of the loop and once we reach there we can simply break the chain by assigning something like slow pointer dot next equals null so from this condition is important if we remove this dot next from both the sides then this value will make slow pointer and temporary pointer to reach to the starting point of the loop but we don't want to go to the starting point of the loop we have to go just before that so wherever these both the pointers are we are simply comparing its next value so if both the pointers next value becomes equal then we know that slow pointer is just before the starting point of the loop and once this condition comes out to be false we know that slow pointer is just before the starting point of the loop so friends here you can see that why this condition is important if we don't provide dot next value in both these pointers then this while loop will make us reach to the starting point of the loop and we don't want to reach to the starting point of the loop because if we reach to the starting point of the loop then we won't able to break the cycle so what we do is we simply try to reach a node before the starting point of the loop so here instead of comparing temp with slow pointer we are simply comparing both the pointers next so that when slow pointer will be a node before the starting point of the loop its next will point to the starting point of the loop and temp next will also point to that node so this condition will come out to be false which means our slow pointer will be a node before the starting point of the loop and then at the last step we'll simply assign null value to slow pointers next so this will break the cycle of the loop which is inside the singly linked list so here what we do is in the main method we simply call the remove loop method so this will take this singly linked list which contains the loop and then we'll simply call display method which will print the singly linked list and if the singly linked list will contain a loop then here you can see that display method will keep on running because it won't break because there won't be any null value and this will keep on going but here as we know that we are removing this loop here if i run the code now so here you can see that from third node it pointed to fourth then fifth then sixth and sixth again pointed to node three which we saw here six next is pointing to third but when we've called remove loop method here the loop was removed and when we printed the singly linked list on the console this step made the sixth next to null instead of pointing to three so it simply removed the cycle from the singly linked list and it printed it on the console where the last node was now six pointing to null so friend this was all about that how we can remove a loop from a singly linked list i hope you have find this information useful and in case if you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss that how we can merge two sorted singly linked list so let's see what this problem is and how to solve this so here if you see that we are given with two sorted singly linked list the first singly linked list has three nodes one four and eight and the first node is being referenced by head one similarly the singly linked list two has nodes three six and seven the first node being referenced by head two now if you see both this singly linked list are sorted in ascending order now our task is to merge them in such a way that resulting singly linked list is also sorted so here you can see that when we merge these two singly linked list the resulting singly linked list has six nodes three from list one and three from list two so total nodes are six and here if you see that we have merged it in such a way that the resulting singly linked list is also sorted and that too in ascending order so at the start we have one then three four six seven eight so one is added by list one three from list two four from list one six seven from list two and finally eight being the largest value from list one so the resulting singly linked list is also sorted so let's move ahead and see the demonstration of the algorithm step by step so here you can see that we are given with two singly linked list which are sorted let's say they are referred by a and b and we are calling this merge method and this merge method will return us the head of the merged sorted singly linked list so here if we visualize this merge method on the call stack let's say we have the stack memory and heap memory so stack memory usually have the calls to our methods so let's say after certain calls there is a merge call and we pass a and b as our list so here if you see that whatever the nodes a will hold and b will hold they will hold in the heap memory so these are the objects which are of type list node and a and b are references to these objects so in heap memory it will look like this and now we need to merge these two lists in such a way that the resulting singly linked list is also sorted so just keep this thing in mind because it will be useful later so here is the algorithm to merge two sorted singly linked list a and b so friends before we start if you want to master data structures and algorithms you can subscribe to my channel and click the bell icon so that you never miss any update let's say we call this merge method we pass two lists a and b so here you can see a and b are usually on the stack and they are and they are referencing these objects on the heap and a and b both the singly linked list are sorted in ascending order now our task is to merge these two sorted singly linked list such that the resulting singly linked list is also sorted so at the start what we do is we first create a dummy node so this dummy list node will refer a list node on the heap with a value as zero so this dummy list node can have any value this value doesn't contribute in our algorithm so we can provide any value so it would look something like this that dummy is on the stack and it is referencing one list node in the heap memory having value as zero and next pointing to null so this is a concrete object in the heap now why we are creating this dummy list node we will see later so one such usage of dummy is when we will compare the values of these two lists so one by one we will take out the nodes and add it to this dummy list node so instead of null one one value will keep on coming and at the end after this value will terminate and this logic will end all the list node of both the list will be added to the list being referred by this dummy node so here dummy list node will hold our final list which we will be returning it from this method merge method so it will hold our result list which is merged and sorted the second point of creating this dummy list node is it will help us in avoiding errors like null pointer exceptions so we will see this point later that how it helps in preventing null pointer exception so for timing you can just think that we have created one dummy list node now this list node will keep on adding one one node from both the list such that when the both the list will be exhausted all the list nodes will become part of this list referred by this dummy node moving ahead now here you can see that as we have created this dummy node this dummy node will refer to this node and our task is to merge these two sorted singly linked list by taking one one element and adding it after the dummy node so dummy node stays at this place what we do is we create a tail list node and which will point to dummy so it looks like this now this tail will help us in adding the nodes after the dummy node and after adding one one node the tail will move ahead and it will keep on adding till all the nodes are exhausted so that we will see in the while loop how it does now we are providing a while loop where the conditions are a should not be equal to null and b should not be equal to null so here you can see this and operator tells that if any of the list is exhausted or their references a and b reach to the end of the list we have to break from this while loop and why we are doing this is because so here if i take an example let's say a is referring to one four and then eight and b to three and six so if i see the resulting list it will be like this one then three then four then six so once six will be placed here you can see this b list will have its all the nodes in the resulting list and let's say after eight we have like nine eleven fifteen so after six b has got exhausted so it means that after six there are no more nodes which can be compared with the rest of the elements of a like eight nine eleven and fifteen so what we do is we simply break from this while loop because one of the lists got exhausted so there would be a point when either of the lists can get exhausted we will see this when we will execute the while loop so currently a is not equal to null b is not equal to null so the condition in while block comes out to be true so the while block will execute now we provide if and else condition and here what we are doing is as we want to merge these two sorted singly link lists such that the resulting list is also sorted what we do is we compare the data of a and b and we check which data is less so in this if condition we are checking that a data whether it is less than equal to b is data or not so here you can see one is less than three we are comparing one with three so one is less than three so this condition comes out to be true which means we are starting from the first node of both the list and we have found one node whose value is smaller among all the elements in the both the list because they are sorted in ascending order so your list node which is data as one being referred by a will be the first node of our resulting sorted singly link list one should come at the start so here you can see now what we do is tail is actually pointing to this dummy node and our task is to add this much node into the dummy list currently here you can see tails next is pointing to null so if we assign a to tails next it would look something like this the tail next which is pointing to null it will now point to a list node which is being referred by a so here this assignment will add this list node having data as one into this list whose head is dummy so we are taking the help of tail pointer to add this node so after we add this node we know that we have used one value of list a so we simply traverse a to its next node because the next comparison should be between three and four because we have compared one and three one was lesser than three so we added this list node into this list so now we simply move a to its next node so there are two reasons why we are moving it to its next node one is in the next iteration of while loop now we will compare four with three so therefore we need a reference to this node and the second point we will see in the next iteration so after this assignment a dot next a next which is node four we will assign that value to a so a will come to this node now like this and here in this step as tail has added one node here now the other node will come after one because this node is added and we have to add more nodes and tail will help us in doing that so we also traverse tail ahead by assigning tail dot next to tail so tail next is node one so now tail will reach here like this because next node will be added after one now a is not equal to null b is not equal to null so the condition in while block comes out to be true now we again compare the data of a and b so here we are simply comparing in this if block is whether four is less than equal to three or not so four is actually greater than three so this condition comes out to be false and the else block will be executed i'll just remove this so in the else block we know that among four and three three was the lesser value so now we have to add this node after one and how we can do that is b is referring to this list node and now we have to add this list node after one so we are taking the help of tail we assign b to tails next here if you see tails next is pointing to this node now so we have to break this link and point it to this node so by this assignment the first thing it will happen is this link will go away and as tail next was pointing to this node now tail next will point to b which is node three like this and also friends in previous while loop we moved a to its next so one reason was that we are comparing four with three the other reason is we have removed this reference from here and now it is pointing to this node so as soon as we remove this reference we need something to hold this two list nodes from the stack which is being done by a so therefore this is the another reason we are moving a to its next and now after this assignment we do the same this value is used up and now it is part of this list so here you can see dummy is pointing to list node having value is zero it is pointing to a node having value as one and one is pointing to a node having value as three so now we have used this value so we move b to its next node so by assigning b dot next to b so b next is this node when we will assign b dot next to b b will come here like this i will remove this and similarly we also moved tail ahead because the next node will be added after three now so we have to somehow reach here and we can only reach here is by assigning tails next to tail so tails next which is node three we will assign it to tail so tail will come here now like this a is not equal to null b is not equal to null so the condition in while block comes out to be true now a dot data which is four b dot data which is six so we are comparing four and six and we are checking whether four is less than equal to six or not so this condition comes out to be true because four is less than six and as four is less than six the next node after three would be four so in the first step what we are doing is tail is pointing to node three tails next is pointing to six so first we need to remove this link and how we can remove this link is to tails next we are assigning a so tails next we remove this node and we assign a which is node four so it would look something like this after this assignment we have used four also so we move a to its next node by assigning a dot next to a a dot next is eight so a will come to it via this reference and as we have added four here the next node will come after four and we are adding node based on our tail so we have to move tail also one node ahead so we are assigning tail dot next to tail so tail will come here like this via this assignment a is not equal to null b is not equal to null so the condition in while block comes out to be true and now we are comparing a data and b data we are comparing six and eight and here we are checking whether eight is less than equal to six or not in this if block so this condition comes out to be false because eight is greater than six so we execute the else part so here this if condition is telling that between six and eight six is smaller so six should be added first to the sorted singly link list which we want to merge so therefore that happens in the else block so this if block is dealing with a list and else block is dealing with b list and here we are doing the same thing we need to add this node referred by b after four and after four means tails next value so we are assigning b to tails next so first we are removing this node like this and after this assignment tails next will point to b like this and then we will move b to its next because we have used six also now so b will move to its next and here you can see b next was null so now b is referring to null we have added six now so the next node will be added after six so tail should come here and tail will only come here when we will assign tails next to tail so tail is pointing to four its next is pointing to six so when we will assign tail dot next to tail tail will point to six like this so friends here you can see that when we are traversing this while loop there will be a moment that one of the list will become empty both the list cannot become empty because as we are adding one one node from each of the list there will be a point when one of the list will become empty so it could be b or a any list can become empty so if any of the list becomes empty we break from this while loop like this and after this while loop we have this if else block now why we have provided this if else block is b got exhausted but there could be a chance that in a there could be elements left so currently here we have only one element there could be a possibility that its next should point to let's say nine then 10 20 like this so our task is to add this remaining nodes as well after six because tail is pointing to six and eight should come after six via this tail node so we check that which list got empty so here in this if block we are checking that which list got empty whether it was a or b so here you can see b is actually pointing to null it means b got exhausted a is not equal to null a is actually referring to a node so this condition comes out to be false and the else part will be executed so you can see if a got exhausted b comes into picture and we assign all the nodes of b to tails next if b got exhausted then we are adding all the nodes of a to tails next so here b got exhausted and we need to put let's say this node into the list so at the last step what we do is we assign a to tails next tail is pointing to six its next is pointing to null so if we assign a to it this will go away and there will be a link from tails next to a like this via this assignment and here you can see as we need to merge these two sorted singly link list in such a way that the resulting list is also sorted we don't have to do anything with the rest of the elements of a let's say it had nine ten twenty like this because they are already sorted so why are this reference all the nodes will be part of now this complete list so our task will be done here so here you can see this dummy list node has built one chain which is actually our resulting list so here you can see it goes like this so here one thing to note here is this dummy list node was created by us therefore we don't have to include this so therefore at the end we are returning dummy dot next dummy is pointing to this list node it was actually a dummy list node which we created here so at the end we need to return dummy dot next so dummy next is this node so we are returning a list node which is holding this list like this from this method so the method which is calling this merge will get a list node let's say if it is called like this so our head will be pointing to one and it goes like three four six and eight and so on so this head will be in the stack and this will be in the heap all the nodes so we are returning dummy dot next because we have to discard this dummy because all the nodes which we added using our tail were after the dummy node so we have to discard this so here if you see if i if we hold this pointer and if we stretch it i this nodes will be stretched out and it will look like this so dummy was our node which we created it has no significance we return dummy dot next so dummy next is this so this is our final sorted singly linked list which actually has all the elements of a and b so from here you can see that we use dummy list node and we saw that it helped us in building up this list because this is one concrete node in the heap and this is on the stack so dummy is referencing one concrete node on the heap and then we are simply adding the rest of the nodes after dummy so this was the one case where we are actually creating this dummy list node the other thing we saw was that it helped us in avoiding null pointer exceptions so here let's say if we are not using this dummy list node so here we are not using this line instead of this dummy list node we have to create one head which we can return from this method so we have to do something like this like this instead of this and this tail instead of dummy it should point to head and instead of dummy dot next we should return head because this list node head will be holding the merged sorted singly linked list but here you can see that once we execute this line and we are not creating this dummy list node so it would look something like this after this line head will point to null and when we will execute this line we are assigning value of head to tail because this tail will help us in adding of the nodes in this while loop so here it would look something like this tail will refer to a value which is being held by head via this assignment so tail will also start from null now here you can see in this while block we have provided if and else block and let's say when we compare one and three for the first time we know that one is less than three so this condition would have been true because a data is less than b data so here you can see when this line would have been executed here we are assigning a to tails next but when this line will be executed tail is pointing to null and if we are doing this dot next it means we are accessing a variable which is being referred by tail so there should have been one concrete object in the heap on that we have to call next but here tail is pointing to null so here you can see it will give us a null pointer exception because tail is pointing to null it doesn't have any object in the heap on which we can call next similarly here also we would have got an error so we will get null pointer exception so this is one of the uses we are creating this dummy list node because we need this concrete object so that we can use tail and add this remaining nodes so this is one important thing to remember that we usually create this dummy list node to avoid the null pointer exceptions now let's say if we are told that we don't have to use this dummy list node we want to merge this to sorted singly linked list using the normal nodes so we can also solve the problem that way this dummy list node is actually helping us in avoiding these errors and the checks but what if we want to merge these two lists without the dummy nodes so how we can approach that is now here you can see that head is starting from null now what if head starts from a concrete list node in the heap and it doesn't start from null so if i just remove this line so you can think before this assignment of head to tail we have to write some logic to handle this condition so that these errors are avoided what we need to do is the things which we are doing in while loop in one shot that we are comparing all the nodes using this if and else condition what we do is for the first time we just check for one of the nodes so this check which we are doing in the while block we have to do for the first comparison so that we can get one concrete node in the heap so we have to write some extra logic so what we do is here you can see before while block and this tail assignment we have to write some logic like this here you can see this conditions are very much similar to this while block so here what we are doing is as we need one concrete object in the heap and we don't have to use this dummy object what we do is to get one of the concrete objects from this two list we do the first comparison out of this while block here we do a.data and check whether it is less than b.data and if a.data is less than b.data so currently one is less than three so what we do is we simply treat this node as our starting node and we directly assign head to it via this assignment and as we have used this node so we simply traverse a to this node by assigning a.next to a so this if and else block is very much similar conditions but for getting one of the concrete nodes we do this one check out of this while block and rest of the code is pretty much the same this a not equal to null and b not equal to null a not equal to null will start from this node so when we had created this dummy list node this code we don't have to write and all the logic would have been compared in this while block so first node of a and first node of b would have been checked in the while block but if we don't want to use this dummy list node we somehow need a concrete node so for getting this first node we are doing this check outside the while block here so that we can get a concrete head so rest of the logic is similar once we get head here tail will point to head like this and now in the while block if we do tail.next we actually have a concrete object here we had a null object but here now we have a concrete object so therefore this error won't come and at the end we can simply return head so friend this is how we actually merge two sorted singly linked list so that resulting list is also sorted you need to be very careful while merging this two lists using this dummy node it will make your code easy and simple to write but if you don't want to use this dummy node the first thing you need to do is to identify the actual starting point of the head which is our resulting list so we have to do this comparison first to get our first head and then we can provide this while block and do the similar stuff which we already discussed and at the end instead of doing dummy.next we are returning head so friends i hope you must have liked this video in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw an animation in which we discussed that how we can merge two sorted singly linked list so in this video we will actually code the algorithm and we will test its working in the main method so friends before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here in our previous videos we have created one class as singly linked list so in the same class we will actually code the algorithm so here let's say i give the method name is public merge so this merge method will take two list node a and b so these two list nodes represent two sorted singly linked list and now our task is to merge these two sorted singly linked list and return it back from this method so here as we need to merge these two sorted singly linked list the first step we do is we create a dummy list node and we provide a dummy value to it now this dummy list node will actually hold our merge sorted singly linked list and in our previous video we have saw that why we are creating this dummy list node it is actually providing us a concrete object in the heap so that we can avoid the null point and exceptions now as this dummy list node will hold our merged sorted singly linked list we will create a list node let's say by name tail and this tail will actually point to this dummy list node so the dummy list node will actually hold the complete list and we will use this tail list node and we will add one one element from the both the list using this tail pointer we will see that later now after that we will provide a while loop now as we need to merge these two sorted singly linked list we have to compare their respective elements with each other so that we will do in the while loop so the condition we provide is a should not be equal to null and we should not be equal to null so here as we are comparing one one element from both the list with each other there will be a time that either a or b get exhausted so if any of the list get exhausted we will exit from the while loop now inside this while loop as we are merging these two sorted singly linked list and we want the resultant list also sorted let's say if i give an example so here let's say a has three nodes one three five and b has three nodes two four and six now when we will merge these two sorted singly linked list the resultant list will be like it will also be sorted so here in this while loop what we are doing is we are comparing the elements of both the list first we compare one with two we know that one is less than two so one will be inserted first then after inserting one we move to three and then we compare two with three and we know that two is less than three so the next element comes as two so we move to four and then we compare three with four three is less than four so three will come here and we keep on doing that till one of the list get exhausted so here we provide a condition because we need to find the smallest element among the both the list for the current iteration so here what we do is we simply compare a data and see whether it is less than or equal to b's data so if a's data is less than equal to b's data it means two tails next we will assign a and then we will simply move a to its next node so here when we compared one with two one is less than two so we added one to the resultant list via this assignment and then we move to three so we did a equal to a dot next and similarly if b's data is less than a's data what we do is we simply add b two tails next and then we move b to its next node so here one is less than two so we added one and we moved to three and in the next iteration we compared two with three so two was less than three so we added two here and then we moved two four so that in the next iteration we compare three with four and why we are doing this comparison because we need to get this list and it should be sorted so in this while loop we are comparing each and every element of a and b and whichever element is less we are simply adding that node into tails next and then we are simply moving the respective references to its next node so that we can compare the next element and here we also need to move tail to its next node so here let's say first we added one so initially tail must have been here so we have used tail dot next and added one so the two will come after one so we have to move tail also ahead so that in the next iteration if we do tail dot next two will come here and then we'll simply move tail to two and we keep on moving tail ahead till there are nodes in a and b so this step is also important that we need to move tail also ahead so that in the next iteration we are adding a different element to tails next so after this while loop there will be two possibilities either a will get exhausted or b will get exhausted so here let's say if i copy this part so let's say instead of five we have like this and here we have so here you can see in the result list first we will add one then two will come then three four so after four a will get exhausted and as we need to merge these two sorted singly linked list these elements should also become the part of the result list so one property here to notice as both the list are sorted and as one of the list get exhausted we can directly append the rest of the list after four so we can directly do this after the while loop like this and this will actually merge both the list and will also be sorted so here what we do is we simply check if a is equal to null because here in the while loop as we are moving a to its next and b to its next either a will get exhausted first that a will point to null or b will get exhausted that b will point to null so if a is equal to null then here we saw that we have directly appended b to the result list so here what we do is we do b else if b is equal to null we directly append a and after this if else block we know that we have merged both the list so at the end what we do is we need to return the head of this resultant list so we will simply do dummy dot next and we will return it so why we are doing dummy dot next here you can see this dummy is a list node we created and whatever the nodes we added we added after this dummy using tails next we started with dummy node and we used tails next and added the nodes so the actual head would be dummies next because the first node was inserted in tails next and tail was pointing to dummy so at the end we need to return dummies next so friend this is the algorithm to merge two sorted singly linked list now let's test its working in the main method so in the main method we will create two singly linked list and we will add few nodes to it we do insert last and let's say if we add the nodes in the sorted form so we first add one and let's say we add four and eight so this node should be in sorted form first node will be one then it will be four and then it will be eight now we'll create one more singly linked list and here let's say if i give value as three five eight let's say nine fourteen so here after eight this list will get exhausted and we can directly place the remaining list via this if else block so if i do dot display so currently if i run the code so here you can see we have this two singly linked list which are sorted one four eight three five eight nine fourteen and eighteen like this so now we'll call the merge method and as we need to pass the head of a and b what we'll do dot head so we have passed the head of both the list because this method is taking a list node and this method will return us a list node representing a singly linked list which is merged and sorted so here we will create one more singly linked list we'll give a name as result and let's say whatever list node this merge method will return we will simply add it to results head like this and we will simply do result dot display so when we will merge this two sorted singly linked list this head will actually hold that list and then here we are calling the display method to print the contents of the final list so if i run the code now so here you can see that the resultant list which we got is the combination of these two lists and it is also sorted so one three four five eight eight because we have two eight here then nine fourteen eighteen so after this list got exhausted eight nine fourteen and eighteen were directly added here so friend this was all about that how we can merge two sorted singly linked list here we have used the idea of dummy pointers which we have discussed in greater detail in our previous video and using a tail we are adding one one node in this while loop after comparing a's data and b's data and at the end if any of the list got exhausted we are simply appending the opposite list to tails next and at the end we are returning dummy dot next because this dummy we actually created to get a concrete object and all the nodes were added just after the dummy node so at the end we simply return dummies next so friends i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss a problem that how we can add two singly linked list so let's move ahead and see what this problem is and how to solve this so here in this problem we are given with this two singly linked list which are nonempty so we have this two singly linked list a and b they actually represent a number which is a positive number the digits are stored in reverse order and each of their nodes contains a single digit so as this is a number each node in the list have a single digit and this complete number is stored in reverse order so if you want to know the number you have to read it from end so here the number is three four three so three four three for this list it would be four six five because they are stored in reverse order now our task is to we need to add these two numbers and return the sum as a linked list like this so here you can see if we add these two numbers using a plain maths here you will get eight four and six will give ten so zero will come here and one will be carried over four and three will give seven seven plus one eight so our answer would be eight zero eight so we need to return eight zero eight which is the sum of these two numbers in the form of a singly linked list here we are given that two numbers does not contain any leading zero so for example here we won't have something like this because those are leading zeros the zero can only come so here let's say if we are given a singly linked list like this so this is a valid singly linked list because the complete number is zero so now let's move ahead and see the demonstration of this algorithm step by step so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here we are given this method add we pass two singly linked list a and b like this now we need to do the sum of these two numbers and return the sum in the form of singly linked list only where each node will have only one digit so here you can see the numbers are stored in reverse order so the number we are trying to add is nine four seven because the number is stored in reverse order we are adding 65 to it like this so seven plus five will give twelve two will come here one will be carried over here six plus four will give ten ten plus one will be eleven so one will come here and another one will be carried over nine plus one will give ten so our answer is one zero one two so here this one zero one two should be returned in the form of a singly linked list where each digit should be in the respective nodes so for the results singly linked list we have to first create a dummy list node which will have a dummy value zero so friends in our previous videos we have discussed the idea of dummy list node that why we actually create this dummy list node it basically helps us in avoiding the null pointer exceptions and also it actually provides a concrete object in the heap or else what we need to do is we need to write some extra logic to just evaluate the first list node and then proceed from there on so in order to learn more about dummy list node you can watch my previous videos to it so here at the step one we will create a dummy list node so friends in this algorithm what we are trying to do is we will take one one single digit from both the list we will add them and whatever will be the sum that sum we will create a list node and add just after the dummy list node so currently dummy's next is pointing to null but after we do the sum of each node from both the list whatever their sum will be we will create a list node and we will add to this dummy list so for that we are creating a tail list node like this it is referring to dummy list node we will use this tail to add the list node into this singly link list one by one so that stuff we will be seeing in the while loop moving ahead so here you can see that one list node can have only one digit so the maximum value this list node will have is from 0 to 9 and let's say if we are adding 7 plus 5 so we'll get answer as 12 so we can only store one digit so usually when we do plain maths what we do is we store two here and one is carried over so this one we will be keeping track via carry so at the start carry is zero because we haven't started our addition so carry is zero now we will provide a while loop where the conditions are a is not equal to null or b is not equal to null so in this while loop what we are doing is we are taking one node from both the list and we will do their sum but there could be a chance that one list gets exhausted before the other and as we need to do the sum of this complete two singly link list the condition we provide is a should not be equal to null or b should not be equal to null so even if b is equal to null let's say b reached here and a reached here so b is equal to null but a is not equal to null so therefore this while loop will run one more time to take the sum of this last digit and add that sum into our result list so even if one list is not empty this while loop will keep on running so at the start a is not equal to null and b is not equal to null so the condition in while loop comes out to be true now here what we are doing is even if one condition comes out to be true the while loop will execute so there could be a chance that a is not equal to null but b is equal to null or a is equal to null but b is not equal to null so we need to take this value 7 plus 5 but before taking those values we need to check whether a and b are actually pointing to null or not so here we have used a ternary operator where we are checking whether a is not equal to null so if a is not equal to null we take a is value but if a is equal to null then we take the value 0 because 0 won't affect the sum so this ternary operator condition states that if a is not equal to null so currently a is not equal to null so we will take the value a dot well which is 7 and that will be assigned to x like this similarly we have to take this value because we are adding the first digits so we are first checking whether b is equal to null or not so if b is not equal to null it means there is a digit we need to add so we are simply taking b dot well which is 5 and that will be assigned to y like this so here we have taken out the values in x and y and now what we do is we do the sum so at the start we have a carry as 0 so here carry is 0 we are taking the first digit 7 which is x second digit 5 which is our y and we are doing the sum of these three numbers so 0 plus 7 plus 5 will give 12 so sum will become 12 like this so from here you can see we need to store this sum in such a way that only one digit can come in the list node and when we actually do the maths we get sum as 12 we put 2 here and we carry your 1 to the next digit so how we can perform this mathematical addition is we take the help of division and modulus operator so if we take sum as 12 the maximum value each node can have is single digit so if we take sum as 12 if we divide it by the first two digit number which is 10 we'll get 1 and if we do 12 mod 10 this will give us remainder which is 2 so here you can see we can use these properties where we take the remainder like this which is our 2 and we can take the carry by dividing it by 10 so here we are first evaluating carry for the next addition so sum is 12 if we do divided by 10 carry will become 1 because we need to put 2 here and send 1 to the next addition and now as we are putting 2 here this property will help us in taking out 2 from the sum so we are doing sum mod 10 which will give us 2 and that 2 will be our single digit and we need to return this result in the form of a singly linked list so we will create this list node and we have to add it in the dummy list so we'll take the help of tail so to tail next which is null we'll create a list node provide a value as 2 and add it to tails next so after executing this line tail next was pointing to null so now it will point to a list node having value as 2 which is our first value of the addition moving ahead now after putting 2 if we look into the digits the next digit will become 1 so that will come after this 2 so in the next iteration we will be using tail to put 1 so for that we have to move tail to the next node so that we can still use this condition tail.next and add the new list node so after adding 2 we'll move the tail to its next node by assigning tail.next to tail so it would look something like this because in the next iteration we are doing the sum of the second digits and we will put after 2 using the tails next so friend after we perform the sum of first two digits we need to move a to its next and b to its next to take the next two digits so for that we have to first check whether a or b are actually pointing to null or not so if a is not equal to null we can safely go towards its next by assigning a.next to a so at the first step it would look something like this a will now come to its next because a next is pointing to this node so now a will point to this node similarly we will move b to its next because b is also not equal to null so it would look something like this b next is this node so now b will point to this node i will remove everything so here you can see a is not equal to null a is pointing to the second node b is not equal to null b is also pointing to the second node so the condition in while loop comes out to be true so first we will evaluate x we first check whether a is not equal to null so a is not equal to null so we simply do a.well it means we are taking this value out 4 and assign to x so x becomes 4 then we will evaluate whether b is equal to null or not so b is not equal to null so we will take b.well and assign to y so we'll assign 6 to y like this and we know that after the first addition the carry was 1 so we will do the sum of carry x and y so here if you see 9 4 7 6 5 if we are adding it we get 2 and 1 as our carry 4 plus 6 is 10 plus 1 will give 11 so 1 will come here and 1 will be our carry 9 plus 1 will give 10 0 will come here and 1 will be our carry so the addition will give 1 0 1 2 so we have done with the first addition which is 2 here 1 became our carry and x and y are actually denoting 4 and 6 so we are doing some of these three digits now 1 plus 4 plus 6 so carry plus x plus y so sum will become 11 so if you look at the sum we can only store one digit and another one will be the carry over so first we will evaluate the carry for the next addition so 11 divided by 10 will give the value as 1 because when we will divide 11 by 10 we get value as 1 so our carry will become 1 and the digit we want to store here is will be given by the remainder so 11 mod 10 whatever value it gives here it is 1 so that will be stored here and how it can be stored we have to store in the form of a list node so some mod 10 will give the remainder as 1 so we will create this new list node and we will assign it to tails next so tails next is pointing to null so this will go away and 1 will come here which is this one moving ahead so now we have to move tail to this node because when we will perform the third addition that node will come after this one so tail should go to this node so we will assign tail dot next to tail so tail next is pointing to this node so now tail will come to this node via this assignment we are done with processing of second nodes so now we have to move a and b to its next node so first we will check whether a is equal to null or not so if a is not equal to null we can safely move to its next node by assigning a dot next to a so a dot next is this node so now a will come to this node b is not equal to null so we will assign b dot next to b so b dot next is pointing to null so now b will point to null so friends here you can see the singly linked list b got exhausted and we have reached to the end of the singly linked list but as we are performing the sum of these two singly linked list we have to take the sum of this nine as well so here b is equal to null so this condition comes out to be false but a is not equal to null because there is one more node left so this condition comes out to be true and there is a or so therefore the condition in while loop comes out to be true a is not equal to null so we will take a dot well which is 9 we will assign it to x x become 9 here you can see b is actually equal to null so we can't do b dot well because this will give us null pointer exception because b is not pointing to null so therefore what we do is if b is not equal to null we take b dot well if b is equal to null we take the value of y as 0 this because when we will do sum of x plus y plus carry y will be 0 and it won't affect the sum so here if we do 1 plus 9 plus 0 so it won't affect the sum so therefore we need to put this check that if b is equal to null we take the value of y as 0 like this and now we will do sum of carry plus x plus y so carry was 1 x is 9 y is 0 if we do their sum we get sum as 10 now we get the sum as 10 so we put 0 here and 1 will be our carry over which is here so first we will evaluate the carry by doing 10 divided by 10 so the answer will be 1 so carry will become 1 like this and then we have to take this value 0 so if we do sum mod 10 which is 10 mod 10 we get remainder as 0 so this will become 0 we will create a list node and we will add it to tails next like this so via this assignment we are adding this new list node having value is 0 this using tails next we will move tail to its next like this and here you can see that with this addition we have used this value and this value so a is not equal to null we have to move to its next so a is not equal to null here we assign a dot next to a so now a will point to null we check whether b is equal to null or not so actually b is equal to null so we don't perform this b dot next to b because b is already pointing to null so now here you can see a is equal to null and b is equal to null so therefore both the condition in while loop comes out to be false because a is equal to null and b is equal to null so this while loop will terminate so friends one thing to note here is we have simply done the sum of first three digits 2 1 and 0 but the actual addition result is 1 0 1 2 so this one which was our carry over so we will check here whether carry is greater than 0 or not so if carry is 0 we do nothing but here value of carry is 1 which is greater than 0 so we have to add one more node to tails next to encounter for this carry also so currently carry is greater than 0 we will create a list node by passing in the value as carry which is 1 and we are simply assigning it to tails next so tails next is pointing to null so now it will point to a node having value as 1 which is the value of over carry so friends here you can see that we have done the sum of these two singly linked list the digits were in reverse order so our sum is also in reverse order so 9 4 7 if we add to 65 so 9 4 7 if we add to 65 we get answer as 1 0 1 2 so here at the end we simply return dummy dot next because this dummy is pointing to a list node which actually we created so this is a dummy value so we'll simply return dummy dot next which is a list starting from this list node so it would look something like this that we have dummy list like this and we are returning dummy dot next so the method which called this add method will get like this this would be our answer 2 1 0 1 so friends this was all about that how we can add two singly linked list i hope you must have liked this video in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video so friends in this tutorial we will discuss how to represent doubly linked list in java so friends in my previous tutorials i discussed about singly linked list so in this tutorial i will be discussing about doubly linked list so friends when we discussed about singly linked list so it was a oneway linked list it had only two things one was the data and other was the pointer to next list node but if you see in doubly linked list it is actually a twoway linked list so if you see a doubly linked list we have this list node which has basically three things one is the actual data which it holds and another is the next pointer so this next pointer points to the node which is just after it and it also has a previous pointer which points to a node just before it so this way it's a twoway linked list so in doubly linked list suppose if we are given any particular node then we can use that node to navigate the list in both forward and backward direction if you would have watched my previous tutorial on singly linked list then we saw that we could only move in forward direction in singly linked list so it's not possible to move in backward direction when we are using the singly linked list but with doubly linked list we can move forward and backward in the both direction and one other difference between singly linked list and doubly linked list is like a node in singly linked list can only be deleted if we have a pointer to its previous node but in doubly linked list we can delete the node even if we don't have pointer to its previous node so as you saw the singly linked list moves in forward direction so in order to break any chain or any node in between the singly linked list we usually need a pointer to its previous node to delete the node after it but in doubly linked list as we have these two pointers which helps us in traversing forward and backward then we don't need any pointer to its previous node so for doubly linked list implement the list node with a slight different way than singly linked list so the list node in singly linked list had data and a pointer to the next list node but in doubly linked list the list node has data a pointer to the next list node and a pointer to the previous list node so you can see this is how we represent a list node in doubly linked list so if you want to represent a doubly linked list then it's something like usually we have this head and tail pointers so the head points to the first node and the tail points to the last node so you can see each list node has data a pointer to its next node and a pointer to its previous node so usually the head points to the first node and its previous is null and the tail points to the last node whose next pointer points to null so it's like a twoway linked list where each node has one next and one previous so this is how they form a chain where each node refer to other node next to it and a node previous to it so the traversing becomes easier in forward and backward direction so let's say suppose we have a pointer to this third node then if you want to traverse to the forward then we can use this next pointer and traverse forward and if suppose if you want to traverse backwards then we can use this previous pointer to traverse backwards so this is a basically an advantage of doubly linked list over singly linked list so friends in this tutorial we discussed about how to represent a doubly linked list in java and in my next tutorial i will be discussing the way to implement the doubly linked list in java i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to implement doubly linked list in java so friends in my previous tutorial i discussed how to represent a doubly linked list so here if you see a doubly linked list has basically a head and a tail pointer so the head points to the first node and the tail points to the last node so we also discussed that list node has a next pointer which points to the node after it and has a previous pointer which points to the node just before it and we also discussed that a doubly linked list is a twoway linked list that is it we can traverse the doubly linked list in both forward and a backward direction so a list node which has a next pointer and previous pointer help us in traversing in forward and backward direction so this is a basically an advantage over singly linked list we also saw that how to represent list node in doubly linked list so a list node in singly linked list had only data and a next pointer which points to the node after it but in doubly linked list the list node has data a next pointer which points to the list node just after it and also a previous pointer which points to the list node just before it so friends let's go to eclipse and see how we can implement a doubly linked list so friends in my previous tutorials i discussed about singly linked list so in this tutorial we will see how to implement a doubly linked list in java so here i have just created a class by name doubly linked list so this class will hold the implementation for doubly linked list so in order to implement a doubly linked list we need list node class so we'll create an inner class by name list node so basically this list node class will hold the pointers to next and the previous nodes so as we discussed in the slide that list node contains three things private int data so it contains data and this data can be any generic type as well but here i will be taking it as integer it holds a pointer to the next list node and it also holds the pointer to its previous node so the three things are data a pointer to the next node a pointer to the previous node we'll also create one constructor so this constructor will take the data part and we'll simply assign data to this dot data so this is how we represent our list node and we also saw in the slide that doubly linked list had a head pointer and a tail pointer so we'll create two instance variable of list node one is head another one is tail so basically the head will hold the first node of the doubly linked list and the tail will hold the last node of the doubly linked list here we also create a integer variable by name length so this integer variable will hold the length of doubly linked list so it will just return the count of number of nodes in the doubly linked list so we'll also create one constructor for doubly linked list class so here we'll assign the values of these three instance variables so this dot head equals signal this dot tail so basically when we initialize doubly linked list the list is empty so the head and tail will point to null and length of the doubly linked list is zero we'll also create one method by name is empty so this method will return a boolean value which will signify whether our doubly linked list is empty or not so we can simply return length so suppose the length of doubly linked list is zero therefore the list is empty so it will return true we can also return something like head is null so even if head is null then the list is empty so we can use either of the two statements we'll also create one more method which will return back as the length of doubly linked list so friend this is how we represent a doubly linked list in java so in this tutorial i just created an inner class list node two methods is empty and length so in my upcoming tutorial we will discuss how we can insert the node in doubly linked list and how we can delete the node in doubly linked list so friends i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to print elements of a doubly linked list in java so let's say we are given a doubly linked list having four nodes say 1 10 15 and 25 and as you can see head points to the first node which is 1 and tail points to the last node which is 25 and each node in doubly linked list has one next and one previous pointer so the next pointer points to the node just after it and previous pointer points to node just before it so friends in doubly linked list we can traverse the list in forward and as well as in backward direction so below is the algorithm to traverse a doubly linked list in forward direction so let's see demo of its working so first we'll create a list node by name temp and we'll assign the value of head to it so as head points to first node now temp will point to the first node moving ahead so friends the basic idea behind this algorithm is we have this temporary node so using this temporary node we'll visit each and every element of doubly linked list and we'll print the data on the console so this while loop helps us in traversing the doubly linked list and also printing the data so we'll traverse this temporary list node till it becomes null so currently a stamp points to the first node and it's not null therefore the condition in while loop comes out to be true we'll print the data associated with this temporary node and then simply we'll move temporary node to its next node by assigning the temp dot next value to temp so currently you see temp points to first node at its next point to the second node therefore we'll assign the temp dot next value to temp so it will look something like this moving ahead now it's temp points to second node and it's not null therefore condition in while loop comes out to be true so we'll print the data associated with it and then we simply move temp to its next node by assigning temp dot next value to temp moving ahead now as the temp is pointing to third node and it's not null therefore condition in while loop comes out to be true so we'll simply print the data associated with this node which is 15 and we'll simply traverse the temp to its next node by assigning temp dot next value to temp now here temp points to the fourth node and it's not null therefore condition in while loop comes out to be true we'll print the data associated with the fourth node which is 25 and we'll simply assign the value of temp dot next to temp so temp dot next points to null so we'll assign null value to temp so it will look something like this now if you see temp points to null therefore the condition in while loop comes out to be false and therefore the while loop breaks out now as we have reached the end of the list therefore we are simply printing the null so friend this was the algorithm to traverse the wlink list in forward direction now let's see how we'll traverse this wlink list in backward direction so below is the algorithm to traverse the wlink list in backward direction now we'll create a temporary node but this time it will point to the tail because we need to print the elements in backward direction so now time points to the last node which is tail we will traverse this temporary node till it becomes null now here we'll print the data associated with this temporary node which is 25 so in order to traverse the wlink list backward we will assign the value of temp previous nodes to temp so it would look something like this moving ahead now as temp points to third node therefore it's not null so the condition in while loop comes out to be true we'll simply print the data associated with this temporary node and then we'll assign temp dot previous value to temp so we'll move one node backwards now as temp points to the second node therefore it's not null so the condition in while loop comes out to be true we'll print the data associated with this temporary node which is 10 and we'll assign temp dot previous value to temp so we are traversing temp one step backwards so here temp points to first node which is not null therefore condition in while loop comes out to be true we'll print the data associated with this temporary node which is 1 and then we'll simply assign temp previous value to temp so it will look something like this so currently temp points to null therefore this condition in while loop comes out to be false and while loop breaks out so in the last step we'll print null because temp is currently pointing to null so friends this was the algorithm to traverse the wlinklist backwards so let's move to eclipse and see the working code so friends in my previous tutorial i had created one class by name wlinklist and in this wlinklist i had created few instance variable one was pointing to the head of the linklist and another was pointing to the tail of the wlinklist i also created an integer variable which stored the length of the wlinklist and i also created one inner class which was actually list node class which had data a pointer to next node and a pointer to previous node so friends let's write a method which could print the wlinklist in forward direction so public public void display forward so here i have created method name is display forward so it will display the wlinklist in forward direction so first we'll say if head is null then return so here if suppose the head is null so wlinklist is empty therefore we'll simply return moving ahead first we'll create a temporary node by name temp and we'll assign the value of head to it then we'll create a while loop and we'll traverse the temporary node in a loop till it becomes null so inside this while loop we'll print temp.data and we'll simply traverse temp to its next node by assigning temp.next value to temp and at last we'll simply print null so friend this is the algorithm to traverse the wlinklist in forward direction so now we'll write a method to traverse the wlinklist in backward direction so let's create a method public so we'll give a condition as if if tail is null then simply return so here tail is null then we'll simply return from this method moving ahead we'll create a list node temp which will point to tail then we'll create a while loop and we'll traverse this temp node till it becomes null so i'll just copy this complete part and here instead of traversing to the next node we'll just traverse to previous node so friend this is the code to display the wlinklist in backward direction so now let's see it's working so here in the main method i have created one method which inserts the node into wlinklist so this is the method where insert the node into wlinklist so this algorithm i will be covering in my next tutorial so for now just think that this method insert the node into wlinklist so currently i have inserted four nodes 1, 10, 15, 25 so let's first print this wlinklist in forward direction so i'll do dll.display forward and if i run the code so you can see it prints 1, 10, 15, 25 and null so this is what it displays in forward direction now let's display the wlinklist in backward direction so we will call display backward and we'll run the code so here you see it simply prints the wlinklist in backward direction as 25, 15, 10, 1 and then null so friends in this tutorial we simply discussed how to traverse the wlinklist in forward and backward direction and print the data in the nodes on the console so friends i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to insert node at the beginning of a wlinklist in java so friends let's suppose we are given a wlinklist having four nodes say 1, 10, 15 and 65 so here you see head points to the first node and tail points to the last node and if we want to insert a node at the beginning of wlinklist we usually manipulate the head pointer and in that case tail pointer doesn't play any much role the only case where tail points comes into picture when the list is empty so when the list is empty usually head and tail both points to null and when we want to insert a node at the beginning of wlinklist therefore after this insertion the wlinklist has only one node so therefore head and tail both points to that node so we need to consider that case so in the algorithm if you see if the list is empty then the tail pointer comes into picture so we'll see the demonstration of this algorithm in next slide so friends below is the algorithm to insert a node into a wlinklist at the beginning so let's see the demo of this algorithm so currently if you see there in wlinklist we have this head node and tail node so the head points to the first node and the tail points to the last node so currently the list is empty therefore head and tail points to null and let's say we want to insert a node having a value 1 so first we'll create a new node and we'll assign the value to it the new node variable will point to a node which has data as 1 and whose next and previous points to null moving ahead we'll check whether wlinklist is empty or not so currently as head and tail points to null so list is empty therefore the condition and if statement comes out to be true and in order to insert this new node at the beginning of a wlinklist will first assign the value of new node to tail so currently tail points to null so after this statement it will point to the node to which the new node points so here if you see new node next points to null therefore we'll assign the value of head to new nodes next pointer so here head points to null therefore new node next will also point to null moving ahead and then we'll simply assign new nodes value to head so as head points to null we'll simply now make it point to the new node so here as list was empty so after insertion of this new node both tail and head will point to it because this is the only node in the wlinklist now let's say we want to insert a node having a value 10 into a wlinklist having the first node as 1 so here first we'll create a new list node having the value as 10 so this would look something like this that new node points to a list node having the data as 10 now we'll check whether wlinklist is empty or not so currently it's not empty because head and tail is pointing to the list node having data as 1 therefore the condition in if block comes out to be false and the else part will be executed so as we want to insert this new node at the beginning of this wlinklist so in order to insert this new node into the beginning of wlinklist we will assign the value of new node to heads previous so if you see the head points to the node having value as 1 and it previous points to null therefore we'll simply break this pointer and we'll assign this previous pointer to the new node so it would look something like this so in the first step we assigned head previous to the new node and in order to make it a twoway linked list or a wlinklist we need to assign new nodes next to the head so here we assign the value of head to new nodes next because in wlinklist the nodes refer to each other so the node which comes first refer to other through the next pointer and the node which comes after refer to first one through the previous pointer so here in the else part we saw that head dot previous referred to new node and here we saw that new nodes next refer to now the head so moving ahead so in the last step we'll simply assign the value of new node to head so here currently head points to a list node having data as 1 but as we have inserted is new node into the beginning therefore now head should point to this new node so friend this was the algorithm to insert a node into the beginning of wlinklist so friends let's move to Eclipse and see the working code so friends in my previous tutorial I created one class by name wlinklist head of type list node which points to the first node of a wlinklist and tail which points to the last node of a wlinklist and a length which which return us back the actual size of the wlinklist then we also created one inner class by name list node which had the data a pointer to next node and a pointer to the previous node and in my last tutorial I discussed how to print the elements of this wlinklist and forward and backward direction so in this tutorial we will write the code to insert a node at the beginning of a wlinklist so public void insert first so this method takes in a integer value so this integer value will be a part of the new node which we want to insert into wlinklist so first we'll create a list node by name new node and we'll simply assign the value to it moving ahead we'll create a fblock and here we'll provide a condition as is empty so here we are checking whether the wlinklist is empty or not so currently when we initialize the wlinklist head and tail points to null and the length is zero so is empty method returns us a boolean value and checks whether the wlinklist is empty or not so if the wlinklist is empty then first step will do is we assign new node value to tail and in the else part and if suppose the list is not empty then we'll assign the new nodes value to heads previous so head previous and then we'll simply point the new nodes next pointer to head and as the node is inserted now head will point to the new node so we'll simply assign the value of new node to head after we insert the node into the beginning of this wlinklist we'll simply increment the length by one now in main method let's run this code so first i've created and stands out wlinklist so initially head and tail points to null and length is zero so if i call insert first and i pass value as one and then i simply say display it forward and display it backward and so if i run the code node is inserted with the value of one and we have printed it both forward and backward so it prints out the same because head and tail points to the first node and if suppose i insert one more node as insert first and provide a value as 10 and now i run the code so you see initially there was one node having data as one so when we inserted the new node at the beginning of a wlinklist so now it printed out 10 and 1 in the forward direction so you see the currently head is pointing to 10 and tail is pointing to 1 so friends in this tutorial we saw how to insert a node into a beginning of a wlinklist i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to insert node at the end of a wlinklist in java so friends suppose we are given a wlinklist having four nodes say 1 10 15 and 65 so usually in wlinklist head points to the first node and tail points to the last node so if you want to insert a node at the end of wlinklist usually we do the manipulation with the tail pointer and in that case head pointer doesn't play any much role the only case in which head pointer comes into picture is when the list is empty so the list is empty then head and tail both points to null and after we insert a node at the end of wlinklist so the list contains only one node therefore the head and tail both needs to point to that particular node so here in this algorithm we need to cover that case when the list is empty so when the list is empty then head pointer comes into picture so we'll see the demonstration of this algorithm in next slide so friends below is the algorithm to insert a node at the end of a wlinklist so let's see a demo of this algorithm step by step so let's say currently the wlinklist is empty therefore head and tail both will be pointing to null and let's say we want to insert a list node and to this wlinklist having a value of 1 so in step 1 we'll first create a list node and we'll provide value to it so here if you see the new node will point to this list node having data as 1 and the pointers to next and previous node will point to null moving ahead then we'll provide a statement and in this if we'll check whether the list is empty or not so currently the list is empty because head and tail both are pointing to null therefore the condition in if block comes out to be true and this statement will be executed so as we want to insert this new node at the end of a wlinklist and currently this wlinklist is empty therefore when we'll insert this new node so this would be the only node in the wlinklist and we know that head points to the first node so therefore we'll assign new nodes value to head so you will see that now head points to new node moving ahead so as this wlinklist currently has one node and we also know that head points to the first node and tail points to the last node but this wlinklist has only one node therefore head and tail will point to this node so the last statement would be we need to assign new nodes value to tail so currently tail is pointing to null and after this statement tail will point to this new node so friends after the insert of this list node at the end of the wlinklist we see head and tail both point to this node because this is the only node in the wlinklist now let's say we want to insert one more node having the value as 10 so this algorithm will be executed again so in order to do that we need to first create a list node having the value as 10 so it would look something like this the new node points to a list node having the data as 10 and the next and previous pointers pointing to null moving ahead and in this if block will check whether this wlinklist is empty or not so if you see head and tail points to this node having the data as 1 so list is not empty therefore the condition in the if block comes out to be false and the else part will be executed so in order to insert this new node at the end of the wlinklist we know that wlinklist has currently one node and if we want to insert this new node it would come just after this first node therefore in order to insert this new node into wlinklist first we need to point tail next pointer to this new node and then we need two points new nodes previous to tail node because the adjacent nodes in wlinklist refer each other so therefore in the first step what we do we assign new nodes value to tail next so currently new node points to the node which we want to insert and tail node next points to null therefore when we assign new node value to tail next it would look something like this so now tail node next will point to this new node moving ahead and after this step we need to point new nodes previous to the tail node so in this step we'll assign the value of tail to new nodes previous so it would look something like this so currently the adjacent nodes in wlinklist are referring to each other such that the first node is pointing to the node which we wanted to insert and the node which we wanted to insert is referring it back so moving ahead so the final step is we need to assign new nodes value to tail so if you see in a wlinklist the head points to the first node and the tail points to the last node so initially there was only one node therefore head and tail pointed to the same node but after the insertion of this new node tail should point to this new node so in order to do that we need to assign new nodes value to tail and it would look something like this so friends this was a demonstration of inserting a list node at the end of wlinklist now let's go to eclipse and see the working code so friends in my previous tutorial i had created this wlinklist class and in the last tutorial we saw how to insert the node at the beginning of a wlinklist so in this tutorial we will code how to insert a node at the end of a wlinklist so for this first i will create a method public void insert last and this method will take an integer value now in the first i will create this new node based on the value we are passing to the method and the first step will be we'll provide a if check that whether the list is empty or not and if the list is empty we need to assign new node value to the head so friends if the list is not empty then we need to insert this new node at the end of wlinklist so we know that the tail points to the last node in the wlinklist so in order to insert this node we need to use tail dot next pointer and to tail dot next we'll assign value of new node therefore a tail node next will point to now new node and similarly to new node previous we will assign the value of tail so in the else part we are doing this because this new node and the tail will refer each other and once they refer each other the new node is a part of wlinklist and finally in the last step we'll reassign tail to point this new node so it would be tail we'll now point to new node and at the last we'll increment the length of wlinklist by 1 so friend this is the code for inserting a list node at the end of wlinklist so let's test this method in the main method so here i have created one instance of wlinklist class now let's say i insert say 1 and then i print the wlinklist say in the forward direction and if i run the program so you will see as the initially the wlinklist was empty therefore when we inserted a new node it by default became the first node and got inserted at the very beginning of wlinklist now let's say if i insert value 10 now when i run this program so when we'll print this wlinklist so this time should insert after the node having data as 1 so you see the 10 got inserted at the last position so initially there was node having data as 1 but when we inserted 10 it got inserted at the end of wlinklist so friends if suppose i insert one more node say having value as 15 and if i now run the program so you see the 15 got inserted at the end of wlinklist so initially there was node having data as 1 then we inserted 10 and then we inserted 15 so friends this was a tutorial to demonstrate how to insert a list node at the end of wlinklist i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to delete first node in a wlinklist in java so friends let's suppose we are given a wlinklist having three nodes say 1 10 15 and if you see below is the algorithm to delete the first node in a wlinklist so friends as you know that in wlinklist head points to first node and tail points to the last node so in order to delete the first node in a wlinklist we usually manipulate the head pointer because and if you see as tail points to the last node in a wlinklist therefore tail node doesn't play any much role in deletion of the first node but there is a case where tail nodes comes into picture when there is only a single node so if a wlinklist contains only one node then head and tail node both points to that particular node therefore the tail node comes into picture because we need to delete that particular single node so the only place where tail node comes into picture when head is equal to tail that is the wlinklist has only one node and both head and tail points to it so we'll see the demonstration of this algorithm step by step so suppose we need to delete the first node so in the algorithm first step would be we need to check whether the list is empty or not so if the list is empty it means there is no node to delete therefore we may throw no such element exception so if we take our example then this wlinklist has three nodes therefore the wlinklist is not empty so the condition in its statement comes out to be false so the first step would be we need to create a temporary node which will point to head as we want to delete the first node then we will create a temporary node which will point to the head moving ahead now we'll check whether head is equal to tail or not so currently head points to the first node and the tail points to the third node therefore they are not equal so the condition comes out to be false and the if part will be executed so friends we need to remove this first node now so in order to delete this first node from the wlinklist we need to do two things first we need to break this next pointer which is pointed by the temporary node so if you see temp next points to the second node so we need to remove this and if you see second node points back to temporary node and we need to break this link so these two links we need to break so in the else part we'll first break the link which is pointed by the second node to the temporary node so in order to break this link we noted head points to this first node which we want to remove and its next points to the second node so here what we'll do we'll say head dot next so when we do head dot next we reach to the second node and if we do dot previous then this is the link so currently this previous points to the first node and when we assign null so this link breaks up so so it would be something like this so what we are doing in this line is we are traversing from head to its next and then to its previous so from head we traverse to its next node and then we traverse back to previous so we broke this link here and we assigned a null value to it so we removed one link moving ahead so friends now we know the temporary node points to head which is the first node which we want to delete therefore when the first node is removed head will be pointing to the second node because after its removal second node will become our new head therefore we need to traverse this head to its next node so to head will assign the value of head dot next so currently head points to the node which we want to delete and head next points the second node and once this node is removed we know that now head will point to the second node because second node becomes the head of the doubly linked list so in order to do that we need to traverse head to its next position by assigning head dot next value to head so it would look something like this moving ahead and we know that temporary node refers to second node so we need to break this link as well so to break this link we'll simply do temp dot next equals null so temp dot next point to second node and we'll assign a null value to it so it would look something like this so now you see temporary node is an individual node where previous points to null and next points to null so in the last step we'll simply return the temp because this is the first node which we deleted so friends now doubly linked list contains two nodes where head points to the first node and tail points to the second node now suppose if we again call this algorithm to delete the first node then it would be something like first we will check whether list is empty so list is not empty so friends will create one temporary variable which will point to head and as we know that head points to the first node of a doubly linked list therefore in order to delete this first node we'll point the temporary node to the head moving ahead we'll check whether head is equal to tail or not so head is not equal to tail because head points to first node tail points to the second node so the else part will be executed now here we'll do the same thing we'll first take this previous link which is pointed by the second node to the first node so in order to reach this node we'll use head dot next and to assign null value to previous we'll use head dot next dot previous so when we'll do head dot next we reach here and we'll we'll do dot previous this is the link and we'll assign a null value to it so it would look something like this now we have removed one link moving ahead and now we'll simply traverse head to its next node because now once this node is removed we know that head should point to the next node in the doubly linked list because because now that node will become our new head so we'll simply traverse head to its next position by assigning head dot next value to head moving ahead and we'll simply assign a null value to temp dot next because we need to remove this link as well so so not temp dot next points to null and in the last step we'll simply return the deleted node so friends now you see doubly linked list has only one node where head and tail both points to that particular node so when we will call this below algorithm again to delete the first node then first it will be checked that whether the list is empty or not so currently list has one node therefore it's not empty then we'll create a temporary node which will be pointing to head because head points to the first node in the doubly linked list moving ahead we will check whether head is equal to tail or not so currently if you see head and tail both points to that particular node therefore they are equal so the condition in if statement comes out to be true therefore if block will be executed so friend this is the only node left in the doubly linked list and we want to remove that therefore we need to remove this both pointers head and tail because they are referring to this node so in the first step we'll assign a null value to tail so it would look something like this so now tail would be pointing to null and then we'll simply assign head dot next value to head so it simply means we are assigning null value to head so now head will be pointing to null and we'll simply assign null value to temp dot next but if you see temp dot next is pointing to null value only therefore we just simply return the temporary node in the last step so friends you saw there was only one node remaining and we removed that node as well now if you see tail and head both points to null so if we call this algorithm again so it will be checked whether list is empty or not so if you see head and tail both points to null therefore the doubly linked list is empty therefore if we call this algorithm then an exception will be thrown so we can throw an exception saying that there is no such element left so friends this was the demonstration of the algorithm now let's go to eclipse and see the working code so friends in my previous tutorial i created one class by named doubly linked list and we implemented the doubly linked list into that class so this class has basically a head node and a tail node and an integer variable by name length which stores the size of the doubly linked list you can watch my previous tutorials to understand those concepts so in this tutorial we'll just code a method which will delete the first node in a doubly linked list so i'll create a method as public list node delete first now this method will return us back the deleted node so the return type is list node so first we'll provide a if check and in if block we'll provide a condition as whether doubly linked list is empty or not so if doubly linked list is empty we'll throw an exception moving ahead then we'll create a list node by name temp and we'll assign a value of head to it as head points to the first node of a doubly linked list therefore we'll assign value of head to this temporary node and then we'll check if head is equal to tail or not so when head is equal to tail it means doubly linked list has only one node so in that case we'll assign null to tail because we need to break the reference of tail pointing to that particular node which we want to delete and if head is not equal to tail then in else block we'll write head.next.previous and we'll assign a null value to it we are assigning a null value to head.next.previous because we need to break the previous link which is coming from the second node and then we'll simply assign head.next value to head now we also need to break the next link which temporary node is pointing to the second node therefore we'll do temp.next and assign a null value to it and finally this temporary node is removed therefore we know that size of length is reduced by one therefore we'll do length so here we are decrementing the length by one because we have removed one node and in the last I will simply return the temporary node because this temporary node is pointing to the first node of doubly linked list so friend this is the algorithm to remove the first node in a doubly linked list now let's test it's working so friend in my previous tutorial we saw how to insert the nodes in doubly linked list so here I have added three nodes by data as 1 10 and 15 and if I print the doubly linked list in the forward direction so you can see one points to 10 10 points to 15 and 15 points null so totally there are three nodes now let's delete the first node in the doubly linked list so we'll call delete first and let's display the doubly linked list again so I'll call it display forward and if I run the code so you see initially doubly linked list had nodes as 1 10 and 15 and the node having data as 1 was the first node so when we call delete first the node at first base got removed and the doubly linked list became 10 15 now let's say I again call delete first and if I run the program so you see when delete first was called first time one was removed and when we called delete first again so 10 was removed because 10 became our new head and finally if I call delete first again and I run the program so you see all the nodes are removed and nothing got printed because because in display forward we have kept a condition if head is null then simply return so when all the three nodes got removed head pointed to null and nothing was printed but if I call delete first again as head and tail both are pointing to null and if I call delete first again so you can see we are getting an exception as no such element exception because list is empty and there is no element left to be removed so friends this was the tutorial to remove the first node in a doubly linked list I hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to delete last node in a doubly linked list in java so friends let's suppose we are given a doubly linked list having three nodes with data as 1 10 and 15 so here you see below is the algorithm to delete the last node in a doubly linked list so friends the basic idea behind this algorithm is as we want to delete the last node in a doubly linked list we will use basically this tail pointer to remove the last node in a doubly linked list because in a doubly linked list head points to first node and a tail points to the last node and we want to remove the last node in a doubly linked list therefore we'll manipulate and play with this tail pointer to remove the last node from the doubly linked list so head pointer doesn't play much role in deleting the last node from a doubly linked list The only case where head pointer comes into picture is when there is only one node in a doubly linked list because if there is only one node in a doubly linked list then head and tail both will point to that particular node and if you want to remove that single node from a doubly linked list we need to manipulate head pointer as well. So friends let's see the demonstration of this algorithm. So the first step we will check whether the list doubly linked list is empty or not. So doubly linked list is empty which will throw an exception saying that there are no more elements left to be removed. So currently doubly linked list has three nodes therefore the list is not empty. So the condition in a block comes out to be false. Now as you want to remove the last node from a doubly linked list we will create one temporary node which will be pointing to the tail. So now temp points to a tail because when we remove the last node from a doubly linked list it will be removed using this temporary node. Moving ahead so here in the block we will check whether head is equal to tail or not. So currently head points to the first node and tail points to the third node therefore they are not equal. So the condition comes out to be false and the else part will be executed. Now friends in order to remove this last node from a doubly linked list we need to remove this two pointers because once we remove this two pointer this node will be freed and it will be removed from the doubly linked list. So first we will remove this next pointer because this last node is being referred by the second last node. So we need to remove this link. So in order to remove this link we need to traverse to the second last node and then assign a null value to its next node. So in order to traverse to the second last node we will use this tail pointer will first go to its previous by calling tail.previous and then to its next we will assign a value of null. So in this line what we are doing we are assigning a null value to tail.previous.next. So it simply means we are first traversing to the previous and to the next we are assigning the value as null. So it would look something like this. So this link will be removed and then it will point to the null value. Moving ahead so friends once we remove this last node of a doubly linked list we see tail points to red node. So after its removal tail should point to the second last node because that second last node upon removal becomes the last node of the doubly linked list. Therefore we need to traverse tail to its second last node. So we will simply assign tail.previous value to tail. So it would look something like this. Moving ahead and then we will simply break this link and we will assign a null value to it. So we know that temporary node is pointing to this last node and we need to assign a null to its previous therefore we will simply assign a null value to tail.previous. So it would look something like this. So in the final step we know that the last node which is pointed by temporary node has been removed from doubly linked list will simply return this temporary node. So friends after removal of this last node only two nodes are left. So it is pointing to the first node and tail is pointing to the last node. Now if you want to again remove the last node from this doubly linked list we call this algorithm again we check whether list is empty or not. So list is not empty and as we want to remove this last node we will create one temporary node and we will assign the value of tail to it. Moving ahead we will check whether head is equal to tail or not. So head is not equal to tail because head points to first node and tail is pointing to the second node. Therefore the else part will be executed and in the else part we will do the same as we need to remove this link. So we will traverse a node back and we will assign a null value to its next. So we will simply do tail.previous.next and assign a null value to it. So tail points to the second node and when we do tail.previous we are reaching to the first node and then to its next we are assigning the null value. So it would look something like this. So the link which was referring to this node we have removed it. Moving ahead and as we know that this is the last node of the doubly linked list because once the last node is removed the tail should point to its previous node because dead becomes the last node in the doubly linked list. Therefore we will simply assign tail.previous to tail. So it would look something like this. So now head and tail both are pointing to the first node. Moving ahead and we need to break this link and that link is referred by Tams.previous. So we will simply assign null value to Tams.previous. So it would look something like this. So as we know that this node is freed therefore we will simply return this temporary node. So friends now in doubly linked list only one node is left where head and tail both are pointing to that particular node. So let's call this algorithm again. So first we will check whether list is empty or not. So list has one node therefore it's not empty. Then as we know that there is only one node left and we want to delete the last node therefore this is the only node that needs to be removed. So we will simply create one temporary node and we will assign the value of tail to it. Moving ahead now here is the case where head is equal to tail because both are pointing to this first node. Therefore in order to remove this node we need to break this both links because head is pointing to this node and tail is also pointing to this node and we need to break this both link so that this node can become free to be removed. So in the if part we will simply assign a null value to head. So we have removed one link moving ahead and then we will simply traverse tail to its previous node by assigning tail dot previous to tail. So you see tail previous is pointing to null therefore we are simply assigning a null value to tail. So it would look something like this. So now tail will point to null and now we will simply assign a null value to temp previous. So you see temp previous is already pointing to null therefore we do nothing. And simply in the last I will return this temporary node. So you see now head and tail both are pointing to null and there are no nodes left in the list therefore the list is empty. So if you call this algorithm again then first I will check whether list is empty or not. Now we know that list is empty and there are no nodes left to be removed therefore we can throw and no such element exception because there are no nodes left to be removed. So friends this was the demonstration of the algorithm. Now let's go to Eclipse and see the working code. So friends in my previous tutorial I had created one class by name wlinklist and we implemented a wlinklist into that class. So this class has head and tail node and it also has an integer variable by name length which stores the size of the wlinklist. So if you want to understand the working of wlinklist you can watch my previous tutorials. So in this tutorial we will discuss how to delete the last node of a wlinklist. So first I will create the method as public list node delete last. So this method will remove the last element and will simply return it back therefore the return type is of list node. So first we will provide a if check as if a wlinklist is empty or not. So if it is empty then we will simply throw a exception say no such element no such element exception. Moving ahead will create a list node by name temp and will assign a value of tail to it because we need to remove the last node for the wlinklist therefore we are using this tail pointer to remove that last node. And we will provide an if check if head is equals tail then we will simply assign null value to head because when head is equal to tail there is only one node left in the wlinklist so we need to break both the reference head and tail in order to free that node. So we will simply assign a null value to head and in the else part we will do tail.previous.next and assign null value to it moving ahead then we will simply traverse tail to its previous node because once the last node is removed now tail will point to the node just before it and we will assign null to temp.previous because we need to break that link as well. And finally as we delete this node we need to reduce the length of wlinklist by 1 therefore we decrement the length by 1 and last we will simply return the temp. So friends we saw the algorithm to remove the last node of a wlinklist now lets test its working in main method. So in my previous tutorial we just discussed how to remove the first node of a wlinklist so here I will just call delete last so here if you see we have inserted 3 nodes by data as 1, 10 and 15 and first we are removing the last node so if I run the code you see first it printed 1, 10, 15 and null so when we call delete last so it printed 1, 10 and 15 got removed and if I call this method again and then I run the program. So you see we called delete last 2 times so in the first time 15 got removed and the second time 10 got removed and if I call it again so if I called it again so 1 was also removed and nothing got printed because in display forward we have kept in condition that if head is null then simply return and we know that we inserted 3 nodes and we removed 3 nodes so list got empty and head pointed to null therefore display forward printed nothing and if I call delete last 1 more time then as we know that list is empty and there are no nodes left to be removed therefore you see an exception was thrown because there was no node left to be removed so friends in this tutorial we will discuss how to remove the last node of a doubly linked list I hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to represent a circular singly linked list in java so friends what is a circular singly linked list so if you see this is how we represent singly linked list and this is how we represent a circular singly linked list so the structure wise circular singly linked list is very much similar to singly linked list and here you can see in singly linked list we have these nodes which form a chain and we keep a head node which points to the first node and the last nodes next point to the null so the only difference between singly linked list and circular singly linked list is that in circular singly linked list the last node points to the first node and not null so here if you see in singly linked list the last node next is pointing to null but in circular singly linked list the last nodes next is pointing to the first node again and not null so therefore this property makes circular singly linked list circular in nature where if you see 1 points to 8 8 points to 10 10 points to 16 16 again points to 1 so therefore it's a circular in nature and one more difference is like in singly linked list we keep the track of the head node which is pointing to the first node but in circular singly linked list we keep the track of the last node so in circular singly linked list we keep the track of the last node because it helps us in insertion and deletion of the nodes in constant time so here if you see as head points to the first node and suppose if we want to insert a node in a singly linked list at the end so we need to traverse each and every node in the singly linked list to reach the last node and then add the particular node but here in circular singly linked list we are keeping the track of the last node and if suppose we want to insert a node at the end so we can directly use this last pointer and add the node at the end and suppose if you want to insert a node at the beginning then we know that a circular singly linked list is circular in nature therefore when we do last dot next we reach to the first node so we can directly add node at the beginning in constant time so friend this is how we represent a circular singly linked list where we keep the track of the last node and last node next points to the first node so friends let's see a demonstration of circular singly linked list below you can see that circular singly linked list has three nodes having data as one eight and ten and the node having data as ten has been referred by the last node and you can see it's a last node in a circular singly linked list where its next is pointing to the first node so let's see a small demo how we can create this circular singly linked list so suppose we initialize a circular singly linked list so we know that the list is empty so therefore the last will point to null so when the list is empty the last node is pointing to null now let's suppose we are inserting this node having the data as one so it's a simple node having data as one and next is pointing to null so if you want to insert this node into the circular singly linked list and as the list is empty we'll simply assign the value of time into last so that last points to this node so it would look something like this so now the last node is pointing to the node having data as one and we also know that circular singly linked list has property that last next points to the first node of a circular singly linked list but here if you see there is only one node so basically this node is the last node of a circular singly linked list and also the first node so last next should point to this node only so it would look something like this so when we insert a node into a empty circular singly linked list last points to that particular node and and its next points to the node itself now let's suppose you want to add one more node having data as eight so here you can see the temp is pointing to this node having data as eight and its next is pointing to null so in order to insert this node into the circular singly linked list having data as one and last is pointing to one so what we do is when we insert this node with a value eight we know that its next should point to the first node so therefore what we do is we simply break this link and we point it to the first node so it would look something like this as temp next is pointing to the first node and here if you see the first node is pointing to the second node therefore we need to break this link and we need to point it to the second node so it would look something like this so now you can see that node one is pointing to node eight and node eight is again pointing to node one so they are circular in nature and one last step we need to do is as we have inserted is node eight and we know that this is the last node therefore we'll simply assign the value of temp to last so it would look something like this so after the insertion of node having data as eight the circular singly linked list looks like this where node having data as eight is pointed by the last node and its next points to the first node therefore its maintain a circular property and let's suppose we want to add one more node having data as ten so here if you see the node next is pointing to this first node so in the first step what we'll do will simply remove this link and we'll point it to the first node so it would look something like this so now temp next is pointing to the first node and here you can see that second node is pointing to the third node so but here second node is pointing to the first node so we need to simply break this link and we need to point it to the third node so it would look something like this and one last step we need to do is when we have inserted is node having data as ten we know this is the last node therefore we simply need to refer the value of temp to the last so it would look something like this so friends here if you see we inserted three nodes and we knew that node one is the first node and node having data as ten is the last node and here the last node is pointing back to this first node so therefore we saw how circular singly linked list is created and and how they maintain a circular property so friends in this tutorial we discuss how we can represent a circular singly linked list in Java in my next tutorial we will see how we can implement circular singly linked list in Java I hope you liked this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in Java tutorial series video friends in this tutorial we will discuss how to implement a circular singly linked list in Java so friends in my previous tutorial we discussed how we can represent a circular singly linked list we discussed that it's very similar to singly linked list with a slight difference that in singly linked list the last node points to null but in circular singly linked list the last node points to the first node which makes this data structures circular in nature we also discussed that we use head node to keep the track of singly linked list but in circular singly linked list we usually keep the track of the last node so friends in my previous tutorial we discussed about the circular singly linked list representation so in this tutorial we will discuss how we can implement a circular singly linked list in Java so let's go to Eclipse and see the working code so friends in order to implement a circular singly linked list I have created one class by name circular singly linked list so in this class we will write the code for circular singly linked list implementation now here we will first create few instance variable so private so here we have created an instance variable of type list node by name last so this list node will help us in keeping the track of the last node of a circular singly linked list we will also create one more instance variable so here we have created an integer variable by name length so this length variable will hold the size of this circular singly linked list and inside this circular singly linked list will create a private class of list node so as this is very similar to singly linked list which we saw in our previous slide so I will just code what's required in list node so here list node contains the data part and a reference to the next list node will create one constructor now this constructor will take the data part moving ahead will create a constructor for this circular singly linked list class so friends when we initialize circular singly linked list we know that last points to null and as the list is empty therefore length would be zero so here we also create one more method public int length so when we call this method it should return us back the size of circular singly linked list so we simply return length will also create one boolean method by name is empty now this method will return us back whether the circular singly linked list is empty or not so we'll simply return that when length is 0 then return true and when length is not 0 then simply return false so let's say in our main method I create the instance of circular singly linked list so friends here we will write one more method which can create the circular singly linked list so we'll simply create one method as public void create circular linked list so here we'll first create few nodes say first let's say I give data as one I'll copy this let's say I give data as five ten fifteen and I will change the name is second third so friends we have created this four nodes now we'll interconnect them so first should point to second so we'll do first dot next and assign a value of second to it and similarly second dot next and assign a value of third to it and similarly third dot next and assign a value of fourth to it now friends here you see first point to second second point to third and third point to fourth but fourth is pointing to null therefore in order to make this linked list circular will simply do fourth dot next and assign first to it so therefore now fourth node will point to first node again so it will make it in circular in nature and in last what we'll do the instance variable which we created last it should point to the last node therefore we'll assign the value of fourth to last so friend this is how we represent a circular singly linked list in Java and if you if you want to call this method we can simply do csl.create so this will create a circular singly linked list of four nodes where first will point to second second will point to third third will point to fourth and fourth will again point to first and we can track those changes using the last list node so friend this is how we implement a circular singly linked list in Java I hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in Java tutorial series video friends in this tutorial we will discuss how to traverse and print a circular singly linked list in Java so friends in my previous tutorial we discussed how we can represent a circular singly linked list and we also saw how we can implement the circular singly linked list in Java so in this tutorial we will discuss how we can traverse and print the elements of a circular singly linked list in Java so here you see below is the algorithm to traverse the circular singly linked list and print the elements data so here let's see an example when the circular singly linked list is completely empty and last is pointing to null so friends we know that when the circular singly linked list is empty therefore there are no elements and last will point to null so here when the last points to null we know that there are no nodes inside the circular singly linked list to traverse therefore we are keeping one condition as when the last points to null then simply return so here we know that last is pointing to null so we will simply return from it so friends let's see a demonstration of the algorithm with the circular singly linked list having four nodes say 1 8 10 and 16 where 16 is the last node and its next is pointing to this first node now let's see how we can traverse each element inside this circular singly linked list and print the data with their respective node so here first we'll check whether last is null or not so as last is pointing to this fourth node therefore it's not null so the condition in a block comes out to be false so we move ahead now friends as we know that we are keeping the track of this last node which is the fourth node and suppose if we want to traverse each and every node and print the data so we need to start with the first node and then we can print the data accordingly but as here we are only keeping the track of the last node so therefore in order to reach this first node we know that the last node next points to the first node and we need to traverse circular singly linked list from the first to the last node so therefore we'll create this first node and we'll assign the value of last dot next to it so it would look something like this moving ahead so friends we know that circular singly linked list is basically circular in nature where first node points to second second point to third third points to fourth and fourth points to the first again so we need to provide a while loop to traverse each and every node and we need to take a special care while placing the condition in while loop because if we place some wrong condition then we know that as it's circular in nature therefore this while loop may enter into an infinite loop so here as we want to traverse each and every node and print the data into the respective node so we'll traverse till we have reached the last node so the condition in while loop will put as will iterate till first is not equal to last because when first is equal to last we know that we have traversed each and every node so currently first is pointing to this first node and last is pointing to this fourth node therefore first is not equal to last so the condition in while loop comes out to be true so in the first step we'll simply print a data associated with this first node moving ahead so friends as we have traversed this node now we need to just move to its next node so in order to move this first node to its next we'll simply assign the value of first dot next to first so here if you see first is pointing to this first node and its next is pointing to the second node therefore we are simply assigning the value of first dot next to first so it would look something like this so it simply traverses first to its next version by this statement moving ahead now again first is not equal to last therefore condition in while loop comes out to be true so we'll simply print the data associated with the first node moving ahead now as we have traversed the second node so we'll move to the next node so in order to move this first to its next we'll simply assign first dot next value to first so first dot next points to the third node so after this statement it would look something like this moving ahead now again first is not equal to last therefore the condition in while loop comes out to be true so in first step we'll simply print a data associated with this third node and in the second step we'll simply traverse first to its next by assigning first dot next value to first so it would look something like this moving ahead so friends now here you see first and last both are pointing to this fourth node therefore first is equal to last so the condition in while loop comes out to be false so therefore the while loop breaks out so friends here you can see that we had this pointer to this last node and we started traversing and printing of the elements from the first node so here if you see the circular singly linkage has four nodes and we have traversed three nodes by printing one eight and ten and then in the while loop when we traverse to the last node we know that condition in while loop came out to be false as first is equal to last therefore we have reached to this node but we haven't printed a data for this last element so therefore in the last step we'll simply print a data associated with this fourth node so when we print the data associated with fourth node we are sure that we have traversed all the nodes and we have print the data associated with the respective nodes so friends we saw the demonstration of the algorithm now let's move to Eclipse and see the working of the code so friends in my previous tutorial I created one class by name circular singly linked list and we saw the implementation of circular singly linked list in that tutorial we basically created few instance variable by name length and last so this last node was used to keep the track of the last node in circular singly linked list we also saw how we can create a circular singly linked list and we added this four nodes one five ten and fifteen and we made this linked list circular by assigning this fourth node again to the first so friends in this tutorial we will write the code to traverse and print the elements of a circular singly linked list so we'll create a method as public void we give the name as display so this method will simply traverse each and every element in a circular singly linked list and print the data with the respective node so here first we'll provide a condition as if last equals null so it means that if circular singly linked list is empty or not so if circular singly linked list is empty then we'll simply return and do nothing moving ahead we'll create a list node by name first and we'll assign the value of last dot next to it so this thing we are doing because we need to traverse the circular singly linked list from first position to the last position and we know that last dot next points to first so we are simply creating a list node by name first and we are assigning the value of last dot next to it and then we'll create a while loop so inside this while loop we will traverse each and every node of circular singly linked list using this first node so the condition we provide in while loop is we will traverse this first till it becomes last and in the while loop we'll simply first print the data associated with the first node and in the next step we'll simply traverse first to its next node by assigning first dot next value to first so here in this while loop what we are doing is we are printing the data associated with the first node and then we are simply traversing first to its next node by assigning first dot next value to first so when we are reaching to the last node we need to print the data associated with the last node as well so we'll simply print first dot data now in main method let's see the demonstration of this display method so here first we'll create the instance of circular singly linked list and then we'll create the circular singly linked list by calling create circular linked list method so in this method we are simply creating four nodes where first is pointing to second second is pointing to third and third is pointing to fourth and as fourth is the last node therefore fourth will point again back to the first node and in the last step we are simply assigning the value of fourth to last because we are holding this circular singly linked list through this last instance variable now let's say we are calling this display method and if I run the code so friends here you see it prints one five ten fifteen which are actually the four nodes in our circular singly linked list so friends in this totally we discussed how we can traverse a circular singly linked list and print the data associated with respect to nodes I hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in Java tutorial series video friends in this tutorial we will discuss how to insert note at the beginning of a circular singly linked list in Java so friends in my previous tutorial we discussed about circular singly linked list so here if you see below is the algorithm to insert a node at the beginning of a circular singly linked list so here if you see when the circular singly linked list is empty the last node points to null because there are no nodes inside the circular singly linked list and you see the length is zero so friends let's see the demonstration of this algorithm let's suppose we want to insert a node at the beginning of a circular singly linked list so in the first step what we are doing is we are creating a list node by name temp and we are passing in the data which we actually want to insert so it looks something like this so your temp variable is pointing to this list node having data as one and whose next is pointing to null moving ahead now in the second statement we usually check whether this circular singly linked list is empty or not so we provide a condition that whether last is equal to null or not so here if you see last is pointing to null therefore the circular singly linked list is empty so the condition comes out to be true so in order to insert this temporary node into the circular singly linked list at the beginning the first step we do is we assign the value of temp to last so it looks something like this and after this step temp and last both point to this particular node as the circular singly linked list is empty and we want to insert this node at the beginning so when we insert this particular node we know that the circular singly linked list has only one node the last node points to that particular node so therefore we have assigned the value of temp to last moving ahead now after the if else block what we do is we simply assign the value of temp to last dot next now why we are doing this step is because here we know that we are basically inserting a node at the beginning of a circular singly linked list and we also know that circular singly linked list has property that the last node usually refers to the first node and as we are inserting a node at the beginning we know that the last next should point to this particular node and here if you see when we are inserting a node into an empty circular singly linked list we know that after an insertion there is only one node which is the first and the last node both and we want to make the last dot next point to first node so in order to do that what we are doing is we are assigning last dot next value to the node itself and here we know that temp is pointing to this particular node so it looks something like this so this link is gone and then it will refer to itself because temp is pointing to this node only so after this step last next will point to the node itself and here if you see it is also fulfilling the property of circular singly linked list as last node is pointing to the first node and since this is the only dot in the circular singly linked list therefore last node and the first node is the node itself therefore here it is referring to itself moving ahead so after we insert the node in a circular singly linked list we usually increment the length by one because we know that now circular singly linked list has size one so now the value stored in the length will be one so when the method get executed circular singly linked list looks like this so friends let's insert one more node into the circular singly linked list having the length as one so usually in the first step we create this temporary list node having the data which we want to pass so let's say we are taking a node having data as eight and the temporary node is pointing to it and its next is pointing to null so this node we want to insert at the beginning of this circular singly linked list therefore we need to insert the node just before the node having the data as one so let's see the demonstration step by step so in the first step we usually check whether the circular singly linked list is empty or not so we make an if check that whether last is pointing to null or not so your last is pointing to this node therefore the circular singly linked list is not empty so the condition comes out to be false so therefore the else block will be executed so in the else block what we do is we assign the value last dot next to temp dot next so here if you see last dot next is pointing to the node itself and temp dot next is pointing to null so why we are doing this step is because we want to insert the node at the beginning so therefore this node should come just before this so when this node will be inserted this would be the first node and this would be the last node and as this would be the first node its next should point to this node so in order to do that we need to break this link and we need to assign this link to last dot next so here if you see last dot next is pointing to the last node itself and we want to insert this node just before this therefore we need to assign the value of last dot next to temp dot next so it looks something like this so now temp dot next is pointing to last dot next moving ahead and then what we do is we simply assign the value of temp to last dot next so friends in this step what we are doing is once we insert this node this node would be the part of circular singly linked list and this would be the first node and we also know that circular singly linked list is property that last node will always point to the first node therefore last next should point to this node because that is the circular singly linked list property so in order to do that we are simply assigning the value of temp last dot next so it would look something like this and as we want to insert this node at the beginning of a circular singly linked list we know that last dot next should point to this node because after insertion this node will become our first node we increment the length by one so after the method is executed we know that circular singly linked list has two nodes and length is two now friends let's suppose we want to insert one more node so in the first step will create the last node by name temp so here it would look something like this the temp is pointing to the node having data as 10 and its next is pointing to null now this node we want to insert at the beginning therefore we know that this node should come just before it and once this node is inserted this node will become our first node so let's see the demonstration of algorithm so first we'll check whether list is empty or not so as last is pointing to the node having data as one therefore the list is not empty so in the else block we are simply assigning value of last dot next to temp next so friends as we want to insert this temporal node at the beginning of a circular singly linked list and the first node is having the data as 8 therefore when we want to insert this temporal node just before that then we need to make this pointer point to this particular node and in order to reach this particular node we know that we are keeping the track of the last node and when we do last dot next we are reaching to the first node therefore we are simply assigning the value of last dot next to temp next so it would look something like this now your temp dot next is pointing to the first node of a circular singly linked list moving ahead and the last step we do is as you want to insert this temporary node so once this node is inserted we know that this would become our first node and we know that circular singly linked list has property that last node next should point to the first node therefore here we are simply assigning the value of temp to last dot next so it would look something like this and the final step we are incrementing the length by one currently the circular singly linked list has three nodes where first node has data is 10 second node has data is 8 and the last node has data is 1 and last next is pointing to the first node so after the method is executed the circular singly linked list looks like this so friends here we inserted three nodes having data as 1 8 and 10 at the beginning of a circular singly linked list now let's go to Eclipse and see the working code so friends in my previous tutorial we discussed about circular singly linked list and its implementation we created one class by name circular singly linked list so in this tutorial we will write a method which will insert the node at the beginning of a circular singly linked list so let's say I give the name of method is public void insert first so here I have created one method by name insert first so this method will take the data part which is of integer type so in the first step we'll create a list node by name temp and here we pass the data into the constructor so therefore in this step we are simply creating a list node of the data which we have passed into the method now in the next step we are providing a if check that last is equal to null or not so if the circular singly linked list is empty therefore in the if statement we are simply assigning the value of temp to last so last equals temp moving ahead and if the circular singly linked list is not empty then we are simply assigning value of last dot next to temp dot next and after the if else block we are assigning the value of temp to last dot next so last dot next equals temp and then we are simply incrementing the size of circular linked list by one so friend this is the code for insertion of a node into the beginning of a circular singly linked list so here we first create the list node then we check whether the list is empty or not so if the circular singly linked list is empty then we simply assign the value of this temporary node to last and if the circular singly linked list is not empty then we simply assign the value of last dot next to temp dot next which we saw in the slide and the last step we usually assign the value of temp to last dot next and then we increment the length by one now in the main method let's test the working of this insert first method so in my previous tutorial in the main method we created the instance of circular singly linked list and let's say using that instance we call insert first and we provide the data as 10 and finally we call the display method so if I run the code so you see it printed value as 10 now let's say I call this method again and provide data as 15 and if I run the program so you see it printed 15 and then 10 so here when the circular singly linked list was empty we call insert first and pass value as 10 so the node having data as 10 was the only node into the circular singly linked list and when we inserted 15 so here we are inserting 15 at the beginning of a circular singly linked list so this circular singly linked list had only node having data as 10 so when we inserted 15 it got inserted just before the node having data as 10 so if you want to insert one more node say of data 25 so this 25 will be inserted just before the node having data as 15 so if I run the code so you see it printed 25 15 and then 10 so friends in this tutorial we discussed how to insert a node at the beginning of a circular singly linked list in Java I hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in Java tutorial series video friends in this tutorial we will discuss how to insert node at the end of a circular singly linked list in Java so friend let's suppose we are given an empty circular singly linked list so when the circular singly linked list empty we know that the last node points to null and in order to understand what this last node is you need to watch my previous tutorials so in this tutorial we will be discussing how to insert a node at the end of a circular singly linked list in Java so let's see the demonstration of this algorithm step by step so we also know that when the circular singly linked is empty length is zero now in order to insert a node in a circular singly linked list at the end the first step we do is we basically create a node and will pass the data so here we have created one node having the data as one and which is being referred by this temp node and whose next is pointing to null now we want to insert this node at the end of a circular singly linked list so moving ahead so the first step we check is whether the last is equal to null or not so if the last is equal to null then we know that circular singly linked is empty so therefore the condition in if log comes out to be true so here the first step we do is we simply assign the value of temp to last now as the circular singly linked list is empty so therefore there are no nodes and as we want to insert this temporary node at the end of the circular singly linked list so when we insert this temporary node into the empty list we know that after its insertion this would be the only node in the circular singly linked list therefore last should point to this node so in the first step we are simply assigning value of temp to last so it would look something like this moving ahead now in the second step we are assigning value of last to last.next so why we are doing this step is we need to fulfill circular singly linked list property that last next should point to first node and as we know that this is the only node in the circular singly linked list therefore the last and the first node is the node itself so we are assigning value of last to last next so it would look something like this so this link is gone and now this last.next will refer to the node itself so it would look something like this and in the last step we will simply increment the length by one because we have successfully inserted the node at the end of a circular singly linked list so friends once this algorithm executed we know that initially circular singly linked list was empty and now it contains only one node so it is referred by last because this is the only node and its next is pointing to the first node which is the node itself so now if we call this algorithm again and we want to insert one more node so let's the demonstration of the algorithm now in the first step we will simply create the list node and provide the data which we have passed into the method so it would look something like this the temp is pointing to the node having data as it and whose next is pointing to null now let's say we want to insert this node at the end of a circular singly linked list so let's see the demonstration step by step so we check whether last is equal to null or not so now the last is pointing to one node therefore it's not equal to null therefore the condition in if block comes out to be false so the else part will be executed so in the else block the first step we do is we assign the value of last.next to temp.next so here why we are doing this step is as you want to insert this temporary node at the end of a circular singly linked list we know that after its insertion that the node which is referred by temp would be the last node so if it is a last node then its next should point to the first node and how to reach the first node we know that currently the node which is referred by last its next is the first node therefore we are simply assigning last.next value to temp.next so it would look something like this so this link will be removed and it would refer to the first node and in order to reach the first node we know that last.next refers to first node therefore temp.next will now refer to the node even data as one so it would look something like this so currently you see we have two nodes where temporary.next is pointing to this first node so moving ahead and in the second step we are assigning value of temp to last.next now here you can see last.next is referring to itself and we know that when we insert this node last.next should refer to this node because then it will form a chain so we are simply assigning value of temp to last.next so it would look something like this so now this link will be gone and now it should refer to this temp node so moving ahead and in the last step we are simply assigning value of temp to last now we are doing this step is because we have inserted the node at the end of a circular singly linked list and we know that we are keeping track of this last pointer so after this temporary node is inserted into circular singly linked list we know that this becomes the last node therefore we need to assign the value of temp to last so that last refers to the last node of a circular singly linked list so it would look something like this so in the final step we will simply increment the length by one the circular singly linked list has two nodes and we can also see that the last next is referring to this first node now friends let's suppose we want to insert one more node into this circular singly linked list so we'll execute this algorithm again and we'll pass the data into the method so let's see the demonstration of this algorithm step by step so in the first step we'll simply create a list node and we'll refer it to by temporary variable so here you can see we have simply created a temporary node having data as 10 and whose next is pointing to null and now we want to insert this node at the end of the circular singly linked list so let's see the demonstration of this algorithm step by step now the first step will check whether last is equal to null or not so currently last is pointing to the second node therefore it's not null so the condition and if block comes out to be false so the else part will be executed so the first step in else part we do is we simply assign the value of last.next to temp.next so here you can see last.next is pointing to this first node and temp.next is pointing to null and as we want to insert this node at the end of a circular singly linked list we know that after its insertion this temporary node becomes the last node therefore its next should point to the first node and in order to reach this first node we know that last next is referring to it therefore we'll simply assign value of last.next to temp.next so it would look something like this so now you can see temp.next is pointing to this first node moving ahead in the second step we simply assign value of temp to last.next so here in order to insert this node at the end of a circular singly linked list we know that initially this list contains two nodes and in order to insert this third node we need to break temp.next link which is referring to first node and we need to assign it to the temp node because then this third node will be a part of a chain so in this step we are simply assigning value of temp to last.next so it would look something like this so this link is broken and now it will point to this temporary node moving ahead in the final step we know that as we have inserted this node which is at the last position we'll simply assign value of temp to last so it would look something like this now in the last step we'll simply increment the length by one so friends here you can see the length of the circular singly linked list is of size 3 as you have three nodes where data is 1, 8 and 10 and the last node next is pointing to the first node so friend this was the demonstration of the algorithm now let's go to Eclipse and see the working code so friends in my previous tutorial I created one class by name circular singly linked list and we implemented circular singly linked list into the class so in this tutorial we will simply write a method which would insert a node at the end of a circular singly linked list so I'll create one method as public void insert last and to this method I will pass an integer value which will actually hold the data of the list node so in the first step we'll simply create the list node by name temp and we'll pass the data into the constructor and then we'll provide an if else block so in the if we'll provide a condition is whether list is empty or not so we'll simply check whether last is equal to null or not or we can also call is empty method which we have discussed in my previous tutorials so friends if the list is empty then we'll simply assign value of temp to last and in the second step we'll simply assign value of last to last dot next which we discussed in the slide and in the else part so in the first step what we do is we assign the value of last dot next to temp dot next in the second step we assign the value of temp to last dot next and finally we assign the value of temp to last and as we discussed in the slide once we insert the node at the end of the circular singly linked list we increment the length by one so length plus plus so friend this is the code to insert the note at the end of a circular singly linked list now let's test this method into the main method so in the main method I have created an instance of circular singly linked list so let's add few note at the end of the circular singly linked list so here we will add the notes which we saw in the slide so insert last and let's say I provide data as one and if I print the circular singly linked list by calling display method you can see when I run the code it prints one because initially circular singly linked list is empty and when we insert one note at the end of the circular singly linked list we only get this one note now let's insert one more note and I provide data as eight and when I run this code you can see it printed one and then eight so therefore it inserted eight at the end of the circular singly linked list now let's say I insert one more note having data as ten and if I run this code you can see it printed ten so friends here we inserted three notes at the end of the circular singly linked list so first we inserted one and then we inserted eight so eight was inserted at the last position and finally we inserted ten so you can see the ten is inserted just after eight and which is the last note so friends in this tutorial we discussed how to insert a note at the end of a circular singly linked list I hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in Java tutorial series video friends in this tutorial we will discuss how to remove first note from a circular singly linked list in Java so friends let's suppose we are given a circular singly linked list having three nodes say one eight and ten whose length is three so friends in our previous tutorial we discussed that we are keeping the track of the last node of the circular singly linked list through the last instance variable so friends below is the algorithm to remove the first node from a circular singly linked list in Java so let's see the demonstration of this algorithm step by step so the first thing we here we do is we check whether the circular singly linked list is empty or not so if you see circular singly linked list has three nodes and length is three therefore it's not empty so the condition and if block comes out to be false moving ahead now in order to remove the first node from a circular singly linked list we know that we are keeping the track of the last node and in the circular singly linked list last node next points to the first node so therefore here we are creating a temp node and we are assigning the value of last dot next to it so this temp will point to the first node because in the circular singly linked list last next points to the first node so it would look something like this moving ahead so here we are providing an if else block and in the if block we are checking that whether last dot next is equal to last or not so this condition comes into picture when the circular singly linked list has only one node left so in this case last next points to the last because the circular singly linked list has only one element where first and the last node is the node itself so here you can see last next is pointing to this first node and therefore it's not equal to last so the condition and if block comes out to be false and the else part will be executed so in the else part the first step we do is we assign the value of temp dot next to last dot next now friends as we want to remove this first node we need to do two things first we need to break this link which is being referred by last dot next to the first node so in order to remove this link what we are doing we are simply assigning the value of temp dot next to last dot next so friends here if you see when we remove this first node from a circular singly linked list the node having the data as 8 becomes the first node because this node is removed and we also know the circular singly linked list has property that last next points to the first node so in this step we are simply assigning the value of temp next to last dot next now why we are doing this step is because once the first node is removed the second node becomes the first node so therefore last dot next should point to the second node so when this step is executed it looks something like this that last dot next is removed and we will assign the value of temp dot next to last dot next so it would look something like this so we are breaking the link of last dot next to the first node and then we are assigning it to the second node because when the first node is removed the second node becomes our new first node moving ahead and after the fls block we simply assign the value of null to temp dot next so friends as we are removing this first node and returning it from the method therefore we need to break this link as well so in order to break this link we are simply assigning null value to temp dot next so it would look something like this moving ahead and then we are decrementing the length by one because we know that we have removed this node from the circular singly linked list so initially the length was three so now it will become two moving ahead and then we are simply returning this temp node because we have already removed it from the circular singly linked list so it would look something like this so friends as soon as we have removed this link we know that we are currently left with two nodes and here you can see the node having the data as eight becomes our new first node and you can also see last next is pointing to this node therefore if we again call this algorithm and we want to remove the first node of a circular singly linked list the algorithm goes as follows so again first we check whether the circular singly linked is empty or not so here you can see circular singly linked list has two nodes therefore it's not empty so the condition in if block comes out to be false and the first step we are simply creating a temp node and assigning the value of last dot next to it so friends here as we track the last node of the circular singly linked list and we want to remove the first node therefore in order to reach the first node what we do we simply do last dot next so this value we are assigning for temp node and it would look something like this so here you can see last dot next is pointing to this first node and we are assigning that value to temp so now temp will point to the node having data as eight moving ahead and then in the if block we are checking that whether last dot next is equal to last or not so currently last dot next is pointing to this first node therefore last dot next is not equal to last so the condition in if block comes out to be false and the else part will be executed so friends in the else part what we are doing we are simply assigning the value of temp dot next to last dot next so in order to remove the node having data as eight we need to first break this link which is being referred by last dot next and we also know that when we remove this particular node from the circular singly linked list we are left with only one node so therefore last dot next should point to that particular node so friends here we are assigning the value of temp dot next to last dot next so we know that we have to remove this link and when we remove this particular node having data as eight we know that now 10 will become our first and the last node both therefore we are simply assigning the value of temp next which is the node having data as 10 to last next so it would look something like this so here you can see the link is removed and then we are assigning temp next to last next so it would look something like this so friends here we have removed the link which is referring to this particular node which we want to remove moving ahead and then we are simply assigning the value of null to temp dot next because as we are returning this complete node we need to break this link so it would look something like this so now temp dot next instead of pointing the node having data as 10 it is now pointing to null and as we have removed this node from the circular singly linked list we will decrement the length so now length is one because we have only one node left and in the final step we are simply returning the temp so it would look something like this so friends after the method is executed we are left with only one node which is the first and the last node both because we are keeping the track of the last node and when the circular singly linked list has only one element left we know that that particular node is the last node and if it travels to its next then it will refer to itself because this is the first node and the last node both and if we call this algorithm again in order to remove this last node from the circular singly linked list so the demonstration of the algorithm is as follow so first we check whether the list is empty or not so currently circular singly linked list has one node therefore it's not empty so the condition in if block comes out to be false and as we want to remove the first node of the circular singly linked list we assign the value of last dot next to temp but here you can see we are only left with one node therefore the last dot next is pointing to that particular node only so after this line gets executed it would look something like this so here you can see temp is pointing to last dot next which is the node itself moving ahead and now we are checking whether last dot next is equal to last or not so as we discussed earlier this condition will come only into picture when we are left with one node so currently here you can see last next is pointing to the last node itself therefore the condition in if block comes out to be true so the if block will be executed so friend in this step we are assigning null to last because in order to remove this node we have to break this link if you break this link then this node will be freed up so when this statement will be executed it would look something like this that now last will point to null and as we have broke this link now this node can be removed easily so after the if statement the last step we do is we simply assign the value of null to temp dot next so currently here you see temp next is pointing to temp itself therefore we need to break this link so here temp next is pointing to null moving ahead and then we are simply decrementing the length by one because we have successfully removed the node so now length becomes zero and as here you can see last is now pointing to null and in the final step we are simply returning the temp so it would look something like this so friends after we remove all the elements now if you again call this algorithm so in the first step we will check whether the circular singly linked is empty or not so here you can see the length is zero and last is pointing to null therefore the circular singly linked list is empty so the condition in if block comes out to be true and as we know that when the circular singly linked list is empty there are no nodes left to be removed so therefore we can throw a no such element exception because there are no nodes left to be removed so friends here we saw the demonstration of the algorithm now let's go to eclipse and see the working code so friends in my previous tutorial we created one class by name circular singly linked list and we implemented the code for the circular singly linked list into that particular class so in order to understand the working of circular singly linked list you can watch my previous tutorials and here you can see we are keeping the track of the last node through the instance variable list node so in this tutorial we will write the code to remove the first node from the circular singly linked list so here let's suppose we give the method name is public list node remove first so friends here i have given the method name is remove first and whose return type is of list node so this method will remove the first node from the circular singly linked list and will return it back to us so in the first step as we saw in the slide we are checking that whether circular singly linked list is empty or not so is empty so if the circular singly linked list is empty we will throw no such element exception and here we provide a string as circular singly linked list is already empty and if the circular singly linked is not empty then the first step we do is we create a temp list node and we'll assign the value of last dot next to it and then we'll provide an if else block so in the if block we provide a condition as that whether last dot next is equal to last or not so if the last dot next is equal to last then we'll simply assign null value to last because we know that this condition comes into picture when there is only one node left into the circular singly linked list and in that case if we want to remove that particular node we need to simply assign the null value to last because this last is referring to that particular node and in the else part we are simply assigning temp next value to last dot next and after if else block we are simply assigning null value to temp next and then we are reducing the length by one and in the final step we are simply returning the temp node so friends this is the algorithm to remove the first node from the circular singly linked list now let's test it's working in the main method so friends in my previous tutorial we discussed how we can insert the node into the circular singly linked list so we inserted three nodes in my previous tutorial with the data as one eight and ten and we also created one display method which could display the entire circular singly linked list so if i run the code now you can see it printed 1 8 and 10 because there are three nodes in the circular singly linked list 1 8 and 10 now let's say we are removing the first node from the circular singly linked list and we are calling the display method again now if i run the code again so here you can see initially it printed 1 8 and 10 because we have three nodes in the circular singly linked list and when we removed the first node so one got removed and it printed 8 and 10 now let's again call remove first method and if i run the code now so you can see it removed 1 and then it removed 8 and it finally printed 10 and if i call again remove first and if i run the code so you can see in the second line it printed nothing because it removed all the nodes from the circular singly linked list and when we call display so here you can see in display method we are initially keeping a condition whether last is equal to null and if last is equal to null then we are simply returning from the method so therefore it printed nothing because when we have removed all the nodes from the circular singly linked list we know that last point to the null and now if i call again remove first and if i run the code so you can see it gave an exception as no such element exception and it printed messages circular singly linked list is already empty so friends in this tutorial we discussed how to remove the first node from the circular singly linked list in java so friends usually we never return the list node from a method and we actually return the data part of the node which you want to remove so here if you are calling remove first so it should remove the node but it should return us back the data part of it so the code is similar what we need to do is we need to change the return type to int because the data is of integer type and here after pointing the first node by going through last dot next we create an integer variable which stores the data of the first node so we simply assign tam dot data to result integer variable so initially we were making tam dot next point to null we were doing this step because we are only returning back the list node so now when we are returning back the data part of it we don't require this step because this node will be automatically garbage collected by java and in the last step we are simply returning back the result so friends initially we removed the first node from the circular singly linked list and we returned it back and after some modification we are returning back the integer value so let's test the working of this method so here we will just print the data which this remove first will return us back so here we will call remove first so here you can see there are three nodes one eight and ten and then we are removing the first node so therefore it should print the value as one because one is the first node of the circular singly linked list and if i run the code so here you can see initially it printed the three nodes with data as one eight and ten and then it removed the first node which is one and it printed it on the console and when we did display again there were two nodes left which is eight and ten so friends in this tutorial we discussed how to remove the first node from the circular singly linked list in java i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to represent a stack in java so friends what is a stack so stack is a linear data structures used for storing the data structure we call it a linear data structure because it can be represented by a linked list or an array in which the nodes are adjacent to each other therefore it's a linear data structure so the basic property of a stack is that it's an ordered list in which we insert and delete the node at one end which is called a stop so here if you see if suppose we are given a list and the first node is pointed by top so we make this list restrictive in nature in the way that we can insert and delete the node at one end which is represented by top and if you see this restrictive property makes it a leafo data structure so what is a leafo data structure the last element inserted is the first one to be deleted so here if you see when we insert a node in the stack at the beginning so that element becomes the first candidate to be deleted because we are only allowed to remove and add the nodes at one end which is represented by the top moving ahead so friends let's see a demo of how stacks looks and how the elements are stored and removed so initially if you see when the stack is empty so that top node points to null and usually we use push and pop operation to add and remove the elements from the stack so suppose if you want to push an element having the data as 10 so it would look something like this and once we push the element into the stack the top node points to that particular node inserted so suppose we want to push now node 15 so when the node is pushed into the stack the top points to that particular node and now suppose we want to push 20 so when the node is inserted top points to the last node inserted if you see the stack is basically a oneway list so here you can think that we are inserting node at the one end and the other end is blocked so there is only one end to push the elements and pop the elements so basically if you see when we insert a 20 the top pointed to that element so now if you want to pop an element we know that there is only one end where this nodes will be removed so as we pop 20 so now top will point to the node just before it and let's say if you want to again pop an element so now top will point to the node just before it and finally if we again pop an element so you can see the 10 got removed and now top points to again null so friend this is how the stack works as you saw it's a last in first out data structure so you saw the element which was inserted the last was the first one to be removed so friends this is how we actually represent the stack i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to implement a stack in java so friends in my previous tutorial i discussed how to represent a stack we saw that it is a leafo data structure which means that element which got inserted last would be the first one to be removed and we also discussed that the elements are inserted and removed at the one end which is represented by top so friends in this tutorial we will discuss how to implement a stack in java we will discuss few of the methods which it implements such as push which actually inserts an element into the stack and we will also discuss pop method which removes the last node inserted from the stack so friends in this tutorial we will implement a stack using a linked list so friends as you know that linked list is represented by a list node where it contains two things one is the data and other is the pointer to the next list node so when we implement a stack last we usually keep two instance variables one is top and another one is length so in our previous tutorial we discussed that this top node is used to insert and remove the elements from the stack and here the instance variable length which represent the size of the stack so friends let's see the demonstration of this algorithm so friends when we initialize a stack first top points to null and the length is zero so here you can see top is pointing to null and as the stack is empty the length is zero now suppose we want to add an element having data as 10 so we'll call this push method and pass the data into it so when we call push and pass data as 10 we know that data is 10 so let's see the execution of this method step by step so in order to push an element into a stack we first create a temporary list node having a data which we have passed as an argument so it would look something like this that we have created a list node having data as 10 and it's next pointing to null and you see the name of the list node is stamp and it's pointing to that particular node moving ahead now in order to insert this node into the stack the first step we do is we assign the value of top to temp.next so friends here you see temp points to this node and its next points to null and when the stack is empty we know the top is also pointing to null so in the first step we are simply assigning a null value to temp next so it would look something like this so after this step temp next is pointing to null and top is also pointing to null moving ahead and then we'll assign the value of temp to top so here you see top points to null and when we'll assign the value of temp so temp is pointing to this node so after this step top will point to the temporary node so it would look something like this and in the final step as we know that we have inserted this temporary node will increment the length of the stack by one so here you see when this method gets executed the stack looks something like this the top is pointing to a node having the data which we passed into the push method and its next is pointing to null and therefore the stack has one element therefore the length is one now suppose we again call push method and pass data as 15 so let's see execution of this method step by step when length is one and top is already pointing to a node so here when we have called push 15 so the data is 15 so here we'll create a temporary node and this temporary node will hold the data which we passed into this push method so here you see we have created this temporary node having data as 15 and its next pointing to null moving ahead so friends the next step is we'll assign the value of top to temp.next so currently temp.next is pointing to null so in order to insert this node into the stack we are assigning the value of top to temp.next so we are doing something like this we are removing this link and we are pointing it to top so in this step we are assigning the value of top to temp.next so now temp.next is pointing to top moving ahead so as this node is now inserted now top should point to this node so therefore we are assigning the value of temp to top so it would look something like this so now top is pointing to the temporary node moving ahead and we'll simply increment the length by one because now the stack has two elements so friends after this method gets executed the stack looks something like this so here you see the top is pointing to the node which we inserted last so friends this is how we insert an element into the stack now let's see the pop operation in which we remove the last inserted element so so we'll take the previous example we know that first we inserted 10 and then we inserted 15 so in the pop the last element inserted will be the first one to be removed so let's see how this pop method works so in order to remove the last inserted node so what we'll do we'll simply capture top.data into integer variable by name result so we are storing the data inside this node into the integer variable result moving ahead now as we want to remove this last inserted node we need to break this link so once this node is removed top should point to its next element so for that we'll simply assign top.next value to top so it would look something like this and as this node is not referred by top it would be garbage collected moving ahead now we have removed the node from the stack so we need to decrement the length by one so now length becomes one so we'll simply return the value 15 from this method now you see the stack contains only one element and the length is one now if we again call the pop method so first we'll store the data inside this list node which is being pointed by the top top so we are simply assigning top.data into an integer variable result and as we need to remove this node we'll simply break this link and assign top to its next so we are simply assigning top.next value to top so top.next is pointing to null so we are simply assigning a null value to top so it would look something like this and as this list node is not referred by top so it would be removed we'll decrement the length by one because the node is now removed from the stack and finally we'll return the result so friends here you can see when the stack is empty the length is zero and top points to null so friends here we saw the demonstration of how to implement a stack in java so let's go to eclipse and see the working code so friends in order to implement a stack in java i'll just created one class by name stack so in this class we will implement the stack functionality so as we saw in the slide that stack contains few instance variables so we'll create one instance variable of type list node by name top so private list node top and we'll also create an integer variable by name length which will store the size of the stack so try weight and length so friends as you can see we are implementing a stack using a linked list which is represented by list node so we'll create a inner class of type list node so friends in our previous tutorials we discussed how we can represent a list node in java so a list node contains two things one is the data so private and data and other is pointer to next list node so private list node next we'll also create one constructor so this constructor takes the data part so friends here we are implementing the stack using a linked list so we have created a list node now once we initialize the stack we know that top points to null and length is zero so we'll create one constructor for this stack class public stack and here we'll assign a null value to top and length as zero friends we will also create one method by name length which will return us back the length of the stack so public and length return length we'll create one boolean method by name is empty which will return us a boolean value whether the stack is empty or not so public boolean is empty so here we'll simply return a boolean value which will represent whether the stack is empty or not so in order to know that our stack is empty we'll simply check whether length is zero or not so if the length is zero we'll simply return true that stack is empty and if the length is not zero then we'll simply return a value of false that stack is not empty so we'll simply return length equals zero moving ahead so friends first we'll code the push method so public void push and in this push method we'll pass the data so this data will be inserted into the stack so in order to insert this data into the stack we'll first create a list node and we'll give name as temp and we'll create this list node and inside the constructor we'll pass the data moving ahead and on the next step we'll simply assign value of top to temp.next and then we'll simply assign the value of temp to top so top equal temp and finally as the data is inserted we'll increment the length by one so friend this is the push method now we'll implement the pop method so public int pop so friend this method will return us back the value of last inserted node into the stack so here first we'll put an if check and the check would be is empty so friends if suppose the stack is empty then we can't pop an element from the stack so if this stack is empty we'll throw an exception we'll throw empty stack exception because we know that stack is empty and we cannot pop an element from an empty stack so friends if the stack is not empty then the first step we'll do we'll create an integer variable by name result and we'll assign the value of data stored in that top list node so we'll do top.data and as we have stored the data inside the top you can simply traverse to next node by assigning top.next value to top and finally the top has moved to its next node so that node will be garbage collected and we can simply reduce the length of the stack by one and finally will return the result so friend this is how we pop an element from a stack the stack also contains one more method by name peak so what this peak method does is it simply return us back the value which top holds so it is nothing but returning a value of a last inserted node into the stack so we'll create a method by name peak so public int peak so we'll also provide a if check here that if the stack is empty we will throw empty stack exception and if the stack is not empty then we can return top.data because we know that top points to the last inserted node into the stack and if we do top.data we'll get the value stored in that particular list node so friend this is how we implement a stack in java now let's see the demonstration of these methods so in the main method first we'll create a stack so when we do new stack we know that top is pointing to null and length is zero so let's say we push few elements into the stack so stack.push and let's say we give data as 10 and 15 and 20 so friends here in stack we have pushed 10 15 and 20 and we know that initially top pointed to null and as we inserted the data 10 it pointed to 10 then as we pushed few nodes at 10 15 and 20 so we know that top points should last inserted node so so if we print tag.peak so if we are printing the peak value of the stack we know that it prints the value of last inserted node so if i run the program you see it prints 20 because 20 is the element which we last inserted and suppose i want to pop an element so so i will do stack.pop so we know the top points to the last inserted node so when we do a pop 20 will be removed and if i print stack.peak and run the code so you can see it prints 15 the next time when we do stack.pop the last inserted element is the first element to be removed so the 20 is removed and stack contains 10 and 15 and 15 is at the peak position so it printed 15 and if i simply copy paste this and run the code so you can see the third time it printed 10 because we removed 15 as well so here if you see we have implemented push and pop in such a way that it is resembling a lethal data structure which is the element inserted last is the first to be removed so friends in this tutorial we saw how we can implement a stack in java i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello everyone so in this video we are going to discuss that how we can implement a stack with an array in our previous video we saw how we can represent a stack and we also saw that how we can implement a stack using a linked list so in this video we will see that how we can implement a stack with an array so friends before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so in our previous videos we saw that stack is a lethal data structure which means last in first out now if this is a stack then here in this data structure there is only one end where the elements are inserted via push method and from the same end the elements are popped out using pop method so therefore the element which is last inserted it's first one to be removed so for example if we insert three then two and then one so first we inserted three then we inserted two and then we inserted one so the last element which got inserted was one so this would become the first element to be popped out so in this video we will see the implementation of push pop and peek method with the help of an array and we will see that how we can implement the stack using an array so if we are implementing a stack using an array we need to provide the capacity to it so as the internal data structure is array this capacity will tell that we need an array of three elements which also signifies its stack at the start can only hold three elements so internally it would look something like this that an array will be created of three elements having a default value of zero so currently it's an int array therefore the default values are zero if it is an integer array then the default values would be null in our previous videos we also discussed that values are inserted into the stack using the top variable so here top is an integer variable which will traverse this array and basically insert the elements based on the indexes so at the start top is actually pointing to minus one it means the stack is empty so now let's see how we can perform push and pop operation so let's suppose we want to push element eight so usually what happens is we can insert eight into this array at 0th index first index and second index now at the start top is pointing to minus one now whenever we do push we first increment top by one so currently value of top is minus one when we increment it by one it becomes zero and as it is pointing to 0th index what we do is we simply assign value eight like this so eight comes here and if we see the visual representation of stack it looks something like this that this is a stack the element is pushed into the stack and top is pointing to this element now similarly let's say if you push four so the first thing we do is we increment top by one so top becomes one and four is inserted at index one like this so four comes here and here it looks something like this that four is pushed into the stack and now top is pointing to four so basically when we perform push we do top plus plus and then we perform array of top and we assign the value which is our data which we have passed into our push method so we perform these two steps in the push operation now let's say if we want to push three so first we increment top it becomes two and at array of two we assign three so three comes here and in the stack it looks something like this the three is pushed and top is pointing to this three now let's say if we push one more element with the data as one so here you can see that initially when we created stack we provided a capacity of three it means the stack can hold only three elements now if we want to insert one more element we know that there is no more place into the stack so usually before these two steps we perform a check that whether stack is full or not so if stack is full we throw an exception so usually how we check whether stack is full or not we do array dot length and we compare it with the size of the stack so there is a method size now here if you see array dot length will be three and if we calculate the size of the stack the size of the stack is nothing but number of elements into the stack so we know that number of elements are three and array dot length is also three so how we evaluate this size function is whatever the value is hold by top which is two we do something like top plus one so usually this size method will return top plus one so here value of top is two if we do plus one we get three so array dot length is three and size is also three so it means the stack is full and we can't insert more elements to it so we throw an exception now let's suppose our stack has three elements eight four three and now we want to pop it so we know that we pushed elements like this and we know that the last inserted element will be first to be removed via pop method so when the pop method is called to whichever index top is pointing that element was last inserted so now this will be the first one to be removed so we store this value into a temporary variable and at the end we return this value and what we do is we simply decrement top so we do top minus minus so it looks something like this that initial value of top was two now it becomes one now here either we can provide a value zero or we can left this element as it is because whatever the insertion and deletion we are doing into this array is based on top so either we assign this value to zero or if it is an integer array then we can also assign a value of null to it and here in the stack it looks like three is popped out and now top is pointing to four now let's say if we again call pop so now top is pointing to index one and the value is four so now this four will be removed so we first store this four into a temporary variable and then we simply decrement top so top comes here and it looks like four is popped out and top is pointing to eight and similarly if we call pop again then eight will be removed and we will decrement top so now top will become minus one and eight will be popped out so here you can see if the value of top is less than zero it means stack is empty and if we again call pop method then we also check at the start whether value of top is less than zero or not if it is less than zero then we throw an exception that stack is empty and there are no more elements to be popped out so now let's move ahead and see the implementation of stack using an array step by step so this is the code we have a class stack and as we discussed we have two variables top and the integer array and via this integer array we are implementing stack we have a constructor which takes in a capacity and this capacity is assigned to initialize our integer array and usually if we don't provide any value to our stack constructor then the by default capacity is 10 so let's see the demonstration of this algorithm step by step so we will create a new stack we pass in the value as three which would be our capacity so the constructor will be called capacity is three and we know that at the start when the stack is empty top is pointing to minus one so value of top is minus one and we will initialize the array with our capacity of three so it looks something like this that it has capacity to hold three elements with index zero one and two and if we visualize the stack it looks something like this so when we initialize stack at the start the stack looks something like this now let's discuss the push method so let's suppose we call push method and we need to push a value eight so the data is eight which we need to push into the stack now before pushing eight into the stack we first check whether our stack is full or not so by full we mean that internally it's an array and let's say the capacity of array is three so we check whether this array already contains three elements or not because if the array has three elements then we can't push it into the array so how we check whether stack is full or not we call its full method now its full method returns a boolean value which is true or false which says that the stack is full or not and inside this method how we check whether stack is full or not we simply compare array's length which is three so array dot length is three because the array contains the capacity of holding three elements so array dot length is three and in the implementation of stack we also provide the size method now this size method will actually give us an information that how many elements are currently into the stack so when we will call the size method it actually returns an integer value and what we actually return is top plus one we are returning top plus one because let's suppose we have filled all the elements into the array so top will be here and if top is at this index so the value of top will be two but if we see the size of the stack is it is actually holding three elements so we simply return top plus one which actually tells what is the size of the stack so we simply return top plus one which says that how many elements are currently into the stack so currently value of top is minus one if we add plus one the value is zero it means currently in the stack there are no elements so it returns zero so three is not equal to zero it means this condition will be false and false will be written from this method so the condition in if block comes out to be false that stack is not full so now we can push this data into the stack now the first thing we do is as top is pointing to minus one and we are inserting the elements into the stack using an array so the first place to insert is at zero index so at the start first we will increment top so value of top will become zero top will point to the zeroth index and then using array of top we will assign the data so here array of zero we will assign a value eight so eight will come here like this and if we visualize the stack it looks that eight is pushed into the stack and top is pointing to it now let's say if you again push a value four so the data is four we check whether stack is full or not so array dot length is three and then we will evaluate the size and currently we know that stack has one element which is eight so when we will do top plus one value of top is zero so zero plus one will give one it states that the size of the stack currently is one because there is one element so three is not equal to one so false value will be written from here and the if block won't get executed because is full will return false value now we will increment top because the next value we need to insert is here current value of top is zero so when we will increment it will become one and now to array of top we assign the data so array of one we assign the value as four so four will come here and if we visualize the stack it would look something like this that four is pushed into the stack and top is pointing to four now now let's say if you want to push a value three so data is three we check whether stack is full or not so array dot length is three and size of the stack is two which is top plus one so value of top is one one plus one is two which states that stack has two elements so this method will return two and three is not equal to two so this method will return a false value so this if block won't get execute now the next value should come here because this space is occupied so we increment top top becomes two and at the second index we insert data which is three so three comes here so if we visualize stack it looks that three is pushed like this and top is pointing to it so now let's push one more element with the data as one so the push method will be called with the data as one now here you can see the initial capacity of the array was three and stack has three elements it means the array is completely occupied so when we will call is full method to check whether stack is full or not array dot length is three and when we will call size method we know that current size of the stack is three it simply returns top plus one so value of top is two so it returns two plus one which is three so the size method will return three and here we are comparing three with three so via this comparison we come to know that the stack has three elements and the capacity of our array is also three it means that stack is full so from is full method true will be written which signifies that stack is full so we can't push one into the stack and this if block will be executed so we simply throw an exception that stack is full like this and we can't push one into the stack so now let's look into the implementation of pop method now let's suppose our current stack has three values eight four three the demonstration we saw in our previous slide so value of top is two so when we will call pop method usually with the help of top we actually push into the array and with the help of top we actually pop the elements from the array so in this stack it looks like that we are inserting element from one end and we are removing it from the same end and whatever the element was inserted last will be the first one to be removed so basically top is actually helping us in maintaining leafo property that the element inserted last is first one to be removed so three was inserted last because top is pointing to three so when we will call pop the first thing we check is whether stack is empty or not because if stack is empty there are no elements which we can pop so how we check whether stack is empty or not we call is empty method and we simply check whether top is less than zero or not so when we saw that initially when stop is pointing to minus one the stack was empty the array actually had three values to be inserted because the capacity of array was three so currently value of top is two and it is not less than zero so therefore is empty method will return false let stack is not empty so this block won't get executed and now as we need to pop three from the stack because three was the last element inserted into the stack what we do is we create a temporary variable by name result and we assign value of array top which means that we are assigning it a value which is being hold by second index because value of top is two so we are assigning value three to result and after assigning this value now we can simply decrement top so top becomes one and it looks like that three is popped out from the stack and top is pointing to the element previous to it which is four and at the end we simply return result so value three is written from this method now if we again call pop so now four will be removed we check whether stack is empty or not so value of top is one one is not less than zero so the stack is not empty so a false value will be returned and this if block won't get executed first we will hold the value from the array index one because value of top is one so four is assigned to result then we will decrement top and top becomes zero so it looks like this and if we visualize the stack it looks like four is popped out and top is pointing to eight now which is index zero and we simply return value four that four is popped out from the stack let's say if we again call pop now eight will be removed we check whether stack is empty or not so value of top is zero zero is not less than zero so false value will be returned so this if block won't get executed we first hold the value of the zero index which is eight because top is pointing to zero so result will have value eight we decrement top, top becomes minus one like this and it looks like eight is popped out from the stack and top is actually pointing to minus one and simply at the end we return result as eight that eight is popped out from the stack now here stack is empty so if we again call pop method we first check whether stack is empty or not so here you can see value of top is minus one so top is actually less than zero which signifies that stack is empty so true will be returned and this if block will get executed and we simply throw a runtime exception that stack is empty which signifies that there are no more elements to be popped from the stack so we actually saw pop method which actually removed the element from the stack but there is one more method peak now what this method does is whatever the values hold by top which actually is our last element inserted into the stack so if we don't want to remove this element and we just want to see what is the peak element or what is the last element inserted into the stack we usually call peak method so when we call stack.peak so let's say current condition of the stack is like this that there are two elements eight and four and four was last element inserted into the stack so when we will call peak the first thing we check whether stack is empty or not so value of top is one and one is not less than zero so false will be returned that stack has two elements so this if block won't get execute so here instead of removing the element from the stack we are just returning the value stored at the top index which is at index one and the value is four so this peak method will give us information that which element was inserted last so value four will be returned from this peak method and the element will stay in the stack it won't get removed it is just giving us an information that which is the last element inserted into the stack which is our peak element so friend this was all about implementation of stack using an array i hope you must have liked this video thanks have a nice day hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss how to reverse a string using a stack in java so friends below you can see an algorithm which would reverse a string using a stack in java so friends let's see the demonstration of this algorithm step by step so friends let's suppose we are given a string whose value is a b c d so here we will see the demonstration of the algorithm which would reverse this string using a stack in java so in the first step what we do is we actually create a stack now this stack will hold only the character values so an empty stack is created moving ahead now as we are given with this string a b c d we will first convert it into an character array so in the string class there is a method 2 char array which returns back a character array so it would look something like this that we are now having a character array whose length is 4 and whose values are a b c and d moving ahead so friends here we know that a stack is a leafo data structure which means last in first out and we also discussed in our previous tutorial and how we can represent a stack and we also discussed the push and the pop methods of the stack so the general idea behind the working of stack is the element which goes into the stack last becomes the first one to be removed so in this step what we are actually doing we are providing a for loop which will iterate over each and every character of this char array and then it will simply push it into the stack so in the first iteration the value of c will become a and then we'll simply push the character a into the stack so it would look something like this that now a is into the stack and similarly now c becomes b we will push b into the stack moving ahead now c becomes the character c and we'll simply push the c into the stack and finally c becomes the last value which is d and we will push it into the stack so now as you traverse each and every character of this char array there are no more elements left to be traversed so friends here now in the stack we have four elements the first element which we inserted was a then we inserted b then we inserted c and the last element we inserted is the d so friends now we'll again provide a for loop which will iterate from the value i equal to 0 to a value lesser than string dot length so initially value of i is 0 and here we can see that the length of the string is 4 so currently i is less than 4 so now what we do is we'll pop the elements from the stack and then we'll simply assign it to the respective index from 0 to 3 so friends as soon as we call stack.pop the element which is last inserted which is nothing but d will be popped out so it would look something like this so now d is popped out and the value will be assigned to the char array at index 0 which is this position so now it becomes d moving ahead now we'll increment the i so i becomes 1 and still the value of i is less than 4 now we'll again pop the element from the stack which is nothing but value c and we'll assign it to the char array at index 1 so the value index 1 becomes c moving ahead now value of i becomes 2 2 is less than 4 we now pop an element from the stack and this value we will assign to the char array at index 2 so now at index 2 we will assign the value b moving ahead we'll now increment the i so i becomes 3 and 3 is less than 4 so we'll pop an element from the stack so now value a is popped out and it will be assigned to this char array at index 3 because value of i is 3 so value of this char array at index 3 becomes a moving ahead now i becomes 4 and so 4 is not less than 4 so therefore the condition in for loop comes out to be false and also friends here you can see that using this stack we have actually reversed this char array and the last step will simply return this string by passing in the char array so now it will return a string having a value as dcba so friends in this tutorial we saw how we can reverse a string using a stack in java now let's go to eclipse and see the working of this code so friends in our previous tutorial we actually saw the demonstration of the algorithm to reverse a string using a stack now in this tutorial we'll actually code the algorithm and test the working of it so here i have created one class by name string reverse and inside this class i will create one static method which will return a string and whose name would be reverse now this reverse method will take in a string which we actually want to reverse so friends in our previous tutorial we discussed how we can reverse a string using a stack so here we will create an instance of stack and this stack will hold the character type elements will name it as stack and we will import it from java.util package in the next step what we do is as we are given this string we'll first convert it into character array we'll give name as char and we'll call to char array method of string class which will actually convert this string into an character array and we'll assign it to this char array now we'll simply iterate over this char array one by one and then we'll simply push the character into the stack so stack dot push so whatever the string we have passed this for loop will iterate each and every character of this string and it will push it onto the stack so in the next step we'll again create a for loop now this for loop will iterate from value i equal to zero to i less than string's length and inside this for loop what we'll simply do is we will pop the elements from stack and we will assign it to char's array at the respective index from zero to string length minus one so friends as we know that stack is a leafo data structure so the element which is inserted last will be the first to be popped out so as we have inserted all the character elements one by one into the stack so now when we'll pop it out it will be coming out in the reverse order and then we are simply storing it into the char array and finally we'll simply return a new string by providing this char array into its constructor so after this method gets executed whatever the string we have passed the character inside this string gets reversed so in the main method let's test the working of this code so first we'll create a string we'll give it a value as abcd which we actually discussed in the slide and then we'll simply print this string on the console so this would be before reverse and then we'll print the string after reverse so we'll simply call the reverse method and pass the string to it so whatever the value will be returned from this reverse method it will be printed on the console so let's run this code so friends here you can see before reversing the string it was abcd and after reversing the string it became dcda so friend in this tutorial we saw the algorithm to reverse a string using a stack in java i hope you like this video thanks have a nice day hello everyone so in this video we are going to discuss a problem next greater element so let's see what this problem is and how to solve this so in this problem we are given an array of integers and for each element in the array we need to find its next greater element in that array so the next greater element is the first element towards right which is greater than the current element so let's see it by an example let's suppose we are given an array of integers 4 7 3 4 8 1 now for each element we need to find its next greater element and the next greater element is the first element towards its right which is greater than the current element so here for element 4 it will see in the right direction and it will see which is the first element in right which is greater than 4 so here it sees that 7 is the first greater element than 4 so in the output array we are storing 7 here for index 0 for index 1 we have 7 so 7 sees in this direction and it checks which is the first greater element whose value is greater than 7 so 3 is not greater 4 is not greater but 8 is greater so we store 8 here now for 3 it will look in this direction and it will see that 4 is greater than 3 and it's the first greater element so we simply store 4 here here we are storing it in the respect to indexes now 4 will see in this direction and it will see that 8 is the first element which is greater than 4 so we store 8 here 8 will see in this direction and here 8 will find that no element is greater than 8 in the remaining array so we simply store minus 1 and similarly with 1 there are no elements left so therefore we directly store minus 1 so here for each index we are taking that particular value and we are finding the first element in the right direction which is greater than the current element so we are looking for the first element towards right so for example so for element 4 the first element which is greater than 4 is 7 8 is also greater than 4 but the first element is 7 so we store 7 here which corresponds to this particular index and similarly for 3 4 is the first element which is greater than 3 8 is also greater but 4 is the first greater element so the problem is actually to find the next greater element in the array for any particular index and that should be the first element towards right which is greater than the current element so let's move ahead and see the demonstration of the algorithm step by step so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update and i would request you to watch this video till the end so here is the algorithm where the method name is next greater element it takes in an array and it returns an array so the array which is written stores the next greater element of each and every element in the array so let's say we call the next greater element we pass in the array and let's say we pass the array having six elements 4 7 3 4 8 1 not the first step we create the result array we need to return this result array so we are creating a new result array of the same length as of the given array so we call new int we pass array dot length so the result array also has six elements so friends in order to solve this problem of finding the next greater element towards right we take the help of stack data structure so we initialize the stack like this now this is the leafo data structure the element inserted last will be the first one to be removed so we will see that how we can use the stack data structure and find the next greater element for each and every element in the array so friends in this problem we need to iterate each and every element but we will iterate the array from the last index and go till the zeroth index so here we are traversing the array in this direction because this direction will help us in finding out the next greater element towards right so at the start the value of i will be array dot length minus one so array dot length is six because there are six elements if we do minus one we are starting from the fifth index so i will start from the fifth index so friends here you can see that as we are starting from the last index there is no greater element towards its right so therefore we first check whether our stack is empty or not because in the stack we will store some elements which will figure out that which is the greater element towards the right and which is the first greater element towards the right so at the first step we are checking whether stack is empty or not so you will understand this step more clear when we reach to the middle of the array so at the start stack is empty so this condition comes out to be false because stack is empty and then we provide a fls we check whether stack is empty so stack is empty which signifies that there is no greater element for this index to its right so for one there is no element towards its right which is greater than one so we directly store minus one into the result array at index i which is this index so minus one comes here and at the end we just push one onto the stack so why we are pushing one onto the stack is because let's say at index four there could have been value as zero so for zero one would have been its next greater element so we can't discard this one directly we need to push it on the stack for the rest of the elements to compare so we simply push array of i which is one into the stack so one comes into the stack we will decrement i so i becomes four four is greater than equal to zero so this condition is true now here we are checking whether stack is empty or not so stack is not empty so this condition comes out to be true so if stack is not empty that on the stack there could be an element which is greater than the current element we will see how so if this condition is true in the block we are providing a while loop and in the while loop we are providing two conditions with an end that stack should not be empty which is true so here stack.peak is one and the current element at array of i is eight so one is less than equal to eight and stack is not empty so therefore this condition comes out to be true so the while loop will execute so here this condition signifies that for eight eight will see that there is no element in the stack which is greater than eight so therefore it simply removes one from the stack it does stack.pop and why does stack.pop because it sees that in the stack whichever element is present it is actually lesser than the current element which is eight so it discards one because for the rest of the array eight would be the next greater element but one cannot be the next greater element so let's say four four seven is the next greater element for seven eight could be the next greater element but for any of the element one cannot be the next greater element because we have found one element which is actually greater than one which is eight so therefore it discards the element one by popping it out so one gets popped out as it's a while loop it again checks whether stack is empty or not so stack is empty so this condition comes out to be false and this while loop will terminate and for element eight we first check whether stack is empty so here stack is empty which signifies for the value eight there is no next greater element towards its right so therefore this condition is true and into the result array at index i we store minus one because for eight there is no greater element towards its right and then we will simply push eight onto the stack because eight could be the next greater element for the remaining array we will decrement i i becomes three three is greater than equal to zero so for element at index three which is four we check that whether stack is empty or not so if stack is not empty it means there could be a chance that the next element will lie in the stack so this condition comes out to be true stack is not empty and then we will provide a while loop we first check whether stack is empty or not so stack is not empty so this condition is true and we will do stack dot dot we will do stack dot p which will return us the value eight because eight is the topmost element so stack dot p returns eight we will check whether it is less than or equal to the current element which is four so this condition comes out to be false because eight is not less than equal to four so this file loop will terminate so if the while loop terminates at this condition it signifies that there is one element on the stack left and stack is not empty so this if condition also comes out to be false because there is element on the stack which means that four was not able to pop out eight and it was able to find an element which is the first greater element towards its right so whatever is at the top of the stack we will directly store into the result array so at the index of result array we will store stack dot p which is eight so eight comes here directly so for value four eight is the first next greater element towards its right moving ahead we will keep eight as it is on the stack we will not touch it because four was not able to remove it because if we remove it then for seven we will not able to find which is the first next greater element towards its right so we will keep eight on the stack and we will push four on the stack like this and why we are putting four on the stack is because let's say for three though eight is the next greater element towards its right but four is the first next greater element towards its right so therefore we need to still put four on the stack and we don't have to discard it we will decrement i, i becomes two, two is greater than equal to zero we check whether stack is empty or not so stack is not empty so this condition comes out to be true we provide a while loop the first condition is stack should not be empty so stack is not empty so this condition is true and stack.p which is four we will check whether four is less than equal to the current element which is three so this condition comes out to be false so therefore this while loop will terminate so which signifies that three could not pop four out of the stack which signifies that if stack is not empty then whatever is at the top will be the first next greater element for this index which is two so we directly store stack.peak at index two which is four so as three was not able to pop four out so this is the topmost element if we do stack.peak we will get four and we directly store four here so for three four is the first greater element towards its right and then we push three on the stack because let's say if instead of seven if the value would have been two so for two three would have been the first greater element towards its right so we can't discard three so we simply push it on the stack we'll decrement i, i becomes one one is greater than or equal to zero stack is not empty in the while loop the first condition is stack is not empty which is true stack has three elements stack.peak which is three we check whether it is less than or equal to the current element seven so yes this condition is also true so what seven is actually doing it is actually popping out the elements which are lesser than it so that it reaches to an element which is actually greater than it so this while loop does that this both condition comes out to be true so first it pops out three because three is lesser than seven and for seven it could not be the first greater element towards its right so it pops it out stack is not empty and stack.peak which is four now is less than equal to seven so this condition is also true so for seven it will pop four also out of the stack because four cannot be the next greater element of seven towards its right so four gets popped out stack is still not empty and stack.peak which is eight is less than equal to seven so this condition is false now because eight is greater than seven so this while loop will terminate leaving only eight into the stack and if there is some element on the stack, stack is still not empty which means that for index one and element seven we have found one next greater element towards its right which is stack.p which is eight so we directly put eight here into the result array like this using this assignment operator so friends here we saw that seven actually popped out three and four from the stack because if we go beyond seven whatever element we encounter for those elements seven could be the next greater element three and four cannot be the next greater element eight could be a possibility which is already in the stack which we have stored it here but three and four cannot be the possibility for the remaining elements towards its left so we directly discard three and four and we simply push seven on the stack because seven can be a possibility for the remaining elements that it can become the next greater element for the remaining elements we will decrement i, i becomes zero and zero is equal to zero so this condition is still true stack is not empty so this condition is true we provide a while loop stack is not empty and stack.p which is seven is less than equal to four so this condition is false because seven is not less than or equal to four so this while loop will terminate and if stack would have been empty it means for four there would have been no element on its right which would have been greater than four but stack has two elements so therefore whichever element is on the top which is seven we will simply assign it to the result array at the higher index so for four seven is the first greater element towards its right eight is also greater than four but seven is the first element which this stack help us to figure out so we directly assign seven here and then we simply push four on the stack as there are no more elements left for i to travel but still we push four on the stack we will decrement i so when we will decrement i i will become minus one it will reach here so minus one is not greater than or equal to zero so this for loop will terminate because this condition comes out to be false and at the end we will simply return the result array so friends here you saw that how we can solve the next greater element problem using a stack now as stack is last in first out it actually help us in finding out the next greater element towards right for any particular index so friends i hope you must have liked this video in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update also please like this video and share it with your friends and colleagues thanks have a nice day hello everyone so in this video we are going to discuss a problem of valid parenthesis so in this problem we are given a string as now this string only contains the brackets which are opening and closing brackets so we can have round square and curly brackets we need to determine whether the input string is valid or not so an input string is valid if open brackets must be closed by same type of brackets open brackets must be closed in correct order so let's say we are given with an input string like this and we need to find out whether this input string is valid or not so the input string is valid if open brackets must be closed by same type of brackets so here you can see this is opening curly bracket this is opening round bracket open brackets must be closed in correct order so here we have opening curly bracket and then we have opening round bracket so if we go ahead we have a closing round bracket so this much part is valid because this opening round bracket is closed by same type of bracket and this is also in correct order and at the end we have one curly bracket so this opening curly bracket is being closed by the same type of bracket and dead to in proper order so this complete string is valid now let's say we are given an input string like this this is opening curly bracket but it is closed by a different type of bracket which is the square bracket so this is not a valid string now let's say if you have input string like this we have a opening curly bracket it is followed by opening round bracket and then we have a closing round bracket so this much part is valid because this closing round bracket is being matched with the opening round bracket but after that we don't have any character so we are left with one opening curly bracket it doesn't have its closing bracket of same type so therefore this is an invalid string now let's say if we have string like this so at the start only we have a closing curly bracket so therefore we can directly say that it's an invalid string because our input string is valid where open brackets must be closed by the same type of brackets and these open bracket must be in correct order so this is an invalid because at the start only we have a closing curly bracket so how we can solve this problem is we can use a stack data structure now let's see the demonstration of this algorithm step by step using a stack so friends before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here we have a method is valid which takes the input string and returns a boolean value true or false which states that this string is valid or not so first we will see the negative scenarios where we are actually returning false one is here here and here if stack is not empty so if we call is valid method with passing in one closing curly bracket followed by a opening curly bracket so s will be this string we will first create a stack so here stack is leafo data structure where element which goes last will be the first one to be removed so you can watch my stack tutorial to understand more about this data structure so here the main idea is to iterate each and every character of this string so first we'll convert this string into character array and then we will iterate it through the variable c so when we will call two char array method we get something like this we get a character array where each character is stored at a particular index now this for loop will start with the closing curly bracket so c becomes the closing curly bracket so here as we know that the string is valid we must have opening brackets at the beginning and whenever we encounter any opening brackets we simply push it on the stack so currently here you can see that we have a closing curly bracket so this if block conditions comes out to be false because c is not equal to any of this opening bracket so the else part will be executed now in the else part the first thing we simply check is whether stack is empty or not so why we are checking whether stack is empty because it simply signifies that there is no character in the stack which is opening bracket and we have reached to the else block and we have found that stack is empty it means whatever value c will have it must be the closing bracket so therefore we can directly return false and which is actually true because c value is closing curly bracket because if we have opening bracket then that must be pushed on the stack and stack must have some elements in it but if c is not equal to the opening bracket so in the else part the first step we check is whether stack is empty or not because if stack is empty then we have one closing bracket and there is no element on the stack which we can pop out and match it with the closing bracket so we can return false you can understand more on this in our upcoming examples so currently we return false because the input string is not valid it is actually getting started from the closing bracket now let's say if we are given with this string so as becomes the opening curly bracket and a closing square bracket we create the stack we create the char array so for the first iteration c value will be the opening curly bracket so here you can see that for the first step till zero index the condition holds good because we have a opening bracket so c is actually equal to a opening curly bracket so we simply push c on the stack so this opening curly bracket comes on the stack now c moves to the next character which is closing square bracket c is not equal to any of these opening brackets so the else part will be executed now stack is not empty so this condition comes out to be false and the else part will be executed so friends the main idea behind pushing the opening bracket onto the stack is in the else part we will first pick the topmost element so when we will call stack.peak whichever element is on the top of the stack that value will be returned from this method so currently top will point to the opening curly bracket like this and why we are actually looking into the topmost element on the stack is because we need to check whether this opening bracket is actually close by the same type of bracket or not so here you can see now we provide three conditions here separated by a or so if any of the condition comes out to be true then this if block will be executed so here simply the condition is if on the top of the stack we have a round bracket and the currently visiting element which is c is closing round bracket it means it's a match and similarly with the other two brackets so therefore we are looking for the topmost element in the stack because we have to match the brackets of the same type in correct order so here you can see top is equal to the opening curly bracket but c is equal to closing square bracket so therefore no condition comes out to be true so this overall if condition comes out to be false so the else part will be executed and we can return false because for this opening curly bracket the element which is next to it is closing square bracket which makes it a invalid string so therefore we can return false directly moving ahead let's say we are given with this string so s holds this string we will create a stack we will generate the char array like this so the first c value will be the opening curly bracket in the first if condition we are checking that if we have a opening bracket then we simply push it on the stack so c is actually equal to the opening curly bracket so we push it on the stack now we have pushed something on the stack so in the next iteration c will become the opening round bracket now c is equal to opening round bracket so we know that we need to push it on the stack so this opening round bracket comes like this now c moves to the third character which is the closing round bracket so c is not equal to any of the opening bracket so this if condition comes out to be false in the else part we first check whether stack is empty or not so if stack is empty it means we are straight away getting one closing bracket and it is not having any of its opening bracket before that so we can directly return false if the stack is empty so currently on the stack we have two elements so the else part will be executed first we will check out for the top element by calling stack.peak so if we see the top of the stack we will have a opening round bracket so top will be equal to opening round bracket now here you can see that top is equal to opening round bracket and c is equal to closing round bracket so therefore it's a match here you can see it's a match so the element on the stack which is top is this and the current element c is this so it means we have found one matching brackets which are opening and closing and are in correct order so therefore the first if condition comes out to be true and the overall if condition comes out to be true because we have a or operator here so it means we have found one match which is the correct match so we can simply pop this element out because it's matching pair we have already found so it gets popped out so now here you can see that we have visited all the elements of this char array so this for loop will terminate and here you can see at the end what we return is we check whether if stack is empty or not because if stack is empty it means we have found all the proper matching brackets and the string is valid but here you can see in the stack we are left with one opening curly bracket for which we didn't find its same type of bracket so therefore stack is not empty so stack.empty returns false so we can directly return false stating that this input string is not valid now here we will see one more example which is a proper valid string so as becomes this we create a stack we create the char array like this and in the for loop c will point to the opening curly bracket first so this condition is true so we can push c on the stack so this opening curly bracket is on the stack the next element is the opening round bracket so c becomes opening round bracket c is equal to opening round bracket so we can push it on the stack like this now we'll move to the next character so c becomes the closing round bracket so this overall condition is false because c is not equal to any of the opening bracket stack is not empty so this condition comes out to be false now first we will see the topmost element on the stack by calling stack.peak so top will become equal to closing round bracket like this and then we will provide a if condition we will check whether top is equal to any of the opening bracket so currently it's opening round bracket and the current element which is c whether it's the same type of closing bracket so your c is equal to closing round bracket like this so this much string is valid so the first condition comes out to be true so we simply pop this element out because its matching bracket has been found moving to the next character now c becomes the closing curly bracket this condition is false because we have a closing bracket stack is not empty we will first see the topmost element on the stack by calling stack.peak so top will be equal to the opening curly bracket like this so the first condition is false because top is not equal to opening round bracket and c is not equal to closing round bracket the second condition comes out to be true because top is equal to the opening curly bracket here and c is equal to closing curly bracket so it looks something like this this is our top and this is our currently element which is c so it's a match of the same type of brackets so this much part is valid so this condition comes out to be true so the overall if condition comes out to be true so we will simply pop this element out now we have visited all the elements in this char array so this for loop will terminate and here you can see at the end stack is empty so stack dot is empty material return true so therefore it means that this is actually a valid string so friend this was all about the problem valid parenthesis where we can figure out that whether brackets are actually balanced or not that is the opening brackets is being matched with the closing bracket of the same type and also in the correct order so friends i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to represent a queue in java so friends what is the queue so here queue is a data structure which is used for storing the data and it's an ordered list in which insertion are done at one end called as rear and deletion are done at other end which is called as front so friends if you see an example below then this is a linked list where the first node is referred by the front variable and the last node is referred by the rear variable so here queue follows a basic structure where insertion are done at one end which is called as rear so whatever we insert in the queue we insert at the end which is referred by the rear and whatever the deletions are done we use the front variable to make the delete so basically is a type of linked list where we keep two pointers one is front and one is rear and usually the front points to the first node and rear points to the last node and this linked list follows a certain pattern in which whenever you want to insert an element we basically insert at the end and whenever you want to delete any element we usually use the front end so friends queue is also called as fifo list which is first in first out list so here what we do is the first element inserted is the first one to be deleted so friends queue is a list which follows certain restrictions that whenever we want to insert an element we will use the rear end and whenever you want to remove an element we will use the front end so therefore we can see it's a first node so it means this node was inserted first and if you see whatever the nodes coming after that follow a sequence of removal therefore it's termed as fifo which is first in first out so the node inserted first will be the first one to be removed so let's quickly see the demonstration how queue works so friends queue is a list which follows certain restrictions that we will enter the nodes from one end and we will exit the node from other end so therefore so therefore it forms a fifo list where the element inserted first would be the first to be removed so let's see a quick demonstration so initially if you see queue is empty and there are no nodes so when a queue is empty front points to null and the rear points to null now if you want to insert any element into a queue we basically use an in queue operation now let's say we use an in queue operation and we want to insert a node having data as 20 so here if you want to insert this node having data as 20 then we know that there is only one end where we can insert so it looks something like this and once this node is inserted the front and the rear both points to this particular node and as in previous slide we discussed front points to the first node and the rear points to the last node so friends currently the queue is only one node therefore front and rear are both pointing to this particular node because this is the first and the last element both now let's suppose we want to insert one more element having data as 10 so it would look something like this that elements are inserted at one end and we basically use the rear end to insert the element so when we insert an element now rear will point to the node which was last inserted moving ahead now let's say we want to insert a node having data as 15 so it would look something like this so when the node is inserted now rear points to that particular node so friends here currently queue is three nodes 20 10 and 15 where 20 is the first node therefore it's been referred by front node and 15 is the last node therefore it is being referred by the rear node now let's say we want to remove an element so in order to remove an element we use the dq operation so friends as we know that queue follows a basic restriction that the nodes are inserted at one end and they are removed from the other end so in order to achieve that what we do whenever we insert any element we usually insert it using the rear end and whenever we remove an element we use the front end so let's see when we call this dq operation so the node which is referred by the front will be removed first so it would look something like this and once the node is removed now front will point to the node just after it and suppose we again call dq operation so it would look something like this and now front will point to the node 15 and we again call a dq operation so it would look something like this and now as there are no element into the queue therefore front end real both will point to null so friends here we saw that when we inserted three nodes 20 was the first node so therefore 20 became the first node to be removed so therefore it follows a fifo structure that the node which was inserted first was the first one to be removed so basically queue follows these restrictions that that whenever a node is inserted first it becomes the first one to be removed so friends this is how we represent a queue so in my next tutorial we will see how we can implement a queue in java i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to implement a queue in java so friends in my previous tutorial we discussed what is a queue and we know that it's a linear data structure used for storing the data and here we also saw that it's an ordered list in which insertion are done at one end which is called as rear and deletion are done at other end which is called as front so in my previous tutorial we discussed how we can use this front and rear end to insert and remove the elements from a queue and we also discussed that queue is a fifo list which is first in first out that a node inserted first will be the first one to be deleted so friends in this tutorial we will discuss how we can implement a queue so basically when we implement a queue we usually keep two list node by the name front and rear we insert using the rear list node and we remove using the front list node so friends let's go to eclipse and see the implementation of a queue so friends here i have created one class by name queue having an empty main method so in this class we will implement how a queue works so friends in order to implement a queue we need to create few instance variables so as we discussed in slide so queue contains a front node and a rear node so those two nodes are basically of type list node so here we'll create one list node and we'll give name it as front we'll also create one more list node and we'll give it a name as rear and we'll also create one integer variable now this integer variable will store the size of the queue so friends as we discussed in slide that queue is basically a list therefore internally it uses list nodes so here we will create one inner class of type list node so private class list node and friends as we discussed in our previous tutorials how we can represent a list node so in a list node we basically keep two things one is the data part and other is the reference to the next list node so private int data and other is the reference to next list node we will also create one constructor public list node now this constructor will take in a data part so int data and we'll simply assign this data to this dot data and this dot next will have null value so friends here we saw a queue has two list nodes one is represented by front another is represented by rear below we'll create one method as public int length now this method will return us back the length of the queue we will also create one boolean method public boolean and we will give it a name as is empty so friend this method will return us a boolean value that whether a queue is empty or not so we'll simply return length is equal equal zero so if length is zero then this method will return us true and if length is greater than zero then this method will return us false so friend this is how we implement a queue using the front and rear list node in my next tutorial i will demonstrate how we can insert an element into a queue and how we can remove an element from a queue so friends i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will continue with the implementation of a queue in java and in this tutorial we will discuss how to insert an element in a queue in java so friends in this tutorial we will discuss how to insert an element into a queue and if you see below is the algorithm to insert an element into a queue in our previous tutorials we discussed that queue is a type of a linked list which has some restrictions that it is considered as fifo list which is first in first out list so by first in first out we mean the element inserted first would be the first one to be removed and in this tutorial we will discuss how to insert an element into a queue so let's see the demonstration of this algorithm step by step so friends when we initialize a queue we know that the queue is empty and there are no elements so when a queue is empty and there are no elements so in this situation the front node and the rear node both points to null so here you can see currently queue is empty so therefore front is pointing to null and rear is pointing to null and we also know that as queue is empty and there are no nodes so the length is also zero so friends let's suppose we want to insert an element having the data as 10 so we will call incue function so let's see the demonstration how this method works now as we call the incue method and we pass the value of 10 into it we know that the data is equal to 10 so currently data is pointing to 10 moving ahead now in order to insert an element into a queue what we do we first create a temporary list node having the data which we have passed into the method so it would look something like this now here you can see that it is a basically list node having data as 10 where temp is pointing to this node and its next is pointing to null so this is the node that we want to insert into a queue moving ahead now in the first step we check whether the queue is empty or not so currently if you see front is pointing to null and rear is also pointing to null and length is zero so therefore the queue is empty so the condition in if block comes out to be true now in the if block what we do in order to insert this temporary node into the queue we simply assign the value of temp to front so it would look something like this so now front is pointing to this node having data as 10 so friends in our previous tutorial we discussed that when a queue is empty and if we want to insert an element then after an insertion we know that the queue is only one element therefore front and rear both point to that particular node so here we simply check that whether queue is empty and if it is empty then we'll simply assign the value of temp to front so you can see now front is pointing to this particular node moving ahead now after the if else block we simply assign the value of temp to rear so friends here we know that after the insertion of this node queue is one element so if the queue is one element then we know that front and rear both point to that particular node because the queue contains the only node which is first and the last node both so therefore in this step it would look something like this that rear is pointing to the node having data as 10 and front is also pointing to the node having data as 10 moving ahead now in the last step as we have inserted this node into the queue we noted length of this queue is one so therefore we will increment the length by one because this queue contains now one element moving ahead so when this method is executed the queue looks something like this the front and rear both point to this particular node and whose next is pointing to null and we also know that length is one now suppose if you want to insert one more node having data as 15 so let's see the algorithm once again so in the first step we know that data is 15 moving ahead so friends in order to insert the node having data as 15 first will create a temporary list node which has data as 15 and whose next will point to null so it would look something like this so here you can see temp is pointing to this list node whose data is 15 and whose next is null moving ahead now in the fblog we will check whether queue is empty or not so currently queue has one node therefore it's not empty so the else part will be executed so in the else part what we do we simply assign the value of temp to rear.next now friends in our previous tutorial we know that whatever the nodes we want to insert into a queue we always use the rear end of it this is because queue follows some restrictions that the nodes are inserted at one end and they are removed from the other end so in this case if you are inserting a node then we are always using the rear end so therefore we are assigning the value of temp to rear.next so currently if you see rear next is pointing to null and if you want to insert this node having data as 15 we need to remove this link and we need to point this link to this temp node therefore we are assigning temp value to rear.next so it would look something like this now first this link will be removed and then we'll create one link from first node to second node so it is nothing but we are assigning value of temp to rear next moving ahead so friends we know that we are inserting an element at the rear end and this rear node will point to the last element of the queue so currently we have inserted this node into the queue but we are not pointing rear to this node because this is the last node so in order to do that we are simply assigning value of temp to rear so it would look something like this so now as you can see front is pointing to the first node and rear is pointing to the last node and this is the property which queue follows moving ahead now as we are inserted this node into the queue we know that the queue has now two elements therefore we'll increment the length by one so now length becomes two and finally when this method is executed the queue looks something like this that front is pointing to the first node and rear is pointing to the last node and we have inserted this node using the rear end moving ahead now let's suppose we want to insert one more element having data as 20 so in the first step we know that data is 20 moving ahead now in order to insert data as 20 we will first create a temporary list node so now this temp node is pointing to a list node having data as 20 and who's next is pointing to null moving ahead so the if log we will check whether queue is empty or not so currently queue is not empty because length is two and we have two nodes already in the queue so the else part will be executed so in the else part what we do we simply assign the value of temp to rear dot next so we are doing this step is because we want to insert this node into the queue and we know that the elements are inserted into queue at one end which is called as rear end so therefore we are assigning value of temp to rear next so currently rear next is pointing to null and in order to insert this node into the queue we'll we have to remove this link and we have to assign this link to temp node so therefore we are simply assigning value of temp to rear dot next so it would look something like this so first this link will be gone and then we'll assign the value of temp to rear next so it would look something like this moving ahead and now as we have inserted the node into the queue we know that the node with the data 20 is the last node so therefore we'll simply assign the value of temp to rear because we know that rear points to the last node in the queue so it would look something like this moving ahead and in the final step we'll increment the length by one because now we have three nodes so the length becomes three and once this method gets executed queue looks something like this that front points to the first node and rear points to the last node and we also know that length is three because we have three nodes into the queue so friends this was the demonstration of how to insert an element into a queue now let's go to eclipse and see the working code so friends in my previous tutorial i had created one class by name queue and into that queue we created two list nodes one by name front and one by name rear and we also created one integer instance variable by name length so basically list node front will point to the first element into the queue and list node rear will point to the last element into the queue and as we are discussing the in queue operation we know that we are inserting the element from the rear end and we also discussed that queue has few methods by name length which was actually returning the length of the queue and when boolean method is empty which was returning true if the list is empty and false if the list is not empty so in this tutorial we will simply see how we can insert an element into a queue so we'll create one method as public void in queue and this method takes in a integer data now friends in the first step we'll create the temporary list node and we'll pass the data into the constructor so in the first step we are creating a temporary node which we discussed in the slide moving ahead we'll provide an if else block so in the if we'll check that is queue empty or not so if the queue is empty we are simply assigning the value of temp to front and if the queue is not empty then we are simply assigning the value of temp to rear.next moving ahead after if else block we are simply assigning the value of temp to rear as we discussed in the slide and in the last step we are incrementing the length by one so friend this is the enqueue operation which we discussed in the slide and in this class i will also create one constructor for the queue so public queue so when we initialize any queue we know that front is pointing to null and rear is also pointing to null and length is zero so friends in order to demonstrate how enqueue operation works i will create one more method which will actually print the elements of the queue so here i create one method as public void print and in the print method we'll check if if queue is empty it means it has no node to print so therefore we'll simply return from the method and if the queue is not empty then we'll traverse each element into the queue and we'll print it on the console so in order to print the elements on the console we'll first create a list node current and we'll assign the value of front to it so here as we know that we are implementing a queue with a linked list therefore we are printing the element from the first node to the last node so therefore in order to traverse each and every node we are first initializing the current with the value of front and then we are providing a while loop and inside this while loop we are traversing the current till it becomes null so in the first step we are simply printing the elements on the console so current dot data and then we are simply incrementing current to its next position by assigning current dot next to current and after the current encounters a null value then we are simply printing null so friends let's test the working of in queue method in the main method so here first i will create an instance of queue and when we create an instance of queue we know that queue is empty therefore front and rear both points to null so friends let's insert few elements into the queue so we'll call in queue method and we'll pass the value as 10 and let's say i print the queue on the console so if i run the code now so you can see it printed 10 and null so as the queue was empty when we inserted node having data as 10 so this was the only node so therefore it printed 10 and null now let's insert one more node and if i give the data as 15 and if i run the code now so you see it printed 10 then 15 and then null so here you see queue as two nodes where the first node is pointing 10 and second node is pointing 15 and here you can see we are inserting the node at the one end which is the rear end so therefore first 10 was inserted and then 15 got inserted so if i insert one more node say 20 and if i run the code now so you can see that using the rear end we are inserting the element at the end so friends currently queue has three elements with the data as 10 15 and 20 and in this tutorial we'll discuss how to insert an element into a queue so friends in my next tutorial i will discuss how we can remove an element from the queue and we'll discuss the dequeue operation i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will continue with the implementation of the queue in our previous tutorial we discussed how to add an element in a queue in java so in this tutorial we will discuss how we can remove an element from a queue in java so friends in my previous tutorial i added three elements into the queue by data as 10 15 and 20 so in this tutorial we will discuss how we can remove an element from a queue which is nothing but the dequeue operation so here i will take the same example and you can see that queue has three elements where front is pointing to the first node and rear is pointing to the last node and length is three so here you can see this is the algorithm for a dequeue operation now let's see the demonstration of this algorithm step by step now in the first step we will check that whether queue is empty or not so currently if you see length is three and we know that the queue contains three nodes therefore queue is not empty so the condition in if block comes out to be false now friends as we want to remove an element from a queue so here you can see the return type of dequeue method is integer type we are actually removing an element from the queue and we are sending back the data part of it so in order to store the data somewhere we are creating an integer variable by name result and we are storing front.data into it so friends in my previous tutorial we discussed that queue is a list with few restrictions where the elements are inserted at one end which is the rear end and elements are removed at one end which is the front end so friends the restriction which we impose on a list makes it a queue and therefore the queue is called as FIFO list which is first in first out so here you can see by first in first out we mean the element inserted first would be the first one to be removed so in my previous tutorial we discussed when we inserted the elements into the queue we inserted first 10 then we inserted 15 and then we inserted 20 using the rear end now in order to remove an element we know that 10 was inserted first so now 10 would be removed first so this is nothing but a FIFO property first in first out so let's see how we can use the front end to remove the nodes which are inserted first so here after this name gets executed results hold the value of 10 because the node 10 was the node first inserted into the queue therefore this node will be removed first moving ahead now friends in order to remove this node from a queue we know that it is being referred by this front node and if you break the link from front to this node then this node can be removed easily so in order to do that what we are doing we are simply assigning the value of front dot next to front so here you are simply assigning front next value to front so that once this node is removed 15 becomes our new front so therefore we are simply assigning the value of front dot next to front so it would look something like this moving ahead then we are checking whether the front is equal to null or not so currently you can see front is pointing to the second node therefore it's not null so the condition in if block comes out to be false moving ahead so friends as we have removed the reference of front from this node therefore this node will be garbage collected and you can see once this node is removed we will decrement the length by one so currently the length is three and after the removal of this node length becomes two so we simply decrement the length by one moving ahead and in the final step we'll simply return the value of stored in the result so friends when the dequeue method is executed the queue has two elements and length is two now friends let's suppose we call dequeue method once again so here first we check whether the queue is empty or not so currently queue has two nodes therefore it's not empty and then we'll simply store front dot data into the result so it would look something like this that we are storing the data into the list node which is being pointed by the front so now result contains the value of 15 moving ahead now in order to remove this node from a queue we have to break this link because if front is referring to this node then this node would not be removed so in order to break this link we are simply assigning front dot next value to front so it would look something like this moving ahead then we are checking whether front is equal to null or not so front is pointing to this third node therefore it's not equal so the condition in if block comes out to be false and here as we have removed the link of front to this node so now this node has no reference to it therefore it will be removed easily we know that now queue has only one element therefore we will decrement the length by one moving ahead and in the final step we'll simply return the value stored in the result which is 15 so friends when the dq method is executed queue has only one element where front and rear both point to that particular element because this is the only element left now if we suppose call dq again so first we'll check whether queue is empty or not so currently queue has length one that means it has one node therefore it's not empty so the condition in if block comes out to be false then we'll simply store the value of front dot data into result because we want to return this value so now result will hold the value as 20 moving ahead now friends we need to take an special care when we remove the last element from a queue because if the queue contains only one element and if we want to remove that particular element then we need to break two links one is of front and other is of rear because if any of the link is referring to this node then this node would not be removed so therefore here we are simply assigning the value of front dot next to front so it would look something like this so now front is assigned with its next value which is null moving ahead now we'll check whether front is pointing to null or not so currently if you see front is pointing to null therefore the condition in if block comes out to be true and as we discussed that we need to break both the links in order to free this node so therefore we'll simply assign the value of null to rear so now this link will be removed so it would look something like this so now front and rear both are pointing to null so friends as this node is having no reference therefore this node will be freed easily so once this node is removed we'll decrement the length by one because we know there are no elements left so we'll simply decrement the value of length by one so now length becomes zero because we have removed all the nodes so in the final step we'll simply return the value 20 so friends once this method gets executed this node gets freed up and as we know that now front and rear both pointing to null therefore the list is empty and length is zero so friends if we again call dq method then the first step we'll check whether q is empty or not so here you can see front is pointing to null rear is pointing to null and we also know the length is zero therefore q is empty so there are no elements left to be removed so the condition in a block comes out to be true and we'll simply throw in no such element exception because there are no elements left to be removed so friends in this slide we discussed the demonstration of the dq method now let's go to eclipse and see the working code so friends in my previous tutorial i created one class by name q we created few instance variable of type list node one of which was front another was rear we also created an integer variable which actually stored the length of the q and then we have created few methods one was length is empty and inq so basically we created inq method which could insert the elements into the q and here if you see and we also saw that we have added three elements and when we printed the q it printed something like 10 15 20 so so i will take the same list and we'll perform dq operation on it so first let's write the dq method so public we know that the return type of it would be integer so int tq now the first step we do is we check whether the q is empty or not so is empty now if the q is empty we know that there are no more elements left to be removed therefore we throw an exception as no such element exception and we pass a string as q is already empty moving ahead now we know that when we remove an element from a q we are returning the data part so therefore we'll create an integer variable by name result and we'll store front data to it moving ahead now as we have got the data of the front node we'll simply traverse front to its next value by assigning front next to front and then we simply check whether front is equal to null or not so if front is equal to null we know that we have to make rear also null which we saw in the slide moving ahead now as we are removed the node from a q we have to decrement the length by one and finally we are returning the result so friend this is the code for dq method whose demonstration we saw in the slide now let's test the working of this method so initially we have inserted three nodes now let's say i dq one node and then i print the q again so if i run the code so you can see when we inserted three nodes first 10 was inserted then 15 got inserted then 20 got inserted so the insertion was at the rear end now when we are doing a dq 10 was removed because we are removing a node from the other end which is the front end so thus q is a fifo list where we insert the node at one end which is the rear end and where we removed the node from the other end which is the front end so now as you can see 10 was the first element to be inserted therefore it got removed first now if i call dq again so here you can see 15 also got removed and if i call dq once again so here you can see nothing got printed because we have removed all the elements from the q and when we printed the list we can see when the list is empty we are simply returning from the print method so therefore nothing got printed and now as list is empty if i call dq one more time and if i run the code we get an exception saying no such element exception as q is already empty so friend this was the working of dq method so friends apart from this inq and dq method q also has two more methods by name first and last so when we call the first method we get the value stored at the node which is being referred by front and when we call the last method we get the value stored in the list node which is being referred by the rear so here we simply create public int first so here first we simply check that whether q is empty because if q is empty then we know that front and rear both points to null therefore we check whether q is empty or not and after this check we simply return value stored in the front so we simply return front.data and you also write one more method say last which is very similar we'll first check whether the q is empty or not and if the q is not empty then we'll simply return rear.data so friends let's test the working of first and last method so here i will just remove this thing so we inserted three nodes by values 10 15 and 20 so if i run the code so you can see front is pointing to a node having data as 10 and rear is pointing to a node having data as 20 as so for simply print q.first and q.last and if i run the code so you see it printed 10 and 20 because 10 is being referred by front and 20 is being referred by rear so friends in this tutorial we discussed about the dq operation we discussed about the few of the methods like first and last so this was basically all about the implementation of q i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello everyone so in this video we are going to see a problem that how we can generate binary numbers from one to n so here you can see that the question is generate binary numbers from one to n using a cube so binary numbers can be generated by various ways but here we will take a q data structure and we will generate the binary numbers from one to n where n will be the value provided to us so let's say value of n is 3 so the output would be a resultant array of string type and the binary numbers from one to n will be 1 1 0 1 1 so binary number 1 corresponds to 1 1 0 corresponds to 2 1 1 corresponds to 3 and similarly if n is 5 then we need to return like 1 2 3 4 and 5 so from 1 to n so these are the values and decimal number system and its corresponding binary numbers are 1 1 0 1 1 1 0 0 1 0 1 so here first we will see the conceptual overview that how we can generate the binary numbers from 1 to n so let's say we are provided with the value of n is 5 so the binary numbers we need to return is 1 1 0 1 1 1 0 0 1 0 1 so this value corresponds to 1 this to 2 this is 3 this is 4 and this is 5 so you can watch the videos and understand how this conversion happens from a binary number to a decimal number so here let's take one example let's say we are given with this binary number 1 0 1 so this is at zeroed spot this is at 1 and this is at 2 so what we do is this is binary number which is having 0 and 1 which is two numbers so we simply take this digits value multiplied by 2 and do their sum and we will get the decimal number so to convert this number into a decimal number what we do is we take this digit value which is 1 with multiplied with 2 to the power this value we do sum we take 0 multiplied with 2 to the power 1 we take 1 multiplied with 2 to the power 2 so this gives us 4 this gives us 0 and 2 to the power 0 is 1 so 1 into 1 gives 1 so this gives value as 5 so you can google the stuff or watch the videos there there are programs where we can convert from one number system to another number system so currently our problem is that we are given with a value of n and we need to generate the numbers from 1 to 5 so we need to generate something like this 1 1 0 1 1 1 0 0 1 0 1 so how we can do is so here you can see that at the start we directly have one number 1 and its binary representation is also 1 so the first number is we already know it's it would be 1 now here as we need to return the generated binary number in the form of string what we do is if i append 0 to it and if i append 1 to it i will get 1 0 here and 1 1 here so if you see closely if we are appending 0 we will get our next number if we are appending 1 we will get our third number so the first number we know that it will be 1 if we append 0 we will get the second number if we append 1 we'll get the third number now what about this fourth and fifth so here we do the same steps if we append 0 and if we append 1 so to 1 0 it becomes 1 0 0 and if we append 1 we'll get 1 0 1 now let's say if you would have have n equal to 7 so the next number would have been 1 1 0 for 6 1 1 1 for 7 so how this number would have come we would have taken 1 1 appended 0 appended 1 so this would have given 1 1 0 1 1 1 so this is how the binary numbers are generated but the main problem is for the first digit we know that this is 1 we can append 0 and 1 and we get 1 0 1 1 but how about other numbers how we will get this 1 0 and 1 1 in sequence so that we can append 0 and 1 to 1 0 and get the next elements and then append 1 1 with 0 and 1 to get the rest of the elements that also in sequence and this chain can go on like this so we need to maintain a certain order like this should come first then 1 0 should come then 1 1 should come and then when we are doing 1 0 we should append like this then we pick 1 1 we append like this and here also we'll go in this direction only we take 1 0 0 we'll append 0 and 1 we take 1 0 1 will append 0 and 1 to get the next binary numbers so this similar kind of structure or the sequence can be maintained via queue so here in a queue which is first in first out so the element which is inserted first will be first one to be removed so here we are directly putting 1 and then we remove 1 so when we remove 1 we have that element we can append 0 and 1 we will get 1 0 and 1 1 so first we will put 1 0 then we will put 1 1 so in the next iteration we will take 1 0 out we will append 0 and 1 and into the queue we'll put 1 0 0 first like this and then 1 0 1 and then in the next iteration we'll pull out 1 1 so while pulling out 1 1 we are actually getting the generated numbers but for the rest of the numbers we will append 0 we'll get 1 1 0 we'll put it into the queue we'll append 1 2 1 1 and we will put 1 1 1 into the queue so this chain goes on and the numbers are generated so let's see the demonstration of this algorithm step by step so here is the algorithm let's say we call generate binary numbers which is this method we pass in the value of n as 4 so we need to generate four numbers from 1 to 4 so the first number will be 1 then it will be 1 0 then 1 1 and then 1 0 0 so let's see the demonstration of this algorithm that how we can generate these four numbers so n is 4 first we will create a result array because this is the result array which we need to return from this method and this is of string type so the length of this array would be n so result array will have four elements because we need to return this four generated binary numbers we know that we need to use queue so we will initialize queue so queue is an interface and its concrete type is a linked list so it looks something like this so for the first number we can directly offer 1 into the queue because we need to generate the binary numbers from 1 to n so we directly put a string 1 into the queue because this queue is of string type so 1 comes into the queue like this and now in order to fill the result array we are providing a for loop which will go from zero index to a index n minus 1 which is value of n is 4, 4 minus 1 which is 3 which is the last index which is third index so i will start from the zero index and as we discussed we already know the first element so we simply pull the element from the queue and provide it into the result array like this add index i so when we will pull the queue it only has one element so one was entered first so this will be the only element to get exit first because queue is fee for data structure first and first out the element which enters first will be first to be removed so one will be pulled out and simply provided to the result array at zero index because i is pointing to zero so this gets pulled out and one comes here so this is nothing but a string like this because we have created an array result of string type so for timing i am just demonstrating it like this without double quotes and we know that once we get our first element like this we can append zero and we can append one to get the next two elements which is our n1 and n2 so string n1 can be generated by appending zero so n1 becomes one zero one appending zero will give one zero and one appending one will give one one so n1 becomes one zero and n2 becomes one one one appending with one will give one one so n2 becomes one one and we know that after generating n1 and n2 we will put them into the queue in the respective sequence n1 will go first and then n2 will go so first we will offer n1 so one zero will go into the queue and then we offer n2 which is one one so now our queue has two elements one zero and one one so after placing the first element at its correct position in the result array we will increment i, i becomes one which points to index one now in order to fill the result array at particular index which is one we know that we need to pull the element out because we know that the next element is one zero which we need to put it into the result array so whatever elements we are putting into the queue they are in proper sequence so the next element will be one zero so this number will be generated one zero we will pull that out and put it into the result array at index one one zero comes out we get string one zero here and so here you can see that after we are getting this string out we know what that string is so now for the next elements we can append zero and one so we get one zero zero and one zero one and we can put this two element directly into the queue so first we will generate n1 and n2 so result of i will give one zero we will append zero so n1 will become one zero zero and n2 will become one zero plus one will give one zero one like this and then we will simply offer n1 and n2 into the queue because we need to put them in proper sequence so that this binary number generation is done in proper order so one zero zero which is n1 it will go into the queue and then we will offer n2 which is one zero one so this will go into the queue now this element is generated properly so we will increment i now i will point to two which is the second index to fill this value we'll first pull the element from the queue which is one one and assign it to the result array at index two so one one will come out and one one will come here so here in order to create space we will simply shift this i. So these are still in queue but we have just shifted it so that space is created here for the other elements to go in so we have identified one element one one here so we got one one we know that to generate the further elements we will append zero and append one so this will give one one zero and this will give one one one we will generate both of these numbers n1 and n2 so n1 becomes one one plus zero which will give one one zero and n2 will become one one plus one one one one and then we will offer both the elements into the queue so first one one zero will go and then one one one will go we have filled this position so we will increment i so i will now point to the third index and now we can fill this we will simply pull the element from the queue which is the first element which got entered first so one zero zero got entered first before this rest of the three elements so one zero zero will be pulled out and it will be assigned to the result array here at the third index like this so friends here the algorithm is actually ended because we have generated the integers from one to n so this is one this is two this is three and this is four one two four because value of n is four but in order to demonstrate how these further numbers are generated we'll simply see the rest of the algorithm so whatever the number we just pulled out which is one zero zero it will help us in generating the further elements so one zero zero which is this part i am showing it here we will append zero we will append one so n1 becomes one zero zero plus zero so one zero zero zero like this and n2 becomes one zero zero plus one which will give us one zero zero one and here we have got one zero zero zero like this and similarly we will offer both the elements into the queue so one zero zero zero will be our n1 and then we will offer n2 which is one zero zero one like this so this binary number addition will go on like this but here now when we will increment i i will become four and four is not less than four so this for loop will terminate and though we have elements in the queue but we have figured out all the elements from one to n so we will simply return the result so this result will be a string array having one one zero one one one zero zero the four elements from one to n which is four so friend this was all about the algorithm that how we can generate binary numbers from one to n using a queue so your queue plays a very significant role because this data structure is first in first out the element which got inserted first will be the first to be removed so this property makes us easy to generate these binary numbers by just appending zero and one so friends i hope you must have liked this video in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to represent a binary tree in java so friends first we will discuss what is a tree data structure so here you can see that we are given a tree a tree is a nonlinear data structure which is used for storing the data and it is made up of nodes and edges without having any cycle so here you can see that we represent a tree through nodes and edges so here you can see the nodes are connected to other nodes through edges so friends tree is basically a nonlinear data structure without having any cycle so you can see that nodes are connected to each other but they never form a cycle so here if suppose six is pointing to nine so therefore you can see that it will form a cycle so therefore this representation is not a tree because in a tree you will find nodes having edges to other nodes but you will never find a cycle and you can always think of a tree in the form of a hierarchical structure and also you can see that each node in a tree can point to n number of nodes in a tree so here you can see the node having data as one is pointing to the three nodes by data as two nine and three so there can be n number of nodes in a tree which can be referred by any node so usually a tree is way of representing the hierarchical structure where the parent node is called as root so whenever we represent a tree usually the first node which is the parent of all other nodes is generally referred as root and you can see that it has many levels of additional nodes so so friends in the tree you can see that one is the parent of all the nodes below it and it's generally referred by the root because this is the root of the tree and whatever the edges are coming out from this root it's pointing to the other nodes and here you can see that this structure can go to many levels and also a node who is not pointing to any other node is generally called as leaf so here you can see that node one is a parent of two nine and three node two is parent of four and five and node four has no child therefore this is called as leaf node similarly five is a leaf node six is a leaf node seven is a leaf node nine is a leaf node because they don't have any children's moving ahead so friends what is the binary tree so friends the binary tree is a special kind of a tree where each node has zero one or two children's and not more than that can have zero children's one children or at max two children's so here in the below diagram you can see as root is the parent of all the nodes it's having two children's with data two and three the node two which is parent two four and five has two children's four and five and at the last you can see node four which is a leaf node has zero children's so friends similarly a node can have one children and the other children can point to null so friends the binary tree is basically represented by a tree node so here you can see a tree node consists of three things one is the data part which actually holds the data as you can see the data is like one two three six seven four five and it is a pointer to the left node and a pointer to the right node so these pointers are basically of type tree node itself so here you can see the node having data as one is a basically a tree node and whose left is pointing to the node two and whose right is pointing to the node three so therefore a binary tree having a tree node consists of only three things one is the data part one is the pointer to the left tree node and one is the pointer to the right tree node so basically the way we represent a binary tree in the graphical form is something like this that it contains the data which you can see here and two edges coming out of it so here you can see this is the left edge and this is the right edge and we represent this edge through the left and right pointers moving ahead so as we discussed in our previous slide that a binary tree is basically represented internally through a tree node so friends the structure of tree node is something like it contains data it contains pointer to the right tree node and a pointer to the left tree node in an actual tree and below you can see the java code for representing a tree node so it contains the data and here i have taken this data in the form of integer and which can be any generic type and it contains a tree node left which actually points to the node which is just left to this particular node and one tree node right which actually points to a tree node which is just right to it and basically it has one constructor which takes in a data part so whenever we initialize a tree node we usually pass the data which we want to store into it so usually when a node tree node is created so data which we pass into the constructor is stored in the data variable and left and right at the time of initialization usually points to null and later on we make them refer to the other tree nodes moving ahead so let's quickly see a demo how we can create a binary tree so when we initialize a binary tree the root is actually pointing to null and this root is also a type of tree node now let's say we have created one tree node having data as one and whose left and right is both pointing to null and which is referred by this temporary variable so let's say we want to insert this temp into the binary tree so what we do we simply assign the value of temp to the root so it looks something like this so when we insert one tree node usually root points to that particular node because this is the only node into the tree now let's say we create one more node having data as two and whose left and right both pointing to null which is referred by this temporary node and if we want to insert this node into the tree we know that root is already pointing to the node having data as one so one thing we can do here is we can either point root left to this particular node or root right to this particular node so either way we can do so let's say we assign temporary node value to root left so it would look something like this so now here you can see this is a binary tree having two nodes where root is pointing to the node having data as one and whose left is pointing to a node who having data as two and here you can also see that root right is pointing to null and left and right of root two is pointing to null now let's say we want to insert one more node having data as three now here we can insert this node into a binary tree at three places one is at the roots right another two places are nodes two left and right so basically we can place this node three into these three places which is pointing to null so let's say we insert it at roots right so it would look something like this so now here you can see root is having data as one and whose left and right both are pointing to a node having data as two and three and suppose we want to insert one more node then we can insert it into at the four places now so those four places would be two's left two's right then three's left and three's right because those four positions are pointing to null so friends in this tutorial we discussed how to represent a binary tree in java and we also discussed the structure of tree node so friends in my next tutorial i will be discussing how to implement a binary tree in java i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss how to implement a binary tree in java so friends in my previous tutorial we discussed how we can represent a binary tree in java and we also discussed the structure of tree node in a binary tree so friends in my previous tutorial we discussed that binary tree consists of a root node which is of type tree node and usually this root node keep the hold of all the nodes in a binary tree we also discussed that a tree node consists of a data part and it contains two pointers one is left pointer and one is right pointer so this left pointer is pointing to the left tree node and the right pointer is pointing to the right tree node so friends this is how we store the data into tree node and we usually use left pointer and the right pointer to hold the left tree node and the right tree node and below you can see the java code to represent a tree node so here you can see it has three things one is the data part one is the pointer to the left tree node and one is the pointer to the right tree node and here you can see we can store any generic type of data into a tree node and below is the constructor of tree node where we actually pass the data. So this data part whenever we initialize a tree node gets stored into the data variable. So friends let's go to Eclipse and see the implementation of a binary tree in Java. So friends here I have created one class by name binary tree which is having a main method. So let's implement a binary tree into this class. So friends in our previous slide we discussed that a binary tree consists of a root node which is our type tree node. So first we'll create an instance variable of type tree node and we'll give name to it as root because this root node will hold all the other nodes of a binary tree and in order to represent this tree node we'll create an inner class by name tree node so private class tree node. So as we discussed in our previous tutorial that as it is a binary tree therefore it will have two pointers one is pointing to the left tree node and another is pointing to the right tree node. So therefore we'll create two pointers of type tree node as left and right and this tree node along with holding the left tree node and right tree node it will also hold the data. So we are creating an integer type and which will actually store the data. So this can be any generic type not supposedly of integer type. We can store any data into this tree node. So in this tutorial I am taking the integer data moving ahead. Now below we'll also provide one constructor and this constructor will take in the data part which we want to store. So when we initialize a tree node we usually store the data into the data variable moving ahead we'll create one method as public void and we'll create a binary tree into it create binary tree. So in order to create a binary tree first we'll create few nodes. So let's say we are giving the nodes name as first and let's say I give the value to data as one and I will just create few nodes. Let's say I give the name as second third fourth fifth and let's say I provide data as two three four and five. Now when we call this create binary tree it will first create this five tree nodes. Now in order to store this five nodes into the binary tree first thing we do is we assign the value of first to root. So now root will be holding the tree node having data as one and let's say to first left we are assigning the value of second and to first right we are assigning the value of third. So friends here root will point to the node having data as one and its left will point to a node having data as two and one's right will point to the node having data as three. So here we have simply assigned the value of first to root and then we are assigning the value of second to first left and value of third node to first right. So after these three statements here you can see root will point to first and then after these two statements it would look something like this second so your first left will point to the second and first right is pointing to third. Moving ahead now let's say we assign the value of fourth to second left so we assign value fourth to second left and we assign value fifth to second right. So friends this is how we create a binary tree with the few nodes and after these four or five statements the binary tree looks like this. So friends the binary tree which we created after those four five lines of execution the binary tree will look something like this that we initially created five nodes with the data as one two three four five and then we have assigned the value of first to root. So therefore now root is pointing to the node having data as one and then we assign the value of second to first left. So now first left is pointing to the node having data as two and we assign third node to the first right therefore first right is pointing to the node having data as three. We also assigned the value of fourth and fifth node to two's left and two's right so therefore it looks something like this. So this is how we actually implement a binary tree where we insert the node using the left and the right pointers of a tree node. So friends in this tutorial we discussed how to implement a binary tree in java and in my next tutorial we will discuss how we can traverse each and every node of a binary tree in java. I hope you like this video please like comment share and subscribe my youtube channel. Thanks have a nice day. Hello friends welcome to my new data structures and algorithm in java tutorial series video. Friends in this tutorial we will discuss recursive preorder traversal of a binary tree in java. So friends what is a preorder binary tree traversal? So friends in order to traverse each and every node of a binary tree we apply these three steps on the each node of a binary tree. So what we do is we visit that particular node and then we traverse its left sub tree and then we traverse its right sub tree. So here if you take an example of this tree then we start with the root node and we apply these three steps on the root node. So what we do we first traverse this node and then we traverse its complete left sub tree and then we traverse its complete right sub tree. So once we process this node we first go to its left sub tree and there we encounter a node having data as 2. So on this node we again apply these three steps that we visit this node and then we visit its left sub tree and then we visit its right sub tree. So after we process the node having data as 2 we then go to its left sub tree and then we encounter a node having data as 4. So we apply these three steps on the node 4. We first visit this node and then we traverse with left sub tree and then to its right sub tree. So here you can see node 4 has no left sub tree and no right sub tree therefore we are done with the processing of this node and then we return back to the node having data as 2. So we have processed this node 2, we have processed the node 4. So now on the third step we visit the right sub tree. So we go to the node 5 and then we apply these three steps on the node 5. We first visit this node then we visit its left sub tree and then we visit its right sub tree. So as node 5 is having no left sub tree and right sub tree therefore we are done with the processing of the node 5 and once we are done with the node 5 then we are sure that we have processed the right sub tree of the node 2. So therefore we have processed 2 then 4 and then we have processed 5. So we are done with the left sub tree and then we again go back to the root node 1 and as we have visited the left sub tree of it we now will visit the right sub tree for the node 1. So then we go to the right sub tree of the node 1 and when we reach to the node 3 we apply these three steps now for the node 3. So first we visit this node and then we visit its left sub tree and then we visit its right sub tree. So after processing the node 3 we go to 6 and we apply these three steps. We visit this node we then go to its left sub tree and then go to its right sub tree. Now as node 6 is having no left sub tree and no right sub tree then we are done with the processing of this node and then we return back to the node 3. So once we return back to the node 3 we have processed its left sub tree and now the step remains to process its right sub tree. So when we reach to the node 7 we first process this node and then we traverse the left sub tree of it and the right sub tree of it. So as node 7 has no left sub tree and no right sub tree therefore we are done with the processing of the node 7 and then we reach to the node 3. And since we already processed this node then we reach to the node 1. So friends in preorder traversal we first process the node and then we process it left sub tree and then we process it right sub tree and this we do recursively for each and every node. So let's see the demonstration of preorder binary tree traversal. So friends suppose we want to traverse a tree whose root is 9 and whose left is a node having data as 2 and its left is having data as 4 and the right of node having data as 2 is null and the root 9 also has the right sub tree having the data as 3 and whose left and right sub trees are both pointing to null. So let's see the demonstration of this algorithm that how we can process the nodes of a binary tree in preorder traversal. So here you can see that below is the algorithm for it and as we are applying this preorder traversal to each and every node recursively. So here we know that the method name is preorder and inside this method we are again calling this method to process the left and the right sub tree. So friends when we are doing a preorder traversal we are calling this method recursively and in order to understand this method recursively here we are maintaining a call stack which has method call line number and the root. So in the method call we'll just keep the track of the method that which method is being called and we'll also keep the information of the root that which current node is being processed and we'll come to know about line number when we are demonstrating the algorithm. So let's call the preorder method and we'll pass the root as 9. So when the execution point comes to preorder we know that the call stack will now execute this preorder method and we are keeping the track of the root. So currently the root is being pointed by the data as 9. So then we check that whether root is equal to null or not. So friends why we are providing this condition is because this is considered as our base case and as we are calling this preorder method recursively we need a point to exit this recursion that when root is equal to null then we simply return from that method. So currently you can see root is pointing to 9 here. So therefore it's not equal to null. So the condition in if block comes out to be false and then as we discussed in our previous slide that first we visit the node and then we visit this left subtree and then we visit the right subtree. So we'll first visit the node and we'll print the data associated with that node. So the output is 9. So we have processed this node moving ahead. So now we are calling the preorder method to traverse the left subtree for this root. So the value we are passing to this preorder is root left. So currently you see root left is pointing to the node having data as 2 and as we are maintaining this call stack. So when we call this preorder method we'll keep the track of this line numbers so that once we return it back we know that from which line we need to execute the method. So currently from line 6 we are calling this preorder therefore we'll keep the track of this line number. So here we have stored the number as 6 and now we'll again call preorder method and we'll pass the root.left to it which is nothing but the node 2. So now root will be the node 2 and here preorder is again called with the root as node 2. So now we are again executing preorder with the root as 2. So we'll check whether root is equal to null or not. So currently root is not equal to null. So as we discussed in our previous slide that once we reach to the left subtree we process this node and then we go to its left subtree and then to its right subtree. So now we are processing the node 2. So the output would be 2 because we are just printing the data part of it. Moving ahead and now we'll again call preorder method recursively and then we'll pass root.left to it. So currently root is pointing to the node having data as 2 and its left is pointing to the node having data as 4. So as we are calling this preorder again we'll keep the track of the line number. So we are placing the line number as 6 because we know that we are leaving this preorder at line 6 and we are again calling this preorder. So the point of execution again reaches to preorder and this time the root is roots left so which is 4. So a new root becomes the node having data as 4 and as we are again executing this preorder we know that in the call stack this method will be called again and this time the root is being 4. So we'll again execute this preorder recursively. We'll first check whether root is equal to null or not. So currently root is pointing to 4 therefore it's not null and here we simply process this node. So the output would be 4 and after we process this node we know that now we have to traverse its left subtree and then its right subtree. So first we are processing its left subtree so we are simply calling preorder again and we are passing roots left. So currently here you can see root left is pointing to null so therefore we'll now call this preorder by passing a value null and as we are leaving this preorder now here we'll keep the track of the line number. So we are calling this preorder again and now the root would be null because we are traversing root left. So currently root is pointing to 4 and its left is pointing to null. So therefore our new root becomes null and there will be one more method on the stack with the name preorder and the root would be null. So we'll again execute the preorder method. So we'll check whether root is equal to null so currently if you see root is equal to null so we have reached our base case. So this base case will help us in exiting the recursion and as we know that we are left with no more nodes in the left subtree to traverse therefore we'll simply return from this method. So when we return this method gets executed so it gets removed from the call stack and now as this method is removed from the call stack call goes to the preorder method which was executed just before it. So we'll now start executing this preorder and as we know that we have left this preorder at the line number 6 so we'll now start from the line number 6 and we also know that when we left this preorder method at that moment the root was 4 so once the call reaches to this preorder root will be pointing to 4. So friends here we have first traverse the node 4 then we process it left subtree and now we'll go to its right subtree so that thing will do recursively. So in the line 7 now we'll simply go to its right subtree so as root is 4 and as right is pointing to null therefore we'll call preorder with a null value and as we are calling this preorder method with a value as null we are leaving this preorder method so we'll update the line number that from line number 7 we have again called this preorder method. So now this preorder will be called with a value of null so it's nothing but the roots right so one new root becomes roots right so now root will be pointing to null and we also know there will be one more method on the stack with the root value of null moving ahead so we'll check whether root is equal to null or not so currently root is equal to null therefore we'll simply return from this method so this method gets removed from the call stack and the execution point goes to the method which called it. So now we'll again start executing this preorder method from the line number 7 and we also know that we have left this preorder when the root was pointing to node 4 so we simply traverse to the node 4 and this would become our root and then we'll start again executing from the line 7. So once we reach the line 8 we know that we are done with the processing of this preorder method and whose root is 4 so therefore this method will be removed from the stack and the execution point will go to a method which called this method so if the execution reaches the preorder for the root node 2 and we also know that we have left this preorder from the line number 6 so we'll start executing from the line number 6 and we also know that when we left this preorder at that moment root node was 2 so here the root will now point to the node 2 moving ahead and from the line 7 we'll now call the preorder and we'll pass the roots right because we are applying this preorder traversal to each and every node that we are first traversing the node then we are processing its left subtree and then we are processing its right subtree so as here you can see we have processed this node 2 and we also processed its left subtree which is node 4 so now we are left with the processing of the right subtree so therefore we are again calling this preorder and we are passing the value of roots right so here roots right is null so therefore we again call this preorder method and we'll pass the null value to it and as we are leaving this preorder method and we are calling the new preorder method so we'll just keep the track of the line number so it signifies that we are leaving this preorder from the line number 7 so here now we are calling preorder with the value as null so therefore we know that there would be one more method on the call stack whose current root would be null so therefore now root will point to null and we'll start executing this preorder method so then we'll check whether root is equal to null or not so currently root is equal to null therefore we have reached our base case condition and we'll simply return from this method so when we return from this method this method will be removed from the call stack and the execution point will now reach to a method which called this method and as we have reached to this preorder method we know that we had left this method from the line number 7 so therefore the execution will start from the line number 7 and we also know that when we left this preorder method at that time root was pointing to the node 2 so therefore this root will now point to 2 and then we'll simply start executing this preorder method so once we reach the line number 8 so therefore this method will be removed from the stack and the execution point will reach to a method previous to it and we also know that we had left this method from the line number 6 therefore we'll start executing from the line number 6 and we also know that we had left this preorder method at that moment root was 9 so therefore now root will reach to 9 so friends for the root 9 we have processed the left subtree completely so now it's the time to process the right subtree so therefore we start the execution from line number 6 and here we know that we will again call preorder method and this time we'll pass roots right which is the node 3 and as we are leaving this preorder method we'll keep the track of the line number so now preorder will be called with the root pointing to the node 3 and we also know that there will be now one more method on the stack so now preorder will start executing with a root having data as 3 so therefore now root will point to the node having data as 3 moving ahead we'll check whether root is equal to null or not so currently root is not equal to null so therefore we'll simply process this node and then we'll start processing the left subtree in the right subtree so we'll simply print the data for this root node which is 3 and then we'll process the left subtree of it so we are again calling this preorder method and this time we are passing roots left so it's nothing but we are passing roots left which is null and as we are leaving this preorder method we'll keep the track of the line number which is 6 so now the execution point reaches to preorder and this time the root is null so therefore root will point to null and we also know that there will be one more method on the call stack and the root will be null so we'll execute preorder with the root as null so we'll check whether root is equal to null or not so currently root is equal to null so we have reached our base case so we'll simply return from this method now as we return from this method the preorder method on the call stack with the root as null will be removed from the call stack and the execution point will reach to a method which had called this method so we'll again start executing preorder method and we know that we had left this preorder from the line number 6 therefore the execution point will start from the line number 6 and we also know that when we had left this preorder method at that time root was pointing to 3 so now root will point to 3 moving ahead from the line 7 we'll now again call roots right because we have traversed the left subtree for the root 3 now we'll process its right subtree so we'll again call preorder method and we'll pass roots right which is null so when we are leaving this preorder we'll keep the track of the line number so when we call this preorder method we had passed roots right which is null so therefore for this preorder now root will point to null and we also know that there will be one more method on the call stack with a root as null so then we'll check whether root is equal to null or not so currently root is equal to null therefore we have reached our base case so we'll simply return out from this method so when we return from this method this method will be removed from the call stack and the execution point will reach to a method which called this method so now we'll again start executing this preorder method and we know that we had left this method from the line number 7 so we'll start from the line number 7 and we also know that when we had left this preorder method root was pointing to 3 so therefore root will reach to 3 moving ahead now once you executed all the statements from this preorder this preorder will be removed from the stack and the execution point will go to a method which called this method and the point which we have left this preorder was at line number 7 so therefore the execution point will start from the line number 7 and we also know that at that moment the root was 9 so therefore now the root will point to 9 and finally we are done with this preorder therefore this method will be removed from the stack so friend in this slide we saw the demonstration of how preorder traversal works that it first visits the node and then it recursively calls preorder to process the left subtree and then to process the right subtree and this goes on for each and every node so here you can see the output is 9 2 4 3 so we have visited 9 then we visited 2 then we visited 4 and then we finally visited 3 so friends here we saw the demonstration of the algorithm now let's go to Eclipse and see the working code so friends in my previous tutorial we discussed how to implement a binary tree in Java so I had created one class binary tree and we have implemented the binary tree in Java so here we had created an instance variable of type tree node which was actually root because this root will hold all the nodes of a binary tree and we had also discussed how we can create a binary tree by creating the few nodes so here let's write a code for preorder traversal of a binary tree so public void will give the method name as preorder now this method as we know will take in a root which we saw in the slide and as we are going to call this preorder method recursively will first provide a base case so the base case would be if root is equal to null then simply return from this method and if root is not equal to null then simply visit the node so we'll print root.data and once the processing of node is done we will again call preorder method and we'll pass root left and in the last line we'll again call preorder method and we'll pass root.write to it so here after processing of a node we are recursively processing the left sub tree and the right sub tree in a preorder fashion so friend this is the code for preordered binary tree traversal now let's test is working in main method so first we'll create a binary tree which we actually saw in the slide so here in my previous tutorial I had created few nodes so I'll just remove one of the node and I give the data which we saw in the slide as 9, 2, 3 and 4 so we also saw that root was pointing to 9, 9 left was second and 9 right was holding a node having the data as 3 and we also know that node 2 left pointed to node 4 and we'll just simply remove this line so here we have created a binary tree which we discussed in the slide where root is pointing to 9 and whose left is pointing to 2 and whose right is pointing to 3 and then again 2's left is pointing to 4 now after creating this binary tree let's test the working of this preorder method so in the main method we'll first create the instance of binary tree and then we'll simply call create binary tree now once we call this create binary tree the binary tree will be created and the root will hold the actual binary tree for us and then we'll simply call preorder and we'll pass the root of the binary tree so when I run this code so here you can see it printed 9, 2, 4, 3 which we actually discussed in the slide so friends in this tutorial we discussed the preorder binary tree traversal I hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss iterative preorder traversal of a binary tree in java so friends in my previous tutorial we discussed what is the preorder binary tree traversal so in preorder tree traversal we performed the three steps for each and every node of a binary tree that we first visit that particular node and then we visit this left sub tree and then we visit this right sub tree and this we do for each and every node so in my previous tutorial we discussed the recursive preorder binary tree traversal and in this tutorial we will discuss iterative preorder binary tree traversal we also discussed that we apply these three steps to each and every node of a binary tree that we visit that particular node and then we visit this left sub tree and then we visit this right sub tree so friends in my previous tutorial we used the recursion in order to traverse the binary tree now in this tutorial as we are not using the recursion and we are using the iterative way therefore we need to use an additional data structure which could hold the information of the nodes so friends when we use recursion and we call the method recursively so it internally used a stack so in the iterative way we will use the stack data structure so friends below is the algorithm for iterative preorder traversal of a binary tree and as we are using the iterative version of this algorithm we are creating a stack which could hold the additional information for us so that when we backtrack to a particular node we can fetch it from the stack easily and we also know that stack is a leafo data structure which means the last and first out so the node inserted last would be the first node to be removed and if you want to know more about stack data structures you can watch my previous tutorial so in this tutorial let's take this example that we want to traverse the nodes of this binary tree so let's see the demonstration of this algorithm step by step so basically when we execute this algorithm we start with the root and the first step we check is whether root is equal to null or not so currently you see the root is pointing to the node having data as one therefore it's not null and then we'll create a stack which could hold the three nodes for us so here you can see we have created one stack now this stack will hold the tree nodes for us so on the first step we'll simply push the root node moving ahead so friend as this is the iterative version of the algorithm we are using a while loop and we are placing a condition that iterate till the stack is empty so currently you can see stack is not empty because we have pushed one node therefore the condition in while block comes out to be true and while loop executes so in this line as we know that stack has only one element so therefore this element will be popped out and we'll assign this pop node to a temporary node so it would look something like this so first the node will be popped out so as the three node with the data as one was popped out now this time will point to that particular node moving ahead so friends in preorder tree traversal we first process a node and then we process its left sub tree and then we process its right sub tree so in the first step we'll simply print this node so the output would be one moving ahead so friends we have processed this node and now we will process its left sub tree and then its right sub tree so in order to do that we are first putting the right node on the stack and then we are putting the left node on the stack because when we pop it out we'll first pop out the left node and then we'll pop out the right node and in order to do that we are first checking that whether temp right is equal to null or not so currently temp right is not equal to null therefore we'll push the node having data as three on the stack so you can see three is now on the stack and then we'll check whether temp left is equal to null or not so currently temp left is not equal to null therefore we'll push the node having data as two on the stack so friends as stack is a leafo data structure it means the node inserted last would be the first one to be removed and we also know that in preorder tree traversal we first visit the node and then we visit the left sub tree so basically in order to traverse the left sub tree first we push the right node on the stack and then we push the left node therefore when we pop it out we'll pop out the node having data as two now we'll again check in the while loop whether stack is empty or not so currently stack is not empty therefore condition in while loop comes out to be true and then we'll simply pop an element from the stack and we'll assign it to the temporary node so the node is popped out so it means now temp will point to the node having data as two and in the next step we'll simply print the data for the temporary node so two is printed and hence we have processed this node and now we want to process its left sub tree first and then its right sub tree so on the stack we'll first put the node which is pointed by temp right and then we'll put the node which is pointed by temp left we'll check whether temp right is equal to null or not so currently temp right is pointing to the node having data as five therefore it's not null therefore we simply push the node having data as five on the stack and then we'll check whether temp left is equal to null or not so here you can see temp left is pointing to the node having data as four therefore we'll push the node four on the stack and then we'll again execute the while loop and we'll check whether stack is empty or not so currently stack is not empty therefore the while loop executes and now in the first step we'll simply pop an element which is on the top of the stack so here we know that four is on the top of the stack so it will be popped out and now temp will point to the node four moving ahead and then we'll simply print the data associated with this node which is four and then we'll simply check whether temp right is equal to null or not so currently temp right is equal to null therefore the condition in if block comes out to be false and then we'll check whether temp left is equal to null or not so here you can see temp left is also equal to null therefore the condition in if block comes out to be false and then again in while loop we'll check whether stack is empty or not so currently you see stack has two nodes therefore it's not empty so the while loop executes and the first step will simply pop the top element and will assign its value to the temporary node so currently you see node having data is five is the top element therefore will pop it out and now the temp will point to the node having data is five moving ahead now we'll simply print the data associated with this temporary node which is five moving ahead we check whether temp right is equal to null or not so currently temp right is equal to null therefore the condition in if block comes out to be false we then check whether temp left is equal to null or not so here you can see temp left is also null therefore the condition in if block comes out to be false and then we'll again execute the while loop then we'll again execute the while loop with the condition that stack is empty or not so currently stack has one node therefore it's not empty so in the first step we'll simply pop an element from the stack and we'll assign its value to the temporary node so here you can see when we do stack.pop the node three will pop out and then the temp will point to that particular node so it would look something like this so now temp is pointing to the node having data as three moving ahead now we'll simply print the data associated with this temporary node so the output we see three and then we check whether temp right is equal to null or not so currently temp right is not equal to null therefore the condition in if block comes out to be true so in the if block we simply push temp right which is the node seven on the stack and then we'll check whether temp left is equal to null or not so temp left is pointing to six which is not null therefore the condition in if block comes out to be true and we'll simply push temp left on the stack which is six and then while loop will again check the condition whether stack is empty or not so currently stack has two elements therefore it's not empty so in the first step we'll simply pop an element from the stack so the top element is a node having data as six so this node will be popped out and its value will be assigned to the temp so currently temp is pointing to the node having data as three and after this step temp will point to the node six because because when we do stack dot pop six will be popped out so it would look something like this so now temp is pointing to six we'll simply print its data on the console which is six and then we'll check whether temp right is equal to null or not so currently temp right is pointing to null therefore the condition in if block comes out to be false and then we'll check whether temp left is equal to null or not so temp left is equal to null therefore the condition in if block comes out to be false and then in while loop will again check whether stack is empty or not so currently stack is not empty because there is one node and in the first step we'll simply pop the element from the stack and assign its value to temp so when we pop an element from stack we know that seven will be popped out so therefore temp will now point to seven so it would look something like this and then we'll simply print the data associated with this node on the console which is seven and then we'll check whether temp right is equal to null or not so currently temp right is equal to null therefore condition in if block comes out to be false and then we'll again check whether temp left is equal to null or not so temp left is also equal to null so therefore the condition in if block comes out to be false and finally we'll check whether stack is empty or not so currently you see as we have processed all the nodes of a binary tree so the stack is empty therefore the condition in while block comes out to be false so friends using and stack we saw how we can perform preorder traversal of a binary tree so here we discussed about the demonstration of the algorithm now let's go to eclipse and see the working code so friends in my previous tutorial we created one class by name binary tree and we implemented binary tree into it now this class has an instance variable of type tree node which is the actual root of our binary tree we also discuss about the recursive preorder tree traversal and in this tutorial we will see the iterative version of it so therefore i'll just comment this code and below i will create a method as public void preorder and in this method we'll write a code which would perform the iterative preorder tree traversal so in the first step we'll check whether root is equal to null or not so if the root is equal to null so it means there are no nodes into the binary tree so therefore we'll simply return from the method and in the first step we'll simply create a stack so here we will import the stack from java.util package and as we discussed in slide we'll just push the root on the stack and after that we'll provide a while loop and inside this while loop will check whether stack is empty or not so if the stack is not empty then the while loop will be executed and in the first step we'll create a temporary node and we'll pop the element from the stack and we'll assign it to the temporary node and as we have popped an element from the stack we'll simply print it straight out on the console and in the next step we'll check that whether temp right is equal to null or not so if temp right is not equal to null then we'll simply then we'll simply push temp right on the stack and we will do this step for the temp left as well so here if temp left is not equal to null then we'll simply push temp left on the stack so friend this is the iterative version of preorder tree traversal now let's test is working on the main method so in the main method we have created is binary tree and the end we have called create binary tree so it will create a binary tree with few nodes which we discussed in our previous tutorial and the last i will simply call the preorder method and when i run this code so you can see it printed 9243 and it printed the same what we discussed in our previous tutorials when we had called the recursive version of the preorder tree traversal so friends in this tutorial we discussed about the iterative version of preorder tree traversal i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss recursive inorder traversal of a binary tree in java so friends what is inorder binary tree traversal so here you can see that inorder binary tree traversal has basically three steps and we apply these three steps to each and every node of the binary tree so the basic step involved in inorder binary traversal is we first visit the left sub tree for a particular node and then we visit the node and after visiting that node we go to its right sub tree and these three steps we apply on each and every node of the binary tree so let's take an example of the below binary tree now let's suppose we want to visit each and every node of this binary tree so we start with the root so here you can see root is pointing to node one now we apply these three steps on the node one so here you can see basically the step two is involved in the processing of the node which we are currently pointing to so here before processing the node one what we do we first traverse its left sub tree so here you can see this is the complete left sub tree which we want to traverse before we process this node and after we process this complete left sub tree we then visit this node and after visiting this node we go to its right sub tree so here when we are at node one then before processing this node we go to its left sub tree now as you go to its left sub tree we encounter the node two so when we encounter the node two we apply these three steps over the node two and before processing the node two we first traverse its left sub tree then we process the node and then we go to its right sub tree so here before processing the node two we go to its left sub tree first so once we reach the node four we apply these three steps on the node four So before processing the node 4, we traverse to its left subtree then we process the node and then we go to its right subtree. So here you can see node 4 has no left subtree therefore we are done with the processing of the left subtree and after we are done with the processing of left subtree we actually visit the node. So the first element we visit is the node 4 and after we are done with the node 4 we go to its right subtree and we know that node 4 has no right subtree therefore we are done with the processing of the node 4 completely. So the call returns back to the node 2 and from the node 2 perspective we have actually visited its complete left subtree. So now is the chance to visit the node 2. So we actually visit a node 2 and then we go to its right subtree. So when we reach to the node 5 we actually apply these 3 steps now on node 5. We traverse its left subtree then we visit the node and then we go to its right subtree. So here you can see node 5 has no left subtree therefore we are done with the processing of the left subtree. So then we process the node 5 and after we process the node 5 we go to its right subtree and we know that node 5 has no right subtree therefore we are done with the processing of the node 5. So friends after the node 5 is processed the call returns back to the node 1 and from the node 1's perspective we have completely traversed the left subtree now. So now is the chance to visit the node 1. So we visit the node 1 and then we go to its right subtree. So once we reach to the node 3 we apply these 3 steps over the node 3. So before processing of the node 3 we first go to its left subtree then we visit the node and then we go to its right subtree. So when we reach to its left subtree we encounter a node having data as 6. So we apply these 3 steps now over node 6 we visit its left subtree then we process the node and then we visit the right subtree. So here as node 6 has no left subtree therefore we are done with the processing of the left subtree and then we actually visit the node and after visiting the node we go to its right subtree. And as node 6 has no right subtree therefore we are done with the processing of the node 6 completely. Then our call goes back to the node 3 and we know that we have completely visited its left subtree. So now we can visit the node 3. So once we visit the node 3 the third step is involved is we go to its right subtree. So as we go to its right subtree we encounter a node having data as 7. So on this node 7 we now apply these 3 steps. We first visit the left subtree of it then we visit the node and then we visit the right subtree. So friend as we know that node 7 has no left subtree therefore we are done with the processing of the left subtree for the node 7 and then we actually visit the node 7 and then we go to its right subtree. So here we can see node 7 has no right subtree therefore we are done with the processing of the node 7. So here we have visited each and every node and to each and every node we applied these 3 steps that before processing the node we actually visited its complete left subtree then we visited the node and then we went to its right subtree. So friend these are the steps involved in order binary tree traversal. Now let's go ahead and see the demonstration of the algorithm. So friend let's suppose we want to traverse this binary tree where root is pointing to the node 9 whose left is pointing to node 2 and whose left is pointing to node 4 and node 4 has no left and right subtree therefore they are pointing to null. Node 2 has no right subtree therefore is pointing to null and here node 9 right is pointing to the node 3 which have no left subtree and the right subtree. So friends below you can see the algorithm for the in order binary tree traversal and here you can see the method name is in order which takes in a root and in the method we are actually again calling the in order method therefore these calls are recursive in nature. So in order to understand this recursion we are using this calls track where we are keeping the information for the current executing method and we are also keeping the track of the root node which is getting executed in the particular method call and we are also keeping the track of the line number whose significance we will see once we demonstrate the algorithm. So let's see the demonstration of this algorithm step by step. Now when we call in order method and we pass the root so currently you see root is pointing to the node 9 so we know that this method will be part of our call stack. So it would look something like this that now this method will be part of our call stack and this method will be executed with the root as 9 because currently root is pointing to 9 we move ahead and we check whether root is equal to null or not. So friends why we are providing this condition as this is the base case for our recursion because in the in order method we are again calling the in order method recursively. So friends in order to break this recursion we need to provide a base case and if we don't provide this base case then this method will call each other recursively. So in order to stop this we are providing this base case. So currently you see root is pointing to the node 9 therefore it's not null. So the condition in a block comes out to be false. So in the first step what we do is so what we discuss in the slide that before processing of a node we will first traverse this left sub tree. So we again call the in order method and this time we are passing roots left because we want to process the left sub tree now. So here you can see root left is the node 2 therefore this in order method will call the in order method again with the root as 2. So friends here we are leaving this method and now we are entering to this method again. So we will keep the track of the line number that at the line 5 we left this method so that once this method is processed we again return back to this method and will start executing from the line 5. So therefore we will keep the information for the line number whenever we leave any particular method. So here we keep the track of the line number which is 5 that we are leaving this in order method at the line 5 and we are calling this in order method again with a root 2. So friends this method will be called again and this time the root will be the node 2. So here now root instead of pointing to 9 it will point to 2 and we also know that we have left this method in order method so there will be one more method on the stack. So now this in order method will start executing with the root as 2. So let's see the working we will first check whether root is equal to null or not. So currently root is pointing to the node 2 therefore it's not null. So friends as we discussed in the slide before processing any node we have to process it left sub tree first. So in order to visit the node 2 we will first have to visit its left sub tree. So here we again call in order method and we pass root left so here you can see root is pointing to the node 2 and we will call in order method and we will pass the root dot left which is node 4 and as we are leaving this method we will keep the track of the line number. So here now in order method will start executing with the root as 4. So currently root is pointing to the node 2 so now it will point to node 4 and here you can see there would be one more method coming on the stack. Now this in order method will start executing with the root as 4 moving ahead we will check whether root is equal to null or not. So currently root is pointing to the node 4 therefore it's not null. And here before processing the node 4 we have to first process its left sub tree therefore we are again calling the in order method and we are passing root left so currently root is pointing to the node 4 so now we are calling this in order method and we are passing the null value to it. And here we will keep the track of the line number that as we are leaving this method and we are calling this method so we are keeping the track of the line number. So friends now in order method will be called again and this time the root will point to null. So here you can see currently root is pointing to 4 and as we discussed that we are going to root left so now root will point to null and we also know that once this method gets start executing there will be one more method on the call stack. Now here you can see this in order method has root as null. Moving ahead we will check whether root is equal to null or not. So currently you see root is equal to null therefore we have reached our base case which makes sense because when we encounter a null value it means there are no nodes to be traversed. So we simply return from this method and once we return from this method we know that this method will be removed from the call stack and the execution point will go to the method which called this method. So now execution point reaches here so friends we know that at line 5 we left this method so we will start executing from the line 5 itself. So our execution point will now start from the line 5 because we have processed this information earlier and we also know that when this method was getting executed root was pointing to 4 so when step of execution reaches here root will point to 4. Moving ahead so friends here you can see for the node 4 we have processed left sub tree now is the time to process the actual node. So therefore we simply print root's data on the console. So on the output you can see 4 will be printed because root's data is 4. Moving ahead and we also saw in the slide that after we process the node we then go to its right sub tree. So in order to go its right sub tree we again call the inorder method and this time we pass root's right so currently root is pointing to the node 4 and its right is pointing to null therefore we will again call the inorder method and will pass the null value to it and here as we are leaving this method on the line 7 we will keep the track of the line number so now it will be 7 and we also know that once we call this method so now inorder method will be called again and this time with root's right which is null. So friend currently root is pointing to node 4 and when we call this inorder method with a null value therefore now root will point to null and we also know that there will be one more method on this call stack with the root as null. So let's execute this method in the first step we will check whether root is equal to null or not so currently root is equal to null therefore the condition comes out to be true and will simply return from this method. So once we return from this method we know that this method will be removed from this call stack and the method which called it the execution point will go there. So now the execution point reaches to this method and we also know that we left this method from the line number 7 so therefore the execution point will start from the line 7 and we also know that when we left this method root was pointing to node 4 so therefore now root will point to node 4 again and then will start executing from the line 7. So when we reach the line 8 we know that we have completely processed this inorder method so therefore this method will be removed from the call stack and the call will go to the method which had called this method. So now call will go to this inorder method and we know that we had left this method from the line number 5 therefore the execution point will start executing after the line 5 and we also know that when we are executing this inorder method at that time root was pointing to node 2 so therefore now root will point to the node 2 and will start executing after line 5. So here we can see that before processing the node 2 we have completely visited its left subtree so now is the time to process the node itself therefore we simply print its data on the console. So you can see 2 gets printed on the console and after we process the node we know that now we have to go to its right subtree. So we again call inorder method and we pass root right value which is null and we also know that as we are calling this inorder method we will update the line number here. So now the execution point reaches to this inorder method and we know that there will be one more method on the call stack with the root as null. So here you can see root is pointing to node 2 so now this root will point to null and will start executing this inorder method. So in the first step we check whether root is equal to null so here you can see root is equal to null therefore we will simply return from this method and we are returning from this method that because we have already processed its right subtree. So once we return from this method we know that now this inorder method will be removed from the call stack completely and now the execution point will reach to this inorder method and will now start executing this inorder method from the line number 7. So we will start executing from the line number 7 and as we know that when we were executing this inorder method root was pointing to 2. So now root will point to 2 and then we simply execute this inorder method. So once we reach to the end of this method we know that now this method will be removed from the call stack and the execution point will reach here. So we will start from the line number 5 and we also know that when we are executing this method root was pointing to 9. So therefore now root will point to 9 and then we will simply execute the steps. So friends here you can see before we processed node 9 we completely traversed left subtree and after we traverse its left subtree completely now we are visiting the node. So we are simply printing its data on the console moving ahead and once we are done with the process of this node we have to process its right subtree. So therefore we are again calling inorder method and we are passing the value root right to it. So here you can see root right is the node 3 and as we are calling this new method we are updating the line number. So point of execution reaches to the inorder method with a root as 3. So now root is pointing to 3 and we also know that as this is a new method on the stack there will be one entry on the call stack. So here now this inorder method will start executing with a root as 3. So we first check whether root is equal to null or not. So currently root is pointing to 3 therefore it's not null. And then for the root 3 we apply the inorder traversal again. We first visited its left subtree. So in order to visit its left subtree we are calling inorder method and we are passing root left value to it. So here you can see root left is pointing to null therefore we are calling this inorder method with the value as null. And as we are leaving this method and we are calling this new method we will update the line number. So then execution point will reach to this inorder method with a root as null. So we know that there will be one more method on the call stack with a root as null. And now root will point to null. Moving ahead we check whether root is equal to null or not. So currently root is equal to null. Therefore we simply return from this method and this method will be completely removed from the call stack. And as this method is removed from the call stack the execution point reaches to this inorder method which actually called the inorder method with a null value. And from which line we have to start we have to start the execution from line number 5. And we also know that when we were executing this inorder method root was pointing to 3. So now root will point to 3. So friends now in this step as we have processed the left subtree completely then now we will process the node itself. So we are simply printing the data on the console. And then as we have to process its right subtree now. So we are calling inorder method and we are passing root's right which is the null value. And before calling this new method we are updating the line number. So when the point of execution reaches the inorder method root is null. So there will be one more method on the stack with the root as null. So now this root will point to null. And we will start executing this method. So in the first step we will check whether root is equal to null or not. So currently root is equal to null. Therefore we will simply return from this method. And when we return we know that this method will be removed completely from the call stack. And the point of execution reaches here. So we know that we will execute this method from the line number 7. And we also know that at that moment root was pointing to 3. So now root will point to node 3. And then we will start executing from the line 7. So when we reach to the line 8 we know that we have completely executed this inorder method. So this will be removed from the call stack. So friends now the execution point reaches to this inorder method. And we will start executing from the line 7. And we also know that when we are executing this method root was pointing to 9. Therefore we will simply traverse root to 9. And then we simply process all the steps for this inorder method. So now this will be removed from the stack. So friends as we know there are no methods left on the call stack. Therefore we have successfully executed the inorder binary tree traversal. And the output you can see is 4293. So friends this was the demonstration of the algorithm. Now let's go to Eclipse and see the working code. So friends in my previous tutorial I had created a class by name binary tree. And I have implemented binary tree into that class. You can watch my previous tutorial inorder to understand its working. So in this tutorial we will simply write the code for inorder binary tree traversal. So let's say I give the method name as public void inorder. And as we discussed in the slide this inorder method takes in a root. Now in the first step we check if root is equal to null then we will simply return from this method. Because this is the base condition as we are as we are calling this inorder method recursively we have to provide a base case so that we can get exit from this recursion. And as we discussed in our slide that before visiting any node we will first visit its left sub tree. So we will call inorder method and we will pass root left to it. And after we process its left sub tree we will visit the node. So we simply print root's data on the console. And in the last step we will again call inorder method and we will process root's right sub tree by calling root's right in the inorder method. So friend this is the algorithm for the inorder binary tree traversal. Now let's test its working. Now in my previous tutorial I had created one binary tree and this is the same tree which we discussed in the slide. Use this create binary tree method so here in the main method we will call create binary tree and then we will call the inorder method and here we will pass the root. Now if I run the code. So here you can see it printed 4293 which is the same output which we saw in the slide. So friends in this tutorial we discussed the recursive way of inorder binary tree traversal. I hope you liked this video. Please like, comment, share and subscribe my YouTube channel. Thanks have a nice day. Hello friends welcome to my new data structures and algorithm in Java tutorial series video. Friends in this tutorial we will discuss iterative inorder traversal of a binary tree in Java. So friends in my previous tutorial we discussed about the recursive inorder tree traversal. So steps involved in inorder tree traversal are as follows that before visiting any particular node we first visit its left subtree then we actually visit the node and then we visit its right subtree and this steps is applied over each and every node. So friends if we apply inorder tree traversal over this tree then what we need to do is before visiting the node 1 we have to actually traverse its left subtree then we have to visit the node and after visiting the node we have to traverse its right subtree. So when we start with the node 1 we have to go to its left subtree first because as we go to its left subtree there is no way we can reach to the node 1 again therefore we need an additional data structure which can hold this node so that once we complete the visiting of left subtree we can pull the element out of that additional data structure and we can visit it and after visiting it we can go to its right subtree. So the additional data structure that we use here is stack. So here you can see we are using stack which is the leafo data structure which means the element inserted last into the stack would be the first one to be removed. In order to know more about the stack you can watch my previous tutorials. Before visiting this node we actually put it on the stack and then we go to its left subtree and this we do for each and every node and once we actually visit the left subtree of any node then we pop the element out of the stack we visit that node and then we go to its right subtree. So let's see the demonstration of this algorithm step by step. So let's suppose we are given with a binary tree having 6 nodes and where root is pointing to the node 1. So let's apply this algorithm over this binary tree and let's see how we can traverse each and every node of a binary tree using the in order tree traversal. So basically in the first step we check whether root is equal to null or not so if root is equal to null we simply return because there are no nodes in the tree to be traversed. So currently you see root is pointing to node 1 therefore it's not null. So the condition in if block comes out to be false. So after the if block what we actually do is we actually create a stack. Now this stack will hold the tree nodes for us. So it would look something like this moving ahead. So in the next step what we do is we create a temporary tree node and we assign the value of root to it. So now the temp will point to root so it would look something like this that is temporary node is pointing to root moving ahead. So friends in order to traverse this binary tree using in order tree traversal we actually use a while loop and inside this while loop we are actually placing two conditions. So we are iterating this while loop till stack is empty and temp becomes null. So currently you can see stack is empty. So the condition comes out to be false but you can also see the temp is actually pointing to a node therefore it's not null. So the second condition comes out to be true and as there is a or operator between these two conditions therefore the overall condition comes out to be true. So the while loop executes. So in the while loop we actually encounter an if else block. So in the if block we check whether temp is equal to null or not. So currently you can see temp is pointing to the node 1 therefore it's not null. So the condition in if block comes out to be true. So in the if block the first step we do is we actually push the temporary node on the stack which makes sense because before visiting this node we have to first visit its left sub tree. So therefore we are actually pushing this temporary node on the stack so that once we are done with the left sub tree then we can pop this element out and then we can visit this node and after visiting this node we can go to its right sub tree. So when we push the temporary node on the stack it looks something like this that now node 1 is on the stack moving ahead and in the next step we simply traverse the temp to its left because we have to first visit the left sub tree therefore we need to traverse temp to its left. So we are assigning the value of temp.left to temp so here temp.left is the node 2 therefore now temp will point to the node 2 so it would look something like this. The temp is now pointing to the node 2 moving ahead. In the while loop we will again check whether stack is empty or not and then we will check whether temp is pointing to null or not. So currently you can see stack is not empty and temp is pointing to the node 2 therefore its not null. So the condition in while block comes out to be true and then the if log will check whether temp is equal to null or not. So here you can see temp is pointing to the node 2 therefore its not null so the condition in if log comes out to be true and then we will simply push that node 2 on the stack because before visiting the node 2 we have to first visit its left sub tree completely therefore we will push the node 2 on the stack so it would look something like this that now node 2 is on the stack and then we will simply traverse temp node to its left which is the node 4 so it would look something like this. Now temp is pointing to the node 4 and then again in the while block we will check whether stack is empty or not and temp is equal to null or not. So currently stack is not empty and temp is pointing to node 4 so therefore the condition in while block comes out to be true and then in if log will check whether temp is equal to null or not so currently temp is pointing to node 4 therefore its not equal to null so the condition in if log comes out to be true. So then in the first step what we do is we simply push the temp on the stack because before visiting the node 4 we have to first traverse its left sub tree completely therefore we are pushing the node 4 on the stack so it would look something like this. Now node 4 is on the stack moving ahead and in the next step we will simply traverse temp by assigning temp.left value to temp which makes sense because before visiting this node we have to first visit its left sub tree therefore not temp has to move to its left sub tree. So now temp will point to a node which is left to node 4 and here you can see it is pointing to null so therefore now temp will point to null. Moving ahead we will again check whether stack is empty or not and temp is equal to null or not so currently you can see temp is equal to null but stack is not empty therefore the condition in while block comes out to be true and then in the if log will check whether temp is equal to null or not so here you can see temp is equal to null therefore the condition in if log comes out to be false. So the else block will be executed and here we can see that node 4 left is pointing to null therefore there is no node to be visited so therefore we have visited its left sub tree completely so now is the turn that we can visit the node 4. So in order to do that we will simply pop the first element from the stack and will assign that temp to that node so here you can see as stack is a leafo data structure so the last element inserted is the first one to be removed so when we do a pop the node 4 will be popped out and value of node 4 will be assigned to temp so therefore once the node 4 is popped out temp will now point to the node 4 so it would look something like this right now node 4 is popped out and whatever the value it holds it will be assigned to temp so now temp will point to node 4 so it would look something like this moving ahead so here for the node 4 we have visited its left sub tree completely so now is the time to visit the node 4 so on the console we are simply printing the data associated with the temporary node so here node 4 becomes the first node to be traversed so on the output 4 will be printed moving ahead and as we have visited node 4 now will simply traverse to its right sub tree so we are simply assigning value of temp.right to temp so here temp.right is pointing to null so therefore now temp will point to null moving ahead so in the while block we will check whether stack is empty or not so currently stack is not empty and temp is equal to null or not so currently temp is equal to null but stack is not empty therefore the condition in while block comes out to be true and we will check whether temp is equal to null or not so currently temp is equal to null therefore condition in if block comes out to be false and the else block will be executed so here you can see for the node 4 as its left is pointing to null and its right is pointing to null it means there are no nodes on the left and the right side for the node 4 to be traversed therefore for the node 2 we have completely visited its left sub tree because we have printed the output 4 which means we have traversed this node so here what we are doing is we are again popping the element from the stack and we are assigning it to temp so when we pop an element from the stack we know that it's node 2 so it would look something like this that node 2 is popped out and its value will be assigned to temp so it means now temp will point to node 2 and which makes sense because we have completely traversed the left sub tree for the node 2 so now it's time to traverse the node 2 so the next step will simply print the data associated with the temporary node which is 2 so on the console we simply print 2 and then we will simply traverse temp to its right so here as we have visited the left sub tree for the node 2 and we also visited the node 2 now is the time we go to its right sub tree therefore we are simply assigning temp.right value to temp so it would look something like this so now temp is pointing to the node 5 because it is on the right of the node 2 moving ahead now in the while loop we will check whether stack is empty or not so currently stack is not empty and temp is also pointing to node 5 therefore the condition in while block comes out to be true and then in if block we will check whether temp is equal to null or not so currently temp is not equal to null because it is pointing to the node 5 therefore the condition in if block comes out to be true so what we do is we simply push the node 5 on the stack because we cannot visit this node till we visit its left sub tree completely therefore we need a way to store this element on the stack so we are simply pushing the temporary node on the stack so now node 5 is on the stack and then we simply go to its left because we need to traverse its left first so now temp is pointing to null in the while block we will check whether stack is empty or not so stack is not empty but temp is pointing to null so the overall condition comes out to be true so the while block executes in the if block will check whether temp is equal to null or not so temp is equal to null therefore the condition in if block comes out to be false and the else block will be executed so as node 5 has no left sub tree therefore simply means that we have visited its left part now we will actually visit the node so we simply pop the element from the stack so when we pop the element from the stack we know so we know that 5 was inserted last therefore it would be first one to be removed and when we remove the node 5 we assign its value to temp so now temp will point to the node 5 so it would look something like this so now temp is pointing to the node 5 and then we will simply visit the node 5 so on the console we print the data associated with the temporary node which is 5 moving ahead and once we have visited this node now it's time to go to its right sub tree so now temp will point to null moving ahead in the while block we will check whether stack is empty or not so currently stack is not empty but temp is pointing to null so the overall condition comes out to be true because stack is not empty so the while block executes in the block will check whether temp is equal to null or not so temp is equal to null therefore the condition in a block comes out to be false and the else block will be executed so here you can see we have completely visited the node 5 and this node 5 is actually right to the node 2 therefore we have completely visited a left sub tree for the node 1 so when we pop an element from the stack one gets popped out and now temp will actually point to the node 1 so node 1 is popped out and its value will be assigned to temp so now temp will point to node 1 moving ahead so friends here you can see for the node 1 you completely visited its left sub tree by printing 4 2 and 5 so now we can actually visit this node so therefore we simply print the data associated with this temporary node which is 1 so 1 gets printed on the console therefore we have visited this node and the next step as we have visited this node now we'll simply go to its right sub tree therefore we simply assign temp right to temp so here you can see temp right is pointing to the node 3 therefore now temp will point to the node 3 again in the while block will check whether stack is empty or not so here you can see stack is empty so the first condition comes out to be false but here you can see temp is pointing to the node 3 therefore it's not equal to null so the second condition comes out to be true so here the overall condition comes out to be true and the while block executes so here we will check whether temp is equal to null or not so currently temp is pointing to the node 3 therefore it's not equal to null so the condition in if block comes out to be true and here before visiting the node 3 we have to first visit its left sub tree completely therefore we need a way to store this element on the stack so we simply push the temporary node on the stack so it would look something like this now 3 is on the stack and then we'll simply go to its left sub tree because this left sub tree we need to visit first before actually visiting the node 3 so we are simply assigning temp dot left value to temp so here you can see temp left is pointing to the node 6 so therefore not temp will point to the node 6 in the while block we will again check whether stack is empty or not so currently stack is not empty so the first condition comes out to be true and temp is actually pointing to the node 6 therefore the second condition also comes out to be true so the overall condition comes out to be true and while block executes so the first step will check whether temp is equal to null or not so currently temp is pointing to node 6 therefore it's not equal to null so the condition in if block comes out to be true and then we'll simply push the node 6 on the stack because you can't visit this node till we process its left sub tree completely therefore we are storing the node 6 on the stack so after pushing the node 6 on the stack we simply go to its left sub tree so not temp will point to the left of the node 6 which is null moving ahead now currently stack is not empty but temp is pointing to null therefore the overall condition comes out to be true we check whether temp is equal to null or not so temp is equal to null therefore condition and if block comes out to be false and the else block will be executed so here as node 6 has no left sub tree therefore we are done with the processing of the left sub tree for the node 6 so now is the time that we can visit the node 6 so what we do is we simply pop the element from the stack because we know that we have actually stored this element on the stack so we pop this element from the stack and we'll assign it to temp so it would look something like this so now temp is pointing to the node 6 moving ahead and then we are simply printing the data associated with node 6 so 6 gets printed on the console and as we have visited this node now is the time to go to its right sub tree so therefore not temp will point to null so in the while block we'll check whether stack is empty or not so currently stack is not empty so this condition comes out to be true but temp is pointing to null so the overall condition comes out to be true so the while block executes we check whether temp is equal to null or not so here temp is equal to null therefore the condition in a block comes out to be false so the else block will be executed so friends here you can see for the node 6 we have actually visited its left sub tree we have visited the node and we have visited its right sub tree so therefore we have completely visited is node 6 and here you can see node 6 is to the left of node 3 so now you actually traverse the left sub tree for the node 3 so therefore now we can visit the node 3 so in order to reach to node 3 we know that we already stored this node on the stack so we simply pop this element from the stack and we'll assign it to temporary node so it would look something like this that node 3 gets popped out and its value is assigned to temp so therefore not temp will point to node 3 and then we'll simply print the value associated with this temporary node which is actually 3 so 3 gets printed on the console and as you have visited the node 3 completely now we need to visit its right sub tree therefore we are simply assigning temp right to temp so now temp will actually point to null so now again we'll check the condition in while loop so first we check whether stack is empty or not so currently stack is empty so the first condition comes out to be false and then we'll check whether temp is equal to null or not so here you can see temp is equal to null therefore the second condition comes out to be false so overall both the conditions are coming out to be false so the while loop terminates and here you can see we have actually visited all the nodes of this binary tree and we have printed the data associated with those nodes which is 4 2 5 1 6 3 so friends this was a demonstration of the algorithm and let's go to Eclipse and see the working code so friends in my previous tutorial we actually created one class by name binary tree and we actually implemented the binary tree into this class so friends in order to understand binary tree more you can watch my previous tutorials so in my last tutorial we actually discussed the recursive version of the in order tree traversal but in this tutorial we will discuss the iterative way for the in order tree traversal so here I will just comment this code and below I will create the method as in order now this in order method will take in a root so let's code the algorithm which we saw in the slide so the first step will check that whether root is equal to null or not so if root is equal to null will simply return from this method because there are no nodes in the binary tree to be traversed and the first step will create a stack which will hold the tree nodes for us and as we discussed in the slide we'll create a temporary node and we'll start it from the root so tree node temp and we'll simply assign the value of root to it and now we'll simply provide a while loop and we also saw that we have placed two condition on that that whether stack is empty or not so the first condition is we are checking whether stack is empty or not and then we are providing an or and the second condition we provide is temp should not be equal to null so in the while loop we'll simply provide an if else block so in the if block will first provide a condition that temp should not be equal to null and if temp is not equal to null then we simply push the temp on the stack and then we traverse temp to its left and if temp is equal to null then we simply pop an element from the stack and we will assign its value to the temporary node once we pop the element from the stack we'll simply print it on the console so temp.data and as we have printed the data on the console then we'll simply traverse temp to its right so friend this is the code for iterative in order tree traversal now let's test is working in the main method so here first we have initialized the binary tree and then we have created a binary tree with few nodes so here in create binary tree we have actually created few nodes which we also discussed in our previous tutorials you can watch my previous tutorial in order to understand how this binary tree is created and after creating the binary tree with few nodes we'll simply call the in order method and we'll pass the route to that method so if I run this code now so here you can see it prints four two nine three because in the create binary tree the root is nine and root left is second which is two and roots right which is three so so here nine left is two and nine right is three and here you can see second left is fourth now the fourth node is pointing to the second slab so nine is at the root its left is two and its left is four so therefore so on the console it printed four then it printed two and then nine and then three because as nine is on the root in order to process this node we have to first visit is left sub tree so on its left is the node two and before processing the node two we have to go to its left sub tree so which is four so four gets printed first then we print the node two and then we actually print the root node and then we go to its right sub tree so we simply print three so friends in this tutorial we discuss the iterative version of the in order tree traversal I hope you liked this video please like comment share and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures and algorithm in Java tutorial series video friends in this tutorial we will discuss recursive postorder traversal of a binary tree in Java so friends what is postorder binary tree traversal basically there are three steps involved in doing the postorder binary tree traversal and all these three steps are applied over each and every node of a binary tree so if we take an example of a binary tree shown in the slide then basically we start with the root node and we apply these three steps over the root node so what actually we do is in order to visit this particular node first we actually visit its left sub tree completely then we visit its right sub tree completely and then we actually visit the node so here if we want to visit the node one then we have to first visit its left sub tree completely and then we have to visit its right sub tree completely and then we can visit the node and these three steps are applied over each and every node so suppose we are on node 2 so in order to visit this node what we have to do first we have to visit its left sub tree completely then we need to visit its right sub tree completely and then we can visit the node so therefore here before visiting the node 2 we have to first visit the node 4 then we have to visit the node 5 and then we can visit the node 2 so here basically these three steps are applied on each and every node of a binary tree in order to do postorder binary tree traversal so friends in this tutorial we are discussing the recursive postorder binary tree traversal below you can see the algorithm for the postorder binary tree traversal so we will demonstrate this algorithm using this binary tree here and we will see how we can apply this algorithm on this binary tree and whatever the output comes out it will be displayed here so friends as this algorithm is recursive in nature here you can see postorder method is again internally calling the postorder method therefore this is the recursive nature algorithm so in order to understand the recursive nature of this postorder method we will maintain a call stack so that we come to know that which method is currently being executed and what is the root that is being processed we will come to know about line number when we will actually discuss the postorder method so friends let's see the demonstration of this algorithm step by step so friends here you can see the root is pointing to the node 9 and when we call this postorder we actually pass the root node so to this postorder we are actually passing the root node as 9 so friends when the point of execution reaches this postorder method we know that on the call stack there will be one method by the name postorder and we also know that we have passed the root as 9 so therefore on the call stack there will be one method by name postorder which will start its execution moving ahead so friends the first step we actually check whether root is equal to null or not so if root is equal to null we simply return from that method and here you can see that this condition will act as our base case because as we are calling this postorder method and internally again calls the postorder method we need to provide a base case to stop the execution of this postorder method because if we don't provide the base case postorder method we'll again call postorder method and it will go on calling each other infinitely so this is the base case which is required in order to break the recursion and we will see its significance later in that demonstration so currently as you can see root is pointing to 9 therefore it's not equal to null so therefore the condition in if block comes out to be false and at the line number 5 we see it calls postorder method again and this time we are passing roots left which is the node 2 so friends as we discussed in our previous slide that in order to visit a particular node we have to first visit its left subtree completely then we have to visit its right subtree completely and then we can visit the node so therefore before visiting the node 9 we have to first visit its left subtree completely so we are again calling the postorder method and we are passing root.left to it which is nothing but the node 2 so here you can see when we had called this postorder method there was one method on the call stack and inside this we are calling this postorder method again so when we call this postorder method we are leaving this postorder method so in order to keep the track of this postorder method we will update the line number here so it would look something like this that from line number 5 we are leaving this postorder method and we are again calling the postorder method with the root as 2 so once this line gets executed we know that postorder method will be called again and this time this postorder method will be called with the root as 2 so therefore the line of execution reaches to the postorder method again and we know that root will now point to the node 2 so now this method starts execution with a root as 2 therefore we know that there will be one more method on the call stack so here now this postorder method will start its execution with a root as 2 moving ahead we will check whether root is equal to null or not so here root is pointing to the node 2 therefore it's not null so the condition in if block comes out to be false and at the line number 5 we are again calling the postorder method and this time we are passing root.left so here root left is nothing but the node 4 so why we are doing this step is because because in order to process this node 2 we know that we have to first visit this left subtree completely then we have to visit the right subtree completely and then only we can visit this node and we also discussed in our previous slide that all the three steps are applied to each and every node of the binary tree so therefore before traversing the node 2 we have to first visit this left subtree completely so therefore we are calling this postorder method again with a root as 4 and we also know that we are leaving this postorder method so we will update the line number here which is nothing but 5 so now point of execution reaches to this postorder method with the root as 4 and we also know that now root will point to the node 4 and as this method will start its execution there will be one more method on the call stack with a root as 4 so here now this postorder method will start its execution with a root as 4 so in the first step we will check whether root is equal to null or not so currently root is pointing to the node 4 therefore it's not null so the condition in if block comes out to be false and then on the line number 5 we are again calling postorder method with the value as root dot left so friends in order to process the node 4 we have to first visit its left subtree completely then we have to visit its right subtree completely and then only we can visit the node 4 therefore we are again calling the postorder method and this time we are passing the value as root dot left so here root is pointing to node 4 and its left is pointing to null therefore now we are calling this postorder method with a null value and we also know that we are leaving this method from the line number 5 therefore we'll update the line number here as 5 so the point of execution will reach to this postorder method with a root as null so therefore now root will point to null and we also know that there will be one more method on the call stack by the name postorder and whose root will be null so now this postorder method will start its execution with a root as null so here first we'll check whether root is equal to null or not so currently you can see root is pointing to null therefore the condition in if block comes out to be true so therefore we have reached our base case so we'll simply return from this method so friends as we return from this method we know that this postorder method is executed completely therefore this method will be removed from the call stack so friends when this method is removed from the call stack the call goes to its previous method which actually called this method with a root as null and we also know that we had left this postorder method from the line number 5 so the point of execution reaches to this node and we'll start our execution from the line number 5 because at this line number we have actually left this method so therefore we'll start our execution from this line and we also know that when we had left this method at that moment root was pointing to node 4 so therefore now root will point to node 4 moving ahead so friends at the line number 6 we are again calling the postorder method but this time we are passing it a value as root.right which actually makes sense because in order to traverse this node 4 we have to first visit this left subtree completely then we have to visit this right subtree completely and then we can visit the node so therefore on the line number 5 we have completely visited the left subtree for the node 4 so now is the time to visit its right subtree so therefore we are again calling the postorder method and we are passing the values root.right so here root is pointing to node 4 and its right is pointing to null therefore we know that now we'll call this postorder method with a null value and we also know that as we are leaving this postorder method from the line number 6 we need to update the line number here so the line number becomes 6 so friends point of execution reaches to this postorder method and this time the root will be null and we also know that once this method starts its execution there will be one more method on the call stack with the root as null so it would look something like this so we know that root is null so therefore now root will point to the null moving ahead we will check in the flog whether root is equal to null or not so currently you can see root is equal to null so therefore we'll simply return from this method and as we return from this method we know that this method is executed completely so this would be removed from the call stack and the point of execution reaches to the postorder which actually called this method and we also know that we had left this postorder method from the line number 6 therefore the execution will start from the line number 6 and we also know that when we had left this method root was pointing to the node 4 so therefore now root will point to node 4 moving ahead so friends on line number 7 we will simply print the data associated with this root so friends in order to process the node 4 what we have actually done is we have first visited its left subtree completely then we visited its right subtree completely so after doing this stuff we are actually visiting the node 4 so we are simply printing its data on the console which is 4 moving ahead so friends at the line number 8 this postorder method on the call stack will complete its execution so this would be removed from the call stack completely and the point of execution will reach here and we also know that we had left this postorder method from the line number 5 so the point of execution reaches to the line number 5 and we also know that at that time root was pointing to node 2 so here now root will point to node 2 and we'll start our execution with this postorder method so friends in the line number 6 we are again calling the postorder method and this time we are passing root.write to it so here you can see root is pointing to node 2 so we'll pass root.write which is null to this postorder method so friends here you can see we are calling this postorder method again with the root as null because root.write is nothing but null value and we also know that we are leaving this method so we'll update the line number here and we know that line number is 6 so now line number changes to 6 so root is pointing to the node 2 therefore now it will point to its write which is null now this method will start its execution so therefore there will be one more entry on the call stack with the root as null moving ahead we'll check whether root is equal to null or not so currently root is equal to null so therefore we'll simply return from this method so when we return from this method we know that this postorder method is executed completely so therefore it will be removed from the call stack and once it's removed from the call stack the point of execution reaches to this postorder method and we also know that we have left this method the line number 6 so we'll start its execution from the line number 6 and we also know that when we had left this method root was pointing to node 2 so here root is pointing to null so now it will point to node 2 moving ahead and at the step 7 we'll simply print the data associated with the root which is nothing but 2 so friends here you can see before processing of the node 2 we first completely visited its left subtree and we printed node 4 and then we visited its complete right subtree which was actually null and then we actually visited the node 2 so it printed something like this 4 and then 2 moving ahead so at line number 8 we know that this postorder method has been executed completely so therefore this would be removed from the call stack and the point of execution reaches to this postorder method and we also know that when we had left this postorder method from the call stack the line number was actually 5 so we'll start our execution from the line number 5 and we also know that root at that time pointed to the node 9 so therefore now root will point to node 9 and our execution starts from line number 5 so friends here you can see that we are on node 9 and in order to visit this node we have to first visit its left subtree completely which you are actually done and then we have to visit its right subtree completely so now we'll start to move to its right and then we can process this node 9 so we are again calling the postorder method and this time we are passing the value as root.write because we have to now visit its right subtree completely so therefore you can see root's right is nothing but node 3 so we will be again calling this postorder method with a root as 3 and we also know that we are leaving this method postorder from the line number 6 so therefore we'll update the line number here so now point of execution again starts postorder method and this time with the root as 3 so now root is pointing to the node 3 and we also know that there would be one more method on a call stack with a root as 3 so friends now let's start the execution of this postorder method with a root as 3 in the first step we'll check whether root is equal to null or not so currently root is pointing to node 3 therefore it's not null and at the line number 5 we will again call postorder method and this time we are passing root's left which is nothing but the null value so here before processing of node 3 we know that we have to first process its left subtree and then we have to process its right subtree so in order to process its left subtree we are calling this postorder method again with roots left which is nothing but the null value so friends we are leaving this postorder method at line number 5 so we will update the line number here and then point of execution will call this postorder method again with root as null so now root will point to null and we also know that there will be one more method on a call stack with a root as null so now let's execute this postorder method with a root as null so here we check whether root is equal to null or not so currently root is equal to null therefore we'll simply return from this method so once we return from this method we know that this method is executed completely so it will be removed from the call stack and point of execution will reach to this postorder method and we know that we had left this postorder method from the line number 5 so therefore we'll again start our execution from the line number 5 with a root as 3 so currently root is pointing to null so now it will point to 3 so we are starting now line number 5 and our root will point to node 3 moving ahead so the line number 6 we will call postorder method again and we'll pass the value as root.right because in order to traverse this node we have to traverse this left subtree first which we have already done so now is the time to traverse this right subtree and after traversing right subtree we can actually visit this node 3 so in order to visit this right subtree we are calling this postorder method again and we are passing the null value to it and we also we are leaving this method at line number 6 so we'll update the line number here so now point of execution will start the execution of this new postorder method with the root as null so root is pointing to node 3 now it will point to null and we also know that there will be one more method on the call stack with the root as null so let's start the execution of this postorder method with the root as null so we'll check whether root is equal to null or not so currently root is equal to null therefore we have actually visited the right subtree for the node 3 so we'll simply return from this method and as we return from this method this postorder method will be removed from the call stack and point of execution will reach to this postorder method and we know that we have left this postorder method from the line number 6 with a root as 3 so we'll start the execution from the line number 6 and we know that at that time root was pointing to 3 so now root will point to node 3 so friends we have visited the left subtree for the node 3 and we also visited the right subtree for the node 3 so now we can actually visit the node 3 so on the line number 7 we will simply print the data associated with this root which is nothing but 3 moving ahead and once we reach the line number 8 we know that we have successfully executed this postorder method so this method will be removed from the call stack and the point of execution will reach to this postorder method and we also know that we had left this postorder method from the line number 6 and at that time the root was actually 9 so we are starting on the line number 6 and we know that we had left this method when the root was pointing to 9 so therefore now root will point to 9 and moving ahead so friends here you can see for the node 9 we have completely visited its left subtree and we have printed 4 and 2 then we actually visited the right subtree completely and we printed 3 so now is the time to visit the node 9 so we are simply printing the data on the console for the root which is pointing to node 9 so now 9 will be printed on the console and on the line number 8 we know that we have completely executed this postorder method so this would be removed from the call stack and once this is removed from the call stack we know that there are no more methods left to be traversed so here we have actually successfully executed this recursive postorder traversal to this binary tree and we have printed its each and every node on the console as 4 2 3 9 so friends this was the demonstration of the algorithm now let's go to eclipse and see the working code so friends in my previous tutorial i had created one class by name binary tree and we actually implemented the binary tree into this class so in order to understand the implementation of this binary tree you can watch my previous tutorials so in this tutorial we will actually code recursive postorder traversal of a binary tree so here i will create one method as public void post order so this is the same method which we discussed in the slide so this method takes in a root which is our type tree node so first we'll provide the base case which is we will check whether root is equal to null or not so if root is equal to null then we'll simply return from this method so this is nothing but the base case because we are calling this postorder method recursively so friends as we discussed in our slide that in postorder tree traversal before visiting any node we will first visit is left sub tree and then we'll visit is right sub tree and then we can visit the actual node so first we'll visit the left sub tree by calling root dot left and then we'll visit its right sub tree by calling root dot right and after visiting the left sub tree and the right sub tree we'll actually visit the node so we'll simply print root dot data on the console so friend this is the code for recursive postorder binary tree traversal so now let's test it's working on the main method so here in the main method we'll first initialize this binary tree class and then we'll create the binary tree so in create binary tree method we are actually creating the binary tree with few nodes and these are the same nodes which we discussed in the slide and we also discussed this method in my previous tutorials so you can watch my previous tutorials in order to understand how we have created this binary tree with a few nodes so after creating this binary tree we'll actually call the postorder method and we'll also pass the root into it so if i run the code now so you can see it printed four two three nine which is the same output which we discussed in the slide so for in this tutorial we discussed about the recursive postorder binary tree traversal i hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello everyone so in this video we will discuss about the iterative postorder traversal of a binary tree so in our previous videos we discussed about the recursive postorder traversal of a binary tree and in this lecture we will see the iterative approach to traverse the binary tree using the postorder so here you can see let's say we are given with this binary tree and we want to traverse this binary tree using the iterative postorder traversal so in our previous video when we discussed about the recursive approach to traverse the binary tree we discussed that in order to traverse a binary tree using postorder what we do is before visiting the root we visit all its element on the left subtree then we visit all its element on the right subtree and then we actually visit the root and usually these three steps we perform on each and every node of a binary tree when we do the traversal in a recursive way so in case you want to learn more about that you can watch my previous video so the only thing we need to remember here is when we do postorder traversal on every node we need to first traverse all its elements on the left side then we need to visit all its elements on the right side and then we can actually visit the node so for example if we are on node 2 then we can't directly visit the node 2 we need to visit first the node 4 then we need to visit node 5 and then only we can visit the node when we are performing the postorder traversal so in this video we will discuss the iterative approach where we are not performing any recursion so when we perform postorder traversal using the iterative way we usually take the help of a stack so stack is nothing but a LIFO data structure which means last in first out where the last element inserted will be the first one to be removed so we will use the stack data structure to traverse this binary tree using the postorder traversal so let's see the demonstration of this algorithm step by step so at the first step what we do is we create a tree node current which simply points to the root and in the middle of this algorithm we are also creating one temporary tree node we will see their advantages later in the algorithm so in the first step we are simply creating the current and pointing it to root then we are actually creating the stack data structure so this is our stack data structure and we are using the stack class present in java so as you want to perform this postorder traversal we need to visit each and every node of this binary tree and as you are following a iterative approach we are providing a while loop where we are providing the two conditions first is the current is not equal to null or stack is not empty so here you can see current is pointing to a node having value as 1 therefore this condition comes out to be true because current is not equal to null so the overall condition of this while loop comes out to be true because any of this condition if comes out to be true this while loop will execute so here you can see in the first step what we are checking is that if current is not equal to null then we simply go inside this if block or else we perform this logic so why we are providing this condition here is let's say current is pointing to a node having data as 1 and let's suppose we want to visit this node so if the current is not equal to null then we can't directly visit this node we need to first visit all the elements of its left sub tree and then we need to visit all the nodes of its right sub tree and then only we can visit this node so current will be null at this location and when current will be null then we can simply decide now can we visit the node or not so here as current is not equal to null so there can be a possibility that this node has a left sub tree so what we do is we simply push node 1 into the stack and then we simply traverse to its left by assigning current's left to current so current is pointing to node 1 its left is pointing to node 2 so now current will point to node 2 we again check where current is equal to null or not so current is not equal to null so the first condition comes out to be true and we don't evaluate the second condition because of this or operator so this while loop will execute we check whether current is equal to null or not so current is not equal to null so this condition also comes out to be true because there can be a possibility that node 2 has a left sub tree so what we do is we simply push the current on the stack so 2 will be on the stack and then we simply visit current to its left so current will now point to 2's left which is 4 and similarly current is not equal to null so this condition comes out to be true here current is not equal to null because it is pointing to node 4 so we simply push current onto the stack because there can be a possibility that there is a left sub tree or a right sub tree so 4 is on the stack and we go to its left by assigning current's left to current so current will point to its left which is null value so friends here you can see now current is actually pointing to null now if the current is pointing to null so this null can be on the left side of this node or on the right side of its node so if the current is on the left side of the node then we know that we need to visit the right side also before visiting this node but if the current is on the right side of the node then we know that we have already visited left we have already visited right now we can visit this node so in the postorder we discussed in order to visit any node we need to visit all its left children then we need to visit all its right children so if current is pointing to a null then there can be two possibilities that this null value can be on the left side and this null can be on the right side so if the null is on the left side we need to visit the right sub tree for this node and if the current is on the right side then we know that we have already visited left and we have already visited right then we can simply visit the node so here current is equal to null so this condition comes out to be false but our second condition the stack is not empty so this condition comes out to be true and overall condition comes out to be true so while loop will execute this if check will fail because current is actually pointing to null so now we'll go to the else part so in the first step what we do is we create a temporary variable and we assign a value stack.peak.write so here you can see in the stack whichever is the last element inserted is the peak of the stack so when we do stack.peak we are simply pointing to this node 4 and if we do .write then we are actually pointing to nodes.write so here this is 4 and write will be null so we will see why we are creating this temporary variable so for timing you can see that temp is pointing to null now here we are given two conditions that whether temp is equal to null or temp is not equal to null so why we have provided this condition is because let's say if current is pointing to null then we need to somehow check that whether this null value is on the left side of node 4 or on the right side of the node 4 so in order to verify that thing we created this temporary node so as current is pointing to null so this can be any left or right child of a node and we also know that this node will be already present on the stack and if you want to know that whether we are on the left side or on the right side what we do is we simply go to this node and go to its right so here temporary variable is doing that for us so here why we are providing this check here is if temp is equal to null so this will signify that whatever the value was on the stack its right is actually pointing to null and there are no nodes left to be traversed on the right side of this node so what we can simply do here is poll this element out because we are not sure that as current is pointing to null and temporary is pointing to null which means that we have traversed the left subtree and the right subtree for this node so now we can simply poll this node out and we can simply visit it so we'll poll this element out and our temp will point to four and in the next step we'll simply visit the temp so we are simply printing the data of the temp which is four here so friends why we actually do all this stuff is when current actually reaches to any null value then we need to be sure that whether it's on the left side or on the right side so we simply create a temporary variable to simply pick the right side of a node present in the stack and if the temp is equal to null then it simply signifies that there are no nodes on the right side and we have already visited the left side so now it's time to visit the actual node so we have visited four here moving ahead so for now here we provide a while loop and why we provide is while loop because the first thing we are checking is stack is not empty so as we have recently pulled an element out of it so there can be a chance that stack becomes empty so stack should not be empty and the second condition is very important which is the core of this algorithm is we are simply checking whether temp is stack dot peaks right so here you can see so as we have recently visited this node here so there can be a possibility and we need to be sure that whether this node is on the left of two or on the right of the two because if it is on the left of two then we can't directly visit two we need to go to its right and visit node five but if it is on the right side then we can simply visit the node two so here stack peak is node two this and it's right which is this value is node five so we are simply checking whether this node which we visited just now its value is equal to its parents right or not so if this value comes out to be true then we know that that parent right is actually the node which we just now visited so we can simply visit the parent now but here you can see temp is pointing to four and stack peak which is the node two is pointing to right therefore they are not equal which means that whatever the node we have visited just now it's on the left side not on the right side of node two so this value will terminate and our call will reach to this while loop again so friends here why we have provided this while loop it will be clear when we reach here so for timing you can just think that we have provided a while loop here so moving ahead here you can see current is pointing to null but stack is not empty so the overall condition comes out to be true current is equal to null so we go in the else now on the first step what we do is we simply assign the stack peaks right value so stack peak is node two this node and its right is node five so temp will point to five so friends why we are assigning this value now here is as current is pointing to null and we have recently visited node four and we also verified here that node is at the left of two so there can be a possibility that node two might have a right subtree and in postorder traversal after visiting the left part we need to visit the right part and then only we can visit the parent so here we are simply assigning the value of stack dot peak dot right so two's right is five so temp will point to five and here we will check whether temp is equal to null or not so your temp is not equal to null which signifies that the right part there is a node which also can have left and right children so and we can't directly visit this node because there might be a possibility that it contains left and right children so here if the this condition comes out to be false and we go in the else part where we'll assign the current to the temp so why we are assigning current to temp because this five can be treated like any other node which can have the left and right children so as we started by pointing current to root it is similar to that step that this node can have a left or a right children so we need to perform all those steps again on this node so here current is not equal to null so this condition comes out to be true and if the current is not equal to null so this is the same case which we discussed here that current is not equal to null there can be a chance that this node have a left children so what we do is we first push the five on the stack and then we go to its left by assigning current's left to current so current will point to null so as current is pointing to null so this condition is false but our second condition is true because stack is not empty and here you can see current is equal to null so this condition also comes out to be false and we go into the else part in the first step we are assigning stack peak's right value to temp so stack peak is node 5 this node and its right is this value so we are assigning null to temp and then we are simply providing this check because if temp is null then we know that current is already pointing to null which is the left part and temp is also pointing to null which is the right part so it signifies that its parent has no left and right children so we can simply visit the parent now so in the first step what we do is we poll the topmost element which is the which is the node 5 and we'll assign it to temp so first this will poll out and temp will point to 5 so we can safely visit this node because we have already visited its left and right children so 5 will be visited here and then we are providing this while loop which we will discuss when we reach here so just for timing thing that we are providing this while loop to check whether the node which we have visited is on the left or on the right side of its parent so currently stack dot peak is 2 which is parent to 5 and if we see here dot right is this value only and temp is also pointing to this node so this condition temp equal equal stack dot peak dot right is actually true because we are on the right side of the parent and we have already visited this node so now we can simply poll this element out and we can simply visit because we have already visited its left part and the right part so this while loop condition will come out to be true we are polling 2 out and temp will point to node 2 and then we are simply printing the data of this node by visiting it so 2 will be printed so as it is a while loop we are again checking that whatever node we visited just now is it on the left side or on the right side of its parent so the first condition stack should not be empty because we have recently polled an element out so there can be a possibility the stack is empty so here stack is not empty and the second check verifies that whatever the value we have here which is the parent to this node so here we are simply verifying that this temp is on its left or on its right side so temp is actually on the left side so this condition comes out to be false so our execution point reaches to this while loop where here you can see current is equal to null but stack is not empty so here current is equal to null so this condition comes out to be false in the else part we will assign stack.peak.right value to temp so stack.peak is 1 and its right is node 3 so temp will now point to node 3 moving ahead we check whether temp is equal to null or not so temp is not equal to null so this condition comes out to be false so if this condition would have come out to be true and temp would have point to null then we could have visited this node directly but as temp is not equal to null so there can be a possibility that this node can have left or right children so we simply go to the else part and we assign the value of temp to current so now current will point to this node because we have figured out that there can be a possibility that 3 can have left or right childrens so current will point to 3 so now this is the same situation which we saw in this start that current is not equal to null and if current is not equal to null there can be a possibility that there could be a left children of it so we are simply pushing the current onto the stack so 3 will be on the stack and then we go to its left by assigning current left to current so current will now point to null so as current is equal to null but stack is not empty this overall condition comes out to be true so we check whether current is equal to null or not so current is equal to null so in the else part we will assign stack's peak right value to temp so stack peak is node 3 and its right is 6 so not temp will point to 6 and here we check whether temp is equal to null or not but here you can see temp is not equal to null so there can be a possibility 6 can also have left or right children so in the else part we simply assign current to 6 current is not equal to null and in the if check also current is not equal to null and there can be a possibility that 6 can have left children so we push 6 on the stack and we go to its left by assigning current left to current so current will point to null now which is the left of 6 current is equal to null but stack is not empty so this condition comes out to be true and overall condition comes out to be true because of this or operator here the if condition comes out to be false because current is pointing to null and then we simply assign stack.peak.right to temp so stack peak is node 6 this node and its right is this node so temp will now point to null and here we are providing this check that if temp is equal to null which means that current is pointing to null and whatever its parent is its right is also pointing to null so we can safely visit this node which is the parent so how we can safely visit that node is first we'll pull that element out of the stack so 6 will be pulled out and temp will point to 6 we will visit this node so 6 will be visited now friends here we encountered a while loop and we discussed that why we are providing this while loop is because the first check is stack should not be empty so stack has two nodes therefore it's not empty now as we have recently visited this node so after visiting this node we need to be very much sure that whether this node was at left or was at right to its parent which is 3 we can access 3 by stack's peak which is by getting this value and if we call.right if we call.right then we'll reach here only so if temp is equal to this value only then we know that we are actually on the right side of temp's parent which signifies that we have already visited the left part we have completely visited the right part and now we can simply visit the parent so here we pull the parent out and temp will point to 3 we visit 3 and we again encounter the while loop so friends here you can see that this while loop is provided because if this is the condition here then here you can see that stack is not empty and as we have visited 3 so this 3 can also be the right child of its parent so therefore we are providing this while loop let's say if this chain goes on like this and there are no left nodes so this while loop will simply make us traverse back because all these nodes are on the right side of its parent which we already visited so that's why we are providing this while loop so here again we are simply checking whether temp is pointing to its parent's right or not so here stack.peak will give us 1 its right will give us node 3 and temp is also pointing to node 3 so this while loop condition will come out to be true and we can simply pull 1 out because we have visited all the left subtree of the node 1 and we have recently visited all the nodes on the right subtree of 1 so we can simply pull the 1 out temp will point to 1 and we can simply visit node 1 now so node 1 will be visited here and finally we again check whether stack is empty or not so here you can see we have recently pulled 1 element out so stack is empty so this condition comes out to be false and the while loop will terminate and once the while loop will terminate our call will go reach here so here you can see current is equal to null this condition is false and our stack is also empty which signifies that we have completely visited this binary tree using the postorder traversal so this whole condition will come out to be false so friends here you can see that using a stack we visited all the nodes of this binary tree using the postorder traversal so this was the sequence first 4 was visited then 5 got visited because before visiting 2 we need to visit its left part then we need to visit the right part and then we can actually visit the node so 2 was visited after that now we can't directly visit 1 because we need to traverse all the nodes of its right subtree so we reached here we saw that 3 didn't have any left part so we can't visit 3 directly we went to its right we saw that 6 left and right both are null so we simply visited 6 then after we visited 6 which was on the right side we safely visited 3 and 3 was also on the right side so we safely visited 1 so this is the postorder traversal of a binary tree so friends this was all about this video and in case you have liked this video then please like comment share and subscribe my channel thanks have a nice day hello everyone so in our previous lecture we discussed that how we can do postorder traversal of a binary tree using the iterative approach so in this video we'll code the algorithm and we'll test its working so here you can see in intelliJ I have created one class as binary tree so this class we created in our previous videos which has a root of type tree node so this is the private class inside this binary tree which simply has left and right children we discussed other traversal algorithms such as preorder in order and we also saw recursive and iterative approaches so in this video we'll see the postorder traversal of a binary tree using the iterative approach so here I will be creating one method as public void I'll give a name as postorder so here when we discussed postorder traversal using the recursive approach we saw that before visiting the nodes data we need to visit first its left subtree then we need to visit its right subtree and then only we can visit the nodes data so this was a recursive approach which got implied on each and every node of the binary tree so when we perform the iterative approach we usually use the while loop and we traverse each and every node of the binary tree keeping the postorder traversal in mind and the data structure will help us doing this is the stack data structure which is the leafo data structure which is also known as the last in first out so the last element inserted inside that data structure will be the first one to be removed so we discussed this algorithm step by step in our previous video using an animation so now let's code the algorithm and test its working so in postorder method the first thing we do is we create a tree node current which starts from the root of the binary tree whose traversal we need to do in the second step we create a stack which will hold our tree nodes we give it a name as stack and we are using java.utils stack class we can also use our stack which we discussed in our previous videos but here i will be using the java.utils stack now in order to perform the postorder traversal we need to provide a while loop and inside that while loop we provide a condition as current should not be equal to null or stack should not be empty so here you can see that current is pointing to root and we need to go inside this while loop to traverse each and every node of the binary tree using postorder so the first condition we provide is current should not be equal to null and when current is equal to null then the logic we apply will see later in the algorithm and the other thing is the stack should not be empty so here you can see in this while loop we provide a condition as current not equal to null so if current is not equal to null then it signifies that we can't visit the current directly we need to first go to its left subtree and visit that then we have to go to its right subtree and visit that and then only we can visit that particular node so if current is not equal to null so there is a possibility that current might have a left subtree so the first step we do is we simply offer or you can say push the current on the stack and after pushing current on the stack we simply go to its left by assigning current's left value to current and if current is equal to null then we provide else part where what we do is we create a temporary node and we assign the stack's peak values right to it so friends here if the current is pointing to null then we need to follow these steps to identify that whether that current is actually the left child of the parent or at the right child of the parent because if it is the left child of the parent then we can't visit parent directly we need to go to its right first but if it's the right child of the parent then we can simply visit the parent so if the current is equal to null in order to identify that the first thing we do is we take its parent which is on the stack and we'll simply assign the right value to temp so here after getting this temp there are basically two conditions one is what if the temp is also null so this check basically signifies that if temp is pointing to null and as we have moved to parents right and temp is pointing to null it means that there are no right children of the parent so we can simply visit the parent because when we do postorder traversal in order to visit the parent we first visit its left subtree and then we visit its right subtree and then only we can visit the parent and as we are on the right part and that is coming as null it means that we have visited the right part and now we can safely visit the parent so here what we do is we simply pop the element from the stack and assign it to the temp so once the temp is pointing to parent what we do is we simply visit the parent by printing its data on the console and after visiting the node we again provide a while loop and inside that while loop we provide the condition stack should not be empty because we have recently popped an element from the stack so stack can be empty so here we are providing this one condition that stack should not be empty till this point and so here as we have visited this node now this node can be a children of its parent and it can be on the left side or on the right side so there are also now two conditions coming up here if the temp is on the left side then we know that we need to go to the parents right now because we have visited the temp here but if the temp is on the right side then we know that we have once we have visited the right side we can simply visit the parent so here we need to provide one more condition as if temp is equal to stack.peak.write so this condition signifies that whatever the peak value is on the stack it would be parent to temp and if its right value is equal to temp it means the temp is on the right side so if it is on the right side then we can simply again pull the element from the stack assign it to temp and we can simply visit that and also friends as here we are popping out an element and visiting it we need to provide this in while loop because there can be a chance that whatever we are visiting it's actually coming out to be the right of the parent so once this condition comes out to be true and we pop the parent from the stack there can also be a chance that whatever we visited here will also be on its right of its parent so we need to provide this while loop because whenever we are visiting any element by printing it on the console here or here we need to simply perform this check that what we visited was at the right of its parent or was it at the left of its parent so if it is on the right of its parent which is this condition then we'll simply keep on popping the element out and simply printing its data because in the post order traversal this is the main step that once the right children of any node is visited then only we can visit the parent so here this condition is signifying that only so this was the part in the if condition and let's say if the temp is not equal to null it means that when we peek the parent element and we went to its right that was not null so before visiting right directly there can be a possibility that right also has left or right children so therefore these two checks are important if temp is null then we are sure that right is already visited we pop the element out we print its data and then we again check it for its parent but if the temp is not equal to null then we know that we need to visit the right part also and once we go to its right part the right part can also have its own left and right children so here now our condition becomes something like this what we did here so here what we do is we simply assign the value of temp because it is not equal to null to current so friend this was all about this algorithm now let's test it's working in the main method so friends here you can see that in our previous videos we created a binary tree with these hard coded values so where root was pointing to one one had two children's left and right as second and third these two second had two children's left and right as fourth and fifth these two and third noted left and right as sixth and seventh so these two nodes so here one is at the root second and third are its left and right children four and five are left and right children of two and six and seven are left and right children of three so this was the hard coded binary tree so here after creating this binary tree what we can do is we can simply call the post order and we can run the program so friends here you can see it printed four five two six seven three one here in this binary tree before visiting one which was the root we need to visit two and three so two was at left so when we reach to two we can't visit two directly because two also has left and right children which is four and five so when we reached to four we found that four didn't have any left and right children so the first thing we visited was four because this was the left of two and then we visited five because five was right of two and after visiting the left and right children we visited two here and once we visited two we know that we have visited all the left children of the actual root so now it was time to go to its right binary tree so when we went to one's right we found three so we can't visit three directly because three has a left and right children which is six and seven so when we went to six we found that six didn't have any left and right children so we safely visited six and then we safely visited seven because seven was right to three so after visiting six and seven which was the left and right children of three now we can safely visit three and once we visited three we were pretty much sure that we have visited all the nodes of the right sub tree of the actual root which was one so finally we visited one so friend this was all about the postorder traversal and in this video we demonstrated about the iterative approach using the stack data structure so here in case you find any difficulty you can watch my previous video to this which had all the things in animation so that it becomes more clear to you and in case you have liked this video then please like comment share and subscribe my channel thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video you friends in this tutorial we will discuss level order traversal of a binary tree in java so friends what is the level order traversal so here we use this traversal technique to visit the nodes of a binary tree level by level so here you can see the root is at level 0 2 and 3 are at level 1 4 5 6 are at level 2 so in this traversal technique we first visit the level 0 then we visit the level 1 and then we visit the level 2 so when we actually visit the node and print it data on the console so it will be like first one will be printed then 2 then 3 then 4 5 and 6 so here when we do a level order traversal of a particular level then we actually store the elements of its next level on additional data structure which is nothing but the queue so here suppose we are visiting the node 1 then on the queue we put the node 2 and node 3 so that after visiting the node 1 we can pull the node 2 and node 3 and we can visit them and while we are visiting the node 2 we put 4 and 5 on the queue and when we are visiting the node 3 we put node 6 on the queue so therefore it goes level by level and the additional data structure which we use to store this element is a queue so basically in this traversal we are using queue because it is a fee for data structure which is nothing but first in first out so the element inserted first will be the first to be removed we will see its significance when we demonstrate the algorithm so let's start the execution of this algorithm step by step so let's suppose we are given this binary tree where root is pointing to the node 1 so when this algorithm starts we first check whether root is equal to null or not so if root is equal to null then we simply return from the method because there are no nodes in the binary tree to be traversed and here you can see as root is pointing to the node 1 therefore the condition in if block comes out to be false and in next step what we do we first initialize the queue data structure so here you can see the queue data structure where nodes are entered from one end and they are removed from the other end so this property makes queue a fee for data structure that is the element inserted first is the first one to be removed and in order to know more about the queues you can watch my previous tutorials on the queue data structure and in this tutorial we will use the java implementation of the queue which is nothing but a linked list so we will initialize the queue by creating the instance of the linked list so after creating the queue what we first do is we offer the root node to the queue here offer is nothing but the in queue operation where we add the element to the queue so in the first step what we do is we offer the root node to the queue so it would look something like this as root is pointing to node 1 therefore in the first step what we do is we basically add node 1 into the queue so it would look something like this that is the node 1 is in the queue moving ahead so friends in order to traverse this binary tree using the level order traversal we basically use a while loop and inside this while loop we place a condition s that we will iterate this while loop till queue is empty so currently you can see queue is having one node which is node 1 therefore it's not empty so the condition in while block comes out to be true so in the first step what we do is we actually poll the element from the queue and we assign it to the temporary node so here you can see queue is having one tree node having data as one so when we perform a poll operation on the queue node 1 will be removed and its value will be assigned to temp so it would look something like this so node 1 is removed from the queue and temp is now pointing to the node 1 so whatever the value we pulled from the queue we simply assigned it to the temporary node moving ahead so after polling the node from the queue we simply print its data on the console so one got printed on the console it means we have visited the node 1 and as we discussed earlier that when we visit any particular level we store the elements of its next level on the queue so here we first check that whether temp dot left is equal to null or not so temp is pointing to node 1 and its left is pointing to node 2 therefore the condition in if block comes out to be true because temp dot left is not equal to null so in the if block we simply offer temp dot left element to the queue which is nothing but the node 2 so it would look something like this that now node 2 is on the queue moving ahead we then check whether temp dot right is equal to null or not so here you can see temp dot right is pointing to node 3 therefore it's not equal to null so the condition in if block comes out to be true and here we simply offer temp dot right which is the node 3 on the queue so now node 3 is also on the queue moving ahead now in the while loop we check whether queue is empty or not so currently queue has two nodes therefore it's not empty so the condition in while block comes out to be true and then we simply poll an element from the queue and we'll assign it to temp node so here you can see when we do a poll on the queue the element which was inserted first would be the first to be removed so therefore node 2 will be removed first and temp will point to the node 2 so it would look something like this that node 2 is removed from the queue and its value will be assigned to the temp so it means the temp is pointing to the node 2 moving ahead and then we'll simply print the data associated with the temporary node which is nothing but the 2 so 2 will be printed on the console moving ahead and when we are visiting the node 2 of any particular level then we have to add its left and right element on the queue so here first we will check whether temp dot left is equal to null or not so currently temp dot left is pointing to node 4 therefore it's not null so the condition in if block comes out to be true and then we will offer temp dot left to the queue which is nothing but the node 4 so now node 4 will be part of the queue moving ahead and then we will check whether temp dot right is equal to null or not so temp dot right is nothing but the node 5 and it's not equal to null so the condition in if block comes out to be true and we'll simply add the node 5 on the queue moving ahead we again check whether queue is empty or not so currently queue has 3 nodes therefore it's not empty so the condition in while block comes out to be true and then we'll simply poll the element from the queue so when we perform a poll operation the element which was inserted first is first to be removed so here you can see node 3 is the first element so now it will be removed from the queue and its value will be assigned to the temporary node so it would look something like this so node 3 is removed and its value is assigned to the temporary node so now temp is pointing to the node 3 moving ahead and then we'll simply print the data associated with the temporary node which is nothing but 3 so 3 gets printed on the console and then we'll simply check whether temp dot left is equal to null or not so here you can see temp dot left is nothing but node 6 therefore it's not equal to null so the condition in if block comes out to be true and then we'll simply store the node 6 on the queue moving ahead and then we'll check whether temp dot right is equal to null or not so here you can see temp dot right is equal to null so therefore the condition in if block comes out to be false because we are not storing the null value on the queue we again check whether queue is empty or not so currently queue has 3 nodes therefore it's not empty and the first step is simply poll the element from the queue and we'll assign it to the temporary node so here node 4 will be removed from the queue and temp will now point to the node 4 so it would look something like this so now temp is pointing to the node 4 and now we'll simply print the data associated with the temporary node which is nothing but 4 so 4 will be printed on the console and then we'll simply check whether temp left is equal to null or not so temp left is equal to null therefore the condition in if block comes out to be false and we'll check whether temp right is equal to null or not so temp right is also equal to null therefore condition in if block comes out to be false and then again in while loop we'll check whether queue is empty or not so currently queue has two nodes therefore it's not empty so the condition of while block comes out to be true and in the first step we'll simply poll the first element from the queue which is nothing but node 5 and we will assign it to the temporary node so it would look something like this so now temp will point to the node 5 moving ahead then we'll simply print the data associated with the temporary node which is nothing but 5 so now 5 will be printed on the console moving ahead coming right and then we'll check whether temp left is equal to null or not so currently you can see temp left is equal to null therefore the condition in if block comes out to be false and then we'll check whether temp right is equal to null or not so here temp right is equal to null therefore the condition in the if block comes out to be false and then we go to while loop and we'll check whether queue is empty or not currently queue has one node left therefore it's not empty so the condition in while block comes out to be true so we'll simply pull the element from the queue which is nothing but the node 6 and we'll assign it to temporary node so it would look something like this so the node 6 is removed and our temp will point to the node 6 moving ahead so finally we will print the data associated with the temporary node which is nothing but 6 so we have printed the data associated with the node 6 moving ahead we will check whether temp left is equal to null or not so currently temp left is equal to null therefore the condition in if block comes out to be false and then we'll check whether temp right is equal to null or not so temp right is equal to null therefore the condition in if block comes out to be false and finally we will again check whether queue is empty or not so currently here you can see queue is empty so therefore the condition in while block comes out to be false because queue is empty so there are no more nodes left to be traversed so therefore this while loop terminates and we know that we have visited all the nodes of this binary tree level by level so here you can see we first traversed node 1 then we visited node 2 then 3 then 4 then 5 then 6 so friend this is the algorithm for the level order traversal of a binary tree now let's go to Eclipse and see its working code so friends in my previous tutorial I created one class by name binary tree and we implemented the binary tree into this class so you can watch my previous tutorial to know more about how we have implemented the binary tree so in this tutorial I will be coding the algorithm for level order traversal of a binary tree so here I will be creating one method as public void and I will give the name to its level order so in this method we will be coding the level order traversal of a binary tree so in the first step we'll check whether root is equal to null or not so if root is equal to null then we'll simply return from this method because there are no nodes in a binary tree to be traversed and then we'll initialize a queue which will hold the tree nodes for us and here we are using the Java implementation of the queue so we'll import it from the Java.util package so after we create the instance of this queue we'll simply offer the root node now we'll create a while loop and inside this value will place a condition s that we iterate this while loop till queue is empty so inside this value will first create a tree node by name temp and to this temporary node will poll the element from queue and will assign its value to the temporary node and after polling the element from queue will simply print its data on the console so we'll do temp.data so after printing the data associated with the temp node we will store its left and right node on the queue so we'll first check that whether temp left is equal to null or not so if it is not equal to null then we'll simply offer it to the queue and similarly we'll do this for the temp right so I will just copy it and I will make it to temp right so friend this is the algorithm for the level order traversal of a binary tree now let's test is working in the main method so in the main method we'll first create the instance of this binary tree class and then we'll actually create the binary tree so here you can see I have created this binary tree with the few nodes so this is the binary tree which we discussed in the slide and in order to know more about this create binary tree method you can watch my previous tutorials so after creating this binary tree we will then call the method level order and if I run the code now so here you can see it printed one two three four five six seven which we actually discussed in the slide that it prints level by level so friends in this tutorial we discussed about the level order traversal of a binary tree I hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello everyone so in this video we will discuss that how we can find the maximum value in a binary tree and we'll discuss an algorithm which is recursive in nature so here you can see let's say we are given with this binary tree having nodes as four three seven five and eight and four is at the root so let's say we want to find the maximum value inside this binary tree so looking at this binary tree we know that eight is the maximum value but how to find whether eight is the maximum value in this binary tree is using this algorithm which is recursive in nature because here you can see the method name is find max which takes in a root and inside that it again calls find max so your find max method is calling itself at two places at line number six and line number seven so therefore this algorithm is recursive in nature so here the idea behind finding the maximum value in a binary trees let's say we know the value of fruit and we know what's the maximum value in the left subtree and what's the maximum value in the right subtree so we can simply compare the maximum value of the left subtree with the roots value and then we can compare with the maximum value of the right subtree and we can come to know what's the maximum value among these three values so this idea can be applied on each and every node recursively so for example if you want to find the maximum value of this binary tree having three nodes as three five and eight we can simply take the roots value then we need to calculate the maximum value of the left subtree and the maximum value of right subtree and we need to simply compare these three values and we will get the maximum value till this node so this algorithm is recursive we need to apply these three steps on each and every node and using this algorithm will also traverse each and every node because in order to find which is the maximum value among this binary tree we need to traverse each and every node so let's the demonstration of this algorithm step by step so that the idea of finding the maximum value inside this binary tree will be more clear to you also here you can see as this algorithm is recursive in nature when find max will get executed it will internally call again the find max so in order to keep the track of these methods we will create a table which will be nothing but our call stack so let's see how this algorithm and this call stack works together so the first step we are calling the find max method and we are passing in the root of the binary tree whose maximum value we need to calculate so on the call stack you will find one find max method whose root is pointing to a node having value as 4 so here you can see that this table has five values line number root result left and right so as the algorithm is recursive in nature when we will leave this find max method and we will again call find max will simply keep the track of the line number here we will keep the track of the root result left and right which we will see later how they are important moving ahead so here as the algorithm is recursive in nature we need to provide a base case so that we can exit from the algorithm if we don't provide this base case then this find max will again call find max and it will go on because there will be no end so we need to provide this base case that if the root is null here then we can simply return the minimum value from here so for example if the root is pointing to null so we will simply return the minimum integer value because null can signify that this is the minimal value as the return type is integer we need to return a value so we simply return the minimum value of the integer because the minimum value of integer won't affect the maximum value of this binary tree so here currently we are providing a check that if root is equal to null then simply return the integers minimum value so currently root is pointing to 4 therefore this condition comes out to be false also friends we discussed the idea that how we can find the maximum value of any node and its left and right children is finding the maximum value of this left sub tree finding the maximum value of its right sub tree and comparing it with the roots value so here this three line will do that in the result we are simply storing the roots value so here in the result it will be coming as 4 moving ahead so now we'll traverse to the left of this binary tree in order to find the maximum value of the left sub tree so we are simply again calling the find max method but this time we are passing in root start left so root is pointing to 4 and its left is pointing to 3 so 3 will be our new node and here you can see we are leaving this find max method at line number 6 so we'll simply keep the track of line number here so that when this find max will end we know that where to start this find max so we'll simply store the line number which is 6 and we will again call the find max method passing in roots left node so on the call stack it would look that find max method is called we have left this find max method here at line number 6 and we are again called find max and this time the root is roots left which is 3 so now root will point to 3 moving ahead root is not equal to null again we will apply the algorithm recursively on this node so first we will store the roots data so which is 3 now in order to find the maximum value till this node is we need to find the maximum value of its left subtree we need to find the maximum value of its right subtree and we need to compare those value with the roots value so first we'll go to the left of this root so we will call find max again and this time we'll pass roots left which is 5 but we are leaving this find max method so we'll keep simply keep the track of this line number so which is 6 so now find max will be called again with roots left which is 5 so one new root will become 5 root is not equal to null so this condition comes out to be false and now we'll apply our algorithm recursively to this node we'll first store the roots data in the result which is 5 and then we will again call find max method to simply calculate what's the maximum value of its left subtree and we are leaving this find max method at line number 6 so we'll simply store line number 6 here so there will be one more method on the call stack but this time the roots value will be null because 5's left is null here we are calling roots left so roots left is null so now root will point to null here we'll check whether root is equal to null or not so here you can see that we have encountered a base case that root is equal to null so here we will simply return the minimum value of the integer because as roots left is null so there are no more nodes to traverse and we will simply return the least value of the integers which is integers min value whose value is this because this value is negative in number therefore it won't affect the maximum value of this binary tree and as the left child is null so we can simply return the minimum value of the integer so we are returning the integers min value so here you can see that we are leaving this find max method here and once we leave this find max method here this call will go to this method because this find max method had called this find max method and we also know that we had left at line number 6 so we'll start our execution from line number 6 and as we are returning the integers min value so this find max method will get that value so it would look something like this this method will be removed from the call stack execution point will reach here we will start our execution from line number 6 because we had left this method at line number 6 and here you can see whatever the value this find max method returned we will simply store in this integer variable left so which was the integers min value so in the left we will simply store the minimum value of the integer so I am simply denoting it by IMV here and when we were executing this find max method here you can see root was pointing to 5 so again root will point to 5 and we will proceed ahead with this method so here you can see we have this roots value which is 5 we have calculated the maximum value of the left now we will calculate the maximum value of the right so we'll again call the find max method but this time we'll pass the roots right value so here you can see that we will again have to leave this method at line number 7 this time and we will call find max method again passing in roots right which is null so it would look something like this line number is updated here find max method will be called and there will be one more method on the call stack with root as null so now root will point to null and why this root is pointing to null because we have called find max method by passing roots right which is roots right is null so here now root is equal to null so we'll simply return the minimum value and this method will be removed from the call stack and the execution point will reach again on this method and we'll start our execution from line number 7 so this method returned the integer minimum value which will be stored in the right here and when we have left this find max method root was pointing to 5 so now root will again point to 5 and the execution will continue from here so you can see now we have got all the three values to compare the roots value the maximum value of its left subtree and the maximum value of its right subtree so now we can simply perform this comparison for this node so here we'll check whether left is greater than result or not so left value is the minimum value of the integer so therefore this condition comes out to be false because value of left is integers minimum value and result value is 5 so 5 is greater than left so this condition will come out to be false we'll check whether right is greater than result or not so right value is also integer minimum value so this condition also comes out to be false and here you can see that among this node the maximum value is of the root which is 5 so we'll simply return 5 from this find max method so now here you can see this find max method will be removed from the call stack and the return value will be 5 so this method will be removed from the call stack the execution point will reach here and we know that we have left this find max method at line number 6 so we'll start execution from line number 6 this find max return the value as 5 so this 5 will be stored in the left variable here and when we left this find max method root was pointing to 3 so now root will point to 3 moving ahead so friends for root 3 we have already calculated the maximum value of its left subtree which is 5 here now we need to simply calculate it for right subtree so we'll again call find max method and this time we'll pass roots right which is 8 so we will be leaving this method at line number 7 here and there will be one more method on the call stack with now new root as 8 so root will point to 8 now we check whether root is equal to null or not so root is not equal to null we will store roots data which is 8 and now similarly we'll perform this recursive algorithm for the root 8 now so here you can see friends these three steps we need to perform on each and every node so what we did for 5 now we'll again do it for 8 so we'll simply go fast here because we already seen what happens when the nulls are encountered so first we'll update the line number which is 6 and there will be a find max method in the call stack because now we are going to roots left so roots left is null so this find max will be called with null value root will point to null and root is equal to null so we'll simply return the integers minimum value and this method will be removed from the call stack and integers min value will be returned to this find max method so it would look something like this we'll start execution from line number 6 where root will now point to 8 and the integers minimum value which was written from this find max method will be stored in the left here and similarly now we'll go to roots right so we'll update the line number here so find max method will be called again with the root as null root will be pointing to null and here root is equal to null so we'll simply return the minimum value of the integer so this method will be removed from the call stack and this method will start execution from line number 7 now where root will now point to 8 because when we left this find max method root was pointing to 8 so root will point to 8 now and the integers minimum value which was written from this find max method will be stored in the right now and now as we have got these three values to compare we will check whether left is greater than 8 or not because we need to find the maximum value so left is not greater than 8 so this condition comes out to be false right is also not greater than result because right is storing the integers minimum value and 8 is greater than this value so this condition also comes out to be false and we'll simply return 8 from this method because we have found the maximum value of this right subtree which is 8 so we'll simply return 8 from this find max method so this method will be removed from the call stack and the execution point will reach to this method where we had left at line number 7 so we'll start from here and here root value was 3 so now root will point to 3 and we know that from the right we return the value which is maximum as 8 so 8 will be stored in the right here so friends here you can see for this small binary tree we got the three values 5 was the maximum in the left subtree 8 was the maximum in the right subtree and we'll simply compare it with the root which is the result value so here we'll perform the comparison so we'll check whether left is greater than result or not so this condition comes out to be true because left value is 5 which is greater than 3 so we'll simply update the value of result with the maximum value which is 5 so this will become 5 we'll check whether right's value is greater than result or not so value of right is 8 which is greater than result which is 5 so this condition also comes out to be true so we'll simply update the maximum value which is 8 into the result so this will become 8 and then we'll simply return 8 so from this find max method we are returning 8 which is the maximum value among these three nodes so this method will be removed from the call stack and this method will start execution from line number 6 where root was pointing to 4 so root will now point to 4 and the value which this find max method return which was 8 will be stored in the left so here you can see that for the actual root of the binary tree we figured out what's the maximum value in the left subtree which is 8 so now we need to simply find the same for the right subtree we'll start our execution from line number 6 again and now we'll simply go to its right subtree by calling the find max method and passing in the root's right value which is 7 so this method will be removed from the call stack and we'll simply store the line number 7 because we need to keep the track of this recursive nature algorithm so line number will be updated as 7 there will be one more method find max having the root point to 7 because we have left from line number 7 passing in root's right value so root was 4 and its right value is 7 so 7 will be our new root for this find max method and friend similarly we will apply this algorithm recursively on this node now what we seen with 5 and 8 so we'll simply quickly go over this algorithm root is not equal to null we'll store the root's value in the result field which is 7 we'll recursively go to the left subtree now here by passing in root's left as we are leaving at line number 6 we'll store line number 6 there will be new method on call stack with root pointing to null now because we are going to its left now so this root will be null and we'll simply return the integer minimum value from this find max method we'll start our execution from where we left at line number 6 where root was pointing to 7 and the value which this find max return was integer minimum value so we'll simply store in the left and similarly for the right it will perform the same we update the line number here we'll leave this method we again call find max with root's right which is null so there will be one more method on the call stack having value of root as null so root will point to null we'll simply return the integer's minimum value because root is equal to null so this method will again come on the call stack and we'll start execution from line number 7 now so here root will now again point to 7 and this method had written integer's minimum value which we'll simply store in the right here and now we'll simply compare this three value 7 left and right and we know that 7 is the maximum value so these two conditions will come out to be false because left is not greater than result and right is also not greater than result so this both the condition will come out as false and we'll simply return 7 from this find max method because 7 is the maximum value of the right subtree for the actual root so this method will return 7 execution point will reach here we had left at line number 7 so we'll start executing from line number 7 where root was actually pointing to 4 so root will point to 4 and the find max method which got executed before this find max method had written value as 7 so 7 will be stored in the right so here you can see for this complete binary tree now we have actually got all the three values the root's value the maximum value of the left subtree and the maximum value of the right subtree so we'll simply compare these three values and get the maximum value of this binary tree complete so we'll check whether left is greater than result or not so value of left is 8 which is greater than result which is 4 so we'll simply update the value of left into result so result becomes 8 now we compare whether value of right is greater than result or not so right value is 7 which is not greater than 8 so this condition comes out to be false and finally we'll return the value 8 which is the maximum value among this binary tree so this method will terminate here and on the call stack this will get removed returning the maximum value of this binary tree which is 8 so friends here you saw a very long demonstration of this algorithm where we applied this algorithm recursively on each and every node to find what's the maximum value of the binary tree so friends the complexity is involved in this recursive nature which we demonstrated using the call stack and once you understand how this call stack works you can simply code the algorithm related to binary tree recursively now let's go to intelligence C the working of this code so friends I hope you have liked this video and in case you have liked this video then please like, comment, share and subscribe my channel thanks have a nice day hello everyone so in this video we'll see the demonstration of the algorithm and how we can find the maximum value in a binary tree so in our previous video we saw the demonstration of the algorithm step by step so in this video we'll simply code the algorithm and see it's working so here you can see in our previous videos we created one class as binary tree which had a root as an instance variable of type tree node so this is the class of tree node which we created in our previous videos and we saw different algorithms so here let's say we are given this binary tree and let's say we provide a maximum value in this binary tree as 8 and rest of the value we keep as it is now we want to write an algorithm where we can find the maximum value of this binary tree so friends here in case if you find any difficulty you can watch my previous videos where we have demonstrated each and every line of this code step by step and we have demonstrated all these algorithms step by step so let's code the algorithm to find the maximum value of a binary tree so here we have created one method at find max whose return type is integer because we want to return the maximum value of a binary tree so here we will simply return find max we will pass in the root because we need to pass a root to find the maximum value of a particular binary tree which we also saw in our previous video so here we will create a method as public whose return type will be integer find max and this is the method which will take the root of the binary tree and will simply return the maximum value of this binary tree so here this is our binary tree whose maximum value is 8 so let's see the code to find the maximum value of this binary tree so as we discussed in our previous video that this algorithm is recursive in nature the first thing we provide is the base case we simply check whether root is equal to null or not so if root is equal to null we will simply return the minimum value because as root is null it simply signifies that we can simply return the minimum value of the integer so here we need to find the maximum value of this binary tree and if root is coming out as null then we need to return an integer value so we can safely return the minimum value of the integer because beyond that there won't be any minimum value and our task is to find the maximum value so this minimum value won't affect the maximum value of this binary tree so after providing this if check for the base case the first step is to store the roots value so we are creating an integer value result and we are storing the roots value into this result and also we discussed the basic idea behind this algorithm is in order to find the maximum value of a binary tree we simply compare the roots value to the maximum value of its left subtree and also we will compare this value with the maximum value of its right subtree so when we compare these three values we come to know what's the maximum value of a binary tree so this algorithm is very recursive in nature and this is applied on each and every node of the binary tree so where we simply store the roots value then we go to its left subtree to find the maximum value of the left subtree once we get that value then we go to its right subtree and we find the maximum value of the right subtree and after we get these three values we compare them with each other and we get the maximum value of the complete binary tree so here after getting the roots value we simply try to get the maximum value of the left subtree by calling the findMax method recursively providing roots left value so here we are simply providing the roots left which is the left subtree of this root and whatever the value this findMax method will return will simply store in the left variable and similarly we do it for the right subtree we call findMax recursively providing roots right value so in order to see how this recursive nature works you can watch my previous tutorial where we demonstrated this recursive nature with an animation so you can watch that and here after finding all these three values will simply compare it with each other so the first step will compare whether left value is greater than result or not so if left is greater than result we simply update the result with the left because at the last we need to send the result and which should be the maximum value so first we are comparing left with result and then we are comparing right with result so if the value of right is greater than result we are simply updating the value of right to result and at the last we are simply returning result so here you can see that we are comparing all these three values here if left is greater than result we are storing the greater value in the result and then we are again comparing whether right is greater than result or not and if right is greater than result then we are storing the value of right into result and finally we are returning result because this will be the maximum value among these three values so here you can see this is the algorithm to find the maximum value of a binary tree so lets test its working in the main method so first we are creating this binary tree with these values where we know that 8 is the maximum value and here we are simply printing the maximum value by calling the findMax method which internally will call this findMax method providing in the root which is this root and this root is being created here with this createBinaryTree method so after we create this binary tree with these hard coded values and when we will call the findMax method we will get the maximum value of this binary tree so here you can see it printed 8 because 8 was the maximum value of this binary tree now lets say if i update any value to 10 and if i run the code again you can see answer came as 10 because 10 is the maximum value of this binary tree so friends here we saw the algorithm to find the maximum value of any binary tree which was basically recursive in nature where we compared the three values one was the root value we compared it with the maximum value of its left subtree and we compared it with the maximum value of its right subtree here and finally we returned the result which was the maximum value of the complete binary tree and this algorithm we applied on each and every node of the binary tree because this is recursive in nature and in order to see the complete animation of this recursive nature you can watch my previous video so friends this was all about this video i hope you have liked this video and in case you have liked this video then please like, comment, share and subscribe my channel thanks have a nice day how to represent a binary search tree in java in our previous tutorial we actually discussed about the binary tree we saw that each and every node in the binary tree had two children one was the left child and one was the right child so a binary search tree is a special type of binary tree in which the data is organized in an ordered manner which helps us in faster search and insertion of the data so how binary search tree helps us in faster search and insertion of data we will see later first we will discuss the three properties which makes it a binary search tree so here in the diagram you can see a binary search tree which satisfies these three properties so the property one says the left sub tree of a node contains only nodes with values lesser than the nodes value so what does it mean let's suppose if we take a node having data as 6 so all the nodes to its left like 4, 2, 5 they have values lesser than 6 so if you see there are three nodes to the left of 6 and if you compare the values of these three nodes with 6 you will find that 4 is less than 6 2 is less than 6 and 5 is less than 6 so all the nodes to left of a particular node should have values lesser than the nodes value and similarly if you go to right of any particular node then all the values should be greater than the nodes value so if we take the example of node having value as 6 and if we go to its right we see there are three nodes having data as 8, 7 and 9 all the values are greater than the nodes value so here in the binary search tree we are keeping the data in ordered form that from a particular node if we go to its left we will only find the values lesser than the nodes value and if we go to its right we will only find the nodes having values greater than the particular node so from the third property says the left and the right sub tree each must also be a binary search tree so from here we saw that node 6 is following these two properties that all the values to its left are lesser than the nodes value and all the values to its right are greater than the nodes value and in a binary search tree these two properties should be true for each and every node of the binary search tree so for example if we take a node having value as 4 then we can see that to its left there is only one node and its value is 2 which is less than 4 and if we go to its right then there is only one node whose value is 5 which is greater than 4 so 4 also satisfies these two properties and similarly if you are on node 2 then it doesn't have any left and right check therefore it also satisfies these two properties and if these two properties are satisfied by all the nodes of a tree then that tree is called as binary search tree so here in this diagram you can see that it is a binary search tree so suppose if I change a value here and I make it a value as 8 so here you can see that node with a value as 4 if we go to its left we are getting a value lesser than the nodes value and if we are going to its right then we are getting a value greater than nodes value so 4 satisfies these two properties but if we go to the parent of 4 here you can see the value is 6 and we know that all the nodes of a left subtree should be lesser than the nodes value so here you can see 4 to 8 should all be less than the nodes value but 8 is greater than 6 therefore this is not a binary search tree because these two properties should be true for each and every node and if you are on a particular node then we take all the nodes of its left subtree and right subtree and we compare it with the nodes value so here you can see 4 and 2 are lesser than 6 but 8 is not lesser than 6 therefore it is not a binary search tree and similarly if I take a value of 5 here then you can see that if here at node 8 then if we go to its left we see that value of 5 is lesser than 8 and if we go to its right then we have node 9 and value of 9 is greater than 8 so 8 satisfies these two properties but if we go to the parent of 8 which is nothing but 6 so here you can see that it is not a binary search tree because from property 2 the right subtree of a node contains only the nodes with values greater than the nodes value so if we see the right subtree from the node 6 we see it has 3 nodes and all these 3 nodes should have values greater than 6 but here you can see 8 and 9 have values greater than 6 but 5 is lesser than 6 therefore this tree is not a binary search tree so from all these 3 properties if satisfied by each and every node of a binary tree then it becomes a binary search tree below these 3 properties makes the search and insertion of data faster because let's suppose if we want to search for a value 5 in this binary search tree then we simply check the value 5 with the root of the tree so here you can see that 5 is not equal to 6 and as it is a binary search tree we know that 5 must be lying somewhere to the left of this tree because it satisfies these 3 properties and we know that the left subtree of a node contains only values lesser than the nodes value so we know that 5 must be lying somewhere to the left of node 6 so from node 6 we traverse left and we reach to 4 and also here you can see when we are traversing to node 4 we are simply discarding all the nodes of the right subtree because we also know that 5 can never lie to the right of 6 so let's suppose if we had a binary search tree having many nodes then we could have simply discard half of the nodes and we would have continued our search to either right or to left of the search tree so friends if we compare 5 to 4 then we know that 5 is greater than 4 so 5 must be lying somewhere to the right to 4 and then we simply traverse to its right and we discard the left subtree of the node 4 and finally we found the node having data as 5 so friends when we want to insert a data into binary search tree we usually follow these 3 properties only so let's say if we want to insert a node having data as 10 then we simply start from the root node we check the value of root to the data which we want to insert so here if we compare the value 6 with 10 then we know that 10 is greater than 6 therefore it should be inserted to its right so we traverse to its right and we see there is one more node so we compare this value with the value which we want to insert so here 10 is greater than 8 therefore we know that 10 must be inserted to its right so we simply traverse to its right and we find there is one more node having data as 9 so we check that whether 10 is greater than 9 or not so here 10 is greater than 9 so we go to its right and we find that there is no node because 9's right is pointing to null so we simply insert node at that place so friends this is how search and insertion of data gets faster in binary search tree because in each iteration we discard half of the tree as we know that we either want to traverse to right or to left so friends this is the usefulness of binary search tree moving ahead so friends if we see the structure of tree node in a binary search tree then it is very similar to binary tree that this tree node is nothing but the inner class of binary search tree which has basically the three properties one is the data property to hold the data and other two properties are nothing but the references to the left sub tree and the right sub tree we also provide a constructor to this tree node class which takes in a data part so whenever we want to create a new tree node we simply pass in the data property and left and right property actually points to null so friends lets go to eclipse and see the implementation of binary search tree hello friends in this section we will discuss how we can implement a binary search tree so friends here I have created one class by name binary search tree which is having a main method and we also discussed in our previous tutorial that binary search tree is nothing but a binary tree so friends the initial implementation of binary search tree is very similar to binary tree in binary search tree class we will create an instance variable of type tree node which would be nothing but the root of the binary search tree so here we can see the type is of tree node so we will create an inner class we will give it a name as tree node so friends here binary search tree is a type of binary tree therefore the implementation which we saw in the binary tree is very much similar to binary search tree that we have created by inner class by name tree node also friends in our previous tutorial we discussed that a tree node consists of three parts one is the data part so private int data so this property will hold the data of the tree node here I have taken the type of this data as integer so it can be any generic type as well also friends we know that binary search tree is a type of a binary tree where each tree node has two children one is the left children and one is the right children so we will create a tree node and we will give it a name as left and we will create one more tree node and we give it a name as right so basically a tree node has two children one is the left and one is the right inside this tree node class we will also provide a constructor so public tree node and this constructor will take the data part so we will initialize the data of this tree node with a value which we have passed into the constructor and also friend whenever the new tree node is created the left and right points to null so friend this is how we actually represent a binary search tree in java in our upcoming tutorial we will actually see how we can insert and how we can search a node into a binary search tree so friends I hope you like this video thanks have a nice day hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss how to insert a value in a binary search tree in java and also friend in this tutorial we will discuss the recursive approach to insert a value in a binary search tree so friends below you can see the code to insert a node into a binary search tree so here the insert method takes in a root node and the value which you want to insert also friends here you can see insert method internally calls insert again therefore its nothing but a recursive call so in order to keep the track of this recursion we will use the call stack and based on this call stack we will see the demonstration of this algorithm step by step so friend lets suppose currently binary search tree has no nodes and when the binary search tree is empty we know that root will point to null now lets suppose we want to insert a value phi into this binary search tree so here you can see on the call stack there will be one insert method and currently as root is pointing to null therefore here we can keep the track of the root which is pointing to null and we can also keep the track of its left and right tree node which are also null and the last column will have the value which we want to insert moving ahead so friend in first I will see that whether root is equal to null or not because as we are going into this recursion here we have to provide a base case so that we can come out of this recursion so our base case condition would be to check whether root is equal to null or not so currently here you can see binary search tree is empty therefore root is equal to null so the condition in if block comes out to be true and inside this if block as you want to insert this value phi therefore first we will create a tree node and provide the value as phi so it would look something like this friends in our previous tutorial we discussed that when we create a new tree node we actually pass the value into the constructor of tree node so in this tree node the data is the actual value which is 5 and as it is a new tree node therefore left and right are pointing to null and also friends as we are creating this tree node we are assigning it to the root so it would look something like this that root will point to a tree node having data as 5 and also friends here will provide the value as 5 that root is now pointing to 5 moving ahead and then we will simply return the root so here insert button will come to an end and it will be removed from the call stack so friends when binary search tree was empty we have inserted one node having data as 5 now lets suppose we want to insert one more value the value which we are inserting is 3 and here we also know that root is now pointing to a node having data as 5 so on the call stack it would look something like this that root is 5 its left and right are null and the value which we want to insert is 3 so on the first step we will check whether root is equal to null or not so here you can see root is not equal to null therefore the condition in if block comes out to be false so friends in our previous tutorial we actually discussed what is the binary search tree we discussed the 3 properties which binary search tree follows property 1 was lets suppose if we are on a particular node which has some value and if you try what shows left then all the nodes value to its left would have values lesser than the nodes value and if you go to its right then all the nodes value would be greater than the node value and these 2 properties should be true for each and every node of the binary search tree so friends when we insert a new node we actually check for these 2 properties so here you can see we have provided an if block and inside this if block we have provided condition as that whether value is less than root.data value so here you can see root.data is nothing but 5 and the value which we want to insert is 3 so here you can see the value is actually less than root.data value so here if you want to insert a new tree node having value is 3 then we can only insert into the left subtree of the root because value is less than root.data so therefore the condition in if block comes out to be true so friends here you can see we are again calling the insert method and we are passing the value as root.left and the value which we want to insert so on the call set there will be a new insert method and as there would be a new insert method we will be leaving this insert method and we will again calling the insert method so we need to keep the track of the previous insert method so we know that we have given the line numbers here and we know that we are leaving this insert method at line number 7 so we will simply put a value of 7 in the line number column and we will call the insert method and this time we will pass root.left as a new root so it would look something like this that there would be a new insert method on the call stack and here we know that root.left is null therefore for this insert method root will be null and left and right would be null and the value which we want to insert is 3 so here root will be pointing to null now and we will again check whether root is equal to null or not so here you can see root is equal to null and then we will create a new tree node and we will pass the value into its constructor and we will assign it to the root so it would look something like this a new tree node is created having the value as 3 and left and right are pointing to null so now root will point to this tree node moving ahead so here now root is pointing to 3 and finally we will simply return from this insert method so friend as soon as we return from this method this insert method will be removed from the call stack and the execution point will reach to the insert method which was executed just before that and we also know that we have left at line number 7 so we will start the execution from line number 7 so it would look something like this so now we are starting again this insert method from line number 7 and when we had left this insert method root was pointing to 5 so here root is now pointing to 5 and as we had written root which was nothing but 3 it will be assigned to roots left so here you can see root is pointing to 5 and roots left is pointing to null therefore whatever we return from previous insert method it will be assigned to roots left so it would look something like this moving ahead now root left is 3 and then finally we will simply return the root so the execution of this insert method will be complete and it will be removed from the call stack so friends here we have inserted 2 nodes now let's suppose we want to insert a value 7 so it would look something like this first insert method will be created on the call stack having root as 5 whose left is 3 and whose right is null and the value which you want to insert is 7 we will check whether root is equal to null or not so here you can see root is pointing to a node having data as 5 therefore it's not null and using the binary search tree properties we will check that whether value which we want to insert is less than root.data or not so here you can see root.data is nothing but value 5 and here we are inserting a value 7 therefore the condition in if block comes out to be false we are inserting a value 7 which is greater than the roots value therefore it must be inserted to the right sub tree of the root so now else block will be executed now here we want to insert the value to roots right therefore we are again calling the insert method and this time we are passing in a value as root.right so here you can see root is pointing to a node having data as 5 and its right is pointing to null and as you want to insert a new node to its right therefore we are simply calling the insert method and we are passing root.right with a value which you want to insert and also here we are again calling the insert method we are leaving this previous insert at line number 9 so we will simply put a value of 9 into the line number column that we are leaving this insert method at line number 9 so now on the call set there would be a new insert method and as we have passed in root.right so here you can see root.right is null so we are executing this insert method with root as null and left and right are null and the value which you want to insert is 7 and friends as this insert method is getting executed root is pointing to null so root is pointing to null we are checking whether root is equal to null or not so here root is equal to null and as you want to insert this new tree node having value as 7 we will simply create a new tree node and pass a value 7 to its constructor and then we will assign it to the root so it would look something like this the root will now point to a tree node having data as 7 and whose left and right are pointing to null so here root becomes 7 and finally we simply return the root so when we return the root execution of this insert method gets completed so it would be removed from the call stack and the execution point reaches to insert method which was getting executed just before this insert method and we know that we had left this insert method at line number 9 so we will start our execution from that point so friends here once the insert method gets executed we had return the value 7 and once the execution starts from line number 9 we know that at that point root was pointing to 5 so root will point to 5 and we also know that we have written node 7 from the insert method so therefore simply assign whatever you return from the insert method to root.right so here root is pointing to node 5 and its right is pointing to null therefore node 7 will now point to root's right so it would look something like this so here now right will become 7 and then we will simply return from this insert method so this insert method will be removed from the call stack so friends here we inserted 3 nodes now lets suppose we want to insert one more node having value as 1 so in the first step we will call the insert method providing in the root and the value as 1 so here root is pointing to 5 and left is pointing to 3 and right is pointing to 7 and the value which we want to insert is 1 in the first step we are checking whether root is equal to null or not so root is not equal to null so friends as it is a binary search tree we are checking whether value which we want to insert is less than root's value or not so here you can see 1 is less than 5 therefore we are sure that the value 1 will be inserted somewhere to its left sub tree so therefore the condition in if block comes out to be true because 1 is less than 5 and here we are again calling the insert method by passing in root.left and the value so here root.left is nothing but 3 and as we are leaving this insert method we will keep the track of the line number so we are providing value as 7 so now the insert method will be called with root.left which is nothing but node 3 so for this insert our root will become 3 so here you can see there will be a new insert method where root will be 3 and left and right are null and the value which we want to insert is 1 so here now root will point to 3 we will check whether root is equal to null or not so root is not equal to null and then we will check whether value which we want to insert is less than root.data or not so here 1 is less than 3 so we know that 1 should lie to the left sub tree of the root having value as 3 therefore we are again calling insert method by passing in to the value as root.left so here root.left is nothing but null and as we are leaving this insert method we will keep the track of the line number which is nothing but 7 so here a new insert method will be on the call stack having root as null because here we are passing root.left so root.left is nothing but null so now root will point to null moving ahead we will check whether root is equal to null or not so here you can see root is equal to null and then we will create a new tree node by providing it the value as 1 and that tree node will assign to the root so it would look something like this that now root is pointing to a node having data as 1 and whose left and right are pointing to null so now root is pointing to 1 and then we will simply return the root so we are simply returning the tree node having data as 1 so when we return this tree node we know that this insert method is completed execution point reaches here and we will start our execution from line number 7 so at line number 7 when we had left this insert method root was pointing to 3 so now root will point to 3 and we know that to root left we have assigned the value which we had returned from the insert method so root.left is null and the value which we returned from the insert method was nothing but 1 so therefore now root.left will point to the tree node having data as 1 so here left will now become 1 and it would look something like this and finally we will simply return root so when we return root this insert method will be completed and it will be removed from the call stack and the execution point reaches to the insert method and we will again start execution from the line number 7 and at that point root was pointing to 5 so therefore now root will point to 5 and as we have returned tree node having value as 3 that would be assigned to root.left so here root is pointing to a node having data as 5 we will simply assign the value 3 to root.left so it would look same and finally we will simply return the root so the insert method will be completed and it will be removed from the call stack so friends here we inserted 4 nodes into binary search tree by applying the properties of binary search tree that suppose if we are on a particular node then all the values of the nodes to its left would be lesser than the nodes value and all the values to its right subtree would be greater than the nodes value so here you can see 3 and 1 are lesser than 5 therefore they lie on the left subtree of this node and here you can see 7 is greater than 5 therefore it is lying on the right subtree now friends lets go to Eclipse and see the working of this code hello friends in our previous tutorial we actually discussed how we can insert a node into a binary search tree so in this tutorial we will actually code how to insert a node into a binary search tree so first we will create an insert method so public void insert and to this insert method we will actually pass the value which we want to insert and insert is insert method we will simply call the insert method which we actually discussed in the slide so we will pass root and the value which we want to insert and here we will create a method as public whose return type would be tree node name would be insert taking in parameters as root and the value which we want to insert friends in our previous tutorial we actually discussed the recursive way to insert a node into a binary search tree so here we will first provide a base case that if root is equal to null then we will simply create a new tree node by passing in the value and then we will simply return the root so this would be our base case and if root is not equal to null then we provide the condition which binary tree satisfies that if value which you want to insert is less than root's value then we simply traverse to its left and we will again call insert method by passing in root left and the value which we want to insert and if value is greater than root's value then in the else part we simply traverse to the right subtree by calling insert and providing the values root.right and the value which we want to insert so whatever the insert method will return we will simply assign it to the root's left and in the else part whatever the insert method will return we will simply assign to root's right and finally we will simply return root so for example in our previous tutorial we actually saw how this insert method works step by step now let's test this working into the main method so first we will create the instance of binary search tree and then we will insert few nodes which we actually saw into the slide so with the value as 5 3 7 and 1 so friends after inserting this 4 nodes we will simply print it on the console whether they are inserted in the right order or not so friends in order to print the nodes on the console I will code the algorithm for in order tree traversal which we actually discussed in our previous tutorial when we discussed about the binary tree so in order so here it simply will call in order by passing in the root so here we will provide in order method which will have the root so we had also discussed that will first so friends we also discussed that in order traversal we first check whether root is equal to null or not so root is equal to null will simply return and in this traversal we also discussed that first we visit the left subtree of the root then we actually visit the root and finally we visit the right subtree also friends here you can see that first we are going to the left of the root then we are actually printing the root strata and then we are going to its right so friends binary search tree also follows one property that if we do the in order traversal of a binary search tree then the nodes will be printed in sorted form so lets see how so will simply call in order which will internally call the in order and will pass root into it so if I run the code now so friends here you can see it printed 1357 and also you can see that numbers are in sorted order because if we perform in order traversal on the binary search tree we get the traversal in sorted order so friends which actually proves that whatever we inserted into the binary search tree followed these three properties friends I hope you like this video thanks have a nice day hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss how to search a given key in a binary search tree also in this tutorial we will see how we can search a given key in a binary search tree using recursion so friends lets suppose we are given a binary search tree and we want to search a particular value inside this binary search tree so below you can see the algorithm to search a given key in a binary search tree also friends the method which we are going to call is search method and here inside this search we are again calling search method therefore in this algorithm we are basically using recursion so friends in order to keep the track of this recursion we are basically maintaining a call stack whose significance we will see while demonstrating the algorithm step by step friends lets suppose we want to search a key 5 into this binary search tree so in the first step we will simply call this search method by providing it a root which is the root of the binary search tree and the key which we want to search so friends when the search method will start its execution on the call stack it would look something like this that there would be a search method on the call stack and as we are passing the root which is nothing but 6 and the key which we want to search is 5 so here we are simply keeping the track of these values moving ahead so friends as we are searching a particular tree using this recursion we have to provide a base case so that we can come out of the recursion so here the base case would be we are simply checking in the vlog that whether root is equal to null or root.data is equal to key or not so currently you can see root is not equal to null it is pointing to a node having data as 6 and we also know that root.data which is value 6 is not equal to key which is 5 therefore the condition in if block comes out to be false so friends in our previous tutorial we actually discussed what is a binary search tree so friends the binary search tree is nothing but a binary tree which follows some properties so the first property says that let's suppose we are on a particular node and if we traverse to its left subtree we will find the nodes having values lesser than the node value so let's suppose we are on node 6 if we traverse to its left subtree we are seeing the nodes having values 4, 2 and 5 so these all three values are lesser than 6 and similarly for any node if we go to its right subtree we will find the values greater than the node value so let's suppose if we take an example of node 6 if we go to its right subtree we are finding there are three nodes having values 8, 7 and 9 so all these three values are greater than 6 also friends these two properties should be true for each and every node of the binary search tree and using these three properties we are actually searching a particular key in the binary search tree so here in the fblog we are simply checking that whether value of key is less than root.data or not so here you can see root.data is nothing but value 6 and the key which we are searching is 5 so by the binary search tree property we know that 5 must be lying somewhere to the left subtree of node 6 so here the condition in fblog comes out to be true so friends here we know that 5 must be lying to the left subtree of node 6 therefore we are calling search method again by passing in the values root.left and the key which we want to search also friends when we call this search method we are actually leaving this search method and we are again calling the search method so therefore in order to keep the track of the previous search we will store the line numbers so it means that we are leaving this search method at line number 6 and we are again calling search by providing root.left and the key which we want to search so friends this search method will be called again and this time the root will become root.left which is nothing but 4 so here on the call stack there would be one more search method so as we call this search method by passing root.left which was nothing but value 4 so root became 4 so here root will now point to 4 moving ahead we will again check whether root is equal to null or not so here you can see root is not equal to null because root is referring to a node having value as 4 we will also check whether root.data is equal to key or not so here you can see root.data which has value 4 is not equal to key which is 5 therefore the condition in if block comes out to be false and then we will again check whether key is less than root.data or not so here you can see root.data is 4 and the key which we are searching is 5 so therefore 5 is greater than 4 so the condition in if block comes out to be false so the else part will be executed so friends as here key is greater than root.data we know that 5 must be lying somewhere to the right sub tree of the node 4 so therefore in the else block we will simply call the search method again by passing in root.right and the key which we want to search and also friends as we are leaving this search method we have to keep the track of the previous search method so first we will store the line number so it would look something like this that we are leaving this search method at line number 8 and we are calling this search method again by passing root.right as the new root and the key which we want to search so it would look something like this on the call stack there would be one more search method and as we are calling it by root.right we know that root.right is nothing but node having data is 5 so here root is 5 so root will now point to 5 then we will check whether root is equal to null so here you can see root is pointing to node having data is 5 therefore it is not equal to null and we will again check whether root.data is equal to key or not so here you can see key is nothing but 5 and root.data is also 5 therefore root.data is equal to key so the condition in if block comes out to be true so friend it means that we have found our key so in the line number 3 we are simply returning the root which is nothing but the key which we found so this is the tree node which we have actually found and we are returning this tree node from this search method so friends after this line gets executed this search method will be removed from the call stack and the execution point will go to its previous search method and we also know that we had left the previous search method at line number 8 so we will start our execution from that point also friends when we had left this search method we know that root was pointing to 4 therefore now root will point to 4 and from the line number 8 we will simply return whatever the value we got from this search method which was nothing but a tree node as in data is 5 so therefore this search method will be executed completely and it will be removed from the call stack and the execution point will reach to this search method and we know that we left this search method at line number 6 so we will start our execution from line number 6 and also friends when we had left this search method get temp root was pointing to 6 therefore now root will point to 6 and finally we will return what we actually got from the previous search which was nothing but the tree node having data as 5 so we will simply return 5 and this search method will be removed from the call stack so friends this is how we actually search for a particular value in a binary search tree now let's suppose if we want to search one more value which is not in the binary search tree so let's say we want to search a key having value as 10 so we know that 10 is not in the binary search tree so let's see how this algorithm works in the first step we will call the search method by passing in the root and the key which we want to search so on the call stack it would look something like this that root is 6 and the key which we want to search is 10 moving ahead we check whether root is equal to null or not so root is pointing to 6 therefore it's not equal to null we will also check whether root.data is equal to key or not so here you can see root.data which is 6 is not equal to 10 therefore condition in if block comes out to be false and then using the three properties of binary search tree we will see whether 10 is lying into this binary search tree or not so in the first step we will check whether key is less than root.data or not so here you can see 10 is not less than 6 therefore we know that 10 might lie somewhere to its right sub tree so the condition in if block comes out to be false and the else part will be executed so here as we know that 10 might lie somewhere to the right sub tree of 6 therefore we again call search method by passing in root.write so root is pointing to 6 and root.write is pointing to 8 and as we are leaving this search method we will keep the track of the line number which is 8 and then we will simply call the search method by passing in root.write and the key which we want to search so on the construct there would be one more search method and this time root will become 8 so root will point to 8 moving ahead we will check whether root is equal to null or not so root is not equal to null because it is pointing to a node having value as 8 we also check whether root.data is equal to key or not so root.data is 8 and key which we want to search is 10 therefore 8 is not equal to 10 so the condition in if block comes out to be false we again check whether key is less than root.data or not so root.data is 8 and the key which we want to search is 10 so 10 is not less than 8 therefore we know that 10 might lie to the right sub tree of 8 so the condition in if block comes out to be false and the else part will be executed so here we will again call the search method by passing in root.write so here root is pointing to 8 and its write is 9 and as we are leaving this search method we will keep the track of the line number so on the call stack there would be a new search method and this time root will become 9 because we are passing root.write as root is pointing to 8 its write is pointing to 9 so here our new root will become 9 we will again check whether root is equal to null so here root is not equal to null because root is pointing to a node having value as 9 we will also check whether root.data is equal to key or not so root.data is 9 and the key which we want to search is 10 therefore root.data is not equal to key so the condition in if block comes out to be false we will again check whether key is less than root.data or not so here 10 is not less than 9 therefore the condition in if block comes out to be false and the else part will be executed because we know that 10 must be lying somewhere to the right subtree of 9 so here you can see we are again calling search method and we are leaving this search method at line number 8 so we will keep the track of the line number and we will call the search method by passing in root.write so here you can see root is pointing to 9 and its write is pointing to null because there is no write child to node 9 so on the call stack there would be one more search method so value of root would be null so root will point to null moving ahead we will again check whether root is equal to null or not so here you can see root is equal to null therefore condition in if block comes out to be true so friends condition in this if block is nothing but our base case because after 9 there are no nodes into this binary search tree therefore by some way we need to exit this recursion so friends here we know that 10 is not lying into this binary search tree and also root is pointing to null therefore in the if block we simply return root which would be nothing but null and as we are returning null it signifies that key was not found into this binary search tree so here this search method is executed completely so it will be removed from the call stack and the execution point will reach to this search method and we know that we had left this search method line number 8 so we will start our execution from line number 8 and when we had left this search method root was pointing to 9 so therefore root will point to 9 also from what we had returned from his previous search which was nothing but null we will simply return null from this search method so it will be removed from the call stack and the execution point will reach to this search method and we will start our execution from line number 8 and when we had left this search method root was pointing to 8 so now root will point to 8 and also friends from this search model we will simply return the null value so this search model will be removed from the call stack and then the execution point will reach to this search method and we will start our execution from line number 8 and when we had left this search method root was pointing to 6 so now root will point to 6 and also friends on this line will simply return the value which we got from its previous search which was nothing but null so this method will be removed from the call stack and at last we will simply return null which would signify that value was not found into the binary search tree so in this tutorial we saw the demonstration of how to search a particular key into the binary search tree now let's go to Eclipse and see the working of this code hello friends in our previous tutorial we actually saw the demonstration of how to search a particular key into a binary search tree in this tutorial we will actually code the search algorithm and we will test its working so friends in our previous lectures we actually created a class by name binary search tree we also saw how we can insert a value into a binary search tree so friends in this tutorial we will actually code how to search a given key in a binary search tree using recursion so here first we will create a method whose return type would be the tree node and we will give the name as search this search method will take in the key which we want to search and inside this search method we will simply call search by passing in the root which holds the complete binary search tree and the key which we want to search and we will again create one more method whose demonstration which we actually saw in our previous tutorial so the name of the method is search it will have two parameters one would be the root of the binary search tree and other would be the key which we want to search so in this search method as we are using the recursion we have to first provide a base case so our base case would be if root is equal to null or root.data is equal to key then we will simply return the root from this method so here this would be our base case because this case will help us in getting exit from this recursion and if root is not equal to null or root.data is not equal to key then we simply check that whether key is less than root.data or not so if key is less than root.data we know that key must be lying somewhere to the left sub tree of the root therefore we will simply call the search method by passing in root.left and the key which we want to search and also whatever is written from this search method will simply return here and in else part if key is greater than root.data then we know that key must be lying to the right sub tree of the root so therefore we will call the search method recursively by passing root.right and the key which we want to search and whatever will be written from this method will simply return here so friends here we are calling this search method recursively by using the binary search tree properties so there can be a two case where we are actually finding our key then we are simply returning the root and if you are not finding the key then we are simply returning null so the null signifies that key was not found in the binary search tree also friends we saw the demonstration of this algorithm step by step in our previous tutorial now in the main method lets test its working so here in the main method we have created one binary search tree by inserting few values is 5 3 7 1 and then we are simply printing this binary search tree so if I run the code now you can see its printing the value of binary search tree using this inorder tree traversal and it prints 1 3 5 7 so friends in this binary search tree we know that it has 4 values 5 3 7 1 so lets suppose we search for value 3 so we will provide a if block and we will call the search method by passing in the value as 3 so if this search method does not return null then we know that we have found our value so we will simply print down the console as key found so if I run the code now you see it prints key found because 3 is present into this binary search tree now lets say if we want to search any value which is not present into this binary search tree so here we will simply call search method by providing us value as lets say 10 and we know that 10 is not present into this binary search tree so we will simply print key not found if I run the code now you see it printed key not found so friends in this tutorial we actually saw how we can code an algorithm to find a key into a binary search tree and we also tested its working I hope you like this video thanks have a nice day hello everyone so in this video we are going to discuss a problem validated binary search tree so lets see what this problem is and how to solve this so in this problem we are given a root of a binary tree now our task is to determine whether it is a valid binary search tree or not or bst so a binary search tree if it follows these 3 properties then its a valid bst so the properties are lets say if you are on any particular node the left subtree of a node contains only nodes with keys less than the nodes key so it means here node key is 4 and if we look towards its left then all the nodes which are on its left should have value lesser than 4 so for example if we take 6 if we look towards its left it has 3 elements so the left subtree which is 4, 2, 5 should contain only the nodes with keys less than the nodes key so 4 is less than 6, 2 is less than 6, 5 is less than 6 and similarly the right subtree of a node which is on this side should contain only nodes with keys greater than the nodes key so 8 should be greater than 6, 7 should be greater than 6 and 9 should be greater than 6 so for 6 the left should be lesser and the right should be greater and these 2 properties should be true for all the nodes so here both the left and right subtrees must also be binary search trees so what we saw on 6 the same property should hold for 4, 8, 2, 5, 7 and 9 that if we go towards its left all the nodes towards left of a node should be less than the nodes value and if we go towards right all the nodes which are towards the right should have value greater than the nodes value so this property makes a valid BST moving ahead so here let's say we are given with this binary tree and we need to find whether it's a valid BST or not so here you can see if from 6 we look in this direction the left subtree has 3 nodes 4, 2 and 8 and we know that the nodes in the left subtree should be less than the nodes value 4 is less than 6, 2 is less than 6 but here you can see 8 is not less than 6 so therefore it is not a valid BST so here you can see that for node 4 in the left subtree we have only 1 node and it is less than 4 in the right subtree we have only 1 node which is 8 and 8 is greater than 4 so for 4 it is a valid BST node but if we check all these conditions at this node 8 is greater than 6 and we know that all the nodes of the left hand side should be lesser than the nodes value so therefore it's not a valid BST till this much point it was a valid BST because left nodes were lesser than the nodes value and the right nodes were greater than the nodes value from here then it is not a valid BST because 8 is greater than 6 it should be less than 6 so friends how we can solve this problem is that when we are at node 8 its parent is 4 and 8 lies towards its right so 8 is greater than 4 so this part is valid but but here if you see the parent of 4 is 6 so therefore 8 should lie between 4 and 6 so this thing you can consider as a range that 8 should lie between 4 and 6 but how we can propagate this information to where it is with each node we assign a min or a max value now this min and max value will tell that that particular node value should lie between min and max so now lets assign these values to these nodes so if you see for 6 as it is a root node the minimum range should be minus infinity and maximum range should be infinity because for 6 there are no constraints so it should be like this that 6 should be greater than minus infinity and lesser than infinity so this is the range for 6 so if we go towards the left lets say we are on node 4 so what could be the possible range for 4 so for this node having value as 4 to be a valid BST node it should be less than 6 because 4 if it is lying on the left side the maximum value for 4 would be it should be less than 6 and the minimum value would be minus infinity only because 4 can be greater than minus infinity the only constraint is for the max value that it should be less than 6 so for 4 the range would be minus infinity to 6 so this was for this node lets say if we are going in right and we encounter 8 so we know that in a valid BST if we are going towards right all the nodes value should be greater than nodes value so 8 should be greater than 6 so it means the minimum value 8 can go is just greater than 6 and the maximum value it can be like 100 200 anything so here when it is going in the right the min value for 8 would be 6 and the max can be anything so friends if you closely observe if we are going on left the min remains same and max changes because of the BST constraint and if we are going on the right max remains the same but min changes so we need to keep the range in such a way that if you go towards left subtree min remains same so here min was same so we are propagating such a value that whatever min we have here we are just transferring it as it is and max changes to parent value so we pass 6 here if you go towards right subtree here you can see max remains the same so whatever max was here it must be same here but min changes to parent value so min changes to the parent value which was 6 so these two properties we need to keep in mind while assigning the ranges so now let's see the ranges of the rest of the elements so for 2 we are going towards left so min remains same and max changes to parent value so min remains same which is minus infinity and max changes to 4 which is true as well because 2 should be less than 4 so this is the range and let's say if we are going in this direction which is on the right side so if we go towards right subtree max remains same so this infinity will remain same because this is the max value and min changes to parent value so for 9 min will become 8 which makes sense because 9 should be greater than 8 because it lies on the right subtree so min changes to parent value so 8 comes here and infinity remains the same which is our max so friends one tricky part comes in this direction let's say we are going in this direction now if you see we are going in the right side so if you go towards right subtree max remains same so for 4 if you look max is 6 so we know that for 8 the max will remain the same which is 6 and min changes to parent value so min would be parent value which is 4 so it should be like this from 4 we are going on the right subtree and if we are going on the right side max remains the same so here max was 6 so we pass 6 as it is min changes to parent value and min changes to 4 so here why this range is important here you can see we have transferred 6 towards 8 so that we can validate whether 8 is lying between 4 and 6 or not so currently 8 though it is greater than 4 but it is greater than 6 as well it should lie between 4 and 6 therefore we can directly return a false value saying that this is not a valid VST so we will see the code for this but to understand we are simply passing down the ranges and we are checking whether that particular node is actually lying between these ranges or not so for any range it should be like this but here 8 is greater than 4 but this condition is false because 8 is not less than 6 it is greater than 6 so therefore this node makes this binary tree an invalid binary search tree and now for 7 we are going towards left so min remains same here if you see min is 6 and max changes to parent value so parent value is 8 so max becomes 8 so for 7 it would be like 6, 8 and here you can see 7 is lying between 6 and 8 so friends now let's go ahead and see the demonstration of the algorithm that how we can figure out whether a binary tree is a valid VST or not so here you can see that this is the algorithm so friends before we start if you want to master data structures and algorithms then you can subscribe to my channel and click the bell icon so that you never miss any update so here you can see that this is valid method is returning a boolean value stating that whether this tree node which is being referred by root whether it is a valid VST or not and here you can see this is valid method is getting called here and here recursively so in order to demonstrate the recursion we are maintaining a call stack here where we denote the method call and we store the state of the elements like root, min, max, left, right so when any particular method will relieve the call stack we store the state of that method and when it comes back we start our execution by applying those values back to the variables and then we proceed ahead so friends here you can see we discussed about the min and max value and here you can see that when we are going towards left here we are calling is valid method again we are going towards left so min remains the same and max changes to root's value which is the parent value and when we are going towards right we are calling is valid with root.right here you can see max remains the same but min changes to the parent value which is root.well so these two properties we need to keep in mind and in this if block we are basically checking that whether this root or the node value whether it is lying between those values or not so if it is less than equal to min we know that it should be greater than min so we can directly return false or if root.well becomes greater than max then we can return false because root.well should be less than max so this root.well should be like this min max and here if root.well is less than or equal to min we can return false because it should be greater than min and if root.well is greater than equal to max we can return false because it should be less than max and as we are calling this method recursively we are providing a base case that if root reaches to null let's say here so this null doesn't change the bst property for 1 so we can directly return true from here so now let's call is valid method we pass in the root so for root we know that it should lie like this from minus infinity to infinity so for an integer value we are providing here a long min and long max so we call is valid method with long's min value and long's max value because these two values will be like minus infinity and infinity to 5 because 5 is an integer and long is a data type which is greater than integer and we are taking long's extreme values and max value because the root doesn't have any constraint so we can provide the minimum and the maximum value of long so is valid method will be called and there will be one method on the call stack root as 5 min as min which is long rod min value I have written it like this max would be long rod max value like this and left and right would be the boolean values which we will be receiving from here and here and we will see that later moving ahead root is not equal to null so this condition comes out to be false so here you can see 5 is not less than equal to min and 5 is not greater than equal to max so here min is the long min value which is in the negative infinity so 5 is actually between this so both the conditions come out to be false so for 5 this range is valid and now we are going towards the left of 5 so we are going in this direction now to node 2 so here you can see this is valid method will be removed from the call stack and we are leaving this is valid method at line number 8 so first we update line number 8 here and then we are calling this is valid method here you can see we are passing root.left because we want to go in this direction and when we are going on the left side we know that min remains the same and max changes to parent value so for 2 min will be minus infinity and max would be the parent's value which is 5 so now we will call this is valid method with the respective values so there will be one more method on the call stack like this we have passed root.left so root will point to node 2 we know that min remains the same and max changes to parent's value which is 5 root is not equal to null so this condition comes out to be false so here root.well which is 2 it is not less than equal to min it is actually greater than min so this condition is false root.well which is 2 is it greater than max which is 5 so this condition is also false therefore overall condition comes out to be false we signify that 2 is between minus infinity and 5 so therefore this if block condition comes out to be false and for 2 also these conditions are true so now we go towards its left so we are again leaving this is valid method at line number 8 so we will update line number 8 here we pass root.left which is 1 now min remains the same which is minus infinity but max changes to parent's value which is the current root's value which is 2 so there will be one more method on the call stack now root becomes 1 so root will come here min remains same and max changes to parent's value which is 2 root is not equal to null so this condition comes out to be false root.well which is 1 so it lies between minus infinity to 2 because max is 2 so this condition is true therefore here root.well which is 1 it is not equal to minus infinity and 1 it is not greater than equal to 2 so therefore both this condition comes out to be false and we reach here so here if I just put the ranges for 2 it would be like this and for 1 it would be like this so till this point everything is fine now we will go towards its left so we are going to call is valid method again and root.left so root.left is null now min remains same and max changes to 1 so we are leaving this is valid method at line number 8 now and there will be one more method on the call stack here now root will be null so root is pointing to null so whenever we encounter this null cases we know that it is our base case so we directly return true so root is equal to null so we return true so now you can see this is valid method will be removed from the call stack and execution point will reach here with a value as true so this got removed from the call stack execution point reached here and we had left is valid method at line number 8 so we start from line number 8 and this is valid method return true so that true will be assigned to left so left will have true like this and when we left is valid method root was pointing to 1 so root will come back to 1 like this I will remove this thing so now you can see if from the left side we would have got a false value there is no point in going towards the right we can directly return false because if any of the value states that this is not a valid BST then overall tree would be not a valid BST so first we check whether left is true or not so if left is true then only we go towards the right so currently left is true so for this node we are done with the left part now we go towards its right so there will be one more method on the call stack which is valid we pass root.right and here you can see one changes towards the right max remains the same but min changes to root's value so here first we will update the line number here because we are leaving this method so 10 comes here now when we will call is valid method max remains the same it means 2 remains the same and min changes to parent's value so currently parent value is 1 so we will see how it looks there is a is valid method on the call stack with root will be now null because we have went towards its right now by calling it with root.right here you can see when we go towards right max remains the same these values are same and min changes to parent's value so if we move ahead root is pointing to null so this is our base case so we directly return true from here so this method will be removed from the call stack and execution point will reach here and it starts the execution at line number 10 with root as 1 so this is valid method return the value of true so we can assign it to right now like this and when we had left is valid method root was at 1 so root comes back to 1 so friends here you can see that for this one node from left we got true and from right also we got true it means this particular node is a valid vst node so we can directly return the value of right because left is we have checked it is already true so now this is valid method will be removed from the call stack and execution point will reach here we will start from line number 8 like this and this is valid method return the value of true and this method we received the value true from here so that will be assigned to the left so left will become true and in this is valid method root is at node 2 so root will come back to node 2 we check whether the left side of true returned true or not so which is true so this condition is true so therefore node 2 decides to go towards its right to do the same steps so here now we will again call is valid method we pass root.right so root.right is 7 when we are going to write max remains the same which is 5 but min changes to root value so currently root value is 2 so therefore first we update the line number here because we are leaving this is valid method at line number 10 so 10 comes here now is valid method will be executed again root will become 7 because we are going towards the right max remains the same and min changes to roots value because we are going to the right root is not equal to null so this condition comes out to be false root.well is not less than min so here you can see root.well is 7 and min is 2 so 7 is greater than 2 and 7 should be lesser than 5 because 5 is max so this condition is false because 7 is greater than 5 so here you can see root.well is 7 min is 2 so here 7 is not less than equal to 2 so this condition is false but here you can see 7 should be greater than equal to max which is 5 so this condition became true so therefore this overall condition came out to be true and we know that 7 is not in this range from 2 to 5 and this condition came out to be true because root.well which is 7 we are checking whether it is greater than 5 or not so it has over passed the max value which shouldn't be the case so we directly return false now because 7 should be less than 5 but here we found that 7 is greater than max so this condition came out to be true so we return false so this method will be removed from the call stack by returning a false value execution point reaches here we start from line number 10 here and this method returned a false value so to write we assign false like this and when we left this is valid method root was at 2 so root will come back to 2 like this so from here we received true and from here we received false so when we will proceed ahead from left we received true and from right we are receiving false so therefore if any of the value came out to be false we directly return false stating that this binary tree is not a valid BST so we return false so this is valid method will be removed from the call stack by returning false and execution point will reach here we had left at line number 8 here and the previous is valid method returned a false so we return false to root 5 so to the left we assign false and root will come back to 5 from here so we first check whether from left only we received false or not so for node 5 the left subtree returned a false value so it should not go towards its right it should directly return false because left we received false so we directly return false stating that this binary tree is not a valid BST so when we will return false this method will also be removed from the call stack like this so our algorithm will end and we simply return false value so now let's say instead of 7 we had 3 like this and root was here so this was the previous state which we already discussed let's say when we are on this part root is at 3 the min value should be 2 and the max value should be 5 so for 7 we had the same conditions root is not equal to null so we check whether root.well which is 3 is it less than min so this will be false because 3 is greater than min we check whether root.well is it greater than min or max so this condition is also false because 3 is not greater than max which is 5 previous to that here it was 7 so therefore we had returned false but now we have 3 and 3 lies between 2 and 5 so therefore both the conditions came out to be false so why I am demonstrating it with 3 is just to complete the algorithm for a positive BST so this tree is actually a valid BST so now we go towards the left of this root which is 3 and this is our base case so we will go quickly over this we first update the line number here because we are leaving this is valid method root will come to null and min max will be 2 and 3 root is equal to null so we return true so this method will return true and it will be removed from the call stack execution point will reach here we start from line number 8 this method return true so to left we assign true and root came back to 3 left is true so we go towards its right which is also our base case so we first update the line number here 10 and this valid method will be on call stack with new root as null because we are going towards the right so root comes here root is equal to null so we return true directly we start from line number 10 and this is valid method return a true value so true comes here and root goes back to 3 and root goes back to 3 and whatever the value right has we directly return that value because if we are going towards right it means left is already true so if right would have been false we would have written false if right would have been true we are returning true so this is valid method will be removed from the call stack and will return true so we reach here this is valid method from line number 10 here and here this is valid method return true so we update true here and at that moment root was at 2 so root comes back to 2 so here from this null we got true from here we got true so both came out to be true so we returned a true value which we stored here so now this is valid method will be removed from the call stack returning the value of right which is true will return true and this is valid method will be executed from line number 8 because 5 at call is valid and passing in root.left which was this and this is valid method return true so we assign true to left root comes back to 5 left value is true so for this node it sees that its left sub tree complete left sub tree return value is true so now it checks by going towards the right so it will call is valid again passing in root.right when we are going to the right max remains the same and min changes to parents value which is root.well so here when we go towards the right we reach 6 so for 6 max remains the same which would be long.max value but min will change to the parents value which is root value which is 5 which makes sense because 6 should be greater than 5 and it can be lesser than any of the max value so max remains the same and min changes to root.well so first we update line number here which is 10 and we will go quickly over this 3 nodes now so root comes here root is not equal to null 6 is between 5 and max so both the condition comes out to be false now we go to the left of 6 by calling is valid method passing in root.left when we are going to the left min remains the same which is 5 but max changes to root.well so it should be 6 now so there will be one more method on the call stack with root as null we know that we have went to the left so min remains the same and max changes to root's value which is 6 root is equal to null so we return true and max changes to root value which is 6 root is equal to null directly we start from line number 8 so left will receive true root comes back to 6 left is true so now we go to the right of 6 we update line number here which is 10 there will be one more is valid method on the call stack with root as null because we have went to root.right now and as we are going to the right we know that max remains the same and min becomes the root's value like this so root is equal to null so it is our base case so we return true directly execution point will reach here it will start from line number 10 so this method returned a value true we stored in the right and root came back to 6 and now we can directly return whatever the value right will hold so currently it is true so we will pass true to this is valid method and this method will be removed from the call stack so now this is valid method will be starting from 10 because we had left at line number 10 and this method returned a value of true so right will have true root will come back to 5 and then here you can see from the left we received true from the right also we received true like this so for 5 as it is a root of this binary tree it sees that from its left side it received true and from the right it received true and 5 being the root node it is also in the boundaries of long dot min value and long dot max value so therefore it directly returns true which is stored in the right so this method will be removed from the call stack stating that this is a valid BST so friends I hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone welcome to my new data structures and algorithms in java tutorial series video in this tutorial we will discuss an interview coding problem search in a row and column wise sorted matrix so friends in an interview we are given a problem that given a row and column wise nxn sorted matrix write a program to search a key in a given matrix so what do we mean by row and column wise sorted matrix so here you can see we are given a 4x4 matrix so by 4x4 matrix we mean that it has 4 rows and 4 columns and here you can see that each row is sorted and each column is sorted so for an example the row at 0th index you can see the value is 10 20 30 40 and the last row we have value as 32 33 39 51 and all these rows are sorted in ascending order and similarly if you see the columns then those are also sorted so for example 0th index column has value as 10 27 32 and similarly if you take 2nd index column the values are 30 35 37 39 so this is a matrix in which each row is sorted and each column is sorted in ascending order and we are given a value and we need to write a program to search that value inside this matrix so friends lets suppose we are given this 4x4 matrix which is sorted row wise and column wise so here as the matrix is 4x4 the value of n is 4 and lets suppose we want to search for a key as 32 now this key is present into the matrix and we want to write a program which could search this key into this sorted matrix so friends here you can see the algorithm for it now lets see the working of this algorithm step by step friends there is an inefficient solution that is using 2 for loops and what we do is we compare 32 with each and every value of this matrix and see whether the element is present in the matrix or not so friends this is an inefficient approach because because the time complexity of this solution is O of n square and here as we are given this matrix is sorted row wise and column wise we can use that property to write an efficient code so lets see a demo of this algorithm so here we are simply calling this search method by passing in the 4x4 matrix the value of n and the key which we want to search so friends here we know that this matrix is sorted row wise and column wise therefore we start our searching from the top right corner of the matrix lets say we start from 0,3 having a value of 40 so what we do is we compare 32 with 40 and see that whether 32 is equal to 40 or not so if it is equal to 40 we simply print that we have found our element at 0,3 and here as 32 is less than 40 so the idea behind this algorithm is if we go to the left of 40 we will find all the numbers lesser than 40 and if we go below 40 then we will find the numbers greater than 40 so friends as this is a row wise and column wise sorted matrix so for each and every element in this matrix this property holds true that if we go a step left we get the number lesser than the current number and if we go one step below then we will get a number greater than the current number so lets suppose if we are at index 2,1 so value is 29 if we go one step left we will get the value lesser than 29 and if we go one step down we will get the value greater than 29 and this property is true for each and every value in the matrix so we will use this idea and search for the particular key in the matrix so in step 1 we will create an integer value i which will be pointing to 0 so this value i will be pointing towards a particular row of a matrix at a particular index so currently it is referring to 0th index row moving ahead and then we will create one more integer variable by name j and we will assign the value of n1 which is nothing but 41 so friends j will point to the columns index so friends we will start our search from the top right corner of the matrix so therefore we have initialized i to 0 and j to 3 and we will start our search from the index 0,3 having a value of 40 so friends as we want to search for value 32 inside this matrix we are providing a while loop and in this value we are providing the boundary conditions of the matrix so that value of i and j do not cross over the matrix boundary so as i started from value 0 we will iterate it to a value lesser than n and we are also providing a boundary condition for j that it has started from 3 it should go till index 0 so currently you see i is less than 4 and j is greater than 0 so the condition in while block comes out to be true so here we have provided a vlog and inside this vlog we are checking that value at matrix i, j is equal to x or not so value at i, j which is nothing but 40 we are checking whether it is equal to 32 or not so the condition in vlog comes out to be false and then we are again providing an vlog and we are simply checking that whether value at i, j is greater than x or not so here you can see 40 is greater than 32 therefore the condition in vlog comes out to be true so friends as this matrix is sorted row wise and column wise so friends when we compare 40 with 32 we know that 40 is greater than 32 therefore we also know that 32 must be lying one step left to 40 so we are simply decrementing the value of j so it could become something like this the value of j becomes 2 moving ahead then we are again checking that whether i is less than n and j is greater than equal to 0 or not so here you can see i is less than n because the value of i is 0 so it is less than 4 and j is greater than equal to 0 because value of j is 2 and 2 is greater than 0 so the condition in while block comes out to be true we will again compare the value at i, j index with x so here you can see the value at 0, 2 is 30 so we will simply compare the value of 30 with 32 so the matrix value at 0, 2 which is 30 is not equal to 32 therefore the condition in if block comes out to be false and then we will simply check that whether value at i, j is greater than x or not so here you can see the value at i, j is less than x because 30 is less than 32 therefore the condition in if block comes out to be false and else part will be executed so for 32 is greater than 30 therefore it must be lying somewhere below 30 so we simply increment i by 1 to go one step down so value of i is 0 so now it will become 1 moving ahead we again check whether i is less than n and j is greater than 0 or not so i is holding value 1 and it is less than 4 and j is holding value 2 which is greater than 0 therefore condition in while block comes out to be true in the first if block we check whether the value at matrix i, j is equal to x or not so here the value at i, j which is nothing but 35 is not equal to x which is 32 therefore the condition in if block comes out to be false we then check that whether value at matrix i, j is greater than x or not so here you can see the value at i, j which is 35 is greater than 32 therefore the condition in if block comes out to be true and as 35 is greater than 32 we know that 32 must be lying somewhere to the left of 35 therefore we simply go one step left to 35 which is nothing but decrementing the j by 1 so it would look something like this that value of j becomes 1 moving ahead now again we check in the while block whether value of i is less than n and j is greater than or equal to 0 or not so here you can see the value of i which is 1 is less than 4 and value of j which is 1 is greater than 0 therefore the condition in while block comes out to be true we again check in the if block that whether value at i, j is equal to x or not so here you can see value at i, j which is 25 so 25 is not equal to 32 therefore the condition in if block comes out to be false and then we will again check that whether the value at i, j is greater than x or not so currently 25 is not greater than x so the condition in if block comes out to be false and else part will be executed so friends as 32 is greater than 25 we know that this value might lie somewhere below 25 so we will simply move one step down by decrementing the value of i so i becomes 2 so i becomes 2 moving ahead we will again check whether i is less than n and j is greater than equal to 0 or not so here you can see 2 is less than 4 and 1 is greater than 0 therefore the condition in while block comes out to be true we check the value of matrix at i, j is equal to x or not so here you can see the value at i, j which is nothing but 29 is not equal to 32 therefore the condition in if block comes out to be false and then we simply check that whether value at matrix i, j is greater than x or not so here you can see value at i, j which is 29 is less than x which is 32 therefore the condition in if block comes out to be false and else part will be executed so friends we will go one step down because 32 is greater than 29 so here as this matrix is row and column is sorted matrix we know that 32 might lie below 29 so we simply go one step down by incrementing the value of i so i becomes 3 moving ahead in the while loop we will again check whether i is less than n or not so here you can see value of i is 3 and it is less than 4 and we also check whether j is greater than equal to 0 or not so here you can see j is greater than 0 so the condition in while block comes out to be true then in the if block we check whether value at matrix i, j is equal to x or not so the value at i, j is nothing but 33 and we know that it is not equal to 32 therefore the condition in if block comes out to be false then we simply check that whether value at matrix i, j is greater than x or not so here you can see the value at i, j which is 33 is greater than 32 therefore condition in if block comes out to be true now as this value 33 is greater than 32 we know that value must be lying to the left of 33 so we simply go one step left by decrementing the value of j so j becomes 0 and then again in while loop we check whether i is less than n and j is greater than or equal to 0 so here you can see value of i is 3 and it is less than 4 and value of j is 0 which is equal to 0 therefore condition in while block comes out to be true now we simply check that whether value at matrix i, j is equal to x or not so here you can see the value of matrix at 3, 0 which is 32 is actually equal to 32 therefore condition in if block comes out to be true so friends here we know that we have found our value so therefore we simply print on the console that x is found at 3, 0 so in the console we are simply printing that x is found at 3, 0 and then we will simply return from this method so friends in this tutorial we saw the demonstration of the algorithm now let's go to eclipse and see the working of this code hello everyone so friends in our previous tutorial we saw the demonstration of the algorithm to search for a value in row and column by sorted matrix now in this tutorial we will actually write that code and test its working so here i have created one class by name sorted matrix and inside this class i have created one main method and here i have initialized the matrix which we discussed in our previous tutorial which is row and column by sorted matrix now let's write a program to search for a key in this row and column by sorted matrix so i will give the name of this method as public void search and this method takes in 3 arguments one is the matrix one is the value of n as it is a 4x4 matrix therefore value of n will be 4 and one will be the value which we want to search we are denoting it by x so in order to search in a row and column by sorted matrix we are using 2 pointers i, j so we are initializing i to 0 and j to n1 because we are simply starting our search from the top right corner of the matrix so here value of i will be iterating over the indexes of the rows and value of j will be iterating over the indexes of the columns moving ahead we will provide a while loop and inside this while loop we have to iterate over the matrix using the values of i and j therefore we are simply providing the boundary condition so that i and j do not cross over the matrix boundary so here i should be less than n and j should be greater than equal to 0 which we actually discussed in our previous tutorial in the first step we are providing an if block and inside this if block we are simply checking that value of matrix at i, j is equal to x or not so if the value at matrix i, j is equal to x then we know that we have found our element so we simply print x found at i comma j and then we will simply return from this method because we have found our element and if the value at i, j is not equal to x then we simply check that whether that value is greater than x or less than x so matrix i is greater than x or not so here if the value at matrix i, j is greater than x and as it is a row and column with sorted matrix we have to go one step left so in order to go one step left we simply decrement the value of j by 1 and if the value at matrix i, j is less than x which is the else part then we know that we have to traverse one step down because value of x will be lying somewhere down to the value of matrix i, j so we will simply increment the value of i by 1 also friend if you don't find any value then after this while block we will simply print value not found so friend this is the code to search a value in a row and column with sorted matrix now let's test it working so in the main method we have already created a matrix which is row and column with sorted matrix so first we will create the instance of the sorted matrix class and then we will simply call the search method by passing in the matrix the value of n which is matrix.length and let's say we want to search for a value 32 which we discussed in our previous tutorial so if i run the code now so here you can see that it prints that x is found at 3, 0 so we have simply printed the indices of the matrix where we have found this value now let's suppose if we search for a value which is not present in the matrix say we give value is 100 and if i run the code now so you can see in the second edit printed that value not found so friend in this tutorial we actually coded an algorithm to search for a key in a row and column with sorted matrix so friend i hope you like this video thanks have a nice day hello everyone so in this video we will be discussing a famous interview problem print a given matrix in spiral form so here you can see that we are given with a matrix now let's say we are given with an integer matrix having the values as 1,2,3,4 and so on now we need to print this matrix in spiral form now what is the spiral form? so the spiral form is something like this so here you can see that it basically traverse in clockwise direction and it goes something like this so we need to print this matrix in this form so first we need to print it from left to right then from top to bottom then from right to left and then from bottom to top and once we are done with the outer matrix here you can see the spiral curve goes inside so then we will go to the inner matrix so here we will first reverse it like this left to right then top to bottom then right to left and then from bottom to top and after traversing it like this we will traverse the inner matrix like this and we keep on doing this till there are no more elements left to be traversed and this matrix can be of any length and can have any inner boxes so if we print this matrix it would look something like this 1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 and 10 now lets see the demonstration of this algorithm step by step now here you can see this is the algorithm to traverse the matrix in spiral form so if you see this algorithm looks quite complex once you get an idea it becomes very easy so before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here lets say we call the spiral print method we pass in the matrix which we saw in our previous slide so that matrix was 4 x 4 it has 4 rows and 4 columns so we are passing that information as well so here it would look something like this that we have this 4 x 4 matrix having row index from 0 to 3 and column index from 0 to 3 so this value r is 4 is denoting that it is 4 rows and c equal to 4 is denoting its 4 columns so for timing you can think its something like this here that its in outer boundaries of this matrix and it is basically denoting the number of rows and number of columns but here these numbers are denoting the indexes from 0 to 3 moving ahead now we will create 3 pointers i, k and l so here i if you see it will be our normal iterator which will help us in printing the matrix in spiral form so this is the generic iterator k will basically help us in traversing the rows and l will help us in traversing the columns so we will see its significance later so for timing we are starting from 0th row and 0th column so therefore these 2 variables will help us in traversing rows and columns from 0 so k is 0 and l is 0 so this 0 is basically the index so k is pointing to 0th row so this is the row and l is pointing to 0th column so this is the column so now we will see how these 2 variables help us in traversing the matrix in spiral form so friends in our previous slide we saw that how we can traverse the matrix in spiral form first we need to traverse the outer matrix then we need to traverse the inner matrix and we need to go on like this till there are no more elements left to be traversed we provide a while loop and these are the boundary checks that k should be less than r because k could travel from 0 to 3 so therefore it should be less than r which is 4 and l should be less than c so l should be less than c because this is the boundary of the column and this is the boundary of row once this condition comes out to be true you can see that we have 1 for loop 2nd for loop 3rd for loop and 4th for loop now why this 4 for loops so it's very simple the 1st for loop signifies that we need to go from left to right the 2nd for loop will help us in traversing top to bottom the 3rd for loop will help us in traversing from right to left and the last for loop will help us in traversing from bottom to top so we need to print the matrix in spiral form so it's like going from left to right top to bottom right to left and bottom to top so this will help us in traversing the outer matrix so this while loop will help us go to the inner matrix and perform these steps again and it will go on till these conditions are satisfied and once these conditions are not satisfied we know that we have traversed the matrix in spiral form so let's see the demonstration of these 4 for loops along with the outer while loop so initially both these conditions are true now our task is to print 1st row so here you can see this is the 1st row we need to print so if you see this 1st row is being referred by or pointed by k and once we print 1, 2, 3, 4 we are going to this direction so when we go to this direction you can see the row remains same and what changes is the column so if you want to print 1 we need 0, 0 if you want to print 2, 0, 1 0, 2 for 3 0, 3 for 4 so here you can see the column is actually changing so when we go this side column changes so this for loop you can see as we want to print from the 1st element or from the 1st column to the last column with row remains the same so the column varies and this column will vary from l equal to 0 to the last value of the column so here l will help us in starting that from which column we need to print so currently this matrix we are printing is from the start so this is the outer matrix but once we traverse this matrix once we need to go to the inner matrix so that time this l will help us to start from 6 and we need to perform this logic again so here this l help us in keeping the traverse of which column is actually printed and this k will help us in traversing that which row is actually printed so we will see their advantage later so here you can see that we are starting from l which is 0 and will go till i is less than c so i is less than c we need to go till this point so here now it's very simple that i is starting from 0 from here and we need to print from left to right keeping the row constant and varying the column based on the i so after providing the valid range for i here you can see that we are keeping the k constant because row is the same what varies is the i so we will quickly go over this for loop and will print the first 4 elements because i is travelling from 0 to less than c so currently c is 4 so i will go from 0 to 3 so let's see how so 1 will be printed i will get incremented 2 will be printed i will get incremented 3 will be printed i becomes 3 and then 4 will be printed so now here you can see when we will do i plus plus i will become 4 so 4 is not less than 4 which is the value of c here you can see so it means we are done with printing the first part going from left to right so this thing is done we have printed 1 2 3 4 now here you can see that as this row is already printed we don't have to print this row again we need to go to this side from 6 to 7 so what we need to do is we need to now increment k by 1 position because we are done with this row so k becomes 1 and now it signifies that this is our range to print because we have already printed the first row and here you can see that this k also help us in starting of the top to bottom it won't print 4 again because here you can see that when we go top to bottom we are starting from k so i will start from this k equals to 1 and here you can see that when we go from top to bottom you can see that we need to print 8 12 16 so here you can see the column remains the same now what varies is the row so here i will simply write r so basically you need to think that if we are going from left to right column varies if we are going from top to bottom row varies so this i will start from k because we need to print 8 and we don't have to print 4 so we have already printed 4 so we have incremented k by 1 so now i will start from k equal to 1 and it will go till i is less than r so here you can see i is less than r because now row varies and here you can see the column remains the same so in order to print this column its value is 3 which is c minus 1 so let's see how it goes so i starts from k k so here i is 1 so now here you can see the row is actually varying here column was varying here row is varying and column here remains the constant so we need to print the last column so how we can get the last column is we simply do c minus 1 so this will help us in getting the last column so now i starting from 1 so we are first printing because c minus 1 is 3 then we will print 2 comma 3 then 3 comma 3 so we will see how it goes so now 8 will be printed value of i is 1 and c minus 1 is 3 so 1 comma 3 will be printed which is 8 we will increment i i becomes 2 so it means it has now reached here then we will print 12 which is 2 comma 3 we will increment i i becomes 3 and at the end we will simply print 16 we will increment i so i will become 4 so here you can see 4 is not less than 4 so this for loop will exit and here you can see that we have printed now this part left to right is printed top to bottom is printed and after printing here you can see that we have completed with this column so in the next iteration of while loop we need to start from here so for example we need to start from this column not from this column so we need to decrement c now because c is pointing to 4 now we need to decrement it because once everything will be finished and this while loop will again come here you can see we are printing c minus 1 so if c remains at the 4 3 will be again printed so c becomes 3 now and here you can see now we are simply providing one check that if k is less than r then only go from right to left so here this condition we will look into later so for time being just think that we have only this for loop so currently k is actually less than r but we will see the importance of this condition later so for time being just think that k is less than r because k value is 1 4 now here you can see we are done from left to right top to bottom now we need to go from right to left and we know that what varies in this direction is the column so here we need to print now 15 then 14 then 13 so here you can see the column is actually varying from 2 then 1 then 0 and what is constant here is whatever is from left to right or from right to left the row remains the same column varies and if we go from top to bottom or bottom to top the row varies and columns remains the same so here now we are going from right to left so column is actually varying from 2 then 1 then 0 and here you can see the row is same which is 3 so here now our i will start from c1 because we need to print this part not this so i will start from c1 which is 2 2 it means this column and row is constant and here you can see this i will traverse till i is less than equal to l so here you can see if l would have been here it means that we are printing this smaller part of the matrix because this l will help us in providing the range that which column we need to print so currently why we are going till i is greater than equal to l because we need to print all the column values corresponding to this row and here you can see that after each iteration we are decrementing i because we are printing 2 then 1 then 0 index so we are going from right to left so row remains constant so how we can get this value is we simply do r1 so this is the row which we need to print and column varies from 2 to 0 which is provided by l so we will simply print 15 now we will decrement i i becomes 1 we will now print 3,1 which is 14 we will decrement i i becomes 0 we will print 3,0 now which is 13 we will decrement i it will become minus 1 it means i has gone out of the boundaries of the matrix so this condition comes out to be false so we are going to do r1 so we are going to do r1 so we are going to do r1 so we are going to do r1 so this condition comes out to be false because l is 0 then i should be greater than equal to l so here you can see after this for loop completes we are done with this part 15,14,13 and here we are done with this row so now we will simply decrement r because in the next iteration of these 4 loops we will simply go to the inner matrix so this row is already printed so we will simply do rminus so r becomes 3 and this is the similar condition what we provided here we will discuss this both condition later so for timing thing that l is less than c because l is 0 and c is pointing to 3 so this condition is true now here we need to go from bottom to top so we know that row will vary and column will remain the same so we need to print this column and print here you can see that how this k is helping to prevent traversing this one again because we need to print this column which is 9 and 5 so here like we did here provided a range here you can see starting i from rminus 1 which is 2 because we need to print this now 9 and it will go till k so this k will help us to only print 5 and it won't allow us to go beyond that to print 1 so this is the advantage of these conditions here so i will start from 2 because rminus 1 is 3 minus 1 which is 2 so here i is starting from the second index row and here you can see that we know that column is constant and this column is being denoted by l and the row varies so row is actually varying by this iterator i so first we will print 2, 0 which is 9 then we will decrement i by 1 i will become 1 so i has become 1 now we will print 1, 0 because value of l is 0 so 5 will be printed so here you can see now i become 0 here so we don't need to print this so therefore this k will help us in not going to this row because i should be greater than or equal to k but here i is not greater than or equal to k its value is 0 so this for loop will exit and once this for loop will exit you can see that now we have printed this part so after this 4 for loops we are done with the outer matrix so now we need to go to inner matrix so this for loop will help us going to the inner matrix but before going that as we have printed this column now we need to simply shift l by 1 position because we need to start again from here now so we need to shift l by 1 position by doing l++ so l will become 1 so here you can see that how this l and k are helping us in traversing this matrix in spiral form we are done with this column so now when this value will come again into picture we will simply start from inner matrix and this complete matrix will not be touched based on this conditions so lets see how so here you can see k is still less than r so this condition is true and l is less than c so this condition is also true so now you can see that initially we started k equal to 0 and l equal to 0 r was pointing to 4 and c was pointing to 4 and we printed the outer matrix like this so now you can see after the previous complete iteration we shifted everything by 1 position we shifted k by 1 position we shifted l by 1 position we reduced r by 1 position and we reduced c by 1 position so now you can see that as we have reduced the dimensions of k, r, l, c it means that we are telling that we are done with the outer matrix and we are now starting from the inner matrix so here you can see k is pointing to 1 it means it is starting from here now l is starting from this column because we need to print this and similarly r and c so now at the start we need to print now 6 and 7 so here we know that column varies so from which column we need to start this will help us we need to start from the first column because we need to print 6 and rho remains the same so i is starting from l so here you can see the advantage that this l is actually providing us the range and it will go till less than c so this i will go and print 6 and 7 because it is going till less than c so less than c is 2 it means 6 and 7 will be printed because column is varying and rho is constant which is k so this is the similar thing now so the only idea is we need to keep the track of the ranges rest everything is very much same so we will simply print now 6 then we will increment i i becomes 2 so now we will simply print 1,2 here 1,2 so 7 will be printed we will increment i so i becomes 3 so 3 is not less than 3 so this condition comes out to be false now and for loop will terminate and our condition is we need to only print 6,7 not the 8 so here c is helping us to keep within the boundaries of inner matrix so we are done with this part and here you can see rest everything is same we are done printing this rho now so we will simply increment k by 1 which means we need to print now this rho now we will go from top to bottom so rho varies and k is pointing to 2 so i will start from 2 because we need to print 11 now so i is starting from 2 here and here you can see the column remains the same so this is the only column or only element inside this column we need to print because rest everything is printed so we simply print c1 which is the second column and i is travelling from k to less than r so after printing 11 when we will increment i it will reach to 3 which will make us equal to r so therefore i will be equal to r and we will break from this for loop so this only 11 will be printed here now so here we will print 2, 2 so 11 will be printed we will increment i so i will become 3 but here you can see this condition is not getting satisfied which makes sense because we don't have to print now 15 we are done with the printing of the inner matrix so this part is done and as we have printed this column so we will simply shift c by 1 position here we do c minus minus and this condition k is less than r still holds true because k is less than r we will discuss this later and now you can see we need to go to from right to left so column varies so here you can see this column will vary from c minus 1 which is this part c minus 1 which is 1 and it will go till l because l will help us to stop going beyond the particular column so it will help us only print 10 now because our i is starting from c minus 1 which is 1 and we need to only print this simple value which is 10 so i is 1 and it is greater than equal to 1 so this is the part and here we know that when we go from right to left only column varies row remains the same so here we are simply printing r minus 1 comma i so r minus 1 will give us this row and i is actually pointing to 1 so we are simply printing 2 comma 1 now which is 10 we will decrement i i will become 0 so here you can see now this condition comes out to be false because i is not greater than equal to l so here you can see we have printed 10 and this part is completed so now we will do r minus minus because we are done with this row so r becomes 2 so here k and r both are pointing to 2 and here you can see l is less than c we will see this both conditions later now here you can see we have completely traversed the matrix so this for loop will wont start because i equals to r minus 1 so if we do r minus 1 i will start from 1 which is this but we are actually done with printing this complete row so here this condition help us in exiting from this for loop because this is the actual range of the rows i should be greater than equal to k but here you can see value of i is 1 and value of k is 2 so this condition comes out to be false because 1 is not greater than equal to 2 so we will simply increment l now so l becomes 2 and this inner 4 for loop will end and this while loop will now exit because here you can see k is equal to r and c is also equal to l it means we have completely traversed this matrix in spiral form so friends now we need to see why we are providing these conditions i will demonstrate one condition and rest will be pretty much same for the column so let's suppose we are given with a matrix like this that it has only 1 row and 2 columns ok so we will simply quickly go over this k is 0 l is 0 this both condition comes out to be true now we need to print 1 and then 2 because at the start we need to go from left to right and column varies so i starts from l and goes till less than c so this is pretty much normal step 1 will be printed and then 2 will be printed so this is actually printed and we are done with the problem but here if we do k++ so k is pointing to 0 so now k is pointing to 1 here we will start from i equal to 1 because we are done with printing this row now we need to start from the next row and we need to go from top to bottom so here r varies and i starts from k and goes till r minus 1 so this for loop won't get executed because k and r are pretty much same pointing to 1 so what we do is we do c minus minus because we are done with printing the last row because it is already printed so we simply go c minus minus so c comes here so let's suppose if this condition wouldn't have been provided here we can see k is equal to r now and if we don't provide this condition let's say this for loop starts executing then we need to go from right to left so when we go from right to left we start from c minus 1 so c minus 1 is i will start from 0 and it will go till i is greater than equal to l so here you can see l is pointing to 0 so this condition comes out to be true so this is where this problem starts if this condition comes out to be true then it will simply print r minus 1 which is r pointing to 1 if we do minus 1 we get 0 and i value is 0 so it will actually print 1 which is we don't want that because why we don't want that is because we are already done with this row so therefore when we go from right to left it is very much important that we need to think that ok is the matrix completely traversed because here you can see matrix is completely traversed so here this condition will help us preventing to print 1 again after printing 1 and 2 we should simply exit and these two condition will help us doing that because there could be a possibility that we are given with this matrix only so these are the few edge cases which we need to provide so this condition is also pretty much same let's say if we are given a matrix like this here it was 1 row 2 column here it will be 2 row 1 column so this condition will help us in preventing let's say 1, 2 so like 1, 2, 1 again similar to that stuff so friend this was all about traversing a matrix in a spiral form it is a very complex question but if you understand this figure C varies, R varies, C varies, R varies and they vary from range K, L, R and C so if you understand these two points you can traverse the matrix in spiral form pretty much easily using this simple for loops I hope you must have liked this video and in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss about the introduction to priority queue and binary heap in java so friends what is a priority queue so here you can see priority queue is a data structure that allows us to find minimum or maximum element among a collection of elements in constant time so here priority queue data structure holds the collection of elements and it helps us in finding the minimum or the maximum element in a constant time that means from the collection of elements we can find the minimum or the maximum element very fast in constant time so usually priority queue supports these three operations one is the insertion operation where we actually insert a particular key into the priority queue so the second operation is delete max or delete min so here you can see whenever we call delete max or delete min what it does is if we call delete max it return and remove the largest key from the priority queue and whenever you call delete min it removes the smallest key from the priority queue and return it back also friends if you don't want to remove the largest and the smallest key from the priority queue then we use the third operation which is the get max and get min so it simply returns the largest and the smallest key without actually removing it from the priority queue and also friends we will discuss more about the priority queue in our upcoming tutorial moving ahead so friends in our last slide we saw about the priority queue so now we will discuss about the binary heap so here you can see the binary heap is a data structure that helps us in implementing the priority queue operations efficiently so whatever the three operations we discussed in our last slide about the insertion of key delete max or min and get max or get min those operations are efficiently implemented with the help of binary heap also friends the binary heap is a complete binary tree in which each node value is greater than or less than the values of its children so why it is a complete binary tree we will discuss later below you can see that there are two binary heaps one is the min heap and other is the max heap and why we call it as a min heap because each node value is less than equal to the values of its children so here you can see if you take an example of node having value 0 then its children which is 7 and 3 have values greater than the parent so here in the min if the parent value is less than or equal to the value of its children also here you can see if you take a node having value 7 then both its children which is 9 and 8 have values greater than 7 and if you take an example of 3 then both its children having values 5 and 6 have values greater than its parent so here this property is true for each and every node of the binary heap and here you can see in the max heap each node value is greater than or equal to the values of its children so here if you take the node having value is 9 then its children have values lesser than the parent and similarly if you take the node having value is 3 then its both children is having values lesser than the parent similarly 6 which is the parent to 5 and 4 its value is greater than both 5 and 4 therefore by this definition a binary heap is a complete binary tree in which each node value is greater than equal to which is the max heap or less than equal to which is the min heap then the values of its children so here you can see the binary heap has 2 types which is the min heap and the max heap so in the min heap each node value is less than or equal to then the values of its children and in the max heap each node value is greater than or equal to than the values of its children moving ahead so as we discussed in the previous slide that binary heap is a complete binary tree so what do we mean by complete binary tree so here as per the definition a complete binary tree is a binary tree where all levels are completely filled except last level and last level has nodes in such a way that left side is never empty so what do we mean by this definition is below you can see a binary tree so here at the level 1 we have a node having value as 0 so this node will be having a left child and a right child so at the level 2 we have these 2 nodes which is 7 and 3 and till level 2 you can see it is completely filled because a node can have only 2 children but as soon as we go to level 3 here we see that 7 has 1 left child and 1 right child similarly 3 has only left child and there is no right child so here you can see a binary tree is completely filled except the last level so this is the last level so here you can see all the levels are completely filled except the last level so here we can see there is no node therefore it is not completely filled and also it has one more property that the last level has nodes in such a way that left side is never empty so here you can see whatever the nodes the last level is having they are in such a way that left side is never empty so by the left side we mean that in example 2 you can see that level 1 is complete level 2 is complete but level 3 is not complete and also the last level is not completely filled but here you can see by the second property it says that last level has nodes in such a way that left side is never empty so here you can see one left side is empty so therefore it is not a complete binary tree so we call it an incomplete binary tree those last level is not completely filled but there is one missing left node and similarly here you can see that all the levels are completely filled and the last level is not completely filled but it has nodes in such a way that the left side is never empty so friends here you can imagine complete binary tree in such a way that if we go from left to right then we always get a node so here at the level 1 there is one node so level 1 is completely filled as we go to level 2 there can be at most 2 nodes so here you can see if we go from left to right we are getting 7 and 3 so those are completely filled if we go to third level if we go from left to right then we are always getting a node now there is no right child of 3 but still it is a complete binary tree because because there are no gaps if you are traversing from left to right and similar if we talk about incomplete binary tree and if we go from left to right then here we can see that 3 has no left child therefore the first node is null so it doesn't satisfy the property of complete binary tree also friends in our upcoming tutorial we will also discuss more about the complete binary tree because this is the main property which helps us in creating a binary heap hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss how to represent a binary heap in java so friends in our previous tutorial we actually discussed about the introduction to binary heap so in this tutorial we will actually see how we can actually represent a binary heap in java so friends in our previous tutorial we actually discussed that binary heaps are nothing but complete binary tree and we also discussed that there are two types of binary heap one is the main heap and other is the max heap so friends diagrammatically we represent a binary heap in the form of a binary tree that there is one parent who has two children and similarly the other levels have their own children but when it comes to storing these elements binary heaps usually are implemented using the array so here you can see a max heap in which each node value is greater than or equal to the value of the children so 9 is greater than 3 and 6 3 is greater than 2 and 1 6 is greater than 5 and 4 so in order to represent the binary heap we basically implement it through the arrays also here you can see the max heap is having 7 elements as 1, 2, 3, 4, 5, 6, 7 so we usually store these elements into an array so in order to store these 7 elements into this array we usually create an array of 7 plus 1 elements because the first entry of array we always take it as empty so here you can see that we never store any element at the 0th index and here you can see that we start storing these elements from index 1 so usually we keep the first entry of this array as empty also friends we store these elements into an array by traversing this binary tree level by level from left to right so here you can see at level 1 if we are traversing from left to right we only encounter 1 node which is 9 so we store 9 into an array at the 1st index moving ahead then we go to level 2 and at level 2 from left to right we first encounter 3 so we store 3 at index 2 and similarly then we encounter 6 so we store it at index 3 and similarly if we go to level 3 from left to right first we encounter 2 so 2 we store at index 4 and similarly the other elements also friends in the last tutorial we discussed that binary heaps are complete binary tree that all the levels are filled and if all levels are not filled then only the last level is the level which is not filled and the elements are arranged in such a way that the left side is not empty so here you can see why we are taking it as complete binary tree so let's suppose if 2 is not present so when we store these elements from left to right in an array so you can see that here in an array we will get an empty whole which will store a null value so whenever we are representing a binary heap using an array we don't want that any value inside is binary heap to be an empty or null so therefore the binary heap are nothing but complete binary tree where each level is filled completely and if all the levels are not complete then it is the only last level which is not complete and all the nodes are as left as possible so friends binary heap has these 2 properties one is that it should be complete binary tree and second it should follow the heap order property so the heap order property is what we discussed that each node should have values greater than or less than the values of its children and if the values are greater than its children then it's a max heap and if the values is less than its children then it's a main heap which we already discussed in our previous tutorial also friends if we represent these indexes here then it would look something like this that we have filled this array from left to right level by level moving ahead also friends in our previous slide we discussed that how we can represent a binary heap in the form of an array so here you can see this max heap is represented in the form of an array so whenever we perform any calculation over this array we are basically provided a particular index and we need to calculate basically its parent or its child using some formula so here you can see if we are at node having value as 9 so in the array it is at first index and if we look for its children then it has 2 children one is having value as 3 and other is having value 6 and they are at index 2 and 3 so 1 has 1 children at index 2 and 1 has other children at index 3 similarly if we take a node having value as 3 then here we can see that it is at index 2 and if we look for its children then they are at index 4 and 5 which means that index 4 which has value 2 and index 5 which has value 1 are children of index 2 whose value is 3 so here you can see 3 is parent to 2 and 1 in which 3 is at index 2 2 is at index 4 and 1 is at index 5 so here value at index 2 is parent to value at index 4 and also value at index 5 similarly if we take the node having value as 6 then here we can see 5 and 4 are children to 6 if we take this representation into an array then 5 is 1 children of 6 and 4 is the other children so friends here you can see that how this binary heap is represented into this array and how we can represent this parentchild relationship into this array but in order to calculate this parent and child of a particular index there is a formula so we always have the children of first index is 2 and 3 we saw the children of second index which is this node is 4 and 5 and we also saw the children of third index which is this has children at 6 and 7 so if we are given any particular index let's say kth index and we want to find its children then the children of kth index would be 2 times k and 2 times k plus 1 so here children of 1 is 2 into 1 and 2 into 1 plus 1 children of second index is 2 into 2 which is 4 and 2 into 2 plus 1 which is 5 children of third index is 3 into 2 which is 6 and 3 into 2 plus 1 which is 7 so friends this is the formula which we use in order to find the children of any particular index we simply substitute that particular index value here and we get the values of its children so friends this was the formula to calculate the children of any particular index now let's say if we are given any particular index and we want to find its parent index then here you can see the parent of 7 index is 3 so here the parent of 7 index is 3 parent of 6 index is 3 so parent of 6 index is also 3 parent of 5th index is 2 so this is the 5th index and its parent is at 2 so friends in order to find the parent of kth index the formula would be simply k by 2 so you can see that if you are at 7 index and you want to go to its parent then what we simply do is we do 7 by 2 which gives us a value of 3.5 and as we are dealing with the integer values this integer value is rounded off to 3 so 7 by 2 gives 3.5 and if we take the integer value of it it round off to 3 similar the parent of 6 index is 3 which is evaluated as 6 by 2 which is 3 and parent of 5th index is 2 is being evaluated as 5 by 2 which gives us a value of 2.5 and if we round it off we get 2 so friends in this slide we discussed that whenever we represent a binary heap in the form of an array and if we are at any particular index then we can traverse to its parent or to its child using these formulas if we want to traverse to its child we simply multiply it by 2 which will traverse it to the left child and if we add a 1 to it we simply go to its right child and similarly if we are at any particular index and if we want to go to its parent we simply divide that index by 2 and we will reach to its parent index so friends in this tutorial we actually discussed about the representation of a binary heap and we also discussed that we are actually representing a binary heap in the form of an array where this first element of the array is left as empty and we start our insertion of these elements from the index 1 and we also discussed that how we can actually calculate the children of any particular index and also the parent of any particular index I hope you liked this video thanks have a nice day hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss how to implement max heap in java so friends in our previous tutorial we actually discussed that binary heaps are of basically two types one is the min binary heap another is the max binary heap so here you can see a max heap is a complete binary tree in which each node value is greater than or equal to the values of its children so here if we take any particular node let's say 9 so its value will be always greater than or equal to the values of its children so here you can see 9 is greater than 3 and 6 so this property should hold true for each and every node is max binary heap so if we take an example of node having value as 3 then 3 is greater than 2 and 1 and similarly if we take an example of 6 then 6 is greater than 5 and 4 and also in a binary tree the last level has the leaf nodes so therefore the property holds true for them as well also friends in a max heap you can see that the maximum value is always at the top which we also call as the root of the binary tree so here in the max heap the root always has the maximum value and if we represent this max heap in a form of an array then it would look something like this that as this max heap has 7 elements we will first create an array of length 8 because the first element we always keep it as empty and we start insertion from the index 1 we also discussed in our previous tutorial that how we actually insert this value inside an heap so we go level by level from left to right so at level 1 we have only the root node which is 9 so 9 is placed at an index 1 similarly at level 2 we have 3 and 6 3 is placed at index 2 and 6 is placed at index 3 and at level 3 we have 4 nodes 2, 1, 5 and 4 so 2 is placed at index 4 1 is placed at index 5 5 is placed at index 6 and 4 is placed at index 7 so friends here you can see the maximum value of this binary tree is at the root which is 9 and if we represent this max heap in an array then here you can see at index 1 we will always get the maximum value moving ahead so friends here you can see the code for the implementation of the max priority queue so this is the initial implementation and there are many more methods which we will discuss in our upcoming tutorials and here you can see this max priority queue is nothing but our max heap where it has the integer array which we discussed in our previous slide so we give it as a name of heap and we actually store the size of this max priority queue in the integer variable n so friends here you can see in the main method the first step we do is we basically create an instance of max priority queue and to its constructor we are actually passing the capacity that how many elements this max priority queue will hold so here you can see in the constructor the value which we are passing is nothing but the capacity of the max priority queue so this is nothing but the initial capacity of the max priority queue so when this line get executed the call reaches to this point and we know that we have passed the value as 3 so the capacity is 3 now as we have this instance variable which is an integer array by name heap and the integer variable n which holds the size of this max priority queue and also friends here you can see that this integer array can be any generic type array but for the simplicity of understanding I am using here as an integer array so here in the constructor the first step we do is we actually create an array having length as capacity plus 1 so it would look something like this now capacity is 3 and we have initialized this array with a length of capacity plus 1 which is 4 so why we actually do capacity plus 1 is because we discussed in our previous tutorial that that the first element in an array we always keep it as empty so we actually don't use the index 0 we always keep it as empty and we place our elements starting from index 1 so here you can see as we are not using this zeroth index now the array can hold a capacity of 3 so therefore we are initializing this integer array with a length of capacity plus 1 moving ahead now as we have initialized this max priority queue here the initial value of n would be 0 because there are no elements currently into this heap so n is 0 and also friends here we have provided two methods one is the isEmpty method which returns a boolean value which tells that whether priority queue is empty or not so here you can see if the value of n is equal to 0 then we know that there are no elements into this heap and max priority queue is empty so we simply return true if value of n is 0 or else we return false and the second method we provide is size we simply return the value of n so here if we call the size method it will print 0 because currently the value of n is 0 and then if we simply call isEmpty method to check whether priority queue is empty or not we simply return true because n is equal to 0 so friends this is a basic and initial implementation of a max priority queue there are more other methods which we will discuss in our upcoming tutorial so the only understanding we need to see is that a max priority queue basically implemented through an array which we give here name as heap and we simply create an integer value n which keeps the track of the number of elements currently into this heap array so friends this was the demonstration of this few methods now let's go to Eclipse and see the working of this code hello friends in our previous tutorial we actually discussed how we can implement a max priority queue in Java and in our previous tutorial we actually saw an animation to basically implement a max priority queue and in that tutorial we actually implemented the max priority queue at a very basic level and which we will enhance in our upcoming tutorial so friends let's see the code to implement a max priority queue in Java at a very basic level so friends in this tutorial I have created one class by name maxPQ which is nothing but max priority queue which has a main method so friends in our previous tutorials we also discussed that we represent a max priority queue in a form of an array so first we will create an integer array and we will give it a name as heap and the second instance variable will give it an integer variable by name n so this will store the size of the max heap moving ahead we also discussed that we will provide a constructor so this constructor will take the initial capacity of the heap so inside this constructor we also saw that first we will create an integer array whose size will be capacity plus 1 so why we are taking its capacity plus 1 is because index 0 is kept as empty and we simply initialize the value of n to be 0 because when we initialize this max priority queue there are no elements into this heap so the value of n is 0 we will also provide a method which will return a boolean value and the name of the method would be isEmpty which will return a boolean value that whether this max priority queue is empty or not so we simply return n equal equal 0 so if the value of n is 0 it will return true and if value of n is not 0 then we know that there are elements into this heap array also we will provide one more method whose return type would be an integer value which would be nothing but the size of this max priority queue so we will simply return the value of n so whenever we call this size method it will return us back the size of this max heap that how many elements currently this max heap has so friend in the main method will first initialize this priority queue let's say with capacity 3 and then will print its size and will also check that whether is currently empty or not so here you can see when we initialize this max priority queue the value of n is 0 so the size return is 0 so it will print 0 and if we check whether this max priority queue is empty or not so n is equal to 0 so it would return true if I run this code now so here you can see it printed 0 and true so friend in this tutorial we actually discussed the basic and a very initial implementation of this max priority queue in our upcoming tutorial we will see the operation a priority queue supports such as insertion, get max and delete max I hope you like this video thanks have a nice day hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss bottom up 3 ep5 in max heap so friends in our previous tutorial we saw the initial implementation of a max heap in java now in this tutorial we will actually discuss what happens when we insert a particular element into this max heap so here you can see that a max heap is a complete binary tree in which each node value is greater than or equal to the values of its children so here you can see the node having value as 9 has 2 children 3 and 6 so 9 has a value greater than both 3 and 6 and similarly if we take a node having value as 3 it has 2 children 2 and 1 so both these values 2 and 1 are less than 3 so here you can see in max heap each node is having value greater than the values of its children so friends this property is called as heap order property of a max heap that each node value is greater than or equal to the values of its children so friends let's suppose we are given a particular max heap having this 7 elements now let's suppose if we insert any particular element into this heap so after inserting that particular element into this max heap it may not satisfy this above property so friends let's suppose we are given any particular max heap having this few elements so in this max heap we know that the maximum value is always at root so friends let's suppose if we insert an element into this max heap having value greater than 9 so friends as we discussed that heap is a complete binary tree and here you can see all the levels are filled so when we insert a new node it will be inserted into this level 4 to the left of 2 and let's suppose we insert a value of 15 so once we insert this value as 15 the heap order property which we discussed that each node value should be greater than or equal to the value of its children will break because 2 will be parent to 15 but its value is lesser than 15 so it will break the heap order property of this max heap so friends what we do is after inserting that particular value we perform bottom up reeap5 technique so in this technique what we do is simply adjust the location of elements so that it satisfies this heap property so friends let's see a demo that how we can perform bottom up reeap5 in a max heap so let's say we are given this max heap having 7 elements and let's say we insert 10 so here you can see all the levels are filled completely and as heap is a complete binary tree the value 10 will be inserted to the left of 2 at level 4 so it would look something like this because in a complete binary tree all the levels are filled completely except the last level and the last level is filled in such a way that leftmost side is not empty so 10 will be inserted to the left of 2 so friends as it is a max binary heap we know that the maximum element always lies at the root of this binary tree but here you can see as we have inserted a value 10 which is greater than 9 therefore the heap order property is not being satisfied because as we discussed that each node in a max heap should have values greater than the values of its children but here you can see if we compare 2 and 10 then the value 2 is less than 10 therefore it is breaking the heap order property of max heap so friends in order to satisfy the heap order property of this max heap what we do is we simply adjust the locations of these nodes such that heap order property is satisfied so here you can see as 10 is greater than 2 so what we do is we simply shift up the value 10 and we swap it with the 2 so it would look something like this that 10 is swapped with 2 so friends once we swap this value we know that 10 is now greater than 2 so at this position 10 is satisfying the heap order property of this max heap but here you can see after this swap we simply traverse through this node and then we again see that whether it has any parent or not so here you can see 10 has a parent whose value is 3 so then we compare these 2 values because here you can see 3 is less than 10 so still the heap order property is not being satisfied so what we do is we simply shift up 10 and we swap it with the 3 so it would look something like this so value 10 is being swapped with 3 so once we perform this swap we again traverse through 10 and we check that whether it has any parent or not so it has a parent then we compare the parent to his children so here we will simply compare 9 and 10 so here you can see the value of 9 is less than 10 so still the heap order property of this heap is not being satisfied so what we do is we simply perform a shift up and we will simply swap these 2 values so friends once this swap is done we simply traverse through 10 and we again check whether it has any parent or not so here you can see that 10 doesn't have any parent then we also see that heap order property is satisfied because the root has the maximum value among the other nodes now friends let's suppose we want to insert a value as 8 so as it is a complete binary tree the other value will be inserted to the right of 3 so we simply insert 8 to the right of 3 so after we insert this value 8 we simply compare it with its parent and here we see that 3 is less than 8 therefore the heap order property is not being satisfied so what we do? we simply perform a shift up and we simply swap these 2 values and once we perform this swap we simply reach to 8 and then we again compare it with its parent so here 9 is greater than 8 therefore the heap order property is satisfied because in maxheap the value of parent should be greater than the value of its children so 9 is greater than 8 so therefore the value 8 is at its correct position moving ahead friends in our upcoming tutorial we will see that how we can insert a value in maxheap and we will see the demonstration of the code step by step so the example we will take in our upcoming tutorial will be like this and let's suppose the maxheap is empty so first we are inserting 4 so as 4 is the only element into this maxheap therefore the heap order property is maintained then we insert 5 so as level 1 is filled completely 5 will be inserted at level 2 to the left of 4 because we know that maxheap is nothing but a complete binary tree so 5 will be inserted to the left of 4 so once we insert 5 we will simply check its value to its parent and as it is a maxheap we know that each node is having value greater than the value of its children so here we simply compare 4 and 5 and we know that 4 is less than 5 therefore the heap order property is not maintained so we will simply shift up 5 and we will swap it with the 4 so now 5 is at correct position and we know that among these 2 values 5 is the largest value which is at the root of this binary tree moving ahead let's say we insert 2 so 2 will be inserted to the right of 5 because left is already occupied by 4 so once we insert 2 we will simply compare the value 2 with its parent and as 5 is greater than 2 therefore it is satisfying the heap order property now let's say we insert 6 so here you can see the level 2 is filled completely so now 6 will be inserted at level 3 to the left of 4 and then we will compare these 2 values and as 4 is less than 6 therefore we will perform a shift up and we will simply swap 6 and 4 so once we perform the swap we will reach to this node and then we will again compare it with its parent so here now we will compare 5 and 6 and we know that 5 is less than 6 so we will perform a shift up and we will simply swap these 2 values so friends here you can see 6 is at its correct position because it is the largest value among the other 3 values now let's say we insert 1 so 1 will be inserted to the right of 5 and then we will compare it with its parent and here we can see that 5 is greater than 1 so no swap will be done and let's say we insert 3 so now 3 will be inserted to the left of 2 we will compare 3 with its parent whose value is 2 and we know that 2 is less than 3 therefore we will perform a shift up and we will simply swap these 2 values and also friends there we will compare 3 with 6 and we know that 3 is at its correct position therefore no swap will be done so friends this is how we perform bottom up reepify in order to maintain the heap order property of min or max heap so friends usually in most of the cases whenever we insert any new value in a heap the heap order property breaks so after inserting a new element we simply perform a bottom up reepify technique in which we simply change the locations of the element so that they maintain a heap order property and we also give different names to this technique we call it bottom up reepify we also call shift up we can also call swim because the elements usually swim from bottom to top when we insert a new element so in our upcoming tutorial we will actually see the code to insert an element into a max heap and we will look the demonstration of that code step by step I hope you like this video thanks have a nice day hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss how to insert in a max heap in java so friends in our previous tutorial we actually discussed about what is a max heap that it is a complete binary tree in which each node value is greater than or equal to values of its children and we also discussed that the maximum value of this max binary heap is at root and if we look into its array representation we also discussed that how we actually place these values inside this heap array so we simply put these values level by level from left to right so here you can see in this heap array if we return the value at index 1 we will always get the maximum value of this heap also friends we discussed in our previous tutorial that priority queue helps us in getting the maximum value among the collection of elements in constant time so if we simply return the value at index 1 we get the maximum value of this max binary heap and similarly for the min binary heap if we return the value at index 1 we will get the smallest value among the collection of elements so let's see how we can insert a value in max heap so friends in our previous tutorial we actually discussed the basic implementation of the max priority queue so in this tutorial we will actually see how we can insert a value into this max priority queue through this insert method so in our previous tutorial we also discussed that when we call this max priority queue and let's say we provide a capacity of 3 so it would create an integer array having length 4 because we are initializing this heap array with length as capacity plus 1 as we are not using the zeroth index of this heap array and we start inserting from index 1 therefore here you can see the initial capacity of this heap array is 3 so here heap.length is 4 so here you can see currently there are no elements into this heap array so the value of n is 0 which we already discussed in our previous tutorial also friends in our previous tutorial we actually saw a demonstration of how we can insert few elements in max heap so friends we will insert the same elements into this heap array and we will see the demonstration of this code step by step so let's say first we insert a value as 4 so the insert method will be called and the value which we want to insert is 4 so x will become 4 moving ahead so from then we provide a if check that whether n is equal to heap.length minus 1 or not so here you can see heap.length is 4 and if we do a minus 1 we get 3 so here we are simply checking that value of n is equal to 3 or not because if value of n is equal to 3 then we know that we have utilized all the capacity of this heap array and there is no more additional space left to insert the value 4 so here you can see currently value of n is 0 and it is not equal to heap.length minus 1 which is 3 so the condition in if block comes out to be false in the next step as we are inserting 4 into this heap array first we will increment the size of this max priority cube by 1 that we are about to insert one element into this max priority cube also friends as we are not utilizing the index 0 so what we will do? we will simply insert x at index 1 so it would look something like this so we are simply assigning the value of x to heap at index 1 because value of n is 1 so 4 is inserted also friends we discussed that whenever we insert any value in a max heap we then perform a bottom of reepify which we also called as swim so here now we will actually call a method swim by passing in the value stored in n which is 1 so here swim method will be called and here you can see that as we are passing the value of n as 1 so k will become 1 so friends then in swim method we actually provide a while loop so what we do in this while loop? we simply check the newly inserted value with its parent and as it is a max priority cube we simply check that its value is lesser than or greater than to its parent and if it is greater than its parent then we simply swap them and if it is lesser than its parent then nothing so this is the condition we actually provide into this while loop so the first condition we provide is k should be greater than 1 because here you can see k value is 1 and here you can see that as there is only one element into this heap array there is no parent to index 1 because it is the root of the heap so the condition in while block comes out to be false so 4 is inserted into this heap array and it is placed at its correct position now lets say we insert 5 so x becomes 5 we check that whether n is equal to heap dot length minus 1 or not so n is not equal to 3 because heap dot length is 4 and 4 minus 1 is 3 so the condition in if block comes out to be false now as we are inserting 5 we will first increment the value of n by 1 so n becomes 2 so as we have incremented n by 1 we will simply insert 5 at index 2 by simply assigning the value of x to heap at index 2 moving ahead so for an as you have inserted 5 now we simply perform the bottom of reefify by calling this swim method and inside this swim we will simply pass the value of n so value of k becomes 2 because n is 2 now friends here you can see as we discussed in our previous tutorial that 4 is at root and 1 of its left child is 5 so friends as we have inserted 5 in while loop we will simply check that whether value of k is greater than 1 or not so here you can see k is greater than 1 because value of k is 2 and in our previous tutorial we also discussed that in order to calculate the parent of any index we simply do k by 2 and why we are doing this k by 2 because we need to compare this newly inserted value with its parent so here you can see value of k is 2 if we do k by 2 we will get 1 which signifies that 4 is parent to 5 and then we will simply check that whether value at parent is less than its children or not so friends as it is a max priority queue k by 2 is nothing but 1 and the value at index 1 is 4 which is parent to 5 so we will simply compare these 2 values and we will simply check that parent is less than its children or not so here you can see 4 is less than 5 therefore it is breaking the heap order property so the condition in while block comes out to be true and in order to maintain this heap order property we will simply swap these 2 values so it would look something like this that first we will assign 5 to this temporary variable and then we will simply assign the value at index k by 2 to k which is nothing but value at index 1 to value at index 2 so it would look something like this moving ahead and then we will simply assign the value of 5 to the index k by 2 which is 1 so it would look something like this and as we have swapped these 2 values now we will traverse to 5 again in order to check that whether it is at its correct position or not because then we again compare with its parent so in order to reach to this index again we simply assign the value of k by 2 to k which is nothing but traversing k to its parent by assigning k by 2 to k so here you can see the value of k by 2 is 1 so k will become 1 and then again in while loop we will check whether k is greater than 1 or not so here you can see that 5 is at its correct position because among these 2 values 5 is the largest value and it is placed at the top of this heap which is nothing but at index 1 therefore the condition in while loop comes out to be false now let's say we insert 2 so x becomes 2 we check whether 2 is equal to heap.length1 or not so heap.length is 4 and heap.length1 becomes 3 so n is not equal to 3 so the condition in if block comes out to be false and as we are inserting 2 we will simply increment the value of n by 1 so n becomes 3 and to the third index of this heap array we will simply assign the value as 2 and then we will simply perform the bottom of rep5 at this index which is nothing but 3 so k becomes 3 now k is greater than 1 which is true now we have to compare 2 with its parent so we simply do k by 2 so if we do k by 2 it becomes 1 because 3 by 2 will give us 1.5 and as we are using it as integer it will be round off to 1 so here parent is at index 1 and child is at index k which is 3 so we will simply compare these 2 values and we will simply check that parent value is less than the child value or not so here because if 5 is greater than 2 therefore the condition in this while block comes out to be false so now let's say we insert 6 so x becomes 6 and now here you can see value of n is 3 and heap.length is 4 if we do minus 1 it becomes 3 and here you can see 3 is equal to 3 so friends here it signifies that parent value of n is 3 and parent value of n is 3 and parent value of n is 3 and parent value of n is 3 that this heap array is failed completely and there are no more space left to insert 6 so the condition in if block comes out to be true so what we do is so we will simply call resize method by passing in a value which is twice of heap.length which is nothing but 8 so friends in our array section we actually discussed how we can resize an array in java so you can watch that tutorial to understand more about this resize method so what this method actually does is it will resize this heap array to a size double of its current length so once this method gets executed it will look something like this that heap array has now length of 8 which is double of its previous length so we actually perform this resize method because we want to insert more elements into this heap array so then we will simply increment n by 1 and now we will simply insert the value x at index 4 so it would look something like this and then we will simply perform bottom up reepify at index 4 so k becomes 4 now here in the while block k is greater than 1 which is true and now we have to compare this newly inserted value with its parent that whether it is satisfying the heap order property or not so in order to know the parent of 6 we take its index which is at 4 and we divide it by 2 so k by 2 becomes 2 so here the value at index 2 which is 4 is actually parent to value at index 4 which is 6 so now we will simply compare these two values and we will check that whether value at parent is less than the valued child or not so here you can see 4 is less than 6 therefore it is not satisfying the heap order property so the condition in while block comes out to be true so friends now we know that we have to swap these two values so we will simply perform swap we will assign 6 to a temporary variable and then we will assign the value at index k by 2 to k which is nothing but assigning value 4 at index 4 so it would look something like this and finally whatever the value is stored in temp we are simply assigning it to heap at index 2 and also friends in our previous tutorial we discussed that whenever we insert a new value in a heap we keep shifting it up till it reaches to its correct position so here you can see that we have swapped 6 and 4 and 6 is at index 2 so friends after we perform this swap 6 is at index 2 so friends after we perform this swap we simply traverse to this index by assigning a value of k by 2 to k so here you can see k by 2 is 2 and if you assign it to k it becomes 2 and also here you can see k is 2 which is greater than 1 which means that there is a parent to 6 so we need to compare it with its parent so here its parent is at k by 2 if we do k by 2 we get the value 1 so the value at index 1 is parent to 6 so we will simply compare 5 with 6 and we will check whether 5 is less than 6 or not so here you can see 5 is less than 6 so the condition in while block comes out to be true and as we are inside this while loop we will simply swap these two values using this temporary variable so at first step we will simply assign the value at index 2 to 10th and then we will assign the value at index 1 to index 2 so it becomes 5 and finally we will assign the value stored in this temporary variable to index 1 and after we perform this swap we will simply traverse to its parent by assigning k by 2 to k so k by 2 is 1 so k will become 1 now as k is equal to 1 it is not greater than 1 so therefore we know that 6 is now at its correct position because among these 4 values 6 is the largest value and we know that in max heap the value at index 1 is the maximum among the other values so the condition in while block comes out to be false now let's say we insert 1 so x becomes 1 so here value of n is 4 and it is not equal to heap dot length minus 1 which is 7 so the condition in if block comes out to be false now as we are inserting 1 we will first increment the value of n by 1 and at index 5 we will simply assign the value which we want to insert so it looks something like this and then we will simply perform the bottom up reepify at index 5 so k becomes 5 and here k is greater than 1 so here as we have inserted 1 now we will compare this value with its parent so we know that this value is at index 5 so if we do k by 2 we will reach to its parent so 5 by 2 will give us 2.5 and as we are taking it as integer it will round off to 2 so k by 2 becomes 2 so if you see the value at index k by 2 which is 2 is 5 so here we are simply comparing 5 because we know that 1 is child of 5 so here we are simply checking that whether value at parent is less than child or not so 5 is greater than 1 therefore condition in while block comes out to be false and by this we mean that 1 is at its correct position because it is child to 5 and 5 value is greater than 1 which satisfies the heap order property now let's say we want to insert 3 so x becomes 3 the condition in if block comes out to be false because 5 is not equal to 7 we will increment the value of n by 1 as we are inserting 3 now so n becomes 6 so at index 6 we will simply insert 3 and then we will simply perform the bottom up reepify at index 6 so we will call swim method and pass the value as 6 so value of k will become 6 now here whatever the value we inserted at index 6 we will simply compare it with its parent that whether it is less than its parent or not so here k is greater than 1 because value of k is 6 so first we will evaluate the parent of 3 so we will take its index we will divide it by 2 so k by 2 becomes 3 so the value at third index is 2 so 2 is parent of 3 so we will simply compare these 2 values and we will check whether parent value is less than child or not so here you can see 2 is less than 3 so the condition in while block comes out to be true so once the condition comes out to be true in the while block we simply swap these 2 values so it would look something like this we will assign 3 to this temporary variable then we simply assign the value at index 3 to value at index 6 by simply assigning the value at index k by 2 to k so it becomes 2 and finally we simply assign the value 3 to value at index 3 so it becomes 3 so friend as the value of k was 6 and we swapped 3 and 2 so 3 reached to its parent so now we will simply assign the value of k by 2 to k because we need to again compare 3 with its parent so once we do k by 2 to k k becomes 3 and in while block we again check whether k is greater than 1 or not so k is greater than 1 and we will simply compare 3 with its parent so first we will evaluate its parent by taking its index which is 3 dividing it by 2 which will give us 1.5 and as we are taking it as integer it will round off to 1 so the value of heap at index k by 2 is nothing but value at index 1 because 6 is parent to 3 and we will simply check whether 6 is less than 3 or not so here you can see 6 is greater than 3 so the condition in while block comes out to be false which means that 6 is at its correct position and also the 3 which is at its correct position so friends here we saw the demonstration of how to insert a value in a max heap and we saw the demonstration step by step we also saw that how we can perform bottom up reepify in case the heap order property is not being satisfied by inserting a new element so friends in our next tutorial we will code this insert method and we will test its working I hope you like this video thanks have a nice day hello friends in our previous tutorial we actually discussed that how we can insert a value in max priority queue so in this tutorial we will actually code the insert method which will perform the insertion into this max priority queue so friends in our previous tutorial we actually created one class in a max pq which had an integer array which was nothing but our heap and we provided a constructor which took the initial capacity of this max priority queue we also provided 2 methods isEmpty and size so isEmpty tells us whether max priority queue is empty or not and size method will tell us that how many elements are there into this max priority queue so in this tutorial we will actually code about the insertion in this max priority queue so we will create a method as public void insert so this insert method will take in a value which we want to insert so here I am taking the argument as x so inside this insert method first we will check that whether this heap array can accommodate a new value or not so we will simply check that whether value of n is equal to heap.length minus 1 or not so if the value of n which is the size of this max priority queue is equal to heap.length minus 1 it means the integer array failed completely and there is no space to insert the new element so if this condition comes out to be true we simply resize this array dynamically and as initial length is heap.length we will simply resize this array to twice of its current length so we will simply pass 2 into heap.length so then we will create a method resize so this resize method will take the new capacity of the array so here if the if condition comes out to be true it means that heap array has failed completely so into the resize method what we do we first create a new array with whatever the capacity we pass to this resize method after creating this new array we simply copy each and every element from this heap to this temporary array and then we finally reassign this heap to this newly created array so here first we will create a new temporary array whose length would be the capacity which we have passed after creating this temporary integer array we will copy each and every element from this heap to this temporary array so we will start from 0 0 and we will traverse till heap.length and inside this for loop we will simply copy the value at particular index i to this temporary array and after copying the contents of this integer array we will simply reassign temp to heap so now heap will point to an array which is of length twice of its current length so after the resize method gets executed the integer array heap will now have more spaces to insert new elements so here after if block the first thing we do is as we are inserting a new element we will increment the size of this max priority queue by 1 and then we will simply insert the value x into this heap array so we will simply assign the value of x at index n and after this insertion we know that now we have to perform bottom of vpy by creating a new method swim and by passing it the value n because now we have to perform the bottom of vpy at index n so here we will create a new private method swim which will take the argument that here this new index have been inserted so inside this swim method we will provide a while loop because in this while loop we will simply compare this newly inserted value to its parent and we will check that whether parent is less than this newly inserted value or not so the first condition we provide is whether k is greater than 1 or not because if k is equal to 1 then we know that currently heap has only one element and if value of k is greater than 1 then we know that there are more than 1 elements into this heap so then we will compare the value at parent index which is k by 2 with value at kth index and if both the condition comes out to be true we simply swap these two values so here so using this temporary variable we will swap these two values and after we perform this swap we will simply traverse to its parent by assigning k by 2 to k because we need to continue shifting up till new value inserted is at correct position that means whatever the value we inserted is at its correct position so that the heap order property of heap is satisfied so friend this is how we actually insert a new value into the max priority queue now in the main method let's test it working so I will just remove this so let's say the initial capacity of this max priority queue is 3 so here we will insert few values which we discussed in our previous slide so first we will insert 4 then we will insert 5 then we will insert 6 then we will insert 1 and then we will insert 3 and then we will simply print the size of the priority queue the size of the priority queue if I run the code now so here you can see the size it printed is 6 because we have inserted 6 elements and also if you print this heap array so here I will create one method as print max heap so inside this print max heap method I am just excluding the edge cases so I am simply providing a for loop which will iterate from i equal to 1 because into this heap array the value at 0th index is empty so we are starting from 1 and we will simply traverse i to a value n which is nothing but the size of the max priority queue and inside this for loop we will simply print the value at i at index of this heap and in the main method we will simply call print max heap and if I run the code now you see it printed 6 5 3 4 1 2 which is the same output which we discussed in our previous tutorial and here you can see that as it is the max priority queue the value set which is largest among the other values is at index 1 so in this tutorial we actually discussed how we can insert a value into this max priority queue in our upcoming tutorial we will see how we can delete a particular element from the max priority queue I hope you like this video thanks have a nice day hello everyone so in this video we are going to discuss top down reepify in max heap so this technique is also called as sync so in this technique we are simply doing the reepify in one of our previous video we saw the bottom up reepify and in this video we will be looking into top down reepify so when we are inserting an element in a binary heap we usually do bottom up reepify and when we are deleting the max element from the heap we usually do top down reepify so friends here you can see that we are given with a max binary heap now a max binary heap as we already discussed in our previous videos that it's a complete binary tree in which each node value is greater than equal to the values of its children so for example 9 is greater than 3 and 6 3 is greater than 2 and 1 6 is greater than 5 and 4 so this is the one of the property which max binary heap satisfies the other thing is it should be complete binary tree as we already discussed that a complete binary tree is a binary tree where all levels are completely filled so for example here you can see there are three levels 1, 2, 3 so here all the levels are completely filled except the last level and last level has nodes in such a way that left side is never empty so here all the levels of a complete binary tree should be filled so here you can see this level is filled in the second level it can have only two children so this level is also filled and in the last level this side is not filled so except the last level should be filled and the node should be filled in such a way that left side is never empty so here this is the complete binary tree because the elements are filled from the left side like this but here you can see that this is the incomplete binary tree because all the levels are filled except the last level but this is not a complete binary tree because the left side is empty because there could be one element coming up here so the insertion of nodes or the element should be such a way that it should be from the left side and the left side is never empty so if suppose here could have been one more element let's say 6 so this is also a complete binary tree because all the levels are filled and now next element would be inserted from here from the left side and if any of the element is not filled from the left side then this would be incomplete binary tree so here you can see when do we actually require top down reepify so when we delete an element from heap there may be a case that it may not satisfy the heap properties so deleting an element we mean delete max from the max binary heap and delete min from the min binary heap so when we delete the max element from heap let's say if we want to remove the max element which is at the root at index 1 so if we want to remove this element after its removal there arise a problem that this max heap may not satisfy the heap properties thus we perform top down reepify technique in which we adjust the locations of the element to satisfy the heap property so now let's move ahead and see how we can perform this technique so let's say we are given with this max binary heap where the elements are stored in an array starting from index 1 which we have already discussed in our previous videos now let's say when we call delete max so we want to remove this element 9 but if we directly remove this element 9 the heap property of this max heap will not get satisfy so what do we do is before removing 9 we simply store its value in some variable let's say max now after storing the value because we need to return this value from the delete max so we are storing it in a max variable now after getting its value what we do is we simply take the last element which is filled in the max heap and we simply swap both the elements so here 9 will be swapped by 4 so 4 comes here and 9 comes here now after this swap we can easily remove 9 because this is the last element so 9 gets removed but as we swapped it with the 4 the heap order property is not getting satisfied because in the max heap the root element should be greater than or equal to the values of its children so 4 is greater than 3 but it is not greater than 6 so therefore heap order property is breaking here so now the third step we apply is we do top down reepify now in this technique what we do is as the root element or the parent element should be greater than or equal to the values of its children the heap order property is not getting satisfied at this location so the children x1 which is 2 and 3 we will first compare 3 and 6 together and we will find which is the max element among these two values so we will compare 3 and 6 so 6 is greater than 3 it means now we need to compare the parent value with 6 as parent value should be greater than both the values of its children we are simply comparing the parent element with the max of the values of its children so here we are not comparing 4 with 3 because we have already compared 3 with 6 and as 6 is greater than 3 now we will simply compare 4 with 6 so here you can see 6 is greater than 4 it means parent value is smaller than the value of its children therefore what we do is we simply perform a shift down which is top down or we can also call sink what do we do in this technique is now we simply swap 6 with 4 so 6 comes here and 4 goes here so here you can see now the parent value is greater than both of its children so after doing this what we do is as we perform the shift down the parent element is at its correct position and then we simply traverse to this position and then we perform the same steps again because there could be a possibility that 4 may not still satisfy the heap order property so what do we do is when reaching 4 we see that it has only 1 children therefore it doesn't have the other children so we can directly compare 4 with 5 so here 5 is greater than 4 it means the heap order property currently is not getting satisfied so we simply do a shift down so 5 comes here and 4 comes here and after performing shift down we reach here and now you can see it doesn't have any children it means 5 is placed at its correct position 6 is placed at its correct position and 4 is also placed at its correct position so now you can see that maxi property is getting satisfied and all the elements are at its correct position and at the end we simply return the value 9 now let's see one more example let's say we are given with this max heap where all the levels are filled completely except the last level and it is also getting filled from the left hand side now let's say we call delete max so the first step we do is we simply store value 10 in the max variable the second step we do is we take the last element of the max heap and we simply swap it with the root element so 3 comes here, 10 comes here so after we perform this swap we can now easily remove this element and as 10 is removed one problem it has created is like the heap order property may or may not get satisfied so after we perform this swap we are at this position and we need to place the maximum value among these 3 values because 3 is the parent 9 and 6 are its children and whichever value is the greater among these 3 should come here so here we have to compare 3 with 9 and 3 with 6 or what we do is we simply compare both the children's value which is 9 and 6 and whichever value is greater so here 9 is greater so we simply compare 9 with 3 because if let's say here would have been 11 for example so if 11 is greater than 9 it will also be greater than 6 because we have compared these 2 values already so currently its 3 so now 9 is greater than 3 therefore what we do is we do a shift down 9 comes at this position and 3 comes at this position so we are doing a swap and after doing the swap we reach here and then we try to compare this index value which is 3 with its children so here you can see now we simply compare 1 and 2 and whichever value is greater among these 2 which is 2 we simply compare it with 3 so here you can see 3 is greater than 2 therefore there won't be any shift down because 3 is now at its correct position because it is greater than both of its children so we don't do anything and the process ends here and this max value will be returned so why we are comparing these 2 children is because we need to compare parent with a greater value among these 2 because if 3 is greater than 2 then 3 will also be greater than 1 so that's why first we compare both the children's value and whichever value is greater among both the children we simply compare that value with the parent's value and if the parent's value in max if if it is less then we do a shift down and if it is more like the current scenario then we don't do anything because 3 is at its correct position now let's see one last example let's say we are given with this max heap currently all the heap properties are getting satisfied let's say we call delete max so first we store the value 9 then we swap this value with the last value of the max heap so 0 will come here and 9 will come here like this and after doing this swap we can safely remove this element with value 9 so now here you can see after this swap we are starting from the very root node and there might be a case that heap order property is not getting satisfied so what do we do is first we compare both its children which is 3 and 6 and we figure out which is the max element so if we compare 3 and 6 so 6 is greater than 3 so now we compare 6 with its parent value so 6 is greater than 0 so 6 is greater than 0 it means that whatever value is at index 1 is not satisfying the heap order property because in the max heap the parent value should be greater than both of its children so we do shift down so 6 comes here and 0 comes here and then we reach here now again there could be a possibility that after this swap this value 0 is still not satisfying the heap order property so what do we do is we simply compare both the children first and whichever is the max in this case it is 5 so we compare 0 with 5 as 5 is greater than 0 therefore the value of children is greater than the parent so it is not satisfying the heap order property so we do a shift down 5 comes here and 0 comes here and then finally we reach here and here we see that it doesn't have any children so therefore now 0 is at its correct position 5 is at its correct position and 6 is at its correct position so here 6 is greater than 3 and 5 5 is greater than 0 and 4 and at the end we simply return 9 so friends in this video we saw that when we perform a delete max operation in a binary heap there could be a possibility that heap order property is not getting satisfied in a binary heap therefore we do top down top down reepify which is also known as sync or shift down where we are simply shifting down the elements till it reaches at its correct position so friends this was all about top down reepify when we perform delete max in our next video we will actually see the implementation of the algorithm step by step I hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss that how to delete the maximum element in a max heap in our previous video we saw the top down reepify technique when we actually deleted the maximum element from a binary max heap and in our previous video we also saw that a max heap is a complete binary tree in which each node is greater than or equal to the values of its children so here you can see that 9 being parent to 3 and 6 has values greater than both of its children 3 is having value greater than both of its children 6 is having value greater than both of its children so its a max binary heap and when we want to delete the maximum element from the max heap the maximum value is usually at the top which is also the root of our binary tree so here max heap is usually demonstrated in the form of a binary tree but the data is actually stored in the form of an array where index 0 is empty we usually take index 0 as empty because it helps us in evaluating the children of any parent we also saw the formula for evaluating the children of any parent given at index i which is 2i and 2i plus 1 so this is child 1 and this is child 2 so this is what we actually discussed in our previous videos as well so usually we fill this array from left to right level by level so this is level 1 so 9 comes here then we go to level 2 the first element we see is 3 so 3 comes here 6 comes here then we go to level 3 2 1 5 and 4 so this is what we actually discussed in our previous videos as well so if we mark these indexes at each element it would look something like this 1, 2, 3, 4, 5, 6, 7 now in order to access the maximum value in this max heap we take the value stored at index 1 which is heap of 1 and then we perform delete operation on the top of it and after we perform delete operation we also do the top down reepify so let's see it via an example which we already discussed in our previous video let's suppose we are given with this max heap and we want to delete the max so first thing we do is we simply store the maximum value which is at heap max and then we actually pick the last element and we swap it with the element which we want to delete so 9 and 4 are swapped 4 comes here 9 comes here and then we can safely remove 9 but here you can see when 4 reaches here it doesn't satisfy the heap order property the value of 4 should be greater than both of its children but here you can see 4 is greater than 3 but 4 is not greater than 6 so therefore here what we do is we compare 4 with its children either we compare 4 with both of its children or we can first compare both the children's and take the maximum value out of them and then compare that maximum value with the parent's value so first we compare both the children's value so 6 is greater than 3 so as 6 is greater than 3 now we compare the parent's value with 6 so 6 is greater than 4 it means that heap order property is not satisfied and we perform a swap we take 6 here and 4 here by doing shift down or top down repify so 6 comes here 4 comes here and after we do swap 6 is at its correct position then we actually go towards one of the children from which we did the swap and we again perform these steps as 4 doesn't have the right child so we directly compare 4 with its left child value 5 so 5 is greater than 4 so therefore we do a shift down 5 comes here and 4 comes here and here you can see after we do this swap 5 is at its correct position then we simply traverse to 4 and perform the same steps again but here you can see 4 doesn't have a left or a right child therefore 4 is also at its correct position so therefore now heap order property is satisfied by all the values of this max heap and at the end we simply return 9 so now lets see the implementation of this algorithm step by step so this binary tree now we will see the implementation in the form of an array so lets say we have this binary heap and we know that it is starting from index 1 which has the maximum value in this binary max heap the value of n which is the total number of elements is 7 we have already discussed this in our previous videos so value of n is 7 now we call delete max so the first step we do is we simply store the value 9 in max because at the end we need to return this value and as we are going to delete the max we first store it in the max variable which is 9 so 9 is stored in max and we also discussed that after we store the value in max variable we perform a swap with the last element and the root element which we are trying to delete so we pass 1 and n so in the swap method we are using this temporary variable and then we simply perform a normal swap so we will go over this quickly so a is 1 and b is 7 we are swapping 9 and 4 using the temp variable so first we are storing 9 in temp then we are storing 4 into heap of a which is 1 and at the end we are storing temp value at heap of b which is 7 so 9 comes here so after this method gets end 9 is here and 4 is here so now we can decrement the value of n because we need to remove 9 completely so total number of elements should become 6 now so n comes here and then here we can see we are having 4 here so 4 is not actually satisfying the heap order property if we see the children of 4 it is at index 2 into i and 2 into i plus 1 which is at index 2 and index 3 4 is greater than 3 but 4 is not greater than 6 and in the max heap parent should be greater than both of its children so these formulas we have already discussed in our previous video that how we can evaluate the children of a parent so now we actually do this top down reepify using this sync method we pass the value of the index from where we need to do this reepify so currently the index value is 1 so we will call sync method now so the call will reach the sync method so this is the sync method where we have passed the value as 1 so k will become 1 which is the index from where we need to start our top down reepify now here we need to perform this top down reepify till the heap order property satisfied or there are elements left such that we compare the parent with its respective children so this is the condition for that we are doing 2 into k less than equal to n so k is at index 1 its children will be at 2k index which is 2 and total number of element is 6 so 2 is less than 6 it means that element 4 has some children so this while loop will execute and this condition comes out to be true so at the first step what we do is the j represents one of the children of k which is given by formula 2 into k where k is the index of parent which you can see here if we do 2 into k we get index 2 so value of j will become 2 because j is one of the child of k so friend when we saw the animation we first compared both of the children of the parent and whichever was the max we took that particular children and compared it with the parent's value so here so first we check whether the parent has actually a right child or not because by this condition parent does have a left child because 2k value is less than equal to the number of elements we have here j less than n denotes that there is also a right child of this parent so how we can understand this is let's say if we take this example here so currently this element will be removed because n is pointing to 6 so 1, 2, 3, 4, 5, 6 so this is the present condition so for example here k value is 1 which is the parent index let's say k points to here at 3 if we do 2 into k we will reach to one of its children so 2 into 3 we reach here which is the child 1 so this condition tells us that there is one child to this parent and here you can see value of j is 2k which is 6 if 6 is less than 6 which is the total number of elements it means there is also one right child currently 6 is not less than 6 therefore we are sure that there is no right child here if we take k value is 3 so therefore this condition tells us that whether we have a right child or not because we need to compare both the left child value we have to take one of the maximum value among those and then we have to compare it with the parent's value so currently value of k is 1 the index of its first child is at 2 and index of its next child is at 3 so 3 is less than 6 therefore we know that for k equal to 1 it has both left and right children so this condition is very important so currently this condition comes out to be true then we check whether heap of j which is value 3 is less than heap of j plus 1 or not it means we are now comparing 3 and 6 which are actually children of 4 present at index 1 this and this we are comparing so 3 is less than 6 therefore this condition comes out to be true now why we are incrementing j is because j is actually telling the position of the element which is the maximum child to which we need to compare with the parent so j points to 3 which tells that 6 is the maximum child value among these 2 children and now whatever we want to compare we need to compare parent with this value at j you will understand more this in next iteration so now we calculate whether the parent value is greater than or equal to the child value or not so here 4 is compared with 6 heap of k is compared with heap of j so 4 is not greater than or equal to 6 so this condition comes out to be false and if this condition comes out to be false it signifies that heap order property is not getting satisfied so then we perform a swap between 4 and 6 so we will quickly go over this method 6 will come here and 4 will come here so 6 has come here and 4 has come here so now 6 is at its correct position it is parent to 3 and 4 and its value is greater than both of its children now when we discussed that after we do shift down in our previous example we actually reach to the position which actually did this swap so our next k value we assign the value j so k becomes 3 now when we did this swap 6 came here and 4 came here and then we moved to the next position we moved to 4 because this 4 we still need to figure out whether this might or might not satisfy the heap order property because there are more elements left in the heap so we first check whether k has any left child or not so if 2 into k is less than equal to n which is 3 into 2 6 it is less than equal to n which is 6 so therefore it must have a left child and what would be the index of the left child would be 2 into k which is 6 so j points to index 6 now we actually check with this condition whether k also have a right child or not so 2 into k plus 1 will give us the right child 6 plus 1 7 but here you can see 2 into k which is j and if we do plus 1 we will get the right child 7 is not less than 6 therefore it doesn't have a right child 3 only has a left child which is 5 and it doesn't have a right child so this condition is important so this overall condition will come out to be false because j is not less than n j is actually equal to n now we compare the parent value with the child value because j is pointing to the only child of index 3 so 4 is less than 5 this condition comes out to be false and then we perform a swap between 4 and 5 so a is 3 and b is 6 we are swapping 4 and 5 5 comes here and 4 comes here now after this swap we take k to its one of the child from which we compared so we are simply assigning j value to k so k will become 6 now here you can see 2 into k is not less than n because if we do 2 into k which is 2 into 6 which will give us 12 and value of n is 6 therefore this condition comes out to be false which also signifies that we have completely performed the top down reepify 6 is at its correct position 5 is at its correct position and 4 is also at its correct position because it doesn't have any left or right children so this sync method will end and call will reach here and this is our array when we perform the sync operation and after we perform sync operation we can simply delete this element by assigning a null value to heap n plus 1 n is pointing to this index which is 6 so n plus 1 will point to here so we are making it null now and here as we are doing delete max there will be a time when most of the elements will be deleted from this heap array so we are simply comparing whether n is greater than 0 and if n is equal to heap dot length minus 1 by 4 which is like 1 fourth of the heap dot length if n is equal to that then we simply resize the array by half of it so we will see the demonstration of this resize later so currently n is greater than 0 but n is not equal to heap dot length which is 9 minus 1 by 4 8 by 4 2 value of n is 6 and it is not equal to 2 therefore this condition comes out to be false and we return the maximum value which is 9 and we have also removed 9 from this heap so friend let's suppose we keep on deleting the elements like this so this array will have more and more null values and let's say we call delete max and we want to remove 3 so we have performed these steps and we need to remove 3 and let's say we have also performed sync so this will be the array and now if we assign null to the heap of n plus 1 as we want to remove 3 this will become null so in this case we are simply seeing the condition that this if block comes out to be true let's say we keep on removing the elements so there will be null values in the array so n is greater than 0 and n is actually equal to heap dot length minus 1 divided by 4 so heap dot length is 9 minus 1 by 4 which will give us 8 by 4 2 and value of n is equal to 2 this means both the conditions are true so now here what we do is we call the resize method which we have already seen in one of our previous video where we are simply providing the new length of our heap where we are simply saying create a new heap of half of its current length which is 9 by 2 which gives out to be 4 so we are removing this additional space which we have occupied we are freeing it up and we are creating a new array which has the size half of the current heap's length so when this method will get executed our heap array will become something like this that we have resized the heap to heap dot length by 2 which is 4 so we have removed the unwanted occupied space so this resize method we have already discussed in one of our previous video you can watch that video and at the end we simply return 3 so friend this was all about that how we can delete the maximum element in a max heap using delete max method we saw the implementation of delete max and also the top down reepify method which is sync I hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day Hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss linear search algorithm in java so friends here we are given an array of let's say n elements and we are given an element x which we want to search into this array so below you can see the algorithm to search for an element x into this array so this search method takes in the array into which we want to search an element here we also pass the value of n which is nothing but the number of elements in an array and we also pass the value of x which we want to search into this array so let's suppose if we are given this array which has 7 elements and we want to search an element x having the value as 10 so let's see the demonstration of this algorithm step by step so here you can see the number of elements into this array is 7 and the value which you want to search is denoted by x which is 10 moving ahead so friends how this algorithm works is is we start from the leftmost element of the array and one by one we will compare x with each and every element of array so here if x matches to any of the elements then we simply return the index of array and if x doesn't match with any of the elements in the array we simply return minus 1 so here in order to compare x with each and every element of this array we provide a for loop which basically start from the leftmost element and traverse till the last index of the array so here in this for loop we are iterating i from 0 to a value less than n which is nothing but 7 so i will travel from 0 to less than n which is 6 and then we will compare each and every element of array with x so at the start of our loop i become 0 so this i is nothing but the index value of the array so we will start from the leftmost element and the for loop will provide a condition that value at index i is equal to x or not so here you can see the value at index 0 is 5 and 5 is not equal to 10 therefore the condition in if block comes out to be false so here we are incrementing i by 1 so i becomes 1 so now in the if block we are again comparing that value at i at index is equal to x or not so value of i is 1 and if we take the value at index 1 is 1 and if we compare it with x then 1 is not equal to 10 so the condition in if block comes out to be false so after the increment now i will become 2 and we will use this i to point to the second index of the array and the if block will again check that the value of array at i at index is equal to x or not so here you can see the value of array at second index is 9 and 9 is not equal to 10 therefore condition in if block comes out to be false will then increment i by 1 so i becomes 3 moving ahead so here in the if block we again check that whether value at i at index is equal to x or not so value of i is 3 so value of array at third index is 2 and 2 is not equal to 10 therefore condition in if block comes out to be false and after increment i becomes 4 now in the if block we again check that value of array at i at index is equal to x or not so here you can see the value of array at fourth index is 10 and if we compare it with x then both values are equal so the condition in if block comes out to be true and here we have found our element at index 4 so the if block will execute and will simply return the value of index where we have found the element which is nothing but 4 so friend this is how the linear search algorithm works in java also friend if we had searched any value which was not given in this array then after this for loop we would have simply returned minus 1 because we haven't found the value into this array so friend this was the demonstration of the algorithm now let's go to eclipse and see the working of this code hello friends in our previous tutorial we actually saw the demonstration of the linear search algorithm so now in this tutorial we will actually code the linear search algorithm and will test its working so here first we will create a search method so public whose return type would be the integer because we are returning the index where we have found our search so i will give the name as search now this search method will take the array into which we want to search for a particular element it takes the value of n which is nothing but the number of elements of this array and integer x which is nothing but the value which we want to search so friend here this search method will return back as an integer value which is nothing but the index where we have found our search and if we haven't found our search then it will return back as minus 1 so here we will provide a for loop which will iterate over each and every element of this array and inside that for loop we will compare each and every element with the x and if it is equal then we will simply return the index so we will provide a for loop which will start from 0 and which will go to a value lesser than n so inside this for loop we will simply provide a if condition we will compare value with iid index with x and if the condition in if block comes out to be true we will simply return the index value where we have found our element and if the for loop executes completely and we haven't found our element we will simply return minus 1 which indicate that we haven't found our element so friend this is the code whose demonstration we saw in our previous tutorial now in the main method let's test its working so here we have actually created an array with few elements so first we will create the instance of linear search class and then we will simply call the search method we will pass in the array and the number of elements would be the length of the array and let's say we want to search for a value 10 so we will pass 10 so whatever the integer value it returns we will simply print it on the console if I run the code now so here we can see it printed 4 which means we have found our element at index 4 now let's suppose if we want to search a value which is not present in this array so if I search for value as 50 and if I run the code now so here we can see it return minus 1 which states that we haven't found our element into this array so friends here in this tutorial we actually coded the linear search algorithm and we tested its working I hope you like this video thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss binary search in java so friends what is a binary search binary search is a divide and conquer algorithm so here if you see that suppose if we are given an array which is sorted so here you can see the numbers are sorted in ascending order so friends let's suppose we have to search an element in a sorted array so what we can do is either we can perform a linear search that we can compare the elements with an array with an element we want to search so this linear search will go on with the each and every element that we first check with the number at 0 to index then 1 then 2 then 3 and it goes on till the end of the array but here if the array is sorted then instead of doing a linear search we can do a binary search so what we can do is we can repeatedly divide an array into half and with the each division we know that we are dividing the array into two halves so we usually compare the element we want to search with the middle element and if suppose the element we want to search is less than the middle element then we can ignore the other half and we can search in the first half and if the element we want to search is greater than the middle element then we can ignore the first half and we can search in the last half so below you can see the algorithm for the binary search now let's see the demonstration of this algorithm step by step so suppose we are given an array having 9 elements and here you can see the array is sorted so suppose we want to search a key having the value of 65 now we know that 65 is in the array and we want to search it using the binary search so what we can do is so the first step what we do is we create an integer variable by name low and we assign a value of 0 to it so here you can see low is having value of 0 so here it means that we are pointing at the first element of an array at the index 0 moving ahead and then we create an integer variable by name high and we assign it a value of say numbers dot length minus 1 so here what we are actually doing in the first step we created an integer variable low and we are pointing it to the first index and then we are creating an integer variable high which will point to the last index of an array which is 8 so here if you see there are total 9 elements in an array and when we do numbers dot length we get 9 and when we do minus 1 we get the 8 so it just means that high is having value as 8 and it is pointing to the last element of an array so friend as the array is sorted and we are applying binary search over it so we are using this while loop and inside this while loop in each iteration we will divide the array into two halves and we will search for the key 65 so the condition we are placing in the while loop is we will iterate till low is less than equal to high so currently you can see low is pointing to the 0th index and high is pointing to the 8th index therefore low is less than high so the condition in while block comes out to be true so in the first step what we are actually doing is we are actually finding the middle element of the array so in order to find the middle element the formula we are using here is we are doing high plus low and we are dividing it by 2 so currently high is having a value as 8 and low is having a value of 0 so when we will do 8 plus 0 by 2 we get mid as 4 so here mid will point to the index 4 which is nothing but the middle element of this array moving ahead so friends here you can see as mid is pointing to the middle element of an array we know that array is divided into two parts from low to middle and from middle to high so first we will check whether the value at mid position is equal to key or not so if the element is equal to key then we have found our key and we will simply return the value of index so currently you can see the value at mid is 59 and if we compare it with the key then 59 is not equal to 65 therefore the condition in if block comes out to be false and then we will check that whether key 65 is less than 59 or not so here you can see 65 is not less than 59 therefore the condition in if block comes out to be false and the else block will be executed so friends here you can see as array sorted and we have identified that key 65 is greater than the middle value therefore we know that 65 would be somewhere in the last half so now we can ignore the first half and we can directly search into the last half so this is how this algorithm works we actually divide using this middle element and we compare it with the middle value and if the value is greater than the middle value we search in the last half and if it is less than the middle value then we search in the first half so now the overhead of searching in first half is gone and we can directly perform our search in the last half so what here actually we do is currently low was pointing to the zeroth index and now we know that our key will be lying between the index 4 and 8 so therefore to the low we are assigning the value as mid plus 1 so it would look something like this that now low will be having value as 5 and it will point to the 5th index moving ahead now in while block we will check whether low is less than equal to high or not so currently low is having value as 5 and high is having value as 8 therefore 5 is less than 8 so the condition in while block comes out to be true so now in the first step we will again find the middle index so we apply the formula as high plus low divided by 2 so currently you can see high is 8 and low is 5 so when we do 8 plus 5 we get 13 and when we divide it by 2 we get 6.5 and when we take it as integer variable the value is rounded up to 6 so now mid will hold the value as 6 so friends here you can see we have again divided the array into two halves using this middle index so in the first step we will check whether the value at mid is equal to key or not so currently here you can see that value at mid which is 75 is not equal to our key which is 65 therefore the condition in if block comes out to be false and then we check whether our key is less than this middle value or not so if key is less than this middle value then we know that we have to search into the first half and if key is greater than the middle value then we know that we have to search in the last half so currently key which is 65 is less than 75 therefore the condition in if block comes out to be true so friends here we know that as key 65 is less than 75 so therefore it must be lying somewhere between the low index and the middle index which is nothing but the first half so now our high will become mid minus 1 because we have to search in the first half so therefore here you can see mid is 6 so when we do mid minus 1 high will store the value as 5 so friends here the key 65 was less than the mid value therefore we know that it must be lying somewhere between the low index and the middle index so therefore we assign the value of mid minus 1 to high so that now we can search in the first half of an array moving ahead we will again check whether low is less than equal to high or not so currently low is having value as 5 and high is also having value as 5 so therefore the condition in while block comes out to be true and we will again find the middle index by the formula high plus low and then we will divide it by 2 so here you can see high is having value 5 and low is also having value as 5 so when we do high plus low we get value as 10 and when we divide it by 2 we get value as 5 so now value of 5 will be assigned to the mid here and now mid will point to the 5th index so friends in the if block we will check that whether the middle value is equal to key or not so here you can see the middle value which is 65 is equal to the key 65 therefore the condition in if block comes out to be true so it means that we have found our key so we can simply return the index position which is nothing but the 5th index and if we don't find any value in an array till low is less than or equal to high then we can come to know that element is not in the array and then we can simply return the index as minus 1 so friends let's go to Eclipse and see the working code so friends here I have created one class by name binary search so inside this class I will be creating the method which can actually perform the binary search so let's create a method as public int so this method will return us back an integer value and I will name it as binary search and this method will take two things one is the integer array which is actually sorted array another would be the key which we want to search in the sorted array so in the first step what we do is we create an integer variable by name low and we will assign a value of 0 to it which is nothing but the 0th index of an array and we will also create an integer variable by name high and we will assign it a value of last index of an array so we will simply do nums dot length minus 1 so now high will be pointing to the last index of an array and then we will provide a while loop and in the while loop we will provide a condition as low should be less than equal to high so we will iterate in the while loop till low is less than equal to high so in the first step what we do is we actually divide the array and we find the middle index so we will create an integer variable by name mid and we will assign it a mid value by applying the formula as high plus low divided by 2 so this formula will return us back the middle index of an array after finding the middle index we will simply check that value stored at the middle index is equal to our key or not so if the mid value is equal to key then we know that we have found our key and we can simply return the mid index and if suppose the value of middle index is not equal to our key then we can provide an if else block so in the if block we will provide a condition as that if key is not equal to the middle value then it must be less than mid value or greater than mid value so if key is less than the mid value then we know that key lies in the first half of an array so we will simply assign the value mid minus 1 to high and in the else block we will simply assign mid plus 1 value to low because we know that if key is greater than the middle value then we can ignore the first half and we can start searching in the last half so at that time low will become mid plus 1 so in the while loop if we find our key then we can simply return the mid index and if we didn't find our key then we can simply return minus 1 which is nothing but the negative index so friend this is the code for binary search now lets test its working in the main method so here first we have initialized the binary search class and then I have created one sorted array which we discussed in the slide so friend lets search for a key having value as 65 so here I will be providing system.out.print talent statement and here we will print the index so we will use this binary search instance and we will call binary search method and inside this method we will pass this sorted array and lets say we want to search for the key as 65 so friend here we know that 65 is in the sorted array so if I run the code now you can see it returned 5 which means that we have found our key at the 5th index so here you can see 0,1,2,3,4 and 5th index so it is actually returning the 5th index where we have actually found our key and lets say if I provide the value as say 100 and we know that 100 is not in this sorted array so if I run the code now so here you can see it returned minus 1 which is the negative index because it didnt find 100 in this sorted array so it finally returned minus 1 so friends in this tutorial we discussed about the binary search in java I hope you like this video please like, comment, share and subscribe my youtube channel thanks have a nice day hello everyone so in this video we are going to discuss search insert position problem so lets see what this problem is and how to solve this so here in this problem we are given a sorted array of distinct integers so the array is sorted and we dont have duplicates we are given a target value and we need to return an index if the target is found if target is not found in the array so as the array is sorted then we have to return the index where it would be if it were inserted in order so here this problem is a search and insert problem so we are given with a sorted array which doesnt have duplicates and we are given with a target value we need to first search the target value in the array and if the target is found we need to return that index and if the target is not found then we need to return that particular index where the target value should lie so for example if we are given an input array which is 1 3 5 7 so this is sorted array in ascending order and the target value is given as 5 so if i put index is on top of the number you can see 5 lies as index 2 so we return 2 now lets say if we are given with the same array and target value is 2 so 2 is not found in the array but if you see as the array is sorted and if we would have wanted to place 2 somewhere in the between and if the array is still sorted you can see it can lie between 0 and 1 so 1 is at 0 index after that 2 would have come so 2 would have come at this place and 3 would have shifted ahead so 2 would have come at first index so we would return output as 1 now lets say if we are given with this input array these are the indexes and target is 8 so here you can see 8 is not found in this array so the probable position for inserting 8 would be after 7 so this sorted array goes from 0 to 3 3rd is the last index and we can only insert 8 after 7 which is the 4th index so we return the value as 4 similarly so this was the extreme case where we need to put 8 outside the boundaries of the array in this direction now lets say if we are given with this array and target is 0 so here you can see 0 is not found in this array and 0 can only lie before 1 but before 1 we have index minus 1 so this minus 1 is not a valid index in an array so our target would lie at 0 index only and the rest of the elements will get shifted in this direction why we not added 0 at minus 1 index because minus 1 index doesn't belong the array should start from 0 index so the only place to put target is at 0 index so we return the output as 0 and the rest of the elements can shift here but here when the target was 8 2 index 4 was not in the array but 4 is a valid index an array can have a size where index 4 can belong but an array cannot have an index minus 1 so therefore these two are some of the cases we need to handle and we need to run the algorithm in log of n time because we can directly search in the array in O of n time and we can place the element at that particular index because the array is sorted so we need to use an algorithm which runs in log of n time so lets move ahead and see that so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here this is the algorithm where the method name is search insert it takes in an array and a target and returns the index that where this target should belong so here as we need to run the algorithm in log of n time we basically take the help of binary search and try to figure out the proper index for this target now why we are applying this binary search is first the given array is sorted and second we need to find the target in the array and return that index so one is the search part which we need to do in log of n time so here why the search is in log of n time is because when we try to run the binary search on a sorted array what happens is each time if the value is not found half of the array is discarded because as the array is sorted we keep on discarding the half of the array with every iteration of while loop so we will see that later and if you see the time complexity of binary search it is log of n so we will see that how we can apply the binary search and try to figure out the index for the target so most of the algorithm is pretty much same as our binary search but there are some things to understand that how we can figure out the index of a target if it is not found in the array so let's say we call search insert we pass in the array and we pass the value of target as 66 so target becomes 66 now our task is to find 66 in this sorted array if we found an index here then we simply return the index of the array where we found the target and if not then we need to find that particular index where this target would lie so at the start as we need to apply this binary search on complete array we take two pointers low and high low starts from 0 index and high starts from the last index which is array.length1 which is 8 so if we do array.length we get 9 and if we do minus 1 we get 8 so high starts from 8th index so now we apply the binary search and we provide a while loop where the condition we provide is low should be less than equal to high so once low crosses high we need to stop this algorithm so currently value of low is 0 and high is 8 so this condition comes out to be true so friends how this binary search works you can also watch my videos on binary search but here I will explain that as the array is sorted we don't directly search each and every element of the array because that would take O of n time complexity because we are comparing target with each and every value and as array is sorted we can use that property what we can do is we can try to find a mid element and we simply compare that mid element with target so let's see how so in order to find the mid index we use this formula we do low plus high minus low by 2 so here in binary search we also do something like low plus high by 2 but here we are using this type of approach because this formula will actually avoid the integer overflow condition so let's say if you are given with a very huge array which actually touches the boundaries of integer range so if we do the addition of low and high there could be a possibility that the range of integer is overflowed so we will get undesired value and so this part where we are doing low plus high would fail and our binary search will not work properly so therefore what we do is we apply this part where we are doing high minus low so here high would be a very large number and low would be a number which is lesser than high so when we are doing subtract we are going back into the integers range only and when we are dividing it by 2 we are going further down and then we can safely add it with low to get the value of mid index so if we do low which is 0 plus high which is 8 minus 0 by 2 so 8 by 2 will give 4 which would be our mid index so mid value would be 4 this now the significance of taking the mid index is we directly see what value is at mid so here it is 59 we check whether it is equal to our target or not so here we can say 59 is not equal to 66 which is our target so therefore this if condition comes out to be false and then we check whether target is less than the value at mid index so here 69 is not less than 59 so this condition also comes out to be false so here you can see the basic idea is after calculating mid we take the value at mid index and there could be 3 possibilities that this value is equal to target this value is less than target or this value is greater than target so here we know that the array is sorted so if target is less than array of mid and as array is sorted we know that the target might lie in this range and here target is greater than array of mid here you can see 66 is greater than 59 so we are sure that 66 might lie in this range because the array is sorted 66 can't lie in this direction because array sorted all the numbers before 59 will be lesser than 59 and all the numbers in this direction will be greater than 59 so our chances that 66 might lie in this direction so therefore what we do is as 66 is greater than 59 we know that it might lie in this direction so here in binary search we can safely discard this much array because with this comparison we are sure that target will never lie in this index it can only be found in this index because it is actually greater than the mid value so therefore we bring this low to this point because if array of mid is not equal to target we then perform our search from 5th to 8th index so high will be at the same position we bring low to this direction so what we do is the new value of low would be mid plus 1 so mid is 4 and if we do plus 1 we reach 5th index so low becomes 5 it will point to 5th index so now our search will continue from index 5 to 8 and we will discard this much array so at every step when we evaluate mid and perform this check after that we actually discard half of the array so therefore this algorithm runs in log of end time because at every step we are discarding half of array because the possibility of target could be either in this direction of mid or in this direction of mid if it is not equal to mid so therefore the algorithm runs in log of end time moving ahead now we are trying to search 66 in this range so low is less than equal to high we first evaluate the mid index so low would be 5 plus high would be 8 minus 5 by 2 so this will give 3 by 2 and this would give 1 so mid would be 6th index like this so it will point to the 6th index so friendship array of mid here it is 75 if it would have been 66 then we would have found our target and problem states that if we are finding our target then we should return the index of that spot where the target belongs but here you can see that array of mid is 75 it is not equal to our target which is 66 so therefore this condition comes out to be false and now we check whether target is less than the value at mid index so if we compare 66 we get it is less than 75 which is our value at mid index which is 75 so this condition comes out to be true so here as the array sorted and 66 is less than 75 we know that it must lie somewhere in this direction if 66 would have been greater than 75 we would have discarded this spot and we would have searched in this spot but as 66 is less than 75 now we can safely discard this spot so how we can discard this spot is as high is pointing to 8 now in the next search high should go from mid1 so therefore we assign mid1 to high so high becomes 5 which is at 5th index and here you can see by doing this we have discarded half of the array and now we are searching in this spot moving ahead low is actually equal to high so therefore this condition in while loop comes out to be true so first we will evaluate the mid index so low and high both are pointing to 5th index so 5 plus 5 minus 5 by 2 and the answer would be 5 so mid will become 5 which will point to the 5th index like this now first we check whether value in the array at mid index whether it is equal to target or not so 65 is not equal to 66 so therefore this condition comes out to be false and then we check whether target is less than the value of array at mid index or not so our target is 66 and the value of array at mid index is 65 so therefore 66 is greater than 65 so this condition comes out to be false so it means the new value of low would be mid plus 1 because this value is less than target so we need to search in this direction so the new value of low would become mid plus 1 which is 6 because value of mid is 5 so low will point to the 6th index now so from now here you can see value of low is greater than high high is at 5th index and low is at 6th index so therefore this value will terminate and here you can see that one critical step is if we have found a target we simply return the mid index but if we haven't found a target and the binary search ends here at whatever index low will be that will be our actual index to insert the target so here 66 was greater than 65 and as there are distant integers the probable index for inserting 66 would be this which is being pointed by low and then rest of the elements can shift ahead so we simply return the index that it is the value which is being assigned to low when the binary search ends so why we are only returning low but not high so we will see it by an example so for this this step is very important that we always return the index value of low and that would be our actual value where this target might lie so now we will see that why we are actually only returning low and not high so friend let's say if we are given with only one element let's say the value would have been 4 it would have been at 0th index and let's say the target value would have been 5 so we know that answer would have been 1 because at 0 we have 4 so 5 will lie at index 1 so at the start low will point to 0 and high will also point to 0 because array.length is 1 11 will give 0 and low is actually equal to high so this condition is true the mid would have been 0 plus 00 by 2 which is 0 so this would have been our mid this condition would have been false because 4 is not equal to 5 so target which is 5 is not less than 4 so this condition would have been false so here you can see then the else part would have been executed it must lie in this direction so therefore we do low equal to mid plus 1 so when we do mid plus 1 low becomes 1 which is at first index so therefore after this statement in the while loop low value is 1 and high value is 0 and we know that we have to return 1 because 5 will lie after 4 so this is the one case so let's say now our target is 3 so we know that 3 will lie before 4 here somewhere but here you can see index of 4 is already 0 and 3 can't lie in minus 1 index because this index is not an array so therefore answer would have been 0 only because 3 will lie here and 4 will shift ahead so here low is and high is at 0 index low is equal to high so this condition is true the mid would be 0 plus 0 minus 0 by 2 which is 0 so mid comes at 0th index only the value at mid index which is 4 is not equal to target because 4 is greater than target so here you can see target is actually less than array of mid 3 is less than 4 so therefore this condition would have been true now and high would have become mid minus 1 so it means as the array sorted 3 must lie in this direction so therefore high will become mid minus 1 so mid is 0 and if we do minus 1 high will reach at a value minus 1 so in the next iteration of while loop this condition comes out to be false because value of high is less than low because low is referring to 0 index and high is referring to minus 1 this condition would have been false and here you can see at the end we are actually returning the value of low which is our answer that 3 will lie at 0 index only so therefore we need to keep a note that low will be the answer that where this target might lie if it is not found in the sorted array and this is pretty much similar to the binary search algorithm but this step is very critical to understand so friend this was all about the search insert problem I hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so friend in this section of course we will be discussing about various sorting algorithms and in this lecture we will discuss what is bubble sort algorithm so we will be looking into the demonstration of bubble sort algorithm and later we will look into its implementation so here what is bubble sort so if you see bubble sort is also called as sinking sort now what do we mean by sinking sort so here let's say we are given an unsorted array which has some random numbers and if we apply the algorithm on those random numbers so usually the algorithm works in various iterations and with each iteration the largest element tends to sink at the end of the array and when they sink to the end of the array they are usually placed at the correct position and after every element is placed at its particular position at the end we get a sorted array so how does this algorithm work is as we are given few numbers which are unsorted so usually this algorithm it repeatedly compares the pair of adjacent elements and swap them if they are in wrong order so when the few numbers are given which are unsorted we start with the first two numbers and we compare them to check whether they are in correct or wrong order and if they are in wrong order we simply swap them and then we move to the next two numbers so let's look into an example where we are given an unsorted array so here inside this array there are six numbers which are unsorted and now let's say we want to sort them in ascending order so now what do we do is we compare the adjacent elements repeatedly so in the first pass we compare the first two numbers and as we want to sort this array in ascending order we simply compare that the number on the left is greater than the number on the right or not so if the number on the left is greater than the number on the right then we know that they are in wrong order so here three is greater than one so we know that they are in wrong order so what do we do is we perform a swap so after performing the swap between these two numbers one comes to the left and three goes to the right and after performing the swap we simply move to the next adjacent elements we compare three with five and three is less than five so therefore they are in correct order so we perform no swap and then we simply move ahead with the next two numbers now here you can see five is greater than two so therefore they are in wrong order so we perform a swap and after we perform a swap two goes to the left and five goes to the right and then we move to compare the next two adjacent elements here we see five is less than six so therefore they are in correct order so we do no swap and at the last six is greater than four so therefore we perform a swap because they are in wrong order so four goes to the left and six goes to the right so after the first pass completes you can see that six, which is the largest element among the array tends to sink at the end of the array and here you can see being the largest element six is actually at its correct position so now with the first pass the first number got its correct position now we again perform the steps with the second pass but this time as six is at its correct position we don't include six in our comparison so now our new array is from index zero to four so initially it was from zero to five as we got one of the number correctly sorted for the second pass our array becomes from zero to four so we start comparing the first two elements now one is less than three therefore we perform no swap now three is greater than two so it means they are in wrong order so we simply perform a swap here so two goes to the left and three goes to the right moving ahead we compare three with five three is less than five therefore no swapping is done and then we compare five with four so five is greater than four therefore we perform a swap because they are in wrong order so four goes to the left and five goes to the right and as we don't include this element after completion of the second pass you can see the second largest element among this list which is five is correctly placed at the second last position just before the six so when here you can see that this algorithm needs to make the largest element sing at the end of the array so similarly this algorithm continues but here you can see the numbers are now in one, two, three, four so by looking at the array the numbers are already sorted but there is no way for the algorithm to know that the numbers are sorted because the algorithm has to make the comparisons so in order to make the algorithm know that the array sorted what we do is we simply keep the track of the swapping so let's see how we can do it in the third pass so we compare the first two elements one is less than two so therefore they are in correct order so no swapping is done so here we perform no swap two is less than three so therefore there is no swap three is less than four so therefore there is no swap so from here you can see in the third pass we didn't perform any swap so at the end of the third pass we simply check that whether we had performed any swap or not so if we haven't performed any swap we can come to know that array is already sorted so friend usually with each iteration or with each pass we simply keep the track of swapping and if in any particular pass no swapping is done then we can directly come to know that the array is already sorted and we simply break from the algorithm so friend this is the demonstration of the bubble sort algorithm in our next lecture we will see the demonstration of the code and then we will write the implementation of it in eclipse and see its working I hope you like this video thanks have a nice day hello everyone so in our previous lecture we discussed about what is bubble sort and we saw its demonstration with an example so in this lecture we will see the demonstration of the code using an animation so here let's say we are given an unsorted array having 5 elements as 5 1 9 2 10 now we want to sort this array in ascending order by applying the bubble sort algorithm so here you can see that this is the bubble sort algorithm so friends in our previous lecture we saw the demonstration of the algorithm where we discussed that we start comparing the adjacent elements and if they are in wrong order we simply swap them and usually when we complete one particular iteration the largest element tends to sink at the bottom of the array or at the end of the array and we also discussed that with each iteration we keep the track of the swapping and if no swap is done in any particular iteration we simply come to know that the array is already sorted so let's see the demonstration of this algorithm step by step so here the number of elements are 5 with an index from 0 to 4 so at the first step what we do is we simply create a boolean variable we give it a name as isSwapped now this boolean variable will keep the track of the swapping in each iteration that whether the swap is done or not so here you can see at the last step what we simply check that if the swap is not done then we come to know that the array is already sorted so we simply break from this algorithm so we will see its usage inside this algorithm so here we have created the boolean variable isSwapped so from here you can see there are two for loops one is the outer for loop and other is the inner for loop so usually the outer for loop basically keep the track of each and every iteration and the inner for loop will simply help us in performing the comparison with the edges and elements so let's see the usage of these two for loops so with the outer for loop we start with i equal to 0 and this for loop will loop till i is less than n1 so here you can see 51 which gives 4 so this for loop will travel 4 times as it is starting from 0, it will go from 0, 1, 2, 3 so with total 4 iterations so usually this outer for loop what it tracks is here you can see there are 5 numbers and we also discussed that with each iteration the largest element tend to go to its correct position by syncing at the end of the array and once it syncs to the end of the array we simply don't include that element in the next iteration so here as the outer for loop will travel 4 times with each time we get a number sorted at its correct place so here there are 5 numbers so with 4 iterations we will get the 4 numbers sorted correctly at their position and as the 5th number is the only number left it will be already sorted to its correct position so therefore we iterate this for loop from 0 to less than n1 so currently value of i is 0 and it is less than 4 which is n1 so the condition in for loop comes out to be true and as we want to track that whether any swap has been performed with each and every iteration with this iteration we start with is swerved as false and moving ahead now we encounter the inner for loop which simply compares the edges and elements and perform the swap so here you can see the inner for loop starts from j equal to 0 and here it goes till j is less than n1 minus i now here you can see that the outer for loop is controlling the inner for loop now why we are doing it is with each iteration the largest element will sink to the end of the array and once those elements are sinking to the end of the array we don't have to include those elements so as the outer for loop is incrementing one by one the j will traverse only to those positions which are still unsorted so let's see it via demonstration so currently j is less than 5 minus 1 minus 0 because i is 0 so the condition in for loop comes out to be true and for loop executes and here inside this for loop we are simply providing an iflock where we are simply comparing the edges and elements j and j plus 1 and as we are sorting this in ascending order we are simply checking that the value at jth index is greater than value at j plus 1th index or not so it means we are simply comparing these two elements now here you can see 5 is greater than 1 so therefore they are in wrong order so we simply perform a swap so here the condition in iflock comes out to be true and here inside the iflock we are performing the swap so usually how we perform a swap is we create a temporary variable and we store one of the values inside the temporary variable so here we are storing the value at jth index to the temporary variable because in the next step we will override this value and we actually need this value in the later computation so as we want to swap these two elements now we are taking the value at j plus 1th index and we are assigning it to the jth index so it becomes 1 and at the last step as we have stored this value into the temporary variable 5 we simply assign the temp to the array at the j plus 1th index so here you can see we have swapped both the numbers using the temporary variable and then we mark a swapped variable with a value true because we have performed one swap in this iteration so it becomes true moving ahead now we will increment j by 1 so j becomes 1 and 1 is less than 5 minus 1 minus 0 which is 4 so the condition in for loop comes out to be true and here as j is 1 so it will simply point to the first index and j plus will point to the second index because now we want to compare these two elements and here as 5 is less than 9 therefore they are in correct order so we perform no swap as the condition in if block comes out to be false there is no swapping we will increment j by 1 so j becomes 2 and 2 is less than 4 so the for loop executes now the value of j is 2 therefore now we will compare 9 with 2 so here you can see as 9 is greater than 2 therefore they are in wrong order so here we need a swap so the condition in if block comes out to be true because 9 is greater than 2 so now we will simply swap using the temporary variable which we saw in our previous steps so we store 9 in the temporary variable then we store 2 at the place of 9 and then we store the value stored in a temporary variable at the third index on the place of 2 so here we have simply performed a swap between these two elements and we assign value true to a swapped variable which is already true we will increment j by 1 so j becomes 3 and 3 is less than 4 now we are simply comparing the jth index with j plus 1th index which is the third index with fourth index comparing 9 with 10 so here you can see 9 is less than 10 so therefore no swapping is done and the condition in if block comes out to be false so we simply skip this part we will increment j by 1 so j becomes 4 and j becomes 4 so j becomes 4 so now here you can see value of j is 4 and 4 is not less than 4 therefore the condition in for loop comes out to be false and this for loop exits and just after the for loop we have completed our one iteration completely so we simply check that whether in this iteration we performed any swap or not because if we haven't performed any swap in this iteration then the algorithm comes to know that the array is already sorted but here you can see the value of we swapped is true so therefore this if condition comes out to be false so here you can see the outer for loop has performed its one iteration completely with the value of i equal to 0 so after the first iteration of the for loop you can see the largest element which is the 10 has basically sink to the end of the array and here now you can see 10 being the largest element is at its correct position so now we will increment i by 1 and 1 is less than 4 therefore the condition in for loop comes out to be true so for now next pass starts so we simply assign the value false to the swapped variable and now the second pass starts so we start comparing it from the first two elements with j equal to 0 so from here you can see the value of i is 1 and value of i is basically controlling the inner for loop and why it is controlling because with the first iteration we have found our one element which is sorted and it is at its correct position so therefore when we are starting our next pass we don't want to include this element so our array has now become from 0 to our index so therefore we are subtracting 1 from this condition because value of i is 1 so it means the inner for loop will simply compare these elements from 0, 1, 2, 3 and it will not touch the fourth element using this condition so currently you can see j is 0 and j is less than 5 minus 1 which is 4 minus 1 which is 3 so 0 is less than 3 and we simply perform the comparison what we did in our previous steps we compare the value at jth and j plus 1th index so here as 1 is less than 5 therefore they are in correct order so no swap is done and the condition in if block comes out to be false now we will increment j by 1 so j becomes 1 1 is less than 3 now we simply compare the elements at index 1 and 2 because value of j is 1 here 5 is greater than 2 so therefore they are in wrong order so we simply perform a swap because condition in if block comes out to be true so we simply store 5 into the temporary variable and then we migrate this value which is stored at the j plus 1th index we simply assign it to the jth index so it becomes 2 using this step and at the last we simply assign the value stored at the temporary variable to array at j plus 1th index so it becomes 5 so we have performed a swap here so as we have performed a swap we simply assign the value true to a swapped variable we will increment j by 1 so j becomes 2 2 is less than 3 now we compare the second index with the 3rd index using array of j is less than 1 so 5 is less than 9 therefore they are in correct order so no swap is done we will increment j by 1 so j becomes 3 now here you can see 3 is not less than 3 therefore the condition in for loop comes out to be false and for loop exits and here we simply check whether a swapped is equal to false or not but here a swapped is true because we had performed one swap here so therefore the condition in if block comes out to be false and friends here you can see with the completion of the second iteration of the outer for loop the second largest element which is 9 is at its correct position which is the second last position so here bubble sort makes the largest element tend to sing at the end of the array the second largest element tend to sing at the second last position and similarly it goes on like this so now we will again execute for loop with i equal to 2 by incrementing the value of i so i becomes 2 2 is less than 4 we assign false to a swapped variable because with this inner for loop we are starting our new iteration so here you can see as these two elements are basically sorted so we are using the value of i which is 2 to control the inner for loop in this condition here so j is starting from 0 and it will go till which is 5 minus 1 which gives 4 minus 2 which gives 2 so 0 is less than 2 so now we will again start comparing these two elements and as 1 is less than 2 therefore they are at correct order so no swapping is done and also friend here you can see the importance of this Boolean variable because if you see the array is already sorted but the algorithm doesn't know this so here when the j was equal to 0 we didn't perform any swap and the swapped value remained false now we will increment j by 1 so j becomes 1 1 is less than 2 so we simply compare the elements at index 1 and 2 so 2 is less than 5 therefore they are in correct order so no swapping is done so this Boolean variable still remains false will increment j by 1 so j becomes 2 and here you can see 2 is not less than 2 so therefore this for loop will terminate because the condition in for loop comes out to be false and friends here you can see at the last step we are simply comparing that whether a swapped is false or not so here is 7 value is false which tells us that array is already sorted and we don't want to continue this algorithm further because we were keeping the track of the swapping so in this step the condition in if block comes out to be true and we simply break this for loop so in this step the condition in if block comes out to be true and we simply break this for loop so friends here we saw the demonstration of the bubble shot algorithm so in our next lecture we will see the demonstration of this algorithm in eclipse I hope you like this video thanks have a nice day hello everyone so friends in this lecture we will code the bubble shot algorithm and we will simply test its working so in eclipse I have created one class as bubble shot and inside that I have created one method print array so this method will simply take the array and will simply print its content on the console so we have already discussed this algorithm in our previous lectures when we discussed about the arrays so I will be using this print array method to simply demonstrate that whether our array is sorted or not so inside this class I have provided a main method where I have created an unsorted array which we already discussed in our previous slide and at the first step what we are doing is we are simply calling the print array method and providing this array to simply see the contents of this array before performing the sort so here you can see the array is not sorted so let's write an algorithm to sort this array so in this lecture we will see about the bubble shot algorithm so we will create a method as public void we will give it a name as sort and to this sort method we will pass the integer array which is the unsorted array so when inside this method the first step we do is we simply calculate the value of n which is the number of elements inside this array so we simply do array.length and as per the algorithm which we discussed in our previous lecture we will first create a boolean variable isSwapped so we have created this variable to keep the track that in any particular iteration we perform any swap or not so if we have performed any swap then we are ensure that array is sorted or not also in any of the iteration if we haven't performed any swap then we can come to know that the array is already sorted moving ahead we first provide a for loop which starts from zero and goes till n1 and also friend we discussed that value of i will basically control the inner for loop because as we are comparing the adjacent elements we need to stop at a point where we don't want to compare further so here with the start of any iteration we simply provide a value false to a swapped variable and now we will provide the inner for loop where j will start from zero and j will traverse till n minus 1 minus i j++ so friend we already discussed that why we are providing this condition here is because we need to control the inner for loop by the outer for loop value which is the i so we are simply providing i here now inside the inner for loop our basic comparison will start so we simply start with comparing the adjacent elements that if the value of index j if it is greater than value at index j plus 1 then we know that they are in wrong order so we simply perform a swap so inside is if block in order to perform swap we create a temporary variable and we simply store the value at the jth index so that we can use this value to perform the proper swap so after we take out the value at the jth index what we do is now we can simply store the value at j plus 1th index to the jth index because we need to perform a swap and the final step we simply store the value present in the temporary variable to the array at j plus 1th index so in these three steps we are simply performing the swap of the values present in the jth and the j plus 1th index because they are in wrong order as value at the jth index is greater than value at j plus 1th index so after we perform swap we simply assign a value true to a swap variable to keep the track that inside this for loop when we compare the adjacent elements we did perform a swap so after every iteration here what we do is we simply check that whether we perform any swap or not so if we didn't perform the swap we know that array is already sorted because all the adjacent elements are at its correct position so we simply break from this algorithm and if we had performed any swap then the value would have been true so we are unsure till this point that whether array is sorted or not but if the value it hold its false then we are sure that array is already sorted so when this is the bubble sort algorithm which we already discussed in the previous lecture and in this lecture we have simply provided the code for it so now let's test its working so here what we do is we simply call the sort method we provide the array and after we have performed the sorting we simply print the array again so if I run the code now so from here you can see initially the array was 5 1 2 9 10 which is the content of array before sorting and then we perform the sort on this array and after performing the sort we simply printed the array again and we found that array sorted with all elements to its correct position 1 2 5 9 10 so the array sorted in ascending order in this tutorial we saw the demonstration of the bubble sort algorithm we tested its working in the main method so friends I hope you like this video thanks have a nice day hello everyone so friends in our previous lecture we discussed about the bubble sort algorithm so in this lecture we will discuss about the insertion sort algorithm so let's discuss this algorithm in detail so here if you see insertion sort is a simple sorting algorithm works the way we sort playing cards in our hands so when we play with the deck of cards usually most of the games are involved where we keep few cards in our hand and what we generally do is we keep them in proper order so how do we manage to keep them in proper order is we use the insertion sort algorithm so let's say we have this deck of cards which is lying in front of us and let's say we pick few random cards from the top of the deck so usually what we do is when we pick up the first card we simply keep it in our hand because it is already sorted and when we pick the second card the card which we have picked we simply compare it with the card which we have in our hand and based on the comparison we either keep that card before or after the first card the deck of cards which is lying in front of us are basically in random order or you can say they are basically unsorted form and the cards which we have in our hand are basically kept in sorted form so when we pick up the third card from the random cards now the card which we have picked we simply compare it with the cards which we have in our hand so we compare the third card with second and then with the first card and based on the order which we are following we simply place the third card either after the second card or in between first and second card or just before the first card so similarly let's say we have this unsorted array so using the insertion sort algorithm we divide the given array into two parts one is the sorted part and the other is the unsorted part so how the algorithm works is from the unsorted part we take the first element and place at its correct position in the sorted array so here we are simply picking one element from the unsorted array and based on some logic we are simply putting that element into the sorted array at its correct position so this is done by shifting all the elements which are larger than the first element by one position so here let's say we are sorting the array in ascending order so the first element which we pick from the unsorted part we simply compare the element with each and every element in the sorted array and all the elements which are larger than the first element we simply shift them by one position and as soon as we encounter any element which is smaller than the first element we simply store this first element just after that and this process is repeated till unsorted array is not empty so friend let's see the demonstration of insertion sort algorithm with an example we will take an unsorted array we apply the algorithm mentioned here and we will see that how we can sort the array so friend here you can see that we have this array from index 0 to 5 so basically there are 6 elements with the value as 3, 1, 5, 2, 6, 4 now let's say we want to sort this array in ascending order so how do we start this algorithm is we simply pick the first element so here it is 3 and as we have picked the element 3 we know that there is only one element so it's already sorted so basically this algorithm starts from the second element because the first element is already sorted so friends in our previous slide we discussed that we divide the array in two parts one is the sorted part and other is the unsorted part so when we start our algorithm from the second element so the elements to the left are basically sorted and the elements to the right are basically unsorted so now what we do is from the unsorted part we simply pick the first element which is 1 and what do we do is we simply store this element let's say to a temporary variable so as soon as we store this element to a temporary variable what do we do is we simply provide a whole here that this part is empty so after providing this empty space what do we do is we simply compare 1 with the element in the sorted array now as we are sorting this array in ascending order we simply compare that whether 1 is less than 3 or not so here 1 is less than 3 so therefore 1 should come before 3 here you can see there is no space so what do we do is as we discussed in our previous slide we simply shift the elements which are larger than 1 by 1 position so here we will simply shift 3 to this empty space so after we perform this shift are there any other elements in the sorted array or not so here you can see there was only 1 element 3 there are no other elements so we simply place 1 at its correct position so after placing 1 at its correct position you can see that now our sorted array has 2 elements 1 and 3 in sorted form so now we simply pick the first element from the unsorted array so we simply pick 5 we store it into a temporary variable and we create an empty space here now what do we do is we compare 5 with 3 and we know that 3 is smaller than 5 therefore 5 has to be placed after 3 which is this spot only so there is no shift because the element to which we are comparing in the sorted array is already small from the element which we picked from the unsorted array so the position of 5 will not change 5 will be stored at its own position and here you can see that as 3 was less than 5 we didn't compare 1 with 5 because as this is a sorted array 1 will be by default smaller than 5 so after placing 5 at index 2 now our sorted array has 3 elements 1, 3, 5 and from the unsorted array we simply pick the first element which is 2 we store this 2 into a temporary variable and we create an empty space here now what we do is we compare 2 with 5 so 2 is less than 5 so we know that 2 must be lying somewhere before 5 but here you can see in sorted array there is no space left so what do we do is we simply shift the larger element by 1 position and as here is the empty space we can simply shift it here so 5 comes here and the empty space comes here so friends here we are not sure that whether this is the correct position of 2 or not so what do we do is we simply compare 2 with this element which is 3 so here you can see 3 is also greater than 2 so we know that 2 must be lying somewhere before 3 so what do we do is we simply shift 3 by a position and as here is the empty space 3 comes here and the empty space goes here so friends we are still not sure whether 2 must be placed here or not so we simply compare 2 with 1 and here you can see that 1 is smaller than 2 so therefore we are sure that 2 must be lying after 1 and the position after 1 is empty so we simply store 2 at this empty position so friends after this step now we have 4 sorted elements and 2 unsorted elements so we simply pick the first element from the unsorted part which is 6 we store 6 in the temporary variable we create a empty space here and we compare 6 with 5 so as 6 is greater than 5 we know that it must be lying after 5 so after 5 we have this empty space so 6 will be stored at its own position so now our sorted part is 5 elements 1, 2, 3, 5 and 6 which are sorted and in our unsorted part we have now only 1 element left so we simply pick the first element which is 4 we store it into a temporary variable and we create an empty space here now we compare 4 with 6 so we have 6 elements now we compare 4 with 6 so 4 is smaller than 6 so it must be lying before 6 but there is no space left here so we simply shift 6 by 1 position here so 6 comes here and we have empty spot here so now we are not sure whether we simply put 4 here or not so we simply compare 4 with an element just before the empty spot which is 5 so that we are sure that whether 4 can be placed here or not so as 5 is greater than 4 therefore we know that 4 must be lying before this element but here there is no space so we simply shift 5 by 1 position to this empty spot and the empty spot reaches here now we are still not sure whether we need to place 4 here or not so we simply compare 4 with 3 now as 4 is greater than 3 we know that it must be lying after 3 and here you can see after 3 we have this empty space so we simply store 4 to this empty space so then after this step you can see the complete array sorted so here we saw the insertion sort technique where we divided the array into 2 parts one was the sorted part and other was the unsorted part and with each step we simply picked the first element of the unsorted part and we simply placed it into its correct position in the sorted part and this we did till the complete array was sorted so in this lecture we saw the basic demonstration of insertion sort technique in our next lecture we will see the working of the code step by step using an animation I hope you like this video thanks have a nice day hello everyone so friends in our previous lecture we discussed about the insertion sort and we saw the demonstration of the sorting algorithm now in this lecture we will see the demonstration of insertion sort algorithm step by step so friends here you can see that this is the algorithm to perform insertion sort so let's say we are given an array having 5 elements which contains values as 5, 1, 9, 2, 10 so here you can see the values are in unsorted form so let's see the demonstration of this algorithm step by step to sort this array in ascending order so here the number of elements inside this array are 5 which are ranging from index 0 to 4 so friends while performing the insertion sort the first thing we encounter is the for loop so here you can see this for loop goes from i equal to 1 and it goes till i is less than n so friends in our previous lecture we discussed that when we perform insertion sort we usually divide the array into two parts one is the sorted part and the other is unsorted part so here you can see that when we start sorting this array all the elements are in unsorted part and no element is in sorted part so what we do is we simply pick one element which is the first element of the unsorted part so let's say we pick 5 and as soon as we pick 5 as 5 is the only element which we want to sort therefore we directly place 5 to the sorted part because we don't have to compare 5 with any element so instead of doing this stuff we directly start from i equal to 1 which is this position because 5 is already sorted into its correct position so usually this algorithm starts from i equal to 1 so here you can see that 5 is in sorted part and all other elements are in unsorted part so we always start from i equal to 1 and as i having value as 1 is less than 5 therefore the condition in for loop comes out to be true so friends here when we perform insertion sort one rule of thumb is we always pick the first element of the unsorted part and we try to put it in sorted part by comparing one with all the elements in the sorted part and placing it into its correct position so when we perform this comparison in the sorted part all the elements which are larger than this first element we simply shift them by one position so that there is an empty space where we can simply put this element so here you can see the space are already occupied with some numbers so when we perform a shift there can be a chance that some numbers can be overridden so what we do is we simply store this value which we want to compare with the elements in the sorted part we simply store it into a temporary variable here moving ahead so friends now we want to compare this element with the elements present in the sorted part so here you can see as we have picked the first element of the unsorted part if we go one position back we will get the elements of the sorted part so we simply do i1 and to access the elements of the sorted part we simply store it in the j variable so here j becomes zero so usually the elements of the unsorted part are accessed via i and the elements of the sorted part are accessed via j so friends now we provide a while loop because we want to compare this element with each and every element in the sorted part and all the elements which are greater than this element we simply shift it by one position so that there can be a space where we can simply put this element and as we are sorting this in ascending order so here the condition we provide in while loop is that j should be greater than equal to zero because inside this while loop we are decrementing j by 1 so we have to provide this condition that j should be greater than equal to zero because we don't want to go outside of this array and also why we are decrementing j by 1 is we need to compare this element with each and every element in the sorted part so that we can put this element into its correct position so the first condition is j should be greater than equal to zero so here j is equal to zero therefore this condition comes out to be true and then we provide one more condition as the element at jth index is greater than temp or not so here you can see the value of j is zero so the element at index 0 is 5 and here you can see 5 is greater than 1 so we know that as we are sorting this array in ascending order one should be placed before 5 so therefore this condition in while loop comes out to be true and we want to find out the correct position of 1 so what do we do is in the first step as 5 is greater than 1 and as we discussed in our previous slide that all the elements which are greater than 1 we have to shift by one position so how we perform shift is as we have already stored 1 into this temporary variable therefore it's like a hole here and we can shift 5 here so we simply assign the value stored at jth index which is 5 2 value at j plus 1th index so j is zero and j plus 1 is 1 so we are simply storing 5 to this place so here now 5 has been shifted to this position and after this shift we simply decrement j by 1 because now we want to compare 1 with an element just before 5 so we simply decrement j by 1 so as j is zero j becomes minus 1 so here it means that now j is pointing to minus 1 which is an index which is out of this array so friend as here you can see that in our sorted part there was only one element 5 so we compare that element with 1 and there are no more elements to compare so therefore this condition where j is greater than equal to zero comes out to be false because j is equal to minus 1 so the condition in while loop comes out to be false and while loop exits and at the end we have found a position where we need to store 1 so that position is j plus 1 because as j is pointing to minus 1 so it means j at travel till minus 1 position to basically shift the largest elements by 1 position so when we do j plus 1 here we are simply storing the value 1 at index 0 because as j is minus 1 j plus 1 becomes 0 so we are simply storing 1 at 0th index so friend after performing this all steps now here you can see that 1 and 5 are basically 2 elements which are sorted so therefore with each for loop iteration we will get one element which will be now part of the sorted array so here now 1 and 5 are part of sorted array and rest of the elements are part of unsorted array sorted array so here now we will increment i by 1 so i becomes 2 so friend as we already discussed that we simply pick the first element of the unsorted part in order to make this element to be placed in its correct position in the sorted array so we simply start with storing the value at i at index into a temporary variable and why we are storing into this temporary variable is because we want to create a whole here so moving ahead now in order to access the sorted array we simply do i minus 1 so the value of j is 1 in while loop we simply check whether j is greater than or equal to 0 or not so j is greater than 0 so this condition comes out to be true and then we simply check that the value stored at jth index is greater than temp or not so here you can see value of j is 1 so the value at first index is 5 and 5 is not greater than 9 so therefore this condition comes out to be false and the while loop exits so here you can see that as we are sorting this array in ascending order we want a correct position for 9 in the sorted array so as there are only two elements which are sorted 1 and 5 when we compared 9 with 5 we found that 5 was not greater than 9 so therefore the correct position of 9 would be after 5 so here this while loop exits and at the end we simply store the value 9 in the array at jth index so value of j is 1 when we do plus 1 we get 2 so we simply store the value 9 as index 2 so now you can see that 3 elements 1, 5, 9 are properly sorted so therefore 9 will be now part of this sorted array we increment i by 1 i becomes 3 and now we simply pick the first element of the unsorted array so we simply store the value 2 as a temporary variable because now we want to place this 2 into its correct position in the sorted array so when we perform these steps we need to shift some of the elements by one position so that we can place 2 to its correct position so when we shift this element by one position we need to create a space here so what do we do is we simply store this value somewhere into the temporary variable because we need to refer this while comparing it with the elements in the sorted array so in order to access the sorted array we simply do i1 so j will keep the track of the sorted array so now we will perform the comparison that j is greater than or equal to 0 so value of j is 2 therefore this condition is true so now we will compare this 2 stored in this temporary variable with the element stored at jth index which is 9 so here you can see 9 is greater than 2 therefore the condition in while loop comes out to be true and as 9 is greater than 2 we know that 2 must come before 9 so for 2 coming before 9 we need to create a space here so what do we do is we simply shift this value by one position by storing the value at jth index into j plus 1th index so j is 2 so this value 9 we are storing in j plus 1th index which is the 3rd index so 9 comes here with a shift and as we have already stored this value at temporary variable we can overwrite this part so 9 goes to the 3rd index so now we have compared it with 9 so we simply decrement j by one position because there can be more elements which can be greater than 2 so j becomes 1 and as j is greater than 0 this condition comes out to be true and the value stored at jth index which is 5 is also greater than 2 therefore the condition in while loop comes out to be true and we simply shift 5 by 1 position by assigning the value at jth index to value at j plus 1th index so we are simply shifting 5 by 1 position because value of j is 1 so this value we are assigning it to j plus 1 which is the 2nd index and then we will decrement j by 1 because there can be more elements which can be greater than 2 so j becomes 0 now here as j is greater than or equal to 0 this condition comes out to be true but the value stored at jth index which is 1 is not greater than 2 therefore we know that this value 2 will be stored somewhere after 1 and as we have already shifted 5 to its correct position this position is actually a space where we can store 2 so here this condition comes out to be false and at the last step as j is pointing to 0 we know that we need to store 2 after 1 so we simply store this temp value to j plus 1th index which is the 1st index so 2 comes here which is actually 2's correct position now after this 4 loop ends 1 2 5 9 will become part of the sorted array we will simply increment i by 1 so i becomes 4 and now we simply want to put 10 to its correct position in sorted array so we simply store 10 into this temporary variable moving ahead so now as we want to compare the value stored at temporary variable with the elements in sorted array we need to access the sorted array so we simply do i minus 1 and we store it into j so j becomes 3 which is the last element of the sorted array so as j is greater than or equal to 0 this condition comes out to be true but the value stored at jth index which is 9 is not greater than 10 so therefore this condition comes out to be false and we simply store this value 10 in this array at jth index because 9 is at its correct position and as it is less than 10 therefore 10 should be stored just after that so we simply store 10 to jth index so friends here you can see that not 10 will also be part of the sorted array and as there are no more elements left to be compared because when we increment i by 1 i becomes 5 and as 5 is not less than 5 therefore the condition in for loop comes out to be false and this for loop exits so friends here you can see that we have sorted this array into ascending order storing in the form as 125910 so friends in this lecture we discussed about the certain sort algorithm by demonstrating the algorithm step by step where we actually divided the array into two parts the sorted part and the unsorted part and with each iteration we picked the first element of the sorted part and we compare this element with each and every element in the sorted part to place the element into its correct position and how we place the element in its correct position is is by shifting all the larger elements which was greater than this first element of the unsorted array so friends this is the demonstration of the algorithm step by step now lets go to eclipse and see the implementation of this algorithm and its working i hope you like this video thanks have a nice day hello everyone so friends in our previous lecture we saw the demonstration of the insertion sort algorithm step by step so in this lecture we will code the algorithm and we will test its working so here i have created one classes insertion sort this classes method has print array which simply prints the contents of this array on the console which we already discussed in our previous lecture so here lets say we want to sort this array having 5 elements that is 5, 1, 2, 9 and 10 so when we will print these elements on the console lets say if i run the code so here we can see it printed 5, 1, 2, 9 and 10 so here the array you can see is not in sorted form so lets write the code to sort this array using the insertion sort so here i will be creating one method as public void lets say i give the name of the method as sort so this method will take the array which we want to sort in the first step what we do is we simply compute the number of elements inside the array by storing the length of the array by storing the length of the array by storing the length of the array to the integer variable n and then as we discussed in our previous lecture that we start our algorithm with a for loop where value of i will be starting from 1 and not from 0 because the first element inside this array when we pick to sort we know that its already sorted so we simply start from the second element so i starts from 1 and it goes till i is less than n so friends we also discussed that when we perform insertion sort we usually divide the array into two parts one is the sorted part and the other is unsorted part so here the value which is tracked by i is usually the unsorted part and the value which j tracks which we will see later is usually the sorted part so here by providing this for loop with each iteration we simply pick one element and we place that element into its correct position by applying the insertion sort so we simply store the first element of the unsorted part into the temporary variable and after we store this now we simply access the sorted part so here you can see that as i starting from 1 so the element which is stored at the 0th index is already sorted and we can access it via j so now j will basically keep the track of the sorted part we provide a while loop where we provide two conditions that j should be greater than or equal to 0 and as you want to compare the value stored into the temporary variable with each and every element stored in the sorted part we provide another condition as the element stored at the jth index is greater than temp or not so if this is true inside this while loop what we do is we simply shift all the larger elements which are greater than temp by one position and how do we do it we simply take the value stored at jth index and we transfer it to the j plus 1th index so here we are simply shifting larger elements to temp by one position and after shifting the elements we simply decrement the value of j by 1 because inside this while loop we need to compare the temporary variable with each and every value of the sorted part so friend while we are shifting all the larger elements by one position which are actually larger than value stored into this temporary variable is because we need to find the correct position of the value stored into this temporary variable so after we perform the shift by one position we decrement the value of j by 1 and then we again compare it with the value stored into the temporary variable and this loop goes on till greater than or equal to zero so this is basically a boundary check that we don't go to the out of the boundaries of the array and after this while loop we simply store the value stored into this temporary variable into its correct position which is at j plus 1th index because here we will exit the while loop with these two conditions and as we have already decremented j by 1 we note at the correct position for the value stored into this temporary variable would be at j plus 1th index so friend after this for loop completes for one iteration our sorted part increases by one value and with each iteration the sorted part increases and the unsorted part decreases and finally when this for loop exits all the elements of the unsorted part now becomes part of the sorted part so friend this is the insertion sort algorithm we discussed this algorithm in greater detail in our previous lecture and in this lecture we have simply coded the algorithm so now we will test its working so here we will call the sort method we pass in the array and after the sort happens we will simply print the array again so this print array will be called before sort and this print array will be called after sort so if I run the main method now so here you can see the array is already sorted initially it printed 5 1 2 9 10 which was the unsorted array and then it printed 1 2 5 9 10 which is the sorting of the array in ascending order so friend in this lecture we saw the code for the insertion sort and we tested its working in main method I hope you like this video thanks have a nice day hello everyone so in this video we will discuss about the selection sort algorithm we will first understand what is selection sort and we will see a small demonstration of selection sort algorithm so here as we are performing selection sort we are basically sorting the elements of an array into ascending order so let's say we are given with this array with 5 elements as 3 1 5 2 6 we know these elements are unsorted and we want to sort them in ascending order using selection sort algorithm so in this algorithm what we do is we first divide this array into 2 parts one is the sorted part and other is the unsorted part so here you can see at the start all the elements are unsorted so our sorted part and unsorted part looks like this that all the elements currently are unsorted and there are no elements in the sorted part now what we do inside this algorithm is let's say we are given with this boundary what we do is we start with this boundary and we find which is the minimum element among these all the elements in the unsorted part so once you find out which is the minimum element among these elements we simply swap it with the left most element of this boundary and as soon as we swap them we know that the minimum element which we found is at its correct position so for example here you can see when we pick the minimum element and swap it with the left most element of the unsorted part which is this boundary after swap the element now becomes part of the sorted array so for example among these 5 elements if we find out which is the minimum element we can find that one is the minimum element so what we do is we see which is the left most element which is 3 here and we simply swap these 2 values so it would look something like this that these elements are swapped and we also know that as one was the minimum element among these all the elements one is at its correct position if we actually sort this array completely it simply signifies that now one is the part of the sorted array and these 4 elements are part of the unsorted array so this finding of minimum element in the unsorted part and swapping it with the left most element of the unsorted part is repeated till all the elements are part of the sorted array and there are no elements left in the unsorted part so the idea behind this algorithm is very simple we divide the array into 2 parts sorted part and unsorted part from the unsorted part we pick the minimum element and we swap it with the left most element of the unsorted part so the element which is next to this boundary we simply swap the minimum element with this and after we perform this swap we know that the minimum element which we figured from this array is at its correct position so at the each pass 1 1 element from the unsorted part becomes the element of the sorted part and at the last we only get the sorted part so let's see the demonstration of this algorithm with a small example so let's suppose we are given with this array having 6 elements index from 0 to 5 and they are unsorted so let's say if we want to sort them in ascending order here length of this array is 6 so the first step we do is we divide this array into 2 parts sorted and unsorted part so initially all the elements are unsorted so therefore the sorted part has no elements and the unsorted part has all the elements now let's see what happens when we perform the first pass so here what we do is we simply start from the unsorted part and we find that there is 1 element 3 so let's say we are assuming that 3 is the minimum element of this complete array now what we do is we go to its next element and we compare 3 with 1 and we check that whether 1 is less than 3 or not so here 1 is less than 3 so which means that our assumption is wrong and 1 will become our new minimum so 1 becomes our new minimum and simply we go on like this we check whether 5 is less than minimum so 5 is not less than minimum we move ahead we check whether 2 is less than minimum so 2 is not less than 1 so we move ahead and 4 is also not less than 1 6 is also not less than 1 so here you can see after we completed the first pass we found that 1 is the minimum element among all the elements so now what we do is we simply swap this 1 with the leftmost element of the unsorted part so the element next to this boundary we simply swap it with that so here we will simply swap 3 and 1 so 1 comes here and 3 comes here and after first pass 1 is at its correct position so therefore now our sorted part has 1 element and unsorted part has the rest of the elements now we will simply do the second pass and we perform the same steps at first we consider 3 is the minimum element we compare it with each and every element next to it so 5 is not less than 3 we move ahead so here 2 is less than 3 so 2 will become our new minimum we move ahead 6 is not less than 2 and 4 is also not less than 2 so after second pass we found that 2 is the minimum element among the unsorted part now after we found out that 2 is the minimum element what we do is we simply swap it with the leftmost element of the unsorted part so we will simply swap it with 3 so 2 comes here and 3 goes here and we also know that 2 is at its correct position now so therefore now our sorted part has 2 elements and unsorted part has rest of the elements so we will go with the third pass now we assume 5 is the minimum element and we compare it with the rest of the elements we check whether 3 is less than 5 so yes 3 is less than 5 so therefore 3 will become our new minimum we compare whether 6 is less than 3 so it is not so we move ahead we check whether 4 is less than 3 so 4 is not less than 3 so after the third pass we came to know that 3 is the minimum element among these elements which are part of the unsorted array so after finding this minimum element we simply swap it with the leftmost element of the unsorted part so leftmost element is the 5 so we will simply swap 3 with 5 and now our sorted part has 3 elements and unsorted part has the rest of the elements we will continue with the fourth pass we will assume 5 is the minimum element among the elements in the unsorted part we compare it with the rest of the elements 6 is not less than 5 so we move ahead and we move ahead 6 is not less than 5 so we move ahead 4 is less than 5 so 4 will become our new minimum so after this pass among these 3 elements in the unsorted part we came to know that 4 is the minimum element and we will simply swap it with the leftmost element of the unsorted part so we will simply swap 5 and 4 now our sorted part has 4 elements and unsorted part has the rest of the elements so our fifth pass will start we assume 6 is the minimum element and we compare it with the rest of the elements so there is only one element which is 5 so we check whether 5 is less than 6 so we compare it with the rest of the elements so there is only one element which is 5 so 5 is less than 6 so 5 will become our new minimum and after the fifth pass we found that among these two elements 5 was the minimum so we will simply swap 5 with the leftmost element of the unsorted part so 5 will come at this place and 6 will go at this place after the swap and once we perform the swap the minimum element which we swapped becomes part of the sorted array so from here you can see that after the fifth pass 5 came to its correct position and we are left only with one element so by default this element at its correct position so we don't have to perform these steps on the last element because it is already at its correct position so the only thing to consider here is if the length of array is 6 then there are at least 5 passes which is n1 which is the length1 so if there are 6 elements we have to perform 5 passes to get the array in sorted form so this was the basic idea behind the selection sort algorithm we usually do 3 steps first we divide the array into 2 parts sorted and unsorted at the start all the elements are in unsorted part and then we apply the selection sort in different passes so with each pass what we do is we simply find the minimum element of the unsorted part and simply swap it with the leftmost element of the unsorted part and after this swap the minimum element which we just found becomes part of the sorted array and this process is repeated till all the elements are part of the sorted array so friend this was the basic demonstration of the selection sort algorithm in our next video we will see the complete animation of the selection sort algorithm step by step I hope you have liked this video and in case you have liked this video please like, comment, share and subscribe my channel thanks have a nice day hello everyone so in our previous video we saw a basic introduction to selection sort and we also saw a demonstration that how selection sort is applied on an array having unsorted elements and once the algorithm is applied all the elements become sorted so here let's suppose we are given with this array where the elements are unsorted so in selection sort what we actually do is we divide the array into two parts one is the sorted part and other is the unsorted part so at the start all the elements are part of unsorted part and we have this boundary here so what we actually do we simply find out the minimum element in the unsorted part so here let's say the minimum element among all this element is one so what we do is we pick one and we simply swap it with the leftmost element of the unsorted part and once we swap them so it would look something like this and we know that one is at its correct position because we want to sort the elements in ascending order so after the swap is done the element now becomes part of the sorted array so the boundary goes here that we have now one element in the sorted part and rest of the elements in the unsorted part so this process is repeated for each and every element on the unsorted part till this boundary reaches to the end of the array so when all the elements are sorted the unsorted part has zero elements and all the elements are in sorted part so in our previous video we saw step by step demonstration of the algorithm now we will see the step by step demonstration of the actual code so here you can see this is the algorithm to perform the selection sort on an array and this algorithm will sort the elements into ascending order so let's say when we call sort method and pass in an array so let's suppose this is our array having 5 elements 5, 1, 10, 2 and 9 now here you can see there index from 0 to 4 moving ahead in the first step what we do is we simply store the length of the array in an integer variable n so value of n is 5 because we have 5 elements moving ahead also friends in our previous video we discussed that we divide this array into 2 parts the unsorted part and the sorted part so when we start the algorithm the sorted part has zero elements and unsorted part has all the elements so here basically what we do we find the minimum element in the unsorted part and once we find that out we simply swap it with the leftmost element of the unsorted part and once the element is swapped now that element becomes part of the sorted array and this boundary will get shift by one position so here you can see this outer for loop goes from i equal to 0 to a value i less than n minus 1 so here basically i will keep the track of this boundary and here you can see it will start from 0 and it will go to less than n minus 1 which is 4 so it will go till 3 here so why we traverse i to less than n minus 1 because when we are on the last pass the last element goes to its correct position and we don't perform this algorithm on the last element because we know that that element is at its correct position so we will see the demonstration of the algorithm and it will be more clear to you so currently we will start with i equal to 0 and 0 is less than 4 so the condition in for loop will be true and the for loop will execute so here whatever the value i is holding it will be simply the indexes of this array so it can be symbolically represented like this so in selection sort our first task is to find the minimum element among the unsorted part so here you can see we first assume that let's say whatever the value i is holding we treat it as the minimum value so here we create an integer variable and we store the value of i so min will also become 0 which signifies that we are assuming that value 5 is the minimum element among these all the elements and now we provide the inner for loop now this inner for loop is for actually finding the minimum value so here this is our assumption and in order to find the minimum value among all these elements we need to compare this minimum value with all the elements of this array once we find any value which is less than the minimum value our min will point to that value so let's see how so here this for loop will start from i plus 1 because here you can see we are assuming that 5 is our minimum value and i is pointing to it so we start this inner for loop will j equal to i plus 1 so here you can see value of j will become 1 which is 0 plus 1 so this signifies that we are starting from this value because we need to compare now 5 with each and every value of this array so j starts from i plus 1 and it will go till j is less than n so less than n will become 4 because we want to compare it with each and every element so last index of j would be 4 so let's move ahead and see how it works so in the first step we are simply comparing that whatever we assume to be the minimum value is the value at jth index less than the index value which min is holding so here you can see the value at array of min would be 5 and array of j would be 1 so now we will simply compare these two values and here we are checking that whether 1 is less than 5 or not so here you can see this condition comes out to be true so as we have found a minimum value now what we will do? we will simply update the minimum to this value so whatever the value j is holding which is 1 now min will point to this value holding a value as 1 so min becomes 1 and symbolically it will point to an index 1 moving ahead will increment j by 1 because now we need to compare this 1 with rest of the elements so j becomes 2 now we will compare these two values and we check whether 10 is less than 1 or not so 10 is not less than 1 so this condition comes out to be false we will increment j by 1 so j becomes 3 now we will compare these two elements that value of array at min index is 1 and value of array at jth index is 2 so we will now compare these two values so here you can see 2 is not less than 1 so this condition comes out to be false we will increment j by 1 so j becomes 4 and now we will simply compare 1 with 9 and we will simply check here whether 9 is less than 1 or not so 9 is not less than 1 so therefore this condition comes out to be false and now we will increment j by 1 so j will become 5 which means that j is now out of these boundaries and this condition here you can see j should be less than n so j value is 5 and 5 is not less than 5 so therefore this for loop will terminate and we simply reach here so here you can see that we have found out the minimum value among this element which is 1 and in selection sort what we do is we simply swap it with the leftmost element of the unsorted part which is being hold by the value i so here we are performing this swap using this temporary variable so in the first step we are storing the value 1 into the temporary variable so temp becomes 1 and then we are simply swapping the value at i at index which is 5 into this index so 5 will come here and at the last step we are simply assigning value stored at temp into the i at index which is this so we have simply swapped these elements and after we perform this swap we know that one is at its correct position because we need to sort all the elements in ascending order so now this one will go into the sorted part and rest of the elements will be still in the unsorted part so the call will reach here in the outer for loop will increment i by 1 so i will become 1 so now i will point to this index which is 1 in the first step we are assuming that let's say this is our minimum value among all the elements so we are simply assigning value of i to min moving ahead now as we need to find the minimum element from the unsorted part we need to provide this inner for loop which will start from j equals to i plus 1 so i is pointing to index 1 so j will start with index 2 and the value of j which is 2 is less than 5 so this condition comes out to be true so now we are again we are simply performing this check that whether 10 is less than 5 or not by taking in the value at jth index and the value at min index so min is pointing to index 1 and j is pointing to index 2 so we are taking these two values and we are comparing that whether 10 is less than 5 or not so this condition comes out to be false because 10 is not less than 5 we will increment j by 1 so j becomes 3 so still you can see 3 is less than 5 so this condition comes out to be true now we will compare these two values we check whether 2 is less than 5 or not so yes 2 is less than 5 so this condition comes out to be true and as this condition comes out to be true and we need to find the minimum element among these elements so now our min will point to this index because we have found a minimum value moving ahead will increment j by 1 so j becomes 4 and 4 is less than 5 so this condition comes out to be true now here we check that whether 9 is less than 2 or not so 9 is not less than 2 so this condition comes out to be false j becomes 5 so now this condition 5 is not less than 5 so this 4 loop will terminate and we have found our minimum element which is 2 so we will simply swap it with the leftmost element of the unsorted part which is being tracked by the value i so we are simply swapping 5 with 2 using these 3 steps so we will quickly go over these 3 steps 10 will have value 2 with this statement we will transfer 5 to this position by assigning the array value at i.e. index to the array value at min index so this becomes 5 and at last we will store the value of temp into the i.e. index so this becomes 2 so friends here you can see after we perform this swap 2 will also become part of the sorted part with each pass the sorted array is increasing and the unsorted part is decreasing so now we will increment i by 1 so i becomes 2 and 2 is less than 4 so this condition comes out to be true so now we need to find the minimum element among this unsorted part so we are assuming that whatever the value i is holding currently it's the minimum value so we are simply assigning value of i to min so value of min will become 2 and now we need to compare 10 with rest of the elements so for that we need to provide this inner for loop where j will start from i plus 1 because we need to compare this with other elements so i is already pointing to this element so we will start j by i plus 1 so j becomes 3 now we will simply compare these two values and here we are finding that whether 5 is less than 10 or not so this condition comes out to be true so we have found our minimum element after this comparison so we will simply update min to this value 3 and we continue with our for loop we will increment j by 1 j becomes 4 and 4 is less than 5 so this condition comes out to be true now we will simply check whether 9 is less than 5 or not so 9 is not less than 5 so this condition comes out to be false we will increment j by 1 so j becomes 5 which is out of bounds of this array and here 5 is not less than 5 so this condition comes out to be false and our for loop will terminate so here you can see we have found our minimum element which is 5 now we will simply swap it with the leftmost element of the unsorted part which is being tracked by value i so we are simply performing this swap where 5 will come to this position and 10 will come to this position so so here after we perform swap now 5 is at its correct position and now this will become part of the sorted array we will increment i by 1 so i becomes 3 and 3 is also less than 4 so this condition comes out to be true now at the first step we assume that 10 is the minimum value so we simply assign the value of i to min which is 3 so it will point to the third index and now we need to find the minimum element from the unsorted part so only 2 elements are left so we will start our inner for loop with j equal to i plus 1 so j will start with 4 4 is less than 5 so this condition comes out to be true and here we will simply compare that value at jth index which is 9 is less than value at min index which is 10 or not so 9 is less than 10 so this condition comes out to be true and we have found our minimum element among these 2 elements so min will be updated to 4 by assigning the value of j which is 4 to min we will increment j by 1 so j becomes 5 which means that 5 is not less than 5 so this condition comes out to be false and then as we have found our minimum element we will simply perform a swap with the leftmost element of the unsorted part which is being tracked by i so 9 will come to this position and 10 will come to this position using this temporary variable so first 10 will come here and then whatever the value we stored here which is 9 will come here so after this swap we know that 9 is at its correct position so this will be part of the sorted array so friends here you can see that at the end there were only 2 elements and as we sorted the second last element the unsorted part was left with 1 element so this algorithm should not be applied to this element because this is already sorted because this is at its correct position only now so therefore we provided this condition that i should go to less than n1 so here if we increment now i by 1 i becomes 4 so i will come to this point but here you can see 4 is not less than 4 which makes sense because now i is pointing to the last element and if it is the only element left then we are sure that the last element is actually sorted so friends here we saw the demonstration of the selection sort algorithm step by step and once this algorithm gets finished we found all the elements sorted into the ascending order so now lets go to intelligent and code this algorithm and test its working so friends i hope you have liked this video and in case you have liked this video then i would request you to please like comment share and subscribe my channel thanks have a nice day hello everyone so in our previous video we discussed about the selection sort algorithm and we saw the demonstration of the algorithm step by step using an animation now in this video we will code the algorithm into this sort method where we simply pass in the array which we want to sort and we will simply apply the selection sort and test its working in the main method so currently we are given with this array 5 1 2 9 10 and if i run the main method so here we will see that we are simply printing the array now using this print array method so 5 1 2 9 10 got printed now lets code the algorithm in this sort method so in the first step what we do is we create an integer variable n which will hold the length of the array because we will use this value of n in the algorithm while we provide the for loops now at the first step we provide a for loop which starts from integer i equal to 0 to a value less than n minus 1 minus 1 i plus plus so in our previous video we discussed that we are actually dividing the array into two parts the sorted part and the unsorted part so basically this i will keep the track of the sorted and the unsorted part so at the start all the elements are part of the unsorted part so therefore the value of i will be 0 and the value of i will go to less than n minus 1 so here we can see we have these 5 elements so the value of n will be 5 and if we do minus 1 it will be 4 so i will go from 0 to 3 now why this i will go from 0 to 3 is because if we see the indexes it starts from 0 and 3 will come to this point so when we compare these last two elements we sort them then we know that both the elements will be at its correct position so this algorithm should not go further ahead because if i will come to this point then we know that this is already sorted so we are keeping track of the i till less than n minus 1 and which we already discussed in our previous video in great detail so you can watch that video now inside this for loop as we want to find the minimum element in the unsorted part so what we do is we assume that that min is pointing to index 0 at the start and we are assuming that the first element is the minimum element and after that we need to provide a for loop now this for loop will start with j equals to i plus 1 and this will go till less than n j plus plus so here you can see that we are assuming the value hold by an array at i at index is the minimum value so this is our assumption and in order to find the minimum element among the unsorted part we need to provide this for loop where we will compare all the elements with the value hold by the min index and as the min is pointing to the i at index we are starting this inner for loop with j is i plus 1 and j will go till less than n because we need to compare this minimum value with each and every element of the array so j will go till the last index and inside this for loop will provide a condition as if value at jth index is less than value at min index then we know that we have found one more element which is less than the value at min index so what we do is we simply update the min value to point to j because we have found a new minimum value so now min will point to jth index and this for loop will go on till all the elements are compared with the min value and after this for loop will terminate we know that we have found our minimum value whose index is being hold by the min integer so after the for loop we will simply swipe this minimum value with the leftmost element of the unsorted part which is being hold by the value i because we already discussed that we divide the array into two parts the sorted part and the unsorted part and i will keep the track of that boundary so at the start i will point to 0 which would be the leftmost element of the unsorted part so we will simply swipe this minimum value with the value stored at the ith index and we will use this temporary variable so we first store the value at minimum index which would be our minimum value into the temp and then we will assign the value at ith index to value at min index and at the last whatever the value stored in temp will assign to ith index so here you can see after we perform this swipe one element reaches to the sorted part and then we increment the i by 1 so i becomes 1 and the rest of the algorithm is repeatedly performed on an array till we get all the elements into the sorted part so in order to understand the selection sort using an animation you can watch my previous video so this is the code for the selection sort now lets test its working so after printing the array we will call the sort method we pass in the array and once this method gets executed we will simply print the array again if i run the main method so here you can see initially array was 5 1 2 9 10 and after we performed the selection sort it became 1 2 5 9 10 which is in ascending order so friend this was all about the selection sort algorithm i hope you have liked this video and in case you have liked this video then please like, share, comment and subscribe my channel thanks have a nice day and how we can merge two sorted arrays in java so before we start in case if you are new to my channel then please subscribe to my channel so that you don't miss any update so here lets suppose we are given with this two arrays array 1 and array 2 and here if you see both these arrays are sorted in ascending order so array 1 has 4 elements 3 5 10 and they are sorted in ascending order and same with array 2 having elements as 4 6 11 and 15 now our task is to merge these two array in such a way that the resultant array is also sorted so the idea behind this algorithm is we create a resultant array whose length is the length of array 1 plus the length of array 2 so in this case array 1 has length 4 and array 2 has length 4 so our resultant array will have length 8 because we need to merge all the elements of array 1 and array 2 into this result array so in this algorithm, as this both the arrays are sorted in ascending order what we do is, we simply compare the elements of array 1 with array 2 and whichever the element is smaller, we simply put it into the result array so how do we perform this algorithm is, we take 3 pointers 1 pointer will start from array 1 2nd pointer will start from array 2 and there will be 3rd pointer which will start from our result array so the 3 pointers we create is i which will point to the zeroth index of array 1 j which will point to the zeroth index of array 2 and k which will point to the zeroth index of result array so here as both the arrays are sorted, we simply compare the elements stored at the ith index of array 1 with the elements stored at the jth index of array 2 and whichever of them is smaller we simply put it into the kth index of result array so here in first step we compare 2 with 4 because i and j are pointing to an index having value as 2 and 4 so here we see 2 is less than 4 so therefore we simply update this value to kth index of the result array so it would look something like this, 2 will come to this position now here as we have filled this value here, so we simply increment i by 1 and as we have filled this position, we also increment k by 1 so now we will again compare the value at ith index with the value at jth index of both the arrays so we will compare now 3 with 4 so here you can see 3 is less than 4 so we simply update the value 3 into this position and as we have used the value 3, we simply increment i by 1 and we have filled this position so we increment k also by 1 so now we will again perform this comparison we compare 5 with 4 so now here you can see 4 is less than 5 so therefore we put this value 4 into this kth index because our task is to merge 2 sorted arrays and the result array should also be sorted so therefore we perform this check and whichever is the minimum value we simply put it into the result array so now we have used the value stored at jth index so we will simply increment j by 1 and we have filled this value so we will increment k also by 1 so here you can see wherever we are finding any lowest value in array 1 or in array 2 we are simply incrementing that pointer and why we are not incrementing the other pointer that value still needs to be filled inside this array so now as we have incremented j by 1 we will compare 5 and 6 because those values are preferred by i and jth index and here we know that 5 is less than 6 so we will simply update 5 value at the kth index and as we have used this value we will increment i by 1 we have occupied with this position so we will increment k also by 1 now we will compare 10 with 6 so here you can see 6 is smaller than 10 so 6 value will be updated here and as we have used this value 6 we will increment j by 1 and we have filled this position so we will also increment k by 1 now we will compare 10 with 11 so here you can see 10 is less than 11 so value 10 will be updated here we will increment i by 1 so here you can see now as we are incrementing i by 1 i will be crossing the boundaries of array 1 so now there is no more element left in the array 1 to be compared with the elements in the array 2 it means all the elements of array 1 are filled into the result array and we are only left with the elements of array 2 which are already sorted so now our task is to simply put these values into its respective positions here because we don't have to compare these values with any other value because these are already sorted in ascending order so as we incremented i by 1 after filling the value 10 here we will increment k also by 1 and now we will simply copy the remaining elements of array 2 into this result array using the jth pointer so the first step we will simply copy 11 here then we will increment j by 1 and we will also increment k by 1 and we will simply copy 15 into this kth index we will increment j by 1 so j has reached out of these boundaries now for array 2 and we will also increment k by 1 so k has also reached to its end so which signifies both these array elements are now part of this result array and as both the arrays were sorted in ascending order you can see the result array is also sorted in ascending order so here this is the idea of how we can merge two sorted arrays by simply using 3 pointers i, j and k i will traverse array 1 j will traverse array 2 and k will traverse our result array we will simply compare the values stored at ith and jth index of their respective arrays and whichever the value is small will simply update it into the result array at the kth index and after we update these values whichever value we took either from array 1 or from array 2 will simply increment that respective pointers and as we are filling up their positions in the result array we will also increment the kth pointer so friend this was all about the demonstration of how we can merge two sorted arrays and create a resultant array which is also sorted in our next video we will look into the animation of the actual algorithm which is involved in merging these two arrays so friend in case you have found this video informative then please like, comment, share and subscribe my channel thanks have a nice day hello everyone so in our last video we discussed about that how we can merge two sorted arrays in java we discussed about the idea that how we can merge two sorted arrays so in this video we will see the step by step demonstration of the algorithm but before we start in case if you are new to my channel then please subscribe to my channel so that you never miss an update so here you can see that this is the algorithm to merge two sorted arrays array 1 and array 2 into a result array and simply return the result array from this method merge so let's see the demonstration of this algorithm step by step so initially when we call this merge method we pass in the two sorted arrays array 1 and array 2 and we also pass the length of these two arrays with a variable as n and m so n will correspond to the length of array 1 and value m will correspond to the length of array 2 so when we call merge method here you can see that for this example we are taking two arrays which are sorted in ascending order having length as 3 so let's say we are providing this two sorted arrays having length as 3 and here you can see the elements are sorted in ascending order in both the arrays and now our task is to merge these two arrays into a result array and return that result array from this method so the length of this array are denoted by n and m having value as 3 so in the first step as we want to merge these two arrays all the elements should be part of the result array so first we create that array by name result and the length of that array would be n plus m because we need to merge these two sorted arrays and our result array should contain all the elements of both these arrays so after this length gets executed we are provided with this array whose length is 6 moving ahead and as we discussed in our last video the idea behind this algorithm is we create three pointers i, j and k we will initialize it with zero value now what these pointers are the pointer i will traverse array 1 starting from 0th index so we have provided value 0 pointer j will traverse array 2 starting from 0th index and pointer k will traverse the result array starting from 0th index so here you can see the purpose of these three pointers are different so in this algorithm at any instant we are comparing the value stored at ith index with the value stored at jth index and whichever the value is smaller we are simply updating into the result array ith kth index so these two pointers are used for comparison and this pointer is used to fill this array and the filling of this array is sequential where we place in elements 1 by 1 and will increment k 1 by 1 and similar to this comparison also sequential we are finding the minimum value at each iteration and we are simply updating into the result array so here at the start of this algorithm we are providing this while loop now why we have provided this while loop is because we need to compare the value stored at ith index and value stored at jth index so it simply means i will traverse the array 1 and j will traverse array 2 so in order to perform this traversal in comparison we are providing this while loop and inside this while loop we have provided two conditions one is i should be less than the length of array 1 and j should be less than m which is length of array 2 now why we have provided this condition is because as we are comparing and incrementing values of i and j which you can see here so there can be a chance that j goes out of bounds for array 2 and i goes out of bounds for array 1 so when any of this pointer will exhaust its respective arrays will simply exit this while loop because there are no more elements left to be compared between these two arrays because one array is already exhausted so therefore we have provided this true condition so at the start i is pointing to 0 j is also pointing to 0 i is less than 3 and j is also less than 3 so therefore this while loop condition comes out to be true now in the while loop we are comparing that whether value at ith index for array 1 is less than value stored at jth index for array 2 or not so here you can see so we are comparing 2 with 3 so here you can see 2 is less than 3 so this condition comes out to be true so therefore if block will be executed now as we have found a minimum value among these two values and we want to merge these two sorted arrays into this result array in sorted form then what we do is we simply update the value at ith index for array 1 into this result array at kth index so 2 will come here moving ahead now as we have used this value so we will increment i by 1 so currently i is 0 i will become 1 and after this if else we will increment k by 1 because we have filled this position here so now we need to go to next position to get the next element so k becomes 1 we will check both these two conditions so 1 is less than 3 and value of j is 0 so 0 is also less than 3 so this both the condition comes out to be true now we will again compare value at ith index for array 1 with value at jth index for array 2 so which is we are comparing 5 with 3 now here you can see 5 is not less than 3 so therefore this condition comes out to be false and else part will be executed so in the else part as 3 is less than 5 we will simply update value of 3 to the result array so here we are assigning value stored at jth index for array 2 into result array at kth index so 3 will come here now as we have used the value 3 we will increment j by 1 so j becomes 1 and we are not touching i because we need to still get this value 5 and store it somewhere into the result array so i will simply point to the same index we will increment k by 1 because we have filled ith position so for the new value we will simply go to its next index so k becomes 2 1 is less than 3 and 1 is less than 3 so this both the condition comes out to be true we will compare value at ith index for array 1 with the value at jth index for array 2 so here we are comparing 5 with 4 now and here you can see 5 is not less than 4 so this condition comes out to be false and in the else part as we have found the minimum value as 4 we simply update 4 into the result array by this assignment and as we have used this value we will increment j by 1 and we have filled this position so we will increment k by 1 k becomes 3 here still i is less than n and j is also less than m 1 is less than 3 and 2 is also less than 3 so this both condition comes out to be true we will now compare 5 with 9 because those are the values pointed by i and jth index and here you can see 5 is less than 9 so therefore this if block condition comes out to be true so now it's time to update value 5 into the result array and as we have updated value 5 we will increment i by 1 so i becomes 2 and as we have filled this position we will increment k by 1 k becomes 4 so still this while loop condition comes out to be true because i is less than n and j is also less than m we compare these two values 7 and 9 we found that 7 is less than 9 so therefore this condition comes out to be true so we simply update value stored at ith index in array 1 into the value 8th caret index for result array so 7 comes here and then we will simply increment i by 1 so i becomes 3 so here you can see now i has crossed the boundary for array 1 we have used this position so we will increment k by 1 k becomes 5 so for now here you can see that array 1 is already exhausted so this condition i is less than n where 3 is not less than 3 so therefore this overall condition will come out as false and this while loop will terminate so here you can see whenever any of the array gets exhausted we will simply break from this while loop and then our execution point will reach here where we are encountering 2 while loops so friends here you can see that there can be a chance that array 1 gets exhausted first or array 2 gets exhausted first so when this while loop will terminate we are not sure that which array gets exhausted first so therefore we have provided these 2 while loops so here let's say for example array 2 gets exhausted first so if array 2 gets exhausted first there can be left over elements in array 1 which need to go into the result array so we are providing this while loop where we are simply traversing i to complete the array 1 get those elements from array 1 and simply fill it in the result array because as both the arrays are sorted we are simply copying the left over elements from the respective array into the result array so this while loop is when array 2 will get exhausted and this while loop is when array 1 will get exhausted so currently for this example you can see array 1 got exhausted so this while loop will not get executed because the condition here is i should be less than n so 3 is not less than 3 so therefore this while loop won't get chance to execute because because array 1 is already traversed completely and we know that there are left over elements in array 2 because j is less than m 2 is less than 3 so whatever elements are left over in array 2 will simply get copied into the result array because those elements are already sorted so we will simply store value 9 into the result array by this assignment and after doing this assignment here for this small example you can see that there was only one element so we simply updated one element here but let's say there are many elements and as this arrays are sorted so we can simply copy those left over elements directly into the result array because there are no elements left for array 2 to get compared with array 1 because array 1 is already exhausted and same thing goes when array 2 gets exhausted and there are left over elements in array 1 so these two for loops are important because they simply copy the left over elements from their respective arrays to the result array and there can be multiple elements which are left over so therefore we are providing this while loop so at the last step of this while loop we are incrementing j by 1 and k by 1 because we have migrated value 9 into result array so j will now get incremented by 1 j becomes 3 which means now j has crossed the boundary of array 2 and we will also increment k by 1 so k becomes 6 so which means k has traversed the result array completely by filling out each and every position so now we will again compare whether j is less than m or not so here you can see 3 is not less than 3 so therefore this condition comes out to be false which signifies that we have completely migrated all the elements of array 2 to result array so friends finally here you can see that we have merged these two sorted arrays into a result array which is also sorted so finally we will return result from this algorithm so friends in this video we discussed the algorithm that how we can merge two sorted arrays so in case if you find this information useful then please like, comment, share and subscribe my channel thanks have a nice day hello everyone so in our previous video we discussed step by step demonstration of how we can merge two sorted arrays in this video we will actually code the algorithm and we will test its working but before we start in case if you are new to my channel please subscribe to my channel so that you never miss an update so here I have created one class is merged sorted arrays which is having a method as print array which takes in an array and print its elements on the console so we have discussed this print array method in our previous videos so I will simply use this print array method to demonstrate how we can merge two sorted arrays in java so here you can see I will be creating one method as public whose return type would be an integer array because we want to merge two arrays which are sorted and we want to return back the merge sorted array having elements of array 1 and array 2 so the method name I will be giving as merge this method will take four things one would be the array 1 other would be array 2 the length of array 1 and length of array 2 which is being denoted by n and m so here you can see that array 1 and array 2 are already sorted arrays and we want to merge them together so at the first step what we do is as we want to merge them we will simply merge them in the result array so we will create a result array now the size of this array would be n plus m because we want to accommodate the elements of array 1 and elements of array 2 into the result array so the idea behind this algorithm is we create three pointers i which will start from 0 so this pointer will traverse array 1 from start to finish we will create one more pointer which will start from 0 and it will traverse array 2 and we will create one more pointer k which will start from 0 and which will traverse result array so here why we have created this three pointer is because pointer i will traverse array 1 elements 1 by 1 and j will traverse elements of array 2 1 by 1 and we will simply compare those two values stored at i and jth index and based on our comparison whichever value will be small will simply store it into the result array at kth index and after we store this value whichever value of that particular array we get as a small will simply increment pointer of that array and after filling the result array at kth index will also increment k by 1 so here in order to perform that we provide a while loop and inside that while loop we provide two conditions one is i should be less than n and j should be less than m so these are nothing but boundary conditions where we are simply checking that whether i is in the boundaries of array 1 and j is in boundaries of array 2 and we have provided this n condition because in this while loop we are comparing the value stored at ith index with the value stored at jth index for their respective arrays and in case any of this array gets exhausted which means that either i will cross over array 1 or j will cross over array 2 we simply break from this while loop so inside this while loop we are providing a condition as if value at ith index of array 1 is less than value at jth index for array 2 so here it signifies if array 1 element at ith index is less than array 2 element at jth index so if this is the condition then after this comparison this value is the smallest value and as we want to merge these two sorted arrays into a result array and that also should be in sorted form so therefore we simply update the smallest value at the kth index which means storing array 1 element into result and after we store array 1 element we have occupied the ith position into the result array so we will increment i so that we can go to its next index and similarly if this condition is false then in the else part we do the opposite of it we store the value at jth index for array 2 into result because here we know that if this condition is false then value stored at jth index for array 2 will be smaller than this value so we are storing that value into the result array and as we have used the value stored at jth index we will simply increment j by 1 so after storing the minimum value among these two values into the result array we have filled the kth position in the result array so we will also increment k by 1 so that k travels to an unfilled position so that when this while loop will be executed again we are left with the unfilled position so after this while loop gets terminated there can be two possibilities either array 1 got exhausted or array 2 got exhausted if array 2 got exhausted which means that all the elements of array 2 are now part of our result array and whatever left over elements are there in array 1 we simply copy it into the result array so for that we will use the while loop we provide the same condition as i should be less than n because we are simply copying the left over elements of array 1 now so we copy this and we will increment k also by 1 after filling the position so here this while loop signifies that array 2 got exhausted and similarly we don't know that which array got exhausted in this above while loop so we need to provide the same while loop for the array 2 as well we provide the condition as j should be less than m this will signify that array 1 got exhausted first we will increment j by 1 and we will keep rest as it is so friends here you see that why we have provided these 2 while loops is because we don't know whether array 1 got exhausted first or array 2 got exhausted first so if array 2 got exhausted first we are simply copying the left over elements of array 1 into result and if array 2 got exhausted first we are simply copying the left over elements of array 1 into result and if array 1 got exhausted first we are copying the left over elements of array 2 into the result using this while loop and why we are simply copying these elements from the respective arrays because those elements are already sorted and we don't have to compare it with any other elements whatever the comparison we need to do we have done it in this while loop so at the end we will simply return the result array so friends this is the code for merging 2 sorted arrays now let's test it working in the main method so here i will be creating 2 arrays array 1 let's say i provide the value as 0 comma 1 comma 8 comma 10 these 4 values and here you can see these are sorted in ascending order and similarly i create array 2 let's say i provide value as 2 4 11 15 and let's say 20 so these values are also sorted in ascending order now let's print both this array on the console if i run the code now so here you can see it is simply printing both the arrays on the console now we will call our merge method we pass in array 1 array 2 length of array 1 which is denoted by n and length of array 2 which is denoted by m so this method will return as the result array so we will store it into the result variable and finally we will print the result array if i run the code now so here you can see that it returned 0 1 2 4 8 10 11 15 20 it merged these 2 sorted arrays and returned as the result array which is also in sorted form so friends this was all about the code and working of the algorithm now why this algorithm is important because the similar approach is usually used when we actually perform the merge sort which we will be looking into our upcoming lectures so there we will simply use this idea and we will perform the sorting of array using merge sort so friends if you find this information useful then please like comment and share this video and incase if you are new to my channel then please subscribe to my channel so that you don't miss any new update thanks have a nice day hello everyone so in this video we will be looking into a sorting technique we call it merge sort so before we start incase if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so what is merge sort so here you can see that merge sort is a divide and conquer algorithm so divide and conquer algorithm is very widely used algorithm to solve the problem now as per the Wikipedia here you can see divide and conquer recursively breaks down a problem into two or more sub problems of the same or related type until this becomes simple enough to be solved directly so when we divide a complex problem into two or more smaller sub problems and we keep on doing it till those smaller problems are easily solved and after breaking this complex problem into smaller sub problems what we do is we solve those smaller sub problems we take their solutions and then combine them to give a solution to the original problem so basically we divide a large problem into various smaller sub problems and we keep on doing it till those sub problems are simple enough to solve and once we solve them we have their solutions so what we do is we take their solution and we combine them so that we get the solution to our original problem so at this step when we are combining the solution of smaller sub problems and getting the solution to our original problem is actually the conquer part of it so let's see how this divide and conquer algorithm fits into merge sort so when we are given an array and we want to sort them what we do is we first apply the divide part now in this step what we do is we take the middle point of the array and divide the array into two halves and once we divide the array into two halves now the algorithm is carried out recursively on these two halves and it goes on till there are no more halves of arrays to divide so we keep on dividing it till there is only one single element left which is not further divided so after this divide step ends what we do is we then conquer and how we conquer is in this step from the bottom we take those smaller half arrays we sort them and merge the divided arrays and get the sorted array so we will see this divide and conquer with an example to make it more clear so for timing we divide an array into two halves and we keep on dividing them into two halves till there is only single elements are left and those are not pretty much divided so when we pick those single elements those are already sorted so we simply merge them and get the sorted array and we keep on doing this till the complete array is sorted so lets see these two steps with an example so first we will see the divide part so now lets say we are given with this array and we want to sort it in ascending order so in the divide part what we do is here we can see that there are 7 elements 2, 10, 5, 3, 6, 4 and 11 now we simply evaluate the mid position so here is 3 so how we evaluate this mid position is we will see later but here we can see that as there are 7 elements from 0 to 3 we break it down into one array and from 4 to 6 we break it down into other array so here you can see now this was our original problem to solve we break it down into two smaller sub problems and after breaking it down into two smaller sub problems we do it recursively again into these smaller sub parts so here what we do is after breaking it down into two parts we take this part and we further break it down into two parts so this algorithm is pretty much recursive in nature and now as this algorithm is recursive we take this smaller half and we break it down into two halves so here you can see that after breaking this 0 and 1 we are left with single single element 2 and 10 so here algorithm decides that ok we can't break 2 and 10 further down so what we do is the divide part is done for this piece so then we conquer so in mer sort a single element is already sorted and in the conquer step this is the smallest solution we have that lets say if the array had only one element it would have been sorted so now in the conquer part we actually merge them so in one of our previous videos we have discussed that how we can merge two sorted arrays so this is the first sorted array and this is the second sorted array so in the conquer step we merge them and we merge them in such a way that we compare their respective elements one by one and we try to merge them so here we compare 2 with 10 and we simply merge them to get the sorted array so after merging those two sorted arrays we are left with a larger sorted array so here 2 and 10 are actually sorted now this conquer is done for this particular step the algorithm then tries to break this part because as this is a recursive algorithm it breaks it like this first it breaks in 4 then 2 then 1 1 and after merging the smaller subunits it takes the next unit and break it down into smaller pieces so it breaks 5 and 3 like this so 5 and 3 cannot be broken down further so now it conquers it so here it simply compares 5 and 3 and we get 3 and 5 because 3 is smaller so 3 comes here and 5 comes here so here you can see that this is the first sorted array and this is the second sorted array and now we simply merge these two parts because these are solved problems of our smaller sub problems so in the conquer step we actually merge them so after merging these two sorted arrays it looks something like this so 2 is compared with 3 it comes here then 10 is compared with 3 so 3 is smaller so 3 comes here then 5 is compared with 10 5 is smaller so 5 comes here and then 10 goes here and this step is done so now algorithm will pick this part and try to break it down using the divide step so it will break it down like this 6 and 4 and 11 because there are 3 elements and here it will now first pick this part so it will break 6 and 4 like this and then it will merge 6 and 4 so which will become 4 and 6 so the only thing to keep in mind is in the conquer step of merge sort what we are doing is we are merging two sorted arrays and the result is a large sorted array so here you can see that this was sorted array this was sorted array we merged it in such a way that we got a larger sorted array similarly with this we got larger sorted array and as this part was actually sorted and this part was also sorted so we merged these two sorted arrays as well so we got this sorted array and similarly we did here so after sorting 4 and 6 as 11 is the only element left so it goes like this it comes here and then we have 2 sorted arrays and we merge it so we get 4, 6, 11 and now here you can see the algorithm sees that we have one sorted array we have another sorted array now we can simply merge these two pieces together like this 2, 3, 4, 5, 6, 10, 11 so here you can see that the final array which got sorted is actually our original problem which we wanted to sort so friends here I will just go back so we will go through this one more time we saw that this was the problem given to us and we wanted to sort it using merge sort so here we evaluated the midpoint of the array and we break it down into 2 smaller sub problems recursively so recursively how it goes is it breaks it down like this and recursively it goes to here it break it down like this and then it again recursively go here then it break it down 2 and 10 and it sees that ok it can't be further broken down so it tries to merge it so why it tries to merge it because this is the sorted array having only single element and the single elements are already sorted so it treats it as 2 smaller sub arrays which are sorted and it tries to merge it in the conquer step so it merge it like this 2 and 10 so one thing is important you watched my previous video where we actually saw the algorithm how we can merge 2 sorted arrays and the resultant array is also sorted so we will get this sorted array so this recursion ends here it then goes to this side it takes 5 and 3, breaks it down like this it merges 5 and 3 which gives 3 and 5 so this part is done so once this part is done it sees that ok I have got one larger array here and here and both are sorted so it tries to merge them so we will get 2, 3, 5, 10 and after doing this part completely it then goes recursively to this part it breaks 6, 4, 11 into 2 parts 6 and 4 on one side and 11 on other side it recursively sees that ok I can break this down further it breaks it down 6 and 4 like this it merge them it becomes 4 and 6 and then it goes to this side it sees that ok 11 is only the single element left so it comes here and it sees that ok I have got 2 sorted arrays like this so in the concur step I will simply merge them so when we will merge them we will get 4, 6, 11 and as we have done this step the algorithm sees that ok this is the one sorted array this is the other like this so friend this is the basic idea behind divide and conquer algorithm when we are dealing with merge sort in our upcoming videos we will see all these steps in greater detail we will see the demonstration of the algorithm step by step so that this idea becomes more clear to you but how it is actually done I hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day so friends before going into the actual algorithm of merge sort so before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update we saw that in divide step we saw that we break the array into two parts or into two sub problems and that we do recursively so at a high level I will simply show you the code so this code we will be discussing in a greater detail with an animation in our upcoming video but just for understanding that how it works so when we break the array into two parts we are not actually breaking the array from here let's say from 0 to 3 it goes like this and from 4 to 6 it goes like this we are breaking it based on the three pointers let's say low high and mid so usually array remains the same and we have something like let's say low points here mid points here and high points here so from low to mid we consider that this is the sub problem and from mid plus 1 to high we consider it as a different problem but the array structure remains the same it's only the pointers which decides which is the left part and which is the right part so here you can see in the sort method this method gets called two times recursively so one is for going into the left side and one is going to the right side after breaking it based on the mid element and as this sort is recursive in nature so here you can see usually at the start low points to 0 and higher points to the last index and let's say if we calculate mid so here it will be 0 plus 6 minus 0 by 2 which will give us 3 so mid comes out to be 3 so for example let's say we calculate mid as 3 so this division here is done based on calling of these two sorts so what we do is so when we call this sort we pass the ranges from low to mid so low to mid so it looks like that we are doing like this and for the right sub array it says from mid plus 1 to high so this is the mid plus 1 to high so it looks like this but the array remains like this only it's actually the logical division based on low, mid and high pointer and this we do recursively so when we call this we actually get this and it again does the same thing again and here you can see it again recursively calls this so this is low and this is mid and this is mid plus 1 and this is high so it goes on like this till we can't divide them further so this condition low less than high help us in preventing that so here if you see low and high point to the same so we simply return from this and once we return from this it goes here then this sort is called like this and here similarly this condition help us to make it come back so after these two steps and we actually merge the two sorted arrays so these are the sorted arrays and you can watch my previous tutorial that how we can actually merge the two sorted arrays but in merge sort we actually take the help of a temporary array which help us in merging the two sorted arrays so this we will discuss in a greater detail in our upcoming videos but here we will simply see a high level view of merge how it is actually done so here you can see that we saw that at the last step we take this sorted array we take this sorted array this is the left array and this is the right array and we usually merge it so we do something like this we compare the elements in the respective arrays and we fill out the array like this and this is our answer that we get a sorted array so this is done via merge method now let's see how we can take the help of temporary array and merge it so this is the same thing which we saw in our previous slide deck so this is the left part and this is the right part so these are distinguished based on these colors so usually how we merge it we create a temporary array of the equal length and then we first copy all these elements like this so here it looks something like this so after we copy every element like this now what we do is this array is our original array we have took every element in the temporary array now we create the pointers which traverse to left part and the right part and based on our comparison the original array is actually filled so I will just remove this so here we take i for this left part and j for this right part and how we actually fill is in the original array we start from here let's say k so we compare 2 and 4 denoted by i and j so 2 is less than 4 so we know that 2 will take this position like this and we are done with this part so we increment i and we also increment k because we are done with this filling now we compare 3 with 4 and 3 takes this place we are done with this increment so we increment i we don't increment j because these values are not filled up and you can watch my previous video where we actually saw that how we can merge 2 sorted arrays so this is the first sorted array, this is the second sorted array and the concept remains the same when we do the merge sort so after filling 3 we increment k and then we again compare 5 and 4 so 4 is smaller so 4 takes this place so we are done with this element so we increment j and here similarly we do the filling so in the next iteration 5 is less than 6 so 5 comes here we increment i we increment k 6 is smaller than 10 so 6 comes here we increment j then 10 comes here and here you can see after filling 10 this element also gets filled so now there are no more elements left in the left part and here you can see that we have only left with 11 so this goes out of the boundary and whatever the values are left in the right part we simply put it here because they are already sorted so anything which comes after 11 will be let's say 12, 14 x, y, z but it will be greater than 11 so they will come directly like this so we simply copy the elements in the left over part of the original array so it goes like this so this is the merge at a high level using the temporary array so from there are 2 cases which we need to see so the case 1 is when the left array is exhausted so here you can see after filling 2 3, 5 into the respective position and even 10 here now your left array is exhausted so we don't touch this now because everything is filled up here and here you can see as we copied all the elements like this in the original array if you see 6, 7 and 8 whatever the values are here those are actually sorted and when we actually copied into the temporary array it came it like this only so here you can see we don't push it back like this because the right array values are already present in the original array in the same order 11, 12, 17 so we do nothing here once the left array is sorted we do nothing because right array is already having the elements here which are already sorted now case 2 comes when right array is exhausted so here you can see 4, 5 6, 10 11 these are all exhausted till this point so after putting 11 j goes out of this array and k comes to this part and k comes to this part because we need to fill 2 more elements and our right array is exhausted so here you can see when the right array is exhausted we have to do something to push left array elements into this 7 and 8 position so how we do that we provide a small code which is like this so here you can assume that mid is this point and i will go till mid and we simply copy the left over elements into the respective places using the i in kth index so here you can see in the original array at kth index we are assigning temp of i so this is the temp and this is the i so 12 will go to array of k like this and then we increment both i and k so k will go here and i will go here and this while loop will continue and will simply put 15 at this position by this assignment so after that this while loop will terminate so friends here we need to keep this 2 cases in mind that if left array is exhausted we do nothing because when we copied the element into a temporary array when the left array got exhausted the right array left over elements were already present in the original array and dead to in sorted form but in case 2 if right array is exhausted so here if this array is already exhausted and all these elements are present here and there are elements left over in the left part so we need to provide some additional code like this to put it into the respective places so we will see this algorithm in much greater detail in our upcoming video because that is very complex algorithm so i just demonstrated at a high level how it looks so when we will discuss that algorithm we will see all the details of sort method merge method and how this sort method recursively calls itself and basically divides the array into 2 halves and later when the 2 halves are no longer divided further then how we actually merge them so friends i hope till this point you must have got a high level idea of how merge sort works in our upcoming video we will see a detailed animation of merge sort algorithm which will make this idea more clear to you you can watch this video 2 to 3 times so that you can get an idea of the merge sort at high level i hope you must have liked this video and in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw at a high level that how merge sort works in java so in this video we will be looking into the algorithm and we will also see the step by step animation of the algorithm before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so here if you see at a high level we are going to sort this array having 5 elements so you just need to keep that at a high level how this algorithm works so that when we demonstrate actual algorithm you can relate to it so here we see the array as 5 elements so we divide the array into 2 parts based on the mid index so we evaluate the mid index let's say here it comes as 2 so how we break it we usually consider this as low this would be mid and this would be high and this would be high so low to mid is the left sub array mid plus 1 to high is the right sub array so here we can see that we break it down logically using these 3 pointers like this low to mid is 1 side and mid plus 1 to high on the other side so now after dividing the array into 2 parts we recursively break the left part further down so here this will be our low this will be mid and this will be high so we break it down into these 2 parts low to mid in the left and mid plus 1 to high on the right part and this algorithm goes recursively and we divide now these 2 elements so it will be divided something like this 9, 5 and here we see we can't further divide 9 and 5 because these are the single elements so these are nothing but our algorithms base case that we can't divide them further so here you can see when the division ends for this part now is the time to conquer it so here this left sub array is actually sorted because it has only 1 element and the right is also sorted so now we have 2 sorted arrays and we try to merge them and we merge them in such a way that the resultant array is also sorted so we simply do the comparison and we come up with 5 and 9 so this is the merge step so after merging the left side, now we go to the right side so we pick 2 2 can't be divided further down so then here you can see we have left sub array and right sub array both are sorted so we try to merge them so after merging it becomes 2, 5, 9 and after doing this part as this is the recursive algorithm we first go to the left and then we go to the right so here you can see for this point we have completed all the left side so now we go and perform the same steps on the right side we break it down into 2 parts then we go to the left and then we go to right so when we go to right, we can't further break it down so here the single element is already sorted we try to break the right side we find that it has only 1 element so we can't divide them further down so what we do is we try to merge them so when we merge them it becomes 3, 4 and here you can see now we have this 2 sub array which are sorted so we try to merge them so 2, 5, 9 and 3, 4 we apply the logic of merging of 2 sorted arrays and at the end we will get 2, 3, 4, 5, 9 so just keep in mind that we will perform these steps when we will demonstrate the actual algorithm so that you can relate that how at high level this algorithm works so here you can see that this is the merge sort algorithm where we have this sort method and this is the array which we want to sort in our previous video we also saw that how we can use this temporary array to merge 2 sorted arrays into the original array so here when we will call this method so let's suppose we want to sort this array having 5 elements 9, 5, 2, 4, 3 so here this temp array is actually of equal length of our original array and at the start it mostly contains the default value which is 0 so for timing I just made it empty and here you can see that we want to sort this complete array from 0 to 4th index so we provide low and a high value so usually at the start low is 0 and high is array.length1 so this array is of length 5 and if we do minus 1 we get the last index so low will point to the 0th index and high will point to the 4th index and here you can see that as it is a recursive algorithm this sort method internally calls itself again with some different values so we need to keep the track of the sort method here in the call stack so we need to keep the track of these 4 things one is the line number so let's say if we are leaving this sort method and calling this sort so we keep the track of the line number because when this sort method will end we need to return back to this method so this line number will help us that where we actually left and which sort method we left so we keep the track of the line number here and 3 fields low mid and high so these 3 fields are very important because they help us in dividing the array and at the end they also help us in merging the array to make the array in sorted form so here at the start there will be one sort method so here we saw that low is 0 and high is 4 so here low should be less than high so this is nothing but our base case because as we are calling this algorithm recursively we need to provide a base case so that we come out of the recursion so in the simple terms let's say if we have this array 5 3 and using this 2 sort method if we break it down like this 5 and 3 so here we can see at this moment of time low and high will point to the same index so when we will call this sort recursively on this element you will find that low is actually equal to high so therefore we can't divide this array further so we actually return and similarly with 3 we return and once we return then we know that 5 and 3 are 2 left and right array so we simply call the merge method and merge them and this we do recursively for each and every array which we have divided so we will see later so for timing this is the base case so currently low is 0 and high is 4 so this condition comes out to be true in our previous video we saw that merge sort is divide and conquer algorithm so this division goes on till our base case is reached and once we encounter the base cases then we try to conquer and by conquer we mean we try to sort 2 sorted arrays which we also discussed in our previous video so this merge method help us in doing that so here we need to divide this now in 2 parts and how we can do that so we try to figure out the mid element and how we can figure out the mid element is by using this formula so here we do low plus high minus low by 2 so here low is 0 plus high is 4 minus 0 by 2 which will give us value is 2 it means this index so usually when you see the merge sort code you will find that this is somewhat different here we do something like low plus high by 2 so basically in the text books most of the time you find this low plus high divided by 2 which give us the mid element so why we actually do this here and not this is because here you can see this low and high are basically integer values so usually they have a particular range and if we cross that particular range we actually get the garbage values so if we do low plus high like this so in most of the cases this works but if low value and high values are at the very end of the integer value and if we do some of it we will actually get some garbage value so therefore if our array is very huge this condition gives us the garbage values so we try to avoid this and we use low plus high minus low by 2 because if we do high minus low we will come back into the integer range only so basically this we use to avoid the overflow of integer value so now here you can see that we have calculated mid as 2 so mid becomes 2 here you can see mid is pointing to index 2 so now what it suggest is from low to mid this would be our left part and from mid plus 1 to high this would be our right part so now we are breaking this array into 2 parts using this 3 variables which are low, mid and high so we are not actually breaking the complete array we are simply dividing the array based on these 3 values so from low to mid this is our left part from mid plus 1 to high this is our right part and we know that we have to call this algorithm recursively because we need to still break it down further till they are not further divided so here you can see after calculating the mid we are now going into the left side of it to divide it further so we will divide these 3 elements further so here you can see that we are going from low to mid and as we are leaving this short method at line number 4 so first we will update the line number here and then we will call the short method so this short method will be called so here you can see we pass mid as 2 so this mid for this short method became high so now there will be one more method on the call stack which is high as 2 because we have called the short method from 0 to 2 because now we need to further break it down this left array so initially there was complete array now we are trying to break this left array further down so high as 2 and here for this short method high will come to this point low is less than high we again calculate the mid point so here mid point would be 0 plus 2 minus 0 by 2 which is 1 so mid becomes 1 we update the mid here it looks something like this so now what it suggests is this boundary again divides the array into 2 parts so from low to mid we have left and mid plus 1 to high we have right so now again recursively we try to break the left part from low to mid so here we are again leaving this method at line number 4 so we will update the line number 4 here and here mid is 1 so for the next short method this mid becomes the high so now there will be one more method on the call stack with high as 1 and for this short method high will come to this position so low is less than high now we again compute the mid element so here 0 plus 1 minus 0 by 2 which will give us 0 so now mid becomes 0 we update it here so mid points to 0 I will just remove this so now we have calculated the mid it means we again have 1 boundary from low to mid which is the 1 element and mid plus 1 to high which is the other element so here you can see that now we are again calling short because currently our array is of 2 elements and we can still further break it down to 1 1 element from low to mid which is the 0 and mid plus 1 to high which is 1 to 1 so we are leaving this short method at line number 4 so this mid is 0 so here you can see low is 0 and high becomes 0 because we have called this short method with mid value is 0 and this mid value for this short method becomes our new high so we will simply point high to 0 as high is 0 so here you can see that now we have reached our base case because we can't divide this single element further so at the start we had this full complete array then we had this small array and then we had this small array and now we are actually having this array so we can't divide 9 further down so it means we have reached our base case and we have to return from here so as we want to return from this short method the call will reach to this short method and we need to begin from line number 4 again so we will see how so this execution point reached here and we know that we had left its previous short method at line number 4 so we will start from there and when we had left this short method low, mid and high pointed to 0, 0 and 1 so we again provide them their own values high becomes 1 mid becomes 0 so it was something like this when we left so now we move ahead so here we are done breaking this left part now this two short method actually help us in getting the left part of the array and right part of the array and then we merge both of them here to make a sorted array so usually this left and right part are also sorted which we will see later and in the merge method we are actually merging two sorted arrays so we will see how so now we need to break 5 or mid plus 1 to high further down so we need to leave this short method now and we need to call this short again and we are leaving at line number 5 so we update line number 5 and there will be one more method on the call stack with values as low will be 1 and high will be 1 because when we had left this short method mid was pointing to 0 and when we called this short again we provided mid plus 1 so it means our new low becomes 1 and high remains the same so it looks something like this for this short method that low is pointing to 1 and high is pointing to 1 like this and here you can see we can't divide 5 further down so this is our base case so now we have to return from this method and once we return from this method the execution point will reach here and that method will be removed from the call stack so we had left at line number 5 so we start from there and when we left this short method low pointed to 0, mid pointed to 0 and high pointed to 1 so we provide them their own values like this so we move ahead so friends here you can see that in this algorithm we are actually recursively going down and down and we are dividing the array into 2 parts so at the end we are only left with single single elements which cannot be divided further which are actually encountering our base case so after this 2 short method now it's time to merge both left part which we got from this short and the right part which we got from this short so here you can see 9 and 5 you can think of it a small array having only 1 element and when array is only 1 element that array is considered as sorted because there is only 1 element so now this merge method will take this left part and the right part because they have only single single element and compare these 2 elements in such a way that both these elements become sorted so that we will see in the merge method so we are leaving this short method at line number 6 now so we will update line number 6 here so we will update line number 6 here so we will update line number 6 here and here we have this merge method we pass the array the temporary array low mid and high so because we require all these 3 values to actually come to know that from low to mid we have left part mid plus 1 to high we have the right part so these are the 3 values so in our previous video we saw that how we are actually doing the merge first we are actually copying all the elements from the original array to temporary array and how we are copying it we are only copying that much part which we want to merge so from low to high so here low is 0 and high is 1 it means we are only copying this and this element so it looks something like this we will traverse this for loop quickly so 9 comes here and 5 comes here and this for loop ends so now we have copied the elements like this here we will now merge these 2 sorted arrays which is having only single elements left and right so here we actually take 3 pointers one will point to the left sub array so here i will point to the left sub array j will point to the right sub array because we know that it is starting from mid plus 1 and k will help us in merging these 2 sorted arrays back into the original array so we will see now so i is 0 it is pointing to this left sub array so you can think that this array is like this left and right j is 1 so j is pointing to the right sub array and k is 0 so k will basically start from low because we are merging these 2 sorted arrays based on this range so when we copied this element from any particular range we need to put it back into that range only so we are starting from k equals to whatever the value low has so currently it is pointing to the 0th index so here in our previous videos we actually discussed how we can merge 2 sorted arrays so the idea behind this algorithm or this merge method is pretty much the same here i will go till it is less than equal to mid so i will traverse the left part and j will traverse the right part so these are the last indexes of these 2 small arrays so currently both the conditions come out to be true because 0 is less than equal to mid and j is less than equal to high so here you can see we have 2 small arrays of single single element which are inherently sorted and now we need to merge it in such a way that final array also is sorted so how we do that is we are taking 10 value with i.e. index and 10 value with jth index which is 9 and 5 and we are checking whether 9 is less than 5 or not so 9 is not less than 5 so this condition comes out to be false and the else part will be executed so it means that this position among these 2 values whichever is the smaller will place it there so currently 10 value with jth index is smaller which is 5 so 5 goes to the kth index of original array so it goes like this and here we have placed 5 at its correct position so we simply increment j j becomes 2 but we know that currently there was only 1 element but there could be a possibility that we are trying to merge a very huge array which is equally among the left and the right part but currently we have only this 1 element and as we have filled this position we will increment k so k becomes 1 now here you can see this condition comes out to be false because j has crossed the limits of high as j value is 2 greater than 1 so this while loop will terminate and here you can see once the while loop gets terminate we have only placed 5 here we need to place 9 at its correct position so we are providing this small loop and we also discussed in our previous video that once the right array is exhausted we need to provide this small while loop so that all the elements of the left sub array are directly copied back so they are copied back with this condition which was similar to here that i should be less than equal to mid so currently i is less than or equal to mid and using this while loop we are simply copying back the element from the ith index to the kth index so now 9 goes here and after placing 9 to correct position we have used this 9 so we will increment i i becomes 1 we have filled this position so we will increment k also k becomes 2 and here you can see that we have merged this left and right sub array so here now this condition comes out to be false so here you can see after this merge method ends we sorted left and right both were two sorted arrays and we merged them so we got the result array of two elements which are now sorted so now we will leave this method and we will go back to the sort method where we actually left so the point will reach here back we had left at line number 6 which was this part so now here you can see so when we had left low, mid and high pointed to 001 based on the values we kept here so it was something like this so here you can see now this sort method will end because there are no more lines to execute and also you will find it after this merge method ends in the original array vf5 and 9 actually sorted into the range of low to high so this method will end now and once this method will end it will reach to this point because we had left this sort at line number 4 so we again start execution from line number 4 we provide the respective values to low, mid and high so when we had left this sort, this was our condition so now we move ahead with our execution so here you can see this sort method actually sorted the left part so here you can see if this is the line this array which is our left is sorted now so now we try to go to the right part using this sort method so we provide mid plus 1 and high so mid plus 1 is the range for the right part and it goes still high so now we will again leave this method at line number 5 so this sort method will be called again with low as mid plus 1 so when we will leave this method mid was pointing to 1 so in the call stack there will be sort method where low will be node 2 which is like this here and high will point to 2 because the high remains at its own position mid was 1, previous to it so for this method it became mid plus 1 so mid plus 1 is 2 and this 2 became our low for this sort method so it means now we are going to the right side recursively to divide that array further down so here you can see we only have this one element so we have encountered our base case so we return from here we reach here we had left at line number 5 and we have line number 5 so we start from line number 5 and now here you can see we provide these values to their respective variables low was 0 mid was 1 which is at index 1 and this was our line which divided the left and right so this is the left and this is the right so here you can see when we had called merge method previous to that we actually merged 2 small arrays having single element 5 and 9 and whatever was the result that was sorted then we went to the right and we found that the right part has only one element so it is already sorted so this merge method will take a bigger sorted array and will try to merge with the right sub array so this merge method will be called this is our temporary array high is 2, mid is 1 and low is 0 so from low to mid so from low to mid this is the left part which is sorted and from mid plus 1 to high this is our right part now we are actually merging a slightly bigger array so we will go over this merge method quickly we copy the elements from the original array to the temporary array from low to high so 5, 9, 2 we copy to temp at the respective positions so we will go over this for loop quickly 5 comes here 9 comes here 2 comes here and this for loop will end so friends here you can see that now we have a left part and the right part which are sorted and we need to merge these two sorted arrays and after merging it we need to transfer it back to the original array so this is the boundary for left and this single element is in the right so it's very much similar to what we discussed previous to it i will be traversing the left part and j will be traversing the right part so j will start from mid plus 1, mid plus 1 is 2 and i will start from 0 like this and k will start from the low which is 0 so now we will again merge these two sorted arrays based on this while loop provided here so i is less than mid and j is less than equal to i so both the conditions come out to be true now we compare the element at ith index with the jth index which is 5 and 2 so 5 is not less than 2 so this condition comes out to be false and into the original array we first place the smallest element which is temp of j so temp of j is 2 so 2 goes here and after using this we increment j so j points to 3 and after filling this position we increment k now here you can see that the right array is exhausted because j value is 3 and 3 is greater than 2 so this condition comes out to be false so here you can see that we actually placed all the elements of the right sub array into the original array but the left sorted array still remains and as it is already sorted we will simply copy it back to the respective kth position using this while loop so i is less than equal to mid we copy 5 to the kth index which is 1 so 5 comes here then we will increment both the pointers because we have filled this position and we have used this element so i becomes 1 and k comes to 2nd index i is less than equal to mid we copy 9 to index 2 we filled this position so k comes here and as we have used this position so i comes here so now this value will terminate because value of i is 2 2 is greater than 1 so this condition comes out to be false so friend here you can see now slowly we are merging the array and we are actually getting a bigger sorted array so it started with single single element then we got 2 elements 5 and 9 and now we are getting 3 elements 2 5 9 so we go back to the sort method where we left so here we left at line number 6 where these were the default values for low, mid and high low, mid and high and this was the boundary so here you can see now we have sorted the left part and the right part in such a way that now they are completely sorted with this much range so this merge method is ended all will reach here so this is the line number where we left this sort method and the respective values are 0 2 and 4 so high was pointing to 4th index mid was pointing to the second index when we actually left at the first sort so now here you can see we have completely sorted the left side of it now we simply go to the right side using this sort method which is going from mid plus 1 so this range is mid plus 1 2 high so when we will call this sort method again, mid plus 1 becomes our low so here we will first update the line number there will be one more method on the call stack where low will be 3 because mid plus 1 is 2 plus 1 which became our new low for the right part and high is actually 4 only so we are simply placing this into the respective indexes for this sort method low is less than high we calculate the mid now here you can see first we did this for the left part and we keep on breaking it till we got a single element now we are simply doing it for the right part so now low is 3 plus 4 minus 3 by 2 so this will give us value as 3 because 1 by 2 is 0 and 3 plus will give us 3 so this will give us 3 now so here you can see now we have got our 2 boundaries low to mid is the left part and mid plus 1 to high is the right part so first we will go to the left part and try to divide the array we will update line number we will call the sort method with low as 3 and when we had left this sort method mid was actually pointing to 3 so for this sort method here this mid becomes our high so value is 3 so it looks something like this so we have reached our base case and we can't divide 4 further down which is at index 3 so we return back I will just remove this so we had left at line number 4 so we start execution from here low, mid and higher pointed to 3 3 and 4 like this so here this 4 cannot be divided further and as this left part is only one element it is inherently sorted and now we go to the right part via this sort method we update the line number and here we are leaving with mid plus 1 which will become our new low so mid plus 1 is 4 so in this sort method low became 4 and high is actually at its own position 4 so it looks something like this this is our base case because low is actually equal to high it means we can't take 3 further down so we return we had left at line number 5 so we start execution from line number 5 and at that moment low, mid and higher were 3 3, 4 so we will assign those values back to them 3 so here you can see for the right this is single element array which is the left and this is the right both are sorted so we simply merge them to make it a bigger array which is also sorted so we will call the merge method so this was the condition when we left the sort and came for the merge so it was 3, 3 and 4 so here you can see we are not touching now this part because this left part is already sorted so therefore we have provided this low, mid and high because now we will copy the elements from the original array to the temporary array from low to high which is from 3 to 4th index so only these two elements will be copied here we will see it quickly 4 will be copied here and 3 will be copied here because we are simply assigning the value at the ith index of the original array to temp array and this for loop will end so now our task is to merge these two sorted arrays this is the left and this is the right via this temp array so i will be traversing the left part j will be traversing from mid plus 1 which is the left part j will be traversing from mid plus 1 which is the right part and k which will start from the low which is the index 3 because we don't have to touch this part now we have to only sort in this range like this so here i is 3 j is 4 because j starts from mid plus 1 and k is 3 j will traverse to the left part j will traverse to the right part and k will help us in merging them to the original array so i will just remove this stuff so here you can see i is less than mid and j is less than equal to i so the while loop will execute we compare the ith index value with the jth index value which is 4 and 3 so 4 is not less than 3 so the else part will be executed it means we take 3 which is temp of j and we put it into the original array at its correct position because we need to sort this two smaller arrays so 3 comes here we have used this element and we have filled this position so we will increment j j becomes 5 which is now out of the boundary for this smaller right array we will increment k k becomes 4 and here you can see the right array is exhausted completely so we will break from this while loop and then we have provided this while loop because we need to still place the elements of the left sub array back into the original array and as the left array is already sorted we simply copy it back to the original array via this assignment so i is less than or equal to mid we assign temp of i2 kth index of array 4 comes here then we will increment i and k because we have used this element i becomes 4 and we have filled this position so we are incrementing k also so this while loop will terminate now because we are done with our task of placing both the elements into their correct position within their range and here you can see initially it was 4 3 and now it is 3 4 which is sorted in this particular range so we go back and we had left at line number 6 so here you can see current status of array is something like this 2 5 9 3 4 so the left part is sorted the right part is sorted and these were the values for low, mid and high when we left so now this sort method will end because there are no more execution steps so now call will reach to the previous sort method we had left at line number 5 and at that moment low, mid and high were 0 2 and 4 so this is the very starting point where we left the first sort method so this was the condition so now here you can see we have a larger left array and a larger right array and both are actually sorted so 2 5 9 and 3 4 into their respective ranges they are sorted it means we have 2 sorted arrays and using this merge method we will merge these 2 sorted arrays in such a way that the resultant array is also sorted so here one thing this step at every point when we called merge method we did merging of 2 sorted arrays so at the start we had only 1 1 element then we got 2 elements then it became 3 like this and here it became 2 and now finally we are merging a left array of 3 elements and right array of 2 elements so let's see this merge method now we have updated the line number 6 here so these are the values for low, mid and high 0 to 4 and this is our current original array so now here you can see from low to high we copy all the elements to the temporary array because in the merge we actually do the merging based on this ranges here low is 0 and high is 4 it means from 0 index to 4 we will copy every element to the temporary so we will quickly go over this for loop 2 comes here 5 comes here 9 comes here so these are simple assignments 5 comes here 9 comes here so these are simple assignments so now this for loop will end so here why we are copying this element into a temporary array because this temporary array is helping us with this actual merge which we are doing here and it is helping us putting the elements into their correct position in the original array so here the left array is from low to mid so 0 to 2 is the left array so this is the boundary for left and right array and mid plus 1 to high is the right array so I will traverse the left array and j will traverse the right array which we already discussed in our previous merge method i is 0, j is mid plus 1 which is 3 and k is 0 because we need to merge this element from the low to high so we are starting k with low i, j comes here and k comes here and here you can see this is the boundary for left and the right sorted arrays so we will quickly go over this step because we have already discussed what it does i is less than equal to mid and j is also less than equal to high we compare the ith and jth index value which is 2 and 3 so 2 is less than equal to 3 so this condition comes out to be true so we are simply copying now 2 to kth index because this is the smaller value among these two so it becomes 2 and here we have used this value so we will increment i i will become 1 we have filled this position so we will increment k 1 is less than 2 and 3 is less than 4 so both the condition comes out to be true we will compare ith and jth index values which is 5 and 3 and here 5 is not less than 3 so this condition comes out to be false we put the smaller value at the kth index of the original array by this assignment so 3 comes here we have used this value so we will increment j j becomes 4 we have filled this value so we will increment k both these conditions are still true we will compare 5 and 4 5 is not less than 4 so this condition comes out to be false so we will simply put the jth value at kth index of the original array so 4 comes here we have used this value so we will increment j j becomes 5 we have filled this position so we will increment k so from here you can see now this condition is true but this condition is false because 5 is not less than equal to 4 it means the right array is exhausted completely so this value will terminate and once the right array is exhausted we know that whatever the elements are left in the left array those are actually sorted in their respective array so we simply copy them 1 by 1 to the original array using this small while loop so i is less than equal to mid we copy temp value at ith index into the original array at kth index so we are simply assigning 5 to this position we have used this value we will increment i i becomes 2 we have filled this position so we will increment k and similarly we will place the last value at its corresponding index so 9 comes here this value is used i becomes 3 this is filled so k becomes 5 so now this while loop will terminate because value of i is 3 and 3 is not less than equal to 2 so this merge method will end and here you can see now finally we have sorted complete array 2 3 4 5 9 so we go back to the method call where we left the sort and we call the merge so execution point will reach here at line number 6 and these values will be pointing to 0 2 4 and friends here you can see the original array is now properly sorted 2 3 4 5 9 and there are no more lines to be executed after that so this sort method will end so all the method in the callstack has ended and we have got our sorted array so friends this was the complex animation of this merge sort which i depicted based on this callstack i hope you must have got some idea of how it works internally so friends i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw the demonstration of the merge sort algorithm via an animation step by step we will actually code the algorithm and will test its working in the main method so before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here if you see i have created one classes merge sort which is having print array method which we have already discussed that it is used to print the elements of an array on the console we will be creating the method as sort and as we discussed in our previous video that this sort method will take the original array one temporary array which will basically help us in sorting the original array we will take the range from low to high so usually at the start low is zero and high is actually pointing to the last index of the array because we want to sort the complete array now in this method we provide a condition as low should be less than high now this is basically a base case because this sort method is actually recursive in nature we will see later so in this algorithm we are actually dividing the array into two parts the left part and the right part and we will keep on dividing them till the left and the right part contain only single element because they can't be divided further and when low will be equal to high it means we are having only single element so we need to return from this method because we can't divide the array further down so when low is less than high now we will divide the array into two parts so for that we need to figure out the mid index so here we evaluate mid so we use the formula low plus high minus low divided by two so here you can see these are nothing but indexes we can use this formula which will evaluate as the mid index so this formula also takes care of the integer overflow condition let's say our array is huge which we have already discussed in our previous video if the array is very small and it fits into the integer size we can also use this formula low plus high divided by two because here you can see why we are using this formula is because these are two integer values and if we are doing addition of it let's say low and high are at any particular value of integer when we do sum of it it crosses the integer limit so therefore we will get some garbage value so therefore on the safe side we do this we do minus of both the ranges so that the overall value is still in the integer range so after evaluating the mid now as this is a recursive algorithm we will call short again so we break it down the array into two parts and the range would be for the left it will be low to mid and for the right it will be from mid plus one to high so here you can see this is a recursive algorithm and it keeps on dividing till there are only single elements left which can't be broken further down so after getting to that point as single elements we treat them that they are already sorted because there is only one element from there on we try to merge them together and this merging keeps on going till the final array is sorted so in the merge method we pass the array we pass the temporary array we pass low mid and high why we are passing all the three values is because in the merge based on low to mid that will be our left sorted sub array from mid plus one to high will be our right sub array which is sorted and we are simply merging two sorted arrays to get a bigger sorted array so we will code the merge method now so here you can see we have this original array and we have this temporary array we know the range that it goes from low to high low to mid is our left sub array, mid plus one to high is our right sub array so before merging the two sorted arrays we can't directly merge them in the original array so in order to merge the two sorted arrays we take the help of this temporary array what we do is we provide a for loop which starts from low and goes till high index so what we are doing is now we are simply copying the elements of the original array into the temporary array so this is what we discussed in our previous video in greater detail so here we do temp of i array of i now we have got our range from low to high in our temporary array and we also know that from low to mid we have the left sub array which is sorted from mid plus one to high we have a right sub array which is sorted and now we need to merge these two sorted arrays such that the resultant array is also sorted so in one of our previous videos we saw that how we can merge two sorted arrays so we will apply the same algorithm here so for more understanding you can watch that video so here we will create now three variables i j and k so here i will traverse left sorted sub array j will traverse right sorted sub array and k will merge both arrays into original array which is this so if i is traversing the left sorted sub array we know that it should start from the low because from low to mid we have the left part and j should start from mid plus one because we know that the right sorted sub array is from mid plus one to high and we also know that as we are merging the two sorted arrays within a range from low to high k should also start from low and it will go till high so after creating these three pointers we will now compare each and every element of the left and the right sub array and whichever element is small we try to fit in that element into the original array at kth index so this is the basic idea behind merging two sorted arrays such that the resultant array is also sorted so we have provided while loop and the condition we provide is i should go till mid and j should go till high and if any of this condition breaks the while loop will terminate so here what this condition suggests is when we are merging the two sorted arrays there will be a point where either left array will get exhausted or the right array gets exhausted so whichever gets exhausted this condition will break respectively and we will come out of the while loop so inside this while loop now we will try to compare the left array's ith index value with right array's jth index value and as these two arrays are already sorted that's why we are doing the comparison with the respective indexes so we do if temp of i is less than equal to temp of j so here it means whichever value is present at the ith index left sub array value is small so at the original array at kth index we will put temp of i and after placing the temp of i we know that left array is one element is at its correct position so we will increment i and else we do the other way round array of k temp of j and we will increment j by one position because we have taken up one element from the right sub array and here you can see we are actually filling the original array at kth index so after this if else block as kth index is filled up so we also increment k by one position to fill in up the next element so this value will again go on like this till any of the array is exhausted so here you can see that now there are two cases which can arise either the left array gets exhausted or the right array gets exhausted so here when the left array gets exhausted all the elements of the right sub array we don't copy it back to the original array because those elements are already at their correct position in the original array because when we are copying the elements from the original array to temporary array and as both the arrays are sorted so the elements of the right sub array which are left over will usually be at their correct position in the original array so these two cases we discussed in greater detail in our previous video now we only need to keep in mind is if the right array gets exhausted first then we need to write some logic to put in the left array's left over elements into the original array so for that we provide a while loop and the condition is exactly the same because this i is pointing to an index from where the left over elements are starting and we can simply copy it back to the original array so what we do is we can simply copy it something like this temp of i k++ and i++ so it is a simple loop which is copying the elements at i at index of temporary array into the original array at kth index and after copying it we are incrementing both the pointers so once this method will end the smaller left and right sub array will be sorted and then as it is a recursive algorithm working like this so it keeps on merging the left and the right sub array till the point all the elements are sorted in ascending order so now let's test its working in the main method so here we have created this array 95243 here we will call the sort method we will pass the array which is our original array and we need to pass a temporary array so which is of length same as our original array so we will do new int array.length we pass the low as 0 and high as array.length minus 1 because at the start low is at the zeroth index and high is at the last index which is array.length minus 1 and after doing the sort we will print the array and we will see whether these 5 elements are sorted or not if i run the main method so here we can see it sorted as 23459 now let's suppose if i put one value here as minus 1 if i call it again so here we can see it it sorted in ascending order so friend this is all about the merge sort algorithm so friend this is all about the merge sort algorithm so friend this is all about the merge sort algorithm so friend i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss that how we can sort an array having zeros, ones and twos so we need to sort an array in such a way that zeros are at the start ones in the middle and twos at the end so this problem is also known as Dutch national flag problem because each number basically corresponds to one of the colors in the flag so for example zeros let's say given as red one to white and two to blue so when we sort an array having zeros, ones and twos zeros are at the start, ones are at the middle and two are at the end so therefore this problem is also known as Dutch national flag problem so in this problem we are given an array containing only zeros ones and twos so let's say if we take this example we have zero, one one, two, zero, one two, so these are currently random numbers and when we actually sort them we get zero at the start one in the middle and two at the end so it looks like Dutch national flag like this now our task is to sort the array in O of n time complexity and O of 1 space complexity because if we sort this array using the language specific sort method then the time complexity will be n log n but as we know that there are only three types of numbers, zeros, ones and twos we can leverage this idea and achieve O of n time complexity so let's see how so friends before we start the discussion in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so friends here you can see that this is the piece of code which actually does the sorting in O of n time here we have one while loop which does all the trick so in this video in order to demonstrate at a high level that how this algorithm works, I have just mentioned the code here in our next video we will see the demonstration of this code step by step so let's see at a high level how this algorithm will work now for example we are given an array of seven elements from index zero to six and the numbers are zeros, ones and twos so two zero, two two, zero one one now we need to sort this array in such a way that zeros are at the start ones in the middle and twos at the end so this is start this is middle and this is end so friends the basic idea behind this algorithm is we actually use three pointers which is i j and k so here in this algorithm each pointer has a special task to perform so at the start i starts from zero, j starts from zero and k starts from the last index so i starts from zero j starts from zero and k starts from the last index now here you can see that after that we are providing a while loop where the condition we are providing is i should be less than equal to k so here i is our main pointer which will actually traverse the array in this direction and when it traverses in this direction, k also traverses in this direction and this loop will go till i is less than or equal to k once i crosses k this while loop will terminate and our array will be sorted in zeros, ones and twos format so here the i is our main iterator of the array now its main job is here we can see at the start we have to provide zeros in the middle, ones and at the end twos so whenever i will encounter zero here it is encountering zero so we know that we have to throw zero to the start so basically when zero will be encountered it will be thrown to j and whatever will be j will hold it will come at the place of i so zeros will be at the start and j will help us in achieving that when two will be encountered i will throw two to end and to the end we have k so it will throw it to the k and take its value to the ith index so this will achieve this part when i will encounter one it will do nothing, it will simply traverse ahead because one is already in the middle so this is the crux of the algorithm that we have three pointers and three numbers when i will encounter zero it will swap that number with j when i will encounter two it will swap it with k and when i will encounter one it will just move ahead and keep one at that position only so here you can see at the start the numbers are in unsorted form so we usually draw four regions like this one region is for zeros other region is for ones and the third region is for twos and one region is just to mark which are the unknown elements till now or unvisited elements till now so at the start all the elements are unknown so they are marked as unknown and their range is from i to k so from i to k so every number is unknown so every number has tick now slowly when i will move ahead it will try to encounter these numbers and try to explore them so these tick will come in these three regions marking for the zeros, ones and twos at the start from i to k all numbers are unknown from start which is the zeroth index to j1 so j is actually pointing to zero index if we do minus one will reach here so currently there is no such area or range from j to i1 j to i1 which is also unknown area from k plus 1 to end which is the last index so if we do k plus 1 we will go out of this so this is also the unknown area so at the start all the elements are unknown and all the regions are unfilled now we will slowly move ahead and try to fill each and every region so let's see how we can remove this unknown elements and fill the zeros, ones and twos and one thing to remember zeros, ones and twos will be filled in a proper order zeros at the start, ones in the middle and twos at the end so we will see it later here so here you can see at the start, array of i is two so this condition is false, this condition is also false and this condition is true because array of i is equal to two so now what i will do, here we saw that whenever i will encounter two, it will simply swap two with the value which k is holding or index k is holding when we will do swap for two and one which is being referred by i and k in the swap method we will simply swap them so one will come here and two will come here so here our one task is done successfully that we have placed two at its proper position here so one two is at its proper position and we know that when this while loop will run one element has become known now and which is that element which has become known is this, that two is at its correct position also friends as we have filled this position we will move k to this direction because for the other two which is here for example it should come here right so k will move to this position and it keeps on moving in this position as many as twos are encountered because we need to swap two with the value of the kth index so we do k minus minus so k comes here now here you can see as k is here we know that from k plus one to the last index we have two so here we will see this range at every moment of this while loop and we will figure out where this take will go so if you see here k plus one k plus one is this index to the last to the end which is the same index we have to mark twos because one number is known so this take will go away and this take will come here which says that from i to k still the numbers are unknown and only one number was known which is placed at its correct position we have provided take here now here one thing to notice when we do this swap two will come here and at this position there could be zero, one or two any of the three number so we are not sure which number is actually getting swapped here so i will be at the same position only we will only move k so this is the one difference so in the next iteration of while loop here you can see now this condition will be false and this condition will be true because area of i is one so we discussed when we encounter one we will simply move ahead because ones will be in the middle so we will simply increment i so i will come here and as i will come here here you can see that unknown is from i to k which is this portion now because this number is known from start to j1 we have zeros so j is still here j1 is out of this area from j to i1 we have to mark 1 so j to i1 which is this part we have to mark 1 so this element is known so it will go away and mark will come here because we have found 1 and we have placed at its correct position in this range so these ranges are important it will help us in traversing the array and also relocating the values of zeros, ones and twos moving ahead now here you can see array of i is 0 so this condition will come out to be true so here we have discussed that whenever i will encounter 0 it will throw it to j and take its value so here 0 and 1 will be swiped by this method 0 comes here 1 comes here so here you can see now 1 has actually changed its position initially 1 was here we have marked here now 1 has actually changed the position so here what we will do we will increment i and j both so why we are incrementing i because here we saw that whenever we encounter i as 1 we simply move ahead and if you see this range 1 is always 1 step behind the i so range is from j to i1 so whenever i will point to 1 it will simply move ahead so this is the range that 1 is behind the i so we will do i++ and j++ so why we are doing j++ because we have placed 0 at its correct position now another 0 should come here so we are doing j++ so j comes here and now if you again look into this ranges from i to k these are still unknown and 1 number is known which we placed here and we took 1 and placed here so from start to j1 start to j1 we have zeros so 1 tick will come here because we have identified 1 0 so this will go away it will come here and also here you can see that from j to i1 j to i1 this portion is actually our 1 so now this tick will go away and it will come here because we have swabbed 0 and 1 so 0 is now at the start 1 is in the middle and 2 is at the end and in the middle we have unknown elements so this is how this algorithm works let's see further iterations now array of i is 2 so this condition comes out to be true so we know that what we need to do we need to simply swap this value with k so 1 will come here and 2 will go there 1 comes here, 2 goes there and then we will decrement k because the next 2 value should come here so this position is filled and 1 more number is now known so if we mark again from k plus 1 to end we will mark 2 so k plus 1 this range will be marked as true so this tick will go away and there will be 1 tick here in the middle we have unknowns also friend one more thing that here why we are moving i when array of i is 0 and we are not moving i when array of i is 2 because when we are swapping it with array of k we don't know what value it will be 0, 1, 2, any value but when we are swapping it with array of j which is here we are sure that there will be only 1 single value 1 because we have started traversing i from the middle and whenever we are encountering 2 we are throwing it here and whenever we are encountering 1 we are simply moving i ahead so we are leaving 1 behind so that will be the only value which will it will be swiped so therefore it makes no sense to keep i in the same place so we move i also with it but here we don't know whether it is 0 1 or 2 which is being swiped so therefore we are keeping i at the same place so now in this iteration array of i is 1 which is this condition so we simply move i i comes here this element is known because 1 should be in the middle so this thing will go away because unknown is from i to k and i to k is this range this element is known we have to put this element here from j to i1 j to i1 which is these 2 numbers so 1 tick comes here now in the next iteration array of i is 2 so what we do is we simply swap and move k in this direction so we are simply swapping 0 and 2 so 0 comes here and 2 comes here and then we are decrementing k because we have filled 2 at its proper position so we are moving k here so k comes here this element is known it will go away and it will come here because from k plus 1 to end we have to provide 2 so these are 2s k plus 1 to end now only 1 element is unknown so in the next iteration i is still equal to k and array of i is 0 so we will simply swap this 0 with the jth element here so 0 comes here 1 comes here this is the proper place of 0 so we increment j and as we have placed 1 here we have also seen that whenever we encounter 1 at the ith position we simply move ahead so we are also moving i ahead so i comes here and j comes here so now every element is known so this tick will go away and where this tick will come it will come here because we have just placed 0 at its correct position so we will mark this as true and as we have swapped 0 and 1 so this tick will go away and it will come here so it would look something like this so now if we match the range we will see that unknown are from i to k so i has actually crossed the boundaries so every element is known now so its blank from start to j1 this is start this is j minus 1 will reach here so this is actually our zeros which is being marked properly from j to i1 we have marked once so j to i minus 1 so this is the place for once we have marked it properly from k plus 1 to end we have marked 2 so k is here, k plus 1 is this to end we have all the 2's which is what we have ticked here so friend this is how this algorithm works basically we need to keep the track of 3 pointers i is actually doing main work it is encountering different values at different positions when it encounters 0 it swaps it with j when it encounters 2 it swaps it with k and when it encounters 1 it does nothing it simply moves ahead so you need to go through this algorithm few times to understand how these regions are getting plotted and how these 0's, 1's and 2's are actually segregated that way in our next video we will actually see the detailed demonstration of this algorithm step by step but to demonstrate this in high level i will just use these regions so that when we encounter this algorithm step by step we can directly come to know that which element is here so friends i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss the algorithm step by step that how we can sort an array of 0's, 1's and 2's in our previous video we saw at a very high level that how this algorithm works in order to understand this video you need to watch that video first so lets see the demonstration of this algorithm step by step so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update here you can see that we are given with a algorithm where the method name is 3 number sort which takes in an array now this array consists of 0's, 1's and 2's and we need to sort that array in a linear time so lets see the demonstration of this algorithm step by step now lets suppose we are given with this array having 7 elements 2, 0, 2, 2, 0, 1, 1 and we need to sort this array in such a way that 0's are at the start 1's in the middle and 2's at the end so when we will call 3 number sort method we will pass in the array so friends in our previous video we discussed that we can solve this problem using 3 pointers i, j and k we also discussed that i is the main iterator which will traverse from 0 to a value less than or equal to k and we also discussed that how this 3 pointers help us in sorting the array so at the very beginning i starts from 0 j also starts from 0 and k starts from the last index which is 6th index now as we need to sort this array in linear time we have provided a while loop and the condition in while loop is i should be less than or equal to k so here i will travel in this direction k will travel in this direction and when i will cross k this while loop will terminate now at the start value of i is 0 and k is 6 so this condition comes out to be true so inside this while loop we have provided 3 conditions array of i which is the value at ith index it can be equal to 0 it can be equal to 1 or it can be equal to 2 so any of this condition will come out to be true now here what we do is when i will encounter 0 it will throw it to j and take ith value so j is mostly behind i and when we encounter 0 we know that 0 should be at the beginning because we need to sort the array in such a way that zeros are at the beginning so it is the responsibility of i and j to put 0 at the beginning so whenever i will encounter 0 it will throw it to j and take ith value whenever i will encounter 2 it will throw it to k and take ith value so here k is at the last index and we know that we need to place 2 at the end so i will throw 2 to k and take ith value and whenever i will encounter 1 it will do nothing it will simply move one step ahead because the 1 is already in the middle so j keeps the track of placing 0 at the beginning k keeps the track of placing 2 at the end and i whenever encounter 1 simply move ahead and do nothing so here at the start array of i is 2 so therefore this condition comes out to be false this condition also comes out to be false and this condition comes out to be true so we know that whenever i will encounter 2 it will simply throw the 2 to k and take ith value it means we are swapping the value with the kth index so we will call swap method we will pass the positions of i and k and here it will swap them so i will be demonstrating swap directly this we have seen many times in our previous videos so when we will swap i and k 1 will come here and 2 will go there it means we have swapped value with ith index with value with kth index we have thrown 2 at the end and after placing 2 at the end we know that this 2 is actually at its correct position so now we decrement k because the next 2 will come here so we do k minus minus so k becomes 5 moving ahead i is still less than equal to k now array of i is 1 so this condition comes out to be false this condition comes out to be true and whenever we encounter 1 we do nothing, we simply move i by 1 position because we don't have to touch 1 it's already in the middle range so we move i 1 position ahead i becomes 1 moving ahead i is still less than equal to k now here you can see array of i is 0 so this condition comes out to be true so when array of i encounter 0 or i encounter 0 it will simply swap it with j and take its value so when we will swap it with j 0 will come here and 1 will come here so here now 0 is at its correct position because we need to arrange 0 at the start so after placing 0 at its correct position the next 0 should come here so what we do is we increment j and i both and as i is pointing to 1 we know that we need to simply traverse i also by 1 position so we do i plus plus i becomes 2 and we do j plus plus j becomes 1 so now next 0 will come here i is still less than equal to k now array of i is 2 so this condition comes out to be false this condition also comes out to be false now this condition comes out to be true so it means we need to throw this 2 to k and take its value so when we will perform swap 1 will come here and 2 will go there and now 2 is at its correct position here so we will decrement k so k becomes 4 also friends here who can see that when we are swapping with k we are only decrementing k we are not moving i ahead because when we are swapping it with k whatever value is here there could be 3 possibilities it can be 0 it can be 1 or it can be 2 so we are not sure that what value we will encounter here so therefore we are keeping i at the same position but when we are swapping it with j we know that there could be 2 possibilities 0 or 1 so when we encounter 1 we know that we have to move i by 1 step but when we encounter 0 it means that i and j are pointing to the same index and when we will do swap 0 will come at same position only and then we will move both the pointers together ahead so the maximum time the value which we swap between i and j is 1 so therefore after this swap when i will see that here it is 1 it will simply move ahead by 1 position but with k we don't do this because we can get 3 possible values 0, 1 and 2 and we are not sure that what value it is getting swapped with now again i is less than or equal to k array of i is 1 so this condition comes out to be false now this condition comes out to be true because array of i is equal to 1 and we know that when we encounter 1 we simply move i by 1 position because 1 is already in the middle area so we simply increment i by 1 position i becomes 3 i is still less than or equal to k now array of i is 2 so this condition is false this condition is false and this condition will be true so when we encounter 2 we simply throw it to k and take its value so 2 will come here and 0 will come here like this now this 2 is at its correct position so we will decrement k k becomes 3 now here i is equal to k so this condition is still true array of i is 0 so this condition will be true when we will encounter 0 we need to throw it to j and take its value so that 0s are at the start so when we will do swap so 0 will come here and 1 will come here it means 0 is now at its correct position and as we have encountered 1 here we first move i by 1 position so i becomes 4 we have placed 0 at its correct position so we will move j also by 1 position j becomes 2 so friends here you can see now this condition comes out to be false because i is actually greater than k so this while loop will terminate and here you can see that we have sorted the array in 0s 1s and 2s form where 0s are at the start 1s in the middle and 2s at the end so friends this is all about the algorithm we usually take the help of 3 pointers i, j and k i and j starts from 0th index k starts from the last index when i will encounter 0 it will simply swap it with j because j's responsibility is to place 0s at the start when i will encounter 2 it will simply swap it with k because the responsibility of k is to put 2 at the end and when i will see 1 i's responsibility is to place 1s in the middle and as i is already in the middle it will simply move ahead so friends i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss about a basic introduction to quicksort in this video and in upcoming few videos we will discuss completely about quicksort so quicksort is a sorting technique where we get a collection of elements and we sort them in ascending or descending order so in quicksort here if you see when we discussed merge sort we saw that it was a divide and conquer algorithm so by divide and conquer we mean that let's say if we are given a complex problem we try to divide that complex problem into smaller sub problems and when those smaller sub problems are not further divided we try to conquer them and when we conquer each and every smaller sub problems we reach to the solution of our original problem so quicksort is also a divide and conquer algorithm it involves three steps the first step is the pivot selection so in pivot selection what we do is we pick an element from the array and mark it as pivot now this pivot element can be the first element last element or any random element we just take any element and mark it as pivot so here let's suppose we are given this array and we want to sort this array using quicksort so as we discussed the first thing we do is we take a pivot element now this pivot element can be the first element any random element or the last element so we can take any element as pivot in this tutorial we will take the last element as our pivot so here the last element which is at index 8 the value is 3 so this is our pivot so this is the first step we take a pivot and we can take any element as our pivot now after taking a pivot what we do is whatever the element we have taken as pivot now we actually partition the array so by partitioning we mean that we reorder the array such that all elements greater than pivot comes after the pivot and all the elements smaller than pivot comes before the pivot the elements equal to pivot can go either side of the pivot so whatever the pivot we took which we saw in our previous slide it was 3 so then we partition the array in such a way that all the elements which are greater than pivot comes after the pivot and all the elements which are smaller than pivot comes before the pivot so we are actually reordering the array and the elements which are equal to pivot can go on either side it can go on the left side or on the right side so why we are doing this partitioning is this is the important step after we perform the partitioning the pivot is actually at its correct sorted position now what it means is let's say 3 is the pivot and these are the remaining elements so all the elements greater than pivot should come after the pivot and all the elements which are smaller than pivot should come before the pivot so here 3 is the pivot so now we will check 9 is greater than pivot it comes here because as it is greater than 3 we know that all the elements which are greater than pivot will go after the pivot minus 3 is smaller than 3 it comes here 5 is greater than 3 it comes here 2 is lesser than 3 it comes here 6 is greater than 3 it comes here 8 comes here minus 6 comes here 1 comes here and 3 is the pivot so it is at this position so here you can see these are all the elements which are smaller than pivot and these are all the elements which are greater than pivot we are not concerned about the order of the elements here it is minus 3 then it is 2 then it is minus 6 so we are not concerned about the order here it is 9, 5, 6, 8 like this we are only concerned about the partitioning of this array in such a way that this is the left part which is smaller than pivot and this is the right part which is greater than pivot so why we are actually doing this partition here you can see I will just remove this so when we actually partition the array based on what we discussed here you can see that 3 was our pivot all the smaller elements are just before the pivot and all the greater elements are just after the pivot and it can be in any order but here you can see that after this partitioning one unique property with this pivot is let's say this is low index and this is high index and this is any jth element so after this partition in this array from low to j1 which is this portion is less than equal to array of j which is our pivot which is less than equal to j plus 1 to high like this so when we do this partition this holds true and if you see when we sort this array so this is the sorted array so the elements are arranged in ascending order but here you see that the difference between this partitioning and this sorted array is the pivot after the partitioning and after the sorting doesn't change its position it's actually at its correct position after the first partition so here if you see 3 was our pivot after partitioning came at index 4 and if we sort this array you will see that in the sorted array the pivot doesn't change its index it will still be at index 4 so this is one critical information about quicksort let it partitions the array and all the elements which are smaller than pivot comes to the left and all the elements which are greater than pivot comes to the right but this pivot after partition is actually at its correct position even after the array is sorted so this is the second step of quicksort the partitioning step moving ahead now here you saw does this pivot and this partitioning it is actually the divide part of the algorithm where we are actually reordering the array in the partitioning step and now how we will conquer this is based on this recursion step whatever we did above now we recursively apply the above steps on the sub array formed on the left side of the pivot and on the right side of the pivot so these two steps we will apply on all the elements which are lesser than pivot and on all the elements which are greater than pivot recursively so this step which we discussed that after this partitioning the pivot is at its correct sorted position we don't touch the pivot after the partitioning we take the left part of the pivot we take the right part of the pivot and we apply the above steps recursively on the left side and on the right side so here pivot in the sorted array is at its correct position like this but when we do the first partition this one particular element is sorted here you can see in the sorted array pivot doesn't change its position and it is at its correct position so we can think from the first partition we have sorted one element and now when we were discussing the recursion part the third step what we do is we take the left side of the partition we take the right side of the partition we leave the partition as it is at its correct position now we apply the same steps of choosing a pivot and then partitioning on the left side of the array and on the right side of the array so this we keep doing recursively till all the elements are at its correct position first partition gives one sorted element if we do this recursively with the left part and with the right part there will be a time that all the elements will be properly sorted and they will be at its correct position so the recursion step is important so these are the three important steps in quicksort pivot selection partitioning and then doing the recursion of these two steps on the left side of the pivot and on the right side of the pivot and when this recursion will end all the elements will be properly sorted and they will be at its correct position so this was the basic introduction of the quicksort at a high level in our next video we will see how we do this pivot selection and the partitioning and after that we will see that this recursion helps us in sorting the array, taking the help of these first two steps and applying them recursively so friends I hope you must have liked this video, in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss that what is quicksort partitioning in the part one of this video we discussed a basic introduction about quicksort so in this video we will be discussing what is quicksort partitioning so friends in our previous video we discussed that quicksort is a divide and conquer algorithm which basically involves three steps pivot selection partitioning and recursion in pivot selection we actually pick an element and mark it as pivot the pivot element can be the first element, last element or any random element from the array and the second step is the partitioning step where we reorder the array such that all the elements greater than pivot comes after the pivot and all the elements smaller than pivot comes before the pivot and the elements which are equal can go on either side of the pivot so usually in the partitioning step we actually get a left part and a right part and in the middle we have pivot so once the partitioning is done pivot is somewhere in the middle also we discussed that after this partitioning the pivot is at its correct sorted position so here you can see at whatever index pivot comes after the partition if we sort this complete array the pivot will lie at the same index only so it means after the partitioning one of the element is sorted so in the recursion step we apply this pivot selection and partitioning recursively in the left side and in the right side and we keep on doing that till the complete array is sorted so in this video we will see that how we do pivot selection and partitioning so let's say we are given with this array so here we can choose any element as our pivot but here we choose the last element as our pivot so 3 is the pivot and as we discussed in our previous video that after we partition and reorder the array in such a way that all the elements smaller than 3 comes before 3 and all the elements greater than 3 comes after the 3 so it would look something like this that this part is the left part and this is the right part and this is our pivot so if you see when this array will get sorted completely so this is the sorted array so here you will see get the pivot after the partition was at 4th index and once the array got sorted completely it was still at the same index because when we partition the array in such a way that this condition holds true which we discussed in our previous video as well after the partition the pivot is actually at its sorted position so now let's see how this partitioning happens so here is the algorithm to partition the array so friends before we start if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update also please like this video and watch it till the end so here you can see that let's suppose we are given with this array of 9 elements 9, minus 3, 5 2, 6, 8 minus 6, 1 and 3 so when we will call partition we are actually partitioning complete array it takes low and a high pointer so low actually starts from the 0th index and high starts from the last index because we need to partition the complete array so low starts from 0 and high starts from 8 so when we do partition of the array the first thing we need is the pivot so we can select the pivot as the first element last element or any of the random element in this array so here we will choose the last element as our pivot so array value at high index which is the 8th index will give us our pivot so pivot is 3 this value which is at array of high which is at array of high now after this pivot selection what we do is we reorder this array in such a way that all the elements smaller than pivot comes in the left part then comes the pivot and all the elements greater than pivot comes at the right part so this reordering is done by two variables i and j both are starting from low which is the starting index of our array or the starting range of the array from where we need to do the partitioning so i starts from low which is 0 index and j starts from the low which is 0 and j starts from low which is 0 index so friends now we actually traverse each and every element of this array and we provide a while loop where condition is i will traverse till it is less than equal to high so friends the basic idea behind this algorithm is why we are creating two pointers if you see closely then we have these four pointers so usually from low to j1 we actually have smaller elements and equal elements to pivot means all the smaller elements to pivot comes from low to j1 including the elements which are equal to pivot from j to i1 we will have all the greater elements to pivot elements to pivot and from i to high the elements are yet to be traversed so after every execution of while loop you can see these conditions and you can figure out that how this ranges works so at the start from i to high every element is yet to be traversed and low to j1 and j to i1 goes beyond the array so therefore there are no elements in these ranges currently i is less than equal to high so this condition is true now we are trying to explore the first element which is 9 so here what we do is in one of our previous videos we saw that 3 numbers sort or how we can sort 0 and 1 we apply the small part of the same logic here as well so what we do is this 9 which is at array of i and this 3 which is our pivot there can be 2 possibilities array of i can be less than equal to pivot or array of i can be greater than pivot so if array of i is greater than pivot it means whatever value we have here it is actually greater than pivot so here you can see we know that greater elements lies from the range j to i1 so when array of i is greater than pivot what we do is we simply move i by one step and if array of i is less than pivot we perform a swap between i and j and then we move j and i simultaneously so you will understand why we are doing this once we perform few of these iterations so at the start, array of i which is 9 is greater than pivot so this condition comes out to be false so if array of i is greater than pivot we simply traverse i ahead i becomes 1 and we reach to index 1 so you can see that why we actually traversed i one step ahead when pivot was lesser than array of i 9 was greater than 3 so greater elements should lie from j to i1 so here you can see j to i1 so this element so this is the only range which can help us to figure out that it has the greater elements to pivot you will understand more about these two ranges and these two points when we traverse ahead now i is less than equal to i so this condition is true array of i is minus 3 minus 3 is less than equal to pivot so this condition comes out to be true so when array of i is less than equal to pivot we simply swap the value with i and jth index so after we perform swap we will see why we are actually doing that so these three steps i will be going somewhat fast because we have already discussed how we can do this swapping so minus 3 will come here and 9 will come here now after this swap minus 3 has came here 9 has came here so here when array of i encounters a value lesser than pivot it simply throws it into this direction from low to j minus 1 we need to put the smaller and the equal elements to the pivot so how i can throw it in this direction is by swapping it with j and after we perform this swap we increment j and i both because this value is placed at its proper position that it is lesser than the pivot so now we will increment j also so j becomes 1 and as these two elements are already explored we will increment i as well i becomes 2 now our execution point reaches here and here you can see that from low to j minus 1 we have smaller and equal elements to pivot so from low to j minus 1 which is this element this range are the smaller elements to pivot from j to i minus 1 this element is in the range of the greater elements to pivot so what these two conditions are still holds good i is still less than or equal to high so this condition comes out to be true and the while loop will execute now 5 is greater than pivot so this condition comes out to be false and once this condition comes out to be false and once this condition comes out to be false we know that we need to simply traverse i ahead i becomes 3 so now here you can see this part is smaller elements range and this and these two elements 9 and 5 are greater than pivot so it is separated by j and i in such a way that from low to j minus 1 we have smaller elements from j to i minus 1 we have larger elements so therefore when array of i is greater than pivot we simply traverse i ahead we do nothing and when array of i is less than equal to pivot it means we have found one element lesser than pivot so we simply throw it to the starting range and we simply shift the larger element range i ahead so here initially 9 was here which was the larger or the greater elements to pivot when we did the swap 9 actually shifted in this direction so that there could be a place for the elements which are smaller than pivot to come in this direction so now similarly we will do this for the rest of the elements from i to high the elements are yet to be traversed currently i is less than equal to high so this condition comes out to be true 2 is less than equal to pivot so this condition is true so now here you can see we know that 2 should lie somewhere in this range at the starting range and j keeps the track of the smaller elements from low to j minus 1 so at j we have one greater element and we need to put 2 somewhere here so that this 2 comes at its proper position but here we already have 9 so therefore we do this swap so that 9 can come here and this range of the greater element is still maintained in the middle somewhere and it simply shifts in this direction so i will remove everything so now we will do this swap 2 will come here and 9 will come here 2 came here and 9 came here so the range of greater elements simply shifted in this direction because we need to create a space so that smaller elements can come in this direction we will increment j now we will increment i because this element which was here is actually being traversed so from low to j minus 1 we have smaller elements range from j to i minus 1 we have larger elements range or greater elements range i is still less than equal to high so this condition is true 6 is greater than pivot so this condition comes out to be false it means 6 is at its proper range we don't have to touch this we will do i plus plus so i simply moves ahead i becomes 5 now this element also got into the range of greater elements because from j to i minus 1 we have the greater elements to pivot i is still less than high so this condition is true so the while loop will execute now array of i which is 8 is greater than pivot so this condition is true therefore this condition comes out to be false and as array of i is greater than pivot we do nothing we simply traverse i i hit i becomes 6 and this element becomes part of our greater elements range from j to i minus 1 i is still less than equal to high this condition is true now minus 6 is less than 3 so therefore array of i is less than equal to pivot now we need to throw this pivot in the left direction and we know that j is actually keeping the track of that so this condition is true first we perform swap between i and j so that this minus 6 comes in this range and we simply shift one of the greater elements in this direction so we will perform this swap using a temp variable so minus 6 came here and 5 came here so after placing a smaller element at this spot we will increment j j becomes 3 because for the next smaller element this would be the right place so we increment j as well and as we have already traversed whatever the value was here at this index we will also increment i so i become 7 so here you can see this range from low to j1 we have smaller elements from j to i1 we have greater elements to pivot value of i is 7 so 7 is less than equal to i which is 8 now 1 is less than equal to 3 so this condition comes out to be true we need to throw this 1 because it is lesser than or equal to pivot in this direction so that it can come in this range we simply swap i and j so 1 came here and 9 came here so you can see when we are actually encountering a value lesser than pivot we are doing this swap and putting that at the starting range and whatever value j is pointing from j to i1 we have greater elements so at j we have 1 greater elements so we are simply shifting the range which is greater than the pivot just ahead so 9 came here but still if you see the ranges intact all the elements which are greater than pivot are in sequence the order will not be maintained but the range will be maintained so now after using this spot we will increment j j becomes 4 and we will increment i because this element is traversed and it got shifted here so we simply traverse i ahead i becomes 8 so here you can see from low to j1 this range is of smaller elements j to i1 this range is of greater elements now for the last time this while loop will execute i is equal to i so here you can see that now we are actually encountering the pivot itself and this is one critical step because we need to put this pivot at its correct position somewhere between the range of smaller and greater elements to pivot's range so this equal to condition does that and it is very important so currently array of i is equal to pivot so 3 is equal to 3 which is the pivot and we can place this 3 because smaller and equal elements to pivot will lie from low to j1 and j is at the spot which can take lesser or equal values to the pivot so 3 at index i will be swapped with j so 3 comes here which is our pivot and 6 comes here which is the value greater than to pivot so after placing an element which is less than equal to pivot at its correct position using j we will increment j so that next element can come here but as there are no elements but still we do this j++ so j becomes 5 and we will increment i because we are done with this element so i becomes 9 which goes out of the boundaries of this array so this condition comes out to be false because value of i is 8 and i is 9 so i is actually greater than i so this value will terminate and here you can see that in quickshot pivot partitioning when we do this partitioning at the end we need to return the index of the partition that from which index the partition is happened so here we can see that from low to j1 we have smaller and equal elements to pivot so i will redraw this low to j1 smaller and equal elements to pivot j to i1 so i value is 9 so j to i1 which is still 8 these are the elements greater than pivot and from i to i we have traversed all the elements so if you observe closely j is actually pointing to a place where the next smaller elements to pivot will come so we will simply return j1 because we know that from low to j1 we have elements smaller and equal to pivot so 3 comes here which is at index 4 so we will return the index of the pivot so in this partition whatever value we return is actually the index of the pivot after the partitioning which is j1 so index 4 will be returned this is how we do partitioning and this partition method is very frequently used in the quick sort similar kind of logic is used when we do sorting of 0 and 1 or putting e1 or odd integers in certain sequence or we sort the 3 elements 0, 1 and 2 so for 0 and 1 this code is pretty much similar so this partitioning logic which you are seeing here is very important for many of the algorithms and this traversal with this range is very important to understand because the same logic applies to many of the algorithms so we will see the partitioning logic how it applies to quick sort in our next video we will see that how this recursion happens where we apply the same logic of partitioning in the left side of the array which have smaller elements and the right side of the pivot which have the greater elements so friends I hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss about quick sort recursion in part 2 video of quick sort we discussed that how we can partition an array so in this video we will see that how we can perform quick sort recursion so in the previous video we discussed about the pivot selection that we pick an element and mark it as pivot the pivot can be any random element it can be first element, last element or any random element now based on what we choose as our pivot we do the partitioning we reorder the array such that all elements greater than pivot comes after the pivot all elements smaller than pivot comes before the pivot the elements equal to pivot can go on either side of the pivot and once this partitioning is done based on the reorder of the array, the pivot is actually at its correct sorted position so this we already discussed in our previous video so in this video we will be looking into the recursion part, where after partitioning the array we perform these two steps the pivot selection and partitioning recursively on the sub array formed on the left side of the pivot which has the smaller elements to pivot and on the sub array formed on the right side of the pivot which has the greater elements to pivot so here about two steps we perform recursively on the left side of the pivot and on the right side of the pivot so let's see at a high level how this recursion looks so let's see we want to sort this array using quicksort so here you can see that this is a small piece of code which does the sorting it takes in an array and it takes in a range that from which index to which index we need to do the sorting and here you can see that the first step we are doing is the partition step and once we get the partition index now we have two arrays one is on the left side of the partition and one is on the right side of the partition so we recursively call the sort method which is the same method from low to P1 which is the left part and from P plus 1 to high which is the right part and this happens recursively because the method is calling itself again and again after the partition we are actually rearranging the array in the partition method in such a way that the element present at the partition index which is the position of our pivot that element is correctly sorted and placed at its proper position so with one partition we can get one element and place that element at its correct position such that that particular element is sorted and we will keep on doing this recursion till low is less than high so this is our base case so at a high level let's see how this recursion looks in our next video we will see the step by step demonstration of this quick sort algorithm but for time being we can just see at a high level that how this recursion looks like so here at the start we need to sort this complete array so this will be our low and this will be our high now low is less than high we call the partition method so in the partition method we take the last element as our pivot like this so 3 is our pivot now after this partition method will end we get the index of the element 3 that where it belongs so in our previous video we saw that how we can perform this partition and we took the same example so in the first partition you will see that 3 comes at index 4 and in the partition the arrays rearrange in such a way that all the elements lesser than pivot comes on the left side all the elements greater than pivot comes on the right side so here we are doing the logical division of the array and we are partitioning into 2 parts left and right so we are not breaking the array its just for the demonstration purpose that it looks like this if you see the index from 0 to 3 we have smaller elements from 5 to 8 we have elements greater than the pivot so this is the pivot index now after we get the pivot index if we sort this array directly you will see that in the sorted array 3 will be always at index 4 it means when we perform this partition one of the element is sorted and it is placed at its correct position so once it is placed at its correct position we don't touch this element now what we do is we call the sort method on the left side recursively so it goes deep down like this and the range we took is low to p1 so p is the pivot and this is p1 so now we will call the sort by taking this left side only these 4 elements and this will happen recursively low should be less than high this should be our base case so here when this sort method will be executed for this left array you can see that this sort method will be executed again low will be the same but high will become p1 so this would be our high low is less than high now we will again call partition method we will pass in the array we will pass in low and high so now in the partition method only these 4 elements will be reordered because we are providing the range of low and high in the partition at the start low and high were the complete range of the array from 0 to 8 now this partition method will only partition 0 to 3 so in the partition method we will first choose the pivot element which we have discussed that we choose the last element now we need to do the reordering such that all the elements lesser than 1 should come on the one side and all elements greater than one should come on the other side so here we will see that the partition method will reorder the array in such a way that it looks like this this much part are the elements which are lesser than pivot and this much part are the elements which are greater than pivot which is 1 but here we will see the index which we get is 2 because it returns the final position of the pivot so index 2 will return here in the first partition index 4 was written so based on this p1 we took the left side of the array and we did the partition again so now here if you see if we sort this array completely you will find that 3 is at 4th index which is sorted and after the second partition 1 will be at 2nd index so this element is also sorted so now we don't touch 1 here if you see we again go on the left side from low so this was our low and this is our p and this is our high so we again call sort method from low to p1 which is we are taking the left side of the array so when this sort method will be called again low will be at the same spot but high will become this spot so it means now we are actually picking up this 2 elements and we are trying to sort them and we are trying to apply this logic so this will be our low and this will be our high low is less than high so it means we have 2 elements so we can again do the partitioning of the array from low to high so in the partition method we will take the last element as our pivot and now we will partition the array in such a way that all the elements lesser than minus 6 will go on the left side and all the elements greater than minus 6 will go on the right side so this partition method will reorder only these 2 elements now because we are providing the ranges and it will touch the array into these ranges only so it looks like this so as there are no elements which are smaller than minus 6 so minus 6 will be the only element on the left side which is at index 0 and minus 3 is greater than minus 6 so this will lie on the right side so from here you can see that now this is our low and this is our pivot index so after we get the pivot index we will again call sort on this one element we will try to sort its left part from p minus 1 so p is at 0 index if we do p minus 1 it will go minus 1 so here if you see when we partition the array pivot was at 0th index it is the only element now so on the left side of pivot we have no elements so if we call sort method again passing in low as 0 and high as p minus 1 so it will take the value of the new high as minus 1 so here we will reach the base case and we will simply return from this method because low value is 0 and high value is minus 1 so therefore we can't further divide minus 6 and at whichever index minus 6 will be there that will be the properly sorted position for the element minus 6 so now this method is done because when we call sort again we will reach this base case and we will return so this method will be done so now this sort method will be executed and we go to the right side of the pivot it means now we are taking in the elements which are greater than minus 6 which is the only element minus 3 so p plus 1 p plus 1 will be our new low this will be our low and high will remain the same index so here if you see we will again encounter the base case low is actually equal to high so it means we can't divide from low to high further down so based on this base case this sort method will end and the call will reach here again and the sort method which we call from here this will also get end so minus 3 will be also at its correct sorted position like this so here with these two sort methods we are going in this direction and then we are going in this direction so with this sort we went to this direction this is sorted and with this sort we went to this direction which is sorted so we will return back to the left side and here you can see when we will return back here when we had called sort on this part we went in this direction and as we are returning back from here so we will return from here like this and now when these two elements are sorted we will go in this direction to sort the greater elements to this pivot because we are doing this algorithm recursively so first the left side is done and once that left side is done we go on the right side so this side is done completely here now we go on this side so here 2 is the only element left so this will be sorted because the base case will be fulfilled for this element low and high will be at the same spot because this is our P and if we are going on the right side we do P plus 1 so P plus 1 will be the index 3 which will be our low and high is already at index 3 so this is sorted like this so now execution point will reach back here and here you can see left side is now properly done so it will go back here and now we perform the same steps recursively on the right side of the elements which are greater than 3 which is our index 4 so now we perform the same step on this right side so if we are going on the right side we are doing P plus 1 we are going on the right side the low will be from P plus 1 to high so this is P this will be our low and this will be our high because this high has not changed its value so now we will partition it again based on what we saw here so 6 will be our pivot and now when we will partition it it would look something like this so 6 is properly sorted now we go on the left side first so 5 is the only element left so it will encounter the base case this is our P and this is our low so for the left side if we do P minus 1 to take all the elements which are lesser than 6 this will become our high and as high is equal to low we will return from the recursion and 5 will be at its correct position so we go back like this and then we try to sort the right side so we call the recursion again by taking P plus 1 to high so this was high like this and if we do P plus 1 this will be our low now so now we are actually partitioning two elements so we take 9 as the pivot we do the partition so our pivot lies at the 8th index there is only 1 an event which is lesser than pivot which is on the left side of the array and there are no elements which are greater than pivot so after the partition at whichever position the pivot lies this is the properly sorted position for element 9 and we are left with only one element so if we first go on the left side like this we take from low to P minus 1 because if we do P minus 1 we will get the left side range so this will become our new high and as this is the only element left low is equal to high so we can't divide or partition this piece of subarray further so 8 will be also at its correct position like this so if I remove everything so here you can see that we are performing the recursion on this array recursively and we are doing the partitioning and with each partition 1 1 element is getting sorted in place at its correct position so if you try to combine all these indexes you will see that if we sort this array, the array would look like if I just plot it here it will look like first minus 6 minus 3 then 1 2 3 5 6 8 and 9 so if you see that this would be our finally sorted array and if you see the indexes of all the elements from 0 to 8 you will see that at 0 we have minus 6 like this at index 1 we have minus 3 sorted index 2 we have 1 at index 3 we have 2 index 4 we have 3 at the 5th index we have 5 6th index 6 7th index we have 8 and at the 8th index we have 9 so here you can see that how this recursion and this partitioning is helping us to perform the quick sort so friends here if you see at the start we took complete array we took a pivot we did the partitioning all the elements lesser than pivot were on this side and all the elements greater than pivot were on this side then we recursion we took the left part we took the pivot and we did the same steps like this then we took the left part again we did the same step and finally we got minus 6 and minus 3 at 0 and 1 index which are sorted this left and right part and sorting them this left part was done properly then we picked the right part of this pivot and this was sorted and after we sorted this all the elements were done for the first left sub array then we went to the right part and we did the same steps again we first went on left then we went on the right we first went on the left then we went on the right and at the end you see all the elements are at their proper indexes so if we sort this array you will get this array so friends this was all about the quicksort recursion if you didn't understand any of the recursion logic here in our next video we are going to see the step by step demonstration of the quicksort algorithm there it will make sense that how this recursion is happening where this sort method is again calling this sort method two times after partitioning we go on the left side first and then we go on the right side so we will understand this recursion in our next video with a detailed demonstration I hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day so this is the quicksort algorithm and we will see the step by step demonstration of the algorithm so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so in quicksort algorithm we have this sort method which takes in an array which you want to sort and we pass basically a range that from low to high we need to sort so at the start let's say we want to sort this array having six elements five, two, zero one, six, three so when we will call sort method we will pass in the array the low will be zero and high will be array.length minus one which is the last index so low is zero which is pointing to zero index high is five which is pointing to the last index so we are telling that we need to sort this array completely from zero index to fifth index and here you can see that this sort method is recursively calling this sort method again here and here so in order to demonstrate the recursion we are using this call stack which will have the method calls and the state of the method stored in low, p and high so when this sort method will be called there will be one method on the call stack by name sort low is at zero index high is at fifth index and p is the index of the pivot which we will be calculating here moving ahead so here we know that quicksort is divide and conquer algorithm so here we actually divide this complex problem of sorting into smaller sub problems which means that we are dividing this array into two parts and we keep on dividing the array into this recursive sort methods based on range low and high so when low will be equal to high or low will be greater than high when low will be equal to high so it will be something like this that low is equal to high, it means we can't further break down the array because it has only one element so therefore when this condition will arrive we need to simply break from this recursion because this sort method is recursively calling this sort and it keeps on going so when low will be equal to high or greater than high then we need to tell recursion that we have reached our base case and we need to stop the recursion so currently low is less than high low is zero and high is five so this condition comes out to be true so friends in our previous video we discussed that how we actually do the quicksort we first do the pivot selection where we pick up a random element from an array and then we actually partition the array in such a way that the elements which are smaller than the pivot usually lie on the left side and the elements which are greater than pivot usually lie on the right side and the equal elements can go on either side so here this is the first step we actually call the partition method we pass the array we pass the range from low to high so currently we are telling that we need to partition this complete array and in this partition method we actually do the pivot selection and reordering of the array so this method we have discussed in our previous videos in a greater detail you can watch that video to get more understanding but here also we will see that how this partition works so when we will call partition method we are leaving this sort method so the execution point will leave the sort method and the partition method will be on the call stack so before we leave this sort method we need to store the state of this sort method that low was at zero and high was at fifth index and as we are leaving this sort method we need to keep the track of line number because once this partition method will end we need to begin this sort method from line number three only because we are leaving this sort method at line number three so here we will update the line number three like this which tells that we are leaving this sort method at line number three and when we will come back to this sort method we will start our execution from line number three and when we will start our execution low will be at zero and high will be at five so we are simply storing the state here so now we will see this partition method with this array low as zero and high as five so we are partitioning this complete array we have discussed this method in greater detail in our previous videos you can watch that video so that once we go through it again you will get more better understanding so first we do the pivot selection we can choose any random element from the array as our pivot we can choose the first element or any element in the middle or the last element so here we choose the last element as our pivot which is denoted by the end of this range so pivot becomes array of high which is three so this is our pivot and after this pivot selection our job is to do this partition elements lesser than three will go on one side which is on the left side elements greater than three will go on the right side and the elements which are equal to pivot can go on either side so when we perform the partition we take the help of two variables i and j here i and j both starts from low currently low is pointing to zero index so we are not starting i and j from zeroth index we always start it from the low index because currently as we are partitioning complete array pointing to zero there could be a chance that we only need to partition these three elements so at that moment low will be at third index so we need to partition of third index to fifth index so therefore we create two pointers i and j both starting from low i is zero because low is pointing to zero j is zero now as we need to partition we need to provide a while loop where we traverse each and every element of the array using the iterator i it goes till it is less than equal to high so this is very important algorithm and it is used in many problems here what we do is we have these four pointers and once we partition the array it looks something like this smaller and equal elements to pivot are on the left side then we have the pivot and then we have the elements greater than pivot so this is the ranges and if we use these four pointers the range varies like this from low to j1 we have smaller elements or equal elements to pivot from j to i1 we have the elements greater than pivot and we have discussed this in greater detail in our previous videos as well from high to high we have elements yet to be traversed so at the start we need to traverse every element so from low to j1 and from j to i1 we don't have any elements because all the elements are yet to be traversed therefore we have provided this condition that this while loop will run till i is less than equal to high so we will see how this algorithm works and also we need to keep this if condition in mind so here when we are partitioning we need to compare each and every element with the pivot and if it is less than pivot the first thing we do is we simply swap the values at i and jth index in the array because as this element is less than equal to pivot it should come at the starting range because we need to partition it that way so we will see how this three steps work and if the element is greater than pivot we do nothing we simply leave the element there and we traverse i ahead so this condition is true i is less than equal to high so in the if condition we check whether array of i is less than equal to pivot or not so we are simply checking whether 5 is less than 3 or not so 5 is greater than 3 so this condition comes out to be false so when array of i is greater than pivot which is our case we simply leave that element there and simply traverse i ahead so i becomes 1 i is still less than equal to high now array of i which is 2 2 is less than 3 so this condition comes out to be true and once this condition comes out to be true we know that we need to swap the values at i and jth index it means we need to swap 5 and 2 so here why we are doing this swap is we need to partition the array in such a way that smaller element should come at the starting range then our pivot should come and then the element greater than pivot should come so when array of i is less than equal to pivot we simply throw the element which is at ith index to jth index and take its value so when we will do this swap i will go over these steps quickly 5 will come here and 2 will go there so 2 came here and 5 came here and we know that now we need to increment j and i both so why we are incrementing j is because j has placed one of the smaller elements here so this space is occupied so j moves ahead so j moves ahead j becomes 1 and we will simply traverse i also ahead because this element is also explored so i becomes 2 so friends one thing to note here is irrespective of any of this condition is met we simply traverse i ahead in both the cases so therefore it is written here now i is less than equal to i array of i which is 0 it is less than 3 so this condition comes out to be true so we need to throw 0 to j and take its value by doing this swap so 0 goes here and 5 comes here so friends here you can see that as 5 is greater than pivot the elements which are greater than pivot they are actually shifting in this direction but the elements which are lesser than pivot we are simply throwing it to j to put it at that particular index and j actually holds one of the greater elements to pivot because from j to i1 we have the elements greater than pivot so j is actually pointing to one of the greater elements than pivot and once this swap is done we are simply taking a greater element and shifting it ahead and by doing this swap we are creating one space here so that the elements which are lesser than pivot can come here so therefore we do the swap we throw whatever the element is at the ith index to j and take its value so this spot is filled now properly so we will increment j so j becomes true we will increment i i becomes 3 this condition is still true i is less than equal to i 1 is less than 3 so this condition is true so we perform these steps again so we are performing this swap using the stem variable so 5 comes here and 1 goes there and after filling this position with a value smaller than pivot we move j ahead so j becomes 3 and we have explored the array till this point so we move i also ahead i becomes 4 so friends here you need to keep watch on these two ranges from low to j minus 1 we have the elements smaller than pivot which is true from j to i1 we have elements greater than pivot so this is j i1 so 5 is actually greater than pivot so this both the conditions are true when we are doing these steps now i is still less than equal to i so this while loop will execute array of i which is 6 is actually greater than pivot so this condition comes out to be false so when array of i is greater than pivot we know that this element is greater than pivot and it is at its proper position so we don't touch this element we simply move i ahead like this so still you can see from j to i1 we have elements greater than pivot so therefore when we encounter a value greater than pivot we simply move ahead and when we encounter a value lesser than or equal to pivot we simply throw it into this direction so that we can perform a swap between i and j now i is actually equal to i so this loop will run one more time and now here you can see our pivot and array of i are the same elements so why we are running it one more time is because smaller than or equal to pivot so we have got a value equal to pivot so we need to make it lie in the range of low to j1 so j is holding a value greater than pivot so we do this swap here so 5 comes here and 3 goes there so it means our pivot has landed into its correct position then we will increment j j becomes 4 and we will increment i i becomes 6 so as i has become 6 this value will terminate because value of i is 5 so from this partition method does two things first it returns the index of the pivot which is j1 which is 3 and second it takes in the original array and reorders it in such a way that all the elements smaller than pivot are on the left side and all the elements greater than pivot are on the other side so when this method will end we will return j1 which is the index of this pivot from where this partition has happened so the execution point will reach to this sort method and the array has been reordered we have left this sort method at line number 3 so we will start from line number 3 this partition method has written a value of p which is the index of pivot which was 3 so value of p will be 3 like this here so this is what we saw in the partition that all elements smaller than pivot are on this side and greater than pivot are on this side so friends here you can see that if i sort this array directly the sorted array would look like 0, 1, 2, 3, 5 and 6 and here you can see that once this partition is done when we are putting all the smaller elements before the pivot and all the greater elements after the pivot so when we sort this array completely you can see that the index of the pivot remains the same 3 is at index 3 and after sort also it will be at the index 3 because here it's 0, 1, 2, 3, 4, 5 index so it remains at the 3rd index only so this is one important step in the partitioning that after the partition pivot is actually at its sorted position so now what we do is we don't touch this pivot because it lies at its proper sorted position now our task is to perform this pivot selection and partitioning on the left side of the pivot and on the right side of the pivot and dead to recursively so this sort method will keep on calling itself till the base case is reached so now we call the sort method again and this time we only take these 3 elements and we try to sort them so here we are calling this sort method we are passing in this array low value will be 0 only high value will become p1 because we are calling this sort method with p1 it means we are taking in this range this is p so this will be p1 so when this sort method will again gets called our high will become p1 so as we are leaving this sort method and we are calling this sort method so first we will update the line number here and we are storing the state of the low, p and high so we update line number 4 here and we leave this sort method and again call the sort method so this sort method will be called with low as 0 and high as p1 so this was our p previously p1 which is 2 so here now we are doing the sort from low to p1 so this is the range of our array which we need to sort now so high becomes 2 p1 which is 2 so our new high becomes 2 low is less than high so now we will partition only the left side of the pivot which is these 3 elements so we will leave at line number 3 this sort method so this partition method will be executed again and now we are not taking in complete array we are taking the array from range low to high which is 0 to 2 index like this so this partition method will only touch these 3 elements so first we select the pivot which is the last element of this range so array of high will become our pivot so 1 becomes our pivot we start the partitioning with a value of i and j low which is 0 and as we have already discussed how this algorithm works we will go over this quickly we need to keep these ranges into mind and these 2 conditions into mind so i is less than equal to high this value will execute array of i which is 2 it is greater than pivot so we do nothing, we simply move ahead we do i++ i becomes 1 i is still less than high now array of i which is 0 it is less than equal to pivot it means we need to throw it to j and take its value so we do this why i swap so 2 comes here and 0 goes there so 0 goes there and as j is filled this position properly we will increment j j becomes 1 we will also increment i i becomes 2 i is actually equal to i so this loop will run one more time to put this i is actually equal to i so this loop will run one more time to put this pivot at its correct position now 1 is equal to pivot so we do this swap again so 2 comes here and 1 goes there then we increment j j becomes 2 and we increment i so i becomes 3 and this while loop will terminate because value of i is 2 and j is 3 so 3 is not less than equal to 2 so here you can see that now we need to return the index of the pivot which is at j1 which is this and here you can see that when we did partition of these 3 elements these are actually elements which are lesser than pivot which is 1 and these are the elements which are greater than pivot which is 2 so currently it has only 1 1 element so we have reordered the array and we are returning the pivot as 1 so execution point will reach here we know that we have left at line number 3 so we start from here this method returned the value of pivot as 1 so p becomes 1 like this so friends we know that after doing this partition we recursively call the sort method again and this time we go from low to p1 which is the left side and then we go from p plus 1 to high which is on the right side so first we go on the left side so here you can see this recursion is happening till the array is getting divided so now when we will leave this sort method we will first update the line number here which is 4 and then we will call this sort method where low will be 0 and the value of high we pass is p1 so p1 minus 1 will be 0 so this value will go to high and this value will go to low in the next sort method so we have updated the line number and we have called this sort method again so it looks like this that this low which was 0 is 0 p1 which is 0 index so high becomes 0 so it looks like this so friends here you can see now low and high are pointing to the same index it means that we have left with only one element and we can't divide this array further down or partition this array further down because we have only left with one element so therefore we have reached our base case so low is equal to high so this sort method will end and this sort method will be removed from the call stack and the execution point will reach here back so it looks like this this method was removed from the call stack and execution point reached here we know that we left this sort method at line number 4 so we start from line number 4 and when we had left this sort method low was at 0 p was at 1 high was at 2 so we position them back to their respective indexes high was at 2 p was at 1 and here you can see that we are done with this left part now so this sort method is done and now we go on the right side so we call this sort method again now this time we are passing the value of low as p plus 1 so p is 1 and p plus 1 is 2 so when we go on the right side the value of low changes and when we go on the left side the value of high changes here you can see if we are going on the left value of high changes if we are going on the right value of low changes so now we will leave this sort method we first update the line number here that we are leaving at line number 5 and we are calling this sort method with p plus 1 as our low which is 2 and high as 2 so there will be one more method on the call stack with low as 2 and high as 2 so something like this moving ahead here you can see that now we are actually partitioning the elements which are greater than pivot which is only this element 2 which is only one element as low is equal to high it means we have reached our base case and we are telling to this sort method that please stop the recursion so this method will be removed from the call stack because we can't divide 2 further down and the execution point will reach here so when this sort method was left we are left at line number 5 so we start from line number 5 and at that moment value of low, p and high as 0, 1 and 2 so we give them their respective indexes so it was like this and now after executing line number 5 there are no more lines left to be traversed so this sort method will also end and the execution point will reach to this sort method because this sort method was actually being called by this sort method so this method will be removed from the call stack and when we had left this sort method we had left at line number 4 so we start from line number 4 and at that moment value of low was 0 p was 3 and high was 5 so we give them their respective indexes so this was the state when we had left this sort method so here this sort method is done it means so it means that when we had done our first partition the pivot came out to be index 3 and in this sort method we went to the left side of the pivot and we did the sorting and here you can see these 3 elements are sorted so we had done with this method now our task is to go on the right side call sort method again recursively we pass the value of low as p plus 1 because we need to now go in this direction and high remains the same so here we are leaving this sort method we will update line number here which is 5 and we are calling this sort method passing in low value as p plus 1 which is 4 so it looks like this low becomes p plus 1 which is 4 so it looks like this low is less than high it means we have 2 elements it means we can divide this 2 elements further down so we call the partition method again we pass in the range from low to high we are telling we need to partition the array of these 2 elements only so this is our range so when we are calling this partition method we first update the line number here and we have stored the state already in low and high so line number 3 comes here we leave this sort method we call this partition we need to partition from low to high that is in this range we are not touching this side because we have already done the sorting and partitioning of these elements so we are now only touching these 2 elements array of high will be our pivot so first we are doing the pivot selection so 5 becomes our pivot we create 2 pointers i and j which start from 4th and next and then we perform the same step which we have discussed already we provide a while loop and the condition is i should be less than equal to high we need to keep 4 things in mind these 2 ranges and these 2 conditions so array of i which is 6 it is greater than pivot so we simply traverse ahead we do nothing we do i++ i becomes 5 i is equal to high so this condition is true now array of i is 5 and 5 is our pivot as well so therefore when array of i is equal to pivot we need to throw whatever value is at ith index to j and take its value so we first perform the swap so 6 comes here and 5 goes there we have placed 5 at its correct position which is our pivot position so we increment j and then we increment i so now this while loop condition comes out to be false because value of i is 6 and high is 5 so we simply return the pivot index which is at j1 so j1 which is the 4th index so we return 4 from this partition method and we have also reordered the array in such a way that all the elements lesser than pivot are on its left side so currently there are no elements which are lesser than pivot because we are not touching this side we are touching from low and high so from low to j1 low to j1 we have elements smaller than or equal to pivot which is true and from j to i which is 6 minus 1 which is only this element having a value greater than pivot so we simply return index 4 from here so the execution point will reach here we had left this sort method at line number 3 so we start it from line number 3 the partition method return the value as 4 we have placed 4 here so p becomes 4 now we go on the left side of the pivot from low to p1 so here you can see low and p are pointing to the same element so when we call this sort method we first update the line number which is 4 and then there will be one sort method on the call stack so here when we had left this sort method we called this sort method from low to p1 so when we did p1 our high became 3 so here you can see that low is actually greater than 3 so it means we have reached our base case and which makes sense because there are no elements on the left side of the pivot to be divided further down so we simply return from this method and the execution point will reach here we had left at line number 4 so we start from line number 4 and low p and 5 had values as 4, 4, 5 so we give them their respective values 4, 4 and 5 and now we go on the right side of the pivot which is at p plus 1 to high so p plus 1 is index 5 so first we update the line number here because we are leaving this sort method and then we are calling sort so there will be one more method on the call stack with p plus 1 as our new low which is 5 and high remains 5 only so it looks like this so here we can't divide this 6 further down it means we have reached our base case low is actually equal to high so this if block will not be executed so the condition in if block comes out to be false and we simply leave this method so this method will be removed from the call stack and the execution point will reach here we had left this sort method at line number 5 so we start from line number 5 and at that moment low p and high were at 4 4 and 5th index so we reassign them their indexes like this and as there are no more steps left to traverse for this sort method so this sort method will also be removed from the call stack and the execution point will reach here so when we had left this sort method we had left at line number 5 so we start from line number 5 and at that moment low p and high were at 0 3 and 5th index like this and also friend zero can see that after line number 5 we have no statement to execute so this sort method will also be removed from the call stack so friend zero can see after every method got removed from the call stack we have actually performed the sorting of the array we have used the quick sort and we have sorted the array so friend this was all about the step by step demonstration of quick sort algorithm where this sort method recursively calls this sort method one is when it goes on the left side of the pivot which is the smaller elements and one when it goes on the right side of the pivot which are the greater elements to pivot in this partition method we do the pivot selection and reordering of the array in such a way that smaller or equal elements are on the left side then our pivot comes and then the elements greater than pivot comes so this steps we do recursively till all the elements are sorted so friend this was all about quick sort algorithm I hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we will be discussing a coding problem squares of a sorted array in java so if you see in this problem we are given an integer array which is sorted in ascending order so here you can see this is the input minus four minus one zero three and ten so it's sorted in ascending order now what we need to do is we need to return an array of integers such that we need to square them and whatever is the outcome we need to simply return that array so for example the output would be zero one nine sixteen and hundred so how this output came is after squaring each and every number you will see the array will become minus four into minus four will give us sixteen minus one into minus one will give one zero into zero will give zero three into three will give nine ten into ten will give hundred so this is the array which will be generated after we square each and every element now the complexity part is we need to sort this array and return from the method so after we sort this part it will become zero one nine sixteen hundred so friends the brute force approach would be we simply square the array so it will become like this sixteen one zero nine hundred and then we again use arrays dot sort we pass in the array and we get this result array but this is a brute force approach which is not very efficient so if you see at the last time if we sort the array the time complexity will be n log n so which is not good we need to see that whether can we do it in o of n because this operations are constant and if we iterate each and every element once we get o of n time complexity so let's see the algorithm and its demonstration step by step so here is the algorithm so here you can see it is only taking one for loop and we are not sorting the array anywhere so let's see the demonstration of this algorithm step by step but before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so we will call this method we pass in the array so let's say if we take this array minus four minus one zero three and ten so the length of the array is five so at the start we simply calculate the length of the array by doing array.length and we store it in integer variable n so n will become five now as you want to square each and every element and return this array all together in a sorted form we will first create our result array so this result array will store all these elements squares in sorted form so we will create this new array we pass in the length as five so it will look something like this so these are the default values of the integer array so here the idea is we take two pointers i and j so i will start from zero and j will start from n minus one which is the last index so it would look something like this that i is pointing to zero index and j is pointing to the last index which is four so here if you see when we do the squares of any negative number we usually get the result in positive side of the numbers so therefore this problem becomes complex because if suppose our array had only positive numbers then this problem would have been straight forward we just do the squares and as the array is already sorted the squares would have been in sorted form but here as we are including these negative numbers here you can see three is greater than minus four but if we take the squares of both the numbers minus four into minus four we will get sixteen and three into three we will get nine so before doing squares minus four is less than three but after doing square this number sixteen is actually getting greater than nine so it means when we will return the result of the squares in sorted form this minus four square will come after three squares because nine will come before sixteen this algorithm becomes very tricky to find the exact position of these negative numbers among the positive numbers so what we do is we try to fill this result array from the end so here we create a for loop where k starts from n minus one so k is starting from four because value of n is five so it means we will try to fill this result array from the last why we are doing it from the last because this is the extreme point where we are sure that what value will come so for example this array sorted so here will be the smallest number and can be negative and here will be the largest number so if we do square of these both numbers and we try to compare them we will get one value for sure which will be greater than overall all the numbers squares and we can simply put it here so let's say for example if we take minus four and ten so minus four into minus four will give sixteen ten into ten will give hundred so if we compare sixteen with hundred we are very much sure that hundred is greater than sixteen and any number in the array will get bigger than hundred because we are actually comparing the extremities of this array so here let's say if it would have been minus eleven if we would have done the square we would have got one twenty one and ten square is hundred so we are very much sure that if we are comparing the extremities we will get a square which will be the largest among all the numbers and we can safely put it in the last index so this idea will be more clear when we will actually see the demonstration of this algorithm so I will just remove this so here k's value is four and it is greater than or equal to zero so this condition is true so here you can see why we created these two pointers and we pointed at the extremities because as the array is sorted in ascending order the element square won't be necessarily sorted in ascending order so here what we do is we take the absolute value of the value at ith index and the absolute value at the jth index so what this absolute method returns is let's say if the value is minus four it will give us four let's say if the value is minus one let's say if the value is ten it will give us ten so it gives the absolute value without the sign of it so here we are actually comparing the numbers without their sign and why we are doing it because this negative sign when we do square this becomes minus into minus becomes positive and we actually do the square of the number which will give us sixteen so it's plus sixteen so this minus doesn't play any role in the square part but as these numbers are sorted and we can encounter negative values as well so therefore we are comparing the absolute values of the start and the end so here if you see the mat.absolute value of i will be four and j will be ten is not greater than ten so this condition comes out to be false so the else part will be executed so this actually signifies that we can safely take ten do its square and place it into the end of the result array because we are very much sure that this value can be safely placed here because we have compared it with the extreme left value so here we do ten into ten which is hundred and we simply put it into the result array at kth index now after placing it we know that we have used this value so we will simply decrement j so j becomes three now we will simply decrement k because we have used this place and k is still greater than or equal to zero so friends here you can see the importance of doing mat.absolute we are actually discarding this negative signs and as the array sorted we are comparing the extremities of i and jth index and whichever will be the greater number that square will come directly here so here mat.absolute of array of i will be four and mat.absolute of array of j will be three only so four is greater than three so this condition comes out to be true so we simply assign the square of this value minus four into the result array at kth index so minus four into minus four will give us sixteen so we will simply assign sixteen here and as we have used this minus four will increment i so i will point to index one we will decrement k because we have used this spot k is greater than or equal to zero now we will do mat.absolute of minus one which will give us one and mat.absolute of three which will give us three so this condition comes out to be false because one is not greater than three so we can safely put three's square here which will be nine we have used this spot so we will decrement j now so j becomes two we will decrement k because we have filled this spot k becomes one and one is greater than or equal to zero now we do mat.absolute of minus one which will give us one and mat.absolute of zero which will give us zero so one is greater than zero so this condition comes out to be true and what we do is we simply assign minus one into minus one which is one into this spot we have used this spot so we will increment i i becomes two we will decrement k because we have used this spot so k is equal to zero so this condition still comes out to be true and here we are left with only one element so zero is not greater than zero because mat.absolute value of zero is zero so this iflock condition comes out to be false and we simply assign zero into zero which is zero to this spot so it becomes zero now we have used this spot so we will decrease j so j becomes one which we will point here we will decrement k because we have used this spot so k becomes minus one it means it has gone outside of the boundaries of the array therefore this condition will come out to be false and here you can see at the end we will simply return the result so this is the result where we have squared each number and after squaring each number you can see the result array is still sorted and we have used this algorithm without using arrays.sort so the time complexity of this algorithm is O of n so we will simply return the result so friends I hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw a problem squares of a sorted array we saw the animation of the algorithm step by step so in this video we will actually code the algorithm and we will test its working in the main method so before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here in our array util class I will be creating one method as public static we will give a name to this method as sorted squares so this method will take in an array and what this method will do is it will do the square of each and every element of the array and whatever the array it will return that array will also be sorted and this array is already sorted so in our animation video we saw that we can solve this problem using two pointer technique so here first we will create an integer variable n this will store the length of the array then we will create one pointer i which will start from the zero index and one pointer j which will start from the last index so the last index will point to array.length minus one now as we want to return a sorted array so we will create a result array the size will be the same as our input array now here what we will do is we will provide a for loop and inside that for loop we will try to fill this result array from the end so here we will start from k equals to n minus one because n minus one is the last index and it will go to when k is greater than or equal to zero k minus minus so from k and minus one it will go to zero and with each iteration it will get decrement by one position so friends here you can see that this array is actually sorted array so if i take this example so here you can see that this array can contain negative values so if the array contain only positive values this problem would have been very easy we would have just done the square of each and every number and simply place it into the result array at their respective indexes but as this array contains the negative elements also so here for example let's say it was given something like this so we can't directly do the square of each and every number and put it into the respective position because this will result something like this minus four into minus four will give sixteen minus one into minus one will give one zero into zero will give zero and three into three will give nine so here you can see we can't directly just square the numbers and put it into the respective position because this array is not sorted and we want to return the sorted array so one thing is we just square and at the end we just do the sorting explicitly and return but that would be a very bad algorithm time complexity wise because we are actually using the sorting technique so in this algorithm using this for loop we will try to sort this array properly so that it would look something like this that zero should come here then one then nine and then sixteen so usually in order to do that what we can do is we try to compare the absolute extreme values so whichever value is greater we do their square and we simply put it into the last index and similarly we go on doing like this so for example if we do the absolute value of minus four we will get four and we see that four is greater than three so it means if we do four into four or minus four into minus four we will get sixteen and we can safely place sixteen at the end and after filling this position we just come to this position and after using this minus four we just shift here so in the next iteration we simply compare the absolute value of minus one which will give us one and we will compare one with three and we see that three is greater than one so we simply do three square and we put nine at this position and similarly we keep on doing like this so here the main idea is to take the absolute values of the extreme values try to compare them and whichever is the greater do their square and put it into the result array at the index which is starting from the last index which is n minus one so here we provide a condition as if math dot absolute of array of i so we have created these two pointers one would be at the start and other would be at the end if it is greater than math dot absolute array of j so what we can do is if the absolute value of ith index is greater than absolute value of jth index then in our result at kth index we will assign array of i into array of i so we are doing the square of this number and we are assigning it to the result array after doing that we know that we have used for example we have used this position of the i so we simply increment i because we need to now take another value because we are done with this value let's say for example and else then we can simply assign array of j into array of j and as we are assigning array of j and it is basically starting from the last index so it signifies that we have used this value for example and now we need to go one step before to it so what we do is we do jminus and after the first iteration of for loop in our result array let's suppose if we take this example sixteen got occupied at this place so we are doing kminus because now we need to fill this position we have filled this position now we need to fill this and with each iteration we will fill oneone position and at the end we will simply return the result so from this is the algorithm now we will test it's working in the main method so here I will be using this array which we discussed in our slide as well here we will get the result array we will call sorted squares we pass in the array and at the end we will simply print the array and if I run the main method so here you can see that we got the answer at zero, one, nine, sixteen, hundred so this zero came from this zero this one came from minus one nine came from three sixteen came from minus four and hundred came from ten and how it came we simply squared them and using this for loop we actually placed them at their respective position so that the final array is also sorted so friends I hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss a problem rearrange sorted array in max min form so lets see what this problem is and how to solve this so in this problem we are given a sorted array of integers in ascending order now we need to rearrange the array in such a way that the first position will have the largest number which is the right most number the second will have the smallest second will have the smallest which is the first number the third will have the second largest so the 3rd number will be second largest and it will go on so the 4th number will be 2nd smallest and here it will be 3rd largest 3rd smallest and then 4th those so the 1st constraint is that we can't create a new array and do this rearrangement. We need to solve this problem in O of 1 extra space. So here if we create a new array of same size which would be our result array, then this problem becomes simple because then we can create one pointer here and one pointer here and we can alternatively put the elements in the array and return. So the space complexity of the problem will become O of n because we are creating a new array and then we are putting the elements in maximum form. So if we are using O of 1 extra space, it means we need to modify the same array and return it back. So let's see how we can solve this problem in O of 1 extra space. Let's suppose we are given with this array which is sorted 2, 3, 5, 6, 8, 9 and our output array will become like this 9, 2, 8, 3, 6, 5. So 9 is the largest, 2 is the smallest, 8 is the second largest, 3 is the second smallest and so on. So as the array is sorted, we know that we can get the largest element. If we start from this index which is the max index, so this pointer max index will help us in giving the largest, then second largest, then third largest and so on. And the smallest elements will be given by min index. So here both these pointers will help us in giving largest and smallest numbers, second largest and second smallest number. So min index will travel in this direction and max index will travel in this direction. And here we will have iterator i which will travel 1 1 element in this direction because we have to solve this problem in O of 1 extra space, we can't create a new array and simply put the elements in alternate fashion. So somehow we need to modify the original array only. So we create this pointer which will travel in this direction and try to fill the elements in this form. Also friends here you can see in the output array, 9 being the largest. So if I write here largest, if you see the indexes of the largest elements, 9 is at 0, then comes the second largest 8 which is at 2, third largest at 4. So for this simple array if I write the indexes it would be 0, 2, 4. And for the smallest it is 1, 3 and 5. So the indexes would be 1, 3 and 5. So here if you see we need to arrange this array in max min form and to place the elements in respective indexes, we have this idea that the largest numbers will be placed at even indexes and the smallest number will be placed at odd indexes. So this is one thing we need to keep in mind. So this iterator when it will travel in this direction at whichever index it is, we will first deduce that whether it is an even index or odd. If it is an even index, then we will take the help of max index, take that value and somehow place it at the index denoted by i. And if the i is at odd index, then we will take the help of min index, take that value and somehow place it where i belongs. So I will write here max index, min index. So we need to keep this information in mind that the largest will be at even index and will be placed with the help of max index which will be starting from the last index, the smallest will be at odd index, the numbers will be provided by min index starting from the zeroth index, min index after placing one one smallest element will travel in this direction and max index after placing the largest element will travel in this direction. So if you closely observe between these two arrays, you will see we need to arrange the array in max min form. So at the start when i will be at zeroth index here, we know that we need to put nine at the first spot. So as we can't create a new array, we need to put nine somehow here. But here you can see we have already two because two will lie in this index after the output. But two will see there is a three. And if you see three will lie in this index here. And when we'll place three here, it will see that it has six, because six will lie in this index here. And it has eight, so eight will lie in this index. And similarly, if you see, we can't directly replace the elements, because it has already one element which we need to place it at its correct index so that it looks in max min form. So friends, a trick to solve this problem is instead of storing nine directly here, what we can do is we take nine, we take two, we apply some formula and generate, let's say an integer, let's say we combine nine and two in such a way based on such formula, and we get a number x. So we will store x here instead of nine. So why we are storing these numbers? So as we are storing a combination of number based on a formula. Now let's say if I take an example, here, we have eight. Now this eight, we need to somehow place it index two here, like this. So let's say to this number, I denote it as a. And this number, let's say I denote it as b. So we'll take b and a and apply some formula and generate a number x. So this x we will store here. Instead of eight directly, we will store a number x which will be a combination of b and a five and eight. Now why we are storing both the numbers is in the output array, it should come here, but five will be lost. So we need to prevent both the numbers. Because if I put a directly here, then five will be lost. And we can't figure that what we need to place at this index, because five should come here in the output area. So this x we store in such a way, we will see the formula later, this x we store in such a way that it will help us in giving a back and b back. So that after storing x here, in the resultant area at this index will somehow deduce a and when we reach here, we take that x and we can somehow deduce b, so that we can place five directly here. So this is very important that we are using some formula here and storing a number x and this x will help us in generating a and b back. So here what we do is, as the array sorted, the last index will be the maximum value, we will take a variable which is greater than our largest number. So here what we can do is we can simply do nine plus one. Let's say 10. We are going to last index, we are taking that value and adding one, we will see why we are doing that. So friends, the formula we use to store two numbers is let's say if the i is an even index, we need to store the largest number. And that largest number will be given by max index here. And the max we have is 10. So let's say if we are at index zero, and we need to place nine here, like this. So if I use this formula, so add this index, what we will store, we will store the whatever the value here we have, which is the two, which is important for us because this is our, let's say b. So we take two, we take the number which we are shifting, which is nine, we do modulus by 10, which is nine divided by 10 will give us a remainder. And we do multiply by 10. Now here you can see, it will give us to the remainder is nine into 10. The number is 92. So at area five, we are storing the number 92. It was two, and we are storing 92. So here if I write number 92. So you can see this number is our x. And how we can deduce a and b back is 92. The max which we took, let's say if I divide 92 by 10. So we will get nine, which is our a. And if I do 92 mod 10, we'll get the remainder, which is two. So you can see this largest number which you are taking, it is generating a number, which is storing our both the integers, the number which you are shifting here, and the number which is already here. So we can deduce nine into back. So now let's see how this algorithm will move ahead. So this mod, you will understand when we reach here. So now I will come here. And we assume that max index somehow has placed this value here. So the max index will now come back to index four to take the second largest value like this. So now I is at odd index. So now we will use the formula for odd index, we will take the help of min index, the formula is pretty much same, only the value in array for max index and min index is changing here. So now you can see that this step will be more clear to you why we are doing this modulus. So at index one, we need to put the smallest number, we are taking this formula. So we take the value here, which is three, because we don't want to lose this value. And here you can see, we'll take the value at min index. So currently, if I take the value at min index, it is not two, two is gone, we have 92. So I will simply write 92 mod 10 into 10. Now you will understand why we are doing first mod is because there could be a chance that we get an overridden value. So here we have 92. And we know that from x we can deduce our overridden value, which was two, and the number which is transferred here. So 92 divided by 10 will give 992 mod 10 will give remainder which is two. So here therefore we are first taking this remainder so that first we get the original value. And even if this value is not overridden, let's say it was two only. So two mod 10, this will again give us two only. So here, so here this formula is important that we are doing mod with the max value. First to deduce our original number. And then we are simply multiplying it by 10. So that something like this can happen. So three plus two into 10. The remainder is two. So it will give 23. So here this number 23 is suggesting that that we will store 23 here. And now this value is overridden. 23 comes here. And what it is telling is it is storing two numbers, the number which is getting shifted here, and the number which was already here. So we'll go over this quickly now, because we have a fair amount of idea what we are doing. So for two, it is an even so we use this formula. So we take the value five plus we are using this formula. Value at max index is eight. So we are doing eight mod 10 into 10. So here you can see that this value is not overridden. So therefore, even if we do mod 10, we get the same value back. So five plus eight into 10, which is 85. So we are storing 85 here for this index i. And then I will come here. And this max index will come here. And as we have used this two also here, so we will move the min index to here. So now as i is at three, which is odd index, we need to take the smallest value, we move min index in this direction, because we assume that we have placed two here somehow, the step which we did previous 285, while we placed 23 here. So min index, use this value, and it shifted here. Now at this spot, what we do is we are taking this formula because value of i is three. So here we take six, 23, like this, the remainder will be three, it will give 36. So here, now this value will become 36. This has been overridden. And this has also been overridden. So these are the now original values at these spots. Now after taking the help of min index, min index will come here. We will move i ahead. And now value of i is four, we will take the largest number. And we'll use this formula. So eight plus the value at max index is 36 mod 10 into 10. So this will give us eight plus six into 10. It will be 68. So we are storing 68 here. So this eight will be overridden with 68. So this value will be overridden and max index will come here because it has used this value. I will go here. And at the last index being an odd index, we will take that value nine, because we are using this formula, we are taking the value nine, then plus value at min index, which is 85, because min index is pointing to index two. So 85 mod 10 into 10, nine plus five into 10. So this will give us 59. So we are storing 59. So I just remove this now everything. So now instead of these numbers, we have a combination of numbers. So let's say if I denote this number as x, and we need to get back b and a. So we know that will give us a, will give us b. We know this formula already. So now we will iterate this array one more time. And now what we do is we need to store nine here, which is our a. So what we do is 92 divided by 10 will give nine. So nine comes here. Here 23 divided by 10. Two comes here. And similarly 85 divided by 10 will give eight, 36 divided by 10 will give three, 68 divided by 10 will give six, 59 divided by 10 will give five. So this is how this combination numbers will give us output array, which is our answer. So friends, these are the formulas we need to keep in mind. And now let's move ahead and see the demonstration of this algorithm step by step. So we have method arrange max min, which takes in an array. And here you can see that we are not creating any additional array. So this problem is solving over one space complexity. So friends, before we start, if you want to master algorithms and data structures, then you can subscribe to my channel and click the bell icon so that you never miss any update. So we call arrange max min, we pass in the array. So this is our original array, which is here. And this is our resultant array, which is our output array. So here as we will modify this array, this number will be getting overridden. So to understand what the previous number was, you can refer this array, because this is our original array. Moving ahead, we create a max index, starting from the last index, array dot length minus one, array dot length is six minus one will give five. So max index will start from here, because this max index will give us the largest, then second largest, then third largest, and so on. We'll create a min index starting from zero. This min index will give us smallest, then second smallest, and third smallest, and so on. So as the array sorted, we have created two pointers, starting from very extreme ends. And then we will evaluate a max value, which you already discussed, that we simply take the value at the last index, which is the maximum, because this array sorted, we do plus one. So max will become 10. And now we will apply the for loop where we are traversing i in this direction, starting from zero and going till fifth index via this condition. So currently, I will start from zero index, zero is less than array dot length, which is six. So friends in our previous slide, we discussed that first we evaluate whether this i is at even index or at odd index. So if i divided by two, if it gives remainder as zero, it means it is an even index. And if i mod two doesn't give us a remainder zero, it means it's an odd index. So currently value of i is zero, so i mod two will give remainder as zero, which means that we are at even index. And as we are at even index, we know that we need to place the largest numbers, which will be given by max index at odd index, we will put the smallest numbers that will be given by main index. So here we are using the same formula. So as i is at zero index, we are taking the help of max index to take the maximum value and place it here. So we will store a modified number here, which is the combination of this and this number. So we will take two plus value at max index, which is nine mod 10, which is our max into 10. So this will give us 92. So we store 92 here. And then we decrement max index, assuming that max index has placed nine at its proper spot. So the max index will come at index four, like this. We will increment i, i comes at index one. Now i mod two will give remainder as one. So therefore we know that one is an odd integer. So the else part will be executed. So now here we will take the help of main index to get us the smallest numbers. The formula is pretty much the same, which we already discussed in our previous slide. Here we will take this number, which is three. We will take the number at main index, which is 92. We will do mod 10, multiply by 10. We are doing mod 10 is because we need to get back the original number, which was two. So 92 mod 10 will give us two, because we need to put two here somehow. So in the output array, here two will come here. So at this index, we need to place two. So therefore from 92, first we are deducing two via this modulus. So three plus two into 10. This will give us 23. So 23 will come here. So now we assume that main index has taken two and somehow placed it at its correct spot. So this value and this value, we assume that we have used up. So we increase main index value so that we can get a second smallest value now. Main index becomes one. We will increment i. i comes at index two, i mod two, which is two mod two, which will give us zero. So it means two is even index. So we apply the formula. We take this value, five plus. Now we take the value of max index, because we need to put eight somehow here. So eight mod 10, five plus 80. It will give us 85. So 85 comes here. Now we will decrement max index because this value is used up. Max index becomes three. So it means we have used up this value now. We will increment i. i comes at third index, which is odd index. So this condition will fail because three mod two will give us remainder as one, which is not equal to zero. And here we will take the help of main index and take the second smallest value now. So we will take this value, which is six. We take 23. We will do mod 10 because at index three, you see the number we are shifting is now three should come here in the resultant array. So first we need to deduce this three back. So 23 mod 10 will give remainder as three, which was our original number here. And then we do multiply by 10. So this will give us six plus 30, 36. So 36 comes here. And now we assume that we have placed three here properly somehow. So this number will be used up and main index will come to this spot. So we'll increment main index like this. We will increment i. i comes to this spot. The value of i is four, which is an even index. So this condition comes out to be true. We take the value eight and here we will take the help of max index because we need to put the max value here. So first we will deduce what number we need to shift. So we'll take 36, 10 into 10. This will give us six into 10, 68 plus 60 will give 68. So 68 comes here and then we have used this six also. So we will decrement max index now. It will come at index two now. We will increment i. i becomes five. Five is still less than six. Five mod two will give a remainder as one. So therefore the else part will be executed. And here we'll take help of main index. So at main index the original value was five and we know that five needs to become here. So first we need to deduce five out of 85. So we'll use this formula. We take nine here plus, so this formula will help us in getting five back. So we'll take 85 mod 10 into 10. This will give nine plus five into 10 which is 59. So 59 comes here. And then we will increment min index because we have used this value also. So now when we will increment i, i will become six and six is not less than six. So therefore this formula will terminate now which makes sense because we have used up all the values. So now this is our modified array. At the start we have taken this array which was our original array. We transformed it into this array and now our task is to transform this array into this array. So for that we are using this for loop and we have already discussed how we can do that is let's say we take 92. We know that we have stored both the numbers. The number which was getting shifted here and the number which was already here. We can deduce both the numbers. So let's say if i denote 92 as x. So here x will give us a via x by max which is our 10 here and x will give b via x mod max. So if i take 92 if i do 92 by 10 we'll get nine which is our a. If i do 92 mod 10 it will give us two which is our b and our task is to store the largest element we know that we can get it via division. So we iterate this array back from i equal to zero it will go till the last index so we'll go over this formula quickly because it is very simple. So i is zero. Now at the same spot we are taking 92 dividing it by max which is 10 and storing it back at the same index only. So here it will come 92 divided by 10 will give 9 like this. Moving ahead i becomes 1. 23 divided by 10 will give 2. We increment i again. i becomes 2. 85 divided by 10 will give 8. We increment i. i becomes 3. 36 divided by 10 will give 3. We'll increment i. 68 divided by 10 will give 6. We'll increment i. 5 is still less than 6 because the array dot length is 6. So this for loop will execute one more time for the last index 59 divided by 10 will give 5. And now when we'll increment i it will go beyond the boundaries of array so this for loop will terminate. And here you can see after this for loop will terminate our algorithm will also end and here you can see that now we have got our output array which is in max min form and one thing to notice we have modified the same array which we received so therefore we have used o of 1 extra space. So friends in order to understand this problem more you need to go over this video two three times to understand these formulas which is helping us to store two numbers instead of one and then here we are deducing one of the number out of it. So this x is giving b year and a year. So friends i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update. Thanks have a nice day. Hello friends welcome to my new data structures and algorithm in java tutorial series video. Friends in this tutorial we will discuss about the introduction to graphs. So friends what is a graph? So friends below you can see a figure it represents a graph. Here it contains few nodes say one two three four five and these five nodes are connected through some lines. So a graph is a nonlinear data structure used for storing the data. So we can store the data inside a graph but it's not a linear data structure like arrays and linked list. So friends it is a set of vertices. So here you can see one two three four five are nothing but vertex of the graphs and it also has a collection of edges that connects a pair of vertices. So here you can see two vertex are connected by an edge. So in a graph if we take any two vertex and if you want to connect them we just provide an edge. So here you can see between this five vertex there are six edges one two three four five and six. So in simple terms we can represent a graph as set of vertices and a collection of edges that connects a pair of vertices. So friends why graphs are important. So here you can see so friends here you can see a graph which is nothing but social networking site so in computer applications graphs help us to implement social networking sites such as Facebook and Twitter and we can term it as social networking graph. So friends here in this social networking graph the names of people which you can see here is Ankit, John, Bill, Kathy and Max. We can see them as the vertices of this social networking graph. So if you consider the example of Facebook then friendship between two people can be represented as an edge of the graph. So here you can see Bill is friend to Kathy and Kathy is friend to Bill. So therefore there is a link between them which is nothing but friendship link. So we can represent this graph where people are the vertices and the friendship link between them is nothing but the edge. Another application of the graphs would be the web content over the internet. So friends let's suppose we are having few web pages as google.com, udemi.com, youtube.com, twitter.com and facebook.com and let's suppose from google.com there is an edge to udemi.com. So this edge is nothing but a link and similarly let's say from udemi there is one link which can take us to facebook.com and from facebook to twitter and from youtube to twitter and vice versa. So here we can take these web pages as the vertices of this graph and the links as the edge between these vertices. So friends in computer application this web content can be represented as a graph where web pages are nothing but the vertices and the edge which connects between them is nothing but the link. So friends this was the introduction to graph. In our upcoming tutorial we will discuss the graphs into further detail. I hope you like this video. Thanks have a nice day. Hello friends welcome to my new data structures and algorithms in java tutorial series video. Friends in this tutorial we will discuss how we can represent an undirected graph. So one of the way in which we can represent a graph is adjacency matrix. So friends first of all what is an undirected graph. So here in the figure you can see five nodes 0 1 2 3 4. So these nodes are nothing but the vertices of the graph and you can see here an undirected edge. So here between the vertex 3 and vertex 4 there is an undirected edge. So what is an undirected edge. The undirected edge doesn't have any direction. So if suppose we are on vertex 3 then we can go to vertex 4 and if suppose we are on vertex 4 then we can go to vertex 3 and as such there is no direction between the two vertices. So a graph which has these two edges are termed as undirected graph. So if we take an example then social networking graph which we discussed in our previous tutorial is nothing but an undirected graph. So let's suppose the social networking graph there is a set of vertices which is nothing but the names of people. So let's suppose John is a friend to Max. So here John and Max are nothing but the vertices of the graph and the friendship between them is nothing but the edge of the graph. So here if John is friend to Max then it implies that Max is also friend to John. So it is nothing but an undirected graph. So here John is friend to Max is same as Max is friend to John. So the social networking graph can be seen as an undirected graph where edges are undirected they don't have any direction. Moving ahead so friends graph can be represented by a two dimensional array which is nothing but a matrix. So let's suppose we are given this undirected graph where 0 is connected to 1, 1 is connected to 2, 2 is connected to 3 and 3 is connected to 0. So in order to represent this graph in a data structure we usually use the matrix which is nothing but a two dimensional array. So friends here if you see there are four vertices. So therefore we create a 4 cross 4 matrix. So this 4 cross 4 matrix goes from indices 0 to 3 and this matrix is nothing but a 0 1 matrix. So why we call it a 0 1 matrix because in order to represent an edge between two vertices we just provide a 1 which signifies that there is an edge between the two vertices. So friends here you can see from 0 to 1 there is an edge. So when we want to represent an edge in matrix we follow this rule that a first vertex is the row and the second vertex to which this edge is going is the column. So if I take an example then between 0 and 1 there is an edge. So in the graph we can represent it as from 0th row to 1th column there is an edge which is nothing but 1. Similarly if we are at node 1 and if you want to go to node 0 then there is an edge. So from the first row to 0th column there is an edge and as it is an undirected graph therefore we can go both ways from 0 to 1 and 1 to 0. So let's suppose if you want to go from 3 to 2 so from the third row second column there is an edge which can be represented as 1 and similarly it is an undirected graph therefore from 2 we can go to 3. So from the second row to third column there is an edge. Also here you can see that from node 3 to node 1 there is no edge therefore from the third row to first column there is no edge therefore we have represented it as 0 because it signifies there is no edge between 3 and 1. So in the matrix wherever you want to represent an edge we usually put 1 and wherever we want to represent a no edge then we put 0. So friends here we use the matrix to represent an undirected graph. I hope you like this video thanks have a nice day. Hello friends welcome to my new data structures and algorithm in java tutorial series video. Friends in this tutorial we will discuss the adjacency matrix implementation of an undirected graph. So friends in our previous tutorial we discussed what is an adjacency matrix and how we can represent an undirected graph into it. So friends in this tutorial we will see how we can implement an adjacency matrix to represent an undirected graph through a demonstration. So friends let's suppose we are given an undirected graph with four vertices as 0 1 2 3 where 0 and 1 are connected through an edge 1 and 2 are connected through an edge 3 and 2 are connected through an edge and 0 and 3 are connected through an edge. So friends using this code here we can actually represent this undirected graph into a form of matrix. So let's see this demonstration step by step. So in our previous tutorial we discussed that using a matrix we can represent that a graph. So here in our java class graph we are having this adjacency matrix and in the constructor we are initializing this adjacency matrix with the number of nodes in the graph. There is a method add edge which takes two parameters let's say u and v. So here suppose if you want to add an edge between 0 and 1 so 0 would be u and 1 would be v. So through this code we can add an edge between u and v. So you'll see it's demonstration step by step. So let's suppose in our main method first we initialize the graph with the number of nodes. So here you can see there are four nodes. So we are passing the number as 4 here. So now the execution step goes into the constructor of graph where nodes is having value of 4. So in the constructor we simply initialize an object of matrix by providing the value of row and column as the value in the nodes which is nothing but 4. So after execution of this step it will create a two dimensional array which is nothing but a 4 cross 4 matrix. So it would look something like this. So here it will be represented as an adjacency matrix which is a 4 cross 4 matrix. Moving ahead. So friends here you can see that from 0 to 1 there is an edge. So by calling add edge method we pass 0 and 1 because we want to create an edge between 0 and 1. Here we simply apply this rule that between a row and a column we just provide a 1 which represents an edge. So if you want to represent an edge between 0 and 1 so 0 will represent a row and 1 will be representing as a column. So between 0 and 1 there would be an edge which will be represented by 1. So let's see how. So as the value of u is 0 and v is 1. So here in order to represent an edge between 0 and 1 in the matrix 0 comma 1 we provide a value as 1. So in the matrix 0 and 1 we just provide a value of 1. So it would look something like this. So this represents an edge between 0 and 1 which is 0 row and 1 column. Moving ahead. So friends in the second step what we do is as this graph is an undirected graph there is no direction between the edge. Therefore we can see it something like as there is an edge between 0 and 1 and we can also see it as there is an edge between 1 to 0. So friends this information we need to store into the matrix. So in the first step 0 to 1 we provided a value as 1. So similarly in the second step from row 1 to 0th column we provide a value as 1. So it would look something like this. So in an undirected graph basically an edge represents a two points into the adjacency matrix because if we are at vertex 0 then we can go to vertex 1 because there is an edge and if we are at vertex 1 then we can go to vertex 0 through this edge. So therefore in the matrix this edge represents these two points that from 0 to 1 there is an edge and from 1 to 0 there is an edge. Moving ahead. Now we want to add an edge between 1 and 2. So we simply pass the parameters as 1 and 2. So into the adjacency matrix to row 1 and column 2 we need to provide a value 1 to represent an edge. So it would look something like this. Moving ahead. Now similarly we have to provide an edge from row 2 to column 1. So we provide a value as 1. So this represents an edge between row 2 and column 1. Moving ahead. Similarly vertex 2 and vertex 3 are connected through an edge. Therefore in the matrix from the row 2 and column 3 will provide a value as 1. Moving ahead. And similarly from the row 3 to column 2 will provide a value as 1. Because if you want to traverse from third node to node 2 we know that there is an edge and that can be figured out through this matrix. That we can directly figure it out that from row 3 and column 2 is there any edge or not. So if the value is 1 we can come to know that there is an edge. Moving ahead. And the last edge is between vertex 3 and vertex 0. So it would be represented as row 3 and column 0 which is this value will provide a value as 1. Moving ahead. And finally from the row 0 to third column will provide a value as 1. So friends this is how we can represent an undirected graph into a matrix. And also one point to note that as it is an undirected graph. Therefore for each edge there will be two values of 1 into the graph. Which will be actually demonstrating a twoway graph. Here from 0 to 1 there is a way and similarly from 1 to 0 there is a way. So into the matrix we represented it something like from 0 to column 1 there is an edge. And from one row and 0 column there is an edge. So friends this is how we can represent a graph in the form of a twodimensional array. Which is nothing but a matrix. In my next tutorial we will actually code this algorithm into the Eclipse. I hope you like this video. Thanks have a nice day. So friends here I have created one class by name graph which is having a main method. So into this class we will code the implementation of graph through adjacency matrix. So first we will create an integer variable. And we will give it a name as v. So this v is nothing but a number of vertices in the graph. We will also create one more integer variable. We will name it as e. So this e would be number of edges in graph. We will also create a twodimensional array. Which would be our adjacency matrix and it would represent a graph. So it would be a twodimensional array. And in the constructor we will initialize these three values. So this graph constructor takes in number of nodes. So here if simply we can assign nodes value to v. And as we are in the constructor of graph therefore value of e would be equal to 0. Because till now there are no edges into the picture. And finally we will initialize the matrix with the number of nodes. So if suppose the graph is four nodes therefore this would be a four cross four matrix. We will also create an add edge method. Which will actually add an edge from u to v and vice versa. Therefore here simply we can do is. To uth row and vth column will assign a value of one which represents an edge. And vice versa will do from v to u. Because it is an undirected graph. So therefore for every edge in the matrix. There will be two points which will be representing an edge. After adding the edge will increment the count of edge by one. So it would be e plus plus. So friends in our main method will create a graph and add an edge between few nodes. So will create an instance of graph. And will provide a value of four. So this will actually create a graph of four nodes. And also it will create an adjacency matrix. Which is of four cross four. So will actually create a graph which we saw in our previous tutorial. Will add an edge from zero to one. Then from one to two. Then from two to three. And finally from three to zero. So friends here we have added four edges. Which we actually saw in the slide of our previous tutorial. Here I will create one method. Which will give us the string representation of this graph. And I will name it as two string. And so first will create a string builder. Will append v. Which would be vertices. E would be our edges. And then will simply provide a for loop. Now this for loop will iterate over each and every vertex. And inside this for loop will append. And now will provide one more loop. Which will iterate over the adjacency matrix. For a particular vertex. So here will append. So here we are simply printing the matrix. So sb. And finally will return sb.toString. So here will simply print g. And if I run this code now. So friends here you can see. That there are four vertices as we have passed a value into the graph is four. And there are four edges because we have created four edges. From zero to one one to two two to three and three to zero. And below is the string representation of this graph. Which is nothing but our adjacency matrix. So this matrix we discussed in our previous slide. You can refer that slide. And you can come to know that. It represents the same matrix which we discussed. So friends in this tutorial we saw the implementation of the graph. Using an adjacency matrix. I hope you like this video. Thanks have a nice day. Hello friends. Welcome to my new data structures and algorithms in Java tutorial series video. Friends in this tutorial we will discuss. The representation of an undirected graph through adjacency list. Friends in our previous tutorial we discussed about the representation of undirected graph through adjacency matrix. So in this tutorial we will discuss one more way to represent an undirected graph. That is through adjacency list. So this adjacency list is nothing but an array of linked list. So friends let's suppose we are given an undirected graph. Having four nodes zero one two three. And from zero vertex there is an edge to vertex one. From vertex one there is an edge to vertex two. And from vertex two there is an edge to vertex three. And finally from vertex three there is an edge to vertex zero. So friends this undirected graph can be represented as an adjacency list which is nothing but array of list. So here you can see there are four nodes. So we create an array of linked list having the size as four. So here you can see each and every index hold a linked list. And what this linked list contains. Friends let's suppose we are on vertex zero. And there is one edge to vertex one and one edge to vertex three. So friends these two edges from the vertex zero is represented as. In the array index zero the linked list which it holds has node one and node three. So this structure tells us that from node zero there is an edge to one and there is an edge to node three. Similarly if you can see from vertex two there is an edge to vertex one and vertex three. So in order to represent this structure at index two we have node three and node one. So it signifies that from two there is an edge to three and from two there is an edge to one. Similarly here you can see that from three we have one edge to two which is this edge. And from three we have one edge to zero which is this edge. So friends this is one more way to represent an undirected graph that is by using an array of linked list. So the length of this array is same as the number of vertices in the graph. So friends in our upcoming tutorial we will discuss more about adjacency list. We'll see its code and working through animation. I hope you like this video thanks have a nice day. Hello friends welcome to my new data structures and algorithms in java tutorial series video. Friends in this tutorial we will discuss about the implementation of the undirected graph using adjacency list. So friends in our previous tutorial we discussed about the representation of an undirected graph through an array of linked list. We also discussed that how this undirected graph can be represented into an array of linked list. So friends in this tutorial we will look into the code and see its demonstration step by step. So here is the code to implement a graph using an array of linked list. So we'll see the working of this code step by step through animation. And we will see that how we can represent this undirected graph into an array of linked list. So let's start. So in the step 1 we initialize a graph and we pass in the number of vertices the graph can have. So here if you see this undirected graph has 4 nodes. Therefore we are passing the value as 4. So into the constructor the value of nodes is 4. So in the first step what we do is we have taken this instance variable which is nothing but an array of linked list. So we initialize this array of linked list with the number of nodes. So it would look something like this. That here you can see an array of linked list. So as currently the linked list is not being initialized so they point to null. Moving ahead. So then we provide a for loop and we iterate over each and every vertex. And to this array of linked list it will initialize the linked list to each and every index. So as i starts from 0. Therefore at 0th index it will initialize a linked list. So it would look something like this. Currently linked list is empty and head is pointing to null. Moving ahead. Then i becomes 1. And similarly at the index 1 it will initialize a linked list. Moving ahead. i becomes 2. So in index 2 it will again initialize a linked list. And similarly at the index 3 it will initialize a linked list. So now i becomes 4. Therefore the condition for loop comes out to be false because 4 is not less than 4. So friends here we have created an array of linked list. And to each index we have a separate linked list. So here you can see from vertex 0 to vertex 1 there is an edge. So we will call this edge method and we will pass the value as 0 and 1 stating that there is an edge between 0 and 1. So friends value of u is 0 and value of v is 1. And also in our previous tutorial we discussed how we can represent an undirected graph into an array of linked list. So what we do is as there is an edge from 0 to 1. Therefore the 0th index linked list we add 1. So first we get this linked list at the 0th index and add 1 to it. So it would look something like this. That at the 0th index linked list we are adding 1. Moving ahead. And similarly as this is an undirected graph therefore from vertex 1 there is an edge to vertex 0. Therefore the linked list at vertex 1 will add the value 0. So it would look something like this. So here it represents that from 0 there is an edge to 1. So the linked list at 0th index has an edge to 1. And similarly here you can see from the vertex 1 there is an edge to vertex 0. So it is represented by the linked list at index 1 has a value 0. Which signifies that there is an edge from 1 to 0. Moving ahead. Then we can also see that there is an edge from 1 to 2. So we call this edge method by passing 1 and 2. So in the first step what we do is the linked list at index 1 we add the value 2. So it would look something like this. Moving ahead. And similarly the linked list at index 2 we will add value 1. So at index 2 we will add the value 1. So it would look something like this. Moving ahead. Now there is one more edge from the vertex 2 to vertex 3. So this can be demonstrated as to the linked list at index 2 we will add the value 3. So here to a linked list at index 2 we will add a value 3. So it would look something like this. Moving ahead. And as it is an undirected graph therefore to the linked list at index 3 we will add the value 2. So it would look something like this. Moving ahead. So in the last step there is one more edge from the vertex 3 to vertex 0. So we will pass the value as 3 comma 0. So in the first step what we do is the linked list at index 3 we will add the value 0. So it would look something like this. Moving ahead. And similarly the linked list at index 0 we will add the value 3. So friend this is a code to implement an undirected graph through an array of linked list. Here you can see that each and every node has been represented by an index of this array. And in order to represent an edge we simply add those value into the linked list of that particular index. So here you can see that from 0 there is 1 edge to 1 and 1 edge to 3. So at the linked list at 0 index we are adding 1 and 3. So this is a type of a metadata which can help us to know that okay from 0 there is an edge to 1 and from 0 there is an edge to 3. And similarly if I take this vertex 2 there is an edge to 1 and there is an edge to 3. So the linked list at index 2 has 1 and 3. So friend this is how we actually represent a graph into an array of linked list. In my upcoming tutorial we will actually code this implementation into Eclipse and see it's working. I hope you like this video. Thanks have a nice day. So friends in our previous tutorial we actually discussed about the implementation of an undirected graph through adjacency list. So in this tutorial we will code that implementation into Eclipse. So here I have created one class by name graph having a main method. So here in the graph class we will first create an array of linked list. We will import the linked list from java.util. We will also create an integer variable and we will name it as v. So this integer variable will be having a value of number of vertices in the graph. So it represents number of vertices. And similarly we will create one more integer variable and we will name it as e. So this integer variable will be having a value of number of edges in graph. We will also create one constructor. And to this constructor we will pass the number of vertices the graph can have. So we will give this integer a name as nodes. So here what we can do is as we represent the number of vertices in the graph. So we will simply assign the value of nodes to it. And as this graph is getting initialized so the value of e will be zero. Because currently there are no edges. And finally we will create an instance of array of linked list. So this dot adj equals new linked list. And we will pass the value of nodes to it. So after creating an instance of array of linked list currently each and every index of this array will point to null because the linked list has not been initialized. So we will provide a for loop. And we will iterate over each and every vertex. And we will create a separate linked list for each and every index of the array. So adj of v. So friend in this for loop we are iterating over each and every vertex. And as we have created this array of linked list. Therefore we need to initialize a linked list for each and every index. Moving ahead. We will create a method as ad edge. So this method takes in a to value. Let's say we give the name to us as u and v. So we are calling this ad edge method. What we are doing is we are creating an edge between u and v. Friend in our previous tutorial we saw that in order to create an edge between u and v. We have to provide the value of v into the linked list of u and similarly we have to provide a value of u into a linked list of v. So here what we do is. Into the linked list of u we add. The value v. And similarly. Into the linked list of v. We add value u. And finally we increment the value of e by 1. Because it signifies that an edge has been placed between u and v. Therefore we are incrementing the e by 1. So friends in the main method. We'll first initialize the graph. With the number of nodes. So friends in our previous tutorial we saw an undirected graph. Which had 4 nodes. So we'll initialize this graph. With 4 vertices. So we provide a value as 4. And then we'll add an edge. From 0. To 1. And then from 1 to 2. Then from 2 to 3. And finally from 3 to 0. So friends here we have created one graph. Of 4 nodes. And we have added 4 edges. So friends in order to test its working. I'll create one method as. 2 strings. So friends this method will return back as a string representation of this graph. So in the first step I will be creating a string builder. So to this string builder. First I will append. Vertices. And edges. And then we'll provide a for loop. And we'll simply iterate. Over each and every vertex. So you have to string builder will append v. So friends here in the for loop. We are getting each and every value of vertex. So friends as we are looping over each and every vertex. We have the vertex value. We'll provide one more for loop. Which will bring back the link list associated. With that vertex. And we'll iterate over it and print its content. So here we'll provide one more for loop. So in order to iterate over a link list associated with a particular vertex. What we do is. We simply pass the value of that vertex. And we'll get the link list associated with it. So here if I take an example. Then we have added an edge. From zero to one. And there is one edge from three to zero. Therefore when we call. The link list associated with vertex zero. Will get the two values. One is the value one and one is the value three. Because those two values are there in the link list. So in this for loop will simply append. The value present in the link list. For that particular vertex. And finally we'll append. One line break. And we simply return. The string representation of the string builder. So for now main method. Will now sis out. The value of G. And we'll run this code. So for and here you can see the graph is four vertices and four edges. Because we initialize the graph with four vertex. Therefore the value of these four. Which is the number of vertex. And as we have added four edges. We are getting the value of the number of edges as four. And here in the two string representation of it. What we are doing is. We are iterating over each and every vertex. That is from zero one two and three. And here you can see. That there is an edge. From zero to one. And zero to three. Therefore from the vertex zero. There is an edge to one and there is an edge to three. And similarly. From vertex three there is an edge to two. And there is an edge to zero. There is an edge between two and three. And three and zero. So into the linked list of this third index there are values two and zero. Which represent that there is an edge. Between three and two and three and zero. So from this is how we actually represent a graph. Through an area of linked list. I hope you like this video. Thanks have a nice day. Hello friends. Welcome to my new data structures and algorithms in Java tutorial series video. Friends in this tutorial we will discuss. The breadth first search of an undirected graph. So friends breadth first search is nothing but a traversal or a searching technique. Which we apply to the graphs. To visit each and every node of the graph. So here breadth first search is also known as level order traversal. So let's suppose we are given a graph of say five nodes. Where zero one two three are connected by an edge. And four is connected to two by an edge. So therefore what do we mean by level order. So suppose if you are starting from zero. Then this is at level one. So this will be visited first. And then here you can see that from zero three and one are connected. So these both nodes are at level two. So after zero one and three will be visited. Because they are at level two. And then you can see that from three there is an edge to two. And from one there is an edge to two. So therefore the node two is at level three. So after visiting one and three two will be visited. Because it is at level three. And then here you can see node four is connected to two. Now this is at level four. So therefore four will be visited after two. So zero is at level one. One and three are at level two. Two is at level three. And four is at level four. So using breadth first search technique we can traverse the graph level by level. So friends here is the algorithm for it. So friends in this algorithm we usually use queue data structure. So this data structure is nothing but FIFO data structure. Which means first in first out. So the element inserted into this data structure first will be first to be removed from the queue. So we are using queue because it will help us in traversing the nodes of a graph level by level. So friends we apply the same algorithm while we are traversing the tree. But there is a slight catch in the graph. Because in the graphs it may contain a cycle which you can see here. So therefore we need to keep the track of the nodes which are being visited. So we usually keep the track of the nodes into a boolean array. So friends let's see the working of this algorithm step by step. So we'll start with the value zero. So in this method we'll pass the source node as zero. So in first step what we do is. We create a boolean array whose size is equal to the number of vertices in the graph. So this vertices is nothing but the instance variable which we discussed in our previous tutorial. So here you can see in this graph there are five nodes. Therefore we'll create a boolean array by name visited having a size of five. So it would look something like this. And as it is a boolean array so initially all the values inside this array is marked as false. And we have marked it false because initially we haven't visited any node of the graph. Moving ahead. We'll then create a queue data structure. Now this queue data structure will help us in traversing the nodes of a graph level by level. So it would look something like this. So here in our previous tutorial we also discussed how queue data structure works. So you can watch my those tutorial to get more in depth of how queue works. So it's simply a fee for data structure where element inside at first will be first to be removed. Moving ahead. Now friend as we are starting from zero. So we will mark the visited index as true that we have visited this node. In the area we'll make it true. And here we'll mark it that we have visited this node. So friends after we visit the node. We simply put that node into the queue. So as you have visited zero will put the zero into the queue. So it would look something like this. Moving ahead. So friend as we want to traverse each and every node level by level then we'll apply a while loop. And we'll check whether queue is empty or not. So currently you can see queue is not empty because there is one value inside the queue. So the condition in while block comes out to be true. So in the first step we simply pull this element out of the queue which is zero and we'll assign it to the integer variable u. So it would look something like this. And it will be assigned to you. Moving ahead. We'll simply print this element on the console that it is visited. So zero is printed on the console. So here in breadth first search after visiting any particular node. We then go towards its adjacent nodes. So here you can see the node adjacent to zero or one and three. And in our previous tutorial we saw the representation of a graph through adjacency list. So now we'll apply a for loop which will traverse the adjacent nodes of zero. So here if you look the adjacency list of graph then the node adjacent to u would look something like this. That in the adjacency list zero is connected to one and zero is connected to three. So here zero is connected to one and zero is connected to three. So now we'll traverse each and every adjacent nodes of zero. So we'll start with one. So here v becomes one. And the first I will check that whether one is already visited or not. So here in the array we see that value of index one is false therefore it's not visited. So in the if block first we'll mark this node as visited by providing a value of true to index one of this boolean array. So it would look something like this. And here we'll mark it as visited. And after marking the node as visited we'll simply put it into the queue. So we'll put one into the queue so it would look something like this. Moving ahead now v becomes three. We check whether three is visited or not. So here in the boolean array three is not visited. So we will first mark three as visited by making the value as true. That we have visited this node. And then we'll simply put three into the queue. Moving ahead now as we have visited all the adjacent nodes of zero therefore this for loop will terminate. And we will come back to our while loop and we'll check whether queue is empty or not. So here you can see queue is not empty. So we'll pull from the queue. So one will be pulled out. So it would look something like this. And you will have value as one. We will print one on the console that we have visited it. So friends now we will actually traverse the adjacent nodes of one which is nothing but zero and two because they are connected to one. And if we look the adjacency list of one then it would look something like this. That one is connected to zero and one is connected to two. So now in the for loop we'll iterate over these two elements. So we'll start with zero. So v becomes zero. We will check whether zero is visited or not. So here you can see zero is already visited. Therefore we'll simply skip this block. And then now v becomes two. We check whether two is visited or not. So here you can see two is not visited. So we will first mark the value at index two as true that we have visited this node. And also we are marking it as we have visited this node. Moving ahead. And then we'll simply put the two into the queue. So it would look something like this. Moving ahead. Now friends here you can see we have visited each and every adjacent nodes of one. So therefore the for loop terminates. And then we'll come back to our while loop. We check whether queue is empty or not. So queue is not empty. We'll poll the first element from the queue which is three. So it would look something like this. And we'll assign its value to u. So u becomes three. Moving ahead. We simply print three on the console that we have visited. And friends then will provide a for loop which will iterate over the adjacent nodes of three. So here you can see the adjacent nodes of three are zero and two. So if we see the adjacency list of three then it would look something like this. That three is connected to zero and three is connected to two. So now we will visit the adjacent nodes of three and we'll start with zero. So we become zero. We check whether zero is visited or not. So here you can see that zero is visited. So we simply skip this if block. Now v becomes two. And we check whether two is visited or not. So here you can see two is already visited. Therefore we simply skip the if block. So friends there are no more adjacent nodes to three. So therefore this for loop will terminate. We'll come back to our while block. We check whether q is empty or not. So q is not empty. We pull the first element from the q which is two. So it would look something like this. So it would look something like this. And we'll assign it to integer variable u. So u becomes two. And then we'll simply print the value of u on the console that we have visited it. So friends now we will actually traverse the adjacent nodes of two. So here you can see the nodes adjacent to two are three. One and four because they all are connected by two. So if you look the adjacency list of value two then it would look something like this. That two is connected to three. Two is connected to one and two is connected to four. So therefore now we'll traverse each and every adjacent nodes of two. So we'll start with three. So v becomes three. Moving ahead. We will check whether three is already visited or not. So here you can see in the visited array at index three the value is already true. And it's already visited. Therefore we simply skip this if block. Now v becomes one. We know that we already visited one. Therefore we'll skip this if block. Now v becomes four. And here we'll check whether we have visited four or not. So we haven't visited four because the valued index four in the visited array is false. So in the first step what we'll do we'll mark this value as true that we are visiting it. Moving ahead. And then we'll simply offer four into the queue. So it would look something like this. So friends now there are no more adjacent nodes left to be traversed. So this for loop will terminate. We'll again check whether queue is empty or not. So queue is not empty. We'll pull the first element out of the queue which is four. So it would look something like this. And we'll simply assign this value to u. So u becomes four. We'll print this value on the console. And then we'll simply traverse the adjacent nodes to four. So here in the diagram you can see the adjacent nodes to four is only two. So if you see the adjacency list of index four. So it would look something like this. That there is only one node which is adjacent to four. So v becomes two. We'll check whether two is visited or not. So here you can see two is already visited because the value at index two of the visited array is true. So we simply skip this if block. And here we already visited all the nodes adjacent to four. So therefore this for loop will terminate. We'll check whether queue is empty or not. So currently you see queue is empty. Therefore condition in while block comes out to be false. So friends here you can see that we have visited each and every node of this graph using breadth first search algorithm. And you can see in the output that we have visited all the nodes level by level. So we started with level one which is zero. So we visited it. Then we went to level two where there were one and three. So we visited those two nodes. Then we went to level three where the only node was two. So we visited two. And then we went to level four where the only node was four. So we visited four. So friends this was a demonstration of the algorithm. Now let's go to Eclipse and see the working of this code. In our previous tutorial we actually saw the demonstration of breadth first search algorithm in Java. So in this tutorial we'll actually code that algorithm and see it's working. So friends in my previous tutorial I have created one class by name graph and we represented graph using an adjacency list. So friends in order to understand more about graph you can watch my previous tutorials. So in this tutorial we will actually code the breadth first search technique. So here I will be providing one method. My name BFS. And as we know that this method will take a source value. Which would be nothing but a starting point from where we will actually start our breadth first search. So in the first step what we do is we actually create a boolean array which will actually keep the track of the visited nodes. I'll give the name as visited. And friends here you can see that to this graph we are actually storing the number of vertices into this instance variable v. So the size of this boolean array would be v. Moving ahead and then we'll simply create a queue. So we'll import it from java.util package. Friends moving ahead we'll mark the source node as visited. By assigning a value true to the visited array at index s. And then we'll simply offer s into the queue. Which we actually discussed in our previous tutorial. Then we'll simply provide a while loop. And inside this while loop we place a condition that whether queue is empty or not. So this while loop execute if queue is not empty. So in the first step what we do we simply poll an element from the queue. And after polling the element from queue we simply print it on the console. So friends whatever the element we have pulled from the queue then we simply traverse its adjacent nodes which we actually discussed in our previous tutorial. So we'll provide a for loop which will traverse the adjacent nodes to u. So let's say we give it as v. And in order to get the adjacent nodes to u we simply bring the adjacency list at index u. So friends in order to understand this more you can watch my previous tutorial that what is adjacency list and how we can fetch the linked list associated with any particular index. Moving ahead we will check that whether v is visited or not. So if it is not visited then we'll simply mark it as visited by assigning the value as true. And then we'll simply offer it to the queue. So friends in our previous tutorial also we discussed that this boolean array is kept to keep the track of the visited nodes. We are using this queue which will help us in traversing of this graph level by level. So what here we do is we actually visit a particular node at level and after visiting it we'd go to its next level. So friends this is the algorithm for the breadth first search. Now let's test it's working. So here you can see we have already created a graph of four nodes. So here we will apply this breadth first search to the graph which we saw in the slide. So that slide had five nodes. So I will provide a value of five here and here you can see that there is an edge from zero to one one to two two to three and three to zero. So we'll provide one more edge from two to four which we actually saw in the slide. And then we'll finally call the breadth first search method. And let's say we are giving the source node as zero. So if I run this code now. So friends here you can see it printed zero one three two four and we also know that as you started from zero so this was at level one and from zero one and three were connected which we actually saw in the previous tutorial. So they printed after that two was connected to one and three. So then two was printed and finally four was connected to two. So four got printed. So here you can see that we have traversed each and every node level by level. I hope you like this video. Thanks have a nice day. Hello friends. Welcome to my new data structures and algorithms in Java tutorial series video. Friends in this tutorial we will discuss depth first search of an undirected graph. So friends in our previous tutorial we actually discussed breadth first search traversal of a graph. So in this tutorial we'll discuss the iterative way to perform depth first search traversal of a graph. So friends here you can see that we are given an undirected graph. So by undirected graph we mean that that edges that don't have any direction. So if you are on any particular node let's say zero then we can go to one and if you are on one then we can go to zero. So the edges don't have any direction. Therefore this is an undirected graph. So you can see the algorithm to perform depth first search of an undirected graph. So let's see the demonstration of this algorithm step by step. So friends whenever you perform depth first search on an undirected graph we usually pass in the source node that from where we need to start the depth first search. So let's say we start our depth first search from zero. So the value of s will become zero. So friends whenever we traverse any undirected graph we usually keep the track of its node through a boolean array which actually tells us that which node is visited and which node is not. And which node is not because here you can see the graph may contain a cycle and we don't want to visit any particular node more than once. Therefore we keep the track of each and every node into this boolean array. So whenever we initialize this array we actually pass the size as the number of vertices. So here you can see the number of vertices are five. So this boolean array will look something like this. That here each index represent a node and at the start each and every value in this boolean array is false because we haven't visited any of the node till now. Moving ahead. So friends in order to perform depth first search in an undirected graph we usually take the help of stack. So the stack data structure is nothing but LIFO data structure which means last in first out. So the element inserted last into the stack will be the first one to be removed. For more detailed information about the stack you can watch my previous tutorials. So here in this step we'll simply create a stack of integers. So currently stack is empty. Moving ahead. So here first we push the source node into the stack. So zero will be on the stack. Moving ahead. So friends whenever we want to perform depth first search of an undirected graph we are providing a while loop and inside this while loop we are providing a condition that whether stack is empty or not. So when the stack is not empty this while loop executes. So currently you can see stack is having one element. Therefore stack is not empty. So the condition in while block comes out to be true. So in the first step what we do we simply pop the element from the stack and we'll assign it to an integer variable u. So it would look something like this. That zero will be popped out. And it will be assigned to integer variable u. So u is having value as zero. Moving ahead. So then we actually check that whether we have actually visited zero or not. So here in the visited array at zeroth index we see the value. So currently you can see the value is false. Therefore we haven't visited this node. So the condition in if block comes out to be true. And in the block we simply mark the value at index zero is true. That we are now about to visit this node. And we'll simply print it on the console. So zero is printed on the console. Moving ahead. So friends in depth first what we do is whenever we visit any particular node then we look for its adjacent nodes. So here the adjacent nodes of zero are one and three. And in our previous tutorial we also discussed about the adjacency list. So the adjacency list of zero would be a linked list having the values as one and three. So it would look something like this. The adjacency list of zero will have values as one and three. Because these two nodes are adjacent to zero. For more information about the adjacency list you can watch my previous tutorials on graph. So here we are providing a for loop which will iterate over each and every element of this adjacency list. So we'll start from one. The value of v becomes one. And in the for loop we'll check whether we have visited v or not. So value of v is one and the value at index one is false. Therefore we haven't visited this node. So the condition in if block comes out to be true. So in the if block we simply push one on the stack. Moving ahead after visiting one we go to three. So now v becomes three. We check whether we have visited three or not. So here in the visited array at index three the value is false. Therefore we haven't visited this node. So the condition in if block comes out to be true. And we'll simply push three on the stack. Moving ahead. So friends now we have traversed each and every element of this adjacency list. So this for loop will terminate and the call will reach back to this while loop. So in the while loop we'll again check whether stack is empty or not. So here you can see stack has two elements. Therefore it's not empty. So the condition in while block comes out to be true. So the first step will simply pop an element from the stack and will assign it to you. So you will hold the value as three. Moving ahead. We then check whether we have visited the value three or not. So here you can see in the visited array at index three the value is false. Therefore the condition in if block comes out to be true. So in the if block first we mark the valued index three as true. That we have visited this node. And then we'll simply print it on the console. Which signifies that we have visited this node. So friends after you visited three we look for its adjacent nodes which is zero and two. So the adjacency list of three will look like that it has value zero and two which are adjacent to three and will provide a for loop and will iterate over each and every element adjacent to three. So we'll start with zero. So we become zero. We'll check whether we have visited zero or not. So here you can see the valued index zero is true. Therefore we have visited this node. So the condition in if block comes out to be false. Now V becomes two. We check whether we have visited two or not. So here you can see the valued index two is false. Therefore we haven't visited this node. So the condition in if block comes out to be true. And we'll simply push two on the stack. Moving ahead, so friends we have visited each and every adjacent nodes to three. So this for loop will terminate and the call will reach back to this while loop. We again check whether stack is empty or not. So here you can see stack is not empty because it contains two elements. So the condition in while block comes out to be true. In the first step, we'll simply pop an element from the stack and we'll assign it to you. So here you will become two. We check whether we have visited two or not. So here you can see the valued index two is false. Therefore we haven't visited this node. So the condition in if block comes out to be true. And in the if block first will mark the valued index two to be true that we have visited this node now. And then we'll simply print two on the console. Moving ahead. So friends after visiting this node, we actually look for adjacent nodes which is three, one and four. So the adjacency list of node two will look something like this. That it has three values, three, one and four, because these three nodes are connected to two. And we will iterate over each and every element of this linked list. So we'll start with three. So here V becomes three. We check whether we have visited three or not. So here you can see the valued index three is true. Therefore, we have visited the node three. So the condition in if block comes out to be false. And now we will become one. We check whether we have visited one or not. So here you can see the valued index one is false. Therefore, we haven't visited one. So the condition in if block comes out to be true. And we'll simply push one on the stack. And now we will become four. We will check whether we have visited four or not. So here you can see the valued index four is false. Therefore, we haven't visited this node. So the condition in if block comes out to be true. And we'll simply push four on the stack. So friends, here we have visited each and every element adjacent to two. Therefore, this for loop will terminate. And the call will reach back to this while loop. We check whether stack is empty or not. So here you can see stack is not empty, because it contains three elements. So the condition in while block comes out to be true. We pop the element from the stack, and we'll assign it to you. So the topmost element on the stack is four. So four will be popped out. And the value will be assigned to you. So you will have four. We check whether we have visited four or not. So here you can see that valued index four is false. Therefore, we haven't visited four. So the condition in a block comes out to be true. And in the block, first will mark the valued index for to be true that we have visited this node. And we'll simply print it on the console. So friends, after visiting node four, we'll look forward to adjacent nodes. So here you can see the adjacency list of four will look something like this. The linked list will have only one element which is two, because only two is connected to four. And here we are providing for loop, so that we can iterate each and every element adjacent to four. So we'll start with two. So here we will become two. And we check whether we have visited two or not. So here you can see the value at index two is true. Therefore, you already visited this node. So the condition in a block comes out to be false. And also friends here we have visited each and every element adjacent to four. Therefore, the for loop will terminate. And call will reach back to while loop. We again check whether stack is empty or not. So here you can see stack has two elements, therefore, it's not empty. So the first step will simply pop the element from the stack and will assign it to you. So the last element inserted in the stack is one, therefore, one will be popped out. So you will now have value as one. Moving ahead, we check whether you visited one or not. So here you can see the value at index one is false. Therefore, we haven't visited one. So the condition in a block comes out to be true. So in the block will simply mark the value at index one to be true that we have visited this node now. And we'll simply print it on the console. And then we'll provide a for loop so that we can traverse our adjacent nodes to one. So friends, after visiting the node one, we'll look for adjacent nodes, which is nothing but zero and two. So the adjacency list of one will look something like this, that node adjacent to one is zero and two. So we'll provide a for loop and we will iterate each and every element adjacent to one. So we'll start with zero. So we become zero. We'll check whether we have visited zero or not. So here you can see the value at index zero is true. Therefore, we already visited zero. So the condition in a block comes out to be false. Now we becomes two. And we will check whether we have visited two or not. So here you can see the value at index two is true. So the condition in a block comes out to be false. And also friends, we have visited each and every node adjacent to one. So this for loop will terminate and the call will reach back to this while loop. We again check whether stack is empty or not. So here you can see stack has one element, therefore it's not empty. So the first step will simply pop an element from the stack and we'll assign it to you. So one will be popped out and you will have value as one. Then we'll simply check whether we have visited one or not. So here you can see the value at index one is true. Therefore we have already visited the node one. So the condition in a block comes out to be false. We again check whether stack is empty or not. So here you can see stack is empty. So the condition in while block comes out to be false and while block terminates. So friends, here you can see using this depth first search algorithm, we have visited each and every node of the graph. So friends in this tutorial, we actually saw the demonstration of this algorithm. Now let's go to Eclipse and see the working of this code. Hello friends, in our previous tutorial, we actually discussed the depth first search algorithm of an undirected graph. So in this lecture, we'll actually code the algorithm and we'll test its working. So friends in our previous lectures, we actually created one class by name graph and we have implemented the graph using the adjacency list. We also discussed the breadth first algorithm. So in this tutorial, we'll actually discuss the depth first search algorithm. So here we will be creating one method as public void DFS. And we also know that the depth first search will start from a source node. So S will represent the source node. So friends in our previous lecture, we actually saw the demonstration of the depth first search step by step. So friends in the first step will simply create a Boolean array. We'll give it a name as visited and we'll initialize this Boolean array. With a size equal to the vertices of the graph. So friends here we have created this Boolean array which will keep the track of the nodes which we already visited. Because while traversing a graph, there may come a situation where graph contains a cycle. So in order to visit a particular node only once, we usually create this Boolean array, which will keep the track of the nodes which are visited. And then we'll create a stack. So we'll import the stack from java.util package. So friends, we are using this stack which will help us in performing depth first search. And its significance we already discussed in our previous lectures. So after creating the stack, we'll simply push the source vertex on the stack. And then we'll provide a while loop. So in this value, we'll provide a condition that whether stack is empty or not. So this while loop will keep executing with a condition that whether stack is empty or not. So the stack is not empty, this while loop will keep on executing. So inside this while loop, as we discussed in our previous lecture, that we pop the element from the stack, and we'll assign it to you. And then we simply check that whether you visited you or not. So if we haven't visited you, so the condition in a block comes out to be true. So first, we'll mark the value at index u to be true. That we have visited this node, and we'll simply print u on the console. So friends, after visiting you, we simply provide a for loop. Which will iterate over each and every element adjacent to you. So friends, here after visiting any particular node, we'll look for its adjacent nodes. And we can get the adjacent nodes to the adjacency list. And we'll simply iterate each and every element of this adjacency list one by one. So in the for loop, we simply check. That whether the adjacent node to you, which is v, has been visited or not. So if the node is not visited, we simply push it on the stack. And this we do for each and every element adjacent to the already visited node. So friends, this is the code to perform depth first search over an undirected graph. Now let's test it working in the main method. So here you can see we have created a graph with five nodes. And we have added the edges between the nodes, say from zero to one, one to two, two to three, three to zero and two to four. So this is the same graph which we discussed in our previous lecture. So here in the main method, we simply call the DFS method. And we'll pass the value of the source node at zero. That we have to start our depth first search from the node zero. So if I run the code now. So friends, here you can see it printed each and every node of the graph in the following order. First it printed zero, then three, then two, then four, and then one. So this is the same model which we discussed in our previous lecture while demonstrating this algorithm step by step. So friends, this is how we actually perform a depth first search over an undirected graph. I hope you like this video. Thanks. Have a nice day. Hello, everyone. So in this video, we will be looking into the recursive depth first search algorithm to traverse an undirected graph. So in our previous video, we actually saw the depth first search using the iterative approach. So in this video, we'll see that how recursive algorithm works. So here you can see that this is the algorithm which is recursive depth first search. Here you can see this DFS is calling itself here, making it recursive in nature. So let's see the demonstration of this algorithm step by step. But before we start, in case if you're new to my channel, then please subscribe to my channel and click the bell icon so that you never miss any update. In our previous video, where we discussed about the iterative approach, we used the stack data structure to traverse the graph. And in our previous algorithm, where we saw breadth first search and depth first search iterative, there we were given with a source vertex. And from there, we started our DFS. But usually the graph is given in form of like this. So here you can see zero, one, two, three, four, they are connected together. And there is one more node, which is five. So this vertex is not connected with the rest of the elements. So basically, a graph is provided like that, that there could be components, which are basically disconnected. So we need to visit this graph, and it's each vertex. So here, we actually use this for loop, which travels each and every vertex and help us visiting the vertex using depth first search. So let's see the demonstration of this algorithm step by step. So here as the algorithm is recursive, we will keep the track of the DFS method which is getting called on a call stack. And here you can see, when we are calling DFS on any particular vertex v, after visiting it, we try to traverse its adjacent nodes one by one. So those adjacent nodes we denoted by W. And if they are not visited, we call the DFS again, we pass the W value to it, because we want to not traverse the adjacent vertex to v. So when this DFS will be called, this W will become our new v. So we need to keep that in mind while traversing our call stack. So at the start, we simply call DFS. So one method is on the call stack. Now friend as this graph can be connected, and can form a cycle. So when we perform DFS, this visited array, which is Boolean, help us in knowing that which which nodes are already visited, or which vertex are already visited. So this capital v, we already discussed in our previous videos that that this represent a number of vertexes. So currently we have six vertex from zero to five. So we created a Boolean array of six elements. We start from v equal to zero. So v is zero. We first check whether v is already visited or not. So currently, we see at index zero, v f falls. So therefore it's not visited. So we call DFS. And as we are leaving this DFS at line number five, we update line number here. So now there will be one more method on the call stack with vs zero and the visited array you can see here. So when we call DFS on any vertex, the first thing we do is we mark that vertex as true that we have visited. So we mark it as true. And here you can see we made it yellow. And by visiting the node, we mean processing the node. So here, we are simply printing it on the console. So zero will be printed. Now we look for the adjacent nodes to vertex zero. So this adjacency list we discussed in our previous videos. So this adjacency list is an instance variable, which holds all the vertex and their corresponding edges. So when we do adjacency of zero, it has two elements one and three, because these two elements are adjacent to zero, and they are connected. So it looks like this. So after traversing zero, we try to traverse these adjacent nodes. So we can start from any node. So here we pick three. So here you can see W becomes three. We check that whether three is visited or not. So here you can see three is not visited. So we call recursively depth for search on three. So this three which is W, when we will call DFS again, it will become our new vertex to visit. And here you can see we are leaving this DFS on line number 15. So we need to update line number here. Because once this DFS will finish, we should know that from where we need to start this DFS. So we update line number 15 here. And there will be one more method on the call stack with our new V as three. So you can think of it something like this, we are going like this. Moving ahead, V becomes three. We mark three as visited like this. And then we print it on the console. And then we look for the adjacent elements to three. So if we see the adjacent elements to three, we will get zero and two. So the adjacency list of three will give us zero and two. Now we need to visit zero and two, because those are adjacent to three. So we can start with any node. So we pick zero. So W becomes zero. We check whether zero is already visited or not. So here you can see zero is already visited, marked as yellow. So this condition comes out to be false. So now we go with vertex two. So W will become two now. We check whether two is visited or not. So here you can see two is not visited, it is marked as false. So this condition comes out to be true. And now we again call DFS with WS2. We are leaving at line number 15. So first we update line number here. There will be one more method on the call stack, where we will become two, because now we need to traverse two. So we first mark two is visited like this. Then we print it on the console two. And then we try to traverse its adjacent vertices. So here you can see adjacent to two is three, one and four. So the adjacency list will give us three, four, one. So we can start with any node. So we start with three. So W will become three here. We check whether three is visited or not. So here you can see three is already visited. So this condition comes out to be false. We then take four, W becomes four. We check whether four is visited or not. So four is not visited. So then we do the DFS on four. So we call DFS with WS4. We first update the line number here, because we are leaving this DFS now. So there is one more method on the call stack. With our new vertex to visit is four. So V becomes four. We first mark index four as true, because we are about to visit it. We print it on the console. So four gets printed. And now we check for the adjacent elements to four. So here you can see the elements connected to four is only two. So its adjacency list will have only two. So we try to visit two now. So W becomes two. We check whether two is visited or not. So here you can see two is visited. So this condition comes out to be false. And here you can see the adjacent elements of vertex four is all visited. So now this for loop will terminate. And this DFS will also get terminate. And our call will reach to that DFS which actually called this DFS. Because we are done with the all the adjacent elements of vertex four. So this method will be removed from the call stack. And the execution point will reach here. And we know that we had left this DFS at line number 15. So we start our execution from line number 15. And when we left this DFS, the value of V was two. And the value of W was four. So it means we were traversing the adjacent elements of two. And we just visited four. So if we see the adjacency list of two, we visited three already. Then we went to four. So we are done with four also. So now our time is to visit one. So W will become one in the next iteration. One. We check whether one is visited or not. So one is not visited. So this condition comes out to be true. And we call DFS again with W as one. So we update the line number 15 here. There will be one more method on the call stack with V as one. We mark vertex one as visited. We print one on the console. So this is also visited. And now we actually check the adjacent elements of one. So you can see it as zero and two. Zero and two. So we start with zero. W becomes zero. Zero. So here you can see zero is already visited. So this condition comes out to be false. Then we go to vertex two. W becomes two. And two is also visited. So this condition comes out to be false. So here you can see all the elements adjacent to vertex one are visited. So this for loop will terminate and this DFS method will be removed from the call stack. And execution point will reach here. So we start this DFS from line number 15. And we were actually traversing vertex two. And the recent adjacent element we visited was one. So W becomes one and V becomes two. So if we see the adjacency list of two, we are done with three, four and one. So in the next iteration, this for loop will terminate because there are no more adjacent elements to vertex two. So now this DFS will end. And call will reach to its previous DFS. We will start from line number 15. And we had left this DFS when value of V was three. And the recent adjacent element to three, which we tried to visit were two. So V is three, W is two. So if we see the adjacency list of three, here you can see zero, we already visited. And we went to two and two also we visited. So now this DFS will end for vertex three. The execution point reached here. We start from line number 15. And when we left this DFS, we were actually visiting the adjacent elements of vertex zero. And the recent we visited was three. So V is zero. And W is three. And if you see the adjacency list of zero. So here you can see the recent element we visited was three. So now we go with the vertex one. So W becomes one, one. We check whether one is visited or not. So here you can see this visited array is helping us to not to visit the vertex again, because one is already visited. It is marked as true. So this condition comes out to be false. So now we are done with the adjacency list of zero. So this DFS will end. And this method will be removed from the call stack. And we go back to the starting DFS method, where we left at line number five. So we start from line number five. And we are done with visiting zero vertex. So here you can see this for loop will now help us in visiting five. Because when we started with zero, all these nodes are directly or indirectly connected with zero. So we visited everyone using the DFS. So this file is not connected to any of these vertices. So using this for loop, we will visit five as well. So we'll increment V, V becomes one. So vertex one is visited, so we do nothing. V becomes two. So two is visited, we do nothing. V becomes three. Three is also visited. So we do nothing. Four is also visited. And now V becomes five. So here five is not visited. So we call DFS on vertex five. We update the line number. And here we call this DFS with five. So here, it should be five. Because we are leaving this DFS when vertex V was five. So now we call DFS on vertex five. We mark vertex as visited. This is visited now. We print it on the console. And then we try to visit the vertex five adjacent elements. So here you can see, there are no adjacent elements to vertex five. So this for loop will terminate. And this DFS method will be removed from the call stack. And we go back to the previous DFS at line number five, where V was five. And then we increment V, it becomes six. So now this for loop will terminate. And everything will be removed from the call stack. So you can see, in this order, we visited each and every vertex of the graph. And here using this for loop, we even visited vertex which were disconnected. So friend, this was all about the recursive depth first search. I hope you must have liked this video. In case if you are new to my channel, then please subscribe to my channel and click the bell icon so that you never miss any update. Thanks, have a nice day. Hello everyone. So in this video, we are going to discuss that what are connected components in an undirected graph. So friends, here you can see that we are given a graph having six nodes from zero to five. Now here if you see that we have three connected components. So one is having nodes zero, one and three, which is this connected component. Another connected component is two and four. And the third connected component is a component having only one node, which is five. So usually with a graph, we are given a graph in a form of connected components. So one such query comes is that we need to evaluate that in a graph, how many connected components are there. So in this graph, we have three connected components. And also one such query comes is we are given with two vertices, let's say zero and two. And we need to find whether zero and two are connected or not. So here you can see zero is in the first connected component and two is in the second connected component. Two is connected with four, zero is connected with one and three. So zero and two are not connected. So such queries are given. So usually in real world, let's say we can think of this connected components as a graph of a small region, where this three nodes form a road, this two forms another road. And there could be a query that whether this road is connected with this road or not. And similarly, for other applications, we can think as network connections, we just need to query whether this connection and this connection are connected or not. So such queries can be handled via connected components. So in this video, we are going to see the algorithm that how we can figure out the numbers of connected component and how we can figure out whether any node is connected to another node or not. So here is the algorithm. And here we are using the same graph which we discussed in our previous slide. So let's see the demonstration of this algorithm step by step. So friends, before we start, in case if you want to master data structure and algorithm, you can subscribe to my channel and click the bell icon so that you never miss any update. So here you can see that to find the number of components and to find whether any of the vertices are connected or not, we need to process each and every node. So here what we do is we apply the depth first search. Now this algorithm is recursive in nature. Here you can see depth first search is again calling here itself. So it's a recursive algorithm. So therefore we will maintain the calls to the DFS in the call stack. And we need to keep the track of the vertices we are visiting. So at the start, we call DFS. Now when this method starts execution, there will be one method on the call stack by name DFS. And now this method will start its execution. So we are storing the state of v, w and count for this DFS. And this we will do for each and every recursive calls here. Because when we are calling this DFS from this DFS, this method will store the state into the call stack. And then it will again call DFS. So once this DFS will end, the method will return to this DFS. And we will assign back the values of the variables from where this DFS is left. Moving ahead. So friends here you can see that as we are calling this DFS on an undirected graph, there could be a possibility that this graph contains a cycle like this. So what happens is we create a boolean array visited. Now this boolean array will help us to check whether any of the vertices are already visited or not. Because let's say if we visit zero, then one, and then three, then from three, if we go to zero, this boolean array will help us knowing that zero is already visited. So in order to keep the track of visited node, we create a boolean array. And here in our previous videos, we know that the capital V is nothing but number of vertices. So currently we have six vertices from zero to five. So this boolean array will have six vertices from zero to five index, and each index corresponds to a node in a graph. So at the start, all the values of the visited array will be false because no node is visited as of now. Now we will create yet another array, which we will call component ID. We will see its significance later. But here you can see this component ID will store the ID of any particular component in the form of integer. So you can think that as we have three components here. So this component ID for 301 will store let's say an ID of zero, for example, for two and four, it will store one, and for five, it will store two. Now this will state that we have three components, 01 and two, node three belongs to zero component, zero belongs to zero component, and one belongs to zero component. So that will be evaluated with this component ID. And similarly, two will belong to component one, four will belong to component one, and five belongs to component two. So there could be so many nodes in a graph. So this component ID will denote a group of nodes, which will be represented by an ID. So we will see its significance later. So this error would look like this, that at the start, for all the vertices, the value will be zero. Or what we can do is we can also initialize this array as a wrapper of integer. So every value will be null, stating that the nodes are belonging to no component at the start. Moving ahead, then we will create a count variable. Now our task is to first count number of connected components. And our second task is to return true or false for a query that whether x and y are connected or not. So we are using this algorithm to figure out these two problems. So we are creating a count variable, which is suggesting that how many connected components are there in this graph. So at the start, in this DFS method, count will be zero, because we are yet to start the processing of this graph. Also from here, you can see, in this method, we are creating this three things, visited array, component ID array, and count. So usually for these two queries, we take these three variables at the class level, so that we can use them directly in any of our methods. But here, for time being, I have created these three variables in the method itself, so that I can demonstrate the algorithm that how it works. So these three things you can create outside of the method at the class level, we can make these variables as instance variables. So for time being, you can think that these are part of the method itself. And for the actual DFS algorithm, we are actually passing them directly into the method. Or else if they are at instance level, we don't need to pass them like this. Now we will start the processing of graph from vertex zero, and it will go till it is less than the number of vertices, which is six. We need to go from zero to five. So at the start, v is zero. So we update zero here. Now the first thing we check is whether v is already visited or not. So here you can see, as we are starting the processing of the graph, v is not visited. Here valued zero index is false. So therefore, this condition comes out to be true, which means we can apply the depth first search on vertex zero now. So here, now this DFS will be removed from the call stack, and this DFS will be called. So first we update line number here, because we are leaving this DFS now. So we are leaving at line number seven, so that when this DFS method will finish, we come back to this DFS, and we start the execution from line number seven itself. And we assign this value back to v. So now there will be one more method on the call stack, and the execution point will reach to that DFS with v as zero, count as zero, because we are passing count zero and v zero. We will see what this w is here, and visited array and component id array, you can refer here. Now when we will call DFS on any particular node, what we do is, we first process that node, and how we can process that node is, we can perform any typical algorithm on that particular node, and we first mark that node as visited, that we are done visiting this particular node. So in the visited array, at zero index, we simply assign a value true, stating that we have visited node zero, like this. We have visited this node, and here what we can do is, we can either process some algorithm on top of this node, we can print this node, and we can do anything on this node based on the algorithm we are trying to process. And now what we do is, this count variable, which we have passed into the DFS here, this count variable will help us in finding the id of the component. So as we discussed that these three nodes belong to component id is zero, this two belongs to one, and this belongs to two. So these id can be anything. So here, what we are doing is, we are taking the count only as our id. So in the component id array, at vertex zero, we update count as zero, like this. Now after visiting a particular node, what we do is, we recursively visit its adjacent nodes. So in our previous video, we have discussed that what this adjacency list is, this is actually a list, we are passing a vertex zero, because value of v is zero, and we are asking to return its adjacent nodes. So it would look something like this. I'll remove this. So here this list states that zero is connected to three and one, and it is denoted in the form of an adjacency list. You can watch my previous videos to understand more about this. So here, what we are doing is, we are iterating the nodes one by one. So zero is connected to three and one. So we can process these nodes in any order. So this for loop will process one node. So at the start value of w will be three. Let's say we are taking three to visit, like this. Now we need to visit three. So what we do is, first we check whether we have already visited three or not. So here at index three, we have a false value. It means we haven't visited three. So now our task is to recursively call DFS with w will become our new v in the next DFS call. And we are applying this DFS now for vertex three, because we haven't visited this vertex. So before calling this DFS, we know that we are leaving this DFS at line number 18. So we'll update line number first here, like this. And then this DFS will be called. So there will be one more method on the call stack, like this. An execution point will execute this DFS. Here w was three. When we call this DFS, it becomes our new v. So you can think it is going like this. So now we are applying this DFS on vertex three. We have passed count as zero as you're directly propagating the count to this DFS. So v becomes three now. We know that we haven't visited three. So we will first visit three by marking the index three as true, like this. That we have visited three now. And in the component ID array at index three, we will assign the value zero because value of count is zero, like this. Now this zero is actually telling us that this zero and three are actually connected because their IDs are same. After visiting three, we will visit its adjacent nodes. So we will iterate the adjacency list of three. And it has only one node zero because three is connected only to zero. So at the start w will be zero, like this. And now as we are processing the adjacent nodes of three, we first check whether zero is already visited or not. So here you can see at index zero, we have value true. It means we have already visited zero. So this condition comes out to be false. And here you can see for vertex three, there are no more nodes adjacent to three left to be traversed. So this for loop will terminate. And after this for loop gets terminated, this DFS method will also get terminated. And this DFS will be removed from the call stack. And execution point will reach to this DFS. And here we know that we had left the previous DFS at line number 18. So we start from line number 18. At that moment, v was at zero. So we will come back to zero. W was at three. And if you see the adjacency list of zero, we have processed one of the adjacent nodes of zero, which is three. Now in the next iteration, we will pick one, and we will apply DFS on one, because we need to visit one and then visit is adjacent nodes recursively. So w becomes one here. We check first that whether one is already visited or not. So at index one, we have a value false. It means one is not visited. So we will call DFS again. And we are leaving this DFS at line number 18. So we'll update the line number here. 18. There will be one more method on the call stack. As we have called this DFS with w as one, this w will become our new v here for this DFS. So it will go like this. And count will go with a value zero only. The first step we do is we mark the vertex one as visited. So at index one, we mark it as true, like this, that we have visited one now. In the component ID array, at index one, we put the value of ID as zero, which suggests that zero, one and three are connected. Now after visiting one, we will visit its adjacent nodes recursively. So if we call the adjacency list of one, you will see that it is connected only to zero. So we have only one vertex. So w will start from zero. We'll first check whether zero is already visited or not. So here you can see zero is already visited in the visited array. At zeroth index, we have true. So this condition comes out to be false. And there are no more vertex adjacent to one left to be traversed. So this for loop will terminate. And this DFS method will also get terminated and removed from the call stack. So execution point will reach here. We had left the previous DFS at line number 18. So we'll start from line number 18. At that moment, v was zero and w was one. And v was zero, it means we were visiting the adjacent nodes of v. We visited three and we visited one recursively. So now there are no more nodes in the adjacency list of zero to visit. So this for loop will terminate. And this DFS method will also get and and it will be removed from the call stack. And execution point will reach to this DFS, which we left at line number seven. So we start from line number seven. At that moment, v was at zero. So here you can see that after performing the DFS on any of the node, here we started with zero, it recursively visited its neighboring nodes. So once this DFS will end, we know that we have visited one component fully. So now what we do is we simply increment count. So our count becomes one. Now this count is suggesting that we are done processing of one connected component. And we have found one connected component. So count becomes one. We will increment v, v becomes one. Now it means we are going to the vertex v and trying to apply DFS on vertex v. So first we check that whether one is already visited or not, because there could be a possibility that its previous vertex or any of its previous vertex must have visited one, because one must have been connected to that vertex. So here you can see one is already visited. So this condition comes out to be false. We will increment v, v becomes two. We check that whether two is visited or not. So here at index two, we have a value false. It means two is not visited. So we can apply that DFS now on vertex two. So we are leaving this DFS at line number seven. And we are calling this DFS with v or vertex as two. So there will be one more method on the call stack with v as two and count as one. First we mark two as visited like this. So here I am just representing it with a different color. In the component ID at index two, we put one. Now here this count was increased. So our ID also increased, which also helped us in figuring out that two belongs to a different component. Now our task is to visit the adjacent nodes of two recursively. So two is only connected to four. So adjacency list of two will have only node four. So we'll start with four first. W becomes four. We first check whether four is visited or not. So four is not visited. So we call this DFS with W as four. So this four will become our new v in the next DFS call. So first we update line number here because we are leaving this DFS. And there will be one more method on the call stack. So the W which was in previous DFS becomes our new v and count is propagated directly. We first mark four as visited here like this. And in the component ID array add vertex four. We assign a value one. This suggests that two and four are part of one single component because they have same component ID. Now we'll traverse the adjacent nodes of four. So adjacency list of four will have only one vertex which is two. So W starts from two. We first check whether two is visited or not. So here you can see index two we have value true. So two is already visited. So this condition comes out to be false. And this for loop will terminate because there are no more nodes adjacent to four left to be traversed. And this DFS method will end. And execution point will reach to previous DFS. We start from line number 18. At that moment v was at zero. So v comes back to zero. W was four which suggests that we were visiting the adjacency list of two which was this. We know that we recently visited four and there are no more adjacent nodes to two left to be traversed. So this for loop will terminate. And this DFS will be removed from the call stack. And execution point will reach to previous DFS. We start this DFS at line number seven. At that moment v was at two. So it suggests that we just finished one more DFS on one of the vertices which was two. And it must have marked its connected vertices in the visited array. So we'll increase the count now because we are done processing the second connected component. So count becomes two. We'll increment v. So v becomes three. Now we need to apply this DFS again on vertex three. But first we check whether three is already visited or not. So here you can see three is already visited. So this condition comes out to be false. We increment v. v becomes four. Four is also visited. So this condition comes out to be false. We'll increment v. v becomes five. So here you can see vertex five is not visited. So this condition comes out to be true. So now we'll apply DFS on vertex five. So we are leaving this DFS at line number seven. So we update line number seven here. And there will be one more method on the call stack with v as five and count as two. Now the first thing we do is we mark five as visited like this. And in the component ID array at index five, we assign a value two because value of count is two. Now here it suggests that this five belongs to a different component because value of count has changed. Now we'll visit the adjacent nodes of five. So here you can see in this connected component, we have only one node and five is connected to no other node. So therefore this for loop will terminate and this DFS method will also end. Execution point will reach to this DFS. We start from line number seven and v as five. So after this DFS is done, we know that we have just visited one more connected component. So we increase the count. Count becomes three. We'll increment v. v becomes six and we know that we have only nodes from zero to five. So this for loop will terminate and this DFS will be removed from the call stack. So now here you can see, if you see in the visited array, we have visited all the elements in the component ID array, you can see zero, zero and zero are at indexes zero, one and three, which suggests that zero, one and three are connected. If you see two and four, they have a same value one, one, it means they are connected. And here if you see at index five, we have two, it means it's a connected component having only one vertex. So friends here you can see that if we take out these three variables as our instance variable, and we can provide one method as something like public int get count of connected components. So this we can return the value of count like this. So this will solve our first query. The second query we can provide a method as public Boolean. And we can give the method name is connected. And to this method, we pass x and y. So here we can simply return comp ID of x, whether it is equal to comp ID of y. So let's say if you pass x, y as zero comma two, so this is our x and this is y. So the value at index x, which is zero, we have zero and value at vertex to have one. So you can see we are comparing whether zero is equal to one or not. It means this condition comes out to be false and we return false stating that zero and two are not connected. Now, for example, if we pass three and one like this, so three is x and y is one. So comp ID of three we are checking it with comp ID of one. So this will give value zero and this will give value zero. So both the values are equal and this condition is true. So we simply return true stating that three and one are connected and they are part of the same component. So friends, this was all about the connected components in an undirected graph. I hope you must have liked this video. In case if you are new to my channel, then please subscribe to my channel and click the bell icon so that you never miss any update. Thanks have a nice day. Hello, everyone. So in this video, we are going to discuss a problem number of islands. Now let's move ahead and see what this problem is and how to solve this. So here we are given an m cross n matrix like this, which is 2d binary grid. So binary grid, we mean that we have this matrix having only ones and zeros. Now in which ones represent a land, so you can think wherever we have one, it actually represents a land and zeros as water. Like this. Now our task is to return the number of islands. Now what do we mean by island? So as per the definition in the problem, you can see an island is surrounded by water. So this is the one thing that an island is surrounded by water and second is found by connecting adjacent lands horizontally or vertically. So this is a land, this is a land. So one thing is there should be a connection horizontally or vertically and second day should be surrounded by water like this. And we may assume all four edges of the grid are surrounded by water. So beyond this grid, here you can think that there is only water. It means that it has zeros. So here we have zero, here we have zero, here we have zero. So here these three ones form an island because these three are connected horizontally and vertically and they are surrounded by water. This single one forms one island because it is also surrounded by water and this one also is surrounded by water. So the answer is three. We have three number of islands. We don't have to consider this diagonal relationship as per the problem we need to look horizontally or vertically. So here you can see that how we can solve this problem is if you look closely then we are given with a graph indirectly here. If I plot this one, so this is one node and the node adjacent to it is also one. So we can think that there is a connection via this edge horizontally like this. And there is an edge vertically because we need to consider vertical edge also. So this forms another connection like this. So you can think this island in the form of this graph and if we look closely to it, it looks like this. One, one, one, like this. So you can also think that we are given with this five nodes of a graph that they are connected horizontally and vertically and if there is a vacant space here it means that it is surrounded by water. So in one of our previous videos we discussed about connected components. So this forms one connected component, this forms another connected component and this forms another connected component. And we also discussed that how we can process a connected component and we also discussed that how we can find the number of connected components. So this problem is very similar to that. So in the connected components problem we applied the DFS which is a depth first search. So here also we will apply the same. So the only difference is there we had these actual nodes connected by edges and here we are taking these edges and lines horizontally or vertically in the form of edges. So keeping these constraints in mind, let's move ahead and see the demonstration of this algorithm step by step. So friends before we start, in case if you want to master data structures and algorithm, you can subscribe to my channel and click the bell icon so that you never miss any update. Now this is the algorithm to find the number of islands. We are given with a matrix where we have only ones and zeros and they are provided in the form of a character. And here we need to return the number of islands in this grid. So here we have created integer variable number of islands and at the end we are returning this number of islands. So let's see the demonstration of this algorithm step by step. We call the number of islands method passing in the matrix which is our grid. Now let's say we take the same example where we are given with this matrix and we know that we have three islands here. One is this island, another is this and the third one is this. Now let's see how we can find out the number of islands and we also know one property that lands should be connected vertically or horizontally. So this can be treated as a vertex of graph and this can be treated as an edge. So this is a horizontal edge and this is a vertical edge. So friends here you can see that wherever we will find land we need to apply depth first search on top of it so that we can figure out how much deep that connection is via this property. Now here we are given this m cross n matrix. So this m cross n represents row and column. So the number of rows which is m is given by grid.length which is 4. We have 4 rows 1, 2, 3 and 4 with an index of 0, 1, 2 and 3. Similarly we have four columns denoted by n. So this is first column, second, third and fourth column with an index of 0, 1, 2 and 3. So friends when we apply depth first search here we know that we need to consider horizontal and vertical relation. So here let's suppose we are given with this sort of graph. Let's say here we have this one so it must look like this. So if we are applying depth first search on top of it we know that once we visit any particular node then we visit its neighboring nodes recursively. So usually in the graph we can encounter these cycles. So here let's suppose we have visited this node then we go to this node we visit this and let's say if we are going to this node and we are visiting then here we are visiting but if we go back here this node we have already visited. So this is a rough example to just demonstrate that when we return back to this node we know that we have already visited this node but how we can mark that we have visited this node because when we will reach to this node then the algorithm will keep on visiting this node again and again. So we have a cycle so in order to keep the track of the visited nodes we create a boolean array or here you can see that we have created a visited matrix. Here as the graph is given in the form of a grid and here each index represents a vertex so therefore we have to create a matrix of m cross n which will actually help us to figure out that which nodes are visited and which are not. So it looks something like this it's a boolean matrix so at the start every node is unvisited being denoted by f which is false. As we need to return number of islands so we initialize this integer variable with zero because at the start we haven't found any island so the number of island is zero. So friends when we apply def first search on a graph we visit each and every node of that graph so here each index value can be considered as a node of a graph so here you can see that we have 16 such vertex and they are given in the form of matrix m cross n. So we need to apply these two for loops to travel each and every vertex and apply the def first search on top of it to figure out the number of islands. So here i will traverse the rows and j will traverse the columns m denotes our rows and denotes the columns so at the start i is zero j is zero so it means that we are on index zero comma zero like this also friends as we need to find the number of islands we can apply the def first search on the nodes which have values as one because zeros represent water so when we encounter water we need to skip the water and once we found even one of the land then we can apply def first search on top of it with an only condition that this one should not be visited because there could be a possibility if we are going in this direction then we are coming back then going down and they are going up so there could be a possibility that we encounter the nodes which are already visited so which is being tracked by the visited 2d array so the only condition we need to keep in mind is that in the visited array at zero comma zero we should have false value it means this node should not be visited and the value of this node should be one if we encounter zero then we will simply skip this element because this denotes the water so here at the start we found one which is the land and this land is not visited so therefore we can apply def first search on top of this one considering the graph horizontally and vertically so when we will apply dfs on top of this grid at index zero comma zero it would look something like this that this method will now call dfs method like this so here we have this grid and this visited 2d array we pass the row as zero comma zero so on the call stack there will be one method dfs having row as zero and column as zero because we found one and that is not visited so here we are maintaining this call stack because this algorithm is actually recursive as we are applying the dfs we know that it's a recursive algorithm where we actually process any node and then we try to process its adjacent nodes recursively so therefore this algorithm is recursive so in order to keep the track of this method calls we are maintaining a call stack this is our base case to stop this recursion we will see this later so now at the start we are processing a value at index zero comma zero in this grid matrix because we have found one land denoted by one and which is not visited so here you can see this is our base case now as we will apply the def first search horizontally and vertically in all the directions because this land can be connected to another land so let's say we have a land here if above this land we have another one here we have another one and here we have another one and below we have another one so this land if you see here it is connected like this like this like this like this so we need to go in four direction to figure out the extent of this island because we are given in the problem that we need to see in the horizontal and in the vertical direction so here in the normal dfs where we are given with a vertex we visited a node and then we visited its adjacent nodes recursively here the adjacent nodes as we discussed will be given by these four directions which is up left right and down so currently what this base case says that after processing any node if we are going to a level above let's say if we are going to top of this one then we are going outside the boundaries of this matrix because beyond zero comma zero the index doesn't exist in the matrix so here this is the base case that we may go out of the matrix so if row is less than zero or column is less than zero then we simply return from the dfs method so this is our base case the another conditions are if row and column goes beyond this or this then also we need to return and the last two conditions are let's say if we are on this node and if we go to right so here we are finding a water which is being denoted by zero we only keep the track of the lands which are connected adjacent and as soon as if we find a water we simply return back so here if this grid at a row and column if the value is zero then we will simply return and one last thing is let's say if we have visited this one we went here for this one also we need to go up so we'll go back to this one but here we know that we just visited this node and came here and then we are going up so if in the visited 2d array at row and column if we find any true value then also we need to return because we have already processed the node so these six conditions are very important because they form our base case we should not go beyond the boundaries with these first four conditions we should not go in the water with this condition and we should not go to a land which is already visited so at the start we are within the boundaries of this matrix because we are at zero comma zero this vertex is not visited and the value is one which is not zero so therefore all the conditions comes out to be false so we suggest that we have found one land and now as per the dfs we will visit this land and in the visited 2d array we will mark it as true like this so for one property of dfs is after visiting any particular node we visit its adjacent nodes recursively and we know that in order to find the adjacent nodes to one as per the problem they should be horizontal or vertical so we need to apply this dfs horizontally and vertically so it means we have to go in four directions left up right and down to visit the adjacent nodes of zero comma zero recursively so here if you see if we are in particular row let's say zero zero here we can travel in any direction so what we are doing is we are going first to left then up then right and then down so here when we are going left it means we are going in this direction so currently here you can see that whichever box is yellow that is our current row and column which is zero comma zero this if you want to go in the left it means we are going in this direction so when we are going in this direction to the left row actually remains the same here you can see value of row is zero so it remains the same as we are going on the left the value of column decreases by one so here we have column zero here it can be minus one because we are going in this direction similarly if you are going up let's say we are here and if you are going up here row is two now it becomes one so here row is actually decreasing but column remains the same so when we go up row decreases column remains same when we go right let's say if you are here if you are going in this direction so row remains the same and column actually increases from one to two so we do call plus one and if you are going down let's say if you are going down from here to here so row was one now it became two because we have reached here so row is actually increasing and column remains the same so this four direction we need to keep in mind if we are going on the left column decreases if you are going up row decreases if you are going on the right column increases if you are going down row increases so this four direction we need to keep in mind because for any particular land we need to see its horizontal and vertical adjacent nodes to figure out whether it has land or water so we need to call this dfs four times because we need to visit a particular row and column in four directions going left then going up then going right and then going down so first we will go left where row remains the same and column decreases by one so here you can see that we are leaving this dfs at line number eight and we are calling this dfs so first we'll update the line number here eight that we are leaving this dfs at line number eight so once this dfs will end we will return back to this dfs but we need to keep the track of the line that from where we left this dfs so this line number eight will help us knowing that we had left this dfs at this line so we'll start our execution at this line and whatever the value of row and column will be we'll assign those values back to the row and column so now you can see this method will be called where row will remain same and column will decrease by one so there will be one more method on the call stack like this here row remains the same and column decreased by one so it became minus one it means we are going to the left so here we went outside the boundaries of this matrix where column became lesser than zero so it means we have encountered a base case so we simply need to return back to zero comma zero so this dfs will end because we are now returning back so this method will be removed from the call stack execution point will reach here we'll start from line number eight and we have visited the left side and we came back to zero comma zero so we are coming back to zero comma zero and now we know that we are done with the left we need to go up so when we go up row decreases and column remains the same so we are leaving this dfs now at line number nine so we update nine here so there will be one more method on the call stack where row will decrease from zero to minus one and column remains the same so here you can see now we went to outside the boundaries of this matrix in in upper direction so now row has become less than zero so therefore we need to return from this dfs so we will come back to zero comma zero we will start from line number nine here and we will come back to zero comma zero and now we go towards its right so when we go towards right column increases so here it will increase from zero to one because we are going to the right direction and row remains the same so we execute this dfs and we leave this dfs at line number 10 there will be one more method on the call stack where row remains the same and column increases by one because we are going towards right so now you can see we are going to zero comma one so we reach to this index which is zero comma one so now we are within the boundaries of this matrix so first four condition comes out to be false this condition in the visited 2d array we have false so this comes out to be false and we know that at this index zero comma one we don't have zero we have one so therefore this condition also comes out to be false so here you can see all the conditions came out to be false because we are within the boundaries this value is not zero and it is not visited so it denotes that we have found an adjacent land which is being denoted by one and it is not visited so first thing we do is we mark this as visited like this and as we know that how dfs work now for this vertex we will visit is adjacent nodes recursively so now for value zero comma one we will apply the dfs into four directions so for this node first we'll go to left we'll update line number eight here we will have one more method on the call stack and as we are going on the left column decreases so column was one it decreased to zero row remains the same so it means we have reached back to this land here you can see this node is within the boundaries of this grid but if you look in the visited 2d array at row zero comma zero we have already visited this node because we are actually applying the dfs from this node only we reached to this node and then we are coming back to this node so we have already visited this node so though this condition is false that we are encountering a land here but we have visited this land already so we'll simply return from this dfs and this dfs will be removed from the call stack execution point will reach here and to whichever dfs we were we simply start from line number eight here we know that we were at zero comma one so we were at zero comma one so we return back to this node like this and for this node we just went to its left and came back so now we'll go up so first we update line number here because we are leaving this dfs so now there will be one more method on the call stack we are going up so row will decrease so from zero it will become minus one like this it means from zero comma one now we have went to outside the boundaries of this matrix so it means row is less than zero so we need to return back because this condition comes out to be true it means we are returning back to zero comma one now so this method will be removed from the call stack we will reach to this method we simply start our execution from line number nine here and at that moment row was zero and column was one so we come back to this zero comma one like this so with this line we went up and then came back so now we'll go towards right so first we update the line number here which is 10 because we are leaving this dfs we are going towards right now so there will be one more method on the call stack as we are going on the right column will increase so from one it becomes two row remains the same so we are going towards right it means we are going to zero comma two here and here you can see that we have found a water so we need to simply return from this node because we have found water and this is actually stopping this land to go beyond that so we have encountered a water so we'll simply return back this method will be removed from the call stack execution point will reach here we'll start our execution from line number 10 because we had left at line number 10 so we come back to zero comma one because when we left this dfs we were at zero comma one so we came back to zero comma one so we visited left up right so now we'll go down here first we update line number here which is 11 then we will call this dfs again there will be one more method on the call stack if we are going down row will increase so from zero become one column remains the same here so we'll simply return because we have found the water here which is zero so we simply return back this method will be removed from the call stack execution point will reach here at line number 11 at that moment we were at zero comma one because now we are returning to zero comma one back like this so here you can see that for this node we went to its left up right and down and after that we are done with this node so after 11 this dfs will end it means this dfs will end so this method will be removed from the call stack and we go back to its previous dfs that we had left at line number 10 so we start from line number 10 and the value was zero comma zero so we are actually returning back to zero comma zero like this because we went to its right when we visited zero comma one here you can see that we executed dfs we went to right and now we are coming back so we have came back to zero comma zero so for this node now we need to go down so we'll update the line number here 11 there will be one more method on the call stack we are going down so row increases so it became one from zero and column remains the same it means we are going down we came here we are within the boundaries of this matrix so first four condition comes out to be false this land is not visited because value is false here and we have actually came to a land so it means all the conditions comes out to be false it means we are on a valid land which is adjacent to our previous land so first we mark this land as true so in the visited array at one comma zero we put a value true like this so we are putting this value true because in case if we return back to this node we can come to know that we have already visited this node now friend there could be a possibility that here we have one or here we have one so as we have reached to a land now we need to apply the dfs to its adjacent nodes as well because let's say here we have one and then we have one then one one one so this land would have expanded till the last row and last column so we need to apply this dfs now for this node in the four directions left up right and down to figure out whether this land is also surrounded by any other land or not so now first we go to the left so it means we are going in this direction now so we update line number here eight there will be one more method on the call stack where column will decrease it becomes minus one and row remains the same so it means we have went outside the boundaries of this matrix where column became minus one which is less than zero so this condition comes out to be true and as it is a or in all the conditions so if any condition comes out to be true we simply return so we simply return back to one comma zero here so this method will be removed from the call stack we reach here at one comma zero and we start our execution from line number eight we just went to the left of one comma zero so we are returning back to this node like this so now we actually go up so first we update line number here which is nine and then we are leaving this dfs so there will be one more method on the call stack we are going up so row decreases so from one it became zero so it means we have reached here so friends here you can see that from this node we actually went here so for this node this one is also adjacent so when we reached here we know that we have already visited this node so how we can figure this point out is we can simply look in the visited array at zero comma zero we find a value true so we are in the boundaries of this matrix so first four conditions comes out to be false but here you can see this condition visited row column this comes out to be so it means this land is already visited we need to come back so we simply return from this dfs execution point will reach here we'll start from line number nine and at that moment we were at one comma zero so we come back to one comma zero because we are returning from zero comma zero back to one comma zero here and for this node we just went to up and came back so now we go towards right we update line number 10 here there will be one more method on the call stack so we are going now towards right here where value of column will increase so from zero it became one we reached here so in this dfs we are now at one comma one so we reached here now here we have encountered a water so this condition comes out to be true so we simply return because as we are encountering water we need to return back this method will be removed from the call stack we come back to previous dfs we start from line number 10 so we come back to one comma zero like this and now we go down we just visited the right now we go down so we first update line number here which is 11 that we are leaving this dfs at line number 11 and now there will be one more method on the call stack we are going down so row will increase so from one it became two and column will remain same so with this dfs now we restore two comma zero here and as we have encountered a water here so this condition comes out to be true so we simply return back so this method will be removed from the call stack execution point will reach here we start from 11 and at that moment we were at one comma zero so we come back to one comma zero here and for this node we visited its left up right and down and after that this dfs will end so for this node we have visited all the directions so this will be removed from the call stack we reach back to this dfs we start from line number 11 and at that moment we were at zero comma zero so we come back to zero comma zero here so here you can see that we started our dfs with this index zero comma zero and after traversing recursively all its adjacent node we are returning back to zero comma zero which means that we have visited left up right and down so the last direction we visited was down here and we came back so after this line this dfs will end which signifies that we have visited all the lines connected horizontally and vertically so we'll return from this dfs so this dfs will be removed from the call stack and we will simply go back to the method which called this dfs at the start here and this is our condition as of now that we have visited this one this one and this one and we have found one connected component which is our island so we'll increase the number of islands value because we have just found one island so it becomes one moving ahead so now we are done with this node zero comma zero so we'll increment j j becomes one we go to zero comma one here because there could be a possibility that from here only another land starts or another island starts so here first we check that whether the value is one or not so here you can see the value is one but we also check that whether we have already visited this land or not because in our previous dfs we started here then we visited this land and then we visited this land so we know that we have already visited this land because value is true here so therefore this condition comes out to be false because we are going only to those lands which are not visited here we have just visited this land in our previous dfs so this condition will prevent going into another dfs call so the condition in if block comes out to be false now we'll increment j j becomes two so we are on zero comma two here you can see that we have landed on water so it means we need to skip this element because we need to identify an island so an island can only be formed by a land which is one so if we are landing on water it that it means that we need to skip this node and proceed ahead so this condition comes out to be false because value is zero here so friends here you can see that now we will go somewhat fast because whenever we encounter zero we'll simply move ahead because this conditions will come out to be false so we'll increment j j becomes three we'll simply skip because we have landed on water so now we'll increment j so j will go beyond the boundaries of this matrix so this condition comes out to be false so this for loop will terminate and the execution point will reach to the upper for loop because now we need to process the second row so first we increment i becomes one so now we are processing this row we are done processing this row so we start from j equal to zero so it means now we are on one comma zero we noted we have found one land denoted by one so this condition is true but we also know that we have already visited this land so this condition comes out to be false we'll increment j j becomes one so now we are processing this value at one comma one so friends here you can see this zero this zero zero zero zero this phi will be skipped because we are landing on water and as we are traversing this matrix we will now encounter five waters so we will go over this somewhat quickly so this is a basic traversal of matrix we have found water so this condition comes out to be false j becomes two this condition comes out to be false j becomes three so this condition comes out to be false so now we are done processing the row one so we go to row two we'll increment i i becomes two we'll start with j equal to zero so we are at two comma zero now this condition comes out to be false j becomes one this condition comes out to be false because we are landing on water so we need to skip it j becomes two so friend now you can see that we are on a particular land because this condition comes out to be true and if we go to the visited area i comma j which is two comma two here we have a false value it means we haven't visited this land so both the condition comes out to be true so it means as we have found a new land we'll apply dfs on top of it to actually figure out its adjacent lands horizontally and vertically so this dfs will be called with two comma two so on the call stack there will be dfs with row is two and column is two like this so now we'll apply the same algorithm which we applied to this node we are in the boundaries of the matrix visited is false and the value at this row and column is one so all the condition comes out to be false so first we mark this land as visited by assigning a value true to the visited 2d array at two comma two now we simply go to left of two comma two so when we go left row remains same and column decreases so we are leaving this dfs so first we update line number here which is eight now on the call stack there will be one more method by name dfs where row remains the same and column decreases so we are at two comma one now it means we are going towards the left of two comma two which is two comma one here we know that we have landed on water so we simply return so this dfs will end execution point will reach here so this dfs we had left a line number eight so we start from line number eight we have encountered the water so we simply return so we come back to two comma two because at this moment row and column were at two comma two so we come back to two comma two now we go up so first we update the line number here which is nine there will be one more method on the call stack if we are going up row decreases column remains same so row became one from two it means we have went here one comma two here you can see that we have landed on water again so we simply return so we come back to two comma two now this method will be removed from the call stack we'll start from line number nine we come back to two comma two and now we are going towards right so first we update line number 10 here there will be one more method on the call stack if we are going towards right row remains same and column increases so from two it became three and we are going to two comma three now here here you can see that we have again found a water so we simply return to two comma two we start from line number 10 we return back to two comma two and now we simply go down so first we update line number 11 here because we are leaving this dfs at line number 11 there will be one more method on the call stack we are going down so row will increase so from two it became three and column remains the same we are at three comma two and here you can see we have found a water so we simply return back to two comma two this method will be removed from the call stack we return to this dfs at line number 11 so we return back to two comma two and here you can see that we have visited all the adjacent nodes of this land so this dfs will end now because there are no more lines to execute so now we'll go back to the method which actually called as dfs at two comma two so this is the condition so here you can see after we finish visiting all the lands adjacent to this land horizontally and vertically we know that we have found one more island so we'll increase the value of number of islands which becomes two now we'll increment j j becomes three so you can see this is a water water water water so for the next four iterations we'll simply skip these values so we'll go over this quickly this condition comes out to be false now we are done with processing the row two so this for loop will terminate we'll increment i, i becomes three because now we are processing the last row we'll start from j equal to zero this condition comes out to be false j becomes one this condition comes out to be false j becomes two this condition comes out to be false and at the end j becomes three that we have found a land which is actually not visited because value is false it means that now we can apply dfs on top of this land so we'll call dfs we pass the value of i and j which is three comma three there will be one method dfs with row as three and column as three like this we are within the boundaries of the matrix and we haven't visited this land so all the condition will come out to be false so we will first mark this land as visited by assigning a value true in the visited array at row three and column three and now we'll perform the same steps we go left up right and bottom so we'll go over this quickly because we know that we are performing the same steps what we did here and here so we need to keep this thing in mind when we are going to the different directions so first we are going left so we update line number here there will be method on the call stack we are going left so column decreases so from three comma three it became three comma two we have reached here now this is a water so we'll simply return back to three comma three we start from line number eight we come back to three comma three and now we actually go up we update line number here and there will be one more method on the call stack as we are going up so row will decrease so it became two comma three now we reached here this is the water so we return back to three comma three we start the execution on line number nine we come back to three comma three because value of row and column is three comma three in this dfs now we go towards right we update line number 10 here because we are leaving this dfs and there will be one more method on the call stack we are going towards right so column will increase so here you can see that we have gone outside the boundaries of this matrix so value of column is actually equal to grid of zero dot length which is equal to four it means we are outside the boundaries of this matrix so we'll simply return we return back to three comma three we start the execution at line number 10 like this and now we simply go down so we update the line number here 11 as we are going down row will increase and we have went outside the boundaries of this matrix so here now value of row is equal to grid dot length which is four so we'll simply return we start the execution from line number 11 and we return back to three comma three and after that there are no lines to execute so this dfs will also will be removed from the call stack and we go back to a method which called is dfs at row and column three comma three so this is the condition so we know that we have visited one more island so we'll increase the value of number of islands so it becomes three will increment j so j will go beyond the boundaries of this matrix so this for loop will terminate and as we have visited the last row will increment i so i will also go beyond the boundaries of this matrix it means we have visited a complete matrix and at the end after visiting all these islands will simply return the value three because there are three islands this this and this here you can see we have visited this this and this so friend this was all about it how we can solve the number of islands problem i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we will discuss about hashing data structure and we will see a basic introduction to hashing so friends before we start in case if you are new to my channel then please subscribe to my channel so that you never miss any update so what do we mean by hashing so before discussing that we will see that why we actually need a concept called hashing so usually when we need to perform any search operation we have few options such as linear search where what we do is let's suppose we are given with this array of 10 elements and let's suppose we want to search for a particular element for example let's say 10 so in linear search what we do is the value which we want to search which is 10 we compare it with each and every element of this array and when we reach here we find that 10 is there in this array and we simply say the value 10 is found in this array also let's suppose if we want to search for a value let's say 20 so what we need to do here is we need to compare 20 with each and every element of this array and after comparing with the last element if we don't find 20 in this array then we simply return that 20 is not found so here the problem is in case if the key which you want to search is not present in this list or array then the time complexity basically goes to O of n because we need to compare the key with each and every element and then only we can come to know that whether the key is present in this array or not so this is one problem with the linear search the other form of search we have is binary search now in binary search what we have is let's say we are given with this array of 10 elements in binary search the array we have is already sorted so here you can see here the elements are sorted in ascending order so when the elements are sorted in ascending order we basically use this property to make this search quicker so for example let's say if we want to search for an element 8 so here we don't compare the key which we want to search with each and every element of this array as we know that the array is already sorted we take the lower index which is zero we take the higher index which is nine and using these two indexes we try to find the mid index so here we simply do nine plus zero divided by two which give us 4.5 and if we take the integer value the mid value will come to four so what we do is whatever the value is at the index four which is 10 we simply check that whether eight is less than 10 or greater than 10 we know that eight is less than 10 so it must be lying somewhere to the left of mid index because here we know that the elements of array are already sorted so what we do here is we simply discard the right sub array completely because we know that searching in elements after 10 will never give us eight it will only come before 10 so we simply discard the right sub array so after discarding the right sub array our array becomes from zero to four where we take zero as the lower index and four as the higher index we do four plus zero divided by two we get two as mid index so whatever the value is at mid index which is five when we compare five with eight we know that eight is greater than five and as the array elements are sorted we simply discard the left sub array because we know that eight must be lying to the right of five so now after we discard the left part our array becomes of three elements from two to four and then we again find the mid index we do four plus two which is six and if we divide it by two we get three so whatever the value is at third index which is mid we see it is eight we come to know that we have found our key and here you can see that compared to linear search binary search works pretty much faster when the array elements are sorted so friends with binary search with each iteration we simply discard half of the array because we know that the element which we want to search can be found at three places one is at the mid index or it can be on the left sub array or on the right sub array so if it is on the left sub array we simply discard the right sub array and if it is on the right sub array we simply discard the left sub array so here you can see on each iteration we are discarding half of the array so the time complexity of binary search comes out to be O of log n which is pretty much faster than O of n but here the problem still remains which is is there any data structure or is there any search technique which gives us a time complexity of O of one because searching an element in linear search takes O of n which is not feasible for the search operation and for the binary search takes O of log n but here we have this constraint that element should be sorted which is usually never the case we have always elements in unsorted form and if we want to sort them we need to apply sorting algorithms whose complexity can reach to n log n so after we sort the elements then our search becomes faster and we get O of log n so how can we achieve a time complexity of O of one so if you see one solution is if we take array data structure now why array because array can be used to provide O of one searches using indexes so let's suppose if we are given with these elements 6 1 3 5 9 7 and let's say if we want to search in these elements and we want that the search should be of O of one time so what we can do is among these elements we will see which is the highest element which is 9 so what we can simply do is we can create an array whose last index is 9 which means we create an array of 10 elements where the last index is 9 and what we do here is we take 6 and we store 6 at sixth index 1 at first index 3 at index 3 5th index 5 9 at index 9 7 at index 7 so we simply store all these elements into their respective indexes in an array and let's suppose if we are given let's search for a value 3 so what we can do is we simply go to third index of array by accessing the array with index 3 and we see whether 3 is there or not so this operation takes time complexity of O of one because we can access array elements directly so here at third index we see that there is a value 3 so our answer is found and let's say if we want to search for 0 so what we do is we go to 0th index and we see there is no value so our answer is not found so friends here you can see that arrays can give us a time complexity of O of one when performing the searches using their indexes so the time complexity of this scenario will be O of one which is pretty much fast so let's suppose we take one more example let's say we are in a classroom and we have these 30 students so what we can simply do is we can assign a roll number to each and every student and we can create a data structure which is array of size 30 where last index is 29 and we can assign the indexes to each and every student and let's suppose we are storing a student object on each and every index so here when these students are sitting in a classroom the teacher can directly go to a particular seat let's say 5 and let's say the teacher has a device where she can directly type 5 and gets the information for the student that the student name is john these are his marks in particular subject and all of the information for the student john and similarly if she searches for 29 she can get the information for Tina so here also we can use array data structure and we can get the time complexity of O of one so to this type of storage we simply call direct addressing moving ahead now whatever the example we saw there array was a perfect data structure for searching in O of one times now where the problem will still arise is let's say if we want to store other card number which is of 12 digits or you can also take an example of storing the social security number in an array so here if you see that the other card number is of 12 digits and it gives an identity of a particular citizen of India based on his other number so the problem is if we take an array to store the other card number then if you want to store this big number into an array which is nothing but direct addressing with its index then there would be a huge array to store all the other card numbers so this is one problem that we need to create such a huge array where the other card number matches the index of that array and the second problem is let's say if the other card number is designed with 12 digits and we have created a huge array to store the other card number and let's suppose we have only distributed 10 to 12 other card to the people and if we try to store those other card numbers into the array then after storing we will see that most of the memory of the array elements will remain unutilized invested so this is the problem with arrays where we can't use direct addressing because we need to store such a huge number so to basically address these problems hashing was introduced now what is hashing so here you can see that hashing is a technique which is used for storing retrieving and removing the information as quick as possible and how do we perform the hashing is here it is a process of converting a arbitrary size key into a fixed size value so here what we are simply saying is let's suppose we have our keys which are huge let's say the other card number or social security number so what we can do is we can't directly store the key into the respective indexes of the array because that problem we discussed in our previous slide so what we do is we take that particular huge key and we try to convert that key into a fixed size value and how we perform this conversion is this conversion is done by a special function which we call hash function so we will discuss hash function in our upcoming videos but for time being we can think the let's say if we have array of thousand elements and we want to store a 12 digit other card number so what we do is we take the other card number which is of an arbitrary size or a huge size we pass that number to our hash function and this hash function will give us a fixed size value let's say if you are taking the size of the array where we want to store the other card number is of thousand then it will give us a fixed size value between zero to thousand and we can simply use that fixed value and store that particular other card number so this conversion of a large key into a fixed small size is done via hash function so we will discuss this hash function in detail in our upcoming videos so for time being you can simply think that hashing is a technique which is used for storing retrieving and removing the information as quick as possible and the operation which hashing supports such as storing retrieving and removing an information have average runtime complexity of o of 1 so friends in this video we saw that why we actually require the hashing technique or why we require a hashing data structure because we need average runtime complexity of o of 1 when we want to store retrieve or remove any particular piece of information so in our next video we will see that what are hash functions and how it helps in converting a huge size key into a fixed size value so friends in case if you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so friends in our previous video we discussed about what is hashing so in this video we will see that what are hash functions so friends before discussing about hash function in case if you are new to my channel then please subscribe to my channel so that you never miss any update so in our previous video we saw a basic definition of what is hash function so a hash function simply takes an arbitrary size key and provides fixed size value also called as index so here using an hash function we can take a key of any size and once we passed that key to hash function it returns us back a fixed size value which we also called as index now this fixed size value is basically small and can be taken up as index and using that index we can store the key which we want and also by using this hash function we can even retrieve that key so we'll see the importance of hash function more in our upcoming videos so for this video you can simply think of hash function is let's suppose we are given key of any size what we do is we simply pass this key to our hash function and whatever key we passed hash function return as an index which is of fixed size now using this index value what we actually do is we simply store this key into a smaller size data structure and we can perform storing retrieving and removing of this key very fast we will see those implementation details later in upcoming videos so for timing you can simply think that to our hash function we pass in a key and it returns back as a smaller fixed size value index we will see its usage in greater detail in our upcoming videos so friends the hash function can be of any type you can basically write your own hash function where what you do is you simply take a key and it should return you back a smaller fixed size value so that you can use that fixed size value and store that huge key into a data structure so that the retrieval storing and removing of that particular key becomes faster and how does hash function help us in achieving a time complexity of O of 1 we will see later in upcoming videos so one such typical hash function which is mostly used in hashing data structure is modular hash function so what this hash function does is the modular hash function simply takes a key and a size now what it returns is remainder by dividing key by size so usually the remainder which hash function return us back is used as an index to store the key in an array of the provided size so here you can assume that key has a large value which cannot be taken up as an index of an array which we discussed in our previous video that it creates the problem so what hash function will help us in doing is let's say we take a smaller size array so when we pass the key and the size hash function will return the remainder by dividing key by that size and whatever the remainder is returned that remainder is taken up as an index to store the key in an array of provided size so here you can see instead of using an array for direct addressing which we discussed in our previous video here what we do is we simply take an array of smaller size and let's suppose the key has a very large value now how we can store that key into the array of small sizes we simply take the key we divide the key by the size and whatever the remainder we get that will be taken up as an index to store this particular key so let's see how modular hash function help us in storing large keys into a smaller size array so here we usually take the hash function as h of key which is the hash function which takes in a key and usually returns us back an index and this hash function can be any implementation you provide but here we are simply discussing the modular hash function so here we take the key we do modulus by size which is key mod size now this modulus operator always returns us back the remainder when we divide the key by size so here let's say these are our keys which we want to store now here you can see the keys are 5 1 10 26 and 99 so we can't take an array of length 100 to store only five elements for the direct addressing so what we do is we simply take a smaller size array let's say of 10 elements now size of this array is 10 now how we store these keys into this array is we take the key we pass into the hash function so here 5 modulus 10 which is 5 is the key modulus size which is 10 so if we divide 5 by 10 we get remainder as 5 because 5 is not divisible by 10 so the remainder we get is 5 so here we simply take this key go to the fifth index here this is the index which it returns so we go to the fifth index and we store 5 now we take 1 so 1 when we divide 1 by 10 we get remainder as 1 so we take this key go to index 1 and store 1 now we take key as 10 so when we divide 10 by 10 we get remainder 0 because 10 is divisible by 10 so here you can see that here 10 cannot fit into this array if we take it as a direct index so this hash function is helping us to get a smaller index so when we do 10 mod 10 we get 0 so here what we do is we simply go to the 0th index and we store 10 here similarly if we take a value 26 if we do 26 mod 10 it means if when we divide 26 by 10 we get the remainder as 6 because 20 gets divisible by 10 and we get the remainder value as 6 so here we go to sixth index and we store 26 there and similarly when we take 99 when we do 99 mod 10 or when we divide 99 by 10 we get remainder as 9 so here we go to ninth index and we store the value 99 so friends here you can see that here instead of doing the direct addressing of the key with array index we are using a simple hash function and whatever is the value of key we don't care we simply divide it by the size and whatever the remainder comes out we simply take that as an index and we store those values at that particular index so friends here we used the modular hash function to store these key elements into an array of fixed size so similarly we can search a particular key based on our hash function so if we take this example let's say if you want to search whether 26 is present or not so when you are storing this value in this array we used modular hash function so similarly when we want to search what we do is we take the value which we want to search we pass to our hash function it returns us back an index we simply go to that index and we simply see that whether that key is present or not so here in this case 26 goes to the hash function and the hash function returns the remainder as 6 so we go to the sixth index we see there is a value we compare this value with the key which we want to search and we see that 26 is present so now here you can see the hash function is helping us store the keys which are very large in size and here you can see that for storing 99 we didn't take an array of 100 size elements we simply took an array of 10 elements and we stored these values in the array so friends here hash function can be implemented in many different ways so one of the most popular hash function which we saw here was modular hash function now friends one more problem arises here is as we are mapping large keys into a smaller fixed size array there could be a possibility that let's say if you want to store one more value as 109 so when we do 109 mod 10 we get remainder as 9 and when we go to ninth index for storing 109 we already see that there is a value 99 so now there is a problem that what do we do with initially stored 99 value because in array we can store only one value at a time so we will see these problems in greater detail in our upcoming videos the idea which you are seeing here is using a smaller array and storing the larger size keys this data structure if we implement in such a way using a hash function such data structure are basically called as hash table so in our upcoming video we will see what is hash table so friends i hope you find this information useful and in case if you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update hello everyone so in this section we will discuss about a basic introduction to hash table in our previous video we discussed about what is hashing and what are hash functions so in this video we will look into a data structure which is hash table and we will see the concepts which we discussed in our previous videos like hashing and hash function and we'll see how they are used to implement a hash table so before we start in case if you are new to my channel then please subscribe to my channel so that you never miss any update in one of our previous video we discussed that array can be used to store retrieve and remove an information with the time complexity of o of one based on indexes but we also saw that array had a limitation while implementing the direct addressing strategy via indexes so we introduced the concept of hashing now based on those concept when we implement a hash table we basically take a generalized form of an array so internally the data structure for implementing hash table is pretty much an array but it is used with the concepts of hashing and hash function now what do we do with the hash table is the data is stored in the form of key value pair so in our previous video we discussed that how a key is passed to a hash function and an index is returned so based on the index we store this key value pair so basically in a hash table we simply put the data in form of key value pair where we take the key we pass it to the hash function and hash function returns as an index so this index is nothing but an index of an array where we simply store our key value pair so this key can be a huge key but our hash function takes that key and returns us back a fixed and a small value which is nothing but an index of our array now what we do is we take that index and we store the key value pair in the array and the primary operations which are supported by hash table are first is the put which takes in a key and a value now what does this operation does is it adds the key value pair against a unique key so here our key is unique and if we try to add a different value with the same key then that value gets updated and the older value will be removed so here the key is unique because this key usually goes into this hash function and based on the hash function calculation our index is returned and on that index this key value pair is stored similarly after storing when we do get then the value is returned for that provided key so here this key goes into the hash function our index is returned and based on this index whatever the value is stored in the array that value is returned for that provided key and the third operation is removed where we pass the key so what it does is it removes the key value pair from the hash table so these are the three primary operations supported by hash table and here if you see all these three operations use a hash function and we will discuss all these three operations in greater detail in our upcoming lectures these all three operations internally use the hash function which takes in a key returns as an index and based on the index put get and remove operations are performed so all these three operations are pretty much fast the average running time of all this operation is o of one and if you see in our java collection framework we have a hashmap class which is pretty much same as the hash table class so if we want to deal with key value pair then we simply use hashmap class and if we want to deal with only keys then we use hash set so here if you want to store any data in form of key value pair then we simply take the help of hashmap class in java which is nothing but an hash table but if you only want to deal with the keys and not with the value then we simply use the hash set class and the idea behind both the classes to store the keys remains the same which we discussed here so for now let's see a simple hash table where we have provided with the hash function as keymod size and size is nothing but the length of this array so this array is the internal data structure to implement a hash table so we simply call it a hash table only now let's say if we want to store these key value pairs in this simple hash table so what we do is let's say key is 5 and the value is john so when we try to store this key value pair in a simple hash table what we do is we take the key we pass it to hash function and this hash function returns as an index so we simply go to that index and store this key value pair so for example 5 mod 10 so when we divide 5 by 10 we get remainder as 5 so this is our index which is being returned by the hash function so here we simply go to the fifth index and we simply store key value pair so this array can be taken up as array of key value pairs which can be our own type object which takes key and a value now if you want to store 1 comma tom so 1 divided by 10 gives remainder as 1 so here we go to the first index and we store 1 comma tom if we want to store 10 comma james we do 10 mod 10 so we get remainder as 0 so we go to the 0th index and store 10 comma james there for this key value pair we get 6 as the remainder so we go to the sixth index and we store 26 comma tina for this key value pair so if we divide 99 by 10 we get remainder as 9 so we go to the 9th index and we store 99 comma sana there now if we take the last value 105 mod 10 will give a remainder as 5 so friend this is a simple hash table so now here you can see if we try to go to fifth index here you can see that we already have this value 5 comma john now the problem is what should we do with this key value pair so whenever this kind of situation comes where we are simply storing key value pair in a particular index and we already encounter a key value pair there this concept in hash table is called as collision because now there is a collision between these two values that what should we do so friends here you can see that these kind of situation usually arrives when we implement a hash table because here you can see the size of this hash table is only 10 and the keys which we are trying to store is more than 10 so usually after storing few values a hash table simply encounters this collision frequently so this is a simple hash table so in our future video we will see that how this hash table can be implemented to resolve these collisions and also friend there are strategies to resolve these collisions which we'll discuss in our upcoming videos so friends i hope you find this information useful and in case if you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so in our previous video we discussed about a simple hash table we saw what hash table does and we also saw that when we use hash function to store the key value pair in a hash table there will come a situation when there will be a collision so in this video we will see that how we can resolve that collision using a collision resolution technique which we call as separate chaining so in our previous video we saw a simple hash table where we had this array of key value pair and of size as 10 our hash function was key mod size where we divided key by size and whatever was the remainder we used that remainder as an index to store these keys with its values in this array so five mod ten gave value as five so at the fifth index we stored five comma john at the first index we stored one comma tom at the zeroth index we stored 10 comma james because when we do 10 mod 10 or when we divide 10 by 10 we get remainder as zero on the sixth index we stored 26 comma tina on the ninth index we stored 99 comma sana and when we encountered a value as 105 so our hash function returned us a value as five because when we divide 105 by 10 we get five as the remainder so when we went to fifth index we saw that there is already a value stored five comma john at fifth index so this resulted in a collision which we discussed in our previous video now in this video we will see that how we can resolve this collision using a strategy called as separate chaining so friends what we do in separate chaining is in case if we encounter a collision let's say when we try to store 105 on the fifth index we already found that value as five comma john so what we do is when this collision occurs then at the fifth index we simply store both the values in a list so that list is nothing but a simple linked list where whenever we encounter a collision we simply add that element in that list which belongs to that particular index so when we try to store many values which are huge in a small fixed size array then there will be a situation where we encounter frequent collisions so we simply add those elements into the list which belongs to that particular index so when this list grows it looks like a chain so therefore the resolution strategy is separate chaining where with each index we create a separate chain or linked list to store the values which are getting collided so let's see an example so friends in our previous videos when we discussed about the linked list we saw that how we can create a singly linked list doubly linked list and circular singly linked list so if we take the example of singly linked list we saw that there is a head from where basically the singly linked list starts and each node basically points to the next node in the list and the node which is at an end points to null so here instead of taking the array of key value pair what we do is we take the array of hash nodes so here if you see let's say if you want to store five comma john we first pass the key into the hash function we get the index which is five so instead of directly storing at this index we create a hash node so this hash node is pretty much similar to the singly linked list list node where we had a data and a reference to the next node so here we simply add one more value which is the key so here our hash node has three attributes one is the key other is the value and the third is the reference one next hash node in this list or chain when some collision occurs so this terminology you can simply take it as hash node so in our upcoming videos we will discuss in greater detail what is hash node now let's say if we want to store one comma tom so at the first index we store one comma tom in a form of a hash node at the zeroth index we will store ten comma james and similarly the other values but when we encounter one zero five comma mary so our hash function is returned our index is five so here when we go to index five we see that there is already a hash node available having key as five value as john now here we have encountered a collision so what we do is as this hash node can be treated and converted into a list or chain what we do is we can use its next reference and we can simply store one zero five as key value as mary and its next is pointing to null so here whenever we encounter a collision we keep on adding those elements in this chain which we also say that it's a form of a linked list so by separate chaining technique we can resolve these collisions and we can store the values in the form of a linked list when any collision occurs so we'll see the importance of this hash node and this linked list in our upcoming videos when we will implement a hash table using the separate chaining technique so friends i hope you find this information useful and in case if this information is useful to you then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so in this video we will discuss that how we can represent a hash node in a hash table so in our previous video we discussed about one of the collision resolution technique which was termed as separate chaining and when we discussed about the separate chaining we saw that how we can remove the collisions via a hash node and create chains where one hash node is pointing to other hash nodes so let's see the structure and representation of a hash node in a hash table but before we start in case if you're new to my channel then please subscribe to my channel so that you never miss any update so here a hash node class in hash table consists of three data members now the first one is the key so the key is basically a unique value which help us in storing the data and here this case simply represents a generic type in java the second data member is value which is the actual data which is being stored in a hash table in a location which is being computed by the key and the hash function so here v simply signifies the generic type it can be any type so k and v can be any type and the third data member is hash node next so it simply refers to the next hash node in a chain of hash nodes so chain of hash node is nothing but a list of hash nodes which help us in resolving the collisions where one hash node simply refer to the other hash node and they form a chain so here these are the three data members and if we see the symbolic representation of it then hash node consists of three things the key which is unique and which help us in storing the value via hash function and the hash node simply points to the next hash node in a list when there is a collision so here hash node is very much similar to the list node which we discussed in our singly linked list videos the only difference is in the list node there was value and a reference to the next node but here in hash node we also store the key so we will see why this key value pairs are stored and how the primary operation in a hash table are implemented and if we see a representation of it it looks something like this that it has a key value and a reference to the next hash node in the list of hash nodes so friend this is how we actually represent a hash node in a hash table so usually when we implement a hash table then the hash node is nothing but a private class inside a hash table which help us in implementing the operations which are being performed by hash table so those operation we will discuss in detail in our upcoming videos i hope you must have liked this video and in case if you are new to my channel then please subscribe to my channel thanks have a nice day hello everyone so in our previous video we actually discussed about that how we can represent a hash node in a hash table so in this video we will see that how we can implement a hash table via separate chaining collision resolution technique so here in order to implement a hash table i will be creating few videos which will be in series so you can consider it as a part one of how to implement a hash table but before we start in case if you are new to my channel then please subscribe to my channel so that you never miss any update so friends in order to implement a hash table we will first look into some of the terminology which we will be using frequently in upcoming videos to understand different parts of hash table so here as we already discussed that hash table is nothing but a generalized form of an array now let's say if you take the example of this array whose length is 10 and having index value from zero to nine so when implementing a hash table via separate chaining collision resolution technique we discussed that we actually use the hash node so here in order to store key value pair we simply take this as an array of hash nodes so to this array we simply call it as buckets and we denote it something like this that each container at a particular index is termed as bucket and this array basically stores hash nodes which has key value pair and a reference to the next hash node and here we will also create a variable which would be number of buckets so this number of buckets is nothing but the length of buckets array which is also called as capacity of hash table so for example if we want to store a key value pair let's say our keys of integer type having value as 10 and a value of string type which takes in a value as james and if we want to store at 0th index what we do is the 0th index bucket simply points to a hash node showing key value and has a reference to next node so currently if there is only one element then the next node will point to null similarly let's say at index 1 if we want to store a key value so it would look something like this so here you can see that way we are storing this key value pair is via hash function which we already discussed in our previous video and which we will be discussing in our upcoming videos also that here you can see the key is 10 and here let's say if you take the hash function as key mod the number of buckets which is also the length of this array then we get 10 modulus 10 which will give us a remainder 0 and whatever we get from the hash function it is nothing but our index so at the 0th index you can see that we have stored a key value pair like this and similarly at 5th index we are storing a key 5 with a value as john so here 5 when divided by 10 gives remainder as 5 only so at 5th index we are storing a key as 5 and we usually term it as hash node which we have already discussed now let's say if we want to store a key of 105 so when we divide 105 by 10 we get remainder as 5 which would be the value returned by our hash function so if we go to index 5 we will see that there is already a value so there is a collision so in order to resolve this collision we are taking help of hash nodes because here you can see that the third data member is nothing but a reference to the next hash node so here we can use the next reference to store this key value pair which also corresponds to 5th index so here when we store this key value pair in form of a linked list the first element is simply treated as head and this linked list is also termed as chains because we are discussing separate chaining collision resolution technique and which is being implemented via chains so here when a collision is encountered the key value pairs are stored in a form of chain and this chain can be the way you want to implement you can simply add the newly inserted node at the end or at the beginning or you can insert in a sorted form like based on the keys that 5 comes before 105 comes later and then 205 305 something like that so you can insert multiple key value pair which is also called as hash node in a way which you want and similarly we can store other values like this also friends here you can see that length of this array is 10 which is also a value stored by number of buckets and which is also called as capacity of our hash table but here you can see that this hash table currently has 1 2 3 4 5 and 6 hash nodes so the size of the hash table is 6 because it has hold 6 key value pairs and the capacity is of 10 so this is the difference between the capacity and size so when we talk about size you can think of it the number of key value pairs inside a hash table and when we talk about capacity number of buckets or length of buckets we are simply talking about the array length so friends these are the few terminologies which are being associated with hash table so here when we implement a hash table you can see that we have three members here one is the buckets array which is of type hash node the second value is number of buckets which is also the capacity of our hash table and the third variable is size which is the number of key value pairs being stored in a hash table so here you can see that hash table is a constructor which takes in a capacity so when we create an object of hash table we need to provide it what's the capacity of our hash table it means we are providing that how many buckets the hash table will have and here you can see that internally our hash table is using hash node class so which we already discussed that it has a key and a value and a reference to the next hash node so here you can see that we are taking key as integer and value as string so this can be any generic type so for the understanding and demonstration i will be using the key as integer and the value as string so basically most of the things remain same when we take any generic type of key and value so here after taking key as integer and value as string and the third member is a reference to the next hash node which help us in storing the key value pair in a chain when the collision occurs so here what we do is at the start we simply call and create an instance of hash table and let's say we pass capacity of 10 to our hash table so it looks something like this that capacity value is 10 and in the hash table constructor what we do is we assign the capacity to number of buckets so it becomes 10 and then we create an array of hash node and we provide the capacity so it looks something like this that internal data structure is array of type hash node it is being termed as buckets and each compartment here you can see is a bucket which holds the hash nodes in a form of a chain so here when we create this array at the start every index or bucket points to null because there are no hash nodes currently into this array of hash nodes so at the start size remains zero because we currently don't have any key value pairs inside this hash table so size is zero so friends in this video we saw a initial implementation of a hash table via separate chaining collision resolution technique in our upcoming videos we will see that this hash table has many operations where we put a key value pair we remove a key value pair and we can get a value based on a key and there are many other operations which we will be looking into our upcoming videos so this is just a basic and initial implementation of a hash table so now let's go to our intelligent id and we'll simply code this part into the id i hope you have find this information useful and in case if you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so in our previous video we discussed about a initial implementation of hash table we saw the structure of hash table and we also saw that how it uses hash nodes internally now in this video we'll simply code for the internal structure of hash table and in upcoming videos we will see the different operations performed by hash table and then we'll test its working in the main method so here i have created one class as hash table now as we discussed hash table will consist of few instance variables one is this array of hash node which we term as buckets and as it is using the hash node class internally here we will create a inner class hash node and as we already discussed that this hash node class will have three members one would be our key so this can be generic type the second member would be value and this can also be any generic type so here for the demo purpose i am using the key as integer and value as string and the third member would be the reference to the next hash node and it will have a constructor which will take two things key and a value we will assign the key to this dot key and value to this dot value so here the hash table consists of an array of hash node which we called as buckets it also has an integer variable number of buckets which is also capacity and it also has an integer type size which is nothing but number of key value pairs in hash table or number of hash nodes in a hash table so basically in a hash table the number of hash nodes represents the size of the hash table and here we will provide a constructor to our hash table class so when we will create an instance of hash table it will simply call the parameterized constructor providing a default capacity so here we will create one more constructor which will take a capacity so here we can provide a customized capacity by calling this constructor and if we call this constructor it will create a hash table with a default capacity of 10 so here what we'll do is to number of buckets we will assign the capacity and now number of bucket is holding the capacity so what we'll do we will create the array of hash node whose length would be the value stored in the number of buckets so here when we'll create the instance of hash table let's say with the capacity we provide so the number of buckets will hold that capacity and the array of hash node will be of size which represents the number of buckets and usually at the start when there are no hash nodes in a hash table the size will be zero so this is what happens when we first initialize or create the instance of hash table now here you can see that this is the initial implementation of hash table so in a hash table there are many operations so one of the operation is that we want to know the size of the hash table that how many key value pairs are there so we provide a method as size and here we simply return the size one more method we provide is boolean we check whether the hash table is empty or not so we provide the method as is empty and here if size is equal to zero then we return true stating that hash table is empty and if size is not equal to zero we are returning false so friends in our upcoming video we will look into the primary operations of a hash table which is put which basically put a key value pair in a hash table so the parameters are key and value so this method basically takes in a key value pair and it simply puts that key value pair in our hash table so we will discuss about this method in greater detail in our upcoming videos so this is one of the primary operations the other operation is get so this method simply takes in a key and returns the corresponding value associated with it so for time being i am simply returning null to compile this method so here whatever the key value pairs are stored in hash table so if you want to get any value associated with a key we simply pass key here and we get its corresponding value and one more method is remove where we pass the key and that key value pair will be removed and the value associated with that key will be returned so when we call get the key value pair remains in the hash table we only get the value out of the hash table but when we do remove that key value pair is completely removed from the hash table and its corresponding value is returned so here these are the three main operations which are being performed by hash table and all these three methods have a time complexity of O of 1 which is the average time complexity of a hash table so friend this was basic and initial implementation of a hash table in our upcoming videos we will see all these primary operations in great detail so friend in case if you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw a basic implementation of a hash table we saw that hash table internally has an array of hash nodes and we also saw the representation of a hash node which contains key value and a reference to the next hash node so after creating a basic structure of hash table in this video we will see that how we can put a key value pair in a hash table and the strategy which we will be using for collision resolution would be separate chaining so friends before we start in case if you are new to my channel then please subscribe to my channel so that you never miss any update so here you can see that in our previous video we saw a basic structure of hash table where we can create a hash table by providing in a capacity which also signifies the number of buckets in a hash table so when we will call this line here you can see the hash table internally uses an array of hash node which we call as buckets and at the start each hash node at a particular index points to null so friends when we try to put a key value pair into the hash table there are various scenarios which comes into picture so the one scenario is when we take the key and we pass it to our hash function then that hash function return us an index so what we do is we simply go to that index and see that whether the hash node is pointing to null value or to any other node so in case if it is pointing to null then we simply insert key value pair in a form of a hash node and we simply assign that hash node to that particular index and in case if there are multiple hash nodes already present then what we do is we first check that whether that key is already present in the sequence of hash nodes or not and if the key is already present then we simply update the value we don't insert a new key value pair and one more use case is let's say if there are multiple nodes but the key value pair is not present so what we do is we simply create the hash node from the key value pair which we want to insert and we simply insert that hash node at the beginning of the list which is being formed by the hash node at a particular index so currently you see all the hash node at a particular index is pointing to null it means that each list which will be getting formed at a particular index starting node is null because there are no key value pair currently in this hash table and at the start we have this number of buckets value is 10 because we are providing the capacity to be 10 and currently as there are no elements so the size is zero now let's say if you want to put an integer key and a string value so here key is 105 and value is john so at the start here you can see that key is very long and we need to accommodate this key somewhere in this small buckets array so that when we put this key value pair and when we want to find that key value pair it should be pretty much fast so what we do is we simply pass this key to our hash function so here we will take the example of modular hash function which will take the key and will simply divide the key by buckets.length or number of buckets and whatever is the remainder that would be our index which will be written by this method so we are using this method as our hash function which is nothing but the modular hash function so if we divide 105 by 10 we get the remainder is 5 so that 5 will be returned from this method and will be our bucket index now what we do is we simply access the hash node at this bucket index so we go to the fifth index and we access this hash node so currently you can see it is pointing to null so which simply means that there are no hash node at this index and as this is pointing to null it will signify the head is pointing to null because at this index we are storing a hash node so this hash node has next reference which can store other hash nodes and if there are many hash nodes then the first hash node is always our head so this is also what we already discussed when we discussed about the singly linked list where we normally had a list node with a value and a reference to the next node so here the only difference with hash node is it has key value pair and a reference to the next hash node so here you can see currently head is pointing to null which means at this index there is no hash node so what we can do is we can increment the size because we can directly put this key value pair here at this point so first we create the hash node with key as 105 value as john and when we create a new hash node the next always points to null so for us now what we do is whenever we insert this key value pair or hash node into this buckets array we can use different strategies one would be that we can insert this node at the beginning of the list or we can insert this node at the end of the list or we can store this node based on some sorting logic such as the ascending order of the keys so there are various strategies by which we can insert this node so here we will be simply inserting this node at the beginning of the list so friends in our previous videos we have seen that how we can insert a node at the beginning of the list or a singly linked list so here the concept remains exactly the same now here you can see as head is pointing to null so at the first step what we do is as you want to insert this node at the beginning of the list and there could be a possibility that there are already nodes here as currently there is no nodes but there could be a possibility that head is pointing to a chain of nodes so at the first step what we do is we simply assign node next value to head because we want to insert this node at the beginning of the list so if node next is pointing to head then only this node will be at the beginning of the list but currently head is pointing to null so node next is already pointing to null and then what we'll do is this hash node which is pointing to the head will break this link and we'll try to point it to our hash node which you want to insert so it would look something like this this null value goes away and this node will be inserted now let's say we want to insert a key as 21 and a value as tom so the bucket index would be 1 because 21 mod 10 will give remainder as 1 so we simply access the hash node at index 1 we see it is pointing to null so it is the same case like what we saw here so we simply increment the size by 1 and then we put the key value pair in the form of hash node so now here you can see that our hash table has two key value pairs therefore the size is 2 now let's say we want to insert a key value pair as 31 comma sana so here now this case is when there would be a collision so how this separate chaining strategy comes into picture we'll see now if we do 31 mod 10 we get remainder as 1 so our bucket index is 1 so we simply go and access the hash node at index 1 so we see that there is already a hash node at this index so now here is a collision so the way we insert this key value pair now is we create the separate chains in a form of list so that's why we have created this hash node which has a next reference so that chain of nodes can be added with ease so at the first step what we do is to whichever hash node this index is pointing that would be our head so this is the first step now what we do is as we don't know that how many nodes are there and there could be a possibility that this key might exist already in this hash table so what we do is we start from the head we compare its key with the key which we want to insert and if that key is already present then we simply update its value we don't add a key value pair in this hash table we simply update the value so that case we will see later but now here can see head dot key is 21 and the key which we want to insert is 31 so therefore they are not equal so what we do is we move head to its next node because so let's say if there are five nodes then we need to compare all the five nodes key with a key which we want to insert because we don't want to insert a key which is already there so we simply move head to its next node by assigning head dot next to head so now here you can see head is pointing to null it means that this key is not present and we can safely insert this key value pair at this index at the beginning of the list and as we are adding this key value pair we'll increment the size by one and then we'll bring head to its first position again now we'll create our hash node with this key value pair so key 31 value is sana and its next is pointing to null so here now we are inserting this node at the beginning of the list so what we saw already here so at the first step what we do is as we want to insert this node at the beginning of the list we simply assign the value of head to node next so that node next currently pointing to null should point to head so it looks something like this that now node next is pointing to head and as node next is pointing to head now we can safely break this link and we can assign this reference to our newly created node so it would look something like this this link will go away and now there will be a reference to this hash node from this index so it would look something like this so here there is a reference from this index to this node which you want to insert and from this node there is a reference to the list of nodes which were already there so currently there is only one node but there could be a chain so when we rearrange this it would look something like this that node is inserted at the beginning of the list and this node simply shifted by one position so friends now here you can see let's say if you want to insert a key value pair where key is already present so here we have these three nodes we are trying to insert key value pair where key is 21 and value is married so when we will divide 21 by 10 we get remainder as 1 so our bucket index becomes 1 so we simply access the hash node at this index and the first hash node is our head and if there is a hash node already present so now our first task is to verify that whether this key is already present in this hash table or not so the way we do it is we do head.key which is 31 here we compare it with our key so here you can see they are not equal so what we do is we traverse head to its next node via this reference so now we again compare head.key so here you can see it's 21 and our key which we want to insert is also 21 so therefore they are equal so what we do is by this check we came to know that key is already present so we don't have to insert a new key and increase the size what we do is we simply update the value when we actually put a key value pair so here instead of tom now the value will become married so friend this was all about this video in our next video we will see the code for adding this key value pair in a hash table via animation i hope you must have liked this video and in case if you are new to my channel then please subscribe to my channel thanks have a nice day hello everyone so in our previous video we saw a demonstration via an animation that how we can put a key value pair in a hash table using the separate chaining collision resolution technique so in this video we will see the code for that and we will see its demonstration step by step with an animation so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so when we create the instance of hash table this is what we discussed that at the start what happens that all the hash nodes on each index points to null so which means that on each index we have a list of nodes and the starting node is basically your head which is being pointing to null and here you can see when we start as we are providing the capacity of 10 it means we are creating the array of hash node with a length as 10 which is nothing but our number of buckets and size is zero so let's say if you want to put a key and a value as 105 in john so we call the put method we take key as 105 and value as john so in our previous video we discussed the idea that how we can insert this key value pair there are many use cases which we will be seeing later so each use case at the start what we do is we take the key and we pass it to our hash function which gives us an index and we take that index and we try to insert the key value pair in the form of hash node into this buckets array so here you can see the get bucket index method is nothing but our hash function so here we are using the modular hash function where we are taking the key we are dividing it by number of buckets and whatever is the remainder we are returning it from this method which would be nothing but our bucket index so when we pass 105 as key and if we divide 105 by 10 then we get 5 as the remainder so the bucket index is 5 now what we do is we try to access the hash node at this bucket index so which is 5 so here you can see it points to a hash node having value as null so here you can see it is referring to a null value so it means at this index there are no hash nodes so we can directly insert this key value pair and as the starting node is pointing to null we are creating a hash node by name head which points to the first node at this index which would be null so head is pointing to null so friends here you can see that on each index there can be multiple hash nodes which are connected via the next reference which hash node has and when we discuss singly linked list we saw that the starting node is head so here we are simply referring head as the starting node of the singly linked list which will be formed by the chain of hash nodes so here why we need this head is because in this file loop at this particular index there could be a possibility that let's say there are many nodes so in this file loop we are checking that whether the key is already present or not so here you can see as head is pointing to null it means that this key value pair is not present so we exit from the while loop and as key value pair is not present we can simply add this key value pair in the form of hash node so first we increment the size so now size becomes 1 and now here you can see that let's suppose at this index there could have been multiple nodes connected via next reference so in this while loop there is a possibility that head might travel to some of the nodes to check whether the key is present or not so after this while loop we bring back head to the first node by again assigning the hash node at bucket index so head will again point to null and now as you want to insert the node so first we create the hash node with key value pair which you want to insert so it would look something like this key is 105 value is john and its next is pointing to null and it is being referred by node now as you want to insert this node at the beginning of the list which is starting from head what we do is we simply assign the value of head to node next because we want to insert this node just before the head which would be the beginning of the list so node next should point to head so we are simply assigning value head to nodes next so currently node next is already pointing to null and now as you want to insert this hash node in this buckets array so at this index whatever the reference would be we simply assign it to the node so at the bucket index we are simply assigning the value of node so it would look something like this as node is pointing to this node now this hash node will point to the node which we want to insert so here you can see that we have inserted one hash node and from now onwards there would be multiple hash nodes on this index in case some collision will occur so let's put one more key value pair where key is 21 and value is tom so size is already 1 key is 21 value is tom we first calculate the bucket index from our hash function so when we'll call get bucket index we pass in the key so 21 when divided by 10 will give remainder as 1 so the bucket index will become 1 so now what we do is we simply try to access the hash node at this bucket index so when we call buckets and we pass bucket index as 1 we are accessing this value so here you can see that the hash node which it refers is null so it means that there are no nodes in this list here so head will point to null now we will simply check whether 21 is present in list of nodes at this index or not so currently head is pointing to null this condition in while loop will come out to be false and we know that this key value pair is not present so we'll simply increase the size by 1 because now we are simply adding key value pair into this buckets array so size becomes 2 and we already discussed that head might travel in this while loop to some of the nodes to simply compare whether 21 is present or not so we simply bring back head to the starting of the list by again assigning the hash node at bucket index so head will again point to null we'll create the hash node with key as 21 value as tom and next pointing to null and as we want to insert this node at the beginning of the list first we assign the value of head to nodes next so head is pointing to null so here node next will point to null and then we'll simply add node into this bucket array by assigning the value of node at the bucket index so it would look something like this that now it will point to the node which we want to insert so friends here you can see that we have added two nodes now now let's say we want to add one more key value pair where key is 31 and value is sana so this is the case where we will actually see the collision and we will see the importance of this next reference so key is 31 and value is sana we calculate the bucket index 31 divided by 10 will give remainder as 1 so bucket index will become 1 we will access the hash node at this bucket index which is at index 1 and to whichever node it is pointing our head will point to that node because that would be our starting of this list so head will point to this node so now we'll see that whether 31 is present in this list of nodes or not which is at this index so currently you see head is not equal to null so there could be a possibility that this key and value might exist already in the buckets array so in the while loop we check whether head dot key which is 21 is equal to 31 or not which is the key which we want to insert so this condition comes out to be false because 21 is not equal to 31 it means this key value pair is not present for this node so what we do is we simply traverse head to its next node because there could be possibility that this list can contain let's say n number of nodes so we have to compare the keys for this n number of nodes by traversing head 11 position with each iteration so we simply assign head dot next value to head so head dot next is pointing to null so now head will point to null we check whether head is equal to null or not so head is equal to null so this condition comes out to be false which signifies that this key value pair is not present in this buckets array so we can safely insert a key value pair so this condition comes out to be false and while loop will terminate so rest of the steps remains the same as we are now inserting this key value pair we will increment size by one so size will become three and here you can see that head has already traversed into this list of nodes so we again bring back head to the starting point of the list by again assigning the hash node at bucket index which is our first hash node so it would look something like this head comes back to the first position and why we are bringing head to the first position is because we are trying to insert this key value pair in the form of hash node at the beginning of the list so we usually need the head for that which is nothing but our first hash node of the list so here we are simply creating the node with key value pair so key 31 value is anna and its next is pointing to null which is being referred by node and now as you want to insert this node at the beginning of the list which means let's say there are n number of nodes already here and if we insert this node our node should come before head which is having key as 21 so the node having key as 31 should insert before the node having key as 21 which is nothing but our head so what we do is we can't directly break this link and assign it to our node because if we break this link this chain will go away so first we need to hold this chain so how we can hold this chain is we assign the value of head to nodes next because we want to insert this node before the head so node next should point to head so after this assignment it would look something like this that node next is pointing to a node to which head is pointing and then we can simply break this link and assign it to our newly created node so it would look something like this this link will go away and there will be a link from this index to the hash node which you want to insert so if we rearrange this structure it would look something like this that the node which you want to insert is at the beginning of this list which is just before the our old head so friends now let's see one last use case where the key is already present so here you can see if we put key as 21 and let's say value is meri so here if the key is already present we don't put the key value pair in the buckets array we simply update the value and that we do with the help of this while loop so let's see how key is 21 value is meri the bucket index will come out to be 1 because 21 divided by 10 will give remainder as 1 so bucket index is 1 so we simply access the hash node at this bucket index which would be nothing but our head so head will point to this node we check whether head is equal to null or not so here you can see currently head is not equal to null so in the while loop we simply check whether key 21 is already present or not so that is done via this if condition we simply check head.key is equals our key or not so 31 is not equal to 21 so this condition comes out to be false and we simply traverse head to its next node by assigning head.next to head so via this reference head has traveled to its next node because we want to compare each and every key present at this index with our key because there could be a possibility that 21 is already present in this list so after this assignment we again check whether head is equal to null or not so we encounter one more hash node so head is not equal to null but now here you can see head.key is 21 it is equal to our key 21 so this condition comes out to be true which means that key is already present in our buckets array so we don't increment size here what we do is we simply assign the value as meri to head.value so head.value storm which will be updated by meri so here we are simply updating the value with the recent value old value is discarded and the size of the hash table remains the same because key is already present and after updating the value we simply return from this method so friends here you can see that we saw various use cases that how we can insert a key value pair in the form of hash node in a hash table we saw that how we can add a key value pair we also saw that how we can update a key value pair we also saw that what happens when there is a collision and we also saw the importance of our hash function that it can take a large key and provide us with a small index so that we can add this key value structure into this buckets array so friends i hope you must have find this information useful and in case if you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw that how we can put a key value pair in a hash table we also saw different use cases which comes into picture when we actually put a key value pair in a hash table so one use case is if the key is not present we simply put the key value pair and increase the size and the second use case is if the key is present then we don't put the key value pair we simply go to that key and simply update the value for that key so if the key is present then we simply update the value we don't add the key value pair in our hash table because key is already there so here before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here you can see that our hash table internally has an array of hash nodes which we call as buckets it also has the capacity which is nothing but buckets dot length and it also has size which is nothing but the number of key value pairs in a hash table or we can say the number of hash nodes which this array holds we also saw that how internally hash table uses hash node class so here it has key value pair and a reference to next node so for our implementation we can take any key value pair but here i have taken key as integer and value as string we also saw about the size method which returns the number of hash node in our buckets array and if size is equal to zero is empty method will return true now we'll see the implementation of the put method which takes in a key and a value and we'll see that how we can put this key value pair in our hash table so at the start we simply provide simple edge cases where we simply check that if key is equal to null or value is equal to null then here either we can return from this method or we can throw an exception let's say i throw illegal argument exception saying key or value is let's say null so friends here you can provide your own edge cases so this is one of the simple edge cases i'm providing now here in order to put this key value pair in our hash table the first thing we do is we try to evaluate bucket where we can put this key and value so for that we will be using modular hash function so here we first evaluate bucket index so we will call our hash function whose name is we had bucket index and we pass our key to it because this key can be a very huge key and in order to accommodate a huge key in simple or small size array we need a hash function which takes in the key and returns us a smaller index value so that we can use that index and put this key value pair so here i'll be creating one private method as get bucket index which will return us back the index value for this key so it will take key and here i'm using the modular hash function so we'll simply return key mod divided by number of buckets and whatever is the remainder that will be returned from this method here we all can also use buckets dot length instead of number of buckets so after getting the bucket index we will try to access the hash node which is at that bucket index so we do buckets we provide the index to it and whatever the hash node it will return it will be the head of the list which this index is holding so that would be our hash node and it will be head so after getting the head what we do is we can't directly put this key value pair in our hash table we first try to search each and every element present at this bucket index which is the list whose first node is referred by this head so what we do is we simply provide a while loop and we provide the condition as head should not be equal to null so if head is not equal to null then first thing we do is we try to search for our key because in case if our key is present then we don't put this key value pair in the hash table we simply update the value corresponding to this key so if head is not equal to null we provide a condition we check head dot key equals the key which we have passed to this method and if it is true what we do is we simply update the value associated with this head node with our value so here you can see that we are using this head to simply traverse the list at this index and we are comparing the head key with the key which we have passed so this case handles if the key is already present in our hash table so after we update the head's value with the new value we simply return from this method because we don't want to add this key value pair again so if this condition is false what we do is we traverse head to its next node by assigning head dot next value to head and this is important because let's say we have found a list of hash nodes which is being referred by head so we need to compare this key with each and every node which is being referred by this head so therefore we have provided this while loop and as soon as we have found our key we are updating its value and returning from the method without adding this key value pair and if we are not finding it then we are simply traversing it to its next node so there would be a condition when head will reach the end of the list so at that moment this while loop will terminate and at that moment while loop terminates it means that we never found our key so we can now directly add this key so what we do in the first step is as we are adding this key value pair in the hash table we will increase the size by one and also from here you can see that we can add this key value pair in the form of hash node and that hash node we can insert the way we want so here we will be inserting this hash node at the beginning of the list so in order to get the beginning of the list what we do is there could be a possibility that in this while loop the head must have traversed so what we do is we simply do this step again and we make head reach to the first position by again assigning a hash node at this bucket index so after this step now head is pointing to the first node of the list and we want to insert this hash node before head so the first step we do is we create the hash node let's say we give name as node and here we provide the key and the value so here it looks something like this key value and its next is pointing to null so now how we can insert the node at the beginning of the list is we simply assign head to node.next here you can see head is pointing to the first node of the list and we want to insert this node just before that so it means its next should point to head so this is the first step and the last step is hash node at this bucket index is currently pointing to head so we need to break that link so here what we do is we do buckets bucket index and we assign the value of node to it so friends here you can see the hash node at this bucket index was initially pointing to head and as we inserted our node just before the head now hash node at bucket index is pointing to node which we want to insert and node next is pointing to the head in order to keep the rest of the nodes intact so this is how we can put a key value pair in a hash table now let's see it's working in the main method so here we'll create a main method first we will create the hash table let's say we provide the capacity as 10 which means number of buckets will be 10 and now what we do is we simply put few values let's say we put 105 comma let's say tom we put 21 21 SANA and now what we do is let's say we do table dot we print the size so if i run the code now so here you can see it printed two now what we do here is we again call table dot put and here we are again providing a key which is already there and this time we are providing the value as harry so if i run the code now the size should remain the same so here you can see it came out to be 2 and here if i debug this so here you can see if you open buckets array that 105 was added at index 5 based on our hash function where we divided 105 by 10 and remainder was 5 so if i open this you will see the value as tom and key as 105 and next pointing to null because you only inserted one value if i open the index one here we will see that we have only one value as next is pointing to null but here you can see the updated value is harry initially it was SANA now it became harry and here we simply updated the old value with the new value and let's suppose if we add something like 31 dinesh and if i rerun it so here you can see 31 divided by 10 will give index one so if i open index one you can see the 31 is inserted at the beginning of the list and now you can see initially it was 21 so now 31 got inserted before that and its next is now pointing to 21 so this is how we actually put a key value pair in our hash table i hope you must have find this information useful in case if you have find this information useful then please like this video and if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update hello everyone so in our previous video we saw that how we can put a key value pair in a hash table using the separate chaining collision resolution technique and in this video we will see that how we can get a value by key in a hash table so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so friends let's suppose we are given with this hash table having buckets array where number of buckets is 10 which is the length of this hash node array and the size is three because we have inserted three key value pairs in the form of hash node and where we have detected a collision there we have inserted the nodes in the form of chains here index one is nothing but our bucket index which correspond to this list whose index is one which is being generated by the hash function by providing a certain key so friends here you can see the advantage of searching a value corresponding to a key in this hash table is it is very much fast so for example let's say if you want to search for key 105 so here you can see that the number of buckets in the buckets array is only 10 and we are storing a huge value in this buckets array so after storing these values in the form of chains there one question arises that how we can get that value because storing is easy but how we can get a value corresponding to a key and that too very much fast so here as we discuss the way we put the key value pair into the hash table using the hash function the same way we use the hash function and deduce the index and try to search for a key so here you can see that size is three so inside this buckets array there can be thousands of elements in the form of key value pairs so how hash function help us in searching our particular key value pair fast is let's suppose if we call table.get and pass in a key as 105 so via this method we are asking that please get us the value corresponding to this key so here what happens is key is 105 so at the start what we do is we pass this key to our hash function and hash function provide us with an index and we try to search only in that particular index so this type of searching makes our data structure very much efficient in searching so here our hash function is we pass the key so here we can take any hash function which we like but here i'm taking this modular hash function where we are simply taking the key we are dividing it by buckets.length or number of buckets and whatever is the remainder that we are simply returning which will be treated as our index so if we divide 105 by 10 we get remainder is 5 so our bucket index is 5 so it means that this key can only present in the chain of nodes corresponding to index 5 so we simply access the hash node at index 5 and to whichever node it is pointing that would be our head because there could be multiple hash nodes in this list so the first node is usually our head so we simply point head to it and now our task is to search for our key so here we do head.key which is 105 we try to compare it with our key and if they are equal then we simply return its value which is john so friends here you can see there are so many elements but with just simple hash function we quickly searched for our key so this is the simple case where our first node became the key which we want to search so after this let's say we search for 21 so key is 21 if we divide 21 by 10 we get remainder as 1 so our bucket index will come 1 so we directly go to index 1 and we will try to access its first node so head will point to the first node via this link and here what we do is we simply compare head.key which is 31 with 21 so they are not equal it means for this node the key is not present but there are other nodes in this chain so what we do is we simply traverse head to its next node via this reference so head comes to this position and now we again do head.key we compare 21 with our key and we see that we have found our key so what we do is we simply return the value as tom now let's suppose if we want to search for a key which is not present in this hash table for example if we call table.get and we pass the key as 88 so here we see 88 is not present so key is 88 when we will divide 88 by 10 we get remainder as 8 so the bucket index becomes 8 we go to the 8th index and try to access the hash node which it refers so here you can see the head will point to null which simply signifies that this key is not present in this hash table so we simply return null from this hash table so from these are the simple use cases where we can get a value by key in a hash table in our upcoming video we will see the code to get a value corresponding to a key from the hash table and we will see the demonstration of the code via an animation i hope you will find this information useful and in case if you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw an animation that how we can get a value by key in a hash table so now let's look into the code with an animation but before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here the example which we discussed in our previous video we will use the same example and we will see that how it works via this code so let's say if you're calling get method and passing in the key so here key becomes 1 0 5 and here you can see currently our bucket has three nodes in the form of key value pairs so the size is 3 so at the first step if you want to get a value corresponding to a key the first thing we do is we try to find the bucket where that key might belong so how we can do that is we simply call our hash function we pass the key to it and it will return us back the and it will return us back the index so when we will call get bucket index passing in the key it will return us back the index by simply taking in the key dividing it by the bucket's dot length or number of buckets and whatever is the remainder it will return us back that index so here we can use any hash function and here i have used this modular hash function which is taking the mod of key and bucket's dot length and returning us back the remainder so when 105 will be divided by 10 we get remainder as 5 so the bucket index is 5 for this key it means that at index 5 this key will be present or it might not present moving ahead now as we have figured out the index so we try to access the hash node at this index so we do buckets and we pass in the index so this will return us a hash node which would be nothing but the head of our list of nodes which can be there on this index so head will point to this hash node because this is the first hash node in a list of hash nodes now how we can search for our keys we provide a while loop and why we are providing this while loop is because here you can see there is only one hash node but there could be a possibility that there are n number of hash nodes so we need to compare each and every hash nodes key with the key which we want to search so we are simply checking whether head is equal to null or not so if head is not equal to null it means that there are nodes present at this index so we provide a if condition and we simply check whether head dot key which is 105 whether it is equal to the key which we want to search so here you can see this condition comes out to be true because 105 is equal to the key which we are searching so the if condition comes out to be true and we simply return head dot value because we have find our key and we want to return its corresponding value so we simply return head dot value so john will be returned now let's say if we want to search for a key which is somewhere in between of this list at a particular index so here we are calling get method key as 21 so at the first step what we are doing is we are calling the hash function get bucket index we are passing in the key so this method will return as an index where we can search for this key so when 21 will be divided by 10 we get remainder as 1 so the bucket index will be 1 so now we'll simply access the hash node at this bucket index and that will be our head so at index 1 we have this hash node so head will refer to it we provide a while loop because here we are having a list from which we want to search our key so we simply check whether head is equal to null or not so here you can see head is not equal to null so this condition comes out to be true we provide a if condition that if head dot key equals key which means that we have found our key so currently head dot key is 31 we compare it with 21 so this if condition comes out to be false because 31 is not equal to 21 so we simply move head to its next node by assigning head dot next value to head so head is pointing to this node its next is pointing to this node so via this reference we will simply traverse head to its next node we again check whether head is equal to null or not so head is not equal to null we check head dot key which is 21 whether it is equal to the key which we are searching so yes head dot key which is 21 is equal to 21 which we are searching so this condition comes out to be true and we will simply return the value corresponding to this key which is tom now friend let's say if we want to search for a key which is not present in this hash table so we call get method we pass in the key as 88 so key is 88 we calculate the bucket index we divide 88 by 10 and we get the remainder is 8 so the bucket index will be 8 so we access the hash node via the bucket index which is this node which would be our head now so head is pointing to null and then we are providing this while loop because there could be a possibility that it contains the chain of nodes so here you can see the condition here is head should be not equal to null but here head is equal to null it means that key which we are searching is not present in this hash table so at the end we are simply returning the null value which signifies that 88 is not present in this hash table so friends i hope you find this information useful and in case if you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw an animation that how we can get a value via its key from a hash table so in this video we will actually code the algorithm and we'll test its working in the main method so before we start if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here in our previous videos we saw a initial implementation of hash table and we saw that how we can put a key value pair in hash table which internally uses the hash function which is nothing but create bucket index and here the hash function which we are using is modular hash function which is using this modular operator now in this video we will see that how we can get a value by providing its key so when we saw the implementation of put we provided this h case that key or value if they are null then we simply throw a legal argument exception saying key or value is null and as we are not putting any null key or null value when we will do get we simply provide this check again and here we'll simply check if the key is null then we throw a legal argument exception saying key is null so this is the simple h case which we are providing and now how we can get a value associated with this key which we are passing to this method because in hash table internally it is using buckets array of type hash node so how we can find our key and return its corresponding value we basically use the hash function which takes a key and return us back an index and corresponding to that index we try to search our key so here you can see we first evaluate the bucket index where this key might lie because there could be a possibility that this key is not present in our hash table so what we do here is whatever the key we are passing we call get bucket index method we pass the key to it so this is our hash function so it will return us back the index where this key might lie so after getting the bucket index what we do is we try to access the first node of the list which corresponds to this index so here we simply access buckets we pass the bucket index it will return us back the hash node which would be the starting node of the list of hash node so we are assigning it to head now after getting the head our task is to find the key so for that we are providing this while loop and here we are providing the condition as head should not be equal to null so friends here you can see this is exactly what we did in put and also we provided while loop where we were simply searching for that key and if key was found we were simply updating its value so here i will simply copy this and we'll paste it here so the only change we do here is if we find our key then what we do is we simply return head dot value because we wanted the value associated with this key so we searched for the key and we checked that whether any key is matching to our key or not so in the if block we provided the condition if head dot key is equal to our key then simply return its value and if it is not then simply move head to its next node by assigning head dot next to head so friends here when we are accessing the hash node at this bucket index there could be a possibility that this hash node will point to other hash node and there can also be possibility those hash nodes point to other hash nodes so we are accessing the head we are comparing the key if key is matching then we are returning the value and if key is not matching we are simply going to its next node and doing the same steps again so friends if the key is present its corresponding value is returned and if it is not then we are simply returning null here now let's test it's working in the main method here in our previous video we added few keys along with its values so if i run the code now you will see there would be three keys so it printed the size of the hash table as three because the key values pairs are three 105 21 and 31 here this 21 was already present so when we call put the Sana was replaced with Harry so it simply updated the value it never inserted a new key value now here what we do is let's say if we do table dot get and say return me the value associated with key 31 and we print it so if i run the code now it should print Dinesh so which is corresponding to key 31 so now if we do table dot get and pass the key as 21 if i run the code it should print Harry because Harry is the upgraded value for key 21 and last let's say if we print a key which is not present let's say 90 if i run the code now so it should print null so it is returning null so friends in this video we saw that how we can get a value associated with its corresponding key i hope you find this information useful and in case if you find this information useful then please like this video if you are new to my channel then please subscribe my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw that how we can get a value from a hash table via its key now in this video we will see that how we can remove a key from a hash table so basically we will see the demonstration of remove method which takes in a key and it removes that key from the hash table and also returns its corresponding value back to us so before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so let's suppose if we are given with this hash table having three hash nodes where size is equal to three now let's suppose if we want to remove a particular key so what we do is we are given with a key we first try to find the index associated with that key via our hash function then we go to that index and we try to search for that particular key in case if we find that key then we simply remove that node from the corresponding list of that index and if we don't find the key we simply return null so here you can see that there are various cases which needs to be handled while removing a key the first case is what if the key is not present so we simply return null the second case is let's suppose the key is in the middle somewhere so when we find that key we can't directly delete this node because if we delete this node directly then there are other nodes associated with this node which will also get deleted so what we do is let's suppose if we want to delete this key then whenever node will reach to this point we compare the key and we find that we need to delete this node we have to break this link so in order to break this link we need to somehow access this node and this is accessed via a temporary node which is previous to our current node which we want to delete so here after we find the key which you want to remove the previous node will help us in removing this node so what we do is as previous is pointing to this node we have to break this link and make a link from this node to current's next because we don't want to remove the nodes after that so we simply assign current's next to previous next so this link will go away and this link will point to current's next which would be the leftover nodes after we remove this node so friend this is also one case where the key which we want to remove is in the middle of this list so for that we simply keep the track of its previous node which we will see later so let's suppose if we want to remove a key having value as 105 so at the first step we pass this key to our hash function which takes the key divided by buckets dot length which is the number of buckets and return us back the remainder of it because here we have this modulus operator so whatever the remainder is returned that is nothing but our index where we can find that particular key so if we divide 105 by 10 we get remainder as 5 so the bucket index becomes 5 we simply access the hash node at bucket index 5 so this will be our head so as head is pointing to the first node at the start we assign a null value to our previous node so this previous will simply track the previous node to our head we will see why it is needed later in this video so currently previous is pointing to null now using the head we will simply search for our key which we already discussed in our previous videos so we do head dot key which is 105 we compare it with our key so here head dot key is equal to the key which we want to remove it means we have to remove this hash node so what we do is as previous is pointing to null it means we want to remove the first node of the list so currently head next is pointing to null so there could be a possibility that there are n number of nodes after that so it means that we want to remove the first node from the list so what we do is in order to remove this node we have to first break this link so that there is no reference to this node and it can be freed up but we can't directly break this link because there could be nodes after that so these nodes which can be after the head will also be removed so what we do is so first we decrease the size so size becomes 2 and now what we do is if we do head dot next we will get the remaining hash nodes in the form of chain and as head dot next is pointing to the nodes after that if we assign head dot next value to buckets at this index so this node can be freed up and this reference will point to whatever the head dot next is pointing so currently it is pointing to null so what we do is if previous is null which means that we want to remove the first node of the list so here we will assign head dot next value to bucket index 5 so it would look something like this head dot next is null so this link will be removed and it will point to null and now we can simply remove this node and we can return head dot value which is john so it would look something like this now let's say if you want to remove key as 21 so 21 divided by 10 will give remainder as 1 it means the 21 key can be present at index 1 so we access the hash node of index 1 so this would be our head at start we assign null value to previous now here first we search for our key so we do head dot key which is 31 we compare it with our key which is 21 so here you can see 31 is not equal to 21 so what we do is before moving head to its next node in order to search for the key we first assign the value of head to previous because we need to keep the track of the previous node so that in case if we find a key then we can use its previous and break the link so that the key which we have searched can be removed easily so here as head is pointing to this node now previous will point to this node and we will simply traverse head to its next node via this link now we again compare head dot key which is 21 with our key so here you can see that we have found our key so our task is to now remove this node but there could be a possibility that after this node there are many other nodes so what we do is as you want to remove this node first we decrease the size so size will become 1 and we simply check whether previous is pointing to null or not so here you can see previous is not pointing to null it means that our key is lying somewhere in the between of this list because if previous would have point to null then we would have sure that head is pointing to the first node of the list but as previous is pointing to this node so what we do is we simply assign head next value to previous next so why we do that because we need to first break this link so when this link will be broken then this node will have no reference so this can be garbage collected but there is one problem head dot next will refer to other nodes as well so those nodes will also be removed if we break this link directly so what we do is head dot next will point to the nodes after that so we simply assign head dot next value to previous next so instead of previous next pointing to head it will now point to heads next so this node can be freed up so it would look something like this this link will go away and as head dot next is pointing to null so it will point to null so now this hash node can be removed easily we will return the value tom and then we will simply remove it now friend let's say we are given with these two nodes and we want to remove 31 so what we do is we do 31 divided by 10 which gives the remainder 1 so bucket index is 1 we simply access the hash node at index 1 we give it a value as head because this is the first node of the list we will assign previous a value of null and then we compare 31 which is head dot key with our key so that we can search for that particular key which we want to remove so here you can see head dot key is equal to the key which you want to remove it means we want to remove this key so first we simply decrease the size so it will become 1 because we are removing this key now and after that we need to break this link so that this node can be freed up but if we remove this link directly then all the nodes in this list will be removed we only want to remove this node and keep all the nodes after that intact so what we do is how can we access all the nodes after that is we simply do head dot next and if we do head dot next we reach to this node so here we break this link and we assign a value of head dot next to it so now this link will go away and it will point to this node and the nodes after that so here we are simply assigning head dot next value to buckets array at index 1 so it would look something like this this link will go away and it will point to this node and once the method will end this node can be safely removed and we can simply pass the value associated with this key so after it gets removed it would look something like this so here there could have been multiple nodes after that so we have kept that list intact and we have removed the node from the middle so this is also one of the use case now let's suppose if we are given with this hash table with two nodes and we want to remove a key which is not there in this hash table so key is 88 if we divide 88 by 10 we get bucket index is 8 we access the hash node at index 8 so here it is pointing to null which means that key is not present in this hash table so we simply return null so from these are the cases which are involved when we actually remove a key from our hash table i hope you find this information useful and in case if you find this information useful then please like this video and if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw that how we can remove a key from hash table via an animation so in this video we'll see the algorithm via an animation and we'll see that how it works step by step so before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here you can see that this is the algorithm to remove a key from the hash table so let's see the demonstration of it step by step we will take the same use cases which we discussed in our previous video so when we will call table.remove and pass the key as 105 the remove method will be called with the key 105 now the first step what we do is we search for that key and how we can search for that keys first we get the bucket corresponding to this key so we call our hash function get bucket index we pass in the key and it returns us back an index by dividing key by bucket.length or number of buckets and return us back the remainder because it has this modulus operator so here if we divide 105 by 10 we get remainder as 5 so this method will return us the bucket index as 5 now what we do is we have got the bucket index and we know that key 105 will lie at this bucket index so we simply access the hash node at this index which is 5 here so the first hash node is nothing but our head and there could be n number of hash nodes so head will point to the first hash node now in order to keep the track of the previous hash node we simply assign it with the null and why we keep the track of the previous hash node we will see later so we are providing this while loop which is pretty much same what we saw in our previous videos that we are trying to search the key first so currently head is not pointing to null so this condition comes out to be true we check whether head.key which is 105 is it equal to the key which we want to remove so here you can see this if condition comes out to be true so what we do is as soon as we find the key which we want to remove we simply break from this while loop because we have found our key and now it's time to remove that key so when we break from this while loop it will come here and here we encounter one use case that head could point to null so which we will see later so currently head is pointing to a hash node which is not null so this condition comes out to be false so now here you can see as we want to remove this node we will first decrease the size by one so size will become two and after that we encounter a if else block which is very much important because here if previous is not equal to null so this is the if condition if previous is equal to null it means we are trying to remove the first node of the list let's say if we take this example and if head is pointing to this so previous will point to null so it means we are trying to remove the first node of this list and if previous is not equal to null it means the key which we have found is somewhere in the between of this list so that use case we'll see later so currently you can see previous is pointing to null so our if condition comes out to be false and the else part will be executed and here we want to remove this node from the list so what we do is and we know that this is the first node which is being referred by bucket's array at bucket index so in order to free this node we need to remove this link we will assign head dot next value to bucket's array at bucket index so the hash node referred by bucket index which is this instead of pointing to this node it will simply point to head dot next because we want to remove this node and this node can also have other nodes so we can't directly break this link we simply assign head dot next value to this index so currently for this use case you can see head dot next is pointing to null so here we simply break this link and we assign head dot next which is null so it will point to null and here you can see after this method gets end first we return the value associated with it which is john and once this method will end this node will be garbage collected so it would look something like this now let's suppose if we want to remove a key 21 so first we'll find its corresponding bucket so 21 divided by 10 will give remainder as 1 so the bucket index is 1 so we simply access the hash node at bucket index 1 which is this node and there could be a list so we assign head to this node because this is the first node of the list we create a hash node previous and at the start we assign a null value to it and now as we want to remove the key 21 so we search in this list using this while loop so currently head is not equal to null if head dot key equals the key which we want to remove then this if condition will come out to be true so here head dot key is 31 it's not equal to 21 so the condition in if block comes out to be false so this is the key we are comparing it with 21 and as this condition is false we will reach here so usually we search for the key in complete list so for this node the key didn't match so before going to its next node by assigning head dot next to head what we do is we simply keep the track of this node because let's say if we find this key here then we can use the previous node and we can simply remove this link here so that this node can be freed up so before moving head to its next node we assign the value of head to previous so it would look something like this and now we simply move head to its next position by assigning head dot next to head so head dot next is pointing to this node so via this link head will now point to this node head is not equal to null if head dot key equals the key which we want to remove so head dot key is 21 and 21 is equal to 21 so this condition comes out to be true and here we know that we have found our key which we want to remove so we simply break from this while loop we first simply check whether head is equal to null or not if head is equal to null then we simply return null so currently head is not equal to null it means we need to remove this key so we first decrease the size by one size becomes one and now here you can see previous is not equal to null previous is pointing to this node therefore this condition comes out to be true so why we provide this check is if previous is equal to null it means we are trying to remove the first node of the list and if previous is not equal to null it means the key which we have found is somewhere in the middle of the list because previous is providing that information to us so in the if part what we do is we need to remove this link and we can't directly remove this link because head dot next may point to the other nodes so what we do is we simply assign head dot next value to previous next so it would look something like this that now previous dot next is pointing to null and why we did that because let's suppose if there are n number of nodes after that and we want to only remove this key we don't want to touch other nodes so to whatever value head dot next is pointing previous dot next should point to that node but here it is null so previous dot next is pointing to null we will return the value tom and this node will be removed from the hash table now friend let's suppose if we want to remove a key as 31 so we calculate the bucket index 31 divided by 10 will give remainder as 1 so 1 will get returned from our hash function so bucket index becomes 1 we access the hash node at this bucket index and to whichever node it is referring that will assign to head so head will point to this node at the start we do previous equals null and then we search for our key so we check whether head is equal to null or not so head is not equal to null so the while loop will start then we provide a condition to search for that key so if head dot key equals the key which we want to remove head dot key is 31 and the key which we want to remove is also 31 so this condition comes out to be true it means we have found our key we break and then we check whether head is equal to null or not so head is not equal to null it is pointing to a key which we want to remove and before removing the key we decrease the size by 1 so size becomes 1 and now here you can see previous is pointing to null so the else part will be executed and in the else part you can see that why we are doing head dot next in use case one head dot next was pointing to null but here you can see there is possibility that head dot next is pointing to other nodes so we can't directly break this link so to buckets array at bucket index we assign the value head dot next so now this link will be removed and as we are assigning head dot next to it this will point to this node because head dot next is this node so it would look something like this that we are assigning head dot next value which is this node to buckets array at bucket index so now here you can see this node can be freed up easily by returning the value sana and if we rearrange it it would look something like this so here we removed a node and we saw the importance of doing head dot next because we can't directly break the link this link we need to assign it head dot next so that it should refer to the remaining nodes of the key which we want to remove so friends one last use case is this use case where you want to remove a key which is not there in this hash table so we will calculate bucket index 88 divided by 10 will give remainder as 8 so bucket index is 8 we access the hash node at this index so here it is pointing to null which means head will point to null we create previous and we assign a null value to it here head is pointing to null so it means this condition comes out to be false and here as head is equal to null it means that size remains the same and key is not present so we simply return null so in this video we saw that how we can remove a key from a hash table and we saw the demonstration of the algorithm step by step i hope you have find this information useful and in case if you find this information useful then please like this video if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw that how we can remove a key from a hash table and we saw the working of the code through an animation now in this video we'll actually code the remove method which takes in a key and return us back the value associated with the key which we are trying to remove so here in our previous videos we saw how we can put key value pair how we can get a value corresponding to a key so now we'll see that how we can remove the key so friend at the start i'll simply copy this part so here if you're passing key as null then we are simply throwing an exception saying key is null so this is the illegal argument exception which states that key is null so this is the simple h case and now in order to remove a key what we do is we pass this key to our hash function and this hash function will return us a index where we can search for this key and once we find that key we simply remove it so it will return us back the bucket index after getting the bucket index we access the hash node at that bucket index and as that index is pointing to a hash node which is the starting point of the list corresponding to this bucket index we give a name to it as head so friends here you can see that these two steps are being used in get method also and in put method also now what we do is in order to remove a key let's add this index if i simply copy this part and here at this index let's say we have this list of hash nodes something like key as 21 value as term now let's say it has three nodes something like this where key 31 is value harry and key 41 is value let's say sana now head is pointing to this node because this is the first hash node of the list now our task is to remove this key so let's say if we want to remove the key as 31 and head is pointing to this so first we will search our key by traversing head to each and every node and if you find the key let's say if we find the key 31 so somehow we need to access this hash node because this link needs to be removed in order to free this node and if you free this node directly then all the nodes after this node will also be removed so what we need to do is as head has traversed to this node so first we simply keep the track of its previous nodes so wherever head will go we will keep a reference to its previous node which is very important while removing a key from the hash table so if head is here and key matches so previous will be here so to previous next we have to break this link so to previous next we need to assign head next because we need to keep these nodes intact we will assign head.next value to previous next head.next is this node and the nodes after that it will be assigned to previous next so this link will go away from this node to this node and then we can simply remove this hash node so for that what we do is at the start we create a previous hash node we assign it a value as null because as head is pointing to this node at start we are doing previous as null so now what we do is we search for the key so for that we provide the while loop and here we will use the same while loop which we did in the get so here we are providing the condition as head should not be equal to null and if head is equal to null it means we have traversed this complete list and we didn't find our key and if head is not equal to null what we do is we compare head.key with the key which we want to remove and after we find our key what we do is we simply break from this while loop because after this while loop head will point to the key which we want to remove let's say here 31 so head will point to this key because this condition matches so let's say if we take this example and if we want to remove a key as 31 so in this while loop head will first check it with 21 this condition comes out to be false then we go to its next node head will come here it is not equal to null then we'll compare head.key which is 31 with the key which we have passed to this method so as soon as we find our key head is pointing to this node and here what we do is before moving the head to its next position what we do is how can we keep the track of this previous node is we first assign head to previous so previous and head will point to this node and then we simply traverse head to its next node so previous is a step behind the head and why we are keeping previous just behind the head is because let's say we have searched for the key which we want to remove so we break from this while loop and as soon as we break from this while loop previous is here and head is here so after this while loop what we do is we first check that if head is equal to null or not so if head is equal to null it means we didn't find any key in this list because this while loop would have terminated when head would have pointed to null which is the last node next so if head would have reached here it means we haven't found our key so we are simply returning the null value and if head is not equal to null then the first thing we do is we decrement the size by one because now we are about to remove the key so here now two condition arises one is at the start previous is pointing to null and head is pointing to let's say 21 and what if if you want to remove 21 only so in that case we are simply removing the first node of this list and how we can come to know that is the first node only is why are the previous because if previous is null and after this if block we can come to know that head is not equal to null so it means head must be pointing to this node only and which means we have to remove this key so here we provide the if condition and we check that previous is equal to null or not so if previous is equal to null and if our code has reached here it means head is also not equal to null which signifies this head is pointing to the first node so in the else part what we do is we have to remove the first node and it is being referred by this the hash node at bucket index is the first node so here what we do is we simply reassign this value to something like we do head dot next so it means that our buckets array at this bucket index was pointing to a hash node to which our head was also pointing and now we need to remove this node so head is pointing to this node if we assign head dot next to this then this node will be removed easily and now our buckets array at bucket index will point to this node because 21 would be removed so this is the small change which we do if previous is pointing to null and if previous is not pointing to null now let's say if we want to remove 31 so head will point to this and previous will point to this so now instead of doing this stuff what we do is we do previous dot next and we assign head dot next to it so here you can see head dot next remains the same as previous is not equal to null it means we can't use this stuff because this is only used in case if we want to remove the first node of the list but if we want to remove let's say a node in the middle then previous will help us in removing that so head was pointing to this and we want to remove this and previous was pointing to this so to previous next we assigned head next this value so now this hash node next will point to this hash node and this hash node can be removed easily so this step does that so after this reassignment head is still pointing to this so at the end what we do is we simply return head dot value and once this method will get terminated this head is our local variable so it will be garbage collected so friends what we did in the remove method we took the key we evaluated the bucket index where this key might lie the starting hash node we denoted with head we created previous and at the start we provided a null value to it and now in the while loop we tried to compare each and every key with the key which we want to remove because if we don't compare then we'll not able to get which node we want to delete so as soon as we found the key which we want to delete we break from this while loop and we perform the assignments here but let's suppose if the key is not found for the first iteration then what we do is we have to move head to its next node but if we move head to its next node we can't delete this node we need to keep the track of its previous node as well so before moving head to its next node we are assigning the value of head to previous and then we are moving head to its next node so that when we will find any key in the middle we have reference to a node before that so that we can reassign its next pointer here you can see we are reassigning it so if the key which we want to remove is at first node then we simply assign head.next value to bucket array at this bucket index and if it is somewhere in the middle or end then we have this previous reference we simply assign head.next to previous next and finally we return head.value and once we return head.value this method gets terminated and the node gets freed up so now let's test it's working in the main method so here you can see let's suppose we have this three keys 105 21 31 and if i run the code now you will see size will come as three because there are three hash nodes or key value pair now what we do is let's say we remove 21 and we print its value on the console so here you can see it printed harry because harry was associated with key 21 now let's say if we want to remove 31 so now if i run the code you can see it printed dinesh and if i print the size of it so here we have removed two nodes so it should print one so it has printed one so here you can see only 105 remains in the hash table because we have removed 21 and 31 so here if i simply copy this part so here before removing these two values we add hash table something like this this is 3 dinesh 21 harry and let's say if i remove this for time being so this was our hash table at index 1 because we are removing 21 and 31 so if we evaluate the bucket index 21 divided by 10 will give remainder as 1 so this is for the index 1 we first added 21 using put and then we added 31 so 31 came before 21 because we are inserting the hash node at the beginning of the list so this was the situation so when we removed 21 had started with this node then it reached here and previous reached here so 21 matched with our key and at the end what we did previous next was assigned width heads next which is null and then we removed 31 so this node was removed and when we printed the size it printed one only this key value pair exists and we removed these two key value pairs so friends i hope you find this information useful and in case if you find this information useful then please like this video if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss a problem contains duplicate update so friends before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here in this problem we are given an integer array and our task is to return true if any value appears at least twice or return false if every element is distinct so let's understand the problem with an example now let's suppose we are given with this integer array having elements as one two three one now our task is to return true if any value appears at least twice so here you can see that one appears at two places therefore we return true and return false if every element is distinct so here you can see in the second example the array is one two three four so all the elements are distinct therefore we have to return false so here our task is to check whether the array contains duplicates or not now let's move ahead and see how we can solve this problem via various techniques so let's suppose we are given with this array seven three one four one and we know that one appears at least twice therefore we know that it contains duplicates so the first way to solve this problem is a very brute force approach where we take each element and compare it with the rest of the elements in the array and we figure out whether the element is duplicate or not so when we try to solve this problem we take a pointer i and let's say the value is seven we take another pointer j and we compare the values at i and jth index so at the start seven is compared with three they are not equal so j moves to the second index seven is not equal to one so j moves to third index seven is not equal to four so j moves to the fourth index seven is not equal to one so therefore we figure out that seven is unique among these elements so after that i moves to three and j points to index after i because seven is already being compared with three in the previous iteration so three is compared with one they are not equal so j moves to third index three is compared with four they are not equal so j moves to the fourth index three is not equal to one so therefore we come to know that three is also unique in this array so we increment i now i comes to the second index so j starts from the third index one is compared with four so they are not equal so j moves to the fourth index now here one is equal to one so therefore we come to know that there are duplicates in this array and one is appearing at least twice so therefore we return directly true from the method so if we see via this approach we need two for loops one for i and one for j so using these two for loops we can figure out whether the array contains duplicates or not so the time complexity of this method is o of n square because this approach contains nested loops so this is not very efficient solution now can we reduce the time complexity from o of n square to less than that so one thing we can do is we can actually sort this array so when we sort this array in ascending order the elements will rearrange something like this one one three four and seven and now after sorting we can use one for loop to check whether the neighboring elements are equal or not so if they are equal we just return true and after the loop ends if we didn't find any duplicates then we can return false so via this approach when we are sorting the array the time complexity comes out to be n log n so this is a better approach and time complexity now is there any other way where we can reduce this time complexity so we'll look into that so in order to reduce the time complexity what we can do is we can use an additional data structure so let's say if we are using a hash set the property of hash set is it only contains unique elements now what we can do is we can iterate over this array we can take one one element and we check whether the hash set contains that element or not if it doesn't contain then we simply add it to the hash set and if hash set contains that value then we are sure that it contains duplicates so for example the first value is seven we check whether hash set contains seven or not so it doesn't contain so we put seven into the hash set then we check for three whether the hash set contains three or not so it doesn't contain so we put three into the hash set then we take one so one is not in the asset so we put one into the hash set then we take four four is not in the hash set so we put four into the hash set at last we get one so when we check whether one is there in the hash set or not we come to another one is already there so therefore we directly return true that we have found a duplicate now let's say instead of one there would have been six so we would have checked whether six is there in the hash set or not so it was not there so we put six into the hash set and after that there are no elements in this array to be traversed so at the end we would directly return false that there are no duplicate elements in this array now by doing this the time complexities we are iterating this array once so time complexity becomes o of n but space complexity increases because we are using an additional data structure so the space complexity is o of n but this is a much better approach because the time complexity is reduced now let's move ahead and see the animation of this algorithm step by step so this is the code where the method name is contains duplicate we pass in the array so at first when we call contains duplicate method we pass in the array now let's say if we are given with this array having values as 1 3 5 4 1 so at the first step what we do is we create a hash set so this is our set now as we discussed we just iterate each and every value once so we provide a for loop where i starts from zero index like this and i goes till nums dot length so here the array contains five elements one two three four five so nums dot length is five so it goes from zero index to fourth index so currently zero is less than five so this for loop executes now hash set has a method contains when we call this method it actually returns true or false if the element is present in the hash set returns true and if the element is not present it returns false so nums of i is nothing but the value at zero index so we check whether set contains one or not so here you can see set doesn't contain one so set dot contains will return false because this element is not present so we add this element into the set so one is added into the set now we increment i so i becomes one one is less than five we check whether value three is present in the set or not so set dot contains return false because three is not present so we simply add three into the set we increment i so i becomes two and two is less than five so this for loop will execute now nums of i is nothing but value present at second index which is five so we check whether set contains five or not so set doesn't have five so it returns false so we simply add five into the set like this we increment i i becomes three three is less than five so this for loop will execute we check whether value at third index which is four present in the set or not so this actually returns false because four is not present into this set so we simply add four into the set we increment i i becomes four four is less than five so this for loop executes now here value at ith index is one and when we check whether one is present in the set or not so one is already present in the set so set dot contains return true so it means we have found a duplicate in this array because one we inserted into the set at the beginning and again we found a one so set dot contains return true because one is already present in the set so it means that our array contains a duplicate so this if block is executed so here we directly return true we state that our array contains the duplicate now let's say if our array doesn't contains the duplicates so instead of one we put a six so after placing one three five four into the set the last element would have been six and if we do set dot contains six so it returns false and if block doesn't get executed so we simply add six into the set now when we increment i i becomes five and five is not less than five so therefore this for loop will terminate so at the end we directly return false stating that our array doesn't contains duplicate it contains unique elements so friends in this video we discussed the problem of contains duplicate i hope you must have liked this video thanks have a nice day hello everyone so in this video we are going to discuss about a very important topic which is intervals so in this video we are going to see a basic introduction to intervals and we will also see what are overlapping intervals now this is a very important topic for the coding interview there are questions asked on the concept of overlapping intervals so let's move ahead and see what are intervals and what are overlapping intervals so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so first we will see a basic introduction to an interval so usually an interval is actually a range which is represented by two numbers something like five comma eight six comma ten so an interval is a range where two numbers are involved now that two numbers are termed as start and end so here five will be our start and eight will be our end so these two numbers are basically start and end of the interval which actually represent a range now usually when we talk about interval they are correlated with time now when it is related with time this start and end can be any unit of time it can be milliseconds seconds minutes so here let's see the time interval of few tasks let's say task a has a time interval of one comma three b is time interval of four comma five c is time interval of eight comma ten d is time interval of nine comma eleven so if we take a time axis like this now here it could be seconds milliseconds nanoseconds it can be anything so let's say if we want to plot this task on this time axis and we take it as seconds so it suggests that task a has start time of one and it has end time of three so if we plot task a on this time axis it would look something like this that a task starts from one and ends at three so it means if we take it in the form of seconds task a takes two seconds to complete from one to three if we plot b it starts with four and ends on five so it takes one second if we plot c so the start is eight and end is ten so it takes two seconds to complete and if we plot d so it starts at nine and ends at eleven so it also takes two seconds so usually these time intervals represent a range let's say for a task or for a process and mostly the coding interview problems are given with these intervals so here we saw that an interval has two numbers start and end now let's see how we can represent this interval in form of a code so the interval representation looks something like this that there is a class interval now this is a custom class which we will create which has two properties start and end so this start will represent the starting point of the interval and end will represent the ending point of the interval so any interval takes only two numbers start and end and if you want to create an interval we have provided this constructor which takes in a start and end and initialize a particular interval with these numbers so this is how we actually represent an interval class so now let's move ahead and see the concept of overlapping intervals so what are overlapping intervals so let's say if you have interval something like one comma five and another interval as two comma six so if we plot these intervals it looks something like this this is one this is five and let's say two is here and let's say this is six so here if you see this is the first interval with one comma five and this is the second interval with two comma six so now if you closely look they are actually overlapping in this region from interval two to five so this actually suggests that these two intervals are actually overlapping with each other in this region two comma five so for an overlapping intervals we actually require two intervals at minimum let's say if we denote it by a and b so there will be some relationship between these two intervals so the first relationship would be that a and b do not overlap so it means a starts and ends here and b starts and ends here so here if we take an example let's say one comma three and four comma five so this is one interval and this is another interval but they don't overlap if we have interval something like one comma three and three comma four then that will overlap because the end time of first interval is equal to start time of another interval but here there is a gap between these two so they don't overlap the another thing would be a and b overlap but b ends after a so it would look something like this that a starts here and ends here and b starts here and ends here so here b is ending after a and this is our overlapping interval so if we take an example let's say one comma four and three comma six so here you can see these two intervals actually represent this condition that a interval starts from one and ends at four and b starts at three so it means this is one this is four this is three and this is six here b is ending after a so we can visualize these two intervals like this the third would be a completely overlaps b so it would look something like this that a is actually overlapping b completely so if you take an example it could be like one comma six for a and b could be two comma four so here one six two and four so it says that a is completely overlapping b so this could be one such case so the fourth case is a and b overlap a ends after b so this is pretty much same as this but here it looks something like this here b was ending after a but here a ends after b so these two are pretty much same only the names of the intervals have changed b completely overlaps a so this is pretty much same as a completely overlaps b so it would look something like this here a was completely overlapping b and now here b is completely overlapping a so here we just need to change the order of a and b so if this was a and this was b so here a would be two comma four and b would be one comma six rest everything remains the same and the sixth case is b and a do not overlap so this is pretty much same as a and b do not overlap so it looks something like this so from these are the six cases where we can demonstrate the overlapping intervals so for a situation where these overlapping intervals come we at least need minimum of two intervals and there could be many intervals like a b c d which can overlap with each other but we actually require minimum of two so friend in this video we covered what are intervals and what are overlapping intervals in our future videos we will see few problems related to overlapping intervals i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we discussed about what are intervals and what are overlapping intervals so now in this video we will look into a problem of merge intervals so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so if you look at the problem you are given with a list of intervals you need to merge all the overlapping intervals and return a list of nonoverlapping intervals so let's see it via an example let's say we are given with a list of intervals like two comma six one comma three eight comma ten and this intervals can be in any random order so we need to merge only those intervals which are overlapping to each other and at the end we have to return a list of all the nonoverlapping intervals so the output would be one comma six and eight comma ten now how this output came we'll see in a diagram so let's say we have this time axis and we have this intervals two comma six one comma three and eight comma ten we will plot these intervals on this time axis so first we will take two comma six so the start is at two and end is at six so this interval takes four unit of time now let's say if time axis is in seconds so this will take four seconds if we plot one comma three it would look something like this one is the start and three is the end and after that we will plot eight comma ten so it looks like this so this is two seconds interval and this is also two seconds interval so here if you see this one comma three and two comma six are overlapping to each other so this is the area where they are overlapping so it means we have to merge all the overlapping intervals so if we merge these two intervals together we will get a bigger interval whose start will be one and end will be six so here as these two are overlapping intervals when we will merge these two you can simply take this first interval and put it on the top of the second interval and that will be our merged interval so it looks like this the start will remain the same because this interval came first and the end will actually depend that which interval has the maximum capture duration so here in this case the first interval is completed at third second and the second interval is completing at the sixth second so we will take the max of three and six and it merges to one comma six so this is the merged interval because these two intervals are overlapping to each other but here if you see eight comma ten as we have only three inputs eight comma ten is not overlapping with any of these intervals and we have to return a list of nonoverlapping intervals so eight comma ten will remain as it is like this so therefore our answer is one comma six and eight comma ten if this eight comma ten would have been six comma ten or five comma ten then our answer would have been one complete merged interval of one comma ten so let's move ahead and see how we can solve such problems so for the overlapping interval in our previous video we saw the different use cases that when two intervals are overlapped with each other what happens so one such condition is a and b do not overlap so it looks something like this that there is a gap between these two intervals so we can't merge them now if a and b overlap but b ends after a so it would look something like this now here one thing we are assuming is a will always come before b so this diagram will make sense that b ends after a and if a and b overlap it would look something like this a completely overlaps b so it would look something like this but still a is coming before b b completely overlaps a in a case that both have same start time so b is completely overlapping a but a should come either before b or it can start at the same time so therefore we are taking this assumption and we will come to know later why it's important so this is one such case where b will completely overlap a but as a should either start at the same time as b or before b this would be one such use case now we will see all these cases and why they are important so with the first case when a and b overlaps and b ends after a so this is the case so when we will merge these two intervals a and b and let's say result we denote it via c now as we are merging these two intervals a and b here you can see the range of c which is start and end would be a start and b end so here you can think of any two intervals but one thing is sure both of the intervals either will start at the same time or one of the interval would be coming first so whichever interval is coming first its start will become c start and the value of c end will depend on the maximum expansion of any of this interval so here you can see as b ends after a b's end value will become c's end and after merge it will look something like this so let's say if a starts from one and ends at three and b starts from two and ends at five so here you can see this is the overlapping part so when we will merge these two intervals let's say we put a on the top of b so it will become something like it starts from one like this and ends at five so this is the merging we'll see another use case let's say a completely overlaps b so in this case if we merge these two intervals let's say we put a on top of b so it would look something like this let's see start becomes a start because this is the start of the interval and as a completely overlaps b c's end will become a's end like this so this is one such use case if we look at the third use case where a start is actually equal to b start and b ends after a so in this case if we merge both these intervals it would look something like this that if we put a on top of b the c start will be either a dot start or b dot start it will be same but the end will be b's end because this is the start and this would be the maximum value till both the interval goes so in all these three use cases one thing to keep in mind is we are assuming a will either start before b or at the same time of b so c start will be equal to a start this is sure and c end there will be a condition that we will take max of a and b end and whichever is the maximum value that will be assigned to c's end so in this case here you can see a end is three and b end is five so c end becomes five here you can see a completely overlaps v so a end is greater than b's end so therefore c end becomes a end and similarly here as b is completely overlapping a so b end is having a greater value than a ends so whichever is the maximum that gets assigned to c end and that will be our merged interval now one thing we discussed that a should start before b or at the same time but if we look into the problem we are given the intervals in random order let's say 10 comma 19 three comma four one comma two and let's say two comma three now we have to merge all overlapping intervals so one thing we need to keep in mind is we have to first sort all these intervals based on their start time once we get the start time this condition will come into picture that one of the interval is starting before the other and once we sorted based on the start time all the intervals start time will be in ascending order so we can directly compare one with the other and see if they are overlapping with each other or not so in order to solve this problem the first thing we need to do is we need to sort the intervals based on the start time so this condition will come into picture that a dot start will be less than or equal to b dot start so here a dot start in this case is less than b dot start in this case also it is less than b dot start but in this case a dot start is equal to b dot start so this condition is important so when we will sort these intervals the merging becomes easier here if you see let's say if you want to merge these two elements we know that a dot start is before or equal to b dot start so c dot start will directly becomes a dot start because a is coming before b but c dot end which we discussed here its value will be depend on whichever interval is going to greater time span so it would be max of a dot end and b dot end so here in this case a dot end was smaller than b dot end so c became b dot end in this case if we merge these two elements then b dot end was lesser than a dot end so when we merge it become a dot end and similarly here b dot end is greater than a dot end so therefore on merging c end becomes b dot end because we have to take the maximum of a dot end and b dot end so these two conditions are very important and once we do the merging of let's say two intervals we can keep proceeding ahead with all the overlapping intervals and we can check which are overlapping intervals and we can merge them so friend let's see the demonstration of this algorithm step by step so we have this merge method which actually merge the overlapping intervals and we are given with a list of interval and our task is to merge the overlapping intervals and return a list of all nonoverlapping intervals because once we merge all the overlapping intervals they all become nonoverlapping so first we will call the merge method we pass in the list of intervals so it would look something like this that this is the list of interval seven comma nine two comma six one comma three and they are in random order so the first thing we have to check that whether interval size whether it is less than two or not so if it is less than two it means list has either zero elements or one element it means there is only one interval or zero interval so we don't have to merge anything we have to simply return the same list back so this is one h case so currently interval dot size is three therefore it is not less than two now in order to compare whether all these intervals are overlapping to each other what we need to do is we have to sort all these intervals based on their start time so that we can come to know that whether there is any overlap or not so the list has a sort method which takes in a comparator and comparator has a comparing int method which actually returns a comparator now in this method this is a static method so in this method we are simply telling take each interval and sort it based on the start time so this comparing int method will take this intervals list will sort it based on the start time so the intervals will become something like this one comma three two comma six seven comma nine so start time so one is less than two two is less than seven so it has sorted based on the start time moving ahead now as we need to return a list of all nonoverlapping intervals we will create a result list like this so currently it's empty now as we are sorted the intervals based on the start time we will compare the adjacent intervals so that we can check whether they are overlapping or not so in order to compare all these intervals the first thing we do is we simply take the first interval as it is so this is the time axis and the first interval is one comma three so if we plot it here it looks something like this now our task is to compare this one comma three with two comma six and check whether anything is overlapping or not so for that we will create two variables start and end we will see its significance later so to the start variable we will assign first dot start because we are starting with this interval so start becomes one because first dot start is one end to end variable we will assign first dot end so first dot end is three so we are simply taking this two intervals start and end as one comma three and now as we have to compare it with other intervals we will take all these intervals in a for loop and we will start with one because zero is already taken so this is zero this is one and this is second index so we will start i from one so it would look something like this that we are now picking up two comma six and i is less than intervals dot size one is less than three so this condition comes out to be true now you can think start and end represents first and in the for loop currently we are on two comma six so this becomes our current interval and this can be treated as previous intervals so from this list we will get that interval by calling intervals dot get we will pass the value as one so we will get two comma six so this will be assigned to the current like this and if we plot it here you can see two comma six now our task is to simply check whether two comma six is actually overlapping with any of the previous intervals or not so we will check whether current dot start is less than equal to the end so we are not doing first dot end because there could be many intervals before this current interval and start and end will represent just the previous interval which are being merged or nonoverlapping we will see its importance later so we are simply comparing current dot start whether it is less than equal to end so here you can see value of end is three current dot start is two so this is the start for current it is less than end so it means that there are overlapping intervals and if you see why this example one comma three is actually overlapping with two comma six so this condition comes out to be true which means we have to merge these two intervals now so once you merge these two intervals let's say the result interval is c so we also saw that c dot start was equal to a dot start which always remains a dot start because a is either starting before b or at the same time as b so here our start will remain one only it won't get changed but c dot end will become the max of a dot end and b dot end so here this is the condition for that that we are simply taking the maximum value of current dot end which is the current interval and value of end which is the value of its previous intervals which is three so if we do three comma six max we get six so here you can see our start will remain the same but end will change to six now because we are merging these two overlapping intervals so end will become six moving ahead so here you can see one reason of picking start and end in a different variable is as we have merged these two intervals start became one and end became six and there could be a possibility that once we move ahead in the array there could be another intervals like this so here in this case all these intervals will get merged together so therefore only the end will get expand till the intervals are overlapping and start will remain the same so therefore we have created these two variables which are doing those things these two variables are keeping the state of the previous intervals which are merged or which are yet to merge so now we'll increment i i will become two two is less than three so this condition comes out to be true now this is our current interval seven comma nine so when we will do intervals dot get two we'll get seven comma nine as our current interval like this so now our task is to merge current with previous already merged intervals so we have to check whether seven comma nine is overlapping with any of the previous intervals or not so that value is actually hold by start and end so here if we see current dot start is this value and current dot end is this value so here you can see current dot start is seven and value of end is six so it means current dot start is not less than or equal to end because value of end is six and current dot start is seven so here you can see there is a gap between these two intervals therefore they are not overlapping with each other so this condition comes out to be false so the else part will be executed and in the else part as we have already found one gap in between these two intervals and this interval we can now safely merge these two intervals because when we go ahead these two intervals will not be get affected and we can simply merge them and add it to the result so in the result we are adding new interval start comma end so we are creating a new interval of start and end which is one comma six and we are adding it to result so it would look something like this that it is merged like this and it is added to result list moving ahead so once we have merged these two intervals and there is a gap between the current and this merged interval now our task will be to focus from seven comma nine to rest of the elements ahead we have to forget this merging now because we have already merged these two intervals and there are no more intervals which can get merged to these two intervals so therefore we have to forget this part now and as you have started with one comma three at the start because that was the first interval now we have to start from seven comma nine thinking it is the first interval so therefore now start will become current start we will assign the value of current dot start which is seven to start and end will become current dot end which will become nine so this is now our fresh interval and if there are more intervals after seven comma nine this seven comma nine will be compared with these intervals and these intervals are already merged and they are added to the result list so we don't touch them now moving ahead we will increment i so i will become three and i is not less than three therefore this condition comes out to be false and for loop will terminate because there are no more elements left to be compared with this seven comma nine so this for loop will terminate and one thing to notice as soon as this for loop will terminate whatever the value start and end will hold that will hold an actual interval which also needs to be added to the result so here you can see seven comma nine was the single most interval left and there are no more intervals left which can be merged with seven comma nine so this seven comma nine also needs to be added to the result list so at the end we have to add this seven comma nine also to our result list because this is a nonoverlapping interval so we do result dot add new interval and we pass the value of start and end which is seven comma nine so it would look something like this that this is also one such nonoverlapping interval and our task was to merge all the overlapping intervals and only return the nonoverlapping intervals so one comma three and two comma six got merged to one comma six and seven comma nine didn't get merged with any of the interval so it came out as seven comma nine so these two are our answers one comma six and seven comma nine so at the end we will simply return the list of interval which is our result list so friend this was all about the problem how to merge and overlapping intervals and return back all the nonoverlapping intervals i hope you must have liked this video in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we actually saw the problem of merge intervals so in this video we will actually see one more problem insert interval so friends before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so in this problem we are given with a list of nonoverlapping intervals which are sorted by their start time we are also given with a interval which we need to insert into the list at a valid position in such a way that if that interval overlaps with any of the intervals which are given in the list then we have to merge all those intervals and return back a list of mutually exclusive intervals which means we need to return back a list of intervals which are different and nonoverlapping so let's see an example let's say we are given with this list of intervals 1 comma 3 5 comma 7 8 comma 10 now they are nonoverlapping and sorted by their start time and let's say we are given with this new interval 4 comma 9 our task is to insert this 4 comma 9 into this list in such a way that if this new interval overlaps with any of the interval given in this list we have to merge it with new interval and return back a list of mutually exclusive intervals so the output is 1 comma 3 and 4 comma 10 now how this output came let's see via diagram so this is our time axis and if you plot all these intervals on this time axis it would look something like this 1 comma 3 5 comma 7 8 comma 10 we have to insert 4 comma 9 so it will go from 4 to 9 so here you can see this 4 comma 9 doesn't overlap with 1 comma 3 so 1 comma 3 doesn't get affected by insertion of 4 comma 9 because they are not overlapping so 1 comma 3 will be part of our answer because it's mutually exclusive so this is the first part now here you can see when we will insert 4 comma 9 it will affect 5 comma 7 and also 8 comma 10 so as 4 comma 9 is completely overlapping 5 comma 7 if we put 5 comma 7 on top of 4 comma 9 that means merging of these two intervals will not get affected because 4 comma 9 is already overlapping completely 5 comma 7 but in this case 4 comma 9 is ending at 9 and 8 comma 10 is ending at 10 so if we put 8 comma 10 on top of 4 comma 9 the region will get expanded till 10 and as 4 is less than 8 so start will remain the same but end will change because 4 comma 9 is overlapping with 8 comma 10 and when we merge these two intervals we take the end time of both the intervals and we see which is the maximum so here 10 is the maximum so the merge interval will be something like this it would be 4 comma 10 so the next output is 4 comma 10 now let's move ahead and see some of the concepts behind this insertion and merging let's say we are given with these two intervals we need to insert a so a and b are non overlapping so it means we can simply insert a without touching b so we simply insert a now let's say a and b are overlapping so when we will merge these two interval their area will be from here to here so this is the start of a and this is the end of b so if we take this interval as c then we have to keep a formula as c start time will become the minimum of a dot start and b dot start and the end time will become the max of a dot end and b dot end so this condition comes into picture if they are overlapping so here you can see let's say if we give it a value as 1 4 3 6 so we know that when we will merge these two intervals the minimum of 3 and 1 so c will become 1 and maximum of 4 and 6 will be 6 we know that the area of this merging will be 1 comma 6 because we have to accommodate both the intervals so this formula comes handy minimum of a dot start and b dot start a dot start is 1 b dot start is 3 so minimum is 1 and c's end will become max of a dot end and b dot end a dot end is 4 b dot end is 6 so c's end will become 6 so this interval will expand from 1 to 6 so c becomes a dot start which is this and b dot end which is this similarly here a completely overlaps b so if we apply this formula the c will become a dot start because a dot start is coming before b dot start and c dot end will become a dot end because it is coming after b dot end we have to take the max value and if this is the scenario then by applying this formula c start will become b start and c's end will become a's end so this would be the area of the c interval and if b completely overlaps a and if we want to insert a so by applying this formula c start will become b start and c end will become b's end so this is how we actually insert and merge the intervals together now let's see why an example if we have these four intervals which are nonoverlapping sorted by their start time and we have to insert a new interval 4 comma 9 so if we plot all these intervals on the time axis it would look something like this 1 comma 3 5 comma 7 8 comma 10 11 comma 12 our task is to insert 4 comma 9 so here as we want to insert this new interval from 4 to 9 there will be three region around this 4 comma 9 which will get affected when we will insert this new interval so one region is just before 4 4 which is this another region is this between 4 to 9 and the third region is just after 9 so here we are taking the region 1 as just before 4 not even equal to 4 and here just after 9 not even equal to 9 because if any of the interval touches this boundary like this then they also need to be merged because they are overlapping with each other and so we need to keep this condition in mind that in region 1 we have to simply check for less than intervals in region 3 it should be greater than the end time and in this region if they overlap we have to directly merge them so how we can solve this type of problem is we have to take these three regions first we have to take all the intervals which are part of region 1 and all the intervals which are part of region 1 will satisfy this condition that their end time let's say this part is less than the new interval start time it means they are not overlapping there is a gap so this less than condition is helpful if they become equal then they actually overlap and we have to merge them so first we cater for less than condition and we figure out what are all the intervals which are not touching 4 comma 9 so those intervals we directly take into our result list because they are not touching 4 comma 9 and they are not overlapping 4 comma 9 so let's say if there are n number of intervals before 4 so we have to check each interval's end time and check whether it is less than the new interval start time if it is less than the new interval start time we know that they belong to this region so after placing all the elements of region 1 we come to region 2 now here what we check is let's say if we take this example so here if this interval has to belong in region 2 what we do is we take its start time and we check whether it is less than or equal to the new interval's end time now here we are checking for this condition less than or equal to so let's say 5 is less than 9 so it means this interval belongs to region 2 because we have already excluded the region 1 intervals and if any of the intervals is left if this condition satisfies that 5 is less than 9 or equal to 9 then this region even if it expands beyond 4 comma 9 it will still overlap with 4 comma 9 and why we are taking this equal condition is because let's say instead of 8 comma 10 we have 9 comma 12 so 9 is the start time and if 9 is equal to new intervals end time so still it is overlapping with this interval and we have to merge them so it still belongs to region 2 so this is the main condition for region 1 all the intervals end time should be less than new interval start time so they will completely belong into this area and they will be non overlapping in this region they will overlap so we have to simply check the interval start time and we have to check it is less than equal to the new intervals end time if that is the condition they still overlap and we have to merge them so here if you see 4 comma 9 overlaps 8 comma 10 because 8 is the start time and it lies before 9 because 8 is less than equal to 9 so therefore when we will insert this interval it will affect 5 comma 7 and 8 comma 10 and we know the formula that how to merge the two intervals together which we saw in our previous slide so after we add all these elements into the list whatever elements are remaining these are out of the boundaries of this 4 comma 9 which is the new interval which we want to insert so we can directly add them into the list they won't get affected by the insertion of this new interval so after merging 5 comma 7 is 4 comma 9 and 8 comma 10 with 4 comma 9 it will become something like this so our overall answer becomes 1 comma 3, 4 comma 10 and 11 comma 12 so the algorithm is something like this we have to skip and add intervals that come before the new interval to the result list so all the intervals of region 1 which are coming just before the new interval we have to simply add onto the list we have to merge all the intervals that overlap with the new interval so this interval and this interval they are overlapping with this new interval so we have to merge it with this new interval we have to add that merged interval into the result so this is the interval which gets merged we add this into the result and finally we insert the remaining intervals to the result so these are the remaining intervals, there can be many intervals like this, we have to just insert them to the result because they are nonoverlapping and mutually exclusive. So this region covers this part, this region covers the overlapping part and this region covers all the remaining elements. So all these regions will be captured by a simple while loop in the algorithm. So let's move ahead and see the algorithm. So this is the algorithm. So this while loop is for the region 1 where we simply skip the elements which just come before the new interval. This while loop is covering the intervals which are getting overlapped with the new interval and this while loop is just adding the remaining intervals. So let's see the demonstration of this algorithm step by step. We'll call the insert method, we'll pass the list of intervals and a new interval which you want to insert which is 2,6. So let's say we have list of intervals as 0,1,3,5,6,7,9,10 and we need to insert 2,6. So if we plot all these intervals on the time axis, it would look something like this, 0,1,3,5,6,7,9,10. We need to insert 2,6 which is from time 2 to 6. Moving ahead. So here we are just simply checking for the base cases. That if list is null or empty, we simply return the list. So currently list is not empty and it is not equal to null. So for the new interval, you can think that it's a valid interval. As we have to return the list of mutually exclusive intervals, we will create a result list which is currently empty. Now as we need to traverse each and every element of this interval list, we will create an integer i starting from 0 index. So first we are picking 0,1. Now in this while loop we are checking that whether 0,1 when this 2,6 will be inserted into the list of intervals, will this get affected or not. So first we check whether i is less than intervals.size. We are simply checking whether value of i is less than interval.size which is 4. Because as we are traversing each interval one by one, there would be a time that i will completely traverse all the elements. So we need to break from the while loop at that moment. So currently i is less than intervals.size. The other condition we check is, we get this interval. So we do intervals.get i. So we get 0,1. And as we discussed, we will check its end time with the new interval start time. And we check whether this interval's end time is less than new interval start time. Because if it is less than new interval start time, it means they are not overlapping, there is a gap between. So intervals.get i is this interval. If we do dot end, we get 1. We check whether 1 is less than newintervals.start. So new interval.start is 2. So 1 is less than 2. So it means this condition comes out to be true. This signifies that 0,1 doesn't overlap with 2,6. And we can simply skip this element and add it to the result list because this won't get affected by insertion of this new interval. So 0, becomes part of the result. Now we will increment i. i will come to the index 1. So i is less than intervals.size which is 4. Intervals.get i which is 1 which is 3,5. Now we are at 3,5. We check whether this interval's end is less than newintervals.start. So here this interval.end which is 5. We check whether it is less than newintervals.start which is 2. So this condition comes out to be false. We suggest that all the intervals which were just coming before new interval have already been part of the result. And once we reach on this interval, this condition comes out to be false which actually states that 3,5 will either lie in the area of new interval or beyond that. But it won't lie here in the region 1 because this condition came out to be false. So ideally this while loop will terminate which signifies that all the intervals which were coming before new interval have been added to the result list. And we can move ahead with another while loop. i is less than intervals.size. Now here we actually check for the second region that whether 3,5 is overlapping with 2,6 or not. And we already discussed how we can do that is intervals.get i which is this interval. We simply check its start time which is 3. We check whether it is less than or equal to newintervals.end. So 3 is less than or equal to newintervals.end which is 6. So which is true. So it means these two intervals are overlapping which is being proved by this condition. And so the condition in while loop comes out to be true. So first we will get this interval 3,5 we assign it to current like this. Moving ahead. Now as we need to merge 2,6 with 3,5. So we know the formula that if we merge two intervals let's say a and b and let's say the result interval is c. So it becomes c start becomes min of a.start, b.start and c's end will become max of a.end and b.end. So here these two are the same conditions and here c is our newinterval only. We are simply merging 3,5 into the newinterval only. So newinterval start will become the minimum of current start which is this and newinterval start which is 2. So minimum of 3,2 will give 2. So newinterval.start will become 2 which is already 2. So this won't get changed. Now newinterval end will become max of a.end and b.end. So current.end and newinterval.end we take max of it. So current.end is 5 and newinterval.end is 6. So if we take max of it we get 6 which is assigned to newinterval.end. So newinterval.end doesn't get changed because it is already 6. So it means we have merged these two intervals and the resulting interval is same 2,6. Because this newinterval completely overlapped the current interval. Moving ahead, now we are done with this interval also. So we will increment i, i reaches to 6,7. So here i is less than intervals.size. Now here if we do intervals.get i, we get 6,7. So friends here you can see that why this less than equal to is important. This 6,7 is starting where this newinterval is ending. So it means they are still overlapping because the interval start which is 6 is actually equal to newinterval.end which is also 6. So therefore they are overlapping and we have to merge these two intervals as well. We can't exclude 6,7 because it is just overlapping with 2,6. So this condition is important. So the overall condition in while loop comes out to be true. We do intervals.get i, the interval 6,7 will be assigned to current like this. And we have to merge these two intervals now. So we will use the same formula. The newinterval.start will become the minimum of current.start which is 6 and newinterval.start which is 2. So minimum will give 2. So newinterval.start will become 2 which is already at 2. Now newinterval.end will become the max of current.end and newinterval.end. So max of current.end which is 7 and newinterval.end which is 6. So it will give 7. So here is the one critical step that newinterval.end will become 7 now. Because after merging these two elements, the newinterval will expand to 7 like this. That we have merged these two intervals. Moving ahead, we will increment i, i becomes 9, 10, i is still less than intervals.size because value of i is, this is 0, 1, 2, 3, 3 is less than 4. Intervals.get i which is 3 will give 9, 10. And here you can see this 9, 10 is actually belonging to the third region. So therefore it starts if we compare it with newinterval.end. So 9 is less than equal to newinterval.end which is 7. So this condition comes out to be false. It means 9, 10 is the remaining element and it doesn't overlap with 2, 7. So we can directly add this 9, 10 and all the elements after that via this while loop. So this condition comes out to be false. So here you can see that before adding 9, 10 into the result list, we have to also insert 2, 7 which is our merged interval into the result. Which is actually merging 2, 6 which was our newinterval with 3, 5 and 6, 7. So after these three intervals merge, we get 2, 7. So this is one important step, we have to add this newinterval into the result. So it will become like this. And now using this while loop, we will add the remaining interval into the result. So i is still less than intervals.size. And as this condition reaches this while loop, we are sure that all the remaining elements will be nonoverlapping with this newinterval. So we can directly add 9, 10 to the result. We do result.add and we pass in intervals.get i which is 9, 10. So it looks something like this. And then we increment i. So i goes beyond the boundaries of this interval list. And now this while loop condition comes out to be false because value of i is 4 and interval.size is also 4. 4 is not less than 4. So this condition comes out to be false. And at the end, we simply return the result which is 0, 1, 2, 7 and 9, 10. 0, 1 doesn't overlap with this newinterval and 9, 10 also doesn't overlap with this newinterval. 3, 5 and 6, 7 were merged with 2, 6 and became 2, 7. So this was the answer. So friend, this was all about the algorithm. I hope you must have liked this video. In case if you are new to my channel, then please subscribe to my channel and click the bell icon so that you never miss any update. Thanks have a nice day. Hello friends, welcome to my new data structures and algorithms in java tutorial series video. Friends in this tutorial, we will discuss about the try data structure, we will discuss about what is a try and what are its real life applications. So friends, what is a try? So here you can see the word try actually came from the word retrieval. So the main purpose of this data structure was to retrieve the stored information very fast. So basically in real life application, we actually store the collection of strings inside the try and whenever we want to get that string, we can retrieve that string very fast. Below you can see the symbolic representation of a try data structure. So here you can see that green circles are nothing but the try nodes and multiple try nodes actually form a try and also you can see the topmost node is actually empty which is being pointed by the root. So root actually points to an empty try node and from the root, the other words originate. So here you can see let's suppose if we store these four words into a try data structure, then here we actually start from the root which is an empty try node and let's say for an example as you want to store a word dog, then we simply create three try nodes storing one alphabet into it and the try node pointing to others in sequence. So friends here you can see that from root we pointed to node D, then from D we pointed to node O, from O to G. So friends after storing G, we know that dog is in the try. So we mark the last node in yellow color stating that this is the end of the word. For example if we take head, then from root we point to H, from H we point to A and from A we point to T. Now as T is the end of the word, we usually mark it in the yellow color. Moving ahead, friends if we talk about the applications of a try data structure, then here you can see the one application would be the autocomplete of the words. So friends you must have searched something on the Google search engine. So there as soon as you type something, the search engine suggests the complete word to you. So this autocomplete feature is basically implemented with the help of tries. Moving ahead, the other application would be the search contacts in phone. So friends in your smartphone whenever you want to search any particular contact, you just type the initial letters of the person name and the application automatically suggests the name of the persons. So this application is also implemented with the help of try data structure. Also friends one more application would be the spell checking. So here you can see that many editors such as word pages implement this spell check. So here what happens whenever user types any wrong spelling, the application auto suggests the correct spelling. So here you can see the spelling is wrong, therefore the application is suggesting the correct spelling so that user can select from one of these options and correct the spelling. So friends this was the introduction to the try and also its applications. In our upcoming tutorial we will discuss more on how to implement a try in the try node and other methods which try supports. Thanks have a nice day. Hello friends welcome to my new data structures and algorithms in Java tutorial series video. Friends in our previous tutorial we actually discussed about the try data structure and also about its usage in real life applications. So in this tutorial we will actually see how we can represent a try node in Java. So friends what is a try node? So friends in our previous tutorial we actually discussed that the try data structure most of the time store the collection of strings. So here a try node basically represents a single alphabet of the word. So here you can see if you take an example of dog. So this green circle having the word as D is nothing but a try node and let's say in order to store a word dog which is three alphabet we actually need three try nodes which is one for each alphabet. So here you can see the topmost try node is empty which is being referred by root and all the words which you want to insert into the try originate after that. So here let's take an example of word head and let's say we want to store the head into this try data structure. So from the root we need to create three try nodes storing three alphabets such as H A and T. So here you can see we have created three try nodes from root there is a link to H from H there is a link to A and from A there is a link to T and as T is the end of the word therefore we are marking it in the yellow color. So friends let's see about the representation of a try node in try. So a try node class in try consists of two data members. So here you can see a try node has two data members. So the first data member is nothing but an array of try node which are nothing but the children of that particular try node. So here it's an array which refers to other try nodes in try and also they are called as the child nodes of a particular try node. So friends here you can see in the most of the applications we actually store the English words therefore the size of the array is usually taken as 26 because there are 26 alphabets in English language. So here if you take an example of this try node there here you can see that there is one link to D and there is one link to H and similarly it refers to the other letters of English alphabets and that referring is done through an array which actually refers to other try nodes and let's say if you are on a particular try node and it refers to other try nodes then those are nothing but the children of that try node. So here the try node array is nothing but the first data member which a try node holds. So if we talk about the second data member so it is nothing but a boolean value which signifies that a void has ended or not. So here you can see in this symbolic representation of try we know that dog is a complete word so here you can see from D it goes to O and from O it goes to G. Now we need to pass some information to this node so that we can come to know that this word is in the try and it is the end of the word. So usually in the symbolic representation we mark this node in the yellow color stating that it is an end of the word but in Java we actually create a boolean value. So this value set as true when a word is inserted completely. So friends we will discuss more about these two properties in upcoming tutorials so that we can understand more about the representation of a try node in try. So friends let's see the demonstration of a try node. So friends if you take an example of hat so we can see how it gets represented into Java because here you can see the symbolic representation and here you will see the actual representation. So at the top there is a root which is empty. So in Java we represented something like that a try node root points to an empty try node which has an array of size 26 because we have this 26 alphabets from A to Z. And when we actually initialize a try root points to an empty try node. So here you can see the default value of this word is false and also you can see the size of array is 26 and each index points to a different try node but here when we initialize this root they all point to null value. Now let's suppose we want to insert H so in order to insert H we need to create a try node and from H we need to refer that. So here it looks something like this that we have created one try node and from H we are simply pointing to this try node. So this represents that there is a children to the root whose value is H and its default value is false because this is not the end of the word and then we actually insert A. So here you can see that A points to null. So then we create a try node and we simply provide a link from A to this try node stating that there is a children which points to A and finally let's say we insert T so it would look something like this that initially T was pointing to null but then we created a try node and we simply provided a value of this try node into this index. So T points to this try node and friends here you can see as this is the end of the word we simply mark the boolean value to be true. So friends here you can see if you are storing the English words then each try node will actually point to the other 26 try nodes so that they can store a particular word. So here we actually saw that root which is an empty node it points to H, H points to A and A points to T and also when all the other values of this array points to null because there are no more words inserted here. So you can see that all other links points to null and also friends here you can see that this is an array so 0th index points to A, 1th index points to B, 2nd index points to C and similarly 25th index points to Z. So how this mapping is done we will discuss later. So for now you can keep an information that a particular try node has an array which refers to other try nodes and whose size is basically 26 if we are taking the English words and it also has other property which tells that whether a particular word has ended here or not. So friends in our upcoming tutorial we will actually discuss more about this try nodes and how this linking is done and how this mapping is done of English alphabet to the index of an array. Till then have a nice day. Hello friends welcome to my new data structures and algorithms in Java tutorial series video. Friends in our previous tutorial we actually discussed about the representation of a try node in Java. So in this tutorial we will actually see how we can implement a try in Java. Friends in our previous lecture we saw about the representation of a try node in try that a try node has two data members. One is the try node array which actually points to the other try nodes and which are also called as try nodes of that particular try node and we also discussed that if you are taking the English words then the size of this array is 26 because the English language contains 26 alphabets. Also friends the second data member is nothing but a boolean value which indicates the end of the word. So we said this value is true when we know that word is inserted completely. So we will discuss about these two data members in depth in our upcoming lectures. So friends let's see the implementation of the try class. So friends here try will be implemented using the try node class which we actually discussed in our previous tutorial. You can also see that root try node is at the top of the try which has an empty value and it has a try node array which actually refers to other try nodes. So here you can see if you are working with English alphabets then there are 26 links and these links actually point to other try nodes signifying that there is a letter into a try or they actually point to null. So friends in the try class we actually create an instance variable of try node and we give it a name as root and whenever we initialize this try class we simply create an empty try node and then using that root try node we actually insert the other try nodes signifying that there are letters into this try. Moving ahead friends now here we will discuss about the character and the index mapping that how it is done. So friends as here you can see that it is an array of try node and array is indexes. So in order to store this English alphabets we usually take the values of the index and we map it to the alphabets. So here into this array we are not actually storing these values we are actually using the indexes and we are figuring out the alphabets. So here you can see A points to 0th index, B points to 1th index, C points to 2nd index and similarly the rest of the alphabets. So how this mapping is done let's use demonstration through a code. So here you can see a char in Java is nothing but a 16 bit value which starts from 0 and goes till 65,536. So here we are creating a char value which points to A and let's say if we type pass it to integer value then it prints 97. So this 97 is nothing but the ASCII value of this character A and let's say next step from A we minus the char value A it prints 0. Similarly let's say we define another value H and if we subtract the char value A from H it prints 7 because from A H is 7 step ahead and similarly if we define a value Z and on the console if we print Z minus the char value A it prints 25. It signifies that Z is 25 values away from A. So friends here you can see that we can actually map the character with an index value by using a formula that whatever the letter we pass and if we subtract the value A we will actually get the index value. So for example if we pass A and if we minus A from it we get 0. If we pass H and if we minus A we get value 7. If we pass Z and if we subtract A then we will get the value 25. So friends in try as we are referring to this array we are implicitly mapping the index value to character. We are not actually storing these characters but any particular index value we are simply mapping it to a character. So from this implicit character to index mapping we will be using in our upcoming tutorials when we will actually insert a word into a try and when we actually search for a particular word in try. Also friends in our previous tutorial we actually saw this demonstration. So let's look it one more time to make it more clear. So here you can see the root trinode is empty and whatever the values we will be storing we will be actually storing into the childrens of the root. We won't be storing any value inside this root because this root is also a type of trinode which refers to other trinodes through this array which are nothing but the child of this root. So let's say we want to insert H so what we do is we simply traverse the H index we see that its value is null. So then we create a trinode like this and then we will simply refer its value into this index moving ahead let's say we want to store A. So as soon as we have inserted a value H and after that we have to insert A so we use this link to traverse through this trinode and then we go to A and we see that its pointing to null. So then we create a trinode and whatever value it has we simply put it into this index and similarly after A we go to T so from this trinode after inserting A we simply traverse through this trinode we go to the index which maps to T and we see that it has null value so we will simply create one trinode and whatever the value this object will hold into the memory we will simply store it into this index because here a particular trinode actually refers to other trinodes so here this trinode is actually referring to this trinode from the index whose character value is T also when a T is the end of the word which is marked here as in yellow so what we do is we simply set the boolean value of its word to be true signifies that we have completely inserted the word hat into this tri so from in this tutorial we actually saw the implementation of a tri that it is made up of a trinode now let's go to eclipse and implement a tri hello friends in our previous tutorial we actually discussed about how to implement a tri we also discussed that how a trinode is represented into a tri so in this tutorial we actually code the basic implementation of a tri data structure so here I have created one class by name tri having a main method so let's start our implementation so friends in our previous tutorial we discussed that a tri is implemented by a trinode class so first we'll create a inner class and we'll give the name to it as trinode also friends we discussed that a trinode has two data members one is trinode array which are nothing but children of this trinode the other data member is a boolean value we signifies that this trinode is nothing but end of the word so we'll give it a name as its word we'll also provide a constructor to this trinode and inside this constructor we will initialize this trinode array with the size as 26 because here we are storing English words so these words are from A to Z also the value of this word is by default false so we set its value to be true when this trinode is actually an end of the word also friend we discussed that a tri contains an instance variable whose type is trinode which is nothing but the root of the tri data structure so this trinode which is the root will point to other trinode through this trinode array will also provide it a constructor so whenever we initialize the tri class we simply create the instance of trinode and we'll assign it to root so here root is empty so here whenever we initialize the tri class root points to the trinode which is empty and after that we insert a particular word character by character which this root points so friend this is how we actually implement a tri using this trinode class also friends in our upcoming tutorial we'll see that how we can insert a particular word into this tri we'll also discuss that how we can search for a particular value that whether it's there in this tri or not so friends in our upcoming tutorial we'll actually see how we can insert a word into this tri and we'll also see that how we can search for a particular word into this tri so friends i hope you like this video thanks have a nice day hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss how to insert a word in tri so friend let's see a demonstration of how to insert a word in a tri friends in our previous tutorial we discussed that whenever we initialize a tri class root points to an empty trinode because in the constructor of the tri we create a new trinode and we simply assign it to the root now for example let's say we want to insert a word as cat so here you can see the word cat has three characters c a and t and as we are using the english alphabets we will initialize this trinode array with a size of 26 where index 0 will correspond to a index 1 will be corresponding to b and index 2 will be corresponding to c and similarly index 25 will correspond to z friends we also know that each character in this word will be represented by a trinode so using this root so first we will insert c from the root so here what we do we go to index 2 which maps to character c and you will see that whether trinode at index 2 is null or not so currently as root is empty the trinode at index 2 is null therefore in order to insert the character c first we will create a trinode and after creating this trinode we will simply refer it from the index 2 which maps to c also friends once we insert this trinode using this link we simply traverse to this position and after reaching to this trinode now we will insert a so what we do is we simply go to the index 0 which maps to a and we'll see there whether it's null or not so currently you can see that it points to null so in order to insert a we'll again create a trinode and after creating the trinode we'll simply refer to this trinode from index 0 which maps to a also friends once we have inserted this trinode using this link we will simply traverse to this trinode and then we will insert the character t so when we reach to this trinode we simply traverse to index which maps to t and we'll see that whether it's null or not so here you can see it points to null so in order to insert t we'll first create a new trinode and then we will simply refer to this trinode from the index which maps to t also friends once we insert this trinode using this link we'll simply traverse to this trinode and after we reach to this trinode we see that there are no more characters left to be inserted so we also know that this is the end of the word so in order to mark cat as the end of the word what we do to this trinode we simply assign the value as true so this value signifies that when you reach to this trinode this makes end of the word and it also signifies that cat is in the try friend let us take one more example we'll insert a word sun so when you call the insert method we'll start from the root and as we want to insert s we simply reach to index which maps to s and we'll see that whether it's equal to null or not so here you can see it points to null therefore in order to insert the character s we'll first create a trinode and we'll simply refer to this trinode through this link from the index which maps to s and after we insert this trinode we simply traverse to this trinode through this link and once we reach to this link we'll now insert the character o so here we go to index which maps to o and we'll see whether it points to null or not so here you can see it points to null so in order to insert o we'll again create a trinode and we'll simply refer to this trinode through this link from index which maps to o and then we'll simply traverse to this trinode and after we reach to this trinode we'll now insert n so we simply traverse to index which maps to n and we'll see whether it's equal to null or not so here you can see it points to null therefore in order to insert n we'll again create a trinode and after we create a trinode we'll simply refer it through this link from index which maps to n and also friends here you can see now this word has inserted completely so using this link when we reach to this trinode we'll now simply mark this boolean value to be true which signifies that this is the end of the word so moving ahead now friend let's suppose we want to insert a word so so here you can see we have already inserted sun and the word so is prefix to sun so let's see how we'll insert so into this trinode so we'll start from the root we go to index which maps to s and we'll see whether it points to null or not so here you can see this time it's not pointing to null and it is pointing to a trinode which signifies that there is a character s into this tri so we'll not create a new trinode and we'll simply traverse to this trinode and then we'll insert o so here we'll reach to index which maps to o and we'll see that whether it points to null or not so here you can see that this index doesn't point to null and it points to a trinode which signifies that there is a character o into this tri so what we'll do is simply traverse to this trinode now using this link and once we reach to this trinode we see there are no more characters left to be inserted so in order to mark this word so that it is present into this tri what we'll do we'll simply assign a value true which will signify that this is the end of the word and the word so is present into this tri so friends this boolean value is very important which let us know that whether the particular word is present into this tri or not also friends if we see the symbolic representation of this tri then it looks something like this that root is empty and from root there are three words c a t t is the end of the word and sun s o n where n is the end of the word and also so where o is the end of the word so basically this tri has three words moving ahead friends whenever we insert into a tri there are few use cases which we will look one by one so the first use case is let's say we have an empty tri and now we are inserting a completely new word so when we say an empty tri it means root is pointing to an empty trinode and let's say we insert a word as cat so from root we will first insert c so it would look something like this then we'll traverse to c and now we'll insert a so it would look something like this and then we'll traverse to a and finally we'll insert t so it looks something like this and then we will traverse to t and we know that now we have inserted this word completely therefore we will mark t as the end of the word by making it in yellow color so this was the use case one now from the second use case is when we want to insert a word into this tri and this tri contains already many words but the word which you want to insert has no prefix to this word so the new word which we are inserting is completely altogether new to all the words inside this tri so here let's suppose we want to insert sun so here you can see that sun doesn't have any prefix to cat so this is an altogether completely new word into this existing tri so we'll see how we can insert sun into this tri so we'll start from the root and first we will insert s so it would look something like this that there is now another branch which takes in a word s from the root first one and we also discussed that root has a tri node array which points to all the english alphabets so in this tri node array from the index which maps to c there is a word and from the index s we will start inserting our new word so after we insert s we'll simply traverse to s and then we will insert u so it would look something like this and after we insert u we simply traverse to u to insert n so it would look something like this and once we insert n we'll simply traverse to this node and here we also that we inserted this word completely therefore we'll mark this node as the end of the word by making it in yellow color friend use case three is insertion with word which is having a common prefix so you can see in our trial there is already one word there and let's say we want to insert a word there so you can see both these words have common prefix so the letters t h e is also present here t h e so these three letters are common to this both words so let's see how we can insert there into this tri so here we'll start from the root and we'll see that whether t is present or not so here you can see t is already present so we'll simply traverse to t and once we reach to t we see whether h is present or not so h is already present so we'll simply traverse to h after that we'll see that whether e is present or not so here e is present so we'll simply traverse to e and now we'll see that whether i is present or not so here you can see i is not present so here from e there would be another branch coming out we'll create a new tri node i and we'll simply link to this new tri node from e so it would look something like this that from e there is a link to a character i and once we insert i we'll simply traverse to i and we'll finally insert r so we'll check whether r is present or not so here you can see r is not present so we'll create a new tri node and we'll insert r and finally we see here that it is the end of the word so we'll simply mark r as the end of the word also friends one final use case would be that insertion with word already present into the tri so here let's suppose our tri consists of a word daddy so it has five nodes which points to d a d d y and let's suppose we want to insert a word dad so we know that dad is already present into this tri tri but we need to perform some work to make sure that dad is inserted into this tri so what we do is we start from the root we see whether d is present or not so d is present so we'll simply traverse to d we check whether a is present or not so a is present so we'll simply traverse to a we check whether d is present or not so d is present so we'll simply traverse to d d and as we know that we have inserted this word completely so one last thing we do is we simply mark d as the end of the word by making the boolean value is what to be true so for in this tutorial we actually saw the demonstration of how we can insert a word into a tri through all the possible use cases in our next tutorial we'll actually see the code to insert a word into a tri i hope you like this video thanks have a nice day hello friends welcome to my new data structures and algorithms in java tutorial series video friends in this tutorial we will discuss how to insert a word in tri friends in our previous tutorial we actually saw a demo of how to insert a word in tri by seeing the different use cases so friends in this tutorial we'll actually see the working of this algorithm step by step so friends below you can see the code to insert a word into a tri so let's see its demonstration step by step so friends whenever we initialize a tri we know that root points to an empty tri node because in the constructor we simply create a new tri node and we'll simply assign it to root so root will point to an empty tri node now let's say we want to insert a word cat so here string word will point to cat so here we are simply seeing the string word in the form of character array where c is at index 0 a at 1 and t at 2 so we'll see how we can insert cat into this tri character by character also friends in our previous tutorials we discussed that we always start from the root when we are inserting any new word so in the step 1 what we'll do we'll simply create a temporary node current and whatever the node root points will simply assign it to current so it would look something like this that current points to a node which root refers moving ahead friends now we will provide a for loop because we need to iterate each and every character of this word and we have to insert into this tri so we'll start from the 0th index and we'll iterate this for loop till index 2 so the condition we place in the for loop is i should be less than word.length so here word.length will be nothing but 3 so as we are starting from 0 we need to traverse till 2 moving ahead so in the for loop what we'll do we'll first take the character at index 0 so we'll simply call the charAt method of the string and we will take the character at index 0 because currently the value of i is 0 so the charC will point to character c also friends in our previous tutorial we discussed that how we are mapping this index with an actual character and we saw that if we are subtracting a from any particular character we'll get the index value so here the value stored in c is c and when we'll subtract a from it we get the index value so here index becomes 2 so in the tri node array index2 maps to character c so using this current tri node we'll see in the children array which is nothing but the array of tri node and we'll see the value at index 2 we'll check whether value at index 2 is null or not so here you can see currently value at index 2 which maps to c is null therefore the condition in if block comes out to be true which means that c is not present into this tri and now we'll insert c into this tri so the first step we do is we simply create a new tri node and we'll simply assign it to a temporary tri node also friends as we have created this new tri node we have to link the tri node at index 2 which maps to c to this tri node so what we do is we simply assign a value of node to current dot children at index 2 which maps to c so it would look something like this that now there is a link established from root to this tri node from the index 2 which maps to c moving ahead and also friends in our previous tutorial we also discussed that as soon as we insert a tri node we simply traverse to that particular node so here we'll simply assign the value of node to current so now current will point to this tri node moving ahead so after incrementing value of i, i becomes 1 so the character at index 1 is a so value of c becomes a we will evaluate the value of index by subtracting a from the value stored in char c which is nothing but a so when we'll do a minus a we get the value as 0 which makes sense because index 0 will map to a character a moving ahead now as current is pointing to this tri node we will check into its children array that at index 0 whether its value is null or not so currently you can see the value at tri node which is at index 0 points to null therefore condition in block comes out to be true so in order to insert a we'll first create a new tri node and we'll simply assign it to a temporary node and in order to insert this tri node in tri what we'll do we'll simply assign the value of node which is this tri node to current dot children at index 0 so here it would look something like this that now there would be a link from index 0 to this tri node then we'll simply traverse to this tri node by assigning value of node to current so now current will point to this tri node moving ahead now after incrementing value of i by 1 it becomes 2 so now we will insert the value at index 2 which is t into this tri so value of char c will become t then we will evaluate the index of the character t so we'll simply subtract a from t so it will give index value as 19 so in the f block we'll again check that value at index 19 is equal to null or not so here you can see the value at index 19 of this tri node array which maps to t is null therefore condition in f block comes out to be true now in order to insert t we'll first create a new tri node and we'll simply assign it to a temporary node moving ahead and now we'll assign the value of node to this tri node array at index 19 which maps to t so it would look something like this the tri node at index 19 will now point to a newly created tri node and finally we'll simply traverse current to this newly created tri node by assigning the value of node to current so it would look something like this that current will now point to this newly created tri node now after incrementing the value of i by 1 i becomes 3 so the condition in for loop comes out to be false because 3 is not less than 3 so here we simply take an exit from this for loop and also friends in our previous tutorial we discussed that the last step we do is we simply mark the boolean value is word to be true stating that this is the end of the word so we'll simply assign the value true to current.asword so it becomes true moving ahead now friend let's suppose we want to insert a string sun so we'll again call the insert method by passing in word as sun so it would look something like this so as we are inserting a new word we'll start from the root so we'll create a temporary node current which will start from the root and then we'll simply iterate each and every character of this word using this for loop so in the first step we'll insert s so c will have value as s we will evaluate its index position by subtracting a from s so index will become 18 then we'll provide a if block and we'll check that into this tri node array at index 18 what's the value whether it's point to null or not so here you can see currently it is pointing to null so the condition in if block comes out to be true so in order to insert s we'll first create a new tri node and we'll assign it to a temporary tri node and as we are inserting this new tri node into the tri we'll simply assign the value of node to this tri node array at index 18 which maps to s so it would look something like this that the tri node at index 18 which maps to s now points to this newly created tri node moving ahead so after this assignment we'll simply traverse current to this newly created tri node by assigning the value of node to current so it would look something like this so that current will now point to this newly created tri node so after incrementing the value of i by 1 i becomes 1 so now we'll insert o so value of kse will become o we will evaluate its index position by subtracting a from o so it would give index as 14 now as current is pointing to this node so we'll check that value of tri node array at index 14 which maps to o whether it's null or not so currently you can see this value is pointing to null therefore the condition in a block comes out to be true now in order to insert o into this tri first we'll create a new tri node and we'll assign it to a temporary tri node and as you want to insert this new tri node into tri we'll simply assign the value of node to this tri node array at index 14 which maps to o so it would look something like this moving ahead then we'll simply traverse current to this newly created tri node by assigning the value of node to current and now after incrementing i by 1 i becomes 2 so now we'll insert the value n so the value of kse will become n we will evaluate its index by subtracting a from n so it would give index as 13 so in the if block we'll simply check that value of this children array at index 13 which maps to n is null or not so currently you can see this value points to null so the condition in if block comes out to be true so in order to insert n into this tri we'll first create a new tri node and we'll assign it to a temporary node and then we'll simply assign this newly created node to the index 13 of this tri node array which maps to n so it would look something like this and then we'll simply move current to this newly created tri node by assigning the value of node to current so it would look something like this so after incrementing the value of i, i becomes 3 so the condition in for loop comes out to be false and then we'll exit from this for loop so friend as you inserted the word sun completely into this tri the last step we do is we simply assign the value true to current dot is word stating that this is the end of the word so it becomes true now friend let's suppose you want to insert a word cap so here you can see that we have already inserted word cat and cab has a prefix ca which maps to ca of cat so we'll see how we can insert cab into this tri so we'll call the insert method by passing in word as cab so word will have the value as cab we'll start from the root by creating a temporary tri node by name current and we'll assign a value of root to it so it would look something like this and then we'll provide a for loop which will iterate over each and every element of the word so we'll start from c we'll evaluate its index position by subtracting a from c so index become 2 so into this children array and we will see that whether value at index 2 which maps to c is equal to null or not so here you can see the value is not null because it is pointing to a tri node therefore the condition in if block comes out to be false which tells us that c is already there into this tri so the else part will be executed so in the else part we'll simply traverse current to a tri node which this tri node array holds at index 2 which maps to c so it would look something like this moving ahead now after incrementing i by 1 i becomes 1 so now we'll insert a we will evaluate its index position by subtracting a from a which gives index as 0 then in the block we'll check that what's the value of children array at index 0 so here you can see that it is not equal to null and it is pointing to a tri node therefore the condition in if block comes out to be false and the else block will be executed and in the else block whatever the value this tri node array at index 0 is referring will simply traverse current to that tri node so it would look something like this that current will now point to this tri node now after incrementing i by 1 i becomes 2 so now we'll insert b then you will evaluate index position of b by simply subtracting a from b so it would give index as 1 and now we'll provide an if block and we'll check the value of this tri node array at index 1 which maps to b whether it's null or not so here you can see that it is pointing to null so the condition in if block comes out to be true now in order to insert b we'll first create a new tri node and we'll assign its value to node and then as we have to insert this tri node into the tri we'll simply assign the value of node to this tri node array at index 1 which maps to b so it would look something like this and then we'll simply traverse current to this newly created tri node so after incrementing i by 1 i becomes 3 so the condition in for loop comes out to be false because 3 is not less than 3 so this for loop will exit and in the last step we'll simply assign the value of true to current dot is word which states that this is the end of the word moving ahead so for now let's cover the last use case by inserting a value so here you can see we have already inserted a word sun and the new word which we are inserting is so so so is already there into this tri but we need to provide some additional info to this tri so that it can come to know that so is actually a word so we'll simply call insert method again by providing a word as so we will start from the root by creating a temporary tri node by name current we'll provide a for loop which will iterate over each and every value of this word so first we'll insert s we'll first evaluate its index position by subtracting a from s so index become 18 now we'll provide an if block and we'll check the value of this tri node array at index 18 which maps to c so here you can see that value is not equal to null so the condition in if block comes out to be false so the else block will be executed and in the else block whatever the node this children array at index 18 is pointing will simply traverse current to that node so it would look something like this moving ahead after incrementing the value of i by 1 it becomes 1 so now we'll insert o we will evaluate index of o by subtracting a from o so index is 14 now we'll again provide an if block and we'll check the value in this tri node array at index 14 so here you can see the value is not pointing to null it is pointing to a tri node therefore the condition in if block comes out to be false and the else block will be executed so in the else block whatever the value this tri node array at index 14 is pointing will simply traverse current to that tri node so it would look something like this now after incrementing i by 1 i becomes 2 so the condition in for loop comes out to be false because 2 is not less than 2 so the for loop exits and here is the most important part that as current is pointing to this tri node and we have inserted this word completely into this tri we will mark the is what property of this tri node to be true stating that this is the end of the word so assigning the value true to this tri node we are telling tri that the word so is in the tri so at the later point of time whenever we perform a search over in this tri this boolean value will help us return a value true or false that whether a particular word is present into a tri or not which we will be seeing in our upcoming tutorials so friends in this tutorial we actually saw the demonstration of how to insert a word into a tri step by step now let's go to eclipse and see the working of this code hello friends in our previous tutorial we actually discussed how to insert a word in a tri and we saw the demonstration of the algorithm step by step and also in our previous tutorial we created one class by name tri and we implemented tri with the help of tri node class so in this tutorial we will actually code a method which will insert a word into a tri so here i have already created one method as insert which takes in a word and whose return type is void so we need to insert this word into the tri so let's write the code for it so in the first step we simply check that whether word is equal to null or not and also we'll check that word is empty or not because the word is equal to null or empty then we'll simply throw illegal argument exception saying invalid input so friends these are the basic edge cases and also friends in our previous tutorial we discussed that we will be storing the english words into the tri so we have taken the size of this tri node array to be 26 so here we will be dealing with lower case letters so we'll convert the word to lower case and also friends before calling insert method we actually initialize this tri class so root points to an empty tri node so whenever we insert any word we basically start from the root so we'll create a temporary tri node and we'll assign a value of root to it now we'll provide a for loop which will iterate over this word character by character so we'll start this traversing from zero to a value less than word dot length and inside this for loop we'll insert this word character by character so we'll first fetch the character at the value i by calling the caret method of the string after getting the character value we will evaluate its index position by subtracting caret from the value which c holds so this will give us back the index position of this tri node array that where we want to insert this particular character so after getting the index position we'll provide an if block and inside this if block we'll provide a condition that tri node array to a tri node which current points and at its index value which we just evaluated we'll check whether it's equal to null or not so if this value is null therefore we know that this character is not inserted into tri so in order to insert this character into tri we'll first create a new tri node and we will assign its value to a temporary node and after creating this new tri node we will assign its value to the tri node array at the index which we just calculated and after inserting this tri node into a tri will simply traverse current to this newly created tri node by assigning the value of node to current and also friend if the value is not equal to null then we'll simply provide an else block and in this else block we'll simply traverse current to a value this tri node array holds at the index so friends after inserting this word character by character after the for loop we'll simply assign the value of this word to be true stating that this is the end of the word so from this is the code to insert a word into a tri so in order to call this insert method in the main method we'll first create the instance of tri so when we will create the instance of tri into the tri constructor the root will be initialized to an empty tri node and then we'll simply call the insert method by passing in few values say cat cab sun and so so these are the values which we actually discussed in our previous tutorial so at last i will simply print values inserted successfully if i run this code now you see it printed values inserted successfully also friends in our upcoming tutorials when we'll actually perform the search we can actually test the working of this insert method that whether these words are inserted properly or not so friend in this tutorial we actually discussed how to insert a word into a tri hi i hope you like this video thanks have a nice day hello everyone so in this section of course we will be discussing about dynamic programming and we'll see that how we can solve the problems related to dynamic programming so in this lecture we'll simply see that what is dynamic programming with a simple introduction so friends what is dynamic programming so if you visited the website kohra there was a question asked on how you can explain what is dynamic programming in a simple manner and to that question a guy named jonathan paulson gave an amazing reply so what analogy is demonstrated so let's say we write something this on a sheet of paper and we ask that what's that equal to so your answer would be you will simply count each one as one plus one two two plus one three three plus one four four plus one five six seven eight so you simply reply eight now let's say if we write one plus to the left of it and we ask what about that so you will be quickly replying nine so initially you took some time to just add all those numbers but when we simply added plus one to the left of it you straight away replied nine so how would you know it was nine so fast so our basic answer would be that we simply added one more and we didn't need to recount everything again because we remembered this result which is equal to eight and we simply added plus one which became nine so friends here you can see the dynamic programming is just a fancy way to say remembering stuff to save time later so here what we do is let's say we calculated these values and when we added plus one we didn't need to count everything again and we knew that all these values were added to eight and we simply added plus one and we gave the answer as nine and let's say if we do two plus to it then we wouldn't have counted everything again we would have straight away replied eleven because nine plus two gave us eleven so friends here dynamic programming also works the same let's say when we solve any small problem so what we do is we simply store that result and when we encounter that same problem again we simply take that stored result instead of recalculating the values in the problem so friends this is our dynamic programming works let's say we are given a problem to solve so what we do is we simply break that problem into smaller problems we solve those problems and we store the result of those problems so while building up the solution to the last problem if that smaller problem comes again we don't recalculate it we simply use the value which we already computed so what it does is it simply saves our time and the problem takes less time to compute what the exact value is so friends when we discuss dynamic programming in the world of algorithms it is basically a technique in which a complex problem is solved by first breaking it into smaller sub problems second solving those sub problems and simply storing their results and third reuse those store results if sub problem occurs or overlaps again so what it means that we are simply avoiding solving that sub problem again and finally using solutions to smaller sub problems to build up the solution for the complex problem so friends we saw an example in our previous slide that when we counted all the ones we came to know that they are equal to eight so what we did was we simply remembered that all these ones were equal to eight and when we added plus one we straight away came to an answer that now it's equal to nine so here also we break the problem into smaller sub problems and we simply store their results so that when those sub problems comes again we simply use that stored results so that our time is saved and we are not recomputing those values and finally using these steps we build a solution to the complex problem so friends if we use dynamic programming then we can solve a complex problem very fast by simply breaking down into smaller sub problems remembering the result of those sub problems and while building up the solution to complex problem if those sub problems are coming again then we simply use those stored values instead of recalculating those sub problems again and finally coming to a solution for the complex problem so friends this is how we use the dynamic programming as a tool to optimize an algorithm so friends in our next lecture we'll take a problem we will solve it without dynamic programming we'll see the problem associated with it and then we'll introduce dynamic programming and we'll see that how fast it makes the algorithm hope you liked the lecture thanks have a nice day hello everyone so friends in our previous lecture we discussed about what is dynamic programming so in this lecture we will discuss more about dynamic programming and its relationship with recursion we will see how recursion and dynamic programming go hand in hand so here if you see we mostly use dynamic programming to provide an optimization over recursion so here let's say we use recursion to solve any problem so usually it happens that when we solve a recursive problem we tend to make the code inefficient which means using recursion we can solve the problem but what it happens is the problem is solved but it tends to take more time so in our previous lecture we discussed that how dynamic programming usually help us to solve a complex problem by breaking it down into smaller sub problems and then solving those sub problems and while solving those sub problems what we do is we simply store the result of those sub problems and whenever that sub problems comes again into picture we usually extract the stored result and we reuse rather than computing it again and again so similarly when we solve any recursive problem what we do is we simply break it down to smaller sub problems and we solve those sub problems and we store those results so whenever that sub problem comes back into picture we usually use the stored result of that sub problem and we avoid recalculating the solution to that sub problem so by doing that a recursive problem gets optimized so if we see the basic definition of dynamic programming is basically taking recursion plus memorization so here we tend to solve a problem recursively and when we solve the sub problem we usually memorize those solutions and later point of time if that sub problem comes again back into picture we use the memorization solution rather than again calculating those sub problems so friends in order to explain what is the problem with using recursion directly and what's the advantage of bringing in dynamic programming with recursive solutions we'll see an example so we'll take the example of fibonacci series so what is fibonacci series so as per the definition it is a series of numbers in which first two numbers are 0 and 1 after that each coming number is the sum of the two preceding numbers so if we go by this definition then this is the formula which comes out so here first two numbers are 0 and 1 so here you can see the fibonacci of 0 is 0 and fibonacci of 1 is 1 which means that first two numbers are 0 and 1 after that each coming number is sum of the two preceding numbers so let's say i want to calculate the nth fibonacci number so in order to calculate the nth fibonacci number what i can do is i can simply do the sum of the n minus 1th fibonacci number and n minus 2th fibonacci number so which means that we are simply doing the sum of the two preceding numbers and getting the current number so here you can see this is the fibonacci series of first few numbers where the first two numbers are 0 and 1 which is this so let's say we want to calculate what's the fibonacci number 2 so the fibonacci number 2 is the fibonacci number 1 plus the fibonacci number 0 so here you can see the fibonacci number 1 is 1 and fibonacci number 0 is 0 so if we do 0 plus 1 we get the number 1 if you want to calculate fibonacci number 3 we simply take the two preceding numbers which is 1 and 1 so when we do 1 plus 1 we get 2 and similarly 1 plus 2 will give 3 2 plus 3 will give 5 3 plus 5 will give 8 5 plus 8 will give 13 and 8 plus 13 will give 21 so this is how the series goes if you want to calculate any fibonacci number we simply take the preceding two numbers we do the sum of it and we get the number so this is the basic formula to calculate the fibonacci number so friends in our next lecture we'll take this example of fibonacci series and we'll see that how plane recursion in calculating the fibonacci number is less optimized and then we'll see that how we can bring dynamic programming more optimized I hope you like this video thanks have a nice day hello everyone so friends in our previous lecture we discussed that how recursion and dynamic programming go hand in hand and we also discussed that dynamic programming provides an optimization to recursion problems and we also discussed about the fibonacci series and we saw that fibonacci series is nothing but a series where first two numbers are 0 and 1 and after that each number is the sum of two preceding numbers and we saw that we can calculate the fibonacci number using this formula so in this lecture we'll take the example of fibonacci series and we'll see that how recursion is less optimized when solving the problem of the fibonacci number and then we'll see that how we can use dynamic programming to make this recursion problem highly optimized so friends in order to calculate the nth fibonacci number this is the basic algorithm which uses the recursion so here you can see that we are using this formula to calculate the nth fibonacci number so you can see that when value of n is 0 we are simply returning 0 when the value of n is 1 we are returning 1 and in order to calculate the nth fibonacci number we are recursively calling this fib function with the value of n minus 1 and n minus 2 and we are simply doing the sum of it to get the value of nth fibonacci number so here you can see that we are calling this method recursively by passing n minus 1 and whatever is written from it we are storing in a integer variable left and then we are calling recursively the fib function with the value n minus 2 and we are simply storing it in the integer value right and finally we are doing the sum of it because we know that we need to do the sum of the two preceding numbers so which is these two numbers we are doing left plus right and we are simply returning the result so this is the plain recursion without using any dynamic programming so we'll see step by step how this algorithm goes so let's say we want to calculate the fifth fibonacci number so then you can see that the fib function will be called where n will be equal to 5 so we have called fib of 5 then we move ahead n is equal to 5 therefore the condition if block comes out to be false we move ahead n is not equal to 1 therefore the condition if block comes out to be false so we move ahead and here you can see now we are again calling the fib function with the value as n minus 1 which is nothing but 5 minus 1 4 and we are going to call this fib function recursively so it would look something like this that the fib function will be called again with a value of n as 4 like this and then we'll move ahead n is not equal to 0 so we move ahead n is not equal to 1 so we simply move ahead and then we again call the fib function with the value as n minus 1 which is 4 minus 1 so it would look something like this the fib function will be called with a value as 3 like this we move ahead the condition in if block comes out to be false because n is not equal to 0 similarly n is not equal to 1 so we move ahead and here we again call the fib function with a value as 3 minus 1 which is 2 so it would look something like this the fib function will be called with a value as 2 n is not equal to 0 so we simply move ahead n is not equal to 1 so we move ahead now we are again calling the fib function recursively with a value as 2 minus 1 which is 1 so it would look something like this the fib function will be called again with a value as 1 like this so n is not equal to 0 so we simply move ahead but now you can see that n is equal to 1 which is this so we have encountered a base case where we want to return 1 now so here fib of 1 is actually 1 so 1 will be returned from this fib of 1 to fib of 2 so it would look something like this as we have left the fib of 2 at this point we will start executing from this point where now left will get the value as 1 because we have returned 1 and now we will move ahead so here you can see that n is 2 and when we do n minus 2 and call the fib function again so it would look something like this that it will call fib of 0 so it would look something like this now n is equal to 0 so now we will simply return 0 from here so it would look something like this that 0 will be returned to fib of 2 and as we have left fib of 2 here we are again coming back to this point and finally we will return left plus right which is 1 plus 0 which comes out to be 1 so from fib of 2 we will simply return 1 and as we have left fib of 3 at this point we will start executing now from this point here n is 3 we will again call the fib of 3 minus 2 which is 1 so now fib of 1 will be called again it would look something like this n is not equal to 0 n is equal to 1 so we will return 1 from here and as we have left fib of 3 from this line we will start executing from this line and we will simply return left plus right which is 1 plus 1 so from fib of 3 we are simply returning 2 to fib of 4 so we know that we had left fib of 4 at this point so we will start executing from this line and then we will call again this fib function recursively with a value as 4 minus 2 which is 2 so now fib function will be called with a value as 2 so it would look something like this so n is not equal to 0 so we'll simply move ahead n is not equal to 1 so we'll simply move ahead and then from fib of 2 we are again calling the fib function recursively because in order to calculate the fib of 2 we need to do the sum of two preceding numbers which is fib of 1 and fib of 0 so first we are calling the fib of 1 because 2 minus 1 is 1 so it would look something like this the fib will be called with the n as 1 and it would look something like this so we will now again calculate fib of 1 we know that n is not equal to 0 so we'll simply move ahead and here we know that n is equal to 1 because we are calculating fib of 1 the conditional envelope comes out to be true and we are simply returning 1 so 1 will be written to fib of 2 and we had left fib of 2 from the left side so 1 will be stored in left and then we'll simply move ahead and then we'll go to its right by calling fib of n minus 2 so fib of 2 minus 2 is 0 so we'll simply call fib of 0 again so it would look something like this that now we are going to its right so here we know that n is equal to 0 so we'll simply return 0 from its right so we'll go back to fib of 2 and as we are returning it from the right we start our execution from this point where n is equal to 2 now so finally we'll simply return left plus right which is 1 plus 0 so fib of 2 will be returning 1 to fib of 4 from its right so as we are returning it from the right we'll start executing from this point that we had left fib of 4 from the right side so right will be having the value as 1 which we have returned it from fib of 2 and finally we'll return left plus right which is 2 plus 1 from the fib of 4 which is 3 so this 3 will return to fib of 5 which we had left from the left side so we'll start our execution from this point where n is 5 now and now we'll go to its right by again calling fib of n minus 2 which is 5 minus 2 which is 3 so fib of 3 will be called again n is not equal to 0 n is not equal to 1 now we'll go to its left because in order to calculate fib of 3 we need to calculate fib of 2 and fib of 1 so we'll call fib of n minus 1 which is 3 minus 1 2 so it would look something like this n is not equal to 0 n is not equal to 1 and in order to calculate fib of 2 we'll first call fib again recursively by passing 2 minus 1 which is 1 so it would look something like this n is not equal to 0 now here n is equal to 1 so we'll simply return 1 from fib of 1 to fib of 2 like this and as we have left fib of 2 from its left we'll start our execution from this point and we'll simply store 1 to the left because this is what is returned from fib of n minus 1 and now we'll simply go to its right by calling fib of n minus 2 which is 2 minus 2 which is fib of 0 so it would look something like this that fib of 0 will be called again and here n is equal to 0 so we'll simply return 0 so as we are returning it from the right side we'll start our execution from this point because 0 will be stored in right and finally from fib of 2 we simply return left plus right which is 1 plus 0 so 1 will be returned from fib of 2 and as we have left fib of 3 from its left we'll start our execution from this point and 1 will be stored in the left then we'll go to its right again by calling fib of n minus 2 which is 3 minus 2 which is 1 so fib of 1 will be called again n is not equal to 0 n is equal to 1 so we'll simply return 1 so 1 will be returned to fib of 3 and as we are returning it from the right we'll start our execution from this point where 1 will be stored in right and finally from the fib of 3 we'll return left plus right which is 1 plus 1 which is equal to 2 so 2 will be returned from the fib of 3 to fib of 5 and as we have left fib of 5 from its right we'll start our execution from the right where 2 will be stored in right and finally we'll simply return left plus right from the fib of 5 which is 3 plus 2 which equals to 5 so friends the fifth Fibonacci number has a value of 5 which we have returned finally from fib of 5 so friends here you can see that we use plain recursion to calculate the fifth Fibonacci number so this solves our problem but here you can see that it is very less efficient code as you can see that we are calculating fib of 5, fib of 4, fib of 3, fib of 2, fib of 1 and fib of 0 but here you can see the boxes in blue color are recalculated again so for example here you can see that fib of 3 we calculated the value as 2 and here we again calculated the value of fibonacci 3 as 2 so we went inside again this tree which you see here and similarly you can see that fib of 2 we calculated here then we calculated here and then we calculated here and similarly fib of 1 we calculated here here here and here and same as fibonacci 0 we calculated it here here here so here you can see the boxes in green were the actual calculation which you wanted to calculate but as we were using this recursion we need to again recalculate everything here again in the blue boxes so this makes this algorithm very less efficient so what dynamic programming says is when we were computing fibonacci of 3, fibonacci 2, 1, 0 what if we stored those values somewhere and later point of time when we wanted to recalculate fibonacci of 3, 2, 1, 0 we could have used those values directly without going into again recalculating those values so as per the dynamic programming definition a complex problem is solved by making it to smaller sub problems we store those sub problems results somewhere and when we get those problems again like here here here here instead of recalculating those things again and again we can simply use the stored result and we can solve these problems very fast so here you can see that dynamic programming basically provides an optimization to the recursion and as we saw in the definition that it is basically an optimization over recursion plus dynamic programming is nothing but recursion plus memorization so here we use recursion but somewhere we memorize the solutions and we store it somewhere so that when those sub problems comes again into picture we usually use the stored solutions rather than recalculating them again and again so using this technique dynamic programming provides an optimization over recursion so friend in this lecture we saw that how plain recursion can be a problem in solving a complex problem so friends in the upcoming lecture we'll see the demonstration of how we can use dynamic programming to use recursion with memorization and we'll see that how we can solve the problems such as Fibonacci series very fast i hope you like this video thanks have a nice day hello everyone so friends in our previous lecture we saw an example to calculate the nth Fibonacci number and we saw that how we can solve the problem using recursion and we also saw that when we use recursion in calculating the nth Fibonacci number the problem was solved but the solution was very less efficient so friends in this lecture we'll discuss that how we can identify that a particular problem comes under dynamic programming so usually dynamic programming problem has few characteristics so one of the characteristics is optimal substructure so what do we mean by optimal substructure so here you can see that a given problem has optimal substructure property if optimal solution of the given problem can be obtained by using the optimal solution of its sub problems so which means we are given a complex problem and we want to solve that problem and if that problem can be solved by breaking it down into smaller sub problems and using the solution of those sub problems and obtaining the solution to the complex problem gives the problem a property known as optimal substructure so in our previous lecture we saw that how we can calculate the nth Fibonacci number and we also saw that how we can solve the problem of nth Fibonacci number by using the formulas if you want to calculate the nth Fibonacci number you need to find the sum of its preceding Fibonacci numbers which is fib of n minus 1 and fib of n minus 2 so here you can see the complex problem has been broken down into smaller sub problems which again gets broken down into more smaller sub problems which we saw in our last lecture therefore as an example we can say that if you want to calculate the nth Fibonacci number we can calculate by breaking it down into smaller sub problems thus this problem has optimal substructure so in our last lecture we saw that in order to calculate the nth Fibonacci number we can use the recursion and we can solve this problem so while using recursion we saw that if you want to calculate let's say the fifth Fibonacci number so here in order to calculate the fifth Fibonacci number we break this problem into two sub problems by first calculating the fourth Fibonacci number and the third Fibonacci number so we further broke this problem into sub problems and similarly it goes on like this so finally when we reach to a point that a problem cannot be divided further so we usually encounter the base cases which is n is equal to 0 and n is equal to 1 and then using the result of those base cases we solve the sub problems then we use the solution to solve the bigger sub problem and doing this we finally solve our main problem so here you can see that this complex problem has a property of optimal substructure where a complex problem can be solved by breaking it out into smaller sub problems and using its solutions to solve the main problem so this one property optimal substructure helps us to identify that whether a problem can be a dynamic programming problem or not so friends you know next lecture we'll see that there is one more property combined with this property makes a problem a dynamic programming problem so we'll discuss that property in our next lecture i hope you like this video thanks have a nice day hello everyone so friends in our previous lecture we discussed that how to identify a particular problem that whether it is a dynamic programming problem or not we saw the dynamic programming has few characteristics so one of the characteristics which we discussed in our last lecture was optimal substructure so in this lecture we'll see that there is one more characteristic which basically help us to identify that whether a particular problem is a dynamic programming problem or not so here the other characteristic is overlapping sub problems so what is overlapping sub problems so friend let's suppose we are given a problem and we want to identify that whether the given problem has overlapping sub problems property or not so we can simply identify the overlapping sub problems property by first taking the problem and breaking it down into smaller sub problems and solving those sub problems to get the solution of main problems now what this overlapping sub problems means so let's say if our solution of a given problem is obtained by solving the same sub problems multiple times so friends few lectures back we saw that when we solved the nth Fibonacci number problem using recursion there we saw that in order to solve the nth Fibonacci number we first broke it down into smaller sub problems using recursion and when we were building up the solution back by solving the smaller sub problems we saw that those smaller sub problems were encountered multiple times so here the example of calculating the nth Fibonacci number has few sub problems which are overlapping to each other so here you can see that in one of our previous lecture we calculated the nth Fibonacci number using recursion and here you can see that in order to solve the fifth Fibonacci number we broke it down into smaller sub problems something like this by using these properties that nth Fibonacci number is equal to n minus 1th Fibonacci number plus n minus 2th Fibonacci number which is nothing but taking the sum of previous two Fibonacci numbers so friends here you can see that when we solve this problem so in this diagram you can see the boxes which are in blue color are basically the smaller sub problems which have occurred multiple times so for example you can see that when we want to calculate the third Fibonacci number we calculated second Fibonacci number first Fibonacci number and again to get the value of second Fibonacci number we broke it down into smaller sub problems by calculating the Fib of 1 and Fib of 0 if we see the tree of Fib of 3 this much you can see that we have recalculated this tree here again and also if you see the tree of Fib of 2 which is this much portion we have recalculated it here and here and similarly Fib of 1 we have recalculated it here here and here and same goes with Fib of 0 we have calculated it here here here so friends here you can see that when we solve this problem by breaking it down into smaller sub problems we encountered that this problem has multiple overlapping sub problems here the same problem overlapped with this this sub problem overlapped with this and this thus the problem to calculate the nth Fibonacci number has overlapping sub problems and also friends you can see that it also has optimal substructure where we are breaking it down into smaller sub problems and solving those sub problems to get the solution to the main problem so friend a problem is considered to be a dynamic programming problem when it follows the two properties the optimal substructure which we discussed in our last lecture and overlapping sub problems which we are discussing now so friends in our previous lectures we also discussed that this solution is very less optimized because we are recalculating the values of the sub problems multiple times so for example let's say we calculated Fib of 3 which has value 2 now what if i store this value somewhere and let's say when i encountered Fib of 3 again instead of going to this deep tree i can just return 2 so i don't have to calculate this tree again similarly with Fib of 2 if i store the value as 1 i can avoid recalculating this sub tree and this sub tree thus you can see that if i calculate the values in green box once i can store those values and simply i can reuse whenever these values are required again therefore it's a perfect example of demonstrating that nth Fibonacci number is a dynamic programming problem so friends in our next lecture we'll see that how we can store these values somewhere and can reuse them again whenever the same sub problems occurs multiple times so friends i hope you like this video thanks have a nice day hello everyone so friends in our previous lecture we discussed about the two main characteristic of a dynamic programming problem which was optimal substructure property and overlapping sub problems property so friends till now we saw that how we can solve a problem using recursion so in this lecture and in upcoming lecture we'll see that how we can solve a problem using dynamic programming so friends there are two approaches to solve a dynamic programming problem the first approach is bottomup approach so what do we mean by it in bottomup approach we try to solve smaller sub problems first use their solution to build on and arrive at the solution to bigger sub problems so which simply means so let's say if you want to solve a complex problem so instead of solving the complex problem at once what we do is we start with the smaller sub problems we try to solve those sub problems we use those sub problems solution to arrive at a solution to the bigger sub problems and this way we try to solve the bigger sub problems and finally reach to the solution of our main problem so the bottomup approach is also called the tabulation method because in this approach when we solve the smaller sub problems we usually store the result of those smaller sub problems into a table and when those smaller sub problems are encountered again then we simply use the values from the table to arrive the solution to the bigger sub problems and this way solving the chain of sub problems we reach to the solution of the main problem therefore the solution is built in a tabular form by using the solutions of smaller sub problems iteratively and generating solutions to bigger sub problems so friends in a previous lecture we saw that when we used recursion and when we solved the nth Fibonacci number problem we saw that it was less efficient code because we were recalculating the sub problems again and again so instead of recalculating the sub problems again and again what we do is we store the results of those sub problems in a table and when those sub problems are encountered again we simply use the values of those smaller sub problems from the table itself without going to solve those sub problems again and again so friends now let's look at the demonstration of bottomup approach that how we can use the tabulation method to memorize the solutions of the sub problems and reuse them later when those sub problems are encountered again so here you can see that in this example we are simply calculating the nth Fibonacci number and this time instead of using recursion we are using the bottomup approach which is nothing but solving it via one of the methods of dynamic programming so let's say we want to calculate the fifth Fibonacci number so here when we call this function fib the value of n will be 5 so in the first step what we do is we simply create a table which is nothing but an array to store the result of the smaller sub problems so when we want to use the result of those sub problems again we can simply refer this table pick up that value and simply reuse so friends here we will simply create a table of length n plus 1 we will see why we are taking the length as n plus 1 so it would look something like this that there will be an array by name table having six elements from 0 to 5 and we are using n plus 1 because we know that array starts from 0 and if you want to calculate the fifth Fibonacci number the value of fifth Fibonacci number will be stored at the fifth index of the array so therefore we are using n plus 1 moving ahead so friends as we know that fibonacci series starts with 0 and 1 so here you can see we are simply assigning the value as 0 and 1 to the zeroth index and the first index so we are assigning 0 to the zeroth index and then we are assigning 1 to the first index moving ahead so friends here you can see that we want to calculate the fifth fibonacci number which is this but we are starting from the bottom by using these base cases therefore this approach is also called as bottomup approach because we build our solution by traversing from the bottom and we move up and finally we reach to our solution so friends here you can see that we have calculated the value at zeroth index and at the first index so now what we do is we provide a for loop we start from the second index and this for loop will go till the value of i is less than equal to 5 so here you can see i becomes 2 and as i is equal to 2 here we can see that i is less than equal to 5 therefore the condition in for loop comes out to be true and the for loop executes also friends we know that how we can calculate the fibonacci number we simply do the sum of its two preceding numbers so here what we are simply doing we have already stored the result of zeroth index and the first index and when we want to calculate the second fibonacci number we simply do the addition of the first preceding number which is i minus 1 and the second preceding number which is i minus 2 so this is nothing but we are doing the sum of its two preceding numbers because in this table we are actually storing the fibonacci series and when we want to calculate the second fibonacci number we simply do the addition of its two preceding numbers which is 0 and 1 so here you can see the value stored at table i minus 1 which is 2 minus 1 index has value 1 and the value stored at table i minus 2 which is 2 minus 2 has the value 0 so we'll simply add 1 plus 0 and store the value 1 at the second index here so these are the two preceding numbers which we will add and store at this position so now the valued second index becomes 1 moving ahead now we'll increment i so i becomes 3 and now we want to calculate the value at the third index so we'll simply do the sum of its two preceding numbers with i minus 1 and i minus 2 so i minus 1 gives the second index value and i minus 2 gives the first index value we'll do its sum which is 2 and we'll store 2 at the third index so value 2 is nothing but the third fibonacci number moving ahead now when we increment i by 1 i becomes 4 now we want to calculate the value of the fourth fibonacci number which is stored at fourth index and this value can be obtained by doing the sum of its two preceding numbers which is at index 2 and 3 which can be obtained by taking the value of the table i minus 1 plus i minus 2 so i minus 1 gives the value at third index i minus 2 gives the value at 4 minus 2 which is the second index so we'll do its sum 1 plus 2 becomes 3 we store 3 at the fourth index moving ahead now we'll increment i by 1 so i becomes 5 and then we'll simply calculate the fifth fibonacci number by doing the sum of its two preceding numbers which is nothing but i minus 1 which is 5 minus 1 equal to 4 the fourth index and i minus 2 which is 5 minus 2 which is 3 and that is nothing but values stored at third index so we'll do the sum of these two values which is 2 plus 3 equal to 5 and we'll store the 5 at the fifth index and now we'll increment i again so i becomes 6 but here you can see that 6 is not less than equal to 5 therefore the condition in for loop comes out to be false and for loop terminates so friends we simply return the values stored at fifth index which is nothing but our fifth fibonacci number which is 5 so friends here you can see that in our previous lecture we used recursion to solve the nth fibonacci number problem and we saw the solution was very less efficient because we recalculated the values of the sub problems again and again so here what we did we simply created a table to store the results of the sub problems and when we wanted to use the values of the sub problems again we simply referred this table use those solution and build up upon the solution to the main problem so here we started from the bottom which is from the 0th index and the first index and as we knew that a first two number of fibonacci series are 0 and 1 we simply used those two values to come up with the second fibonacci number then we used the first fibonacci number and the second fibonacci number we did it sum we got the value of the third fibonacci number and similarly we got the value of fifth fibonacci number so friends here you can see that using this tabulation method we are storing the results of the sub problems and we are not recalculating the values of those sub problems we are simply referring to this array we are taking out the values and we are simply using to build up upon the solution to the main problem so this is the bottom up approach to solve the problem of calculating the nth fibonacci numbers so friends now let's go to eclipse and see the demonstration of this code i hope you like this video thanks have a nice day hello everyone so friends in this lecture we'll see how we can code a program to find the nth fibonacci number using dynamic programming and in this lecture we will use the bottom up approach so friends in our previous lecture we saw the algorithm of how to find the nth fibonacci number using the bottom up approach we saw its animation and here in eclipse we'll actually code the algorithm and using this main method we'll see it's working so here we'll create one method as public which will return us back the nth fibonacci number so int will give the method fib which will take the value of n for which we want to find the fibonacci number so friends for the positive values of n we need to return the nth fibonacci number from this method and as we are discussing the bottom up approach using dynamic programming we noted this approach is nothing but the tabulation approach where we create the table and store the results of the sub problems and when those sub problems comes again into picture instead of recalculating them we simply reuse the values stored in the table so here we'll create an array we'll give it a name as table and the size of the array would be n plus one because as i erase index from zero and we are using this table to store the individual fibonacci number so in order to get the nth fibonacci number we need to create a table which can store n plus one items so that it will start from zero to n and at the nth index we will have our nth fibonacci number also friends what we discussed in our previous lectures that the first two numbers of the fibonacci series are nothing but zero and one so table at the zeroth index will have value as zero and table at the first index will have value as one and also friends we discussed that in fibonacci series if you want to know the current number you just need to do the sum of its two previous numbers so here we have these first two numbers if we do sum of these two numbers we'll get the second number and similarly using this approach we can come to know that what is the nth number so we are simply storing the fibonacci numbers in this table array so we have used the zeroth index and one index so now we'll start from the second index we are starting from the second index and as here you can see the table as size of n plus one so we'll provide a boolean condition here that if i is less than equal to n just iterate this for loop we'll do i plus plus so friends here you can see the advantage of creating a table array what we can do is simply let's say if we want to calculate the ith fibonacci number we simply do the sum of its two previous numbers and whatever the value is computed from this equation we simply store it into the table as ith index so thus this table helps us in computing the nth fibonacci number from the bottom which is from the zeroth index to the nth index so we have these first two values as index zero and one the second value is computed by adding this value and this value which is i minus one and i minus two and storing it into the second index and similarly the third index will be calculated by adding the value at second index and the first index so this loop keeps on going ahead and ahead taking previous two values doing their sum and storing it into the current ith position and finally when this loop terminates the final value will be stored in the table at the nth index which we also saw in our previous lecture using the animation so we'll simply return that value so here first we'll create the object of fibonacci number class we'll provide a shout to print the nth fibonacci number let's say we want to print the sixth fibonacci number we simply call the method fib we'll pass the value of six and now we'll simply run the program so here you can see the sixth fibonacci number is eight so which is something like this that series starts from zero one and then the rest of the values are calculated by using the sum of its two previous numbers so zero plus one gives one one plus one give two two plus one gives three three plus two gives five and three plus five gives eight so the sixth fibonacci number which comes out is eight so friend this was the demonstration of code to find the nth fibonacci number using dynamic programming with a tabulation method which is nothing but bottomup approach i hope you like this video thanks have a nice day hello everyone so friend in this lecture we will discuss about the topdown approach so in our previous lecture we saw that how we can solve a problem using dynamic programming with a bottomup approach and in this lecture we'll see that how we can solve a problem using topdown approach so what is topdown approach so this method is also called as memoization so what it means is that in this method we break the large problem into multiple sub problems each of the sub problems are solved and solutions are remembered so by remembering the solutions we treat it as a memorization and the term given to it as memoization which means that something we are remembering to reuse it later so how does it work is if the sub problem is solved already we simply reuse the answer so here you can see that we are solving the sub problems and its solutions are remembered so later point of time if that sub problem comes again into picture we simply reuse the remembered answer or else what we do is we simply solve the sub problem and store the result which simply means that we are remembering the solution somewhere thus it memorizes the solution of the sub problem to avoid the recomputing the value of sub problem is encountered again so friends in our previous lecture we also saw that when we are doing recursion we can solve the problems by breaking it down into multiple sub problems and if those sub problems are encountered again then instead of recalculating it again we simply store the solution of that sub problem and when those sub problems are encountered again we simply use those solutions rather than computing them again and again thus it brings the optimization to our recursion so here we'll see a program to find the nth Fibonacci number using top down approach so here you can see this is the algorithm where we need to find the nth Fibonacci number and here we are also passing an integer array which will simply help us in memorizing the solutions of the sub problems and we will frequently check this integer array to see if those sub problems are solved already or not so if those sub problems are not solved we proceed ahead we solve those problems and we store it into this integer array and if the sub problems are solved already we simply reuse the solution so this memo array help us in remembering the solutions so that we can reuse those solutions if the same sub problem is encountered again thus it provides the optimizations to our recursive solutions so friend as this is the recursive solutions we will also see the demonstration using the call stack so let's say we want to calculate the fifth Fibonacci number so we'll simply pass an empty array with the sizes 5 plus 1 which is 6 because we know that the indexes of area are starting from 0 and this memo table will store our Fibonacci numbers from 1 to 5 so the value stored at the fifth index will be our answer so therefore we are creating an array of size 6 so in the first step it would look something like this that we have an array of size 6 having the default value is 0 and on the call stack you will see the fib method has started its execution with the value of an as 5 and with the integer array shown here having all the values as 0 so friends here you can see that as we are using the top down approach we are starting from the fifth index which is the topmost index and then we are going to the bottom in the bottom up approach we started from the zeroth index and we went till the fifth index but here we are starting from fifth index and we are going to the bottom so here we are simply checking if the value at fifth index is 0 or not so here you can see the value of fifth index is 0 which in terms of this problem it is not solved so the condition in if block comes out to be true and we need to calculate this value so first we check whether the n is less than 2 or not so here you can see the value of n is 5 which is not less than 2 so the condition in if block comes out to be false and the else part gets executed so here we also know that in order to calculate the fifth Fibonacci number we need to do the sum of its two previous numbers which is the number stored at third index and the fourth index so in order to do that we simply call the fifth function again passing in the memo array and the value is n1 because we need to calculate this value and this value and then do the sum of these two values to get this value so here you can see that now this fifth function is called recursively and we are leaving this fifth function on the call stack line number 6 so we'll simply add the line number 6 here so the later we can come to know that from which point we need to restart this fifth function so we have left this function and on the call stack there will be one more fifth function with this memo array and the value of n is 4 because we are passing n1 so 51 gives 4 so this function will be executed with n equal to 4 we check that whether value of fourth index is computed or not so we know that is equal to 0 therefore it's not computed so then we go ahead so then we go ahead and compute it 4 is not less than 2 so the condition in block comes out to be false and now in the else block if you want to compute the value at fourth index we need to compute the value at second and third index do their sum and get the value at fourth index so friends here you can see that first we will need to calculate the value at third index so we'll again call the fifth function passing in the array and the value as n1 which is 41 equal to 3 and we also know that we have to leave this fifth function at line number 6 so we'll simply store the line number here and then the fifth function will be called again and on the call stack you can see we have left this fifth function and we have started executing this fifth function with the value of n as 3 we check whether the value of 3 is computed or not so you can see the value of n is equal to 0 therefore it's not computed we check whether n is less than 2 or not so 3 is not less than 2 and here in order to calculate the value of the third Fibonacci number we need to first calculate the values of its two preceding numbers so we again call the fifth function passing it the integer array and the value as 31 which is 2 and we are leaving this function at line number 6 so the fifth function will be called again with the value of n as 2 so on the call stack there will be another fifth function with the value as 2 we will see the value at second index is computed or not so here it is equal to 0 therefore it's not computed we check whether 2 is less than 2 or not so 2 is not less than 2 so we'll start executing the else part and here also in order to calculate the value at second index we need to first calculate the value of its two preceding numbers do their sum and get the value of second index so first we'll go to the n minus 1 part which is 2 minus 1 which is equal to 1 so here now fifth function will be called again so we are leaving this fifth function at line number 6 so we'll store the line number here and then fifth function will be called again with the value of n as 1 so on the call stack it would look something like this we see that value at first index is computed or not so here you can see it is equal to 0 therefore it's not computed and we proceed ahead now we check whether n is less than 2 or not so you can see the n is less than 2 because the value of n is 1 so friends here you can see that why we have provided is if block so we know that the Fibonacci series starts from 0 and 1 so we are simply checking that whether n is less than 2 or not if it is less than 2 we are simply storing the value of n to the memo of n so here value of n is 1 so at the first index we are storing the value as 1 so it would look something like this so 1 is stored at 1th position so after this step finally we return the value stored at first index so friends here you can see that why we are returning this value 1 here because we called this fib function from this fib function and we left at line number 6 so at line number 6 we had to calculate the value of 1 and then we have to calculate the value of n2 and then do the sum of these two values to get the value at second index so therefore we have calculated the fib of n1 which is 1 so we are simply returning the value 1 from this fib function to this fib function so it would look something like this this fib function will be removed from the call stack and the call will go to this fib function and we also know that we had left at line number 6 so we'll start executing from the line number 6 and whatever we return from this method will be stored in the left which is nothing but 1 so moving ahead now here you can see that when we are executing this fib function the value of n is 2 we have computed one of its previous value which is n1 and now we have to find the value n2 so that we can do the sum of these two values and get the value at the second index so therefore now we'll again call the fib function to calculate the n2th value so here you can see that now we are again calling fib function and we are leaving this fib function at line number 7 so we'll simply update the line number 7 so that we can come to know the letter that at which line we left this function so we updated the line number and now this fib function will be called with the value as n2 which is 22 which is equal to 0 so it is called for fib of 0 and here we check if the value at 0th index is computed or not so it is equal to 0 therefore it's not computed we check whether n is less than 2 or not so 0 is less than 2 therefore condition if block comes out to be true and finally we'll store the value of n which is 0 to this memo table at index 0 so here at index 0 we'll simply storing the value as 0 because we know that the fibonacci series starts from 0 and 1 so if the value of n is less than 2 we simply store that value into its index so now we'll simply return this value because we need to get this value here so this fib function will be removed from the call stack and 0 will be returned from here and we know that we had left at line number 7 so we'll start executing from the line number 7 and this fib function has returned a value 0 so we'll store that value in the right so 0 will be stored at the right so for now you can see that in order to calculate the second fibonacci number we need to do the sum of its two previous numbers so we have got the sum of its two previous number as 1 and 0 we'll do the sum of it and we'll store at the second index so 1 plus 0 is 1 so we'll simply store the value 1 here and then from this fib function we'll simply return the value stored at second index because value of n is 2 which is nothing but 1 so 1 will be returned from this method and this method will be removed from the call stack and now we'll start executing this fib function and we know that we had left at line number 6 so we'll start executing from the line number 6 and we also know that we had returned the value 1 from this fib function so 1 will be stored in the left integer variable moving ahead now we have calculated the n minus 1th value which is this and we need to calculate the n minus 2th value which is this in order to get the third fibonacci number because value of n is 3 so we have computed one value we need to compute the other value so here the fib function will be called again with the value as n minus 2 which is 3 minus 2 which is 1 and we know that we are leaving this fib function in line number 7 so we'll simply update the line number 7 here so the fib function will be called again with the value of n as 1 here now we have to calculate the value of the first fibonacci number so now you can see the advantage of using this memo table we are checking that whether value at first index has been calculated or not so this sub problem has been encountered again because we have already calculated the value at first index which is 1 so by providing this simple check that whether the memo of n is equal to 0 or not so we have already calculated this value so we don't have to recalculate it again here or here so therefore storing this result of the sub problems gives us an optimization over the recursion here so instead of calculating it again here we are simply returning the value stored at the first index so we are simply returning memo of 1 which is 1 so this fib function will return the value as 1 and we know that we had left and line number 7 so we'll start executing from this line and as the return value is 1 the value stored in right would be 1 and finally we can come to know the third fibonacci number by simply doing the sum of its two preceding values which is 1 and 1 and we'll simply store that value at the third index so 1 plus 1 is 2 so we'll simply store the value 2 at the third index we move ahead and we'll simply return the value 2 from this fib function so this method will be removed from the call stack and it will go to its previous fib function which we had left at line number 6 so we'll start executing from the line number 6 and we know that we had returned the value of 2 from this fib function so it will store in the left and now we'll simply calculate the fib of n minus 2 to get the value of the right part so on the call stack we are leaving this fib function at line number 7 so we'll update the line number 7 this fib function will be called again and on the call stack we will call fib with the value as 4 minus 4 minus 2 which is 2 moving ahead we'll simply check in this table that whether this sub problem which is fib of 2 has been solved or not so we are simply checking this memo table and we are simply checking at the second index whether the value is 0 or not so here you can see we have already solved this problem and stored its result therefore we don't have to recalculate it again so we are simply returning the value stored at the second index which is 1 and we are returning the value 1 from this fib function to this fib function and as we know that we had left this fib function in line number 7 we'll start executing from the line number 7 and then we'll simply store the value return from this function which is 1 into the right variable finally we do sum of these two numbers and we'll store it in the fourth index because in order to calculate the fourth fibonacci number we need to do the sum of its two preceding numbers which is at index 2 and 3 stored in left and right so 2 plus 1 gives 3 so we'll simply store 3 at the fourth index and finally we'll return the value 3 from this fib function to this fib function and we also know that we had left this fib function line number 6 so we'll start executing from the line number 6 we return the value 3 from this fib function we'll simply store it into the left integer variable 3 and now in order to calculate the fifth fibonacci number which is our actual main problem we had calculated one of its preceding value which is n minus 1 here we just need to calculate n minus 2 value this value and then we can do the sum of its two values and get the solution to our main problem so here we'll again call fib function passing in a value n minus 2 which is 5 minus 2 equal to 3 and we are leaving this fib function at line number 7 now so we'll update the line number 7 so this fib function we'll call with the n as 3 and friends here you can see the advantage of this memo table that we have already calculated the third fibonacci number because value stored at third index is not equal to zero therefore we don't have to recalculate it again and again using this code so finally we'll return the value stored at the third index which is 2 and we'll simply return from this method and go to its previous method and we know that we had left at line number 7 so we'll start executing from the line number 7 and as 2 is returned from this fifth call we'll simply store it into the right integer variable and then as we want to calculate the fifth fibonacci number we got the fourth fibonacci number and the third fibonacci number stored in left and right we'll do its sum and we'll store at the fifth index so 3 plus 2 gives us 5 so 5 is stored at the fifth index and finally from this fib function we'll return the value stored at the fifth index which is our actual answer the fifth fibonacci number has the value of 5 so we are simply returning the value 5 and this method will be removed from the call stack and hence our problem is solved so friends here you can see that we started from the top we moved to the bottom therefore it's top down approach and we also know that we have used this memo array which helps us in memorizing the solutions of the sub problems so that those sub problems when encountered again are not recalculated again so we are simply storing those sub problems result here and when those sub problems are encountered again we don't have to compute it again we simply take that value from this memo table and reuse it again therefore using this memo table to our normal recursion we are providing an optimization and we also know that dynamic programming is nothing but the optimization to our recursive problems so friend in this lecture we saw the top down approach of dynamic programming that how we can use that approach and solve a complex recursive problems efficiently now let's go to eclipse and see the demonstration of this algorithm i hope you like this video thanks have a nice day hello everyone so friends in our previous lecture we saw the animation for the top down approach that how we can solve the problem related to finding the fibonacci number using dynamic programming by top down approach so in this lecture we'll code the algorithm to find the nth fibonacci number using top down approach so here in eclipse you can see that few lectures back we saw the bottom up approach and this approach is also a method in dynamic programming so in this lecture we'll see the top down approach so first we'll create a method which will return us back the nth fibonacci number which is an integer and let's say the name of the method is fib now as we discussed in our last lecture that to this fib function we pass in a memo array which help us in storing the solutions to the sub problems and when the sub problems are encountered again instead of recalculating it we just go to this integer array into that particular index we pick up that value and reuse it thus this integer array helps us in optimizing the recursion solutions so this method also takes the value of n for which we want to find the fibonacci number so friends in order to find the nth fibonacci number what we simply do is we simply first check whether the mem of n is equal to zero or not so what it means that we are using this array to store the fibonacci series and as you want to calculate the nth fibonacci number we simply check that this array at index n is equal to zero or not so if it is equal to zero we come to know that the nth fibonacci number has to be calculated so inside is if condition we provide a if block where the condition is if n is less than two then what we do is we simply assign the value of n to the integer array at the index n so why we do this because we know that the first two numbers of fibonacci series are zero and one and as the array starts from zeroth index so this value will be stored at zeroth index and this will be stored at the first index so we simply check whether n is less than two or not so if value of n is zero then zero is stored at zeroth index and if the value of n is one then one is stored at the first index and if n is not less than two then in the else part what we do is so here we know that the fibonacci series has property the current number is sum of its preceding two numbers so based on these two properties what we come to know that if we want to calculate the nth fibonacci number we need to know its two preceding numbers which is n minus one and n minus two we do its sum and we get the current number so here let's say current number which you want to calculate is nth number so what we do is we first calculate the fib of n minus one so we call this fib function recursively which we also discussed in our previous lecture so whatever the value it returns we store in the left and then we again call the fib passing in the memo array and pass in n minus two because if you want to calculate the nth fibonacci number we need to know the n minus 1th fibonacci number and n minus 2th fibonacci number and once we know these two values we can do their sum which is left plus right and as we know left plus right we simply store this value at the nth index because we know that this integer array basically stores the fibonacci numbers and as we want to calculate the nth fibonacci number we simply store the left plus right at the index n and finally we return the answer which is the value stored at the nth index so friends here you can see that this line is very much important because because this line checks that whether the sub problem is solved again or not so here what we do is if the mem of n is equal to zero we come to know that the value of nth index has not been solved so what we do is we go into a block and we calculate the value of nth index and we simply store it here and what if the mem of n is not equal to zero then we know that we have already solved this problem so then we simply return the value stored at the nth index also friends in our previous lecture we saw the animation that how this line helps us in optimizing the recursion so that we don't have to solve the sub problems again and again and as we start from the value of n and then we slowly go to the bottom by doing n minus 1 n minus 2 and then again recursively moving down therefore this approach is also known as top down approach because we start from the top and then go to the bottom and as we go to the bottom we encounter these base cases where the first two values we store as 0 and 1 and after getting these two values we build up upon the solution and finally we get the nth Fibonacci number so friend now let's see the demonstration of this code in the main method so first we initialize the Fibonacci number class and let's say we want to find the 6 Fibonacci number so here the value of n would be 6 and as we are calling this fifth function we need to pass an empty array whose size would be n plus 1 which is 7 because we want to store the Fibonacci numbers from 0 to 6 and finally we need to return the value of index 6 so as we are going from 0 to 6 we need to initialize the array of size 7 so we simply pass an empty array of size 6 plus 1 and if i run this code now so we get the answer as 8 because here you can see that in the array it will be stored in this format 0 1 would be the starting values then we do the sum of these two values we get this value then we do sum of 1 plus 1 we get 2 then 2 plus 1 we get 3 3 plus 2 we get 5 5 plus 3 we get 8 so friend this is how we can use dynamic programming to solve this problem to find the nth Fibonacci number and using this topdown approach we have solved this problem very efficiently and whatever the solution we get is highly optimized so friends i hope you like this video and in case you have any problem you can watch my previous lecture where we go through this code step by step using the animation and in our next lecture we see different problems associated with the dynamic programming thanks have a nice day hello everyone so in this video we will be looking into a problem maximum sum sub array and we will be looking into a specific algorithm which was provided by cadence to solve this problem so before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here in this problem we are given with an array with some random elements and it can have negative elements as well we name it usually maximum sub array sum so here in this problem what we actually do is we try to find any sub array such that if we do the sum of the elements of that sub array and whichever is the maximum sum we simply find that out so for example let's say if i take these two elements so a sub array is actually a smaller piece of array of the bigger array and the elements are contiguous so if we do sum of these two elements we will get seven so this is one such sub array one property of sub array is that it should be contiguous so for example two we can't take two four five do their sum and find the maximum sum because three is missing so a sub array is actually a smaller array which is contiguous so here we saw that one of the sub array has sum to be seven now there can be multiple sub arrays so we need to find the maximum sum of any particular sub array and we simply want to return that sum so here you can see if we take this sub array four three minus two and six we will get four plus three minus two plus six so it will give us eleven so this is one such sum so we try to find that whether this array has any other sub array whose sum is maximum or not so here if you see if we take these three elements seven plus minus one plus six so it will give us twelve so it means we can discard this sum and this would be our answer so twelve is the maximum sum of any sub array so in order to find such sum the brute force way would be that we try to create each and every sub array we do their sum and we see which is the maximum sum so usually this approach is not good so there is one such algorithm which was provided by cadence which actually traverse this array once and figures out what is the maximum sum sub array so here how we actually solve this problem is we usually create two variables current max and the best sum or maximum so far now what this two variables denote we'll see later and this algorithm we try to traverse from left to right so at the start we encounter four now what we do here is let's say if our array had only one element four so the maximum sum would have been four only and we would have returned from this array saying that four is the max sum so here you can see we will be traversing this array one element at a time and let's say at this index for example we will be storing two things current max and the max so far so what these two variables denote is that at index three what is the current max sum and as we have traversed this array we would have encountered many sub arrays so among those sub arrays which what's the max so far or what's the best sum so these two things we keep track while traversing from left to right also when we traverse the elements one by one at each element the element usually asks two questions that should I become part of the current sub array which will give us the maximum sum or should I start my new sub array so here we look into the demonstration and what these two questions actually mean so here if you see at the start we encounter four at index zero so four will ask that should I become part of the current sub array so here if you see current sub array is empty because there are no element as this is the first element only should I become part of the current sub array so that sum is maximum so at the start both these questions as there is only single element both this question correspond to the same thing if four becomes part of the current sub array it would be something like this or if four starts a new sub array it would be something like this so usually at the start the current max is four and it has been formed by this sub array and we simply take four as the max so far being formed by this sub array now we'll go to the first index so at this index three will decide should I become part of the current sub array so here if you see current sub array is four so if it becomes part of the current sub array so sub array will become four three and sum will become seven or it will decide it should I start a new sub array so if it decides new sub array sum will become three so among these two questions three will see that it's better to become the part of the current sub array because we are getting a maximum sum among these two sums so three will become part of the current sub array so the sub array will go something like this these two elements are there and the current max at this point would be seven which is being formed by four and three so here you can see now this max so far this seven is greater than four so this max so far will be updated to seven stating that it has been formed from the elements four and three moving ahead now we encounter minus two I'll just remove this so minus two will think should I become part of the current sub array so if it becomes part of the current sub array the sum would be seven because seven is the sum of the current sub array plus minus two which will give it a value as five or it will decide should I start a new sub array so if it starts a new sub array the sum will become minus two because we will be discarding this sub array if we are starting a new sub array from here so minus two sees that okay if I become part of the current sub array the sum will be five and if I start my own we get minus two so it's better to go with the current sub array and get the sum of five so here at this position the sum will become five it has been formed by four three and minus two and this five is actually smaller than seven so max so far will remain this only it means that though we have taken up minus two into this sub array but the sum is not actually greater than the maximum sum so far or the best sum so the best sum will actually remain this so let's say if we had only this three elements in the array so the current max would have been five and our answer would have been seven stating that we usually take four and three and we will get the max sum we will discard minus two from the best sum and also here one question arises why we are taking minus two into the consideration here why we are actually adding minus two because because there could be a possibility let's say the current number here is six so there could be possibility here number is thousand if we don't take minus two then our current sub array will start from this because the sub array is contiguous and if you are not taking any element it means we are discarding the previous sub array so the sum would have become a thousand if we have not included minus two and now if we include minus two so here we can see the sum came out to be five and let's suppose here would have been thousand so we would have included thousand also and got one zero zero five so which is much way better than thousand therefore we simply include minus two based on these two questions because we are not sure what comes after this minus two it could be any negative value or it could have been any maximum value so it's better to include minus two into this sub array so now our sub array reaches like this that it has included everything four three and minus two i will remove this so now we encounter six so here six will decide that okay should i become part of the current sub array so if it becomes part of the current sub array so the sum will become five because the sum is five plus six which will give us eleven or it decided should i start a new sub array so if it discards this previous sub array and starts a new sub array from here so the sum will be six only so the element six will decide okay i will go with the current sub array because this gives the maximum sum so here the current max will become 11 which will be the addition of these four elements of the sub array so now here you can see that this 11 actually beats seven so max so far will take the maximum sum as 11 because it will figure out that okay now i need to include four three minus two and six together because this is giving me a maximum sum moving ahead we will remove this so now six has become part of our sub array now we encounter minus 12 so minus 12 will decide should i become part of current sub array so the current sub array is this so 11 plus minus 12 will give us minus one or it decides should i start my new sub array so if it starts its new sub array the sum would be minus 12 so minus 12 sees that okay minus one is greater than minus 12 so it's better i should become part of the current sub array so here now our current max become minus one being formed like this but this minus one is very much less than 11 so max so far will remain the same but let's suppose if our array would have ended here so the answer would have been 11 which has been formed from the elements four three minus two and six so this is the significance of max so far it keeps the track of the maximum sum of any sub array so far so i'll just simply remove this and here minus 12 comes with the current sub array now we encounter seven so seven will ask should i become part of the current sub array so it sees the current sub array is this and its sum is minus one so minus one plus seven will give us six or it decides should i start my own new sub array so if it started its own new sub array it has to discard this sub array and if it starts a new sub array from here like this so the sum will be seven so this element thinks that okay i should not go with the current sub array because it is giving a sum only six but if i start my own it will be a maximum sum of seven so here is the critical step where the current element decides that okay i won't go with the current sub array i will start my own sub array which is a new sub array so here we simply discard this sub array because current max will now be seven and it will be formed by only digit seven but this seven is less than 11 so the max so far will remain the same so now this sub array is actually discarded and a new sub array will start from seven so now we encounter minus one so minus one decides that okay should i become part of the current sub array so seven plus minus one will give six or should i start my own sub array so the sum will be minus one if it starts its own sub array so it decides that okay i will be part of the current sub array because it is giving me a maximum sum so here now our current max will become six because minus one has decided to go with the current sub array seven comma minus one okay but this six is less than eleven so our max so far will still remain the same moving ahead so now our sub array has two elements seven and minus one so now the last element comes which is six so six asks should i become part of current sub array so six plus this six will give sum is 12 or should i start a new sub array so if it starts a new sub array the sum will be six so this six decides is okay i will go with the current sub array because it is giving me a maximum sum if i compare these two values so here now current sum will become 12 7 minus 1 6 so this will be included like this and now you can see 12 is actually greater than the max sum so far so max so far will see that okay i need to now discard this because we have found one more sub array whose sum is actually maximum from the current max so far which is 12 formed by seven minus one and six and here there are no more elements left so the answer would be our max so far which is 12 so this will get written so friend in this video we saw that how we can solve the maximum sum sub array problem using Carden's algorithm in our next video we will actually see the demonstration of the algorithm step by step that how we can use the code and come up with this logic we will see it via an animation in our upcoming video i hope you must have liked this video and in case if you are new to my channel then please subscribe to my channel thanks have a nice day hello everyone so in our previous video we discussed about the idea behind how the Carden's algorithm work in finding the maximum sum sub array so in our previous video we actually discussed the idea behind the algorithm we saw that how current max and max so far are the best sum help us in determining the maximum sum sub array in this given array and we also saw that we traverse the array and on each element the element decides that should it be part of the current sub array or should it start a new sub array so now let's see the demonstration of this algorithm step by step so here you can see that we have been provided with an algorithm which is the Carden's algorithm so usually the method name is max sub array sum it takes an integer array and finds us a maximum sum for any sub array in this array so let's see the demonstration of this algorithm step by step so before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so at the start let's say we provide an array as what we discussed in our previous example so usually at the start the first element is simply taken as max so far and the current max so max so far is four this value and current max also becomes four now the algorithm basically starts with second element so here i starts from one and goes till array dot length so here array dot length is eight so i will travel from one to seven because seven is less than eight now on this point three has two choices either it should become a part of the current sub array so the current sub array is this or it should start its new sub array so as we discussed in our previous slide what we do is we take current max and we add the value stored at the index of i and we assign it to the current max so here we are simply taking the current element value and we are adding it with the current max and assigning it to the current max so it means three decided to go with the four it means four plus three will give us seven so seven is assigned to the current max so current max becomes seven now why we directly assigned it because in the next step this current max is actually compared with the with the elements value so this is our second question that should i start my new sub array here this part was where element decides to go with the current sub array and in this if block there is our second question that should i start my new sub array so if current max is less than the value of the current element then we simply assign this value to the current max so here seven is compared with three because array of i is three so whichever is the bigger value is simply assigned to the current max so seven is the bigger value among these two values so current max remains the same so from here you can see that when element decides to be a part of current sub array we simply add it to the current max and here we are simply assigning it to the current max because in the next step we will reassign it if current max is less than the current elements value which means that three has decided to create its own sub array so this is actually our question one and this is actually question two so whichever wins that value is assigned to the current max and if this condition comes out to be false then we do nothing with the current because we have already assigned current max plus array of i to current max which is four plus three equal to seven to current max so now this value is included in the sub array so the current max is seven being formed from the sub array four comma three which is these two elements and now we'll simply compare this sum current max sum with the maximum sum so far so if max so far is less than current max we simply assign the current max value to the max so far because current max actually beats the maximum sum so far so here max so far is four and current max is seven so this condition comes out to be true and max so far becomes seven so here this is current max and this is max so far so at the start it was four then it became seven taking in four comma three moving ahead now we'll increment i by one so i points to the second index now this minus two has two questions that should i become part of the current sub array so we simply take their sum current max plus array of i it means we are including array of i so here it will become seven which is the current max plus minus two so seven which will give us five so current max will become five and then this element simply asked that okay can i start my own sub array so this check actually decides that that if current max which is five so if it is less than array of i value which is minus two so array of i value is simply assigned to current max so currently so this condition comes out to be false because five is greater than minus two then we simply check whether max so far is less than current max or not so why we are doing this check is we are simply keeping the track of the maximum sum so far so if at any step current max becomes greater than max so far it means we have found the maximum sum so far so we simply assign current max to max so far so as of now max over is seven and current max is five therefore this condition comes out to be four because seven is not less than five so here the current max will become five taking in four three and minus two so here the current max will be five and max so far will remain same so now we'll increment i and here you can see this element has been included in the current max sub array so friends here you can see as we know that each element asks two questions whether it should become part of the current sub array by simply adding its value to the current max or they decide to create their own sub array so this piece of code decides that so you can also think this piece of code is something like current max equals we can also write something as math dot max and the two values would be current max plus array of i or array of i so whichever is the maximum value we simply assign to the current max so this is question one and this is question two that should have become part of the current sub array if that is maximum that value is assigned to the current max or if element decides to create its own sub array so it's simply its value is assigned to the current max so either we can do this or we can do this that first we directly assign current max plus array of i value to current max and then with this if block we reassign the array of i value to current max if the value at i th index is actually greater than the current max so it means this value is greater than current max plus array of i so this value will be assigned or else we have already assigned this value to current max here so now value at i th index is six so we simply assign 5 plus 6 which is 11 to current max so current max becomes 11 and then we simply decide that whether current max which is 11 is less than the value 6 or not so if it is less than 6 then we simply reassign current max to the array value at i th index so this condition comes out to be false because 11 is greater than 6 so here 11 is our current max we have taken these four values now we'll simply compare that whether the maximum sum so far is less than current max or not so here you can see 7 is less than 11 it means we found a new max so far so we simply update current max to max so far so it becomes 11 4 3 minus 2 and 6 so it means we have found a sub array of maximum as 11 having these four elements so now we'll continue with the rest of the elements we'll increment i so i will now point to the fourth index so here array of i is minus 12 so here we are simply adding current max which is 11 it will give us minus 1 so current max will become minus 1 and then this element will decide that can i start my own sub array so it will compare its value which is this part with the current max which is minus 1 so minus 1 is greater than minus 12 so this condition comes out to be false and the current max which is minus 1 is actually less than max so far so this condition also will come out to be false so max so far will remain 11 which makes sense because a sub array whose maximum sum is 11 is being found from these four elements so here we simply write 11 only 4 3 minus 2 and 6 moving ahead so here minus 12 has been included in the current sub array i will now point to index 5 so current max will become minus 1 plus 7 which is 6 so this is the part when array of i decides to go with the current max and then it checks okay can i start my own sub array because my own value is 7 but if i go with the current sub array the current max is 6 so therefore it decides that it's better i create my own sub array because if i create my own sub array i will give a sum of 7 and if i go with the current sub array the sum will be 6 so therefore this condition decides that the current max is 6 and it is actually less than 7 so the current max will become 7 by simply assigning array of i to current max which signifies that 7 is decided to go and create its own new sub array so current max becomes 7 so now this sub array will be removed and from here a new sub array will start and here we'll simply denote 7 by taking in only 7 and this current max doesn't beats the max so far so this condition comes out to be false now we'll go to the next element which is minus 1 so here minus 1 will be added to the current max it will give 6 so current max will become 6 now and now this minus 1 will see that if i become part of the current sub array which is this i am getting sum as 6 if i start my own sub array i will get sum as minus 1 because this is the only element so it sees that okay it's better to go with the current sub array so this condition comes out to be false because current max which is 6 is actually greater than minus 1 so here now our current max is 6 taking in 7 and minus 1 together now this 6 doesn't beats the 11 so it remains the same now we'll increment i so now i will point to the 7th index and here this current sub array has included minus 1 with it now we'll simply add the value 6 which is this value with the current max so 6 plus 6 is 12 so current max will become 12 and this 6 also checks that if i start a new sub array from here what's the sum so this is the only element so sum is 6 so it doesn't beats the actual current max so this 6 decides to go with the current sub array by adding itself to the current max so this condition comes out to be false because current max is 12 and it is greater than 6 so now this element is included in the current sub array so the current max is 12 taking in 7 minus 1 and 6 and here you can see that this current max 12 actually beats the max so far so this condition comes out to be true because max over is less than current max so it means we simply update the max so far which is 12 so this value is assigned to the max so far stating that this sum was made from this sub array it becomes 12 we'll increment i so this for loop will exit because the value of i is 8 and 8 is not less than array.length it is equal to array.length so it means we have traversed this array completely and at the last we will simply return 12 because this is the maximum sum so far created by a sub array this is 7 minus 1 and 6 so this 12 is returned so from here we saw that there was one sub array 4 3 minus 2 and 6 which actually gave the sum as 11 so this sub array was max so far for most of the time and at the end this sub array whose total sum came out to be 12 became the max so far so 7 minus 1 and 6 which gave the sum as 12 was the maximum sub array sum which we finally returned from this method so friend this is how the curtains algorithm work so here one more question arises that why we are actually taking in the negative values in the current max like we did here we included minus 2 and the current max became 5 from 7 because here you can see that current max value is 5 after including minus 2 if this value would have been let's say 1000 so in the next iteration if we have included 1000 we would have got 1005 because we will be adding 5 to 1000 but if we would have discarded this value so from this part a new sub array would have been started which only would have given 1000 so we are not sure what next element is coming up so therefore we have included minus 2 because this value is less than this value so therefore we have included minus 2 also because we are not sure what is coming up there could be a very large maximum value which would have raised this sum to 1005 and if we would have discarded minus 2 so this sub array would have been ended here and a new sub array would have started here which only could have given a sum as 1000 I hope you must have liked this video and in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw that how cadence algorithm help us in finding the maximum sum of a sub array in a given array we saw the demonstration of the algorithm step by step now in this video we will actually code the algorithm and will test its working in the main method so if you want to understand the algorithm more you watch the previous videos to this where the algorithm is being explained in a very detailed manner so let's see the code of the cadence algorithm so before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here we will be creating one method as public static we'll give it a name as max sub array sum so this method will take in an array and will return the maximum sum of any sub array so its return type is integer so here code wise this algorithm is simple but to actually understand the concept behind it is very much complex and you can watch my previous videos to it to understand more so in this algorithm we simply create two variables one is current max and we simply assign the first value to it which is the value stored at 0th index and the other variable is max so far we also assign it a value of what the first element is holding so here we are assuming that array is at least one element so the algorithm basically starts from second element from i equal to 1 and i goes from 1 to array dot length so in our previous video we discussed that when we are encountering the current element this current element basically ask two questions that should i be part of the current sub array which is the current max or should i start my own sub array so these two questions basically decides what will be the value of current max so at the start we simply assign array of i to current max so this is the question one where the element becomes part of current sub array so here we have taken the sum of current max and the value of the array at i th index so this satisfied question one and we simply assign it to current max so in the next step we can't directly go with the current max value with this sum this element will also ask the question that can i start my own sub array by taking my own value so here we simply compare current max with array of i so if array of i is greater than this current max so it means that this element has started its own sub array because this value has been assigned to current max so here this is the question two where element decides to start its own sub array so after evaluating the current max what we do is we compare it with max so far so if this current max beats our max so far so we simply assign current max to max so far so friends you can watch my previous video to understand more about this logic that usually at each iteration we ask these two questions and based on these two questions current max value is decided and if this current max value is greater than max so far so we simply assign current max to max so far and at the end we simply return max so far because after this value will terminate whatever the value max so far is holding it decides the maximum sum of any sub array in this array so now let's test its working in the main method so this is the array which we discussed in our previous video as well in the slide here we'll simply call max sub array sum method we pass in the array and if i run the main method so here you can see it return the maximum sum as 12 so which is being formed by this sub array 7 minus 1 and 6 if we add all of these three values we'll get sum as 12 so friend this was all about the cadence algorithm i hope you must have liked this video in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello friends welcome to my new data structures and algorithm in java tutorial series video friends in this tutorial we will discuss the famous twosome problem in java so here the problem is something like we are given an array of integers and we need to return the indices of the two numbers such that they add up to a specific target so if we take an example then let's say we have this array of integers 2 11 5 10 7 8 and let's say we are given a target as 9 so we need to return the indices of two numbers such that they add up to this target so here the problem states that we need to find two such numbers into this complete array which will add up to the target so if we take the above example then the solution would be the element at 0th position is 2 and the element at 4th position which is 7 so they add up to the target so we need to return the indices of it so we need to return 0 and 4 so 0 is the index position for the number 2 and 4 is the index position for the number 7 so let's move ahead and see the demo of the algorithm so friends let's say we are given the array of integers and we are denoting it with the variable name as numbers so here the array elements are 2 11 5 10 7 8 which we saw in the previous slide and below are the index position of it and if you see the below is the algorithm for finding two such numbers which add to make a specific target now let's say we are given a target as 9 and we want to find two such numbers which add to make the number as 9 so we know that 2 and 7 make up to 9 so in order to find those two numbers that below is the algorithm for it so let's quickly see the demo of it so as we need to return the indices of it we will store it in the integer array of having two elements so we need to return the indices of two such numbers so we'll store it into the result array so it would be something like this so first we'll create a hash map we'll see what the significance of this hash map is so here we are encountering a for loop which traverses the complete array so in the first iteration i value is 0 and numbers dot length is 6 because we have the six integers as 2 11 5 10 7 8 so we'll traverse this array from 0th index to 5th index and currently for the first iteration i points to 0 so i would be pointing to the 0th index of the numbers array so friends the basic idea behind this algorithm is like we will traverse each element one by one and we'll store the element into hash map with its index value so that on traversing this complete array we'll take a particular number we'll subtract it from this target and we'll find that whether this contains in the map or not so instead of adding these two numbers and making it to a target we'll just subtract that particular number from the target and we'll look up into this hash map and we'll see whether that particular number is there or not so let's see how it works so here if you see we have this target is 9 and we have this number at ith position which is number at ith position is 2 so what we'll do we'll just check whether the our map contains 9 minus 2 which is 7 into this hash map or not so currently the map dot contains key will comes comes out to be false because the hash map is empty and if you do a reverse of it then this condition in if statement comes out to be true therefore what we'll do we'll just put the number at ith position along with its index so moving ahead now i becomes 1 and if you see the i points to the index at first position and also 1 is less than 6 therefore this for loop will be executed so now we'll again check whether target which is 9 and we'll subtract the number at ith position so if we subtract 11 from 9 we'll get minus 2 and we'll check whether minus 2 is a key in this hash map or not so currently minus 2 is not a key into this hash map therefore this condition map dot contains key comes out to be false and if you make a reverse of it then it then the if condition comes out to be true therefore the if statement will be executed and we'll simply put the number at ith position along with an index value so we'll put 11 and 1 so 11 is the number at ith position and value is the index position which is 1 so basically friends we are putting these numbers so that we can have a quick look up into this hash map and we can come to know that whether there is a number whose addition with this current number will make the target as 9 so moving ahead so now i becomes 2 and it will point to the second index of the array so we'll again check whether target which is 9 minus number at ith position so number at ith position is 5 so we'll check whether 9 minus 5 which is 4 is present in this hash map or not so number 4 is not present in the hash map therefore this condition map dot contains key comes out to be false and if we do the reverse of it it comes out to be true so the if condition comes out to be true and we'll simply put the number at ith position along with the index value in the hash map so we'll store 5 with 2 so 5 is the number at ith position which is 2 and 2 is the index value moving ahead now i becomes 3 so i will point at the third index and we'll again check whether map contains target minus number at ith position so target is 9 at number at ith position is 10 so we'll check whether 9 minus 10 which is minus 1 is there in the hash map or not so currently it's not there so map dot contains key comes out to be false and if we do the reverse of it it comes out to be true so if block gets executed and we'll simply put the number at ith position and the index value in the hash map so we are storing 10 along with this index value moving ahead so now i becomes 4 and here it points to the fourth index now friends we'll again check whether map dot contains key target minus number at ith position so target is 9 and number at ith position is 7 so we'll just check whether 9 minus 7 which is 2 present in the hash map or not so if you see when we do 9 minus 7 it comes out to be 2 and 2 is present in the hash map so it means that the first number is 7 and the other number is 2 so when we do 2 plus 7 we'll get 9 so it's like a fast lookup into the hash map so currently 9 minus 7 which is 2 is present in the hash map therefore the map dot contains key comes out to be true and the and if we do a reverse of it it comes out to be false so it means we have found our two numbers which will add up to make a specific target and now as we want to return the indices of those two values so first indices would be the current value of i because 7 is one of the number so we'll store the index value and the result array at the first position moving ahead and we need to store the index of the number 2 so what we'll do we'll just do a map dot get target minus number at i at position so we are simply doing 9 minus number at i at position which is 7 so 9 minus 7 which comes out to be 2 and we are passing the key as 2 and we are getting the value out of it from the hash map so it comes out to be 0 and we are storing it into the result array so these are the two indices which we found which is 0 and 4 and finally we'll just return the result so friend this was the one of the way by which we can find the two numbers whose sum makes up to a specific target value and suppose if you don't find any number then we can simply either return a result array having the indices at 0 0 or we can throw an exception like illegal argument exception so friend this was the demo of the algorithm now let's go to eclipse and see the working code so friends let's code the algorithm what we saw in the slide so here i have just created one class by name twosome and it has one method the main method so let's give the method name as public static twosome so the return type is the integer array because it will return back as the indices of the two numbers and the method takes in an integer array which is the numbers array and it also takes an integer my name target so in this method first we'll create a result array so this result array will store the indices of the two numbers and then we'll create a hash map which will store the integers as key value pair so map so we can simply give the name as map new hash map we'll just import it now we'll create the for loop so we'll iterate the complete array from 0 to numbers dot length so this will basically iterate each and every element in the numbers array so in the for loop our first condition would be if map dot contains key and here we'll provide target minus numbers at the height position so we'll just we'll we'll just check whether the map contains the target minus number at ith position key and if it doesn't contain then we'll simply put map dot put the numbers at ith position which is index value and in the else now the else part will come when you found the two numbers so we'll just populate the result array say at one will put the index and at zeroth position will put map dot get target minus numbers at ith position and finally we'll just return the result and if suppose we haven't found the two numbers then we can either throw an exception if we can throw an exception say illegal argument exception the string as two numbers not found so friend this is the code for finding the two numbers which add up to make a specific target now let's see is working in this main method so here first we'll create the numbers array so I will populate the values I had given in the slide two eleven five ten seven and eight now as and result array will be returned therefore created integer array variable by name result and I will just call twosome method by providing the numbers array and let's say we give target as nine and let's say we print both the indices so the two indices are result zero plus result at one position so friends let's run this java code so friends you see the two indices are zero and four so at zero will find will find a number having the values two and at index four we have found seven so if we add two and seven we get the values nine so friend this was a tutorial about twosome problem I hope you like this video please like comment share and subscribe my youtube channel thanks have a nice day hello everyone so in this video we will be discussing about the twosome problem in java so in one of our previous video we have actually seen the solution to twosome problem where we used a hash map so in this video we will be looking into yet another approach to solve the twosome problem so before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here if you see we are given an array of integers let's say having different values two eleven five ten seven eight now the integers in this array are not repeated and we are also given a target let's say nine so in this problem we have to write a function where this array and this target will be given and we want to return a pair of numbers such that they add up to a specific target which is nine so here if you see two plus seven will give the value as nine which is equal to our target so we need to simply return two and seven in a form of integer array so let's move ahead and see the demonstration of this algorithm step by step so here's the algorithm which we will be using to find the pair of numbers which is equal to our target so the method name is twosome it is taking in an array and a target and it is returning an integer array so at the first step we usually call twosome method by passing in the array and the target is nine so this method will start its execution this is the array having values as eleven two zero ten seven and six so these are six elements from index zero to five and the target we are providing it as nine so we want to find a pair of number such that if we sum them we get the value nine moving ahead so here if you see as these numbers are in random order so in order to find the pair two and seven which will be resulting to our target we have to compare each element of this array to another element but doing so will be the time consuming algorithm so what we do in the first step is we try to sort this array we will see its significance later so after we sort this array here you can see the elements are arranged in ascending order zero two six seven ten eleven moving ahead now we'll see the significance that why we sorted this array so in order to solve this problem what we actually do is we actually take two pointers one is the left pointer and one is the right pointer so the left pointer usually points to index zero and the right pointer usually points to the last index of this array so here if you see we will be creating a variable left we'll assign a value zero to it so this zero signifies the index so it would look something like this that left is pointing to index zero moving ahead we'll create a right variable we'll assign the value as array dot length minus one so if you see array dot length value is six and if we do minus one we'll get five so right will point to fifth index moving ahead now what we do is as we want to return the pair so we create a result array which will only take two values so this is the result array so by default the values will be zero zero because we are taking the integer array moving ahead now here we actually did two things first we sorted the array in ascending order then we created two pointers left and right now what we do is we provide a while loop and inside this while loop we provide a condition as left should be less than right so here if you see left is at 0th index and right is at fifth index so left is less than right now using these two pointers what we do is we try to find out the pair so first number will be denoted by left and second number will be denoted by right so these two pointers will help us in pointing both the pairs so the condition is left should be less than right in the while loop so at the start this while loop will execute because left is less than right now at the first step what we do is we take the value associated with the left pointer and with the right pointer and as we want to find the pair sum we usually do their sum so here if you see we do 11 plus 0 which will give us 11 so sum will be 11 now what we do is we try to compare our sum with target to simply check that whether sum is equal to target or not so here if you see target is 9 and our sum is 11 so 11 is not equal to 9 it means this is not a valid sum so basically when we do this comparison there are three possibilities sum is equal to target sum is less than target or sum is greater than target so sum is not equal to target so the else part will be executed and now here we will be checking whether sum is less than target or not so here if you see sum is 11 and target is 9 so 11 is not less than target now why we have provided this condition is because so here if you see that when we sorted this array in ascending order now the advantage will come into picture at these two steps so if 11 is not equal to 9 which means sum is not equal to target so there are two possibilities either sum is less than target or sum is greater than target so here currently 11 is greater than target and as we have this array in sorted form in ascending order we know that we need to reduce this sum by 2 or whatever value so that it is equal to 9 so we have two choices either we traverse left this side or we go right this side so here you can see if we go left this side we will get a value greater than zero and if we go in this direction to right we will get a value which is lesser than 11 and we want to reduce this sum so here we can't go in this direction by moving left to this position because in the next iteration when we will do sum we will get 11 plus 2 which will give us 13 2 and 11 will give us 13 and 13 is way more far than 9 so we have only one choice to make that we reduce the sum by moving right into this direction so here these are the two checks which we perform so sum less than target so this condition comes out to be false because sum value is 11 and target is 9 so the else part will be executed where you will see the significance that why we are doing right minus minus because we need to shift right to this position which means from fifth index we need to move to fourth index so we'll simply decrement value of right so it would look something like this right becomes 4 and now it will point to the fourth index i'll simply remove this now again our execution point will reach here we will check whether left is less than right or not so left is less than right so the while loop will execute we will again calculate the sum by taking in the values at left and at right pointers so now our values would be 0 plus 10 so these are the values it will give us a value of 10 so sum will become 10 now we will compare sum to the target so here we can see that sum is not equal to target so the else part will be executed we will again check whether sum is less than target or not so here you can see 10 is greater than 9 so therefore this if condition will come out to be false because we can't move left to right because if we move left to right then we'll get a value which will be more than 9 which is like 10 plus 2 which will give us 12 which will make us more far from the target so what we do is we simply shift right by decrementing it by one position because we know that as the array is sorted if we move right to this position we will get a number lesser than 10 so the else part will be executed now right will point to 3 which is the third index we'll again check in the while loop whether left is less than right or not so left is less than right we'll again do the sum so this time it would be 0 plus 7 which will give us value 7 so sum becomes 7 we compare sum with the target so sum is not equal to target now again our else block will be executed so here you can see now that sum is actually less than target so initially sum was actually greater than target so we moved right pointer in this direction because we wanted to decrease the actual sum but now sum is actually less than target so what we need to do is if we move right again to this point so when this while loop will execute again we will get 6 plus 0 which is like we are going to a more lesser value than target so if sum is less than target we need to increase the sum so that we reach the target so the only way we can increase the sum is by moving left to this point because we know that here it value is 0 and this array is in ascending order so whatever value we'll get after that will be greater than 0 so this condition is for that so else if part will be executed and we'll simply increment left by one position so left becomes one now it will point to the first index moving ahead we will check whether left is less than right or not so left is less than right we will take their sum at their respective indexes so it will be 2 plus 7 which is 9 so sum will become 9 so for here you can see now sum is equal to target so it means we have reached to a point where we can simply return this pair because we have found a pair whose sum is equal to our target so this block will be executed because this condition came out to be true so in the if part what we do is one value is 2 so we'll simply assign the value stored at left pointer to the zeroth index of the result so this 2 will come here and then we'll simply assign the value stored as right pointer to the first index of result so here 7 will come to the first index so we have found our pair which is if we do the sum of 2 plus 7 we will get 9 which is the value equal to our target so at the last step we will simply return the result integer array so friends here you saw the significance that why we sorted the array because if the array is not sorted then we need to compare each element with every other element so this would have given us a count time complexity of o of n square which is a not a good time complexity so we actually sorted the array so that we know that the first element is the smallest and the last element is the largest so when we do the sorting we usually go to n log n time complexity and then using this while loop we simply do one iteration and we find the pair using this two pointers because as the numbers are sorted left starts from here and right starts from here and then we simply take these values stored at right and the left pointer we do their sum and we try to compare it with our target so if the sum is less than target what we do is we simply shift left by one position we simply moved right to this direction by incrementing or decrementing respective variables so friends i hope you have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw an animation that how we can solve the two sum problem in java now in this video we will actually code the algorithm and we'll test its working in main method so before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here you can see that i have created one classes array util and in one of our previous video we saw the two sum problem in that video we discussed one of the solution to solve the two sum problem we basically took the help of a hash map and we solved the problem now in this video we'll see one more way to solve this problem so let's suppose i create one method here as public static two sum two because we are discussing the second approach here so this method will take in an array where we will be provided with different numbers and those numbers will be unique and we will be also provided with a target and usually there will be one such pair which will be equal to the target so we need to find that pair and after finding that pair we'll simply return it in the form of an array of length 2 so in our previous video we discussed that how we can solve this problem we took the help of sorting and two pointer approach so the first step we do is we sort the array so using arrays.sort we will pass in the array so we'll get the sorted array so here you can see this arrays class in java has a sort method where if we provide the array we get the sorted array in ascending order so here you can use your own sorting algorithm or we can use the sorting algorithm provided by java now after sorting this array what we'll do is we create two pointers one is the left pointer which starts from 0th index of this array and one is the right index which usually start from the end of the array so if you want to know the last index of an array what we can do is we'll simply call array.length so this will give us complete length and if we do minus one we'll get that particular index because array starts from zero index and goes to array.length minus one index now after creating these two pointers as you want to return the pair of numbers whose sum is equal to target we will create an array we'll name it as result and this array will be of size 2 because it will take two numbers now after creating this array we have these two variables left and right now these two variables will help us in finding that pair of numbers whose sum is equal to the target now here we'll provide a while loop and as left starting from 0th index and right is starting from the last index this while loop will go on till left is less than right if left becomes right then we'll simply break from this while loop so in the while loop what we'll do is we'll first calculate the sum of the values stored in the left and the right index so we'll do array of left plus array of right now in our previous video we discussed that after calculating the sum we try to compare it with the target so there are basically three possibilities so the first possibility is if sum is equal to target it means we have found our target and we'll simply store the both the values array of left and array of right into this result and we'll simply return the result so here what we'll do is this result at the 0th index we'll simply store array of left and at the first index we'll store array of right because these two are the numbers when we did the sum of it it became equal to our target so we are storing both these values into the result array and here we are simply returning result now this is the first condition when sum is equal to target there could be two more conditions let sum could be less than target or sum could be greater than target so friends here is the significance that why we actually sorted the array if our sum is less than the target then what we do is we need to increase our sum in the next iteration so here we simply increment left by one position so let's say if i take this example here let's say the sorted array comes out to be 0 2 6 7 10 11 so here you can see left will be pointing to 0 and right would be pointing to 11 so if we do sum of it we will get value is 11 and let's say our target we want is 9 so here we know that 0 plus 11 which is our sum is greater than target so what we do is we need to reduce the sum so we have two possibilities either we traverse left towards the second value or we can traverse right towards the second last value so here currently sum is 11 but if we traverse left to the second position in the next iteration our sum will become 2 plus 11 which will give us 13 so we are going way more far than the target so here our only possibilities we move right to the second last position because in the next iteration if we do the sum we will get 10 plus 0 which would be 10 so 10 is pretty much close to the target so these are the fls provided for that so if sum is less than target then we need to increase the sum so that it matches target and the only way to increase the sum is by incrementing left so that left can go to the higher values and if sum is greater than target then we need to reduce the sum so for that what we need to do is we need to decrement right because as the array is sorted if right is pointing here let's say to 11 if it goes to the second last position we will get a value which is lesser than 11 so here we'll do right minus minus this so after this while loop will terminate what we can do is we can simply return our dummy integer array or we can throw an exception like we did here the two numbers not found so now let's test it's working in the main method so let's suppose we are provided with this array and here what we do is we simply call to sum we pass in the array and let's say we pass in the target as 9 and we'll simply print the array so if i run the main method now so here you can see it returned two values two and seven so if we do two plus seven we will get our target as nine so friend this was all about solving to some problem using the sorting and two pointer technique i hope you must have liked this video in case if you're new to my channel then please subscribe to my channel thanks have a nice day hello everyone so in this video we will be discussing a subsequence problem in java so first we will see what is a subsequence before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so usually a subsequence of a string is actually a new string which is formed from the original string only and how it is formed by deleting some or no characters and only thing to keep in mind is we should not change the order of the remaining characters so what it means now let's see why example let's suppose we are given with the original string a b c d e and we are given a sequence a c e now we have to find whether a c e is a subsequence of a b c d e or not so here you can see if we delete b and d and we don't change the order of the remaining elements we actually get a c and e so therefore a c e is a subsequence of a b c d e if we look into a e c so it is not a subsequence of a b c d e so here a e c is present in a b c d e but if we remove b and d the remaining characters doesn't form a e c it actually forms a c and e so the only thing we need to keep in mind is the order of the elements shouldn't get changed so here c is actually coming before e but here e is coming before c so therefore the order of the element has changed so therefore a e c is not a subsequence of a b c d e now if suppose we were given a string as a b c d e so here you can see by deleting some or no characters so if we were given this string this string also is a subsequence of a b c d e because we are not removing any characters and we will be getting the same string back so this is a subsequence of a b c d e so one other way to look into subsequence is we simply see in this direction in both the string and we see whether those characters come into this order only or not so here first we encounter a and here we see we have got a so we move ahead now we see c so here is b so we simply move ahead we encounter c so we simply move ahead we see e and here we see d so we simply discard it and we move ahead and at the last we find e so therefore a c e is a subsequence of a b c d e now here we see a a so we move ahead we go to e we go to b so these two are not equal so we discard it we go here we see e and c we discard this we go here we find d and e we discard this we come here we find e so e and e matches so now we move here but here you can see complete string is exhausted and there are no more elements therefore we come to a conclusion that a e c is not a subsequence of a b c d e so we will be applying this similar algorithm to solve this problem so here you can see this is the algorithm where we will be provided with the original string and a sequence we need to simply find out whether this sequence is actually a subsequence of this string or not so let's see the demonstration of this algorithm step by step so we'll call this subsequence method by passing in two strings one is the original string and other is the sequence and here you can see the return type of this method is boolean so we will either return true or false so at the first step a b c d e is our string and the sequence is a c e so we are figuring out whether a c e is subsequence of a b c d e or not so this is our original string and this is the sequence so here you can see that we have represented a string in a form of a character array so in java string class has this method character at where we pass in an index and we get a particular character present at particular index so if we pass one we will get the character as b so we can use this method to simply get a particular character at a particular index we can also use two char array method which actually gives us the character array and then we can perform our logic on this character array but here i will be simply using this charAt method and we will see the string in a form of a character array moving ahead now what we discussed in our previous slide that we simply look into this direction in both the string so for that we create two pointers i and j so i will simply traverse into the original string and j will traverse into the sequence now we want to simply check whether a c e is present in this particular order into a b c d e or not so for that we have provided a while loop where the condition is this while loop will continue till i is less than string's length so your string length is 5 and j should be less than sequence length so here i will be traveling from 0 to 4 and j will be traveling from 0 to 2 because the length of the sequence is 3 so this is the condition we need to keep in mind so why we have provided this condition is i should be less than string dot length is so if i goes beyond the length of the string then we need to break from this while loop because there are no more characters left to be compared and similarly with the j if j travels beyond the sequence then it simply signifies that we have found our sequence and we should simply break from this while loop because this original string can have n number of elements and as we have found our sequence we should break from this while loop because we don't want to go further into the string so at the start i is less than 5 and j is less than 3 so this condition comes out to be true the first step what we do is we simply compare the character at i at index with a character of the sequence at jth index so it means we are simply comparing this character with this character so j is pointing to sequence so and j is also referring to the index 0 so this character is compared with this character now if they are equal so currently a is equal to a so this condition comes out to be true now what it signifies is one of the sequence character is matched so now we can safely move j to the next index so we do j plus plus so j becomes one moving ahead and after that we do i plus plus because now our second character should match with the rest of the string which is this because this is already being matched so we do i plus plus so i points to index one moving ahead i is less than five as one is less than five and one is less than three because j is pointing to one so both condition comes out to be true we again check whether character at i at index of string is it equal to the char at jth index of the sequence so it simply means we are comparing b with c now here you can see b is not equal to c therefore this condition comes out to be false now as this condition comes out to be false we don't increment j because there could be a possibility c might come later in the string so therefore condition in this block comes out to be false and we only increment i so we don't touch j we only increment i so i becomes two so i'll just remove everything now we again check whether i is less than five so this condition comes out to be true and we also check whether j is less than three because sequence dot length is three so both this condition comes out to be true we compare the respective characters at ith and jth index so here we are comparing c with c because i and j are pointing to these two indexes so here you can see c is equal to c so this condition comes out to be true it means our second character actually matched with the character in the original string so we'll simply increment now j by one because because we have matched our character and now we simply move to the next character so j becomes two and we'll increment i because this character is already matched five becomes three now here three is less than five and two is less than three so both condition comes out to be true we compare the characters at these respective indexes so it means we are comparing now d with e so here you can see d is not equal to e therefore this condition comes out to be false and we don't increment j and here as we discuss why we don't increment j because later in the string there could be e coming up so here you can see e is here but but if here the character would have been different so there could be a chance that e might have come later so we don't increment j we only increment i so i becomes four so i'll just remove this so four is less than five this condition is true and two is less than three so this condition is also true we'll compare e and e which is this character with this character so this comes out to be true so we'll increment j because our character is matched so j becomes three it means now j has crossed the limits of sequence moving ahead will increment i so i becomes five it means i has also crossed the limit of the string so now you can see value of i is five and five is not less than five so this condition comes out to be false so the overall condition comes out to be false so this while loop will exit so friends here at the last step this condition is pretty much important because if value of j is actually equal to the sequence length it means j has traversed this sequence complete and we have found our element so currently j value is three and sequence length is three so three is actually equal to three therefore we will return true because j is equal to sequence dot length and this expression returns true as three is equal to three because when j will equal to the length of the sequence it means it has traversed a c and e completely so here we are returning true so now we'll see one more example let's say we call abc de with the sequence a ec so we'll go over this example quickly i is zero and j is also zero here string length is five and sequence length is three both the condition comes out to be true because i is less than five and j is less than three we compare the characters at the respective indexes of their respective strings so we are comparing a with a which is true so we'll increment j j becomes one and we'll increment i so i will become one both this condition is true because i is less than five and j is less than three we'll compare b with e by this expression so b is not equal to e so this condition comes out to be false we won't increment j because there could be possibility e might lie somewhere after b so we'll only increment i becomes two both the condition comes out to be true i is less than five and j is less than three we'll compare c with e now so this condition comes out to be false we'll increment i i becomes three i is less than five and j is less than three we'll compare d with e so they are not equal so we'll simply again increment i i becomes four i is less than five j is less than three now we'll compare e with e so they are actually equal so it means the if block condition came out to be true so we'll increment j so j becomes two and we'll increment i so i becomes five so this is the important moment this i has become five it means i has crossed the boundaries of this string so here value of i is five and string length is five so therefore this condition comes out to be false so this while loop will exit so friends here you can see now value of j is two and sequence length is three so this condition is very much important to figure out whether all the characters of the sequence were traversed or not so here you can see j is two and two is not equal to three therefore aec is not a subsequence of a b c d e so we'll simply return false so friends i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel thanks have a nice day hello everyone so in our previous video we discussed the problem of a subsequence where we were given two strings one was the original string another was a sequence and we need to find out that whether that sequence is actually a subsequence of that original string or not so before going through this video you watch that animation so that you get an idea that how we can find out that whether a sequence is a subsequence of any other string so in this video we'll actually code the algorithm and we'll test its working in the main method so before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here you can see that i have created one class as string util and inside that class we will be creating our method public static will give it a name as is sub c quence now this method will take two strings one is the original string another is the sequence so we need to find out whether this sequence is actually a subsequence of the string or not so the return type would be a boolean so in our previous video where we saw the animation we actually used the two pointer technique where we created two pointers i nj so i usually traverse the string nj traverse the sequence and usually we traverse both from left to right and we simply try to compare the character present at that particular index which is being denoted by i and j into their respective strings so we provide a while loop and inside this while loop we provide the condition s this while loop will go on till i is less than strings length and j is less than sequence length because as we are traversing these two pointers from start to finish if any of the pointer crosses the limit of their respective strings we simply break from this while loop so inside this while loop we simply compare the character at i and jth index of their respective strings so here we do if charit i is it equal to sequence dot charit j so if they're equal so here let's say if we take the string as a b c d e and let's say we take the sequence as a c and e so here you can see that j starts from zero and is starts from zero so we are simply comparing the first element if they are equal it means we have found one of the character of the sequence into the original string so we simply increment j by one because now we try to compare the next element into the original string and after this if block we always increment i by one position because we have matched this character with this character now c and e will be compared with the rest of the string so in the next iteration you will see that b is compared with the c via this condition so this condition comes out to be false because b is not equal to c so we don't increment j we only increment i because there could be a possibility that c might come later in the string because we are trying to find out the subsequence here so we always increment i irrespective whether we have found our element or not because if we have found our element here then we increment i because we have to compare the rest of the sequence with the rest of the original string and if we don't find the matching character which is here where we are comparing b with c so this condition comes out to be false so we try to only increment i because there could be a possibility that next character should match with the sequence character at jth index so this loop goes on and at the end what happens either this condition comes out to be false or this condition comes out to be false or both condition comes out to be false so this while loop will terminate so after this while loop will terminate we simply return is j is equal to sequence dot length or not so why we are doing this is because let's say if this condition comes out to be false it means j is equal to sequence dot length which signifies that if j is equal to sequence dot length we have found our subsequence we have found that this sequence is actually a subsequence of this string because we have traversed each and every element and we have found them to be true and at the last increment of j it will actually reach to the sequence dot length so if j is equal to sequence dot length it means this sequence is actually a subsequence of our original string and let's say friend if we provide aec so this a would have matched with this a this e would have matched to this e and after that j would have remained to c because our original string would have been exhausted here as i would have become equal to string dot length so at that moment of time this condition would have come out to be false which says that aec is not a subsequence of abcde so friend this is the algorithm which help us in determining that whether any sequence is a subsequence of the original string or not so now let's test it working in the main method here we will simply print is subsequence let's say we pass the string as abcde and we pass ac and e if i run the main method now you will see it came out to be true now let's say if i run it with a e and c so it came out to be false so why because aec though it's present in a b c d but the order of elements which constitutes the property of subsequence is not matched here you can see c is coming before e but here e is coming before c therefore this cannot be the subsequence of this string because the order matters in the subsequence so friends i hope you liked this video and in case if you're new to my channel then please subscribe to my channel thanks have a nice day hello everyone so in this video we will be discussing first nonrepeating character problem so this is a very famous interview question which is being asked by many companies so we'll see what this problem is and we will see the demonstration of this algorithm step by step so here you can see that we are given a string as which only has lowercase letters now we need to return the index of first nonrepeating character first nonrepeating we mean is the unique character which occurs first and if it doesn't occurs or doesn't exist we can return minus one so we need to return the index let's see with an example suppose the string provided is code for code so here you can see the answer is fourth index the first nonrepeating character is f and is found at index four so let's see how we actually traverse the string from left to right because we need to find the first nonrepeating character so here you can see if you see c occurs here as well so this is not a unique character we check o is here and here at three places so o is also not unique we see d d is here and here so d is also not the unique character or first unique character e is here also so e is not the first unique character now we see f so you can see f is not present in the rest of the string so f is the first nonrepeating or unique character in this string and the index is let's say zero one two three four so four is the answer now let's suppose we have provided with string as a a b b so here you can see a occurs twice and b is also occurring twice so it doesn't have any nonrepeating character so we simply return minus one now let's see the algorithm for it and its demonstration step by step so here you can see this is the algorithm to solve first nonrepeating character problem so before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here let's say we call this method first nonrepeating character we pass the string as race cars so here the string is race cars something like this so friends the basic idea behind this algorithm is we actually take the help of a hashing data structure which is a hash map which basically has key and value so here key is unique which is our character and the value is a integer which will actually hold the count of the character occurring in the string and why we are taking a hash map is because if you see somewhere here we are doing get now this get operation when we pass any character will return as the count for that particular character and this happens in O of one time if we don't use hash map then the algorithm will take multiple for loops and will increase the time complexity so therefore to get the character count very fast we use this hashing data structure which is our hash map so we'll see its significance when we see the algorithm step by step so first we will create a map having key and value of type character and integer so here i am simply demonstrating it as key value pair but internally this map uses a hash function to store this key value pair such that the retrieval becomes faster you can watch my videos on hashing data structure and hash map but here i will be simply demonstrating it with the values so here we have this string array scars now what we do is as we need to find out a single character which is first nonrepeating we first take this string we call two char array method on it and this will return us a character array so this method is present in a string class so it would look something like this that we have got our character array where this array at each index holds one character like this moving ahead now what we do is we iterate our each and every character one by one and we put it the character into the map and we put it such a way that if that character is not present we put one and if the character is present we take that value first and we add one to it so we'll see how this line works but here you can see that we are putting the character because key is the character and as the integer what we are doing is we are calling hash maps method get or default so when we do map dot get or default if this character is already present then its corresponding value is returned and we simply add one to it and we put it back into the map and if the character is not present then we return a default value so its like get or default so for the default value here you can see we provide zero which signifies that the particular character if it is not present in the map it means just return the count as zero and why we are doing plus one and putting it back into the map you will get more when we will see the working of this for loop so here this for loop will iterate each character one by one so it will start with r here we will put r and here you can see the map is empty it doesn't have r so the default value of zero is returned and when zero is returned we do plus one to it so it becomes one and we put it into the map so here it would look something like this we put r as our key and value as so this one signifies that character r occurred one time as we are traversing from left to right so at this moment r is occurred one time so therefore we are returning this zero because we are adding one to it so if r again comes up we will do map dot get or default we will get actually one because r is already present as a key so we add one to it which means the count of r is two we extracted one and we added one to it so the count became two and if the value is not present we add one to the zero and put it back into the map moving ahead now it will pick the second character which is a it checks whether a is present or not so a is not present in the map so it simply returns the default value zero we add one to it and we put a as a key and value as one so it goes like this it takes c now and similarly it puts c as a key and one as a value because c is also not present in the map so get or default will return zero as a default value now it takes the fourth character which is e we put e also as one because the count is still one now it takes c so here you can see when we will do map dot get or default now this time zero won't be returned because c is already present and with a value as one so this one will be returned and we'll simply do plus one and we put c with value as two so this complete expression gives us two for c so here it becomes two and which makes sense because till this point we have encountered c two times so we are simply storing the frequency of the character in the value field moving ahead now it will pick a a is also present so it will take this value it will add one to it and it will insert it back so it will become two it will pick r so r also becomes two and at the end it picks s so here s is not present so therefore the default value zero will be returned we do plus one and we put s with one so now this for loop will end so friends here you can see this is the character frequency map so why we have done this is to simply count the number of occurrence of a particular character so here you can see r occurred two times here and here a occurred two times here and here c one year and one year and e and s occurred only once here and here so now the next for loop will help us in deciding which is the first nonrepeating character so here we will again iterate the char array from zero index to the end so initially i is zero and i is less than char.length which is eight so char.length is eight so we pick the first character we provide index zero so r will be picked and now we'll simply call map.get and we pass the character so when we do map.get we will get its corresponding value because we are passing in the key and this map will return us back the value associated with this key and dead to an o of one time which is very fast so that's why we were using hashmap so here when we do map.get r we will get the value as two so here you can see two is not equal to one it means r cannot be our first nonrepeating character because it has value two so we move ahead with the next character i becomes one one is less than eight we take the next character which is a as index one because value of i is one we do map.get a so we pass in the key as a and we get value as two it means a cannot be our first nonrepeating character we move ahead i becomes two two is less than eight we pick c now we do map.get c we get the value as two two is not equal to one so therefore c can't be our first nonrepeating character because it has value two it means it has occurred two times we'll increment i to three we'll pick now e now here you can see when we do map.get e we get a value as one so one is equal to one it means this condition comes out to be true and which signifies that we have found our first nonrepeating character because we were traversing this for loop from this end and whichever value we found to be one we simply return its index so here whatever the value i will have we'll simply return it back so the answer would be three so now let's see this example one more time with value is ab ab so we'll quickly go over it string is ab ab we create a hash map like this we convert this ab ab into character array by calling 2 char array so it comes out to be like this now we literate each and every character and we put its frequency as a value in this hash map so we start with a we check whether a is present or not by this it is not present so we return the default value zero whatever value is returned we add one to it and we put a into the hash map so the value would be one signifies that a has occurred one time we go with the b and similarly b will have one because b is not present in the map we take a and we see a is already present so we get this value out we add one to it and we put it back so one plus one will give two and we put two back into the hash map we take the last character b we see b is also present so we do one plus one and add it back so occurrence of b is also two now this for loop will end so here you can see looking into the hash map a occurred two times here and here b occurred two times here and here so here we can see that in this string no character has appeared once so this for loop will help us in figuring that out we will start with i equal to zero index we go till cares dot length so cares dot length is four zero is less than four we take first element which is a so we do map dot get a we pass the a we get value as two so here we can see that two is not equal to one so this condition comes out to be false we increment i i becomes one one is less than four we take the first index character which is b i'll remove this we do map dot get b we pass the key b we get value as two so here two is not equal to one so this condition comes out to be false i becomes two two is less than four now we take the second index value which is a we do map dot get a it returns two two is not equal to one this condition comes out to be false and similarly we do for the last character we take b we do map dot get b it will return two two is not equal to one so this condition comes out to be false so here now i will become four and four is not less than four so this for loop will end and once this for loop will end if we haven't written anything from this condition at the end we know that there are no characters in this string which are unique so we simply return minus one so friends here we saw two examples in one we found the first nonrepeating character and in other we didn't found any nonrepeating character so if i go to the previous slide so here you can see that when we did race cars we actually saw that e and s both had a count one but here e occurred before s so therefore this e was the first nonrepeating character not s so this is one thing we need to keep in mind that we need to find first nonrepeating character i hope you must have liked this video in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw the detailed demonstration of the algorithm to find first nonrepeating character in a string where we were given a string in lower case letters and we wanted to find the index of the first nonrepeating character in it so in case if you want to understand more you can watch my previous video so in this video we will actually code the algorithm and we'll test it's working in the main method so before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here in string util class i will be creating the method as public static we'll give the method name as first nonrepeating character so this method will take a string and it will return the index which is of integer type for the first nonrepeating character so friends here in order to find the first nonrepeating character we first iterate this string completely and we figure out the character frequency that how many times a particular character has occurred so for that we are using the map postkey is character and values integer which is the count of that particular character that how many times it has occurred so we can give it a name as character frequency map new hash map now we want to iterate each and every character of this string one by one so for that we take the string and we convert it into character array by calling two char array method then we provide a for loop so here we will iterate one one character in each iteration now here what we do is as you want to count the character frequency that how many times it has occurred what we do is we do character frequency map dot put we put the character as key and the value we put is we first check that whether this character is present in the map or not so we do it by method get or default we pass the key to it if that character is present the value corresponding to it will be returned and if that character is not present so we can return a default value because the method is get or default so we need to pass the default value to it which is let's say if the character is not present we want it to return zero so here you can see default value is zero and what we need to do is let's say if the string has a character a which is not present so here we have encountered a so we need to put the count as one because a has occurred once so we'll do plus one to it and let's say next time for example let's say our string has something like a b a so for this map will have a as a key and value as one now when this a will again occur so this get or default will return the previous value which is one and we will add one to it so now map will have a as a key and value as two because a occurred two times so this we do for each and every character and after doing that we provide another for loop and we iterate this char array once again and now as you want to find the first nonrepeating character and we are starting from zero index so whichever character value in this character frequency map will have one it means when we traverse this character array completely that particular element was the one which had only occurrence one and which was the first nonrepeating character so here what we do is we take the char from the ith index we provide a if check if the character frequency map we do get we pass the character and if the value returned is one it means this is our character which is first and nonrepeating so we simply return its corresponding index which is i and if we don't find any such character whose frequency is one then at the end we simply return minus one so now let's test it's working in the main method here we will call first nonrepeating character let's say we pass the string what we saw in our previous video raise cars so here you can see it should return 0 1 2 3 because e is the first nonrepeating character why because r a and c have occurred two times in this string so if i run this so here you can see it return three and let's say if we put a string which doesn't have any unique character so here a has occurred three times v has also occurred three times if i run it it should return minus one and let's say we provide a value here as e so now we have e as a character which has occurred only once and it's the first nonrepeating character so if i do run it we will get its index as six because 0 1 2 3 4 5 6 so e is at sixth index now let's say if i do in between i do f so now f is our first nonrepeating character because e comes later so now it should return three so it comes out to be three so 0 1 2 and 3 so friend this was all about the algorithm to find the first nonrepeating character in a string string i hope you must have liked this video in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we will be discussing a problem that how we can remove vowels from a string so here we are given with a string and we need to remove the vowels from that string and return that string and the string only contains the lowercase letters so if we talk about vowels then there are five vowels a e i o u so let's suppose we are given with this string what is your name so the output would be this a i o u a and e this will be removed because those are vowels and this string will be written like this so now let's see the demonstration of the algorithm step by step that how we can remove the vowels from a string so before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here you can see that this is the algorithm to remove vowels from a string so now let's see the demonstration of this algorithm step by step with an example so we'll call remove vowels method we'll pass the string as ice cream so here string would be ice cream so here you can see that it has vowels like i e e and a so here in order to remove the vowels from this string we take each character and we see whether it's a vowel or not so for that first we create a set which we denote as vowels and this set will only have the characters so this is a set of a e i o u and why we are taking it as a set because here you can see that we are using for loop we are iterating over each character of this string and we are checking whether this particular character is present in this vowel set or not so this contains method is very fast and it has an average time complexity of o of 1 which is nearly constant so therefore we are using set in order to know more about set and hashing data structure you can watch my series on hashing so after creating the vowel set we will be creating an instance of string builder now why we are taking string builder is because when we will be removing the vowels from this string we will be creating a lot of intermediate strings so to avoid that we are basically using string builder so string builder class is provided by java which actually deals with the operations performed over the string and which help us in generating a string without giving a performance hit moving ahead now this string has a method to char array in java so when we call this method we will get a character array so this ice cream will be separated out in a form of a character array so it would look something like this that this is the character array going from index 0 to 8 because it is taking ice cream one single character at a time so now we'll traverse each and every character one by one using this for loop so this for loop tells that iterate over each character present in the char array so when this for loop will start ch which is the character it will point to the first character which is i so ch is i so we take this character and we search into our vowel set that whether it contains ch or not so here you can see vowel set has character i so it means this is a vowel and we don't want to include this into our final string so what we do is here you can see the condition as vowels not contents will come out to be true and if we negate that it will become false so this condition comes out to be false and we will simply skip i because it is a vowel so now we'll go to the second character which is at index one so ch will become c we check whether c is present in the vowel set or not so vowels dot contents will return false because c is not present and if we negate that this will become true it means c is not vowel so we need to include this c into our final string so this condition comes out to be true so string builder has a method append where we will simply append the character c so it would look something like this that c comes into the string builder moving ahead we'll go to the third character which is e now e is a vowel so vowel dot contents e will come out to be true and this condition after negating becomes false so therefore we will skip e because e is a vowel moving ahead now the fourth character is actually empty string or a blank character so ch will point to this empty thing or space so this condition vowel dot contents will come out to be false and if we negate that it will come out to be true because this is not a vowel so we'll include this so we'll simply append the space moving ahead the fifth character is c so we'll simply include this because c is not a vowel so c gets appended now sixth character is r so vowel dot contents r comes out to be false because r is not a vowel if we negate this overall condition comes out to be true it means r is not a vowel and we need to include this so we'll simply append r the seventh character is e so e is a vowel so vowel dot contents will return true and if we negate it this condition will become false so we'll simply skip e because e is a vowel now we will take the eighth character which is a a is a vowel so we need to skip it and at the last we will take m so m is not a vowel so this condition is false and overall condition after negating becomes true so we need to include m because m is not a vowel so we have included m and after m there is no more character left so this for loop will terminate so here you can see at the end whatever we collected into our string builder if we do two string we will get a string like this and we'll simply return it from the remove vowels method so friends in this video we saw the algorithm to remove vowels from a string we took the help of the set and string builder to remove the vowels and return the final string without these vowels i hope you must have liked this video and in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in our previous video we saw an animation and we discussed the problem that how we can remove the vowels from a string so in this video we will be actually coding the algorithm and we'll test its working in the main method so before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here we have created one class as string util and inside that class i will be creating one method as public static we'll give it a name as remove vowels this method will take a string and this method will return back as a string without vowels so the input is a string with vowels what we get in return is a string without vowels so here basic idea behind this algorithm is we iterate over this string character by character and we figure out that which character is vowel and which character is not so how can we figure that out first we will create a set of vowels using set dot of method now this method will simply take the characters so we can provide the vowels as a a e i o u also here this string will only contain the lowercase letters so we have only provided the lowercase vowels now after creating the set of vowels what we can do is we will create string builder class so this string builder class will help us in creating the string which we want to return and this string builder class is performance efficient it has many utility methods by which we can manipulate the string now in order to iterate the input string character by character what we can do is we will call two char array method now this method basically return us a character array so after getting the character array we will provide a for loop where we will simply iterate over each character one by one so what we do is we provide a condition if vowels contains the character so if vowel contains the character it means this character is actually a vowel and we don't want to include it but if it is not a vowel then we need to include that character into our final string so here what we do is we do the negation of it so if character is present into this set this will return true and if we negate it we will we are simply skipping the vowel and let's suppose character is something like c b j k for example when we will call vowels dot contains this let's say c so it will return false this condition will come out to be false and if we negate it it becomes true which means that if there is c then we need to include that into our string so we'll simply append the character to our string builder class so basically when we will encounter any vowel this part will be skipped because vowels dot contains will return true and if we negate it this condition comes out to be false and this part is skipped so after doing this for each and every character at the end will simply return s b dot two string so this string builder will simply append only the characters which are not vowels and at the end when we will call two string it will convert everything into the string and it will return so this is the algorithm now let's test it's working here we'll call remove vowels and let's say we provide string as ice cream and if i run it so here you can see all the vowels are removed i e e and a everything is removed and rest of the string is returned also friends why we are using this set is because when we do contains on a set this is a very faster operation the average time complexity of this operation is o of one so basically it signifies that in o of n time we can simply find out the vowels from the string and remove it so friends i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss that how we can reverse an integer in java so here let's suppose we are given an integer x now we need to return x with its digits reversed so if you see an example here let's say if you are given with an integer as one two three four so our output should be four three two one we are simply reversing the digits of this integer similarly if you are given an integer which is negative one two three four so it should return negative four three two one so the sign should be there with only digits being reversed and let's say if you see example three here we are given an integer which is nothing but integer dot max value which is two one four seven four eight three six four seven now when we reverse this integer we get seven four six three eight four seven four one two so here you can see that this is the integer's max value and if we reverse it this value may overflow the integer range so we need to encounter this use case as well that when we are reversing the max or the min value or any value of the integer which on its reversal may overflow we need to encounter that use case as well so let's move ahead and see the demonstration of the algorithm step by step so here you can see that we are given with a method as reverse and we are passing in the number which we want to reverse so this method return type is long now why we have kept the return type is long is because there may be a chance that let's suppose this int value is maximum or any number which on its reversal may overflow the integer's maximum range or minimum range so therefore in order to fit that particular range we are taking a long value which will be returned from this method so here this long is basically handling our overflow case because when we cross the integer's range the data type which can handle that overflow range would be the long so now let's see the demonstration of this algorithm step by step let's say we want to reverse a negative number one two three four so here the number will be minus one two three four so here you can see the first thing we do is we simply check that whether this number is negative or not so if we provide this condition and whether number is less than zero or not so if number is less than zero the is negative will have value as true currently number is less than zero so the value of this negative will be true by this condition and why we are evaluating whether number is less than zero or not because when we are reversing the digits we need to take its absolute value without the sign we'll see this later so for time being we just evaluate whether number is less than zero or not if it is less than zero then we simply multiply it with minus one to make it a positive number so now number will become one two three four so here minus one two three four into minus one will give one two three four this minus minus becomes positive so here we have the integer value moving ahead now in order to store the reverse we are taking in a long value and why we are taking it is a long values because because this integer value number if we reverse the digits of it there may be a chance the maximum or minimum range of the integer so therefore in order to accommodate this overflow condition we are taking it as long because any value which crosses integers max or min range can be fit into the long variable so at the start reverse is zero so we will create the last digit integer value so this integer value will hold only one single digit which would be the last digit which we will see later here so friends in order to reverse this integer value these are the three main critical steps we need to perform in a while loop this is one of the approach to reverse the integer value now there can be one more approach we can simply take the string value of this number convert it into the character array and then we simply reverse the characters in that particular array so that could be one case but here we are taking the help of modulus operator and the division operator because this modulus operator is very important when dealing with numbers so here we will discuss what actually this modulus operator does and division operator does so currently number is greater than zero so this while loop will execute till number is greater than zero when number will be equal to zero or less than zero then this while loop will terminate so friends here you can see that in order to reverse this number one two three four it should become four three two one so what we need to do is we need to first take the last digit bring to this position then second last digit bring to this position third last to this position and fourth last to the last position so these are the things we need to do so how we can extract the single single digits from this number is we can take the help of modulus operator so here you can see let's say we want to divide 12 by 10 so 10 is the divisor 12 is the dividend and in normal mathematics when we divide 12 by 10 we get quotient as 1 and the remainder as 2 so here this remainder is nothing but the result of the modulus operator which you see here and this one is nothing but the result of the division which we do here so using the simple mathematics we will evaluate the reverse of this number and also friends here you can see that in order to get four when we divide any number by 10 whatever the remainder we get that would be our last digit so here if we divide one two three four let's say if i do one two three four and let's say divided by 10 so one two so here you can see that this is our quotient and this is our remainder so when we are divided one two three four by ten we get the remainder as four which is nothing but our last digit and the quotient would be the remaining digits just before the last digit so this is the crux of the algorithm that when we divide any number by 10 the remainder will give the last digit and the quotient will give the remaining digits so here when we take the remainder of the number which is one two three four the last digit will have value as four because this is our remainder here moving ahead now friends as we have extracted the last digit this would be our first digit when we do the reversal so here if i reverse one two three four we get four three two one so this would be our first digit now so in order to make it first digit what we do is whatever the value reverse will hold we will simply multiply it by 10 and we will add the value stored in the last digit we will see the importance of this part later so currently reverse is zero so zero into 10 will give zero and when we will add four to it we get reverse as four so reverse will become four four this part will be clear in the next iteration moving ahead now as we have extracted one digit we need the rest of the digits now and how we can get the rest of the digit is the quotient of this division so when we will do number divided by 10 we get the quotient as one two three so the new number will become one two three moving ahead so number is greater than zero one two three is greater than zero so this condition comes out to be true now we need this last digit so what we need to do is we need the remainder so when we will divide one two three by 10 because this is our new number so here we'll get 10 one so here you can see when we divide one two three by 10 we get remainder as three and the quotient as 12 so this is a similar approach when we divide any number by 10 the last digit is our remainder and the remaining digit is our quotient so now last digit will become three because we need three to simply append it here somehow moving ahead so for us now as we have got three as last digit and we need to append it here we can't directly add this three to the reverse what we do is whatever the value reverse will hold if suppose this is four and if i multiply it by 10 we will get 40 and then if i add the last digit which is three we will get 43 which is the stuff we want if it reverse one two three four we should get four three two one so four and three should be next to each other so this is the important step here that when we are multiplying the reverse by 10 we are simply shifting the digit by one place and we are adding the last digit to it so that both these numbers are next to each other so this is the important step so here now reverse will become 43 what we discussed here and as we are done with the digit three we need the remaining digits so the remaining digits we get by number divided by 10 which will give us the quotient so number will become 12 and the number is still greater than zero so this condition comes out to be true now we will take the last digit and how we can get the last digit is we divide the number by 10 so this is our remainder and this is our quotient so our last digit is 2 because number modulus 10 will give us the remainder as 2 so 2 will be assigned to the last digit and now how we can append two just after three is we need to create one space here and how we can create the spaces we simply multiplied by 10 we get 430 and then we simply add two to it which is our last digit we get four three two so this is the step which helps us in appending the last digit to the reverse so after this line gets executed reverse will become four three two with this multiplication and addition moving ahead we are done with two and now we simply need one so our new number will become the new quotient by number divided by 10 so we'll get the new number as one number is still greater than zero so this condition comes out to be true now we need the last digit but here you can see one is the only digit left so here when we will divide one by ten we get remainder as one and quotient as zero because one is not divisible by ten so one will be our remainder and quotient will be zero so now last digit will become one this and here here how we can append this last digit to four three two is four three two into ten it will give us four three two zero we will do plus one we get four three two one so this is our last digit so by these two operations the reverse will become four three two one and now we'll simply assign number divided by 10 value to number so here you can see when one got divided by 10 the quotient was zero which is the result of our division so zero will be assigned to the number so number became zero so now here you can see this while loop will terminate because number is equal to zero and not greater than zero so this value will terminate and here is the important step that why we are providing this condition is because we have used up all the digits of our original number and we have reversed it so therefore this condition is very important that number should be greater than zero because when number will be equal to zero it means there is no value left in the number to be reversed and at the last we simply check whether our original number was negative or not so our original number here was negative so if it is negative then this condition will be executed we will simply multiply reverse by minus one so four three two one into minus one will give minus four three two one so minus four three two one will be returned from this reverse method and if is negative would have been false then we would have simply written the reverse so friends this is how we actually reverse an integer value there are three steps to remember first we need to evaluate whether the number is less than zero or not the second is we need to take this data type as long because when we reverse a bigger integer value there may be a chance that its reversal may overflow the integer value so if we take integer here then this reverse will only hold the garbage value which we don't want so in order to accommodate the large overflow integer value we will store it in the long because long can accommodate that value the other thing is this simple mathematics which is very important when we divide any number by any value whatever is the remainder if we want to achieve the remainder directly we can use the modulus operator which is here and if we want to access the quotient we can simply take the value of the division here and using these three steps we have actually performed the reversal of this integer so friends i hope you must have liked this video in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss a lead code problem remove element so friends before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so in this problem we are given an integer array and we are also given with a integer value now our task is to remove all the occurrences of that value from the integer array and that too in place so what do we mean by in places let's say if we take this example and this is our input array and this is the value given to us which is 3 now our task is to remove all the occurrences of this value from this array dead to in place so it means that we have to modify the given array in such a way that we have to remove all the occurrences of this value we can't use additional data structure or an additional array for this removal whatever operation we need to do we have to perform in the given array itself and in this problem after removal of all the occurrences of the value it is okay that order of the elements may change so for example in the second array when the value is 2 you can see after removing the 2 we are getting 0 1 4 0 3 now here we can also return something like 4 1 0 0 3 so the order of the elements may get changed but our task is to just remove all the occurrences of the given value and finally we have to return an integer value which is a count of the elements which are not equal to the given value so here in the first example you can see the array is 3 2 2 3 and the given value is 3 so after removing 3 we are only left with 2 2 so the output would be 2 because there are two values 1 and 2 similarly here let's say we are given with this array and the value is 2 so after removal of all the occurrences of 2 we get 1 2 3 4 5 so our output should be 5 now here we have to do two tasks first is we need to return the count of the values which are not equal to well so which is our k and the second task is we have to actually perform this removal in place in the given array so we have to remove all occurrences of well in array and det2 in place so we have to perform this two tasks now if we look into the problem this is the problem on lead code we have to do this two tasks so whatever the array is given to us we have to modify the same array and we have to return the total number of elements which are not equal to this value so for example in the first task case if the well is 3 and the array is 3 2 2 3 so we know that after removing 3 the number of elements which are not equal to well is 2 1 and 2 so here if i directly return let's say 2 so this task should get passed but if i run the code so here you can see that we have returned 2 which is our output but we haven't modified the array in place so the lead code editor will also check our the given array that we have removed all the occurrences of the given value from the given array now let's see how we can approach the solution of this problem so for example let's suppose we are given with this array 0 1 2 2 3 0 4 2 our task is to remove all occurrences of 2 the output should be 5 because the total number of elements which are not equal to 2 are 5 1 2 3 4 5 and the remaining element is shown blank because the task case doesn't look beyond our output which is 5 so here how we can approach this problem is we can use two pointers let's say i and j so let's suppose if this is our array and we have to remove all the occurrences of 2 so this is our well now here two pointers will move throughout this array in such a way that one is slow pointer and another is fast pointer so let's say they both start at 0 the index and here let's suppose j is our fast pointer and i is slow pointer so j will travel each and every element throughout this array so it's just for iteration and here i will move slowly and its main purpose is to actually remove all the occurrences of the given value so once it removes the occurrences of the given value it will then move ahead slowly so here it helps to remove the element so here what do we do is as j is iterating our complete array we simply compare the value at jth index with the value we want to remove and i is actually helping us to remove that value so here if the value at jth index is not equal to 2 it means we have found an element which we need to keep in the array so we simply take that value and assign it to the ith index and then we actually increment i so let's see why an example so currently the value at jth index is 0 it is not equal to 2 so 0 is not equal to 2 so it means that we have found a value which we need to keep in this array and we know that i will help us in keeping that value in the array so at the start we will assign 0 to the ith index so this value stays here and we increment i to the next index so i comes here and j is actually traversing the array so it will also get incremented now we again check that value at jth index 1 whether it is equal to 2 or not so 1 is not equal to 2 so we assign the 1 to ith index it means the same value is assigned to this index and we move ahead so i moves to this index and j also moves to the second index now here the value at jth index is 2 and 2 is actually equal to 2 so here we know that we have to remove this occurrence so i will actually point to the same index because its task is to actually remove this element so when the value at jth index is equal to our value which we want to remove we don't move the ith index we only move the jth index because i is actually helping us to remove this value so here i stays at the same place and j moves so j comes here now again here the value at jth index is 2 and 2 is equal to 2 and we have to remove this occurrence via taking help of ith pointer so here i stays at the same place and j moves so j comes to the fourth index now value at jth index is 3 and 3 is not equal to 2 so it means we have to move this value here so that this occurrence can be removed so when we move 3 here it would look something like this the 2 is gone and 3 comes here and after the assignment i will move to its next index because its task is to remove all the occurrences of the given value and j usually moves ahead so it goes to fifth index now here the jth index value is 0 and 0 is not equal to 2 so therefore we will assign this value at the ith index like this and here now value will become 0 and now both the pointers will move ahead now here value at jth index is 4 so here 4 is not equal to 2 so therefore we will assign this value at the ith index so it would look something like this so 3 will be gone and here it will be 4 and both the pointers will move ahead so i will come here and j will come here so now the value at jth index is 2 and 2 is equal to 2 so we do nothing here we simply increment j so now j is traversed complete array and here you can see the ith index will be our answer because this is the last place where we need to remove an element but we didn't find any more elements so after removal of 2 our output came out to be 5 so if we put the index at 0 1 2 3 4 and 5 so this 5 is nothing but a value which is pointed by the ith index and this would be our answer because till this point all the occurrences have been removed and after that there were no more elements to be removed so therefore we have achieved two tasks one is we are returning the output as 5 and another is we have modified the array in place and we have removed all the occurrences of 2 so in this problem the basic ideas we are using these two pointers i and j the purpose of j is to simply traverse the array compare the value at jth index with the value we want to remove and the purpose of i is to actually remove the element via assignment when we actually find a value at jth index not equal to the value which we want to remove now let's move ahead and see the demonstration of this algorithm step by step so friends before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here this is the code and let's say we are given with this array which we discussed in our previous slide we are calling remove element method passing in this array and the value is 2 for which we want to remove all the occurrences in this array so we have num's array and the val as 2 now we are creating these two pointers i and j so here i starts from 0 and as we know that the purpose of j is to simply traverse the array and compare the value at jth index with the actual value we want to remove so we are using a simple for loop here so j starts from 0 so at the start j is 0 and num's dot length is 8 because we have 8 elements 1 2 3 4 5 6 7 8 and 0 is less than 8 so this for loop will execute and as we already discussed we have to simply provide one if check that whether value at jth index whether it is equal to val or not so currently value at jth index is 0 and 0 is not equal to 2 so therefore this condition comes out to be true it means that we have found a value which is not equal to 2 and which we need to keep in the array so the way we keep in the array is via ith pointer so we simply assign num's of j to num's of i so num's of j is 0 is assigned to num's of i which is at zeroth index so this value assigned to the same index like this and the actual purpose of i is to actually remove the elements and keep only those elements which are not equal to 2 so after putting a value which is not equal to our given value we move i to the next index like this we will increment j j comes to index 1 and 1 is less than 8 so this for loop will execute we again compare the value at jth index with the given value so the value at jth index is 1 and 1 is not equal to 2 so therefore we have again found a value which is not equal to the value which we want to remove so the condition in iflog comes out to be true and we simply assign value at jth index to value at ith index so 1 is assigned to the same index because i and j are pointing to the same index and after putting a value which is not equal to 2 we simply increment i we increment j so value of j is 2 and 2 is less than num's dot length which is 8 so this for loop will execute we again compare the value at jth index with the given value so yet 2 is actually equal to 2 so the condition in iflog comes out to be false whenever we are encountering a value which we want to keep in the array at that time we are doing this assignment and as soon as we are finding a value at the jth index equal to the value which we want to remove we do nothing and we simply increment j so i will actually remain at this position because in the future there could be a values which we want to migrate to this index because we want to remove this 2 so let's say in future there is 3 0 4 so 3 should come here and this 2 should get removed so this i should stay at the same place so now value of j is 3 3 is less than 8 so this for loop will execute now value at jth index again is 2 and 2 is equal to 2 so therefore the condition in iflog comes out to be false and we do nothing we again increment j value of j becomes 4 4 is less than 8 so this for loop will execute now the value at jth index is 3 so here 3 is not equal to 2 so it means we have found a value which is not equal to the given value and we need to keep this value in the array and this index is not the right place for the value 3 so therefore this i will actually help us in shifting of this 3 from here to here via this assignment so the condition iflog comes out to be true we assign the value at jth index which is 3 to ith index so now this 2 will go away and this 3 will come here like this and after placing 3 at its correct spot now it's time to move i to the next index because in the future there could be more values which can come here so we simply increment i value of i becomes 3 we increment j j becomes 5 5 is less than 8 so this for loop will execute now value at jth index is 0 and 0 is not equal to 2 so this condition comes out to be true so it means we have to shift this 0 to its correct position which is being denoted by i so here we simply assign value at jth index to value at ith index so 0 comes here with this assignment and after placing 0 at its correct spot we will simply increment i we will increment j j becomes 6 6 is less than 8 so this for loop will execute so value at jth index is 4 4 is not equal to 2 so therefore this condition comes out to be true and we simply shift this value 4 at index i so 4 comes here via this assignment and then we simply increment i because we have placed 4 at its correct spot we increment j j becomes 7 7 is less than 8 so this for loop will execute so now here value at jth index is 2 2 is actually equal to 2 so therefore the condition in a block comes out to be false so we do nothing and we simply increment j so value of j becomes 8 and 8 is not less than 8 so therefore this for loop will terminate and at the end we'll simply return the value which is being hold by i which is 5 because this was the last place where we couldn't remove the occurrence and before that we have removed all the occurrence and as the array starts from zeroth index we have to return a value which is the total number of elements which are not equal to our given value so here we had 0 1 3 0 4 which were not equal to 2 and if we count them we have 1 2 3 4 5 so whatever value i holds that will be our answer so we simply return 5 and we have also modified the array in place by removing all the occurrences of our given value which is 2 so friend this was all about the remove element problem i hope you must have liked this video thanks have a nice day hello everyone so in this video we are going to discuss a lead code problem remove duplicates from sorted array so friends before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so in this problem we are given with an integer array and the array is sorted in nondecreasing order so as a input we are given with an integer array and the integer array is sorted in ascending order now as the array is sorted in ascending order there may be duplicates now our task is to remove the duplicates and that too in place so by in place we mean that we cannot use additional array or any other data structure we have to modify the same array and we have to remove the duplicate such that each element appears only once so for example let's say we have this input array 1 1 2 so the array is sorted and here we have one duplicate which is 1 so we have to remove this duplicate such that only one occurrence of an element occurs such that the element appears only once so after removal of the duplicates we get two numbers 1 and 2 and this one is removed so our output is 2 and the array is modified like this 1 2 and whatever elements are left over those are ignored and one more thing we need to keep in mind is the relative order of the element should be kept the same so we have to modify the input array in such a way that let's say we have 1 1 and 2 so at the start there should be 1 and after that 2 should come it should not be like this 2 comma 1 because we have to maintain the relative order of the elements so let's say if you are taking the second example now if we remove the duplicates from this sorted array so here we have 2 0 so 1 is removed because the element should appear only once after 0 if we see the relative order the next number is 1 and we have 3 1s so we have to remove this 2 1s and we need to keep only one occurrence of 1 and after that we have 2 2s so we have to remove 1 2 and we have to keep only 1 2 then we have 2 3s so we have to remove 1 3 and at the end we have 4 so 4 is itself unique so after the removal of duplicates if we count the unique elements so we get 1 2 3 4 and 5 elements so our output is 5 and we have to modify the array in place so at the start 0 comes then 1 comes then 2 then 3 and then 4 so the relative order is maintained and the rest of the elements are just ignored so let's move ahead and see how we can solve this problem so suppose we are given with this array 0 0 1 1 1 2 2 3 3 4 now our task is to remove the duplicates and keep only one occurrences of the element so let's say our array is 0 0 1 1 1 2 2 3 3 4 so your first property is the array is sorted in ascending order so it means whatever duplicates we have they are very adjacent to each other so second property is duplicates are adjacent to each other now how we will solve this problem is we will take two pointers i and j so here j will traverse each and every element of this array so therefore it's a fast pointer and i will move slowly so it's a slow pointer now the purpose of j is to basically iterate the array and compare the duplicates and the purpose of i is to actually remove the duplicates so as soon as i removes the duplicates from this array it will move slowly one step at a time and j will simply traverse the array once so here both the pointers will start from first index i and j so i start from first index because the 0th index already contains a unique element and the next unique element should come here so i starts from here and its main purpose is to remove the duplicates and after removal of duplicates it simply moves ahead now similarly j starts from first index because it actually compares current element with previous element so that it can figure out that these two numbers are duplicates so what it does is we simply compare value at jth index with value at j1 index so therefore we have to start from the first index so as soon as j moves ahead we simply compare the current element with its previous element to figure out whether they are duplicates or not so at the start value at jth index is 0 and j1 index is also 0 so here 0 is equal to 0 therefore this condition comes out to be false so whenever this condition comes out to be false we actually do nothing and we simply traverse j to its next index so j will come to the second index now value at jth index is 1 and j1 index is 0 so 1 is not equal to 0 so this condition comes out to be true so whenever this condition comes out to be true it means that we have found a unique element because the element just before that is different from this so whenever this condition comes out to be true it simply means that when we compare these two elements they were not equal so the current integer is actually a unique integer which we need to keep in the array so what we do is when this condition comes out to be true we simply assign value at jth index to value at ith index because the purpose of i is to actually remove the duplicates and we know that 0 is a duplicate here so we simply assign value at jth index to value at ith index so after this assignment 1 comes here after this assignment we know that the next unique element should come here so we simply traverse i ahead so i comes here and j will move to the third index so purpose of j is to simply traverse the array one element at a time and compare the current integer with its previous integer so now value at jth index is 1 and value at j1th index is also 1 so they are equal so this condition comes out to be false and we know that once this condition comes out to be false we do nothing and we move simply j one step ahead because we didn't find any other unique element so that we can replace it with ith index we simply move j one step ahead now again value at jth index is 1 and value at j1th index is also 1 so it means this condition comes out to be false and we do nothing we simply traverse j one step ahead now here value at jth index is 2 and value at j1th index is 1 so 2 is not equal to 1 so therefore this condition comes out to be true so when this condition comes out to be true we know that we have found a unique element which we need to keep in the array and we know that we are using this ith pointer to simply put this value in the array so once this condition comes out to be true we perform this step so value at jth index we simply assign it to value at ith index so this two comes here and this one which is duplicate gets removed so two comes here and after this assignment we do i++ because the next unique element will come here so i comes here and j traverse ahead now value at jth index is 2 and value at j1th index is also 2 so this condition comes out to be false so therefore we do nothing and we simply traverse j ahead now here value at jth index is 3 and value at j1th index is 2 so 3 is not equal to 2 it means we have found one more element which is unique and which we need to keep in the array once this condition comes out to be true the correct place for this three is we simply assign the value at jth index to value at ith index so this three comes here so this one goes away and three comes here and after this assignment we simply increment i because the next unique element should come here so i moves here and j moves here now the value at jth index is 3 and j1th index is also 3 so therefore this condition comes out to be false so we do nothing we simply traverse j to the next index j comes here now value at jth index is 4 and value at j1th index is 3 so 4 is not equal to 3 so this condition comes out to be true it means we have found one more unique element which we need to keep in the array so we simply assign this value to nums of i so this four will come here and this one will go away and after this assignment we move i one step ahead and j also one step ahead so now j is actually traversed till the end of the array and we know that we have removed all the duplicates till this point and if we count the number of elements we have one two three four five so our output would be five and here as this is an array so this is zero index first second third fourth and this is fifth so we simply return the value which is stored in i which is five and rest of the elements can be ignored so this array can be ignored our task was to remove all the duplicates such that each element appears only once so now let's move ahead and see the demonstration of this algorithm step by step so friends before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here this is the code and let's say we are given with this array which is sorted in ascending order and our task is to remove the duplicates now as the array is sorted the duplicates will be adjacent to each other so when we call this method the first thing we do is we create these two pointers i and j where j is our fast pointer it traverses the array from index one to index seven and i will start from one because this zero is already at its correct place and unique so we don't touch the zeroth index and we start from the first index so we start j also from the index one and why we are starting from j equal to one is we simply compare the current and the previous element so we start from index one and j will travel till num.length so num.length is eight so one is less than eight so this condition comes out to be true and the for loop will execute now in the for loop what we do is we simply compare the two adjacent values which is the value of jth index and the value of j minus oneth index and we check whether they are duplicates or not so currently value of jth index is zero and j minus oneth index is also zero so therefore this condition comes out to be false because both the values are equal so when both the values are equal it means we have found a duplicate and we do nothing we simply increment j j becomes two two is less than eight so the for loop will execute value of j minus oneth index is zero and value of jth index is one so zero is not equal to one so this condition comes out to be true it means we have found one unique element which we need to keep in the array because the adjacent elements are different it means this value is the first integer which is unique so we need to keep this value in the array so the if block will execute and we know that index i will actually help us in placing this value at its proper position so we simply assign nums of j to nums of i so one comes here and we know that next unique element should come here so we simply increment i so i becomes two we increment j so j becomes three three is less than eight we compare these two values now and one is not equal to two so therefore this condition comes out to be true it means we have found one more element which is two which is unique in this array and which we need to actually keep in the array so the condition in if block comes out to be true and we assign this value to nums of i because i is actually holding that place where we can only insert a unique element so via this assignment two comes here and next unique element should come here so we simply increment i i becomes three we increment j j becomes four four is less than eight so this for loop will execute so now we are comparing these two values so condition in if block comes out to be false and we do nothing we increment j j becomes five five is less than eight so the for loop will execute and now we are comparing these two elements so the condition in if block comes out to be false we simply increment j j becomes six and six is less than eight so this for loop will execute and now we are comparing these two elements so two is not equal to four so this condition comes out to be true and we have found one more element which is four which is unique and which we need to keep in the array so the if block will execute and how we will keep this value four in the arrays we simply assign value at j's index to value at i's index so this four will come here and we know that the next unique element should come here so we simply increment i i becomes four we simply increment j j becomes seven seven is less than eight so this for loop will execute now we'll compare these two elements so here both the elements are equal it means we haven't found any unique element so the condition in if block comes out to be false we increment j so j becomes eight and eight is not less than eight it means we have traversed all the elements of this array so this for loop will terminate and here you can see whatever the value i is holding that will be our answer so if we count the unique elements we have one two three four and here we can see as the array starts from zeroth index so whatever the value i is holding which is four will give the total number of elements which are unique in this array which is four so we simply return four from this method but that is our answer and we have also modified the array in place so friend this was all about remove duplicates from sorted array i hope you must have liked this video thanks have a nice day hello everyone so in this video we are going to discuss a very famous interview problem which is threesome problem so in this problem we are given an array of distinct integers now our task is to print all such triplets such that they add up to a specific target and the triplet should be ordered in ascending order so let's say we are given an array of integers now these are actually distinct integers two four three seven one eight nine zero we need to print all such triplets such that they add up to a specific target so we have been provided with the array and a target value the triplet should be ordered in ascending order so we need to find three numbers such a way that when we add them we get a target of six and that two number should mean ascending order so for example zero plus two plus four will give six and here zero two and four are in ascending order one plus two plus three will also give us six one two three are in ascending order so we need to find all such triplets with sum of two a specific target and they are ordered in ascending order so let's see the demonstration of this algorithm step by step so here this is the algorithm where method name is threesome we are given an array and a target let's say we are given with an array having six elements two four three seven one zero and a target let's say six so when we call threesome method we pass the array and the target as six so friends basic idea behind this algorithm is first we sort the array second we use three pointers so when we sort the array we can print the triplets in ascending order so that is one of the use case and the second use case is when we sort the array we can use three pointers which can provide us three numbers which add up to a specific target and that too with a optimized time complexity so here the three pointers we use are i, j and k which we will be seeing later here so these three pointers will give us three different numbers from the array we will take up their sum and print it on the console if sum is equal to target so let's see the demonstration of this algorithm step by step so in the first step we are actually sorting the array in ascending order so two four three seven one zero will be sorted and it will become zero one two three four seven moving ahead now as we discussed that we will be using three pointers i, j and k so for i it will start from zero and it will go to array.length minus two so we will see why we are taking minus two later but it will start from zero and it will go to index three which is array.length six minus two four so here less than means that it will go till three we will see later that why we are taking array.length minus two so currently i will start from zero it means it will be pointing to the zeroth index of the array now as we need to find the three numbers which are distinct so the j pointer will start from i plus one so here whenever this for loop will start with any value of i j will start from a value just ahead of it so value of j will start from one and we will take the k pointer we will start it from array.length minus one it means the third pointer will start from the the last index which is array.length six minus one which is five so k will start from five we will see its significance that why we are starting it from array.length minus one moving ahead so friends as we have now pointed i, j and k to three different indexes we will try to find out the sum of these three numbers and then we will figure out whether they are equal to the target or not so this for loop will actually help us in traversing i and this while loop will help us in traversing j and k so as we want to find the three distinct numbers we have provided a while loop and the condition is j should be less than k so here j and k will traverse through this array j will traverse in this direction and k will traverse in this direction covering up the elements so this while loop will go till j is less than k because if j will be equal to k both j and k will point to the same number which we don't want so j should be less than k in the first step what we are doing is we are calculating the sum of array ith index at jth index and at the kth index because we need to find out the triplets so i j and k will provide us that triplet so when we do sum of 0 1 and 7 we get 8 so sum will become 8 now we simply check whether sum is actually equal to our target or not so our target is 6 and sum we want is 8 so this condition comes out to be false so here as i is fixed at 0th index we have sorted the array in ascending order it means whatever value will come after 1 will be greater than 1 and whatever value will come before 7 will be lesser than 7 because the array is sorted now when we compared sum with target we found out that sum is actually greater than target sum value is 8 and it is greater than target so somehow we need to reduce the value of sum in the next iteration so that it matches the target so what we do is we provide these two conditions we check whether sum if it is not equal to target we check whether it is less than target or it is greater than target so currently if sum is greater than target it means we need to reduce the sum so here array is sorted i is fixed the only option we have is to move j this direction or k this direction if we move i this direction in the next iteration when we will do sum the sum will become 0 plus 2 plus 7 which will give us 9 which is actually more than the current sum and which we don't want so let's say if we move k this direction so k will come here and if we do sum in the next iteration we will get 0 plus 1 plus 4 which will be equal to 5 which is actually reducing the sum to get it more closer to 6 so here as the array is sorted when sum is greater than the target we actually move k to this direction so that in the next iteration the sum will become closer to 6 which is our target and if sum is less than target then we move j to this direction because that will only increase the sum and then it will match our target so currently sum is greater than target so this condition also comes out to be false so the only option we have is when sum is greater than target we move k to this direction because in the next iteration it will help us in minimizing this sum so here the condition is if sum is greater than target move k left if sum is less than target move j to right so currently sum is greater than target so we will move k left so k will become 4 we are simply moving it one position here j is still less than k so this condition comes out to be true we will evaluate sum again 0 plus 1 plus 4 will give sum as 5 so sum will become 5 we compare whether sum is equal to target or not so sum is not equal to target so this condition comes out to be false and as the condition has come out to be false we provide these two conditions we check whether sum is less than target or sum is greater than target if sum is less than target then we move j to right because if we move j to right we will get a value higher than the current value of array at jth index and when we will do sum in the next iteration we will get 0 plus 2 plus 4 which will be equal to 6 so here when we need to reduce the sum we move k to this direction when we need to increase the sum so that it matches the target we move j to this direction so currently sum is less than target we need to increase the sum so we do j plus plus j becomes 2 so j comes here j is less than k now we will again evaluate the sum so 0 plus 2 plus 4 will give sum as 6 so sum will become 6 so here you can see when we provide this condition that whether sum is equal to target or not so this condition comes out to be true it means we have found one of the triplet which is 0 2 and 4 whose sum is equal to the target so we are simply printing the value at ith index jth index and kth index on the console so it will print 0 2 4 0 2 4 and as i is fixed j value is used up k value is used up so here what we do is we increment j and we decrement k because 0 2 4 is already being found if we only increment j it will come to this position so 0 plus 3 plus 4 will never give us a sum of 6 because 0 2 4 is already given as the sum of 6 and as these are the distinct integers here value cannot be 2 it can be only greater than 2 so therefore if we increment j we also decrement k because we will never find any such pair if it would have been duplicated values and here would have been 2 then we have incremented only j so we would have found another triplet 0 2 and 4 but here as these are the distinct integers therefore when we increment j we will never find any such other triplet whose sum will be equal to target so 0 plus 3 plus 4 will give us sum as 7 so therefore to keep k at this position is also useless so we decrement k also so first we will increment j j becomes 3 and then we decrement k now here you can see j is actually equal to k so therefore this file loop will terminate because we need to find a triplet which is unique so j and k cannot be pointing to the same number and bringing up the sum so this file loop will terminate so the call will reach here now we will simply increment i by one position by i plus plus so i will become 1 now we have seen all such pairs which can form a triplet with a value 0 and we have used up index 0 so when we will start i from 1 we will not go behind the value of i because that we have already seen so the new j value will be i plus 1 which is 2 and k we will take as array dot length minus 1 which is the last index j is less than k we will take some of these three values value of ith index jth index and kth index we will do their sum so 1 plus 2 will give 3 plus 7 will give 10 so sum will become 10 it is not equal to target sum is not less than target so this condition also will come out to be false sum is greater than target and array sorted so if we move k to left we will get a smaller number so that in the next iteration this sum will be reduced and can match to the target because currently sum is greater than target we need to reduce this sum currently the value is 7 which is being used up in forming the sum if we shift k this side we will get a lesser value so in the next iteration our sum will be more closer to target so therefore we are decrementing k so k becomes 4 j is less than k we again do the sum so 1 plus 2 will give 3 3 plus 4 will give 7 so sum will become 7 so here you can see why we moved k to this direction is in this iteration we actually reduce the sum from 10 to 7 sum is still not equal to target sum is not less than target so we need to reduce sum further down so we simply do k minus minus so k will become 3 j is less than k j value is 2 and k value is 3 so j is less than k now we will do sum of these three values 1 plus 2 plus 3 which will give us sum as 6 so sum is equal to target it means we have found one more triplet so we will print it on the console 1 2 3 1 2 3 and then we simply increment j and decrement k so j will become 3 and k will become 2 like this now this while loop will terminate because j is actually greater than k we will increment i again i will become 2 we have used up these elements so jth pointer will become i plus 1 which will start from third index and k will start from the last index j is less than k we will take the sum of these three indices at their respective array positions 2 plus 3 plus 7 will give sum as 12 sum is not equal to target sum is not less than target it is actually greater than target so we need to reduce the sum and when we reduce the sum we simply decrement k k will become 4 j is less than k the new sum will be 2 plus 3 5 plus 4 will give 9 so sum has reduced but still it is greater than target so sum is not equal to target sum is not less than target it is actually greater than target so we again decrement k so k will become 3 so here you can see j and k are now pointing to the third index so therefore this while loop will terminate because j is actually equal to k because we need to find triplets which are unique so all this pointer should point to a different values of the array we will increment i i becomes 3 we have used this position so here you can see if we calculate array dot length we will get 6 if we do minus 2 we will get 4 so i is still less than 4 because it is pointing to third index and here you can see that why we have provided this condition is because we need to give space for the other two pointers as well one can occupy this position other can occupy this position if i would have traveled all the way across the array say for example if i would have reached here so j would have started from here and k would have also started from here which we don't want because we want j should be less than k so at least we need to give space for two elements so therefore we are taking it as i should be less than array dot length minus 2 we are doing minus 2 because one slot will be taken by j and other slot can be taken up by k properly so this condition is still true that i is less than array dot length minus 2 so j will start from fourth index k will start from the last index j is less than k we will do the sum 3 plus 4 plus 7 will give 14 sum is not equal to target sum is not less than target if we want to reduce the sum we have to decrement k to reach here so k will become 4 and as we have decremented k j and k are pointing to the same index so therefore this while loop will terminate and again when we will increment i i will become 4 so 4 is not less than array dot length minus 2 6 minus 2 is array dot length minus 2 which is 4 4 is not less than 4 so therefore this for loop will terminate and once this for loop will terminate our method will also get terminated and whatever we have got as a triplet we have printed on the console which is 0 2 4 1 2 3 which are the three numbers which add up to a target of 6 and they are in ascending order so friend this was all about the threesome problem where we use the technique of sorting and three pointers to figure out which are those triplets which add up to a target i hope you must have liked this video in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss a problem product of array except self so let's see what this problem is and how to solve this so in this problem we are given an array of integers we need to return an array result such that value at index i is actually equal to the product of all elements of array except the element at index i so in the result array let's say any index i we need to store the product of all the elements of the given array leaving the element at that respective index so when we are doing the product the values are given in such a way that product fits in the 32 bit integer one constraint is the algorithm should run in o of n time and without using the division operator so let's understand the problem with an example let's say we are given an array having four elements one two three four now in the result array we need to store the product of all the elements of array in such a way that let's say if we are on index one so this is zero index this is one this is two and this is three so let's set index one we have value two so in the result array we need to store at index one product of all the numbers in this array excluding two so for example at index zero we have one so we can directly do the product of rest of the elements two into three six six into four is 24 so we can directly place 24 here we haven't included one into the product now for index one at index one we are storing the product of rest of the elements excluding two so one into three is three three into four is twelve so we are storing 12 here for index two we will exclude three we will take the product of rest of the element which is four into two eight eight into one eight so we are storing eight here for the last index we will exclude four and we will take the product of rest of the elements one into two is two two into three six so we are storing six here so in this problem in the result array at any particular index let's say this index we are storing the product of rest of the elements excluding the element at that particular index so friends we don't have to use the division operator or as the problem would have been very simple we could have multiplied all the numbers so for example if we take the product of all the numbers we will get 24 now let's say if we want to fill for the index one excluding two so we would have directly divided it by two it would have given two element we would have placed 12 here so we don't have to use the division operator and secondly we need to solve this problem in o of n time so here you can see if we use two for loops the nested for loops the time complexity will be o of n square so the first for loop will traverse the element one by one and the inner for loop will travel rest of the elements take their product and store it at the respective index of the outer for loop iterator so the time complexity would have been o of n square so we need to solve this problem in o of n time so now let's see the algorithm and the demonstration of that algorithm step by step so friends before we start in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update now here we will call find product method we will pass this array having four elements one two three four so friends how we will solve this problem in o of n time is we will traverse this array two times one in this direction and other in this direction and let's say this is our result array so when we will traverse in this direction let's say if we take the example of index two this element now at this index we need to exclude three and store the product of rest of the elements but here you can see at index two we are doing the product of these two elements which is on the left side and all the elements on the right side and excluding three so when we will traverse the array from the left side in the result array we will store the product of the left part of the array and when we will traverse from the right side we will include the elements of the right part of this index so when we will traverse on the left we will do the product of the left part store it here and when we will traverse on the right side we will take this value whatever value is stored here we will do the product and we will place it here so in the left part we are doing one into two we will place two here and when we are traveling from the right we will take the value four multiplied with two and store it here so this we will do for all the elements at the respective indexes and finally we will get the result array so first we are traveling from the left direction so at the start we are creating a temporary variable assigning it the value of one we will see its significance later so temp is equal to one we will create the result array like this and as total length of array is four we will initialize the result array with array.length which is four now we will start the for loop from index zero and go till the end of the array so at the start i will be equal to zero which is pointing to the zero index now as we discussed when we are traveling in left direction we will store the product of the left side elements so currently for index zero there are no elements in the left side and here we have created a temporary variable assigned into value one so we will directly store one here which is the value stored in temp because there are no elements in the left part of index zero and we also know that anything multiplied by one will give the same result so therefore we are initializing temp with one so here we will get value as one moving ahead now for the next index let's say for two we need to take the product of the left part so here as we are assigning temp directly to the result at a particular index here what we are doing is we are taking the product of temp with the previous value and then we are storing it in the result array so for the next iteration we have to take product of the left part currently here we have only one element which is one so we are multiplying temp with the value stored at index i which is index zero so temp becomes one because one into one gives one you will understand more about this step when we move ahead so now we'll increment i, i becomes one now as temp is storing the product of the previous elements we will directly take the value of temp and store it in the result array at ith index so one will be stored here because value of temp is one so for the next iteration i will reach here so for index two we need the product of left side we need product of one and two so temp already has product of this part here we will multiply it with array of i which is we will multiply it with two and we will get the product of these two elements and that product we can safely store here because when we are traversing from the left side for this particular index we will only store the product of these two elements and currently as we have already stored the value of temp into result i which is one here if we multiply temp with current element we will get the overall product of these two elements so the new value of temp will be two into one which will give us two we will increment i, i becomes two and we know that temp already has the product of its two previous values which is one into two so we will first directly store one into two which is two at index two of the result array so this step does that so two comes here now when we will move to the next element we need to include three also in the product because for index three which is this index we need to take the product of these three elements we already know the product of these two elements which is stored in a temp if we multiply it with three which is the current element at index i we will get the product of three elements previous to third index so therefore we are multiplying temp with the current index value of array which is three here so three into two will give six so temp becomes six which makes sense because one into two into three will give six which we can use directly in the next iteration so we'll increment i, i becomes three so in the result array at third index we will first directly store the value of temp which is six so here you can see for third index the product of its previous values is six one into two into three six and we are storing six here and as we are traveling from the left side we are only looking in the elements which are on the left part of the particular index so as there are no more elements left this product makes no sense so temp into array of i four into six will give 24 so temp will become 24 but it is of no use because there are no elements going further so we'll increment i, i will become four and this for loop will terminate because four is not less than array.length which is four so when we traverse from the left side in this direction we store the product of the left part so now we'll again initialize temp with one so temp becomes one and now we'll traverse from the right side so here i starting from array.length which is four minus one which will give us three which means we are starting from the third index and this loop will go till i is greater than or equal to zero so friends we also discussed that let's say if we want to fill for index two we need product of these two elements and whatever the product will come which is two here we will multiply it with the right side elements which is four here so two into four will give eight and we will store eight here so in the result array we are already having the product of the left part of each index now we simply need to take the value of the right part do their product and whichever value is stored here we simply need to multiply it with that value so now that thing we will do when we are traversing from the right side so at the result array at i as index so currently we are at the third index whatever value is stored is actually stored of the product of its previous numbers and as index three has no elements to its right we will simply multiply whatever value is stored here into temp which is one and store it back into the result array so for index three at result of i we will take six which is this value we will multiply it with temp which is one which will give us six and we will assign six back to index three at the result array so it will remain six so here we are doing the same steps for index two we need product of its elements which are on its right side so temp value is one we will multiply it with four and we will get the product of its right side elements so temp becomes four we will decrement i so i will come at index two now at this index you will understand the algorithm more what we are trying to achieve is in the result array for index two we need to store the product of the elements excluding index two which is three so one into two which is on the left part excluding three and taking in remaining element which is on the right part so one into two will give two two into four which will give us eight so we need to store it here now in the result array we are already having the product of the left part which is two here we need to simply multiply this two with the product of its right part so currently it's four which is stored in the temp so result of i which is two multiplied by four which is temp so value stored at result of i multiplied by temp will give the actual product of all the elements excluding this index because temp is already having product of its numbers on the right side so two into four will give eight and we will assign eight back to the result array at index i so it will come here now we will multiply three with temp which will give us 12 and we'll assign 12 to temp so why we are doing it because in the next iteration so when we will decrement i i will come to index one now for this index we already have the product of its left element here in the result array we need the product of its right part previous value of temp was four and we multiplied it with three which gave us value as 12 so temp is currently having value 12 which is the product of all the elements on the right side so for filling the value of index one we need product of the left side which is one which we already calculated we will exclude this element and we need the product of the right side which is already stored in the temp so value at result array the ith index which is one will give product of the left part temp will give product of the right part when we will multiply them we will get one into 12 which is 12 so one into 12 which is temp will give 12 so 12 will come here and for the zeroth index we need product of the right part so temp already has product of three and four which is 12 we will multiply it with the two which is the array element at index i so temp will become 24 we will decrement i so i will come as index zero now at index zero we need to simply put the product of all the elements on the right side their product with product of the elements on the left side so left side doesn't have any value because we have value is one here we will take value one multiplied with value of temp which is 24 and we will assign it back to the result array so here it will come 24 and then we will evaluate temp again which actually is of no use because we have already filled all the positions here so the new value of temp will be temp which is 24 into array of i which is 1 which will give 24 so now we will decrement i and this for loop will terminate because value of i will become minus 1 and minus 1 is not greater than or equal to zero so this for loop will terminate and at the end we will simply return the resultant array so friends the basic idea behind solving this problem is we need to do two traversal one is from the left side and one is from the right side when we are traversing from the left side we will only see the elements which are on the left part of any particular index we will do their product and we will store that value in the result array and that will be done from the left part now when we are traversing on the right part let's say for index two when we had completed from the left part we had product of these two elements so in the result array the value would have been two because one into two will give two when we are traversing from the right side we need product of the right part so currently as there is only one element which is four we will take four multiplied with two which will give us eight and we will store it back here and this we will do for all the elements so it's very simple for any index i this is left part this is right part we are excluding the current element left into right and whatever we get value we will store back it here in the result array so we are excluding this part we are taking left part we are taking right part product we are doing their product and storing back out the respective index so friends i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss sliding window maximum problem so let's move ahead and see what this problem is and how to solve this so in this problem we are given an array of integers and we are given a sliding window of size k so it means we are given with this array and a value k which is the size of sliding window now this sliding window is moving from very left of the array to very right so this sliding window is starting from 0th index having a size of 3 and it is moving from left to right and as it is moving from left to right we can only see that many numbers so at the start we can see only 44 77 33 so it means we can only see k numbers of the array at a time and this sliding window is moving into this direction by oneone position so first we will see 44 77 33 then we will see 77 33 44 then we will see 33 44 88 and at the last we will see 44 88 and 11 so for this array with the sliding window of size 3 what we need to find is for every window which we saw so we need to find max among this three and then sliding window will move ahead so then it will see these three elements and then we have to find the maximum among these three so which is 77 again so similarly till the end we need to find the maximum in the sliding window so this is the output for this array having the sliding window of size 3 now how this output came here you can see in the first sliding window 44 77 33 the max value among this three element is 77 so for this sliding window the max is 77 then this sliding window will move ahead so 44 will go out and this 44 will come in so now among these three elements 77 33 44 77 is max so in this sliding window the max would be 77 similarly sliding window will move ahead now we have 33 44 and 88 so among these three elements 88 is max and at the end the sliding window will reach to the end of the array so among these three elements 44 88 and 11 the max is 88 now let's move ahead and see that how we can solve this problem suppose friends we are given with this array and we need to find the max in the sliding window so here in order to solve this problem there are various solutions so one such solution is is to find the next character element of each and every element in this array so the problem of next character element we already discussed in one of our previous video you can watch that video to understand more about this algorithm in this video i will be demonstrating the next character element problem as well so here actually what we do is for each and every element you see here we find its first next character element towards right so if you see for 44 if we look in this side we just see the first next character element to 44 so currently 77 is greater than 44 so it becomes the first next character element of 44 like this then we look at 77 if we look in this direction 33 is less than 77 44 is less than 77 88 is greater than 77 and it is first next character element towards right of 77 so here 88 becomes the first next character element to 77 and similarly for 33 if we look in this direction 44 and 88 both are greater than 33 but the first next greater is 44 so the answer will be 44 for 44 it will be 88 for 88 here we have only 11 so therefore there is no element in the right of 88 which is greater than 88 so in our previous video we discussed that we simply return minus 1 because there are no elements greater than 88 towards its right and similarly with 11 as it is the last element there are no elements after that so for 11 also our answer becomes minus 1 so in that video this was our output and our answer so we will use the same algorithm here but there will be a slight difference so here you can see below i have written the next character element of each and every value of this array so in our previous video in the next character element array we actually return this as our output but now instead of this as our output first we will evaluate the indexes of this elements and we actually store the indexes in the next character element array so for example for 77 if you see as index 1 so instead of storing 77 we will store 1 like this so these are the indexes of this next greater elements so for example for 77 our answer was 88 so if you see 88 is as index 4 so we are storing 4 here i'll remove this here if you see for 33 its next greater is 44 which lies at index 3 so we are storing index 3 for 44 the next letter is 88 which lies at index 4 so we are storing 4 here and for 88 there is no greater element towards its right so therefore as we are storing indexes here if you see the last index is fifth index so we are storing a greater value to 5 which signifies that we have gone out of the boundaries of this array so we are simply storing 6 so this 6 is nothing but array dot length which signifies that for 88 there was no greater element towards its right and for 11 as well so we are storing 6 6 and the value we are taking as minus 1 and minus 1 here we need to store an index which is out of the boundaries of this array so that we can justify that for 88 there is no greater element towards its right and for 11 there is no greater element towards its right so we are storing the indexes array dot length so here you can see if we are on at index 0 for example we see there is a value 44 now if we go to the index 0 of next greater element array we see there is a value 1 this value is only for demo purposes i have written here but actually we will be playing with this value and this value so at 0th index we have 44 and we need to find its next greater element so what we do is we simply go to this array we see there is a value 1 and we know that this is actually an index so what we do is we simply go to the original array at index 1 and whatever value here it is we simply say that this value 77 is next greater to 44 so it goes like this from here first we go here and then we go here to find the next greater now similarly if you want to find that what's the next greater to 33 we simply go to index 2 we see there is a value 3 so we go back to index 3 and we find 44 and we know that 44 is next greater to 33 so friends our problem is to find the maximum in the sliding window so how this next letter element array is helping us in finding that is let's say for example this is our sliding window here we have taken ks3 and let's say after evaluating the maximum of the sliding window the sliding window reached here and now let's say we want to find the max among these three elements and we actually know that it is 88 so here what we do is the step 1 is from where our sliding window is starting we take that element so currently it is 33 we take 33 and assume that it is the max in this sliding window and here you can see it is at index 2 but we know that 33 is not the max in this sliding window so what we do is this is our assumption in the second step what we do is we simply go to the next greater element array at index 2 and we see there is an index 3 which means that if we go to index 3 we will find an element which is greater than 33 so here what we do is if you see the window is starting from index 2 and the value of k we are taking as 3 for example so we know that this window will go till 2 plus 3 minus 1 which is still fourth index this index so we are taking three elements because value of k is 3 from index 2 to 4 so starting is 2 this is our k and if we do minus 1 we'll reach the last index so when we find 3 here we first check whether this index is in the range of this sliding window or not so here you can see 3 actually lies in the range of sliding window so this point suggests that there is an element greater than 33 and it lies in this sliding window which is 44 so therefore this 33 which was our assumption is wrong and now what we do is we simply go to this element 44 and assume that now it is our maximum so we reach here at the 44 but still we are not sure that 44 is max or not so what we do is we simply go to the index 3 which is of 44 in the next greater element array here we find our value as 4 which is the index 4 and we also see that 4 is actually in the boundaries of this sliding window which suggests that at index 4 there is a next greater element to 44 and this element is also in the range of this sliding window so our assumption that 44 was max is also wrong so now what we do is we simply now go to 88 here and we assume that now 88 is our max but now what we do is we simply go to the index 4 here and we see we have value as 6 and then what we do is we take this 6 and before going to the sixth index which is out of this array what we first check is whether this 6 is in the boundaries of this sliding window or not so the maximum range of this sliding window is 4 and we know that the next greater element to 88 is at index 6 which is out of the boundaries of this sliding window it means let's say at index 6 here we have one element 100 like this so here for 88 we know that if we go to the index 6 we will find 100 but this 100 is not lying in this sliding window and we need to find the maximum in the sliding window so we know that for 88 its next greater is 100 but it is lying at index 6 it is not in this sliding window so it means we are 100 sure that 88 is max in this sliding window so therefore we use this algorithm and we can come to know that 88 is max in this sliding window so this approach we do for every sliding window like this and what we do is we take the first element we assume it's the max in this sliding window but to confirm that we take this index we go to the next greater array at index 2 we pick the index of the next greater to 33 which is this index and the element is 44 and as the index is 3 we check whether this index 3 is actually in the range of the sliding window here it is from 2 to 4 and 3 actually lies between 2 to 4 so therefore we know that 33 cannot be our max in this sliding window because there is one more element in this sliding window which is greater than 33 which is 44 and similarly with 44 we found that its next greater is 88 and this 88 is also lying in this sliding window range so then we came to 88 and for 88 we found that its next greater is index 6 here index is out of the range of this array but let's suppose even if the index is had any value let's say 100 but we know that we have to find the max in this sliding window and the next greater to 88 is 100 which is out of this window so therefore our answer would be 88 for this window so friends here is the importance that why we are actually storing the indexes instead of actual values because this window of size k is actually dealing with the indexes and we need to find the index of the elements next greater so therefore instead of storing the actual values in this array which we also saw in the previous video we are actually storing the indexes now the algorithm is very much similar but the only difference is instead of these numbers of next greater we are actually storing their indexes so let's move ahead and see the demonstration of the algorithm step by step so friends before we start in case if you want to master algorithms and data structures you can subscribe to my channel and click the bell icon so that you never miss any update so here we will call the max sliding window method by passing in the array so this is our array and the sliding window size is 3 so value of k is 3 so here the return type of this method is list because we need to return the max of sliding windows among this array which we will store and we will return so here at step one what we are doing is we are simply calling next greater element method we are passing in the array so this algorithm we have already discussed in our previous video i will also demonstrate one more time because the only difference is we are storing the indexes in this array not the actual values so when this method will be called this is our array so at step one we will create the result array now this result array will store the next greater elements so now as we need to find the next greater elements of this array what we do is we take the help of stack so first we create a stack so stack is leafo data structure which means the element inserted last will be the first to be removed so we will use this property and we will figure out the next greater element of all these elements so now we will provide a for loop where this i will start from the last index which is array dot length minus one and i will go till it is equal to zero it means it will travel in this direction and it will reach till index zero and i will help us in placing the next character element of each and every index so we are starting from the last index because it will make our job easy to find the next character element towards right so first we are actually finding the next greater element of 11 so as 11 is the last index and we know that there is no next greater element to 11 so here we are providing this if block we will discuss this later which says that we first check whether stack is empty or not so currently stack is empty it means this condition comes out to be false and actually this stack will hold the next letter elements in the stack for the remaining array so as 11 is the last element we know that stack must be empty because there are no greater elements towards its right so we first check whether stack is empty or not so if stack is empty we simply put array dot length into the result of i why we are putting array dot length is because array dot length is six and six suggests an index which is not in this array which also suggests that for 11 there is no next greater elements towards its right and we will also see that how this index will help us in later in the algorithm when we will find the max in the sliding window so after the if else block now this 11 can be a next greater element for the remaining array so for example instead of 88 let's say if the value would have been 9 so for 9 11 would be the next letter element because 9 is less than 11 and 11 is the only element towards its right which is greater than 9 so therefore we will push index 5 it means we are pushing 11 on the stack like this so i will also write the values beside the index we are actually storing the index in the stack because we need to get a result in the form of indexes and you can assume that we are actually storing the values like 11 moving ahead we will decrement i now stack is not empty so the first thing we do is we provide a while loop now inside this while loop what we are doing we are first checking whether stack is empty or not so stack is not empty so this much condition is true this condition is very important here what we are doing is we are first taking stack dot peak value so if you see stack dot peak is five and if i do array of five and then i do whether it is less than equal to array of four it means we are comparing whether 11 is less than equal to 88 or not so this condition comes out to be true so the while loop will execute and what it will do is this 88 will simply pop 11 out of the stack because we had placed 11 in the stack thinking that there could be a lesser value here for which 11 could become the next greater element but as soon as we figured 88 this 88 will discard this 11 because for the remaining array even if we have any value here its next greater element will reach till 88 and it won't go beyond because 88 is already greater than 11 and 11 cannot be the next element of any of the element in the remaining array let's say if we had 9 here for example so for 9 also the next greater would become 88 let's say if we had 10 here so for 10 also it would be 88 and let's say if we had 11 so for 11 also it would be 88 but there would be no such value here for which 11 can become the next greater element because we have found one element which is already greater than 11 so therefore the job of a greater value here is to remove the smaller values out of the stack because now they won't contribute in the next greater element so first we pop 5 out of the stack so now stack becomes empty so this while loop will terminate we check whether stack is empty or not and we know that if stack is empty it means for this value 88 we didn't find any element which is greater than 88 because stack is empty 88 will pop out the smaller elements and will stop till there are elements which are greater than 88 and those elements will lie for sure in the stack but if stack is empty after this while loop then for 88 there is no greater element towards its right so we simply put array.length which we had placed for 11 which suggests that for 88 also there are no greater element towards its right moving ahead so now 88 can become the next greater element for remaining array till here so we'll push the index of 88 here which is 4 which corresponds to 88 will decrement i, i comes at index 3 and now we are figuring out the next greater element to 44, stack is not empty so this condition comes out to be true in the while loop stack is not empty and first we will take the stack.p which is 4 so array of 4 will compare whether it is less than equal to array of i which is 3 so here we are simply comparing whether 88 is less than equal to 44 or not so this condition comes out to be false which suggests that 44 cannot pop 88 out of the stack because 44 is less than 88 and we can't pop 88 out of the stack because 88 can become the next greater element of the remaining array so here for example for 77 its next greater is 88 only so therefore if a value is smaller it cannot pop this element out of the stack and if value is greater it can pop the element out of the stack so this condition we need to keep in mind so 44 cannot pop this element out of the stack because this condition came out to be false and now we simply check whether stack is empty or not so stack is not empty so the else part will be executed as stack is not empty which suggests that there would be some element in the stack which is greater than 44 because 44 could not pop that element out of the stack and that element will be for sure greater than 44 so at the result of i we store stack.p which is the index or indirectly we are storing 88 so we are storing index here 4 and then we will put value of i which is 3 on the stack like this because this 44 can become the next greater element for the remaining array so for example for 33 88 is also next greater element 44 is also next greater element but 44 is the first next greater element to 33 therefore we can't discard 44 we have to put it on the stack like this we'll decrement i, i comes to index 2, stack is not empty in the while loop stack is not empty and if we do stack.p we will get 3 so array of 3 we are checking whether it is less than equal to array of i which is 2 so we are simply checking whether 44 is less than equal to 33 or not so this condition comes out to be false which makes sense because 33 cannot pop 44 out of the stack because 44 is next greater to 33 and which is at the peak of the stack so therefore this while loop will terminate stack is not empty so this condition comes out to be false in the else part whatever is at the peak that will become the next greater to 33 so here we are storing stack.p which is 3 which suggests that we are storing a value 3 which is the third index value which is 44 this and then we will push 2 on the stack like this so let's say we had 11 here so for 11 33 would have become the next greater element so therefore we can't discard 33 we have to push it on the stack so 2 comes here which is the index of 33 we'll decrement i, stack is not empty so for now here one critical step comes stack is not empty in the while loop we are checking array of 2 whether it is less than array of 1 or not so we are checking whether 33 is less than 77 or not which is true and we have already discussed here that if we find any value which is greater than the peak value of the stack this value will simply pop the element out of the stack because if we see the remaining elements in this direction let's say if we add more elements here 33 cannot become the next greater element for the remaining array because for the remaining array 77 can become the probable next greater element but 33 cannot because 33 is less than 77 and we need to find the next greater element so let's say if we add 2 here or let's say 33 here so for 33 also the next greater would become 77 and for no value here 33 can become the next greater because so for example if we add 87 so for 87 the next greater if it is not 77 then it will be 88 but we are 100% sure it won't be 33 because 33 is already lesser than 77 so therefore this condition comes out to be true and 77 will pop 33 out of the stack because now we can safely discard this value it will play no role in finding the next greater element 2 is popped out of the stack stack is still not empty and here if you say this condition we are checking array and passing stack.peak which is 3 we are checking whether it is less than array of 1 or not it means we are now checking 44 is less than 77 or not so this condition comes out to be true it means 77 has rights to pop 44 also out of the stack because 44 also will not be contributing in the next greater element because we have found already one value which is greater than 33 and 44 so first we have popped out 33 now we are popping out 44 which is at index 3 so 3 will be popped out like this stack is still not empty so now here array of stack.peak which is 4 we are checking whether it is less than array of i so we are simply checking whether 88 is less than 77 or not so this condition comes out to be false because 77 cannot pop 88 out of the stack because 88 can become a probable next greater for the remaining elements in the array and in fact for 77 88 is the next greater element so therefore 77 will not be able to pop 88 out of the stack so this value will terminate because this condition comes out to be false stack is not empty so in the result array we are simply putting stack.peak so if stack.peak is not empty and whatever is at the top will become the next greater element for the current value which is 77 so we are storing 4 here which suggests that if you go to index 4 you will find 88 which is the next greater to 77 and similarly we'll push 1 on the stack which is we are pushing 77 on the stack like this will decrement i, i comes to 0th index, stack is not empty this condition also comes out to be false because 44 cannot pop 77 out of the stack because it is lesser than 77 so this value will terminate stack is not empty so for 44 the next greater element would be whatever the element is on the peak of the stack which is index 1 value 77 so we put stack.peak at the result array at ith index like this and we push 0 on the stack and if we decrement i it goes beyond the boundaries of this array so therefore this value will terminate because i should be greater than or equal to 0 so then we will simply return the result which is actually storing the indexes of next greater elements so this nge array will have the indexes and i have just written the values for these indexes below that so 44 is at 0th index if we go to 0th index of next greater element array you will find 1 which is the index so if we go to index 1 you will find 77 so i have written 77 directly here so that you can just relate that at 4 we have 88 like this at 3 we have 44 like this so now as we need to collect the max and sliding window we create a list by name result like this so this is a list of integers and here you can see that now we will start the for loop from i equal to 0 from here and this for loop will go till array.length minus k why it is going till it is less than equal to array.length minus k if you see array.length which is 6 if we do minus k which is 3 in our case so it will give 3 so it suggests that i will go till index 3 because now in this for loop we are actually calculating the max in the sliding window and the last window will start from when i will be equal to 3 because the value of k is 3 so this window will go till this index from 3 to 5 and beyond that this condition will come out to be false and we will break from this for loop so i will travel till index 3 because the last window will be this window which will actually cover the last window which is the last three elements of this array and beyond that we don't have to go so i will travel till it is equal to 3 so when i is equal to 0 we are looking at the first window which will be from 0 to k minus 1 which is 0 plus 3 minus 1 which is 2 so it will go from 0 to 2 so this is the first window of size 3 and now our target is to find the max in this window with the help of this next letter element array so as we have already discussed what we do is in the first step the element which is the beginning of this window we assume that it is the max in the sliding window so we are creating an integer value j which is our assumption that it always starts from the first element of this window so we are assuming 44 is max in this sliding window which is being denoted by j so j is also pointing to 0th index like this because value of i is starting of this window from 0 so j is also starting from 0th index and now as we discussed that we need to confirm this assumption so what we do is we are providing this while loop and the condition in this while loop is 444 which is at index 0 we simply go to this index we see there is one so we take this one out and then we are checking whether this one whether this lie in the range of this sliding window or not so here if you see if i do i plus k 0 plus 3 so this value will give 3 1 is less than 3 so it suggests that 444 which is at index 0 if we go to the next letter element array at index 0 we are finding a value 1 which suggests that 444 its next letter element lies at index 1 which is value 77 and this 77 is actually if you see it is in the range of our sliding window it means our assumption that 44 is max in this sliding window is false because the next greater element to 44 is 77 and this 77 is also in this sliding window so therefore now j will simply travel to index 1 because now our next assumption is 77 is the max in this sliding window so here we are doing that thing only 1 is less than 3 so this condition comes out to be true it means the next letter element for j which is 44 is 77 which is at index 1 and this one is lying in this sliding window so j will simply travel to that index which is the next letter element array of j which is 1 so it means j will directly shift to 1 suggesting that now our assumption is 77 is max in this sliding window so after this assignment j comes here and our assumption that 44 is max in this sliding window comes out to be false and now our new assumption is 77 is max in this sliding window but as this is a while loop we have to confirm that so now we are again checking the next letter element array of j which is 1 which is 77 which is our assumption we are going to this index we are finding a value 4 so now what we are doing this is giving us a value 4 so we are checking whether 4 is in this sliding window range or not and how we can figure out whether 4 lies in this sliding window is we know that sliding window starts from i so if it goes to 0 plus 3 it will give 3 and we have to do less than that so it will go till second index which is the first three elements from 0 to 2 but here 4 which we evaluated from this part that 77 if we go to this index next letter element array of j is 4 so this 4 is we are checking whether it is less than 3 or not so this condition comes out to be false which actually proves that 77 is max in this sliding window because the next letter element to 77 is 88 which is at index 4 which is actually beyond the boundaries of this window which proves that whatever element comes after the 77 in the sliding window will be lesser than 77 so therefore now this while loop will terminate because this condition comes out to be false and we have found the first max in the sliding window where window is starting on 0 and going till index 2 so in the result we have to store 77 and 77 lies at array of j so here you can see our assumption was correct here so 77 becomes our first max in the sliding window moving ahead now we'll increment i so i will come here at index 1 now we suggest that our sliding window will shift by one position ahead so we are done with this value and sliding window will shift by one position ahead like this i plus k minus 1 so 1 plus 3 will give 4 minus 1 will give index 3 so it will take three values index 1 index 2 and index 3 because the size of this sliding window is k which is 3 and now we'll apply the same logic we assume that the first value of this sliding window is maximum and j will point to that value so i and j at the start are pointing to index 1 which is 77 so our assumption is 77 is max in this sliding window now to confirm that what we do is next greater element array of j j is pointing to one so it means we are going to this index now and here we are finding a value as 4 which means that at index 4 we have 88 which is the next greater element of 77 and here you can see 88 is next greater to 77 but 88 is not in the sliding window range it is just outside the sliding window range therefore we are 100 sure that whatever the elements are here which is 33 and 44 they will be 100 sure lesser than 77 which means for this window 77 will become our max because the next greater element to 77 is 88 which is at index 4 and it is lying outside the boundaries of this sliding window so this condition this part will give 4 we check whether it is less than i plus k which is 1 plus 3 which is 4 so 4 is not less than 4 so this condition comes out to be false it means that our assumption at the start only that 77 is max in this sliding window comes out to be true so in the results list we will simply add the value at jth index so array of j is 77 so it becomes like this so we'll increment i, i comes to index 2 so our sliding window is shift ahead from 2 plus 3 minus 1 which is from 2 to 4th index and now our task is to find the max in this sliding window so now you will understand more about the problem in this step we assume that 33 is our max in this sliding window which is being pointed by i so j starts from i which is 33 so this is our assumption so now we will confirm this assumption based on this while loop what we do is j is pointing to index 2, i is pointing to index 2 and we are assuming that 33 is max in this sliding window so what we do is we just check that at index 2 in the next greater element array which index lies so we find 3 and if we go to index 3 you will find 44 which is actually lying in this sliding window so it means the next greater element to 33 is 44 and it is also lying in this sliding window therefore our assumption that 33 is max in this sliding window comes out to be false and this condition comes out to be true because next greater element of array of j which gives us value 3 we are checking whether this 3 is actually lying in the sliding window or not via this comparison so we are checking whether it is less than i which is 2 plus 3 so we are checking whether 3 is less than 5 or not so this condition comes out to be true which suggests that the next greater element to 33 which lies at index 3 is actually in the boundaries of this sliding window so this condition comes out to be true and in the while loop j simply shifts to 44 because our new assumption is 44 is max in this sliding window so i remains here and j comes here like this and now again we need to confirm whether 44 is max in this sliding window or not so what we do is j is pointing to third index so we simply go to the third index we find a value 4 we check whether the value is index 4 which is 88 does 88 lie in this sliding window or not so here if you see 88 is lying in this sliding window but this condition is actually helping us figure that out 4 should be less than value of i is 2 2 plus 3 4 should be less than 5 so this condition comes out to be true it suggests that the next greater element to 44 which is at index 4 here is also part of this sliding window so the condition in while loop comes out to be true and our assumption that 44 is max comes out to be false so now j will simply shift to 88 via this assignment and now once again we need to confirm whether 88 is max in this sliding window or not if we go to this index you will see the value 6 which suggests that for 88 there are no greater element towards its right because the last index is 5 and therefore we were storing array.length here which suggests that there are no elements greater than 88 so here this condition 6 should be less than 5 comes out to be false so this while loop will terminate and we will simply add 88 into the result list like this so for the third window 88 becomes the max will increment i and i is actually equal to array.length minus k which is 3 so this loop will run one more time because the sliding window will shift by one position and now it will cover all the elements of the array we assume 44 is max so j is pointing to 44 we go to this index we see the next greater to 44 is lying at index 4 which is 88 here so we are simply checking whether 44 is max in this sliding window or not so this will give us value 4 we are checking whether it is less than i plus k which is 3 plus 3 4 is less than 6 so this condition comes out to be true because 88 is max greater to 44 and it is lying in this range so therefore j is simply shift to 88 now via this assignment like this and now we'll again confirm whether 88 is max in this sliding window or not so we go to this index we find 6 we check whether it is less than i plus k which is 3 plus 3 so this condition comes out to be false it suggests that the next greater element to 88 is beyond the boundaries of this array and our sliding window is still the last index so our answer is 88 so this value will terminate and the results list we will add array of j which is 88 so 88 comes here so we'll increment i so i will come here but here you can see this condition comes out to be false because there is no more window left of size 3 so therefore the for loop will terminate and at the end we will return our result list storing the max in the sliding window which is 77 77 88 88 so the first 77 is from here to here which is this value the second 77 is from here to here the 88 is from this window to this window and the last 88 is for last window which is from here to here so friend this was all about the sliding window maximum problem i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss a problem maximum sum sub array of size k now let's move ahead and see what this problem is and how to solve this so here in this problem we are given an array of integers like this and we are given a value of k which is an integer value now this k value you can treat it as a sliding window of size k now this sliding window is moving from very left of the array to very right and it is moving one one position in this direction so at the start if the value of k is three it means the sliding window is taking in first three elements and these three elements also form a sub array of size k now our task is to find maximum sum of any contiguous sub array of size k now contiguous means that the element should be next to each other and we need to take a sub array of size k only we need to evaluate their sum and whichever sub array has the maximum sum we need to return that sum so let's say if we are given with this input array and sliding window is of size k which is three so our output would be 16 now how this 16 came is let's say our first contiguous sub array of size k is from zero index to second index so it is zero one two three four and five from zero to two we have a window of size k this is our sub array and the elements are contiguous to each other now if we take the sum of these three elements we will get a value 12 now after that what we do is we move the sliding window to right by one position so two goes out of the sliding window and five comes into the sliding window so now our three elements are this seven three and five if we do the sum of these three elements we get the sum as 15 then we move the sliding window ahead by one position so seven goes out of the sliding window and eight comes into the sliding window so now this is our sliding window if we do sum of these three elements we get sum as 16 and at the end the sliding window moves by one position and reaches to the end of the array and this is our sliding window if we do sum of the three elements the sum is 14 so here you can see we had six elements and if our sliding window is of size three we saw there were four sub arrays of size three from zero to two from one to three from two to four and from three to five and their sums are 12 15 16 and 14 so among these four sums 16 is the max so our answer should be 16 it means we are telling that we have found one sub array having three elements three five and eight if we do their sum we get a maximum sum of 16 and here window size is whatever the value of k so friends now let's move ahead and see that how we can solve this problem so let's suppose we take this array and value of k is three it means the sliding window size is three and it also means that at a time we can only see three elements in the array and for those three elements we do their sum and we keep on doing their sum for all the sliding windows and whichever sum is the maximum we simply return that sum now here you can see one way to solve this problem is let's say we take a for loop and inside there we take another for loop so the outer for loop let's say it's point to zero index and the inner for loop will take three elements because value of k is three so it takes two seven and three and do their sum so let's say j goes from zero to two and do their sum so we get a value as 12 now after evaluating the first window i will simply travel to this index and j will take the next three elements so this this and this if we do their sum we get 15 and similarly it keeps on going till i reaches here for the last window and do the sum and as we are evaluating the sum for each window like this we compare that which is the maximum sum and at the end we simply return that sum so for three five and eight this window the sum would be maximum which is 16 so if we solve the algorithm using two for loops this problem is very easy to solve so this solution is roughly time complexity of o into n into k because we are traversing the n each time we are taking k elements so the time complexity is o of n k so this time complexity is not efficient we need to solve this problem in better time complexity let's say of o of n so if i remove everything so here with this approach i was here and then we picked three elements did their sum and then we moved i here and we then picked the three elements so here if you see that for the first sliding window seven and three were part of the sum for next sliding window this sliding window seven and three were part of the sum again and only five was included and two was excluded so we did the sum again for these two elements and similarly for the second window we took the sum of seven three and five like this but when we went to the third window we again took the sum of three five so this much part we are doing the sum again in the for loop so this is actually increasing our time complexity now how to solve this problem in a better time complexity is here you can see what we do is as we need to take the sub array and it should be of size k so for the first window we take the sum directly we simply add two seven and three and we get sum as twelve so this is our first window where we do the sum directly now what happens is we shift the window to right by one position because we need to take now the next sub array from index one to three so when we do this shifting what happens is the window in blue becomes our new window and the window in yellow was our old window but here you can see in both this window seven and three were included in the sum so let's say if we do two plus seven plus three we get twelve and then we shift the window ahead we do seven plus three plus five and we get sum as fifteen so here you can see with this nested for loops we were evaluating this sum again which was in the middle of both the windows now if we stop calculating this sum again and again we will get a better time complexity here you can see when window was here we did a normal sum because we need at least k size window so at the start we are doing the sum normally two plus seven plus three we got twelve now when this window shifted ahead for the next sum here you can see two goes out of the window so if you see the blue window two went out of the window and five comes into the window so five comes into the blue area and two went out of the blue area because our current window is from index one to three of size k now here you can see we know the sum of first three elements which is 12 now as we are moving window ahead two goes out of the window we know the sum is 12 and if we do minus two our sum will be 10 which is the sum of these two elements and if we add only five to it we get 15 which is the sum of our next three elements which is in the blue area so using this property will reduce the time complexity of the algorithm so now what we do is we simply perform three steps first we take sum of first k elements which is two plus seven plus three so let's say it gives value as 12 now as we are shifting the window to the next element so that we can evaluate the next window sum what we do is we don't have to recalculate seven plus three plus five what we can do is we already know seven plus three is already in the sum in the 12 we just subtract the element going out of the sliding window so the element which is going out of the sliding window is two so we are subtracting two to get the sum of the remaining elements in the previous window which is seven plus three which is 10 and the third step is as five is getting into the window here we simply add the new element coming in the sliding window so we are simply adding five which is our new element to 10 to get 15 so if you see seven plus three plus five will give 15 which is the sum of our next window which starts from one to three and similarly this window goes on like this one one element goes out of the window and new element comes into the window so the element which is going out of the window we simply subtract from the sum and the new element which is coming into the window we simply add that we also compare 12 with 15 then with 16 then with 14 and add then we will figure out that 16 is the maximum sum in the sub array of size k so this would be our answer and also friends here you can see the value of k is 3 which is very small so here you can see these are only two elements coming let's say value is k is 100 so if one element goes out of the stack we don't have to calculate the 99 element sum again and again we can simply subtract one element and add another element and we will get the sum of the next 100 elements so this makes our algorithm efficient now let's move ahead and see the demonstration of this algorithm step by step so before we start if you want to master data structures and algorithm then you can subscribe to my channel and click the bell icon so that you never miss any update so here is the algorithm the method name is max sub array sum which takes in the array and a value k which is the size of our window so this is our array and value of k is 3 it means we are taking a sliding window of size 3 as we want to evaluate the maximum sum in a sub array of size k we create an integer variable max sum because we need to return an integer value from this method so here at the end we will return the max sum so we initialize a variable max sum with zero then we create a variable window sum so as we want to take the sum of sliding window of size k so let's say this is a sliding window of size k so for these three elements whatever their sum will be we store in the window sum and similarly for the next window sum we store in the window sum so we create a variable window sum having value zero at the start now we create an integer value start which will start from the zero index so this value is basically an index value like this that the initial value is zero for start variable we will see its significance later that why we have created this start and now we provide a for loop and inside this for loop we will do the window sum we'll compare the window sum of different windows of size k and whichever is the maximum sum we simply evaluate here so what we do is we take a integer variable end we initialize it with zero and this end will go till array dot length so array dot length will be six so end will go till the last index which is fifth index so here end will start from the zero index so in our previous slide we discussed the three steps the first step is we simply take the sum of first k elements because the first window is of size k so at the start we need to include the first k elements so that we can get a sum so here you can see the first window of size k will go from index zero to two so it means for this window we will straight away calculate the sum because we need to return the maximum sum of a sub array of size k so we need at least k elements to evaluate the sum and then compare with the next windows so this if condition if you see here will help us achieving that so value of end which is zero is less than six so this condition comes out to be true now to our window sum as we need to evaluate the sum of first three elements this will get stored in the window sum because this is our first window so what we do is to window sum we add array of end which is the first element which is two so here initially the value of window sum is zero plus we are doing array of end which is two we are adding the first element and assigning it to window sum so window sum will become two like this and here you can see that we need to evaluate the sum of first k elements so this condition if end is greater than or equal to k minus one it means we are saying k minus one is two because value of k is three if end is equal to two or greater than two then this if condition will come out to be true so at the start value of end is zero so zero is not greater than two or equal to two so it means this if condition comes out to be false and this if block won't get executed so here you can see if end comes to index two here at that moment two will be this condition will come out to be true so it means when end is reached here we have evaluated the sum of first k elements already here we added the first element then we will add seven and then we will add three so at that moment end will be at index two and when end will reach here then only our main algorithm will run and then it will keep on running for every window we will see that later so currently this condition comes out to be false because zero is not greater than equal to two we will increment end so end comes to index one we take window sum two we add array of end which is seven and we will assign it back to window sum so window sum will become nine now this is the sum of first two elements we need at least first k elements to start comparing for the maximum sum so this condition one is greater than equal to two still comes out to be false we will increment end end comes to index two we take window sum which is nine we simply add three to it so it becomes 12 like this and now here you can see that our first sliding window is from index zero to two it means we have taken the sum of first k elements which is two plus seven plus three which is 12 and now you can see end is at index two so value of end is two and it is greater than or equal to k minus one which is three minus one which is two so this condition comes out to be true so now if block gets executed so here as we have calculated the sum of first k elements it means we know the sum of first sliding window of size k which is 12 at the start max sum is zero so now what we do is we simply compare max sum and window sum and which is the maximum between these two we simply assign to max sum so here what we are doing is as we have calculated the sum of first k element which is the first window initially max sum is zero so you can think of this condition is like we are doing if window sum is greater than max sum then to max sum we are assigning window sum like this so currently maximum is zero window sum is 12 so window sum is greater than maximum so this tells us that we need to discard this maximum and our new maximum will become 12 so maximum value will become 12 like this so as we discussed in our previous slide that after evaluating the sum of first k elements this sliding window will shift ahead to get the sum of next k elements so two will go out of the window and five will come into the window so we also know that the second step we discussed that we need to subtract the element which goes out of the window so here we are doing the same and here you can see this start is actually helping us to know which is that first element of that window we know that start we initialize with the zero and end move till the index two so if you see our window is from start to end having three elements now when this window will shift ahead at whichever value start is pointing that will go out of the sliding window which means two will go out of the sliding window so what we are doing is we are not recalculating the sum now so here now what we are doing is we are simply subtracting the element which is going out of the sliding window so we are taking the window sum and we are simply subtracting the element which is at start index which is two so our window sum will become 12 minus 2 which is 10 like this and this window sum will have the sum of these two elements so for the next window we don't have to calculate this window sum again we can simply reuse that so now as two went out of the sliding window so for the next sliding window it will start from index 1 so we simply increment start so start comes at index 1 we'll increment end and comes to index 3 which suggests that now our new window will be from start to end like this which means these three elements and we know that when we shifted this window here 2 went out of the window and 5 came into the window so here you can see 5 came into the window so our third step was we add the element which comes in so we are simply adding 5 to our previous evaluated window sum which is 10 so it becomes 15 it means with just one sum we now have the sum of these three elements we didn't evaluate it 7 plus 3 again we just added 5 to our previous calculated sum which give us 15 this condition comes out to be true because value of end is 3 3 is greater than equal to 2 and here you can see our window sum is 15 max sum is 12 we simply compare these two values and if window sum value is greater than max sum we simply assign that value to max sum so here we are taking these two values which is 12 and 15 and whichever is the max among these two we are assigning it to maximum because we need to return the maximum sum of a subarea of size k so we just evaluated the sum of second subarea of size k and we simply compared it with the maximum so we got 15 from this subarea so our maximum will become 15 from this statement like this and now after we did the sum of this sliding window from here to here we know that now this sliding window will move ahead and 7 will go out of the sliding window which is which is the element to which start is pointing so this will go out of the window and we know that we need to subtract the element which goes out of the sliding window so that for the next sliding window we can evaluate the sum easily so windows sum is 15 we do minus 7 so it will give 8 and once 7 will go out of the sliding window we know that now next sliding window will start from index 2 so we do start++ so start will come at index 2 we will increment and and comes to index 4 which means now our window will start from index 2 to 4 like this now yes 7 was excluded from the sliding window and 8 was included in the sliding window because this sliding window shifted by one position so 3 and 5 remained there and 8 was included we know that we need to add that value which comes in so here we are doing the same thing we are adding the value 8 into the previous calculated sum so 8 plus 8 will give 16 this condition is true because 4 is greater than equal to 2 the maximum is 15 and this window has a sum of 16 8 plus 5 plus 3 will give 16 we know that we have found one window whose sum is 16 which is greater than the previous maximum so whichever value is greater among these two values we simply assign to maximum so maximum will become 16 now we are done with this window so now for the next window 3 will go out of the sliding window and one will come into the sliding window so if 3 is going out of the sliding window we are taking the sum which is 16 and we simply subtract 3 so it becomes 13 and as our new sliding window will start from index 3 we simply do start plus plus so start comes at index 3 will increment end and comes to index 5 it means now our sliding window is from index 3 to 5 this is our last sliding window and one was added to the sliding window so we simply do window sum which is 13 plus 1 which gives 14 we assign this 14 back to window sum so window sum will become 14 this condition is true because value of end which is 5 is greater than equal to 2 now our maximum is 16 and window sum is 14 so here you can see the maximum is 16 window sum is 14 so we already have a maximum value in maximum so maximum will remain to the 16 only because 14 is less than maximum and now for the next sliding window we simply remove 5 from the sum so it becomes 9 we do start plus plus because next window will start from index 4 but here you can see if we do end plus plus so end will go out of the boundaries of this array which also suggests that there is no window left of size k now so therefore this for loop will terminate and here you can see at the end we are returning the maximum is 16 so which is our answer so which came from this sub array of size k 3 plus 5 8 8 plus 8 16 so from here you can see we used only one for loop and we evaluated the maximum sum of a sub array of size k we need to keep these three steps in mind that at the start we do the sum of first k elements and then based on this condition we do our rest of the steps that one element goes out of the window and one element comes into the window so the element which goes out of the window which is array of start we subtract from the window sum and in the next iteration of for loop which is our next window we simply add the element which just comes into the sliding window and therefore this property help us in evaluating the sum in a very efficient way we don't have to recalculate the sum of every k elements so friends this was all about the problem I hope you must have liked this video in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss a problem longest substring without repeating characters so let's move ahead and see what this problem is and how to solve this so in this problem we are given a string like this our task is to find the length of longest substring without repeating characters so first of all let's understand what is a substring so let's suppose if you are given a string like this test so here a substring is a part of the string in which we will take out the sequence of characters and those sequence of characters should be contiguous it means there should be next to each other so the property a substring has is first it should lie within the string so it lies within the string second the sequence of characters which we are taking those should be contiguous which means they should be next to each other so for example if you want to find that how many substrings are there in this string so if we start from T one substring would be T other would be T E T E S T E S T here you can see this substring should be within the string and it should be contiguous it means they should lie next to each other so we can't take a substring like TT one T here and another T here we need to take a part of a string which is contiguous so if we start from E it would be E E S E S T if we take it from S it would be S S T and if we take the last T it would be like this so if the length of the string is let's say n so the total number of substring would be n into n plus 1 by 2 so here n is 4 so if we put 4 here we will get 4 into 4 plus 1 by 2 which is 4 into 5 by 2 which is 10 so you can see 1 2 3 4 5 6 7 8 9 10 so we need to keep in mind a substring should lie within the string and the part of the string that we are taking it should be contiguous so our task is to find the length of the longest substring in such a way that character should not be repeated so if you take this example here ABC has length 3 but as soon as A comes we get a repeating character so we discard this A and if we take B C A the length is 3 because after that we have found 1 B and B is repeating in B C A so we discard this B now we start from C so C A and B length is 3 we can't move ahead because we have found a repeating character C so we discard this C and then we find A B C and again we find a B so length remains 3 so after we find this B we can discard this A and B together because they won't contribute to the longest substring now so C and B will take two characters and then we find a repeating character so we discard this C and B and at the end we will find 1 B so the length of the longest substring without repeating character is 3 it can be found from A B C B C A C A B A B C that's it because after that we are getting a substring of length 2 like B C C B and at the end we are getting only 1 B similarly in this example we have a string B B B B so the longest substring without repeating character would be 1 because all the characters are repeating here P W becomes 2 because we have found one W here which is repeating so we'll discard this P and W then we'll go here and then we will find one W so this length is 3 and as soon as we find W we discard this W and then we start our substring from K we will find K E W which is length 3 so the length of the longest substring without repeating character is 3 so let's move ahead and see the demonstration of this algorithm step by step so before we start in case if you're new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update so here is the algorithm to find the length of the longest substring without repeating characters so method name is length of longest substring it takes in a string S and returns the length of the longest substring without repeating characters so let's say when we call this method by passing this string so S will become like this P W W K E W so if we see this string internally it will be a character array like this so friends the basic idea behind this algorithm is we create a hash map like this where key is the character and value is the integer so here as we need to find the length of the longest substring without repeating characters what we are doing is we will store the character along with its index into this map so that when we encounter a repeating character we simply look up into this hash map and we simply figure out that when that repeating character last occurred so that we can start our new substring search from an index just after that so you will understand more later in the algorithm as you want to return the length of the longest substring without repeating characters we will be storing it in the max length so at the start max length will be 0 like this so as we want to identify the length of the longest substring without repeating characters we will process each character one by one from left to right so let's say if we take these two characters P and W so the length of this substring is 2 so in this algorithm we will take the help of two variables start and end so this start and end will be actually referring to the indexes so let's say for P W let's say start is here and end is here so if you see closely start and end basically forms a window like this which has some characters so this window is starting with this start variable and ending with this end variable and those are pointing to the indexes so if you want to know the length of this substring we can use the formula as end minus start plus 1 as these are pointing to the indexes it could be 1 minus 0 plus 1 so we'll get the answer is 2 which is the length of this substring so you can treat this as a window from start to end why we are using this two pointer is we need to identify the length of the longest substring without repeating characters so we need to put start at a point from where we are evaluating the length of the longest substring and we will move end in this direction so that as soon as we encounter a repeating character we stop and there itself and using start and end we can figure out the length of that particular substring with this formula so we will understand more when we proceed ahead so as we haven't processed any of the node so start will point to zero index like this and as we discuss we will move end into this direction and start from 0 because now we are processing this first character and end will go till the last index which is 5 so in this string class we have a method charAt where if we pass any index it will return back the character at that particular index so if we call s.charAt 0 because end is at 0 index we will get a value as p which we will be storing in the right char like this so here we are asking the string to return the character at this index which is 0 index which is p and that p we are storing in the right char like this so as end is moving in this direction we have denoted it by right char so now the first thing we do is we simply find whether right char is present in our hashmap or not so we provide this if condition map.containsKey where we pass the right char and if the map contains that key it will return true we will understand more about this part later so currently map.containsKey will return false because this key is not present in the hashmap so here for the first char we know that it's a substring and it doesn't have any repeating character and we also know that in the hashmap we put the char along with its index so we are putting char along with its index so it would look something like this p and we are putting value as 0 which is end so here you can see currently our window is here where start and end are pointing to only single character and our max length is 0 because we haven't processed any character so with this formula we will identify the number of characters in this window so end minus start plus 1 so it would be 0 minus 0 plus 1 so the length of the substring is 1 we are comparing it with max length that whichever is the max we will directly store in the max length because at the end we have to return the max length so for this small substring the max length will become 1 because here it is 0 and this gives value as 1 so whichever is the max we are storing in the max length so we will increment end so why we are incrementing end because with the combination of p and w we can get a substring which is of length 2 and it doesn't have a repeating character so therefore start will remain at index 0 only and we will move only end in this direction so first we will get the character at index 1 now so right care will become w like this we will check whether w is present in this map or not so this condition comes out to be false and we will simply put w along with its index in the hash map so it would look something like this now here max length is 1 and if we use this formula 1 minus 0 plus 1 it will give the value as 2 so here you can see that we have a window of length 2 which is a substring pw which doesn't have repeating character so this will give value as 2 so now our max length will change it will become 2 will increment end so end will come to index 2 so first we will identify the character at index 2 which is w so right care will become w so friends here you can see that our hash map actually contains w so when we will call map.contains key will pass the character as w it will return a value true so this if condition comes out to be true because we have w already in the hash map it means we have found a repeating character and we can't include this w into this substring so here now what we do is till this point we have found the length of the longest substring as 2 which is pw but as soon as we encounter w we can't include this w here because we will have a repeating character so we need to move this start after w so that we can discard one of the w and how we can do that is as w is present in this hash map at index 1 we will first get that index it will be 1 so this index will be returned and we have to just start after this index so we will add plus 1 and currently start is at 0 index so we will take the max of start and this value so 2 is greater than 0 so now our start will go to the index 2 like this we suggest that we have found w here so the next longest substring will include another w so we need to discard this w and start just after that so therefore we are looking up into the hash map to see when this w occurred last and then we start finding a new substring from index just after that which is 1 plus 1 because w was found at index 1 so start comes here so it means we can simply discard these two characters and start finding the length of the longest substring from index 2 now so as we are starting from index 2 because start is pointing to index 2 we will put w along with its index in the hash map so this value will be overridden to 2 and for this single substring we know that max length is 2 which we already found as pw so 2 and minus start plus 1 so 2 minus 2 plus 1 will give 1 so 1 so the length of the longest substring without repeating characters till this point will remain 2 we will increment and and comes to index 3 at index 3 we have a character K so right care will become K K is not present in this hash map so this condition comes out to be false so we will simply put K with index 3 into our hash map like this the max length is 2 and is at index 3 and start is an index 2 so 3 minus 2 plus 1 it will give 2 so the max length will still remain 2 because this part is 2 and max will return a maximum value between these two so 2 will be assigned to max length like this will increment and and becomes 4 the character at fourth index is E so right care will become E is not present in this hash map so this condition comes out to be false so we will put E into this hash map along with its index like this so here you can see max length is 2 and minus 2 plus 1 it will give 3 so this part will give 3 so here you can see we have found one substring W K E without repeating characters which has a length of 3 so therefore now our max length will change because max.max will return a value 3 when it's compared with 2 so max length will become 3 we suggest that we have found one substring of length 3 without repeating characters will increment and and becomes 5 the character at fifth index is W so right care will become W so friends here you can see that W is present in this hash map so this condition comes out to be true and here what we are doing is with this map dot get right care we are just figuring out that when this W occurred last in this character array so this hash map will bring us that index that W occurred at index 2 so we suggest that whatever the substring we found till this point we can't include W because if we include W that will be repeating character so in order to include W for the rest of the string we have to discard this W so for that we need to know the index so when we identify that index we simply shift start to a character ahead then what we find from this map dot get right care so here it gives 2 so we simply just shift by one position by adding plus 1 start was at 2 so map dot max among 2 and 3 will give values 3 so start will now come to index 3 like this we suggest that our new substring should start from this index so now we simply put W into the hash map along with its index so the index value will be updated here it will become 5 and here you can see max length is 3 and minus start plus 1 so 5 minus 3 plus 1 will give 3 so this comes out to be 3 which suggests that one more substring is KEW which is longest and without any repeating character but among these two lengths both are same so the max length will still remain 3 only so now we'll increment end so end goes beyond the boundaries of this care array so this for loop will terminate because end should go till it is less than s dot length so at the end we will simply return a value 3 so friend let's suppose here if we had a value like a so this for loop would have run one more time so here this a is not in this hash map so we simply put a here like this a with index 6 and here our max length would have changed initially it was 3 and minus start so 6 minus 3 plus 1 would have given 4 so this would have become 4 and our answer would have become 4 which would suggest that the longest substring without repeating character is KEWA so friend this was all about this problem we can solve this problem by keeping a sliding window of variable size which has a range from start to end and whatever the characters are between start to end those number of characters will give the length of that particular window and we can use this hash map to figure out the repeating characters so that we can start our new window from a different index by making a lookup into the hash map for the character which just got repeated so friends one important thing to discuss is that why we are using math dot max and we are taking whichever is the max from the start and from this statement so in order to understand this let's suppose we are given with this string PWWP so the example which we took was like this so in our previous example till this point everything remains the same the W we placed last in the hash map at index 2 and after that we went to K so instead of K now we are going to P so we will see what the difference is so when we will increment end will come to index 3 so here instead of K now we are taking the right care as P by this and here you can see that map actually contains P at index 0 so this condition comes out to be true so friends here you can see that if we only provide this condition if we do map dot get right care will get value as 0 and if we add plus 1 to it will get 1 so we can't discard this P and start from index 1 because then our substring will have WWP and here currently the max length is 2 so when we will do end minus start plus 1 so end is 3 and this start will come here so minus 1 plus 1 so our answer will be 3 so at the end we will return max length as 3 so which is wrong because here we are playing with the indexes and this algorithm doesn't know that we have encountered a W here and this is a substring with a repeated character so one thing to keep in mind is if our start is an index 2 and we have found one character which is an index 3 and when we look up this character in the hash map if that character comes beyond our start which is the current case at 0 so this P last occurred at index 0 so we don't have to consider this P or this index because currently we are processing this substring from start to end and this P has occurred in this region so therefore if we do map dot get right care we get index 0 if we add plus 1 we get this index 1 but our start is already at index 2 here so therefore we are doing this math dot max because we have to assign the maximum value between these two statements to start so if start is already ahead of this statement then we don't shift start back we keep the start at that point only so this is the one important thing to consider for this algorithm now after this statement start remains at index 2 and we simply put 3 here and here the max length is 2 if we do end minus start plus 1 we will get 3 minus 2 plus 1 which is equal to 2 so this is the length of that substring so when we will do math dot max our answer will be still 2 because here you can see the longest substring without repeating character is 2 this or this so therefore this is the important condition to keep in mind so friends i hope you must have liked this video in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day hello everyone so in this video we are going to discuss a problem symmetric tree so let's move ahead and see what this problem is and how to solve this so in this problem we are given with the root of a binary tree like this which actually holds this complete tree now our task is to check that whether this binary tree is mirror of itself which means we need to check whether this binary tree is symmetric around its center or not so let's suppose we are given with this binary tree and we need to check whether it's a symmetric tree or not so for this binary tree if we draw a line like this so this line is nothing but a line of symmetry so around this line if a binary tree is a mirror image of itself then we consider that binary tree as a symmetric binary tree so usually when we talk about symmetrical images let's say if i take a rectangle and if i want to find out whether it's a symmetrical image or not what we can do is we can create a line of symmetry and if we rotate the image like this around this line of symmetry let's say i denote this as a b c and d so if we rotate this image around this line of symmetry you will see that a will come over b and c will come over d so if that is the case then this shape is a symmetrical shape so if any shape is rotated around its line of symmetry if the left part superimposes the right part then that shape is a symmetrical shape so here you can see for this binary tree the line of symmetry goes from the root and we have to determine whether this binary tree is a mirror of itself that is we need to check whether it's symmetric around its center so this is the center so if we rotate this binary tree you will see that after the rotation two will come over this two this four will come over this four and this three will come over this three so we can come to know that this binary tree is symmetric around its center because one will remain there itself and if we take this example here you can see that two will superimpose two but as we are rotating this binary tree around the line of symmetry when this two will superimpose this two this three will come like this it will not superimpose this three so therefore this is not a symmetric binary tree because as we are folding this binary tree around this line of symmetry when this two will superimpose this two this child at right will come towards the left of it and so this three is not superimposing this three so therefore we can consider that it's not a symmetrical shape also one thing to note here is the symmetrical shape is actually equidistant from the line of symmetry so this two and this two both are at a equal distance from the line of symmetry this four and this four both are equidistant from the line of symmetry and similarly this three and this three but here you can see this two and this two are equidistant from the line of symmetry this node three and this node three are not equidistant from the line of symmetry therefore it's not a symmetric binary tree. So friends the basic idea behind this algorithm is, if I remove this, so let's say if we are on root, and this root has only one tree node, like this, so therefore we can directly consider that it's a symmetric binary tree, because we need to find whether the binary tree is symmetric around its center, so this is the center, if this root is null, then also will return true, that it's a symmetric binary tree, so here now if binary tree is given like this, so after the root, if we are going on the left, so we will reach to this node, and if we look into the mirror, then this left should be equal to this right, so that we can come to know that till this point, the image is symmetric, now when we reach here, and here, if we are going towards left, then in the mirror it would look like we are going like this, towards right, so we land here, we compare these values, and we know that till this point also the tree is symmetric, now if we go towards right, so in the mirror it would look like we are going towards left, and we reach to node 4, and we compare its values, so those are same, so 2 is equal to 2, 3 is equal to 3, and 4 is equal to 4, and after that there are no more nodes, so we can consider that this is a symmetric binary tree, so here let's say if we are going towards left, then in the mirror we are going towards right, so we reach here, we compare those values, they are equal, so now here we have a null value, if we are going towards left, then in the mirror image we are going towards right, so here we have reached to the null value, but here we have reached to an actual node having value as 3, so when we will compare them, they won't be equal, so we can directly come to know that this is not a symmetric binary tree, so one property to remember is, if we have mirror here, and if we are going towards left, then in the mirror image you are going towards right, and if we are going towards right, then in the mirror image we are going towards left, so similar technique we will apply over the binary tree to figure out whether it's a symmetric or not, so now let's move ahead and see the demonstration of this algorithm step by step, so let's say if we are given with this binary tree, and we need to check whether it is symmetric or not, so when we will call this method is symmetric by passing in the root, it would look like this, that root is pointing to this binary tree, and this method will return a boolean value stating that this binary tree is symmetric or not, so here the first thing we check that whether root is equal to null or not, so if root is equal to null, then we can directly return true, because there is no binary tree, and there is no node, so the binary tree is actually symmetric around its center, so we are returning so this condition comes out to be false, because root is pointing to a node having value as 1, so friends we will use stack data structure to figure out whether this binary tree is symmetric or not, so here we will initialize a stack like this, so stack is a leafo data structure where the element inserted last will be the first to be removed, and we will use this property to figure out whether the binary tree is symmetric or not, so we will see that later, so here you can see if root is not equal to null, it means there is one node till this point the tree is symmetric, and let's say if I draw the line of symmetry like this, so we know one of the property of this line of symmetry is, let's say on this side, if we are going towards right, then in the mirror image it would look like that we are going in this direction, and similarly if we are going in this direction, then in the mirror image it would look like we are going in this direction, so therefore in the stack what we are doing is, we are pushing root.right which is true, so it means if we look into its mirror image, then we need to put this two into the stack as well, because we know that on this side if we are going towards right, it means on this side we are going in this direction, so therefore we need to compare this two with this two, so if we are going towards right on this side of mirror, then we are going towards left on this side of mirror, so we are putting both the two's into the stack so that we can pop them out in pair and compare them, so this thing we will do in the while loop, we will check whether stack is empty or not, so currently stack is not empty, so the condition in while loop comes out to be true, so here this two, so here first we place the right one, so this is the right one and this is the left one, so we will create two nodes n1 and n2, we will pop the nodes from the stack and assign it to n1 and n2, so first we will pop two out which is on the left side and assign it to n1, then we will pop the right one and assign it to n2, so after getting n1 and n2, we need to compare these two nodes now, so the first thing we are checking is whether n1 and n2 both are null at the same time or not, so if both n1 and n2 are null simultaneously, then we will continue with the while loop, so let's say this is our line of symmetry and let's say this is our node 1 and this is our node 2, so here both of them are null, it means the symmetric property holds true for both of these nodes, so we will simply continue, but here you can see n1 is pointing to 2, n2 is pointing to 2, so both of these conditions come out to be false and then this condition is very important because it will directly return false that whether the tree is symmetric or not, so here we check that whether n1 is equal to null and n2 is equal to null, so if both of the conditions are true that n1 is null and n2 is null, so we can continue, so if this condition comes out to be false, we suggest that there could be a chance that either n1 or n2 can be null, so if n1 is null, we directly return false because here we have already checked whether n1 and n2 both are null simultaneously or not, so if this condition came out to be false, we are simply checking first that if n1 is equal to null, then we can directly return false or if n2 is equal to null, we can directly return false because these two cannot be null simultaneously based on this condition or if their values are not equal, so currently n1 is not equal to null, n2 is not equal to null, n1.well which is true is actually equal to n2.well, so this condition also comes out to be false which proves that till this point, the tree is symmetric and these two and these two are actually equidistant from the line of symmetry, so we simply move ahead and now what we do is, as we are on n1 and we are done checking these two nodes n1 and n2, now what we do is, if we want to proceed ahead in the binary tree to figure out the rest of the elements are symmetric or not, we know that if we are going towards left from this two to three, then in the mirror image it would look like we are going towards right and if we are going towards right, then in the mirror image it would look like we are going towards left, so these two nodes are symmetric, so now we have to compare n1's left with n2's right and n1's right with n2's left and if those are equal, then we keep on doing this thing till the complete binary tree is empty, so here in the stack what we are doing is, we are pushing n1's left which is three, so this is the first node like this and as we need to put them in pairs so that we can pop them out and compare with n1's left, we need to put n2's right like this, so n2's right is three, so this is second and then we will put n1's right which is null and along with we will push n2's left which is the mirror image of n1's right, so null will come like this, this is the fourth push, stack is not empty, so now we will pop in pairs and we will compare them, so when we will do stack.pop, fourth node null will be popped out which is n2's left which is four, so n1 will point to n2's left like this and then we will pop one more element which is three which is n1's right, so n2 will point to n1's right like this, so here you can see that now we are actually comparing the mirror images nodes comparing n1 and n2 which are actually symmetric nodes across this line of symmetry, so if n1 is null and n2 is null then we will simply continue, so currently n1 is null and n2 is null, so which proves that till this point the tree is symmetric, so we will continue, stack is still not empty, we will pop the node which is n2's right, so now n1 will point to n2's right which is this node and then we will pop one more node which is n1's left, so n2 will point to n1's left and now we will simply compare them, so here you can see that we are using the stack data structure which is popping the elements in pairs and we have pushed in such a way that this is the line of symmetry that if you are pushing any node in the left side then in the mirror image we have to push the right side node so that we can compare them and come to know that whether they are symmetric or not, so n1 is not equal to null and n2 is also not equal to null, here you can see n1 is not equal to null or n2 is also not equal to null, n1 dot val is 3, n2 dot val is 3, so 3 not equal to 3 comes out to be false because 3 is equal to 3, so this condition comes out to be false, so it means that till this point the tree is symmetric and now what we do is we perform the same steps on this node and this node, so first we will push n1's left, so n1's left like this, so if we are pushing n1's left we are going to the left, so on this side we have to take its corresponding node on the right side like this, so we are putting n2's right which is also null, then we will push n1's right which is this null and correspondingly we have to push n2's left like this, stack is not empty, we will pop this null value which is n2's left and assign it to n1, so n1 will come to n2's left like this, we will pop this null which is n1's right, so n2 will come to previous n1's right here, so here you can see n1 is equal to null and n2 is equal to null at the same time, so therefore we will simply continue, stack is still not empty, so now we will pop both the nulls, so first we will pop n2's right, so n1 will point to previous n2's right which is this and we will pop this null also which is n1's left, so previous n1 was here, its left is this, so n2 will point to previous n1's left, n1 is null and n2 is null simultaneously, so therefore this condition comes out to be true, so we will simply continue, we suggest that this null and this null is symmetric, this null and this null is symmetric, stack is empty, it means there are no more nodes in the binary tree to be traversed, so we will simply return true stating that across this line of symmetry, this binary tree is symmetric, so friend let's suppose we are given with this binary tree now, this is the line of symmetry and we need to check whether this binary tree is symmetric or not, so we will perform the same steps till this while loop, root is not equal to null, we will create a stack, root is not equal to null, so we will push roots right on this side along with roots left which is a mirror image of this node in this side, so 2 will come and this 2 will come, stack is not empty, we will pop 2 from the stack and assign to n1 like this, we will pop another 2 and assign it to n2 like this, n1 is not equal to null and n2 is also not equal to null, so this condition comes out to be false, n1 is not equal to null, n2 is not equal to null, n1.well which is 2 is equal to n2.well, so this condition also comes out to be false and then we will simply push n1's left which is null, so till this point the tree is symmetric and for this node and this node we have to check whether it's child or symmetric or not, so if we are putting the left part on the stack then on this side we are actually pushing n2's right which is 3 and then we are pushing n1's right which is 3 and it's corresponding n2's left like this, stack is not empty, we will pop null n2's left, so n1 will come to n2's left here, we will pop this 3 which is n1's right, so n2 will go to n1's right like this, so n1 is equal to null and n2 is not equal to null, so one of them is null but other is not null, so we can't continue, so this condition comes out to be false, now here you can see as we need to compare these two nodes and they should be equal, this condition proves that n1 and n2 both are not null but there could be a chance that n1 is null or n2 is null, so if any of the node came out to be null we can directly return false because instead of null we actually need a node 3 here so that this binary tree can be symmetric till this point but as it's a null value here, so this condition comes out to be true and as it's a or operator here we can directly return false, so from here only we will return false stating that this is not a symmetric binary tree, so friend this was all about the symmetric binary tree, I hope you must have liked this video, in case if you are new to my channel then please subscribe to my channel and click the bell icon so that you never miss any update, thanks have a nice day.