in my previous video on binary search trees I covered all the basic concepts so definitely check that one out if you haven't seen it yet in this video I'm going to talk about finding the tree height and tree traversal height in a tree represents the distance from the root node to Any Given Leaf node so if you look at this example over here the root node is nine that's height zero but if you see four and 17 here that's height one 36 and 22 height two 5 7 and 20 are height three so it's the distance from the root node to the leaf nodes they're kind of like layers of a cake and that's how you're going to count them different paths in a highly branched tree structure may have different heights but for a given tree there will be a minimum height and a maximum height and if the tree is balanced these values will differ at most by one so before I show you the code to implement those things I'm going to show you the use of the code we're going to go all the way down to the bottom where we create a new binary search tree and then we add all these values which the those values there are the same values as in the picture over here we're going to find the Min height we're going to find the max height and we're going to check if it's balanced let's just comment out these now so it's showing the Min height is one in the console the max height is three and it's not balanced the Min height is the distance from the root node to the first Leaf node with without two children so if you look on here 17 is a root node without two children it has a right child but it doesn't have a left child so the minimum height you start at at the root node which is zero and then you count to the next level which is one so the Min height is one now the max height is just the distance from the root node to whatever the the most bottom node is so 5 7 and 20 are all at the max height so 0 1 2 3 so the max side is three now this tree is not balanced because remember if a tree is balanced the values between the Min height and the max height will be at differ at most by one you can see that there's a missing number here the reason why this tree is not balanced is because there's no number here to the left of 17 but if I uncomment out this code here we're going to add 10 now 10 if you see when it's being added it's going to add to the left of 17 because it's more than 9 but it's less than 17 so the 10 will fill this spot right here and then we're going to find the Min height the max height and then check if it's balanced again okay so now the Min height is two and the max height is three the Min height is going to be either this three or the 10 that we just added it's not showing up in the picture but just imagine there's a 10 right here so we have zero one and then the Min height is this level right here because this is the first level that there are no without two children if you imagine there's a 10 right here so that's two and then three is down here right now is balanced is true the difference between the Min height and Max height is at most one so it's going to have to be either zero or one to be balanced when a tree is balanced then searching through it is much more efficient we're not going to cover this in this video but there are ways that you can make a tree automatically balance itself when you add new items and when you delete items this creates greater efficiency when searching the tree okay now we're going to look at these last lines I have commented out here this these are ways to Traverse the tree tree traversal methods can be used to explore tree data structures and basically find all the values in the tree in depth first search a given sub trees explored as deeply as possible before the search continues on another subtree uh when I show you an example it will that will make more sense but there's basically three ways that this can be done there's in order traversal preorder traversal postorder traversal and this last one I'm going to talk about later this level order traversal so let me run this and then I'm going to explain it so here you look at the bottom of the console and you can see what we what we've logged here for in order traversal you're going to begin the search at the leftmost node and end at the rightmost node so you can see this this just has all the numbers in order 3 4 5 6 7 9 10 17 20 22 those are just all these numbers in order you're going to begin at the leftmost node and you're going to add all the numbers in order now preorder traversal you're going to explore the root nodes before the leaves so let's look at this I'm going to read off these numbers down here and I'm going to show up on the picture where they are in the picture so we're looking at the root nodes first in the list nine is first that's a root node then four that's a root node then three and the next new is going to be six and then five and then seven then 17 and then 10 which we don't have on this picture then 22 then 20 so the preorder focuses on the root nodes first and then adds the nodes below that the post order explores the leaf nodes before for the roots so look at this one the first node on the list is three cuz it's a leaf all the way down and then we have five CU that's a leaf note then we have seven and then we're going to go to Six we're not going to hop over to 20 over here because that's on a completely different branch of the tree you have to finish all the leaf nodes on one branch before you go to the next Branch so after six is four now is where we jump over the the leaf nodes on the next branch and we use 10 which again is not on the picture then 20 then 22 then 17 then 9 this level order is called a Breet first search this explores all the nodes in a given level within a tree before continuing on to the next level first it's going to do level zero which is nine if you see these numbers down here and the next is next is going to show four and 17 then 3 6 22 then 5 720 so let's go over the code so first we're going to go over the code for the man height and the F maxide and the is balanced so the is balanced is pretty simple because you just call these functions that I haven't talked about yet but you're going to call find Min height and see if that's less than or equal to find Max height minus one so this is going since this is a a conditional statement it's going to return true or false so as an example if you remember before we added the 10 we had the Min height of one and the max height of three if this Max height is 3 3 1 is 2 so is 1 less than or equal to 2 no false so we know that the tree is not balanced we have false right here but then we run it again down here and the max height is three and the Min height is two if we do 3 Min 1 that's going to be two so now we have is 2 less than or equal to 2 yes so we're going to return true true so that's how we're going to find out if it's balanced now let's look at find Min height this is going to be a recursive function you can pass in a node but if you don't pass in a node it's going to set the node to the root node here and then it's going to check if the node is null and return negative 1 if you haven't added anything to the binary search tree it's going to return Nega 1 for the height we're going to set the left and right to calling the find men height on node. left and find men height node. right so this is where the function becomes recursive eventually one of these two is going to be NE 1 because the left or right node is going to be null so here we are going to add one to the left if left is less than right and we're going to add one to the right else so if right is less than left and for five find Max height it's it's the opposite so instead of having the less than here we have the more than here so here we're going to return left plus one as if left is more than right else return right + one feel free to check the code in the description to play around with this yourself the in order preorder and postorder there's a lot of similarities to the code so let's look at the in order traversal first um the only thing that's going to be different in each of these uh in order preorder and postorder are these three lines and the only thing that's going to be different in those three lines is the order of the lines so for all of them we're going to check if the root is null and return null this just to check if there's even a binary search Tre that exists or if there's any values in it so if we find out that there is a binary search tree we're going to do these things we're going to create a new array of the result and we're going to add each value in the the in the tree onto the result so we're going to create this function Traverse in order function and you can see down here we're going to call that function and pass in the root node and then after the function has been run you're going to return the result so inside this function it's going to be recursive and remember these three lines are the only thing different between in order preorder and post order it's going to change the order that we check things so in order we are going to first do this line so this right here is short circuit evaluation whenever JavaScript evaluates the and operator like this if the first thing is true it will also run the second command if the first thing is not true it will not run the second command check my video on shortcircuit evaluation to find out more about that so if no do left is true that means if no do left exists then we are going to run the TR Traverse in order function on node. left and that just calls the same function again and passes in no left then we're going to push node. data so we're going to push the value in that node onto the result array and then we are going to check if node. write exists if it does we are going to call the Traverse in order function on node. write and if we look down here like remember I said that just these three lines are different so in preorder it's going to push first and then it's going to call the function on node. left and then it's going to call the function on node. right in post order it's going to call the function on node. left then call the function on node. right and then push the data so just the order that we call these commands is going to change the order of how we get the result when traversing the tree again you can check that code and play around with until you can figure out exactly how it works I'm going to go down to the level order function in this method we start by adding the root node to que then we begin a loop where we DQ the first item in the queue add it to a new array and then inspect both its til subtrees if its children are not null they are each in cued this process continues until the queue is empty we are creating a result array that we are eventually going to return now here's just the the Q array this is just a temporary array that we're using that we're eventually going to put things off that array onto our result if this. root is not null if there actually is a binary search tree we're going to push the root node onto Q This is a y Loop so it's going to continue going through this until we've actually added all the all the elements from the tree so while Q is q. length is more than zero we're going to keep doing these things so first we're going to let node equals q. shift now shift just takes off the first element in the array and returns that element so we're g to put the root node into node because it started out as the root node and now Q is not going to have that root node on it anymore and we're going to push node. data onto that result so we just pushed nine onto the result and if you remember um nine is the first thing in the the level order result now if no do left does not equal null we are going to push node. left onto the Q and if node. right does not equal null we're going to push node. right on to the the queue and then then we're going to go back through the while loop we're going to take off the first node and put into node which remember is going to be no do left that we push on here and we are going to push that value to the result so we're going to push four to the result and now we're going to push node. left and we're going to push node. right so in the Q we're now going to have three and six but when we go back through the while loop and we shift off an Element even though we added three and six in the last iteration of the loop the node that we're shifting off is going to be 17 because shift is going to take the first item of the array off and three and six are at the end of the array so then it's going to get that value and so on it's going to keep going through this until it's gotten every value from the tree okay and this concludes my video about height and traversing trees thanks for watching my name is Bo KS don't forget to subscribe and remember use your code for good