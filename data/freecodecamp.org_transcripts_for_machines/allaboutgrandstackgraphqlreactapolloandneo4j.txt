so i'm going to be talking about full stack development with the grand stack which is graphql react apollo and neo4j database so my name is will i work at neo4j which is an open source graph database i don't work on the the core engineering team for neo4j instead the the team i work on build integrations so making sure that you can use neo4j with your favorite web development framework that you can move data back and forth from different data processing frameworks tools like that and so what i'm going to talk about today uh is largely the the most recent integration that i've been working on which is a neo4j graphql integration which makes up a big part of the of the grand stack but if you get bored while uh while i'm talking um you can go to bit.lee graph hacker and there's a little challenge there basically it will take you to an apollo launch pad which is a tool for building a graphql service in the browser and there's just a couple of steps to follow basically just connect uh connect that launchpad to a hosted neo4j instance and get the graphql service working and then just tweet us about it and we'll send you one of these cool neo4j graphql hacker tshirts and you don't have to do it while i'm talking you can can do it later too cool so uh so what do i want to talk about uh well i want to talk about this this idea of the grand stack so these these technologies that we can use together to build uh to build full stack applications because most of most of us are developers i want to talk about focus on the the how we do this so we're going to go through go through some code samples of how we can build a full stack grand stack application but first of all what what is the the grand stack what are these components uh so the first component of the grand stack is graphql how many people have used graphql at all okay cool so that's maybe like a i call that like twothirds of the audience so graphql is this new paradigm for building apis it's an alternative for building rest apis it's very focused around a schema definition so we start by defining schema we define the the types that are available the fields available on these types and then we can select from the schema on the client which fields we want in our query the other component uh say the next component is react how many people use react okay that's that's a lot of folks cool so as you all know react is this this javascript library for building user interfaces for web native vr very much focused on on components that encapsulate data and logic uh and then we have apollo how many people have used any of the apollo tooling a few folks yeah so apollo is not just a single tool apollo is instead a suite of tools for working with graphql so you see apollo show up both on on the client side with things like apollo client and then also on server side tooling for building a graphql service things like performance monitoring and mocking so when we say apollo in this example today we're going to look at the apollo clients specifically the react integration for apollo client but really there are lots of different apollo projects that help with working with graphql throughout the throughout the stack and then the final component is neo4j database how many people have used neo4j okay okay a few so neo4j is is a native graph database what that means is that we use the property graph to store model and query data as a graph so nodes are the entities in the in the graph relationships connect them we can store arbitrary key value pair properties on nodes and relationships we use the the cipher query language for working with data in neo4j you can see an example at the bottom of the screen there and then we have client drivers in lots of different languages for working with neo4j so in the example today we'll be using the javascript driver for neo4j cool so those are the individual components of of the grand stack how do they how do they fit together well let's look at a simple example let's consider a super simple movie search and recommendation web app so what are the the requirements for this well a user should be able to search by title and then view some movie details for any matching movies and then we also want to show personalized recommendations so for for this movie that a user searched for what are some other movies that the user might like and if you're familiar with with graph databases this kind of recommendation query is really easy to express in a graph so if you've if you use amazon or ecommerce things people who bought this also bought this for movies someone who viewed and rated this movie highly also rated these other movies highly that's a simple example we can do much more complex things but that's the the general idea okay so with that sort of uh that application in mind how do the the piece of the grand stack fit together well we have react on the front end the user types in their movie river runs through it hits search and the apollo client integration in this case sends a graphql query to our graphql service our graphql server has logic uh in there to query our neo4j database to look up movies by title and that data comes back to apollo client the react integration for apollo client binds the graphql query result to the props for our view for our component and and the views rendered okay so that's that's how those pieces fit together let's look at that in a bit more detail starting starting at the data layer so starting with uh with neo4j so since since everyone is familiar with neo4j i want to spend just a little bit of time talking about what is neo4j and i think the best way to explain something is often in the form of a tweet so here's neo4j in 140 characters i guess i could redo this in in 280 now so neo4j is open source software that stores and queries data as nodes and relationships using the cipher query language with index free adjacency okay so there's there's a bit going on there let's dissect that a bit so first of all neo4j is is open source software all the code is on github we can we can go build it from source we can we can download it we can use the docker image for neo4j so lots of different ways to to get neo4j neo4j is primarily database so focused on modeling storing and querying data so when we we write some data to neo4j it's durably committed to disk neo4j is is not just an inmemory processing framework it's it's very much a database okay so it allows us to store inquiry data as nodes and relationships so we said that nodes these are the the entities or the objects in the graph and relationships connect them so relationships are our first class citizens in the data model and we can store key value pairs so properties attributes both on nodes and relationships and if you look at this this data model this might look somewhat familiar if you've been following the news recently so this is the data model from the paradise papers data leak so this was leaked data from in this case a law firm in the bahamas that had lots of information on rich people that had connections to offshore legal entities and the the data journalists that were working with this leaked data they use neo4j to make sense of the connections to these offshore legal entities and this makes sense if you think of a person who has some shareholder interest in a legal entity that is the beneficiary of another legal entity that is a shareholder in uh an offshore trust and things like this where there's a very long path to get the ultimate beneficial owner um so that kind of data makes a lot of sense to work with in a graph so we we model store and query the data as nodes and relationships using the cipher query language so here's a cipher example and this this again this is querying the the paradise papers data set so this is saying find addresses in london find all of the officers so in this case the people find all the people with addresses in london and then uh for those people find all of the legal entities that they're connected to so you can see that cypher is very much about pattern matching in that first line in the match statement we're defining a graph patterns we define nodes within parentheses relationships within brackets and we're basically traversing the graph to find paths that match this pattern of people with addresses in london and their connections to offshore entities and if we run this in in neo4j browser we get this graph visualization okay so these are all the people that addresses in london that have connections to offshore legal entities from the paradise papers and this is useful to sort of see where there are some highly connected clusters we can see a couple of connected clusters there there's something something interesting going on there someone that has lots of connections to legal entities okay that's interesting but oftentimes the answer to our question is not a graph visualization maybe it's the result of an aggregation or maybe it's tabular data so we can modify our query slightly to ask a different question in this case we're saying okay for all these people with addresses in london that have some connection to offshore legal entities uh what are the most common jurisdictions for those offshore legal entities so for people in london uh where do they like to hide their money offshore uh well bermuda is the most common offshore jurisdiction followed by the cayman islands mauritius is on the list as well so the point there is just that graph queries are not just about graph visualizations we can do sort of the same things that you would expect from other query languages like sql and that kind of thing cipher is part of the opencypher project so it's an open query language that is implemented by other databases other processing frameworks we can use cipher with spark for example okay so back to our tweet um so neo4j input source software stores and queries data is nodes and relationships using cipher with index free adjacency so this last part index free adjacency is an important performance characteristic of graph databases what this means is that when we traverse from one node to any other through a relationship that we're connected to we're not doing an index lookup that means that the performance then of a local graph traversal is a constant time operation it's not dependent on the overall size of the data so our query is on a data set of you know a few million nodes then can scale to one with several billion nodes so we can scale these queries to very very large data sets this is a really important performance characteristic of graph databases it's very different from other types of databases okay so that was my neo4j and 140 characters overview if you're interested in playing around with neo4j or that paradise papers data set as well neo4j sandbox is a good a good example of a way to spin up neo4j instance with some different data sets they're hosted on aws with some example queries you can can play around and get started okay so let's take a look at um at some data in neo4j since we said we want to build out our movie recommendation app and i said we were going to look at data about movies and and user ratings but but i lied instead let's look at some data about russian twitter trolls uh so so again if you've been following the the news at least this has been been big in the us i think in europe too but there's been an investigation to russia's meddling with uh the u.s election especially through social media and so twitter twitter released a list of 3000 screen names that are tied to russia and then promptly suspended those accounts which deleted all of the tweets from twitter.com and from the twitter api so we can't really figure out what those 3 000 russian trolls were tweeting about but i i found some of them on internet archive um so i scraped internet archive for all the tweets i could find by these russian trolls and put them in neo4j um so here's the here's the schema uh that we have so we have uh we have a tweet uh a tweet was posted by a user so user posted a tweet then we have hashtags we have urls that the tweet might contain oh and then i also ran some uh some simple natural language processing like entity extraction to find any any people organization or locations that any of these tweets mention so let's look at uh look at an example query so for one user this is 10 underscore gop so this was an account that was intended to look like a political party of the state of tennessee in the u.s but was very much not so we can say okay show me all of the tweets posted by this user and that have a hashtag and show me all of the the hashtags uh for these tweets and we can get back uh sort of this this sort of visualization so here's the user it's posted posted some tweets so here's something about civil rights that trump is taking away we can see some of the the hashtags that are used we can see here that here's several tweets from this user that that use the hashtag barcelona so we can sort of get an idea of what what this account was was tweeting about uh and we can we can run queries over the the full date data set so uh this one is interesting what are uh what are the most common uh hashtags that are used and for some reason there's a lot of a lot of tweets that we captured in german targeting i think things going around around merkel's reelection in germany we can also look at the hashtags used together most frequently uh which i think is also interesting and again we get a lot of a lot of german tweets there okay so that's the that's the data set that i actually want to work with instead of instead of movies so keep that that data set in mind and we'll talk about how to build a graphql service on top of this so so first of all let's talk a little bit about about graphql so we said that graphql is this new paradigm for building apis it's not really a query language for a database necessarily but instead it's a query language for api so it's a way of specifying data and then querying the data but limited support for what we would think of as query so like there's no support for aggregations or filtering things like that and then there's also a big community of tools built around graphql so graphical which we'll look at in a second is this sort of inbrowser ide for working working with graphql we already mentioned mocking and performance so the the schema is really important in graphql it defines what data is available and then a client for any given request selects only the data that that the client is interested in from the schema and this reduces than the amount of data that's sent sent over the wire and it also allows the client to pick the data it needs to render a particular view and these are the the two reasons that that facebook created graphql originally was to be able to render a review with a single round trip request and to reduce the data sent sent over the wire so this was particular to facebook's native apps over slow networks where this sort of network latency is really obvious when you have multiple requests to render a view graphql also makes this this observation that your application data is a graph and we'll come back to this in a minute because i think this is pretty important so here's a graphql query um we're looking up a business by id and then we're specifying uh some fields that we that we want to grab uh okay so so what's the the graph piece of this well graphql makes this this observation that your application data is a graph uh sort of irrespective of how we store that uh on the back end but when we're talking about our application data in the client that that's a graph and and we're traversing it with graphql so we're starting from the business we're then seeing okay what are the the categories connected to this business uh okay for those category objects what are the the name property associated with that and so on so we're traversing traversing this graph and we get back get back our results notice that the the shape of our result matches uh matches our query because those are the fields that we we specified that we're interested in so this this observation that your application data is a graph is interesting because it implies then uh that if you're not using a graph database on the back end if we're using a relational database or a document database then there's some sort of mapping and translation that has to occur from our application data graph graphql to how we're storing and modeling that data in the back end let's take a look at graphical so we can sort of see our data being queried live so here's graphical this is sort of this this in browser ide for working with graphql and this is querying the the neo4j database that i have running so let's just grab the first three tweets so we're querying for uh hashtag politics finding uh the first three tweets grabbing the text but we can also see all the other hashtags uh in the tweet and so on so you can see how our response is changing as we're adding adding more fields here skip some of these slides and talk about how we build a graphql service so so the first thing we do is define a schema and then we define resolver functions that define how we fetch data for that schema here's our movie schema but let's take a look at our russian twitter troll schema it looks like this uh so we have uh it's pretty simple we have three types we have tweets we have a user we have a hashtag and we also have a link and you can see the fields that are available so we have so a tweet has has a text it has a permalink and our fields can reference other types so a tweet has an author that's that's a user here and then the other important thing that we define in our graphql schema is the entry point for our graphql service so here we have two entry points so these are the the queries the graphql queries that we can run we can start by looking up hashtags by by tag or we can do tweets by text so search the text of tweets to find tweets and we define we define our schema using the schema definition language which is this sort of language agnostic way of defining a schema okay and then we said our resolver function has the logic for fetching fetching that data so this is what a typical resolver function looks like where for our entry point we define how in this case a cipher query to look up a movie by title but then we have some other fields that that's not resolving so things like our recommended movies we have to have another query to find our recommended movies our genres are in another another node so we need to have another query to find our genres so if we end up with a nontrivial graphql query what we end up with are lots of these different queries that are multiple round trips to the database so we end up having to batch these for performance and this is typical for for really any graphql implementation so what we wanted to look at was well could we build a neo4j graphql integration that offers some uh some developer productivity benefits right like implementing those resolvers seems kind of tedious we're just sort of writing cipher queries there and if we do this with a relational database we're writing sql or we're writing our orm queries so is there a way that we could translate graphql to cipher and then not have to write those resolver functions and then would this give us better performance because we can just generate a single cipher query so that's one round trip to the database rather than having to to batch a bunch of queries and then could we expose cipher through graphql because graphql is somewhat limited in support for projections aggregations so these are the things we wanted to uh we wanted to explore and so we built what we call neo4j graphql js which is a integration for graphql neo4j that basically takes the graphql schema and uses this to drive what the neo4j data model should be which then allows us to translate arbitrary cipher queries to i'm sorry arbitrary graphql queries to cipher what this means is that for any any given graphql query there's just a single cipher query so a single round trip to the database uh and neo4j has a has a very smart cipher execution engine so those end up being being optimized pretty well and then we can also expose cipher in graphql with a cipher directive so in our schema definition we can annotate any of these fields so this is a this is a field called similar on on our movie type so we said we needed to generate movie recommendations for a movie so this field similar in this case we're just looking for movies that have the same genre um but we could have a much more complex query there looking at user ratings or something like that and that then becomes a computed field uh so that's this idea of the the cipher schema directive and that still is just one cipher query that we are are able to generate uh that computed field essentially becomes a sub query in our cipher query um okay so we thought we thought that was was pretty good and if we if we take a look here um this so this is the uh graphql server implementation uh that i was hitting when i was running graphical here so my russian twitter data and this is the only code to uh to implement my resolver so i don't i don't have to write any cipher there basically all i'm doing is calling the neo4j graphql integration passing along the graphql query and any parameters and our integration is is generating uh the cipher behind the scenes these are these are the generated queries um so here you can see we were looking for the hashtag politics and looking for any tweets that have that hashtag and and so on um so anyway so so i think this was really cool this was a big a big i think developer productivity boost um it allows you also still to have the flexibility of querying other services so if you want to fetch data from another another database you can do that as well just implement your own resolver rather than calling out to the to the integration cool so that's that's the neo4j graphql integration um i'm about out of time so i'm going to going to skip over this this react piece i think we're all pretty familiar with react the only thing i want to say about about the react apollo integration is that apollo clients the react integration for pal client is really neat because it allows us to basically bind a component's props to a graphql query that's sort of the only missing piece here and my my super simple react app that i wrote in just a few minutes as you can see with no no styling or anything uh basically just allows us to search by uh by hashtag so all it's doing is uh binding our uh tweet list uh props to uh to a graphql query anyway the code is is uh is online if anyone wants to check that out um i just want to mention a couple of things um one is that these sorts of uh integrations that we're building these are largely feedback driven so this if this sounds uh like an interesting project like something that you might uh want to play around with please do and then let us know what you think are there features that would be helpful let us know we can build them because really our goal is to sort of figure out what sort of the sort of integrations like this make sense to make it easier to build to build cool applications so i'll mention just just a couple of resources uh the neo4j sandbox which i mentioned before is a great way to get started with neo4j it has this data set for movies and movie recommendations that power the the movie app that i didn't really talk about but as other other data sets as well that are really fun and this portal grandstack.io this is sort of a landing page that collects lots of information about these integrations that we're working on uh has documentation and tutorials for these different different projects so if you want to get started looking at looking at grand stack apps or any of these integrations that i talked about that's a good place to to start cool so that uh that is what i have to say yeah question yeah yeah so the question is uh there's this other database called d graph um why would i why would i use neo and instead of d graph for a graphql integration so so d graph is um is a triple store it it's not quite the same thing as a graph database but um for intensive purposes it's very similar um they they use something kind of like graphql for their query language um they call it uh graphql plus minus i think so they they sort of have added some things to to their flavor of graphql and like they've added some some filtering functions and things like this and the the problem with that is because it's not graphql it means that uh that doesn't work with any of the other graphql tools so you you can't just uh like wire up apollo clients to it because it's uh it's not graphql so things will break there's actually um i won't bring it up here but there's a really good github issue or some of the apollo folks basically said hey you say this is graphql but it doesn't work with any of our tooling what's going on so so anyway so that's that's one thing that i think is a bit confusing about d graph is it's not actually not actually graphql that you know is compliant with the spec that works with other graphql tooling in the ecosystem um but having said that the what they've done with the the graphql language is really interesting um because they've taken taken an interesting query language and sort of added missing functionality i just don't think they've done it in a way that plays well with other tooling um so so anyway the the answer to uh to your question is sort of for if i want to build a graphql app with uh with neo4j or or dgraph you know an important consideration is how does it work with other other tooling in the ecosystem and so the these cipher schema directives um these are sort of the the builtin way in the graphql spec to sort of extend graphql so this means that we're sort of extending graphql by annotating these fields but we're doing in a way that uh is compliant with the spec and that means that it'll work with all of the other uh graphql tooling in the ecosystem well thank you uh there's no more questions