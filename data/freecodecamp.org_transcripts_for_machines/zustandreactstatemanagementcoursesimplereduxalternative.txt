Zustand is a minimalistic state management library for React, offering a simpler API compared to Redux. It aims to provide ease of use without sacrificing flexibility and performance in modern web applications. It provides a simple and intuitive API for managing and updating application state without the need for boilerplate code or complex patterns. Niklas will teach you all about how to use this React state management library. Hey, I'm Niklas Ziermann or Nicholas Ziermann if you prefer names that are pronounceable in English. And I'm so stoked to be able to use the freeCodeCamp YouTube channel to show you this course about state management in Zustand. In this course, we'll first of all take a look at why state management is even that important for React developers. Then we're going to take a look at what makes Zustand special as a state manager. And lastly, we're going to create a little Kanban board in Zustand and React to show you what a real world Zustand application might look like. Okay, so to be started, let's first of all take a look at why state management is important. Well, let's just imagine your React app as a little circle. And in this circle, you have two areas that we can basically split right in the middle. On the one side, you got your markup. So basically, your HTML and your CSS, all the stuff that the user can see. And on the other side, you got your logic. So this will be basically your state, because if you look at what React is named after, it's basically to be reactive, so to react to state updates. And that's basically your main task as an engineer. You need to react to changes in state. So it just makes sense to have a really robust state management solution that you can rely on, because that's a foundation all your logic is based on. So yeah, state management is important. And that's why you might want to use Zustand if your state gets too complex. Sure, normal react state is awesome. But yeah, a state manager can really make things easier. All right, so let's take a look at why Zustand is unique in that regard. Well, first of all, Zustand has very little boilerplate, meaning that you don't have to write as much code to get started with Zustand as you would with something like Redux, for example, which is really boilerplate heavy. Next up, it doesn't rely on a provider. So again, this comes down to the boilerplate. But it also means that you don't need to tap into as much React logic and your fewer things you can forget, because in something like a module, which can be used in multiple apps that would provide their own providers, you might forget you provide in one app and then have issues that you could just prevent if you didn't need one. Next up, it's faster than context. Why is that? Well, it uses a little system that allows you to specifically select what state you want to subscribe to. We're going to look at that more closely soon. But for now, it's just important that it is faster. Next up, it uses state merging by default. That means that if you, for example, had a state that looked like this, a is one and b is two, and you wanted to update b, then you wouldn't need to first of all spread your state and then say b is seven, for example, but in something like Zustand, you can just say, okay, I want to say b is seven, and then Zustand will do all the merging for you. This is just a really nice little tiny change that really improves the developer experience, because you have fewer things you can forget, and you have less noise in your code, which again, is really nice. The next awesome thing about it is that it is extendable by default, meaning that you can use different kinds of middleware, some of which are preprovided to give further functionality to your Tushant app, some of which you can even write yourself. So you can hook into the state management process to really make Tushant your own, which is really cool. And this also hooks into the next thing, which is that it's little opinionated. So it doesn't rely on a specific way of doing things, meaning you can basically like and react, decide how you want to interact with a store. Sure, there's a recommended way, but you don't necessarily need to follow it, which again, gives you more options, and of course, some error potential. But still, as a React developer, I prefer things to be less opinionated so that I match up with my way of working with React better. All right, so now let's get to this faster than context bit for that. We're going to create a little comparison graphic down here. So we got our context. And from this context, our component will get state. So like this. And now let's say our component has value a and value b, and some other stuff that you can get from it. Well, in the case of context, you might want to just get value a, but under the hood, you will always subscribe to all of them. So if you just want value a, for example, but where you be changes, then your component will still rerender. We're going to get into if rerunners are really all the bad shortly, but it will cause a rerender, which is something you might not want. If something like value b changes often, because it's something a user can type into an input field, for example, meaning that every input on the keyboard will trigger a rerender, which you might not want on all the many components. So this might actually be not that good for you. So we'll just make it red. Now let's compare this to Sushnet. With our Sushnet store, we can still have multiple values in our store, but our element only subscribes to those that want to subscribe to, meaning that if value b changes, this component doesn't rerender. It just stays the way that it is. But are rerunners really that bad? Well, no, actually not. Sure, rerunners do run React. So if you have some complex React logic, which you should probably have put into a use effect or use memo, but anyway, then that will run again on every rerender, which is not what you want. But again, that's what dependency arrays and custom hooks are for. But it, of course, still isn't what you want that all of this logic runs too often, so you might want to prevent some of it. Again, for fastmoving stuff like inputs, that's exactly what you want. But for something that changes really irregularly and rarely, you probably don't need to care as much about it rerendering too often. And that is because rerunners don't change the DOM, at least not necessarily. Because React uses a shadow DOM, meaning that all your changes are created on a copy of your DOM, and only if there's a difference between the shadow DOM and the actual DOM, will there actually be a command to change the DOM, which is a really expensive part about doing front and stuff, changing the actual DOM. But changing the shadow DOM is not nearly expensive, which is why React uses it. So a rerender doesn't hurt your application nearly as much if it doesn't change the app, which something like a state value that you don't even use in your component can, of course, do. So don't worry as much there, a rerender won't be as expensive as you think it will. So no, it's not like Zustand would be the beallendall of performance gains, but it does still help if you just have really fastmoving data like an input field, for example, where you don't want everything to rerender constantly. So I still think that state mentions are a really, really great thing, and yeah, let's take a look at how Zustand handles state management by now building the Kanban board. All right, so to get started, we're first of all going to need to open our IDE in an empty directory and then run npm create read, which will basically allow us to create a little startup project. Here we're going to, of course, choose React and then JavaScript. You could, of course, also follow this tutorial in TypeScript, but some of the typing is just a little too much for normal JavaScript developers that have never looked into TypeScript. And because those should be able to follow along as well, I'm going to use JavaScript. Then we can just run npm, install or npm i to get all the predefined dependencies and then install one more, which is Zustand using npm i or npm install zustand, because that's going to be our state manager for this project. And then we can just run npm run depth, which will then allow us to spin up a development server on port 5174. And as you can see, this is our development server now. But we are, of course, going to do some changes to this default setup. First of all, in our app.jsx, we are basically going to remove almost everything so that it basically only returns an empty diff with the class name app. So let's do that real quick, like this. And now we should see a blank slate when we look into our browser, which we did. But there also is some default styling applied that might harm us in the end. So let's just head into our index.css, clear out this root bit and remove everything else in here. And what we now want to do is actually add a few default colors I prepared. So these are CSS custom properties, which we are going to be able to use everywhere in our project. These are just some basic colors I prepared for the project to make it easier for ourselves to start things and also modify them in the future if we want to do. Now let's just also head into our app.css and basically remove everything and just add back the app class in here, which is going to have a background of one of these colors, var dash dash color dash gray. And it's going to have a min height, just so it fills the whole background. And then just to head back into our index.css, we're also going to change a bit about the body, which is that it should have a margin of zero. And now if we just head back to our browser, we can see everything is still gray, basically nothing changed. But we're now using our own simplified study. And if we wanted to, we could, of course, also say something like font, family, hell, vetica, which we're not going to see it because we aren't using any text. But anyway, okay, so now before we get into any advanced statement or whatever, we first of all need to create our components. So to do that, we're going to first of all start with our columns. So components, slash column, dot j six, and here we're going to go export default function column. And a column is basically going to be containing all the tasks or to do in a certain state, like planned, ongoing, or done, we're going to have one prop, which is going to be a state, which we're just going to destructure because it's easier to read that way, especially in JavaScript, where you don't have any type annotations. And for now, we're just going to return a div in here. All right, so now let's go into our app and add three columns in here, because we, of course, going to have three states, so one column for each. Now this one is going to have a state land, the next one, ongoing. And lastly, we're going to have done. So now if we just for testing purposes, render a state in here, we should see that we now have three texts in here. So good so far. So now let's just add a class name in here as well, column, and create ourselves a new file called column dot CSS, which will also immediately going to import. So import dot slash column dot CSS. And now we can basically add some styling to our column. So first of all, it's going to have a background color of var dash dash color, ray dark, it's going to have a certain min height, we'll just go with, I don't know, 20 RAM, and we're going to define a color of white or hashtag FFF. Now we just take a look at this, we can see here, all of these already look similar to what we expect them to look like, but we aren't defining any width or anything. And we also are missing one attribute on the app dot CSS, which is display flex and justify content center. We're going to align items at the start though, just so everything is nice and pretty. And now we're already kind of getting somewhere, even though the spacing isn't quite as we'd like it to be. And yeah, some of the other stuff isn't perfect as well. So now let's just head back into our column dot CSS. The width is just going to be 33% because with three columns and each column should take up a lot of space. But we want to give it a max width as well, just so on really large screens, the app isn't unusable. So let's just go with maybe 20 more. Yeah, that looks a lot better already. So now let's just give them a margin zero on the top and one ramp on the sides, just so they are spaced out a bit, maybe with 0.5 frames of one, and also give them a border radius so they look a bit nicer. Or PX. And now we can see we are already getting somewhere. Let's just add some padding of 0.25 RAM, maybe. And our text is also a bit nicer positioned, but 0.5 RAM should be fine as well. All right. So now that we've got our columns, let's get into actually rendering something inside of them. So we want to create a new component, which is going to be task.jsx. And it's going to export defaults function task. And a task is only going to get one prop, which is a title. You're going to see how all of the other stuff is done later when we get to the statement. So now we're just going to return a div in here again, and that div is just going to render the title for now. So and we, of course, also going to give it a class name. So now let's just add a task.css interview, imported, all the good stuff. And now we should already be able to start it. So here, we're going to create a task. This guy is going to have a background color of white, also a border radius, just so it looks a bit nicer again, of four PX, and a min height of, let's say, five frames. But we aren't currently rendering it. So we aren't seeing it either. So let's head to a column just to get started. We're going to go ahead and put this into multiple lines, put this state build in a P tag, and render a task in here, the title of which is just going to be to do for now. And now we can see here is our task, but the text is currently white because this propagates down. So let's just go in here and say color is, of course, going to be black. And now here we've got to do let's just add some padding in here of 0.5 remigan. That's a lot nicer already. And also head to our index.css again, and apply some styling to everything, box, sizing, order box, which is just going to enable us to have the padding inside of the element and not increase it further than its max width or whatever. So now as you can see, here we've got it to do this. And yeah, we basically rendering them just fine now. One more thing we might want to do in here, though, is actually displaying all status as well. So we currently are getting it using a state manager. So for debugging purposes, we're just going to find a constant here, come status equals land. And we're then just going to go ahead and make this guy right here, a diff that contains our title. And then we're going to want to display our status on the bottom right. So we're going to add a repetitive to be able to place it properly. And there's also going to be an item on the bottom left. So we're just going to add an empty div in here for that. And then we're just going to render one more diff, which is going to have the class name status for now. And it's going to contain our status. So now let's just take a look at our site again, and we can see, yeah, it says plant. So now we can head back into a task that sees this. First of all, make the task display legs and align items space between. I'm sorry, we of course going to need to make it flex direction. Column first, and then make this justify content. So that's basically nicely spaced out. And then we're going to get our wrapper real quick, and give it a name as well. So class name is bottom wrapper, make it display flex as well. And justify content space between just so we're able to space it out nicely. And now if we look at it again, we can see our plan is already in the right position. So now let's just go in here and stylus that is a bit as well. The font size is a bit too big in my opinion. So let's make it small. And let's give it a background as well of var dash dash color gray light. Now, yeah, this is kind of better at least, but still not ideal. So now we can actually go ahead. And first of all, give it some padding. Here, we're just going to go with 0.25 rim and another border radius of 4px again. And now this already looks a lot nicer, but we might also want to change its color depending on what set it is currently in. And for that, we actually going to add one more library by using NPMI class names, which is basically a library that simplifies adding multiple class names to a component and also rendering them conditionally. So now we can just get into a task right here and say the class name of status is not just status, but class names, which takes in status as a first element, and then our status variable as a second argument. Just so we basically got a class name planned, a class name ongoing and a class name done. Now we can just define them in here. So planned, ongoing, and lastly, and here we can now override some stuff from here. For planned, we are basically not going to overwrite anything. So we can just copy this over. For ongoing, we're going to go with color ongoing. And for done, we're just going to go with color done. But now let's try this out. Planned, of course, always looks nice. Then let's go with done here. Perfect. And ongoing should look nice as well. And it does. Okay, so now we basically got our basic styling and markup done. So let's get into actually using sushi done to manage our state in here. So for that, we're going to create a new file called store dot JS. And in here, we're first, we're going to define a variable called store, which is basically just an arrow function that takes in a set as a parameter. So basically a state set up for the whole store. And it's going to return an object. And that object is basically going to contain everything we have in our store. So for now, that's just going to be a set of tasks. And these tasks are just going to be an array. And we're going to add one sample task, just so we can debug, we're going to remove that at the end. So a task is going to have a title, test task, and a state. And that state is for now, it's going to be planned. And then we can just say export on use store is equal to create for tuition, which is going to take in our store. And now this easily, we basically globalized our tasks, we of course can't manipulate them yet. But that's going to come shortly. For now, what's important is we can head into our column, and actually get our tasks automatically. So to do that, we're going to go ahead and say, const tasks equals use store, be careful to implement import your own use store and not the one from tuition. And this basically takes in a callback, because normally when you're using something like use context and react, every change to the whole context would update any consumer, even if it doesn't consume the element that changed. Here, you can really selectively go ahead and say, okay, from our store, I only want to get store that tasks. So only when the tasks change will this component rerun, which is really nice. And for our case, we can go even further and say tasks that filter. And we only want to get those tasks where our task that state equals our prop state. So basically, these tasks will already be filtered to only contain the tasks that we need to render. Okay, so there's one thing we need to be a bit more careful about here, because this filter is actually a mistake, because whenever the return value of this selector changes, then Sushant will cause react to create a rerunner. And if we take a look at it, a filter will always create a new instance of an array. Even if the content of the array is the same, it will still create a new array. And the new array is a new value. And therefore, this component would rerun. So there are multiple ways of solving this, one of which being, we just remove this filter bit, then we got a task here. And then we go const filtered equals use memo. And then we just go ahead and say tasks, copy your filter from up here, and put just what we need as a dependency array, which is the tasks and our state. And now we basically have the react solution for this. So use Sushant as little as possible, and then use filtering to get your required value. But this can be done even better, because we can actually go ahead, leave this filter as this, and then use another function that Sushant provides, which is a comparison function. So if you want your component to only rerun on certain conditions, then you can add an equals function here. And Sushant actually gives you one of these functions, which is shallow. And together, you just go ahead and say import, shallow, run, Sushant slash shallow. Now you basically have a comparison function here that will check if the content of the array changes are not if they're array changes. But if you aren't a fan of this building function, that's fine as well, because maybe you don't like the name, maybe you don't like to import it every time, you can also create your own function, which takes a previous value and the next value. And then it will return either true or false, depending on if it's equal or not. So what we're going to do is we're going to first of all go ahead here, and check if the length changed. So longest equals previous dot length, bigger next dot length. If so, we take previous dot length, otherwise, we take next dot length. So basically, we evaluate whichever one of these two is longer. And then we save that length as a number. And now we can just go over here in a for loop. So let I equal zero, I smaller longest, I plus plus, then refer to one need to check if both of these exists. So if not previous I or not next I, then we want to of course return false, because they can't be equal if one of these arrays is longer than the other one, which we basically check by doing this. And then we can do the next check if these are unequal to each other. Then they of course can't be equal to so we return false as well. And lastly, if we went through this whole array and didn't run into any situation where we return false, then we return true. And now we basically have the same comparison function only if we don't import this shallow bit right here, but that we write it ourselves. Be careful with this though, because again, this runs whenever anything in your store updates. So if you make this comparison too complex, then it will of course run very often and might be a performance issue. So Tushan wants to improve your performance, but you can of course go ahead and break it anyway. And remember, only run filter map or whatever inside of a selector if you use either shallow or your own comparison function. And if you don't do that, then yeah, maybe just stick to a use memo, because the normal react logic will probably work just as fine as well, and might even be a bit more understandable. For our use case though, shallow is absolutely fine. So let's move on with the course. Now we can just go ahead, add some code in here, asks dot map. And for each task, we're going to go ahead and return a task. And the title is of course going to be task dot title. And you might also want to add a key in here. In our case, that's also going to be task the title, because we expect the user to only define each title once, otherwise our application is not going to really work properly. But if you wanted to change that, then you could of course always go with UUIDs or whatever, we aren't really going into using IDs here yet. Because that would just be too much for this tutorial. But if you wanted to implement them, be free to do it. So now let's just check this out again. And we can see we only got one task that's currently ongoing. So that's not right. So let's head into a task. And also use the store again, because we only get the title here, not the steps. So const task equals use store again. And here we want a callback again. So store. And here we want store dot tasks. But find that specific task, where task dot title is equal to a title. So basically, give me the one task that exists that contains the title I got as a prop, so that it can get all the additional information I need. And now we can just go ahead and render task dot title in here, and also ask that status or state instead of the global status variable, which we can now get rid of. And now if we just look at it, we can see we got a mistake. Okay, what is it? Let's take a look. We can see state is not defined in task. So this happened in here, because we did define state here, but not task that state. So now let's look again. And we can see our state is right. And our task is at our correct position. So to prove ourselves here, we're just going to go ahead and call this ongoing now. And now it's in the middle and blue, which is exactly what we wanted to. So now we're basically already rendering the task correctly. So let's go ahead and try to add sun using a little add button we can add ready. So let's first of all head to a column and create this little button. But look, we first of all going to need a diff again, to basically display all of these things next to each other. And then we're just going to say button at this is going to have the class name title wrapper. And then we can just access the button using the title wrapper. So task that CSS that column that CSS sorry, title wrapper is going to be display flex and justify content space between. And now we basically got our add button over here and our ongoing overview. But we of course also want to change the styling of the button because it doesn't look all that nice right now. So let's do that as well. And here we're going to use something really interesting, which is all unset, which is basically going to remove all our default styling from this button. So we just take a look, we can see now we only got this ad bit right here. And then we can manipulate it any way we want. So I want it to be color black and background white. Then I want to give it a little bit of padding. So 0.5 rem and the border radius of four px again. So now this doesn't look all that nice because it currently fills in all the height we've got. So to fix that, we're going to go hide it content. And now it already has the right height, but it isn't centered it. So to fix that, we're just going to go here and say align items center on our title wrapper. And now it already looks kind of nice. So let's just add a little hover effect in here. And in here, we're just going to say background is var dash dash color. Gray light. Now if we hover over here, we can see, yeah, it actually looks kind of nice. Let's just add a cursor pointer. And then we've got our basic button. So now let's head into a tuition store and actually allow us to add stuff. So here, we're just going to add something else to a store, which is add task. And add task is going to be a function that takes in a title and a state, because those are the pieces of information we need to add a task. And then it's going to run the set function, because we of course want to manipulate our store. And here, we will just take an object and tell it what we want to manipulate. So I want to manipulate the tasks. And here, we now need the current tasks, which we don't currently have. So we need to change our set a bit to give us the current state of the store. So just like in a normal use state, you can actually also use a callback to get the current value of our state right here, which is an ideal because we called this state as well. So let's just call it store. And then we can say we want to use all the current tasks. So store that tasks, we're going to spread them. And then just add one new element using our title and our state. And now we're basically taking our store and adding one new element to this array. So let's head back to our column and allow us to add something to it. So for now, we're just going to test this out by saying on click. And we still need to import the function. So on click is just going to be empty. And we can say const add us equals use store again. We're going to get our store and say store that add task. Now we imported the add task function. And here we can just say I want to add a task. The title is going to be a fixed string for now because we didn't add an input yet. And the state is going to be the state we get as a prop for a column. And we're just going to add the state to the string as well. So that's unique. Because as I said, we can't have the same title twice. So for testing purposes, this is absolutely fine. So now let's just add one here. We can see this is planned. This is ongoing. And this is done. And we might want to add some margin in here for things to look nice. So let's do that real quick. Task margin button 0.5. And yeah, that looks a lot nicer. Now let's go ahead and allow us to add custom text in here as well. So for testing purposes, we'll just add this again and say that we want to allow us to input stuff. So just like normally in react, we want to use state for that text and set text equals use state. And the text is of course, by default, empty. And then we're basically just going to do this using a motor that can open. So open and set open is of course also going to be a variable that's initialized as false. And we're going to say when we click this button, we're going to open the model. So set open true. So now let's just add this little model as well by adding a diff with a class name equal to model. And in our model, we're just going to add another diff that's actually going to contain our model content. So class name, model content. And here we'll just add an input with an on change that on change is of course going to be just as normal in react. So set text to e dot target value. So we can actually update our input and the value is of course going to be our text. And we can make the self closing because the input doesn't have any content. And now let's just add another button in here. And that buttons on tick is now going to actually allow us to do a state update. So if we're going to first of all go ahead and say, add task. And add task is going to get our text as a parameter and our state from our props as another parameter. And then we're going to say set text is now an empty string. And we're going to say set open false. And first of all, rendered conditionally. So open and add. If we're not open, we're not going to render this otherwise we will. And now let's just go into our column and say dot model is going to be position absolute. It's going to basically be a little background we're going to render so that everything is kind of darkened out and not clickable. So background is RGB a completely black, but kind of these three. So 0.3 as an opacity. It's going to have a width of 100% and a height of 100%. And it's going to be positioned on the top left. Let's just check this out real quick. Now we did make a mistake seemingly, which is that you state is currently not defined. Which is fine. We can just import it quick. So import use state from react. Okay, so I did need to add a little cut in here because my terminal crashed for some reason. But let's move on. We can now hit add and we can see here we got this gray area where we can't click through. And we got these two elements. Let's now add a little bit of extra styling for our model content as well. So let's copy that class name model content and style that as well. So model content is going to have a background in white. And it's also going to be position absolute going to get its z index of one just to make sure it's branded on top. And a padding of one ramp. And then of course it's going to be top 50% left 50% and transform translate minus 50% minus 50%. And we can see that now everything is centered. We do have some graphical issues, which I can't really explain currently to be honest. But we can fix these quite easily by just giving a bit of extra height or basically whatever we want. So currently I'm using padding. So let's just add a height of, I don't know, reram and width of 10 ramp. And now if we just head back, you can see, okay, 10 ramp is not enough. So let's make a 20 ramp. And also say, display, legs, and justify content center. To also make this five ramp in the line item center, just so it looks a bit nicer. And now we got this little model ratio, which you can also add the polar radius to. Now let's just add a test text in here, click add, do the same with done, test to add. And we can see everything works in the way we'd expect it to. So now let's also add a way to delete tasks. So first of all, we're going to need to head into our store again, and allow us to actually delete them at all. So let's just copy this over so that we've got the basic pattern. And call this delete task. But that we're only going to need title because that's basically already ID for this project. If you're using an ID, then you would of course need that. And then we can just say tasks is now, or dot tasks, dot filter. And we only want to get those tasks that don't have the title that we ended. So we want to filter for all the tasks where the title is unequal to our title. And then we're basically leaving them because we're overwriting the initial reference for the task. So now we just need to wait to delete them. So let's head into our task and fill in this empty thing we have here. So this is going to be an image. And that image is going to get a trash icon. So I've already repaired it. So let's just put that into the assets folder. And delete this react.svg. And I basically got this from fellow icons if you want it as well. But that's not as important right now. What is important is we can now import it. So import trash from dot dot slash assets slash slash dash two dot SVG. And now we can just add this as a source for image tag. And also give our image taken on click event. That is going to throw this thing in the trash. So we're going to need to import that so const delete task equals use store store becomes store that delete task. And now we can just run delete task with our title from our props. And everything will be just fine. Or we could also go with task the title. If we want everything to be a bit more secure. So let's just try this out. We should see our icon in here. But we currently don't because I seem to have made a mistake, which is that I used trash as a string instead of as a variable. Sorry for that. And now if we just reload again, we can see our little trash icon here. And if you click it, our task is gone. We might want to change some stuff about it like, for example, the size or whatever. But as it's just image tag, it's really simple. We can just go with task image and say height is, I don't know, 1.5 rem. Let's try this out real quick. Yeah, that didn't really do anything. So let's just go with 0.5 rem, go a bit to the extreme. And we can see, yeah, that works. So let's go with one rem. I think that does look kind of nice, maybe 1.25. And yeah, and also add a cursor pointer. And now we can delete task in any way we'd like. So we can add task, we can delete tasks. The only thing we can't currently do is move them. So let's get into doing that using the drag and drop API from our browser. So let's start with the easiest bit, which is actually making something draggable. Because for that, you can just head to a task.jsx and give the wrapping diff the draggable attribute. And we now just head back into our browser, we can see, yeah, we can already drag and drop this. But it currently doesn't really look that nice because you don't really know that it's draggable. So let's just head into the CSS as well, for a task and say cursor, move. And now you can see, yeah, that's a good indicator that something is movable. Okay, but if we drop it here, then nothing happens. So let's also add a listener for a drop onto our column. We can just add it on the utmost part of our column. And to get started, first of all, we're going to need an on drag over. And this is basically just going to be a listener for when an element is dragged over our column, which we currently aren't doing anything yet. But one thing we need to do for our drag and drop to work properly is say, e dot prevent default, because by default, the drag and drop API already does some stuff like opening files and new tabs and stuff. And it won't react to our events if we don't prevent this. So we're just going to do that. And maybe we'll use the on drag over later for some more stuff. But what's really important is the on drop. Because what on drop does is actually react to something being dropped on this element. So again, this is going to be a function. And that function is for now just going to console that log drop. So let's try this out, open our inspect element and our console and drop something and we can see, yeah, it was dropped. So now let's head into our store. And actually, first of all, persist what element is being dragged, because currently we can visually drag stuff. But we don't persist what is being dragged. So for that, we'll just add dragged task as a new crop, which can be now or a title. And we're going to need a set of for that as well. So set dragged task is going to run set inside of a function that takes in a title. And we'll just say dragged task is equal to that title. So now let's first of all head to our task to set this set dragged task equals use store and store becomes or dot set dragged task. And here we can now say on drag start. So when we start dragging the element, we want to set drag task to task that title. And then we, of course, want to do the same thing in here, which is set dragged task to now, because when we drop something, then we, of course, aren't dragging anything anymore. So we can set this back to not. But we, of course, need to import it up here as well. So const set drag task equals a good use store with said dragged task. And we also need the dragged task in our column to be able to know what we actually dropped onto our column. So dragged task equals store that dragged task. And now in here, we're just going to go ahead and consider log the task that was currently dropped onto our element. So let's try this again. And we can see, yeah, test task was dropped here. So now we can basically implement our movement already. So move task is going to be our next function that takes in the title and in new state, run set using the existing store again. And then says, I want to return an object of tasks. And here, we will actually map over each task store the tasks that met. And then for each task, we want to make a check. So if task that title equals our title, then we want to create a new task element. Otherwise, we want to use the current task. So basically, we manipulate the task. If the title is the one we want to move, otherwise, we just keep it the way it is. And here we can just say, okay, well, new task is going to be title and state. And that should already be plenty. Now we can head back into our column, import the move task as well. As you can see, the column has a lot of this logic, move task, and move task. And now in here, we can just say, okay, instead of considered logging the drag task, I want to move a task, which is drag task. And I want to set it to the state. Let's pass in as a prop to this column. So let's try this out. And as you can see, it works absolutely awesome. So now we can add tasks, delete tasks, move tasks. We basically got all the functionality, but it currently doesn't look old at nice. So one thing that would already improve things a lot is if we gave an indicator that things can be dropped in here. So for that, we can just say const, drop, and set drop is equal to use state false. So this is basically now going to be a Boolean that we're going to use to indicate whether or not we can drop onto this column. So here we can now use our on drag over function, which we're going to say, set drop to true. And then we're of course going to need one more, which is on drag leaf, which is basically going to be really similar in the way that we can basically copy it over completely. And just say false in here. And now we just need another indicator in here. So let's just go to the class name over here and say, class names, our default class name is of course going to be column again. So that's going to work absolutely awesomely. But we're going to render one conditionally using an object. And the way this object works is your key is basically going to be the class name that's applied. So in our case, we're just going to say, our class name is drop. And then the value is going to be the condition under which this is applied. So in this case, our condition is just going to be drop as well. And now if we just head into our class names for the column, and say dot column dot drop, then we can just give it a little border dashed white. And maybe we make it 4px white. So let's try this out. And we can see, yeah, it works, but it kind of displaces everything. So we can fix that as well, because the border currently makes things wider, which isn't ideal. So what we can do is actually give this border to a column by default, but make it transparent. And now if we just change our border color in here, white, then we can see, yeah, everything is working in the way we intended to. But our drop is currently not being reset, which is not ideal. So we are resetting it on on drag leave, which we saw worked. But an on drop is not also triggering on drag leave. So what we need to do is also setting drop to false inside of our on drop. And now if we move things and drop them, we can see, yeah, the indicator is removed, and everything still looks really, really nice, which is just awesome. So now we basically got a functional app. So we can add some extra stuff here, like, I don't know, by bananas, bananas, or whatever, add some additional stuff, just so we can see that these things are also growing dynamically, which they are. But one more cool thing we can do is actually integrate this into Redux, basically. So we are really integrated into Redux random environment, but we can actually use the Redux toolkits using sushton, which is kind of cool. So let's just download this real quick. So Redux dev tools, Chrome. And then we can basically debug our whole state management using Redux. So as you can see, I've already installed it, but you could do it just here. And yeah, we can now just use these if we went ahead and imported dev tools from sushton slash middleware. And now we can just go down here, use these as a middleware basically by saying create dev tools store instead of just create store. And now if we open this and reload, we can see this is now open. And if we change something or add something, we should see that there are no changes in here. And we can basically just go through this and see every change to application, which is really amazing for debugging. But you might not be a fan of this anonymous bit. So let's fix that as well, because all of these set functions actually take multiple parameters. So the first one, of course, is set. Next one is a Boolean. This Boolean will tell sushton whether or not to replace the whole store with whatever is in this object, or whether to just manipulate all the objects that are changed in here. So we just want to change the tasks and not the drag task or even the set of functions, because that's just wasteful. So we can keep this at false. And then the next one, which is really cool is the label. So here we can just copy over this add task, for example, then we've got this label that if we now just reload and add a task called test, for example, and head back to our toolkit, we can see this is now called add task. So you could basically call this whatever you want and make it easier to debug your stuff. So I think this is awesome, especially that they even went to the effort to use another library's dev tools inside of their own ecosystem. That's just amazing in my opinion. But of course, no app would be complete without the option to also persist our state, which is also something that sushton middleware offers us. So let's take a look at how to persist our store inside of local storage. To do that, we'll first of all head back to the store, the JS file, and then import the persist middleware from sushton slash middleware, which we can also use in our create function right here as a wrapper around our dev tools, for example. And then we'll just need to pass an options object, because this function will actually not work without certain options. The most important of which is the name, because the name will be the key under which everything is stored in local storage. And in some versions of tushton, you might run into issues if you leave this undefined. In others, it might just use the world undefined as a key, which isn't ideal either. So for now, we'll just go with the name, which is store. So let's try this out, reload real quick, move our test task over and add another test task. Let's just call it test reload real quick. And we can see, yeah, everything is persisted just fine. If we now just take a look at our dev tools, under application, and local search, we can see here's a store and a store contains our full state with our draft task and our tasks. The functions, of course, aren't in here, because those aren't required to be persisted anyway. And now that we've, of course, persisted this, we can also head back into a store and remove the default task we added in here. So there are tasks are now empty, because it, of course, doesn't make sense to have a default task in an app where you want to add your own customized task that is special to you. But that shouldn't change much now, because it's persisted anyway, if we move something that will be persisted as well, of course. But as I mentioned in the beginning, this is, of course, extendable to any degree. So you can even write your own custom wrappers. So if, for example, we wanted to create a custom middleware that just locks every stage change, then we could do this like that. So const lock equals config. This is just a way to manipulate the existing setters and getters and stuff. This will be a function and that function will return another function that has the default setter, getter, and API. And that function will then return as a config. And that config again, takes three parameters, a setter, a getter, and an API. So in here, we can now just say our setter will be overwritten. So any arcs we give to it, will be locked. And then we'll just run the default setter again, so that we don't break anything. So we basically just intercept our setter so that we can console lock something, and then move on with the default logic. And now we just need to pass the default get and API in here, because we don't want to overwrite those. And if you now just try this out by wrapping this around a middleware as well, like this, then we should see if we open the console, that everything we do is locked now. And what will be cool, the initial one will actually be a setter where you set all of your default state. So if you wanted to, for example, create your own persist middleware, then that would be possible as well. We just need to change the order of our middlewares here, because we of course need to run lock without this persist bit in there. So we just get rid of that like this. And now we could do something like const current equals get. And then if not current, so if we're in the initial render, where current is not defined yet, then get state from external props. So here you could do something like a custom middleware that would sink to your own custom service that persists your state if you wanted to, which might also be handy for you. Who knows? What this is supposed to show you is that sushi and is really extendable. And that you can basically build it to do whatever you want with it, which is really, really nice. But yeah, log a middleware should be plenty for now. So let's just undo all of this. So we get back to what we had before with a girl persist. And now we still have a little example of what a custom middleware can look like, but we also still persist stuff, which is quite nice. But now that you've got your store set up, it might be helpful to also be able to unit tested to make sure that it will also work in the future. To do that, we're going to use V test. And if you help our libraries, the most important of which being testing library, both for JSTOM and react so that we can use JSX and all of our react logic, and also the JSTOM library, which will allow us to actually use JSX, as I mentioned before. So now let's just go ahead and NPM install these really quick. You can just do all of this in one line and save everything as depth, because none of this will be needed inside the production build. And then whenever it's done, we'll move on. Alright, so now that it's done, we need to head in our vcon.js and add a little test block here. So this is basically a config for v test. Here we define we want to test. We want to allow overwriting globals and using globals. Our environment is going to be the JS DOM library we installed before, to be able to use JSX once again. And then we also need setup files. And in this case, this is going to be dot slash setup tests.js. So let's just create this file real quick. And then here we basically just need to set up the default config for v test. So we're importing expect and after each from v test, we're importing a cleanup function from testing library react. We're importing matches from just DOM. And we're basically importing all of just DOM as well, because this needs to be imported once for everything to work properly. And then our expect function from v test will extend the matches from just DOM. So it will allow us to check for DOM manipulation stuff inside of our expect function. And then after each test, it will run a cleanup function from react to basically clean up all the virtual DOMs and stuff. So we don't run into any memory leaks or whatever, which is also quite handy. And now we basically just need to head into our package JSON, run test in here, and say the test executes the v test library. And now if we just went ahead and run npm run test, then we should see that the test is executed and that it can't find any tests, which is correct. So let's create one, we're going to head into a source directory and run store.test.json. This is going to need to be called JSX, because we actually need to mount our custom hook that's created from store.js inside of some component. And to do that, we're of course going to need a JSX component. And to make sure that everything in here now works, we can create a little sample test sample, which takes in a callback. If you already know v tests, and this will seem really familiar to you, if not, then that's fine as well. And then we can just say we expect one, two, equal one. And now if we run our test, we should see that this is true, because one is of course equal to one. And we can see, yeah, it passed. So everything is absolutely fine. And now we can actually start with all of our logic. And to get a logic to work, first of all, need to create a test component in which our hook will be used. So function, test component. And this test component will take two props. A selector, we want to run in our hook, and an effect that will run whenever the values in our hook change. And then we can just create a little function here. So we first of all say const items equals use store. So a little store that we currently can't automatically import. So we'll do it manually. And then in our store, we're just going to run the selector. We're going to return now, because we don't need any return value from this function right here. And then we'll just run a use effect in here, which will run our effect with our items. And it will of course run every time that our items change. And now if we want to see how our items react to certain events, we can just check what happens inside of this function we pass in. And if what happens inside the function is what we'd expect, then we of course know that our items changed according to what we want them to be like. If you don't understand this yet, then don't worry, we'll get into it shortly. All right, so we can now get rid of this example test and create a second one, which is should return default value at the start. This is normally not something you would need to test, but just so you get used to this, we'll test it anyway. In a production build, you of course don't need to check if two stunt does what it's supposed to be by returning a default value. But in our case, this can't hurt. So now we can just add this callback function again to our test. This is basically just the label we give the test to make sure we can identify it later. So if the test were to break, then it would give us this label. So we know which test broke. And then we can move on by actually saying we define a selector. So a selector equals door. And for the store, we want to store that tasks. So basically, we just want our store to give us the default tasks. And then we also create an effect. So const effect. And our effect is actually going to be a special function, which is vi. So a function from we test that FM. And this is what's called a mocked function. So a marked function is like a normal function can be executed at runtime just normally, but we can actually check if it was called. And if so, with what values it was called, which is really helpful for testing. So what we can do now is we can go ahead and say we want to render from react testing library, our test component. And then we of course pass our two functions. So a selector is going to be a selector. And our effect is of course going to be the effect. And now just to add a really simple test in here, we can say, I expect the effect to have been called with. And then we can basically supply it with what we expected to have been called with. And in this case, we just expected to have been called with an array and an empty one because the default value of a store is of course an empty array. If I change this to whatever else, like an array that contains one, then it would fail and tell us, no, this has not been called with an array that's containing one, it has been called with an empty array. So as you can see, our first test that's actually using our little component right here is actually working. So what is happening here, we use a selector to get our items. In this case, our items are just the tasks. Then we put it inside of our effect, inside of this use effect. And then we check was this effect called with an empty array, because that's the default value of our tasks. If so, then everything is absolutely fine. And it is. So now let's get a bit more complex by actually copying this over first fall. And it should add an item to the store and rerun the effect. So now we will try to actually add something to the store inside of our effect. And if that works, then we know that the effect should run again, because we of course changed our store. And yeah, that should work. So here we'll now go ahead and say store doesn't just return store the tasks, it returns store the tasks as tasks. And it will also return and add task function. Add task is store dot add task. And now our effect, of course, can't run this way either. So we need to give it an implementation. So we can say mock implementation, because we of course can't make this a normal function, because then we couldn't check for this function to have been caught with. So by adding a mock implementation, we can still make this function do stuff without needing to get all fancy about how to check if it was called or not. So here we can now add a bit of an implementation, which will of course need our items to be passed. And then the implementation will just go ahead and say if items dot tasks, that length equals zero, then we want to add a task. So items dot add task. And our task will have a title of a and a state of b, these don't need to be valid tasks right now. So this is absolutely fine. This way we've been basically go ahead and say, if it's the first time that this function runs, because it will of course run again, as soon as we added a task, then please add a task. Otherwise, just do nothing. And now we can actually check, okay, what has this function record with? Well, it has of course been called with an object that contains a task and a task array. But before we do that, or before we fix this, we can just go ahead and say, I expect my effect to have been called time. And I expected to have been called two times the first time, when the initial render happens. And then the next time, when I added the task, because this will change the state, and the state change will of course trigger this user effect in our component up here again. And as you can see, this one absolutely smoothly. So now we can of course change our expects down here as well. And say, I expected to have been called with expect dot object contained. So basically, I expected to have been called with an object. And that object should at least contain tasks. And these tasks should course be an object. And that object contains basically this ratchet. And now if we check this out, we can see it doesn't quite fit right because I actually messed up a bit. We of course aren't passing an object to add tasks, but we are passing parameters. So a title and a state as two separate parameters. And now if we run this again, then we can see it passes. So I just messed up here a bit because I forgot what our ads task logic looked like. And because we aren't using typescript here, we don't get proper typing in for this. So if you were to do this, then yeah, maybe consider using typescript, even though it might be a bit more complicated than what I'm showing you here. But as you can see, the test now passes because tasks does contain this object. And everything is fine. So let's just add one more test, which is even more complicated, because we now wanted to add an item. And then we want to actually delete an item. But if we now were to go ahead and say else, if items dot tasks dot length is one, then we'd of course run into a loop because we create a task, delete a task, create the task delete a task. So we need to somehow persist if we already created the task. And that's actually quite easy as well. We can just say, let create a task equal false, then we can go ahead and say, okay, if not create a task, then create a task, create a task is true. So basically persist, if we already created the task, and if so, everything is absolutely fine. And now we just need this delete task up here. So the lead task will of course be store dot delete task. Now we run into our first problem, because the solution store is actually not cleaned up after each test. So in our first test, we added a task. And now in a second test, we add a task as well. So this water state looks like in the first test, before anything runs at all, we already have a task, then we add another task, and then yeah, everything just breaks down terrible. So we need to fix that. And Tushton actually offers a solution for that right in their docs, which is we need to mock some part of Tushton. So let's take a look at how that will work to clean up our stuff here. All right, so to do that, we're first we're going to need a new file, which is underscore underscore mocks underscore slash sushton.js. So basically inside of the mocks folder, we want it's sushton.js file. And here we're just going to paste the default config from the Tushton documentation. And we're going to go over each line to see what it does. So as well, we got two imports here, those aren't really that important. But the third one is so we're importing an actual create function using vi import actual sushton. So what this means is we are now mocking logic from sushton. So we're basically removing all of the default sushton logic that's exported from the Tushton module. And to be able to still use it, we need to now import it using vi dot import actual to get the actual create function. Then we need to create a set of all our stores, because whenever a test runs through, we will need to reset the state of our stores. And to be able to do that, we just save them in a set. So if a store exists twice, then that's not a problem. The set will get rid of it. And yeah, we can use it later to clean up again, which will happen here, because before each test, we run store reset functions for each reset function, reset function. And what a reset function does is actually in here, because it just sets the state to the initial state and overwrites everything, which is absolutely fine. So now let's get back into this logic routine. So as you can see, we are exporting basically an overwritten create function from sushton, where we first of all run the actual create function to get a store, then we get the initial state of our store using store dot get state, create or reset function to use it before each test. And then we just return our store. So basically, we wrap around the normal create function from sushton, add our own little extra bit here to be able to do this before each to clean up our tests. And then we just return the store. So sushton doesn't even know really that anything is happening here. So now we can just save this tushton.js file in here, head back to our store. And then on the top of our test files, we just need to run vi dot mock. And we need to pass sushton. So basically, we want to mock the library tushton. And as you can see, now our test is breaking, because we expected it to run twice, but it run ran three times. So now let's change this. And now our test passes again, because in run render, it actually was run with this set of items. So here we can't check with to have been called, but we can use a really similar logic to this created task bit here, which is let current items and current items can either be undefined or the return value of our items ready. So we can just say on every run through effect, we want current items to be set to items. And now when I test down here, instead of checking if the function was called with anything, we just go, I expect current items to equal, and then I can pass an object here. But because I only want to care about the tasks, I want current items to task to equal an empty list. So I created task, then the list will, of course, change to what happens up here. And then when I delete the task again, then the list will, of course, be empty in the end again. So by doing this, we can basically make sure, okay, did the delete task run through, because we know that add task work by the test up here. And if it did, then did it actually do what we intended to? And we know that it does. So we now tested add task, we tested delete task. And we also tested the default solution logic, which we don't necessarily need to. But anyway, this is basically how you would test your store, which is actually quite important. Because if you think about it, the store is the most important part of your app, because if it has any logical problems, then those will just spread through all of your state logic in all the other parts of your app, which you really don't want to happen. So yeah, make sure that your store is properly tested using this concept or whatever other concept you want to use. I think this works pretty fine. And yeah, I basically showed you a multitude of ways you can do this using current items or using object containing or basically whatever you want. I really like this current items way to be honest. So yeah, do care about unit testing when it comes to something like this. And make sure that everything works properly. So you now have a fully functional solution based camera board. And it's actually tested as well, which is quite nice. But there are four more features that I want to show you that don't really fit a camera board topic as well. But it is still really cool. So let's look into them. And the first one is that actions like this ad plus right here can actually be async. So what you could do here is you could actually do a fetch request inside of one of these actions, then store this result inside the store. So you don't need to create your own service class or whatever to do fetch requests. You can basically just use your store for that. Because again, if you're fetching something, then you're interacting with state. So it might make sense to put your fetches into the store as well by making actions async. Next up, we got another library that you can use with tuition being immer. So if you just go ahead and run MPMI immer, then we'll basically get a little library that will allow us to do state manipulation a bit differently in a way that you might prefer over spread bread. So if we now just change this ad task a bit by going in here and running produce from immer, then we'll basically get a callback in here. And in that callback, we can do whatever you want with our state. So we can manipulate it in a normal way. Like for example, store dot tasks dot push. And then we just push the item we added before using the spread operator, like this. And now we still have a completely valid store. And if we went ahead and tried this by adding something new, like asked 25, for example, then we can see that is still working. So you basically get rid of all of these spread operators, which is quite nice for people who aren't as used to this kind of syntax. And also for big objects that have a lot of nesting as well. Like if you wanted to manipulate an object like this, which would be really annoying because you need to spread aid and be and then change C. In this case, you could just go ahead and say, okay, a dot B dot C equals eight, for example, which is a lot nicer to handle. But then again, for something simple, like an array, this is really nice as well, because a push syntax just has less noise in the code than spreading the actual tasks, overriding them and all that stuff, you just have a really clean setup. And one more really cool thing we can do is basically react to state updates without needing any react. So we can basically create our own little use effect only using the store. And the way that that works is we can say use store, but subscribe. And this subscribe basically takes in a callback that takes our new store as the first parameter and the previous value of our store as a second parameter. And then we can do something like if new store dot tasks is unequal to previous store dot tasks. So if our tasks changed in this update to a state, then we want to say use store dot set state. And here we could do something like tasks in ongoing. And we then want to set tasks and ongoing to the number of tasks that are currently on your and to do that, we can now just say new store dot tasks. And then we want to fill there for each task where tasks that state is equal to ongoing. And then we want the length of this. And now we of course need to add this in our store as well, which I've already done up here. And we now take a look at our app and move something to ongoing. Then we can look at our logar middleware and see task and ongoing is now two. And if we do it again, then we should see the task and ongoing is now set to three. So whenever this updates and task and ongoing is going to change, and be the according value that we need. But of course, needing to do this if check every time that the store updates is a bit annoying. So what you can also do is actually do this with a selector. And for that, we will need subscribe with selector as another middleware that we can just put around our other middleware. And now our subscribe will change a bit, because we can now add a selector to it, which will be store. And I only want to act when the tasks change. And now these will of course be the new tasks. And these will be the previous tasks. And now we can say this if gets removed new tasks dot filter. And that's it. And now we try this out once again. And take a look at it, we can see now task and ongoing is two. And now task and ongoing should be one. So we basically are only reacting to whatever our selector says. Of course, the if check is still done in the background. But for us, this is just a little bit less code that we need to write, which is quite handy. And the last thing we want to do is actually tied to this subscribe pattern as well, which is we can actually store state and refs as well, if we don't want the component to rerunner when the state changes. So to do that, we're just going to create a little component right now that's going to be a ref test. And ref test will basically store our tasks in ref. We don't need to do this right now, because our app doesn't really have a purpose for that. But if you had something like an input field that's stored globally, and some component needed to react to it, then this would be a really nice option of doing that. And now we can just say const ref equals use ref for this example, we can just return ref.current and run a use effect, which is going to initialize our subscribe really soon. It's of course not going to have any dependencies because it doesn't need to have any. And then we can just say, use store.subscribe here, we first of all now need our selector, because we added the subscriber selector middle where our selector is going to be store becomes store tasks. And then our second function will of course take in these tasks, and do something with them. And in this case, we're just going to go ahead and say ref.current is equal to tasks. And this way, we basically now have a component where our ref will always stay up to date with what our tasks are without the component actually re rendering. So if some other state updated, then we can use our tasks. But if no other state updated, then we of course also don't need to re render, because this component doesn't require that for whatever reason. And yeah, we basically now have the task listed in here without causing re renders, which can be quite nice. Okay, so you should now have a fully functional cabin board. Sure, there are some things to work out. Like, as I mentioned, using a title as an ID isn't really ideal, you might want to change that in your example to replace it with something like your your idea or whatever. But yeah, that's a challenge that you can work out, not me because that would just be too much for this course, as I mentioned before. And also, some really minor things you can work out is currently, if I drop something outside of these columns, it doesn't reset the drag task, which isn't really a problem, because I can't drop anything onto ongoing or done if I'm not dragging anymore. And as soon as I start dragging something else, drag task exchange. But yeah, for debugging purposes, it might be helpful to change this. Anyway, I'm really grateful for the free code cam team to allow me to post this course onto their channel. And I hope you subscribe to them if you aren't yet. And I also hope that you'll check out my channel. I don't do videos this long, but I do do some really interesting react stuff, at least in my opinion, and I think you should check it out if you're interested in learning more about react. So I hope you'll have a good day, and I hope you'll check out my stuff, and also the other stuff on free code cap. Have a good day.