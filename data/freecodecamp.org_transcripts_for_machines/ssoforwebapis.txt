okay welcome nice to meet you to one of the most annoying topics of development security okay my name is nico quibbler i'm from germany i'm a freelance guy and i'm more than 20 years in i.t business i recognize it a few weeks ago when i got my new fitness tracker it has a very small display and i have to put my wrist far away from my eyes so i'm getting pretty old um besides my day job i coorganizing a local java user group in darmstadt it's nearby frankfurt and speak occasionally at tech conferences all over the world and last year i wrote a book about serverless computing in the cloud but that's not the topic i will talk about today and of course as every speaker and developer or whatever guy i'm on twitter so let's start talking about security who of you likes to deal with security one two three four three and a half okay three and a half it's not that pretty much um so did i until a few years ago the reason was for me i didn't understand it then i took the time and tried to understand it read the specs and suddenly it made hey it's easy it's pretty easy but you have to have to take the time and understand how all this stuff really works and security is a wide range of topics and there are also the overs top 10 which deal with the most most frequent security issues and what we don't want to talk about um the the obvious top 10 today we want to talk about authentication and authorization so who of you thinks he or she knows what's the difference because between authorization and authentication okay a bit more than the half it's pretty easy i think but every time i'm talking to customers most of them don't get it right and it's easy as authentication is i don't know who you are please authenticate yourself tell me who you are and how can i make sure that you the person you tell me you are an authorization is the next step after i know who you are i have to check what are you allowed to do this is authorization and yeah also i mix it up still in my daily business business when talking to customers sometimes i say authentication when i mean authorization and vice versa so if i mix it up today please don't be angry with me but um also the http status codes mix it up a bit and these these are pretty old so the guys you made who um who built up the status codes didn't get it either we have the 401 which means which which is called unauthorized but it means unauthenticated or not authenticated 401 is not really it does not deal with authorization it deals with authentication and once you're authenticated the status code 403 tells you you don't you are you're not allowed to do anything you're forbidden so for one unauthorized it's not it's not really correct so and we are in distributed apis nowadays distributed systems distributed apis um at least we have a single page application in the back end that's also a distributed system and how do we log in in such a system in a secure way and when talking when apis are talking to each other we how do they authenticate and authorize each other and when it comes oh yeah when we have distributed apis or distributed systems should we have a centralized approach when it comes to authorization or authentication i think yes because it's called a single sign on and single signon means there's only one system who knows my credentials and um which knows how to to verify these credentials and not two or three or more replicated systems with replicated data because then the the data the credential data of our users is replicated and many systems uh have have have a knowledge about this and we don't want to have many systems or more more than one system to have the knowledge how to verify the credentials only one system that's because it it's called single signon singlesignon does not mean our users only have to log in once when they come into the office in the morning and grab a coffee and they can work with uh ff system that's a side effect of single signon but not that's not um the root of the word single signon the signal is really a single system who knows about our credentials yeah and when it comes to to real users of course they want to have a simple and secure solution and you all know simply simple and secure these are two choose one you always have to choose what is more relevant for you has it to be more simple or has it to be more secure the more secure the less simple um it will be at least for you as a developer if you want to make it simple for the for the users for the end users and secure for the data then the effort is at your side the developers side yeah how do you authenticate of course with our username email whatever a password a simple secret a temporary link or a mobile phone or whatever but then how do we transport these authentication infos to all the systems of course with the token and the token is nothing new already in the beginning of 2000s we have the the summer the security search and markup language which is pretty cool xml no xml and cool doesn't work doesn't fit together it's yeah it's powerful but it's kind of complex and it doesn't feel good and all these claims are difficult to handle and um when we talked today about uh web applications and lightweight um lightweight serialization and such things like json javascript it's really hard to handle xml with javascript i tried it once and i gave up after two days but the token itself is nothing really new and because samoa isn't working pretty good with web technologies in nowadays there's the oauth 2 framework or specification which deals with authorization of 2 has nothing to do with authentication it just deals with authorization who is allowed to do what which system may access another system in your name of course you have to be authenticated before you can give another thirdparty system the authority to access your own system but the authentication process is no standard way when using oauth2 or f2 is just authorization and um the the the authentication process is completely different uh implemented when um looking at the oauth implementation of twitter or facebook or github or whatever so you can use the the login feature of twitter or facebook google for your application but that's not really um authentication that's only authorization you grant access to your application to access twitter in your name when you're not in front of your computer and furthermore if you implement many of these providers you have to implement different ways of how to retrieve the user information the user profile information because every response from every system looks different so oauth2 is just for authorization and not for authentication um but it's pretty uh powerful when it comes to uh web web applications or handling in the web and it has different socalled crunch types or authorization flows there if the authorization code flows the standard flow which deals with many redirects between the systems and the browser and simple said the the user wants to access um okay i can show you here an abstract protocol flow the user wants to access a secured resource on the resource server and the resource server says hey you're not authenticated please log in authenticate yourself and then i will see if you're allowed to do and redirects the user to a login page of the authorization server and after the user logs in the authorization server sends back a authorization code that's why it's called authorization code flow and the authorization with the authorization code flow in the browser with a redirect to the application the client wants to access the application itself can grab the token from the authorization server and the token expresses what the user is allowed to do so with the token um the resource server can deliver the protected resource to the client that's the most powerful ground type or author authorization flow authorization code and if you don't have the the possibility to um to take the authorization code flow and um grab the token from the authorization server because that's uh you need you need an additional secret for the for the client fetching the the token at the authorization server and if you can't provide this secret for example in a public website javascript site you need something other because yeah you can somehow encrypt or hash the secret but it's still in the in the front and the browser and the user's device so the secret isn't a secret anymore and therefore you have the implicit flow and with implicit flow you get implicit the token back to the response after the user logs in successfully if you don't have any chances or you don't want to have some redirects between the systems and the user's browser you can use the resource owner password credentials flow it's probably quite a nice word resource owner password credentials i have to read it every time and that's kind uh of an api sending the credentials directly to the authorization server and get back the token but this is the least least secure possibility because you as as the client application have the you have to have the credentials in uh in your application to send it to the authorization server in the regular cases of authorization code or implicit flow the author's authorization server delivers the login page and the user enters his credentials directly at the author authorization server and with the resource owner password credentials flow the user enters the credentials at your application and you take the application the credentials and send them to the authorization server so there are chances for mantomiddle attacks and when it comes to system to system authorization there's the client credentials flow this is just for it's like it's like the the authorization code um or the implicit flow but just for backend applications there's no browser involved and no redirects and um lastly you have the refresh token flow because um every token has a special lifetime and after the token is invalid you have to renew to refresh the token you can do this with the refresh token flow and that's how the access token response looks like when your application gets the response from the the token fetch or from the authorization server you have the access token itself it can be just a opaque string with no means for outside world the token type is bearer it's always better when dealing with oauth 2 this is written in the spec it has an expiry range it expires in 3600 seconds and we have the refresh token with the refresh token you can refresh an invalid access token so normally the access token has a very short lifetime between a few seconds and i say five minutes and the refresh token has a long lifetime um let's say half an hour hour or whatever so um this access token you can take this access token the the string and um to know what your user or your client is allowed to do you have to take this access token and ask the authorization server what is this user with this access token allowed to do and additionally you don't know who is this user you can only check what is this user allowed to do you don't know who is this user and this is where open id connect came in open id connect is not open id it has nothing to do with openid it's just hosted by the open id foundation which is also doing open id and but it's called open id connect and it's based technically is based on oauth2 with a worth two flows and it standardizes profile user profile information and identity information so it brings in an identity token to the additionally to the access token we have an identity token and it adds an user profile endpoint where you can grab identity information profile information of the user with his current access token and a few more restful endpoints for dealing with all this stuff um so this is the identity token coming in into the response we have the access token the refresh token now we have the identity token but how does it look like how is the identity stored into the token and this is where json web tokens come in json web token that's the standard since 2015 three years old and json web tokens are simply three concatenated base64 encoded strings so if the three uh strings mentioned in different colors and what it is like it's it's a header it's payload and it's a signature and if you decode this can you read it yeah i think yes um you see the header it just contains the type the jbt has the jwt has the type jwt okay and the algorithm with which the signature is signed or the signature is created then you have the payload for the payload you have a few reserved claims we come to this in the next slide the possible claims or the attributes are called claims in terms of jwt and the signature is um is a string uh concatenated of a base 64 encoded header and payload and depending on the the type of algorithm used um a synchronized algorithm the hs256 with just a secret or you can use the rs256 for a private public key usage so the token itself is socalled selfcontained and you can always check if the token was changed by some third party when you get the token and so you have a certain kind of trust level when you get the token if the token itself is valid or is not valid because only if you knew even though the the secret when it comes to synchronized signature or you have to know the private key when dealing with public private public key encryption so you don't have to check the token at a another end point you can this can do this of course if you really need this kind of security but you don't have to use this endpoint yeah the payload itself it has some reserved claims the subject issuer audition and expiry these are the only claims jwt claims for itself the subject is for for whom is the the token issued most of the time this is kind of a user id the issuer is the issuing system represented as an url the audition for which client application this token was issued for my api or for my shop or for whatever system and the expiry date and as the specs says jwt must be used when the expiry date has expired so you have to check the signature if the signature is valid then you can use the token otherwise you must not use this token and um it has to have a valid expiry date the rest of the payload you can choose freely whatever you want to put in the payload as you like open idconnect adds a more some more claims standard claims to the jwt token so if you use jwt in terms of opm id connect you have to use these claims i know i don't know it's difficult to read there was no other way to fit all the information to one slide it's but it's not a website of open id so we have claims for the name the given name the family and the middle name the nickname preferred username and so on also in the bottom you can see there's also address and address is not only a string it's a json object so we have a nested object for the address information and the address object itself is also specified so using jwt changes our access token response to look like this we have the access token the access token itself is when using open id connect also expressed in jwt and we have the token type the expiries in when using jwt you don't need to use this expires in at report because the token itself has an expiry date and you have the identity token in a jwt format and the refresh token also it doesn't make real sense to have the refresh token as a jwt but yeah for simplicity reasons all tokens are jwt tokens the refresh token itself contains just unique string for identifying this session on the authorization server okay and how can this token be used the user after author successful authentication has a token he passes to the web application and the web application itself can pass the same token to backend systems if this application needs to access thirdparty or further backend systems as we can see later in the demo it's also possible that the web application grabs an own socalled service account token for authentication authenticate authenticating itself against backend systems or it can pass the the user token to the backend systems so short conclusion for tokens a token is signed we have seen this and contains all necessary necessary information about a user and its roles so in the access token all the roles the user has should be included we have different kinds of tokens with identity tokens refresh tokens access tokens and sometimes you have things like like an offline token an offline token you can a user can can request to have an offline token issued for another application and this this other application can use this offline token for perhaps regular tasks at night when the user is not online creating reports or whatever sending emails to to exchange this offline token to valid access token and act on behalf of the user even if the user is not online but the user has to has to initiate uh the process for um for creating an offline token so there's no global offline token as a system can use to act on behalf of a user the tokens are sent in bearer format most often in the http header authorization and we have a total time to live and of course tokens must be revocable um i forgot this to mention an access token itself once it is issued it doesn't need to be verified at the authorization server i said before that's right because it's um signed and it's selfcontained so once it is issued it is well it and every system using it can be uh can be sure that it's valid but what what if um the the the token um is stolen or whatever um that's because the the access token should have a very very short total time to live i recommend most often between 30 seconds and two minutes because that's the time amount of time a third party can misuse this token if it gets the token and after this time you have to use the refresh token and to refresh the access token to get a new access token and if you have in the meantime the token the session revoked at the authorization server the server won't access a new exit it won't create a new access token and um and the third party can't use the token anymore so this must be revocable and as i'm a java developer most of the times currently i'm dealing with the javascript i asked myself what does java offer to deal with oauth2 and open id connect and unfortunately it's not that much it's becoming better but it's very sad the big java ee standard now it's called jakarta ieee has a new security api jsrf275 which is quite nice this api but it doesn't deal with um off 2 or almighty connect jwt there are some discussions on the on the mailing list and the issue list to integrate it or not and how to do it but for now there's nothing included and spring security already made oauth2 a firstclass citizen in its implementation and before security 5 you had to use a thirdparty library to to use oauth 2 and open id connect with spring security now it's included out of the box in spring security and there's some other libraries for example there's apache shiro one of the the wellknown libraries dealing with security but also shiro doesn't have oauth2 or id connect jwt included there's some community efforts but nothing in the library itself but there's another library called apache all 2 which does contain all the standards and my favorite question at every conference who knows all two one okay um yeah even me didn't know this library until i prepared the talk and had a look um which libraries are out there dealing with um oauth 2 and yeah it seems it's it's a it's powerful library but nobody knows there are lots of more libraries available some dealing with oauth 2 of my dconnect some not and there are of course a lot of libraries dealing with jwt looking at the ecosystem what's available for storing user data and providing all the flows and processes end points of course you can use off zero or hws cognito storm path as some managed services providing all this functionality but you have to outsource your users data the credentials and that's um i think most of the time not that's what you want to do to give other companies the credentials of your users and besides other projects i like to to use key clock from jboss it's an open source project it's not just a library it's a complete system providing all the services for identity and access management and yeah in most of the cases it can be a good fit uh i also had some case use cases at customers where i said okay key cloak can do it but it's not the best fit for you needs take another solution but in the last few years most of the projects i did with my customers i introduced key cloak to them and they're pretty happy so let's look into some demo how i did it first the architecture it's pretty simple i have a shop system as the the main system a user interacts with and the stock service and the shipping service in the back end and the user gets a user token pass it to the shop and the shop itself um gets a service account token issued for accessing the stock service because the stock service is also secured only allowed resources may access the stock service and for calculating the shipping costs the the shipping service needs the user token so the shop passes the user token to the shipping service this is key cloak this is the uh the admin interface and um i have to make it so it looks better yeah i have um created a shop client this is my shop application and the client protocol is open id connect key clock also supports saml but we don't want to deal with someone only to deal with openid connect and this is a confidential um client which means um this client has a secret for accessing the key clock server like a password for for the for the system itself and um you can find it here it's a secret it's generated and yeah we have a user user has username user and this user has a role called user very surprising and yeah we can now access our shop oh i have to start it first it's a spring spring boot application i will show you some some code in a few minutes so we have the shop localhost 8081. now looks better that's my shop i come from germany that's because the euro symbol and i want to access a secured secured resource and the application redirects me to the key cloud server to log in and all the things you can see on this page are coming with key clock you don't have to implement them themselves the login process you have a register option you have a forgotten password option you have a remember me option you have the option to to use uh social login providers or you can connect your your your ldap or active directory to key cloak so that key cloak just does the authentication process but the credentials are stored in an active directory and all this stuff you don't have to implement it yourself and then we can log in as a user and that's my cat shop you can buy cats you can see i'm the user and now i can put cats into the the cart some double rounding feature um we can see we have some stock information about the cats and the image service is a bit slow it's a public service with random picks and we have shipping costs of um uh approximately 10 euro and if i now log out and do some reconfiguration of my user i tell it's a vip i give the user just a simple attribute with the value true and now if i log in again and put cats into my cart you can see there are no shipping costs because if the user has a vip attribute there are no shipping costs used so that's the application itself let's look into the code how or what i had to do to realize all this besides of the of the business logic for configuration of key cloak for spring boot application and spring boot it's really simple but other java application servers are quite similar we have to provide some configuration it's a realm it's called workstorage let's look here it's called voxturish this is the realm configured in key cloak we have a server url it's localhost 8080 we have the the secret our resource is called shop we we saw this and in our principal attribute we want to have the preferred username claim this one of the open id connect reserved claims and we use the servlet security specification to configure a security collection which says all resources beneath the path shop should require a user role that's why we were redirected to the login page i didn't write wrote any code to redirect the user to the login page just this configuration leads to the login page of key cloud because the key clock adapter which is included in the application which is just a dependency in the palm we have um key clock spring boot starter um and this dependency brings all the adapter logic to redirect to the server and if i authenticate myself come back to the application then the application fetches the access token from the keylog server and knows i'm a valid user with a user role and leads me to the catalog which is done by the shop controller and when we have a look to the stocks get stocks method we have the stock service get stocks and we use a rest template um which i i called key clock client auth rest template and i implemented uh myself it's just an extended standard rest template from spring and um did some configuration magic um this is the off arrest template and make use of the auth client offset client this client can comes with key cloak adapters the dependency mentioned in the palm xml and this client eases the process for authentication authenticating the the the application itself against key cloak to get an service account access token which is needed by the the stock service and we can see the stock service the stock service itself needs the role stocks and as we can see it our user our user doesn't have the roll stocks it's available but it's not assigned and our client shop service the controls there it is um an assigned role stocks so the shop application itself verifies authenticates itself at key clock gets an access token and passes it to the stock service and because the the token contains the stocks rule it's allowed to access the stock service and we have the the shipping service at last service this also needs the user's role and key cloak forwards the user token to the to the shipping service and in the shipping controller i can get i can access the key clock security context through the the request and in this context i can get a token or also i can get some identity token to get identity information or whatever i need and here i check the the vip claim just for completeness and the interesting part is in the shop application again um shipping service i just use a regular rest template but i configured the rest template to use the key clock rest template customizer this also comes with key clock and the key clock rest template customizer is so i need to find it no that's just the interface the interceptor yes the interceptor and the interceptor just cares about getting attributes from the request get the user principle and somewhere yeah getting the key clock security context and putting the the token the token from the security context into the request to the shipping service to the back end so i didn't write any code to secure my applications just did configuration using the key clock application the key clock system server and can can make use of a highly secured application landscape so that's it time is over i hope you enjoyed the session and if you have any questions we have some four minutes left uh just ask your questions raise your hands or come in front of me um the code is not yet online but i can put it online later on and i will tweet the pass through repository so just follow me at desniko and you will be informed okay because but it's no real code it's just configuration the code is a standard java spring boot code it's nothing there's no security code it's just configuration i'll make use of the the key cloak some key cloak magic about the configuration of the rest templates but nothing more yeah okay there's one more how to secure the communication between the shop services and the other two services i mean speaking about the normal way we should be in a safe um did everybody understand the question or should i repeat it okay um what's the what's the purpose of securing uh the bose back uh backend systems the stock service and the shipping service because normally we should be in a controlled and secured area if it's really secured in this area most of the the the um attacks in systems came from internal net internal networks and even if you're in your own intranet controlled whatever at least the the administrator knows how to attack a system and you should secure all your systems regardless if the if the environment claims to be secure or not you should always use https you should always use authentication and authorization so you always can can check at the stock service when and how often the shop accessed the stock service so for auditing reasons or whatever you can you have the the best basics in the second you you propagate the user identity to the shipping service yes but this can be can be needed because some vrp's don't have to pay shipping costs uh whatever yeah but this always also can be can be a risk of propagating user identities to other systems so we have always to deal with the pros and cons of your solution no system is perfectly secure isn't it usually done by this one i saw that you used now the user wrote a feature or a missing feature in key clouds um he asked if i missed why i missed the the scopes from oauth2 and if it's a missing feature of key cloak why i'm using roles and not scopes which which scopes exactly do you mean from from earth to so basically array of strings okay okay is this is this really a part of the specification or is this a way of most companies do it okay um yeah key clock first of all makes use of open id connect and jwt and open id connect is based on oauth2 just for the the the flows and because open id connect uses jwt and jwt can express all what you want you don't have to use some other possibilities scopes into additionally to jwt so you can put all the information you need in your token so you don't have to use scopes from one technology from the auth 2 technology and use tokens from from open id connect of course you can mix it if you want you can how you you you put your um your your authorization information into the token if it's roles or scopes it's completely up to you but open id connect deals not with authorization it deals with authentication and in authentication you don't need roles or scopes it's just an addition to all this kind of stuff and yeah authorization with key clock can be a pain in my eyes for authentication it's pretty good authority um authentication and authorization can be really pain okay time is over thank you for listening and have a nice day