learn how to create your very own programming language and the only prerequisite knowledge is basic python Ariane Hegde teaches this course along the way you'll learn more about object oriented programming linear data structures binary trees recursion tokenization parsing and more so let's get started welcome to this brand new course where I'll be teaching you how you can create your own programming language using python now the goal of this project was to teach you how you can Implement a bunch of programming Concepts into a real world project I have always felt that especially in computer science Concepts have been taught in a sort of abstract and detached manner independent from The Real World and that's why in this course I bring to you a bunch of Concepts like data structures like algorithms recursion object oriented programming I teach how you can Implement all of these Concepts into a real world project you can also head over to blog.algalon.net or click on the link in the description where I talk about a bunch of learning methods I employ during my learning phase to have a better grasp on Concepts and a higher memory retention now the only prerequisite for this course is basic python knowledge stuff like if statements variables while loops and functions and with the basic foundations laid I'll take you to the next level talking about data structures algorithms recursion and much more and by the end of this course you'll have your own programming language so by the end of this project we'll be having the final output so this is our I've run the shell.py file over here and this is what our output is going to look like so we're going to input our shadow script code as a python input so I'm gonna say let's say we can give an input arithmetic expression so one plus one it returns two I can do 5 plus 3 it will give us 8. now I can even talk about order of operation so I can even do one plus four multiplied by 7. in the wrong order of operations that'll be 5 times 7 which is 35 but the correct way to load is multiplication first so we'll have 7 times 4 which is 28 plus 129 which is what we get if we want to make the addition we want to give higher priority tradition we can add a pair of parentheses multiply by 7 and this should give us 35. so that's all about arithmetic Expressions that we can give it apart from math it can do other stuff as well it can create variables so I'm going to say make variable a and I can assign that variable to the value 10 and like how in JavaScript you have the VAR declaration or the let declaration and this time we're using make so the make will be used to create a new variable so we create a variable called a and give it give it the value 10. I can make another variable B set it to 15. and I can make another variable C and set it to a plus b and this stores the correspond the variables and the corresponding values in a python dictionary now after variables we can also deal with conditional operators and comparison operators so sorry Boolean operators and comparison operators so Boolean operators is something like stuff like and or and not the comparison operators are greater than less than is one thing equal to another thing and so on so I can run a Boolean operation I can say 7 greater than 2 and 5 greater than 3 in this case both of the um expression 7 greater than 2 and 5 greater than three both are true and therefore this should return 1 which stands for true if I do 7 greater than 2 and 5 Less Than 3 which will return 0 which stands for false act into 7 greater than 2 or 5 Less Than 3 which will give me 1 again I can do not so I can say not 7 greater than 2 so this will give me 0 because 7 is greater than 2 and then we're not in that operation we are inverting it where um turning 1 to 0. so that's the Boolean operators we can even have two two things are the same I can check if C is equal to B so this is how I use it in Python you have two equal symbols to check if one variable is equal to another in in our syntax we Define it as C question mark equals B and if I run this this is 0 y because 25 is not equal to 15. I can make another variable d set it to 25 and now if I do D equals to C this will give us 1. so that's the comparison operators I can't even check if C is greater than a and that gives us 1 and so on so apart from the comparison operators you can now use if statements so I can say if a is greater than 3 do something so do three times three that makes no sense but let's just see if this works and that will give us the output 9 because a is greater than 3 but if I do if a is less than 3 do 3 times 3 it will give me nothing I can answer on ellips so I can know if a is less than 3 do 3 times 3 l if a is greater than 12 do 5 times 5 else do 10 times 6 so in this case a is not greater than 3 and it is not greater than 12. so both the conditions won't be met and it will go to the else statement and run 10 times 6 which is 60 as the output now the final thing that we Implement in this course is while Loops as well so how do you run a while loop I can say while a is less than 15. do and then we have to make a statement so do following a statement with following the do keyword we have to give a statement like make a equals a plus one so incrementing is value by 1. and this will print the variables list in every iteration of the loop so that's all there is to it in this course we haven't talked about more advanced functionalities like strings or possibly even styles of programming which we could Implement in our language like object oriented programming or functional programming we haven't talked about those aspects because we want to keep this course simple while also learning about a lot of other computer science Concepts like data structures algorithms and the programming paradigms and lots of stuff so we're gonna talk about all of those Concepts from a beginner level and by the end of this course we'll have this amazing project built from scratch so let's begin this course so I'm going to start this course by talking about how computers are able to read code on a high level now this is not really necessary to understand the implementation phase of this course where we will be dealing with python code and writing our interpreter but I just think that this help would helps put things into perspective and explains how computers are able to actually do this stuff in a more physical manner so ultimately um if you've scaled the microscopic level you'll find that computers are made of transistors and they are indicated by the following symbol so um the two wires over here are electrodes and in between is a material known as a semiconductor a semiconductor typically made of silicon or I'm not really going to go into the chemistry but but it composes of silicon and semiconductor is a material that allows current to flow through given a certain input from the control wire so this is the control wire when the control wire is on the semiconductor will allow current to flow through it when the control wire is off the semiconductor won't allow current refer to it so let's represent um these states on and off using two numbers zero and one also known as binary so when the control wire is on the semiconductor conducts electricity and if this let's say is the output so then and let's consider the control wire as the input so we have input and output and we have a way to represent data using binary so over here input is 1 the control wire is on the semiconductor can conduct electricity and it will generate the output 1 and if it is off the output will also be off Now using transistors we can generate logic gates there are multiple ways to generate logic gates um you can use different mechanisms as well but typically inside a computer you'll find transistors and transistors forming the logic gates so how do you make a transition how do you make a logic gate from a transistor I'm going to start off with a simple logic gate which is known as the not gate in fact there are three of them there's the not the and and the or which are the fundamental logic gates that computers use they are also known as Boolean operators that we will be working with during this course during the implementation so not essentially reverses the input so if the input is one a not operation turns it to zero the input is zero the not operation turns it to one and this not gate is built from transistors one way you can build a not gate is okay let me draw that again you can have the output go in that way and have the control y over here so control bar is the input and that's the output so over here input and output if the input is 1 that means current will flow in this direction it will go down and flow in this direction so the output will be zero if the input is zero the output will be 1. and what I'm drawing over here these tables so I know why that's not working yeah there we go so these tables are also known as truth tables they're one of the first things you actually taught in computer science anyway so it's it's just like four cells in an Excel sheet anyway so that's what the not gate does similarly you can construct the and and the nor gate using just combination of transistors I'm not going to go into those details but all you need to know is that the not gate flips the input operation the or gate has a different sort of truth table for a certain input it has two inputs i1 and let's say I2 and one output if both of them are on this will be on if one is on it'll still be on but if both of them are off the output will be off so that's the or gate the and gate is um another logical logical operator it has two inputs i1 and I2 and it has an output and only if both i1 and I2 are on will the output be on otherwise the output will be zero so that's the basics of you know and Gates not Gates and or Gates these form the fundamental logic gates there are some other Gates as well like the X socket but I'm not going to talk about them right now these Gates instead of representing them as transistors we represent them as their own symbol so let me just draw their own symbol and that's the or gate 3 Gates three simple so how do computers perform arithmetic with these logic gates there are two main functionalities we're looking for arithmetic and memory and once we understand both of them I'm gonna move on to the more um the side of this course which is more relevant to creating your own programming language so again as I said we have two operations to accomplish arithmetic which is basic algebra or uh not basic algebra basic addition subtraction multiplication or Division and the memory is refers to storing data essentially storing binary and then we can use the binary to represent other forms of data like for instance video or audio or whatever so anyway before we move on to the arithmetic I want to talk about another gate which is the Excel gate I'm now going to talk about how it's formed this is its symbol it's similarly or gate actually and that's you know yeah there we go so that's how the xorbit looks like and it looks similar to the or gate it too has two inputs I2 and i1 and the truth table and the truth table is something like this if both are 0 the output is zero if either one of them is on the output is on or one and if both of them are 1 the output is zero that's the xor gate now in binary you can also perform addition so what I was referring to as arithmetic let's say you want to add the binary numbers one and one so you would have to represent them as 1 0 essentially uh how do you how you represent binary numbers is the following you you represent decimal numbers which is the base 10 notation in forms of in the form of powers of 10 so for instance 10 to the power 0 10 to the power 1 10 to the power 2 and so on so that's the ones position tens and hundreds position and so on that we've been learning in elementary school so if you have let's say uh the number 3 4 6 so that just corresponds to 3 times 10 to the power 0 plus 4 times 10 to the power 1 plus 6 times 10 to power 2 which is 643. so that's how we represent um decimal numbers but binary is different it is base 2 so you have 2 to the power 0 2 to the power 1 and 2 squared and you can't have numbers from 0 to 9 it's not base 10 you have you can have numbers only from 0 and 1 so 0 and 1. so if you want to represent the number three let's say so that'll be 0 over here one over here a little bit it'll be one over here 1 over here and 0 over here so 0 1 1 is 3 how so um let's do that so it's 1 times 10 to the power 0 plus 1 times 10 to the power 1 plus 0 times 2 to the power 2 and this turns out to be 3. so that's how you do uh basic addition in in binary so so that's how you do basic addition in binary now if you look at the xor gate the truth table of the xor gate it actually looks pretty similar to our Edition so I'm gonna do addition for uh one bit numbers only just to demonstrate the idea of arithmetic using logic gates so I'm gonna do 0 plus 0 which is zero zero plus one which is zero one plus zero which is one okay and the previous one is also one and one plus one as I said it's not going to be um two it's going to be one zero and one zero essentially refers to the fact that it's two to the power zero and two to the power one so you have a 0 over here and one over here so that's just 2 to the power 1 times 1 which is two and one zero equals 2 in decimal so now if you look at this over here you can see that the sum which is the first number is exactly the same as the xor gate it's 0 1 1 0 0 1 1 0. but the carry bit which is this one over here that's called the carry bit because it becomes like like in decimal Edition you take one as the carry so you take one over here and then that comes down over here as one so on the carry bit is one that we have to we have to find another gate for the carry bit the carry bit is zero in these cases but one over here and that's the situation for the and gate so if you can combine the or gate the xor gate and the and gate you can actually come up with a way to handle addition in um using logic gates only and that's essentially how we go that's the starting point you go from there uh try to handle more complicated arithmetic like multiplication or Division and it's the that's the same basic idea you are trying to hook up logic gates in a smart manner to perform calculations and that's how arithmetic Works in computers so now let's talk about memory I'll be using a component called the and or latch as an example to show how computers have the ability to store data so it's called the and on latch as I said so let me just construct it so R stands for reset s stands for set and O is the output so we use the set um wire to save data so if you want to say save the num save the binary number one or just want to save the bit one so how do we do that so the first thing we need to do is turn on the set wire so I'm going to draw a truth table over here so we have set reset and let's not worry about reset for now and output so if you put set as 1 and reset as 0 what will happen to the output so this is an odd this is an or gate over here so on or gate so once once you turn on the set wire one gets transmitted over here because if either of the inputs of the or gate are 1 the output of the or gate is one so the output of the or gate is one over here and the reset is zero so zero gets knotted and that becomes one so now the and gate converts these two input ones into the output one so in the following scenario where in where you turn on the set wire and leave this reset wire as it is the output turns out to be one now afterwards if we turn off the set y let's turn off the set wire so let's make it zero and there is the reset wire is still zero what will happen to the output so now the set wire is zero but regardless since the output is one and that was fed back as an input to the or gate this is one over here and since one of the inputs is one to the auger this Still Remains as one this uh uh the input to the and gate the right the bottom input to the and gate Still Remains is one and therefore the output Still Remains as one so the output is effectively unchanged even after we uh stopped even after we turned off the set wire and that is effectively what computer memory looks like so the computer has remembered the state it was in and that is known as saving or computer memory you can delete it by turning on the reset key and that's also pretty easy to follow if we turn on the ezt that gets knotted to zero and one of the inputs of the and Gates becomes 0 and the output becomes zero and we are back to our original state so that's how basically computers store memory it's solve this feedback mechanism that they use that helps them store memory and now that we've understood these two concepts let's go ahead to the next section where we will talk about the need for programming and why we need to use programming languages so what is the need for programming that's what we're going to talk about in this section of the course now programming refers to giving input instructions to come to a computer so that we can execute them so before we understand how programming works we have to understand how computers understand instructions that's a mouthful let me say that again to understand how programming works we need to understand how computers interpret instructions and as I said all all along that they do this using logic gates so we have a set of logic gates hooked up in a smart way so that they can detect certain instructions like for instance if we have the instruction one zero zero zero so that's the 4bit instruction over here now how do we decode this the computer has a control unit which is responsible for checking for certain instructions looking for certain instructions and once it finds those instructions it will perform the necessary action so that's how computers interpret instructions they have a control unit control units composed of logic gates so let me just say you have the instruction like this so this is the instruction it's fed into control unit and the control unit um detects the instruction checks if uh say for instance the instruction one zero zero corresponds to uh adding and adding to memory let's say so the control unit will check for that instruction if the instruction is one zero zero and again these instructions are stored in the memory of the of the computer we talked about how computers uh save Things So the instructions are stored in the memory of the computer so um once it once it so it sequentially goes through all of the instructions stored in the memory and let's say this is the instruction at first encounters and it tries to match it with the instruction one zero zero zero and let's say in this situation where it does match with this number uh this number let's say the instruction is one triple zero in that case the control unit will detect it using a logic gates and once it has detected that instruction it will go ahead and perform the operation of saving to memory so this two stages detecting the instruction using the control unit and then performing the uh instruction so you have a table like currents corresponding to 1000 uh corresponds to saving to memory maybe zero one zero zero corresponds to doing arithmetic adding two numbers let's say so you have a table of these instructions so you first design these instructions and then computers programmers will go ahead and input these instructions into the computer's memory the computer would sequentially perform each instruction and will execute them so this is how Computing works on a really high level and the problem arose and this is in the early ages of computing the problem arose was that the problem which arose was that you used harder mediums which is like Hardware interactions to input data these instructions like one zero zero uh were fed in by mechanisms like switches or plug boards or um you had some Punch Cards so these harder mechanisms are not really effective especially if you have thousands of instructions to give to the computer and that resulted in the need for a softer way a softer medium for interacting with a computer and that gave birth to a compiler a compiler converts you have high source code high level source code which is essentially a programming language like Python and that source code is written in such a way that it's human readable and you have a compiler which is just another computer which uses a set of techniques to convert that source code into binary which is also known as a machine code so that's the job of a compiler can converts source code into machine code and in this entire course we'll be learning about a lot of processes that compilers use to convert to machine code namely lexical analysis and um passing and interpretation we won't be building a compiler we'll be building an interpreter so we won't be dealing with converting the instructions into binary outputs rather we'll be using a programming language like python to convert to to interpret data in sequence to input interpret our own programming language sequentially so a compiler converts to machine code but our interpreter won't be doing that it will be using a programming language like python to understand our given input and then process it and perform the necessary action so anyway that's it for this section we've talked about how computers understand instructions how they execute those instructions and the need for compilers to convert high level code to low level code and those low level codes is just binary instructions and now with that information it's time to move ahead to the next section where we will be delving more into the implementation side of this course so I'll see you over there in our interpretation process there are three steps involved the first step is known as lexical analysis and then after that you go ahead and do parsing and the final stage is the interpretation which is done by The Interpreter so three steps and if you encapsulate these three steps into its own box so I have an interpreter over here and that box is called an interpreter and if I input some code which is in our own in our custom programming language and for the purposes of this course this programming language will be called Shadow script which is a fancy name for a not so capable language um because of course we won't be able to achieve tasks that advance programming languages like python or JavaScript can do but nonetheless we'll be talking about the core functionalities like variables like arithmetic operations um uh some if statements while loops and possibly even for Loops so all of that code will be implemented it won't be as powerful as the modern programming languages but still it's a great great opportunity to learn lots of programming Concepts so anyway this interpreter will take high level code and in our in our programming language it will take Shadow script in it so it will ingest Shadow script and spit out um the necessary actions the necessary output like say for instance you're creating variables it will spit out the value of the variable and save the variable if you want to do some arithmetic operations it will it will do the arithmetic for you and spit out the output and so on so they'll just give an output and it may also deal with some of the memory processes like saving new variables deleting variables and all of that so it produces an output which will be visible on the shell uh on on the terminal and it will also be dealing with some memory changes so it's these three steps that um okay I don't know what happened over here let's just fix that so it's these three steps that we have to talk about because this is this is what goes on inside the black spot black box and the first step is lexical analysis so I'm going to create a new page for this one and this is known as lexical analysis the process is pretty straightforward easier than the other steps and it involves just breaking down the input code into specific tokens now the tokens for our purposes can have a value and also a type like for instance the number five has a value of five and So that's its value and a type of integer the plus operator has a value of Plus and it's a type of operator so oh so the lexical analysis just breaks down the tokens breaks down the input into tokens and that's pretty much it that's all it does and in the next stage we'll feed the tokens as an input to the parsing so the input of the lexical analysis is the original code the output produced from lexical analysis will go to the parser and the output of the parser will go to The Interpreter and The Interpreter will give the final output so lexical analysis you give an input and I'm going to call it tokenization because lexical analysis is pretty hard to say and they mean the same thing so yeah so tokenization you give an input which is the shadow script code so tokenization and it will break down the input code into specific tokens and in our case it will store those tokens in in a python list I'll talk about data structures in just a few moments but probably in the next few sections but just know that it will store the tokens in a sequential way in a list so list is just like a traditional list token one token 2 and so on so that's a list and this is the first item of the list this is the second item of the list and that's how a python python list looks like now to give an example let's say the input is the arithmetic operation one plus three so we want to add the numbers one and three so after the tokenization process the output should look something like this it should store the token value of 1 and of type integer then it should store the token okay let's put it below so first we'll store token one and it will be a type integer then it will store a token the plus symbol or add symbol and that's an operator and so on and the third final one is the third token which represents the integer three so that's the output of the lexical analysis stage and now let's go to the next section where we will talk about how we process these tokens this stream of tokens how we process them so the next step is called parsing so from the tokenization process we have received a bunch of tokens stored in a python list and now we have to process that that list and generate a useful output so what is parsing first of all let's understand the definition of parsing and fundamentally parsing is just the recognition of patterns in an input like say for instance we have the input one plus one and in a very simplistic uh interpreter for our programming language we can we can interpret this expression by first tokenizing it so we tokenize this into a bunch of tokens we have the number one and we have the plus symbol and then we have the number one again and now once we have these tokens in the list in the parsing process we look for a pattern in a simplistic way let's say The Interpreter can process only the addition or subtraction of two singular digit numbers like for instance one plus one or three plus four or five plus six or something like that in this case the pattern that the parser has to recognize is that the first number is an integer the first okay wrong the pattern that The Interpreter has to recognize is the first number is an integer or the first token is an integer the second token is an operator and the operator could be plus or minus and the third token is again another integer that's all that the parser has to recognize and the simplistic scenario there's an integer plus or minus another integer and the parser just the remember the lexical analysis of the tokenization process blindly converts the input into a bunch of tokens it does not look at any structure it does not see if the input abides by the programming language rules it doesn't do anything like that all it does is converts the input into a bunch of tokens but in the parser it tries to search for patterns it tries to search for this pattern of integer integer plus integer so that's the general pattern so integer plus or minus and this vertical bar is also known as r so plus or minus another integer so that's the pattern that we're trying to look for in the simplistic scenario of course this is not how our parsing process will be in the in the implementation side we will be able to deal with extremely complicated Expressions as well but this is just to give an example of what parsing really is all it is is trying to find structure and um essentially it goes a step further from the lexical analysis and tries to structurize the input how does it do that and it does this using a bunch of grammar rules now in this simple scenario the only grammar rule grammar rule is that an expression is an integer plus or minus another integer in fact I'll write this in a better way so so it's an integer plus an integer integer minus an integer and the vertical bar here so either this is one possibility or this is the other possibility so in this simple grammar Rule and this is the this layout is known as a grammar rule there are certain formats of writing a grammar Rule and I'll come to that in just a second but this grammar rule essentially defines the structure of a programming language the parser checks for certain patterns check for such checks for such structures and C's if the input matches for them if it does not match them then there's probably an error in the input core and an error must be raised so let's talk about let's now talk about the types of grammar rules that exist so the ways in which you can write grammar rules the the one I'm going to use is called P and F and that's extremely hard to pronounce but it's called Backus nor form I believe and I probably misspelled mispronounce that but anyway B and F is a way of writing your grammar rules and let's just go through a bunch of examples now in basic math we have let's say an expression an expression just contains a bunch of terms and a term is just a bunch of integers multiplied together so what does that mean so let me let me go through this again I'm going to say an expression is equal to an in Bacchus now form you actually have two colons over here like that but I'm just going to write it as one colon because it looks much more prettier so like that expression is equal to a term plus another expression or it's equal to a term minus another expression or it's equal to just a term now this may seem a bit confusing because we're calling the expression inside the expression but what this tries to do is just ensure that there is a form of continuity in our expression what does that mean so let's say we have the expression 5 plus 3 plus 2. now that's an expression It's a combination of terms and a term can be an integer or it can also be two integers multiplied or divided but I'll come to that in just a second for now let's just assume a term is an integer so an expression just contains a bunch of integers added or subtracted together now this is where my recursion comes into play and I'll talk about recursion in probably the probably the next few sections but essentially recursion is a way is a type of programming where you're calling the function a certain functionality within the functionality so as you can see over here we call the expression inside the expression itself so what this aim what this tries to do is that it tries to ensure continuity so over here the term let's say the first term is 5 plus another expression our expression can be equal to a term plus another expression so we can say 3 so the three is a term so we can have three plus now expression can be a term as well so 2 is a term so all we're trying to do is we're trying to ensure continuity so that we can enable multiple editions over here so even if there are thousand integers added together we can ensure that all of them uh uh conform to the grammar rule because this is a pretty sound and pretty uh grammatically correct expression five plus three plus two going on for n number of um terms if you still don't understand what I mean I'm gonna use a much more easier comprehensible format so another way to define an expression would be to say okay its expression is a term multiplied or divided so you see we use the bar in fact I'm just going to use the symbols so it's a term multiplied or divided by another term like that now what does this mean this means that an expression can be equal to just one term or it can be equal to a term multiplied or divided by another term actually that should be plus or minus that's my band plus or minus so an expression can be a term by itself but this part over here where we are enclosing uh let me just get that right these two enclosures over here followed by an asterisk represents zero or more times that means now let's clean up that yeah that means this uh the contents within that curly brace can be repeated zero or more times the final that means a term can be a term plus another term minus another term plus another term whatever zero zero or more times then that is effectively what the Backus now form is saying it's calling the expression within itself to tell you that okay an expression can contain n number of Expressions so we're using a form of recursion to to tell the users or to tell the programmers that an expression can have n number of integers n number of terms added a subtracted multiple times now let's define the term so a term as I said it can be equal to just another term or it could be equal to a term it could be it could be equal to a factor now a factor is just an integer for our purposes so a term could be equal to a factor multiplied by another factor or multiplied by another term and you see I'm doing the same thing over here recursion and just to symbolize the same thing as I said the multiplication that means the term can be equal to a factor multiplied by another Factor multiplied by another Factor n number of times zero or more times so a term could just as well be equal to one factor it could be equal to two factors multiplied together three factors multiplied together and so on so that's what I'm trying to signify by calling the term within the term itself so by calling term over here I'll just get the out of her drone for some reason so by calling the term within the term grammar rule I'm trying to Showcase that you can have multiple factors multiplied or divided together so as I said a factor can be multiplied by another term or it could be a factor divided by another term or it could be just equal to a factor now what is the factor for now although in the later part of this course I'll bring in another aspect to this factor definition but for now a factor is just equal to an integer so it could be yeah let's just do integer like that an integer is just a series of digits but I'm not going to go ahead and Define that because I'm pretty sure all of you know what an integer means now in the set of grammar rules we have some terminology as well so the integer although it technically isn't and okay let's just go ahead and do it so I'm going to say an integer is for now let's just say the integer is singular digit so I'm going to say in integer is just a digit 0 0 or 1 or 2 or 3 or 4. right so an integer is just a singular digit and I'm defining that in this way just to keep things simple as you all know a digit an integer can be a series of digits like three four five is an integer or one two three is an integer and so on so in this notation in this in these grammar rules what is inside the angular brackets is called a terminal is called a nonterminal and that essentially means that a nonterminal can be defined by by using a terminal so a terminal in this case is something like an integer which we can concretely Define like a digit uh another terminal in our programming language could be the operator like plus or minus is another terminal these can be concretely defined they are the base tokens of our um of our language so with that knowledge of Bacchus in our form how does all of this relate to parsing so as I said backers now form is a way of defining rules once we have defined rules things actually get pretty simple it seems that you're still far away from having a workable interpreter which can convert your custom program and programming language and execute it it seems that we're far away from that goal but now that we've defined our grammar rules things get a lot more easier so now I'm going to take an example to Showcase how parsing is actually done now that we have the background knowledge of BNF and also about how parsing introduces structure so in passing let's say we're trying to pass the input 1 plus um let's say one now the expression using our previous notation we said that the expression is equal to terms added on added or subtracted from each other now a term can be equal to a factor a factor being just an integer so in this case the expression expression is equal to um one which is a term plus another term one plus one and that satisfies our grammar rule but even if we have something complicated let's say three plus five times two the grammar rule says that an expression is a term plus another expression so essentially saying that again I'm repeating myself but an expression is just a term added or subtracted from another expression n number of times zero or more times so the expression over here is equal to 3 3 is a valid um term which is equal to a factor in this case and even 5 times 2 is a valid term because remember we said the term can be equal to a factor multiplied by another Factor what zero or more times so this is equal to a factor multiplied by another Factor so even this input is possible using our given grammar rules what do I mean by possible that means that it conforms to our grammar rules and such an input can be processed in the parsing stage now I'm going to use a data structure known as a binary tree which I'll talk about more extensively in the next few sections but I'm gonna introduce the binary tree to talk about parsing now parsing essentially involves uh again bringing structure into your code so let's say we have the expression one plus two times five I'm going to construct a tree for this given input and the tree is the following so this tree over here we are adding the integer one and we're adding the product of 2 and 5 and this is the past Tree in fact the goal of the passing process is to generate a tree like this of course we won't be drawing a tree like this in Python but we will be representing such a tree in a list so how do we represent this tree specifically I'm going to write it over here so I'm going to say one Plus two times five like so so in this scenario plus is the operator one is the left node in fact this is known as the root node I'll talk about this terminology in just few sections but this is the left node and this is the right node so over here one is our left node plus is our root node and right node is 2 times 5. so we have effectively represented this tree using this list in Python in this section of the course I'll be talking about object oriented programming and its four main pillars that make it according to me at least more Superior than the other paradigms or the other ways of programming so the first way is functionally functional based programming which uses po functions and functions is just a method like similar to how mathematical function works you have an input you give out an output that's basically it there's some inner workings to a function um it's like a black box you have an input you have an output but you don't see what's inside so that's how functions work and just to give an example let's say we're trying to calculate the amount of fuel that you have left in your car so we create a function called remaining underscore field and this takes in the initial field that you had the kilometers that you drove and also the ratio which is like the gallons per kilometer or whatever unit you're using liters per kilometer um the ratio of that and the remaining fuel would just then be equal to initial minus kilometers times the ratio so in functional programming or functional based programming you separate the data from the actual functionality you see that we have not accepted any data like the initial fuel that he had the kilometers that he had or the ratio we didn't accept any data this is just a standalone function a standalone functionality which can uh basically work fine I mean even if I run this right now there'll be no problems so uh it can work on its own as well so the actual um usability of it comes when we add some data and the essence of functional based programming is that you separate the data from the functionalities now over here I can give in some data let's say uh let's say I say the initial fuel is equal to 50 units the kilometers this person drove is um let's say 10 units or okay 10 kilometers and the ratio let's say is 5 units per kilometer five units of fuel burnt per kilometer drove so then I can calculate the remaining fuel I can print it as well remaining Fuel and I can give the parameters initial kilometers and ratio and this works fine so if I run again this time you see we have okay we have 0 exactly zero let's reduce the ratio here a bit and let's run that again you see we have 30 units of fuel still left so this is a pretty basic example of functions and it seems fine in this level but let's assume that you have a lot of complexity in your application let's say you're building a website and you have the authentication aspect of it you have the payment aspect of it you have the content management aspect of it so many entities uh involved now how do you because if you have so many entities involved you'll have several functions you'll have authentication functions you'll have um payment functions and all of them clubbed in this messy file uh where it just becomes difficult to handle things and that's where object oriented programming comes in object oriented programming divides it divides um code into entities called objects so you can have one object of payments you can have one object of uh of authentication one object of content management one object of uh maybe like contact or server where you have chat functionality or something like that I don't know so and in object oriented programming you divide an application into objects these entities which have their own um data and their own functionality now let's try to understand how objectoriented programming works on the canvas so as I said just as a recap let's just recap what I said uh in operator into programming also called oop you divide things into their own entities called objects so you can have maybe an object for payments so it has its own data it has its own functionality but it's all enclosed in this own entity known as payment entity we can have another entity for let's say authentication which has its own set of data its own set of functions completely different from the payment and you have authentication over here and you can go on and on but you get the point your um encapsulating data and functionality into objects which are the basic unit of object oriented programming and these objectives represent entities like payments and Authentication now in object oriented programming and inside an object the data is referred to as properties and the functions are referred to as methods so now that we've understood the basic gist of object oriented programming let's try and understand what are the four main pillars that hold it and make it such a solid way of writing your code so the first main pillar of object oriented programming is known as encapsulation and it's the basic idea we talked about in the previous section encapsulation refers to basically just start encapsulating uh Properties or encapsulating data and functionality into their own entities so that we can better handle them and it just enables us to write more cleaner code so as an example of our own situation over here we have multiple entities we have the lexor we have the parser we have The Interpreter so it seems wise to use object oriented programming because it can encapsulate each of these entities and have allow designate them their own properties their own methods their own data their own functionality so we can have Alexa which has its own data its own functions or methods there's alcohol functions for now because yeah so the data is known as properties and functions and objectoriented programming is called method are called Methods so this is one object you can have another object you can have a parser which has its own data its own functions and you get the idea we can have a similar class for The Interpreter this is called encapsulation by your grouping things grouping data and grouping functionality the second pillar is known as abstraction an abstraction just refers to simplifying the inner functionality the inner yeah basically just that the inner functionality into its own entity like for instance in our situation over here all we need to do an object oriented programming is create a Lexa which is of the object Lexa and let's say we tell it to let's say we tell it tokenize stuff uh using the methods so this is some notation which I'll go over in just the next section but all this is doing is creating an object called Lexa and it's tokenizing the inputs uh the input expression so as you can see this is a much this is a very clean way of writing code because essentially you're just abstracting away the inner complexities uh and the inner functionality of the Alexa all you're doing is calling the tokenize method and you have your tokens ready all you're doing is create calling the lexor object and you have your own lecture so that is known as abstraction it allows for core reusability the loss for modularity and essentially if you have different developers working on different tasks and they really don't know how the other developers developer is coding his his stuff so they can use object oriented programming to communicate they can say okay this is one component this this component will give a certain output you don't need to know how it works inside it's a black box you don't to know how it works on the inside but all you need to know is for a given input you're getting this output so that's what abstraction is abstracting away the complexities making code looks simple and let's move on now to the third pillar the third pillar of objectoriented programming is known as inheritance inheritance is a concept that is best explained by an example so let's say we are creating a website and each website has different components it has the home page the about page and the home page has different contents in it the about page is different contents in it but if you're designing a website you typically would have the same layout for each page you'd have the heading you'd have the body in pretty much similar positions so inheritance in objectoriented programming allows you to inherit certain common properties within object so what do I mean by this let's say we have our an object called page it has properties like heading body and the images may be so this is the base class this is um this is what you are inheriting from whereas you have maybe another class like another class like the home class which is the home page or the about class which is the about page and um these classes will inherit inherit all of these properties The Heading all of these will be inherited by the Home Home object and um yeah so again the home object would inherit the properties and the functions of the page object while having its own custom functionality which will which it will add over the page object so that's basically what inheritance is you have a fundamental object and other specific implementations of it like the home page the about Pitch inheriting from that fundamental object this is a theoretical discussion here I hope you understand what inheritance mean means in a more theoretical sense in this course I'll be doing objectoriented programming in Python so um I'll be talking about how you implement inheritance and all of that as well and with that knowledge let's move on to the final and fourth pillar which is known as polymorphism so the fourth main pillar in object oriented programming is known as polymorphism and polymorphism is essentially the idea that so polymorphism is essentially the idea that you can treat object of different types so objects of different types as if they were the same type so that may sound a bit confusing but I'll explain it using an example so let's say we have three types of animals we have dogs we have cats and we have Birds now the common thing about all of these animals is that they can make a sound so how can we program a way in which we can how can we program the sounds of these animals so maybe for the dog we do make dog sound so this is what you would typically do but now in polymorphism the idea of polymorphism is that you can make a common interface now in this instance the common interface would be an animal all of three all of these three entities are a type of animal so the common interface over here I can Define it to be an animal polymorphism allows you to do is let's say we create a method in animal called make sound and now using this common interface you can add some custom functionality to this make sound method so maybe the dog does a woof upon the make sound method the cat does a meow on the make sound method and the bird does a chirp on the mix on method whatever but polymorphism allows you to call the same functionality of the dog and the cat and the bird using the same method but each of these entities dog cat embed do it in their own customized way and that's the idea of polymorphism which means many forms it's the idea that you can allow objects of different types to be treated as if they were the same type based on a common interface and the common interface being the animal so that's the idea of polymorphism and with that let's move on to the next section in this section of the course we will be talking about the python implementation of object oriented programming now we've talked about uh the theoretical aspects of objectoriented programming in the previous sections where we talked about objects how objects Define certain entity and we group a set of functionality a set of properties into each object and we separate them using object oriented programming so how do you define an object how do you define one entity like as I said previously we can have a payment entity we can have an authentication entity we can have a let's say contact page always to a chat entity in in the example of creating a website so let's see we're creating a website all three of these are their own entities so how do we create these entities in Python how do we create these objects in Python Now to create an object we must use the pro the at the keyword called class a class essentially defines a blueprint for each object so as you might know the payment will have different set of functions authentication will have different set of functions the payment will have different set of input parameters it might have the user it might have the amount of payment the recipient the donator the authentication will have different parameters it will have maybe um the username the password the ID or the email address the chat will have different input parameters so because we have different input parameters different functionality for each entity we must Define a blueprint for each entity so let's say we create a class for payment now as I said we each each entity will have different set of input parameters like payment will have the input parameter payment recipient amount and all of that and it will have a different set of functionality maybe to process the payment authentication will have a different set of functionality maybe to check if the password is correct or something like that so we can Define we can take in the input parameters for each class using the init method it's a special method and this init method Works in a way that you can take in the self parameter here now I'll talk about self in just a second in fact let me just leave this as pass over here and I'll create an instance of this payment method this payment class so I'll create an object over here I can say payment one is equal to payment and this is where payment one is an object it is an instance of the class so it takes in the blueprint defined by the payment class and it it's an instance of that so this is an object over here payment one is an object it is an instance of the payment class so all of those blue all of the the blueprint defined in the payment class the attributes the functionality the data all of that defined in the payment class all of that comes into play in payment one which is an object which is an instance of the payment class how do you accept parameters like for instance let's say I want to pass in the parameter recipient the uh amount and let's stick to two parameters for now how do you accept these two parameters in the payment class so we use the init method for that and this takes in by default a parameter called self now self is the same as payment one so as you might know that there are you can have different instances of the same class I can have payment one for maybe one transaction I can have payment two for another transaction so let's say another transaction will have will be called payment 2 and this two will have a recipient these two will have an amount so um payment 2 is also an object of the payment class now how do you keep track of each object over here we use the self keyword for that so self refers to the instance itself now I can add to that instance I can say okay now self dot recipient equals whatever input parameter given over here so here we have given a recipient over here let's say the recipient is um I don't know person a and amount let's say it's 25 units and over here the recipient is person B and the amount is 50 units so self dot recipient is equal to recipient and what I am doing by this I'm saying what I'm doing by this is that I'm saying that uh the payment one object you add to that payment one object which is self you add to that payment one object you add a property called recipient and make that equal to the recipient input which is given over here and to understand what that means I'm going to print payment one dot recipient and if I run this over here um okay so we also need to take in the amount and I'm going to surf dot amount equals amount so over here we can see that the recipient is person a so payment one dot recipient defines uh the recipient for this instance I can do payment 2. recipient and this will print out B as you can see over here so just to summarize a class defines a blueprint a set of methods a set of data that can be that pertains to one entity objects are instances of a class you can have multiple instances of one class and you can accept parameters input parameters from each object by using the init method which is by default called when you create an object over here when I'm creating payment this init method is called so you can use the init method to accept input parameters like recipient and amount and we say okay now add to the current object a property called recipient and make that equal to whatever value is inputted over here this is one input this is another input whatever input parameters provided add that to the self dot recipient which is itself add that to that instance itself so now when we Define other functions like maybe let's say um check balance by default I have access to self by default I have access to the instance itself so now I can have I can say okay now self uh is the instance itself and in the init method we added properties like recipient and amount to the instance itself so now in the check balance method I have access to those parameters I have access to those variables so I can Sprint self Dot okay let's say we have an initial amount and after the transaction I'm gonna return self dot initial minus the amount of transaction so over here let's do uh let's print payment one dot check balance and this is initial not self dot initial so initial minus self dot amount and let's say initially he had 500 units of uh cash and now if I pre if I save and run again you see we have 475 left so we've called the check balance method we provided an initial amount and we subtracted the self dot amount which is uh which we remember we added in the init method so hopefully that makes sense if this is the first time your learning object oriented programming this may sound a bit complicated but I if you still don't understand it I encourage you to revisit this section again and hopefully you get in the second time so after you have understood what instance variables are effectively variables that pertain to one instance like uh the recipient the amount we'll move on to class variables and class variables generally are for the entire class for all of the instances these are stuff like constants maybe you have a constant like the dollar to pound ratio that's one constant and that will be same for all payments that will be same for all payment instances so those are class variables that are same generally same for all of the instances so let's learn about class variables in the next section so in the previous section we talked about instant variable instance variables and how we can create variables pertaining to each instance of the original class so over here we set the recipient and we set the amount of the transaction for uh each payment and in that way we created instance variables because they are pertaining to each object they were not the same for all of the instances like for instance if you make one transaction you will have a different amount compared to if you made another transaction so that's why we created instance variables that were that were unique to each transaction to each object but certain on certain occasions you need to have class variables wherein there you have the constant value for all of the instances and that's the main purpose of introducing class variables now in this example let's assume that this class payment acts like a ledger for an individual who is making payments on the internet so let's say he he's making a bunch of payments on the internet and um whenever we he makes a new payment an object is created so payment one corresponds to one transaction payment 2 corresponds to another transaction so whenever he creates whenever he does a new transaction a new object is created and this check balance uh method is run to check how much balance is remaining after each transaction in this situation we don't need to call the initial amount for every single object because the initial amount would be the same for no matter how many transactions he does the initial amount that he started with would be same so in this scenario we need to use a class variable to represent this value of initial initial being the amount of money he had before doing any transactions so to do that I can create a variable over here let's say initial balance and let's set that to 1000 and now how do we access this class variable inside this check balance method so first of all we don't need to accept a variable a parameter over here so we can remove that and instead of writing initial underscore balance because even if we do initial underscore balance you'll see that we're getting this green highlighted uh the clo highlighted problem over here saying that initial balance is not defined even though we've defined it over here and that's because to access a class variable we need to write the name of the class before the name of the variable so over here I can say payment dot initial balance and in this way if I remove these the second payment and just run this command you see we get that the the remaining balance is 975 units so that's the basic gist of class variables and with that knowledge let's move on to the next section in this section of the course we will be talking about class methods and static methods so traditionally in these classes you saw that each method accepted the instance itself like in this situation here when we created payment one which represents a transaction so in fact I'll just call it transaction one so and some trade that as well I'll remove that for now okay so um uh in this example we created an object called transaction one which represents a transaction and it is an instance of the payment class so it's an object which is an instance of the payment class and each method in this class accepted the instance itself the transaction one itself it's as if the first parameter of each of these methods is the instance itself and we do that because in the init method we can uh assign a bunch of properties to that instance given these input parameters over here like recipient and amount and then we can access those parameters uh pertaining to one instance in the other methods as well but sometimes you don't need to you don't want the self to be returned you don't want to have access to the instance which is transaction one but rather you want access to the class itself like say for instance we want to update this initial balance now one good way we can do that is we can create a class method which will take in the class as an input and then we can update the class variable over here so for that we can use a class method and how do you create that easy use a python decorator now we don't really need to know much about python decorators except that they modify the functionality of our class method so I'll use the class method decorator and now whatever method I Define over here which will be update initial balance this method will be modified so that instead of accepting self it accepts the class itself and we don't use the parameter name as class but rather CLS because that is already reserved for creating a new class so update initial balance and let's take an input as the New Balance let's say over here what I can do is I can say class dot initial balance and that's the same as doing something like this over here after the class in line 16 updating the initial balance to New Balance is the same as doing the following payment dot initial balance equals and if the new balance is 50 like so so it's effectively the same thing but we're now creating a class method and including the functionality inside the class itself so now if I do transaction one or let's do um payment dot update initial balance and I set the New Balance let's say 800 and then if I print transaction one dot initial balance and in fact we can even print it yeah this works fine so if I run this now you see we get 800 so since we modified the payment classes initial balance all of the instances initial balance also gets modified and that's why transaction one's initial balance is still 800. uh if we create another transaction it will also have 800 because it's an instance of the original class and since we've changed the class variable itself even the instance variables uh feel the same change so I can even do payment print payment dot initial balance and we'll get the same response if I run this you see we get 800 again so that's a class method now sometimes you you need to use static methods and static methods are basically methods that do not accept any um input parameter by default so in these in a traditional method in a in a class we by default accepted the instance in a class method we by default except the class but in the static method we by default except nothing so that's effectively a simple function but we want to function inside a class because it is closely related to the class so maybe one type of static method we can add is checking if the transaction can be held because checking if the transaction is between the working hours so maybe that's between 8 AM to 5 PM so if a transaction is not within those bounds then we'll have to return false else we can return true so for that I'm going to create a static method and the exact same way we do at static method and then over here we can say check valid transaction and this will take in Nothing by default but I want to take in two parameters the hour and let's say the 24 hour system so I'm going to say if our is um greater than 8 greater than equal to 8 and our is less than equal to um 5 PM which is 17. I'm gonna say return true else let's return false so and this works because if the condition is true we'll return true and exit this function and we won't reach this error but if this condition is not true then we won't exit the function and we'll directly return false so now let's try this so I'm gonna say let's get rid of this as well and I'm going to do transaction one dot check valid transaction and we're going to say the r is 13. and let's print this if we run the file you see we get true if I given something like 24 or less to 23 24 is invalid we get false so that's the basic idea of class methods and static methods and with that knowledge I'm going to go to the final section of object oriented programming which will talk about how we can inherit from parent classes and all of that so for all of that and more I'll see you in the next section so now it's time to talk about inheritance and how we can inherit the properties and methods from another class and to do this I'm going to use an example of a website so in our website you have multiple Pages you have the home page you have the about page you have the contact page and I'm gonna create a base class which is like the fundamental class and that's going to be the page class so this class is going to be page and this is going to have its own init method so the page class will take in um properties parameters like first of all we'll take itself by default and then it will go ahead and take the heading of the page and the body of the page so over here I'm going to say self dot heading equals heading and self dot body equals body moving on I'm gonna create a method called create page so over here I'm going to create underscore page and this will just return HTML code of that page so keeping it very simple let's just have a header tag and if you are not sure if you haven't learned HTML code uh all this is doing is creating a heading using a header tag and it's creating the main body text using a paragraph tag so over here I'm going to say H1 so this is the heading tank and within it goes the heading so I'm going to use an F string to embed self dot heading here so whatever the heading is we're gonna embed it inside the heading tag and then we're gonna create a new paragraph and this will contain the body so this opens the heading tag this closes the heading tag and within the heading tag you have the value of the heading which remember we assigned to the instance of the Page by accepting the heading as a parameter in the init method and over here as well same thing we're going to do it with self.body over here I'm going to return the HTML code to and that's going to be pretty much it for the page class now I want to create another class for the contact page but there'll be a lot of overlappings the page class is like a bigger Circle and the contact class is a smaller Circle within it so the page class is like the parent class of it where the contact class has to inherit stuff like the heading and body from the page class itself because if okay let's just assume you're creating a contact class like this in a simple way then we'd have to copy all of this code and paste it again like so and this is a very inefficient way of working because uh we have the page class which is the base class why don't we just inherit the init method why don't we just inherit the create page because they are effectively the same methods because um they have the same functionality contact page is after all a page and therefore it will inherit some of the methods and some of the properties like software heading and self.body and some of the methods like create page from the page class so how do you inherit how do you inherit these properties and methods from the page class now in Python you use the following notation so you go a pair of parentheses and you write the name of the class you want to inherit from and with that all of this code is saved I don't need to rewrite it again and all I need to do is plus pass essentially do nothing in the contact class and now let's create a contact page so I'm going to say contact UNESCO page is equal to contact and I'll provide a heading let's say um contact us and the body text will be please give us your feedback foreign dot headings let's see what the heading is and if I run this okay so I need to print that so let's print it and if I run you see we get the headings contact us so even if we don't have an init method over here it doesn't matter the python would first look in the contact class to see if there is an init method it doesn't find it it will go to its parent class which is the page class and over here it finds in it it finds an init method and it assigns self heading to heading it sees that over there and from that you see that the contact page instance gets the heading variable attached to it and then when we print it we get contact us as the heading so it first looks in the contact class if it doesn't find the net method it will go ahead into the base class so another thing we can do is create a page We inherited that method so if I run now you see without any code in the contact class it doesn't matter we're getting the same output here because we've inherited the method and the variable from the page class so now with that done I want to talk about one more thing which is the is instance um function the is instance function in Python is used to check if an object is an instance of a particular class I'm sorry for that so let me repeat that again the is instance function checks if an object is an instance of a particular class like for instance over here let's print is instance uh contact page of the contact class and as you'd expect it says true yes the contact page is an instance of the contact class because we have written contact over here if it's an instance but another thing we can check for is if it's an instance of the page class and if I run this now you'll see that 2 will return true because although it's not directly linked to the page class the contact class in helps from the page class and therefore contact page is also an instance of the page class so we'll use this function is instance a lot during the coding of our um uh of the of our programming language so it's important to note the functionality of is instance another another thing I want to talk about is the super function so over here I'm gonna create the init method and let's say I want to accept another parameter for the contact page let's say I want to accept the email address of the person who wants to contact me now that's not that in the base page class because not every page would need to extract the email address but it turns out that the contact page does need to do so so over here it'll it'll extract The Heading first of all self in heading then body then the email address and over here what do I do do I just copy this part over here and then do self dot email ID is this the correct way to do it well let's try it out so if I um given an email let's say um if I get that email in and let's print the email ID if I run this you see this will work we get the email ID but code repetition is not always appreciated it's never appreciated in fact in uh in programming and therefore to avoid this repetition of assigning heading and body to the um instance instead of repeating this since we already have that functionality in the page class we use the super function so the super function calls the init method in the parent class which is page it calls the init method and we can pass in parameters heading and body so this ensures that the init method is called in the super class and the super class is the page class so this is like saying go to the page class and then run the init method and provide the heading and body as parameters so that's effectively what the super function is doing so after we have um handled heading and body then we do self dot email ID equals email ID and let's create another function over here let's say I want to create a contact button and this will take himself and all I'm going to do is return button and then inside the button I'm going to say self.email ID contact now something like that so if my name is if the email ID is ABC email.com then say ABC email.com contact now and this will be inside a button so in the edge in HTML the button tag is used to create a button so over here let's do the same thing let's contact page now we're going to create the contact button and let's print and hopefully this works there we go button ADC email.com contact now so this is the power of inheritance we are adding uh we are extending the functionality of the base class which is the page class we're extending its functionality by adding our own methods while also inheriting the most fundamental uh functionalities like create page and we're also inheriting the um the init method over here previously we we didn't even have to write the init method it automatically found it from the page class and executed that so that's the power of inheritance and with that I'm pretty much done with object oriented programming of course we want to understand objective object oriented programming on a deeper level there are several other Concepts to understand but I think that we've reached a fast stage now where with this base knowledge we can move on to the next section so in the next few sections we'll be talking about data structures and we're going to start off with lists now lists are like regular list that we talk about in common language in everyday language you can have a list of grocery items you can add add to the list of grocery items you can remove something from the list of grocery items you can add something at a certain position so let you know so it maintains a sequential order as well that means it respects sequence that means you can add elements at a certain position uh you don't it's not just that you can add them at the last position at the first position so let's demonstrate everything about lists in Python so this is the simplest form of data structure we'll go on to more complicated forms like eventually we'll talk about binary trees so anyways let's start with the list how do you create a list in Python uh you first create the name of a variable so I'm gonna call the variable R short for array so or let's just call it um I can't use list because that's a reserved keyboard so let's just use um a let's call the list a and you create a list by using these square brackets and I can create the first list by saying one comma two comma three comma four and that's one list over there you can add to the list using the append method so all of this list in Python are builtin classes so that means if I print is instance a of the class list and that's a builtin class if I run this you see it will return true because it's a builtin class and when you use these square brackets you sort of create an instance of the list class so over here in that list class there is a method called append so I can append let's say a number let's say append five and now if I print a you see that the output will be one two three four five the append method adds three last element um there is another method two which is called insert and the insert does not necessarily add at the last at the end of the list it can add things even in the middle or whichever position you define it to be in Python uh the position are defined by starting with the number zero so this first element is called is given the index 0 the second element is given the index 1 and so on so 0 1 2 3 so that's the uh order so you start off with zero so if I say print a square bracket 0 that means I want to access the zeroth element which is the number one so we'll get the number one over here so um we can insert as I said so I can insert a certain data it can be anything it can be a number it can be text whatever so I'm gonna into insert the number eight at position two so that means 0 1 2 that means it should be after the number three so let's print a now and see what we get you see it's um okay I I reverse the order my button so we have to mention the position first and then the numbers of two comma eight now let's see if it works so if I run this you see we get it before three so one two eight and three so at position two so zero one two so now this is a position two over here and follow me following that does the number three then four and five so that's the insert method um for lists I can even add a text here so we create text using these double quotes and let's say text and if I run this we'll get one to text at the second position remember zero one two second position second position three four five and that's that's how it works you can reverse the order so you can have five first in four second and so on by using the reverse method so I'm going to say a DOT reverse and if I run this you see we get it in reverse order we can sort it in ascending order and we can for now I'm going to say ascending number of order of numbers so let's say I have the number 9 here and I'm going to print it print a over here before the sort so before sort and then I'm going to sort a DOT sort and then I'm going to print a again and if I run this you see I'll get before sort it's five four three nine two one but after the Sorting process is stored in the sending order another method is the pop method and this Returns the last element of the list and also removes it from the list so if I right now let's remove all of this clutter and if I do a DOT pop and then I print a let's run this again and you see we get one two three and in fact I say if I can say last underscore element is equal to adopt and if I print the last element I'll also get what the last element was so if I run this you see I get 4 was the last element and now what remains of the list a is one two three so you can also remove all of the elements by using the clear method so over here I can do Aid or clear and if I print a run it you see we get an empty list which is symbolized like so so now let's move on to a few more operations one more Opera one operation you have is let's say I have the D list one like that now I can print or I can do a equals a times five and now let's print a you may think that that makes no sense but that essentially just multiplies this item by Phi so that means this item will be present five times now so 5 times 1 is 5 if this was existing twice then it will add the same array five times to itself and a would look something like this so if I run this you see we get the array with 10 ones because the first base array is with two ones and then you multiply that with five and you get 10 months so that's uh how you can multiply or is you can even add arrays to each other so if I one array is one comma two another array is 3 comma four now if I print a plus b and run this you see we get one two three four so that's how we can add or multiply arrays one more thing you can do is you can go you can iterate over a range of values in an array so like say for instance I have one two three four five and six now if I print a one two three so a one two three let's see what we get over here so if I run this CC I get 2 comma 3 and this starts off from the index one which is here moves on to index two and it excludes the last value here so uh if you want to include the last value you have to add by once three plus one four and in that way it will include two three four like that so let me just um rephrase again so you have at index one you have the number two so two comma three comma four and this is index three zero one two three and this last is since it's four over here but um when you're when you're taking it over a range it does not include the last number it does it one minus that so foreign returns the list from a to the power 1 to a to the power a 3. so index 1 to index 3 that's how it works you can also have um no number to start and that will return everything until the index number three so if I run this you see everything until index 3 if you don't specify a number over here if I specify a number over here it'll be from index 1 to index 3 but if I don't specify it it'll be from the start to the index 3. now after that you also have um copying arrays so how do you copy one copying list so how do you copy one list from to another list so let's say I have this list over here a equals one two three four five six now A2 I want to copy uh list one so I'm going to say a and uh let's see what happens if we do this so now if I print A2 you see we do get one two three four five and six but check this out if I do A2 dot append seven and now I print A2 obviously it will have the seventh number after it but if I print it and run this again you see even a has experienced that change so when you equate these two together even a experiences the operation zero after that of after line two if you don't want that to happen you want to leave a as it is and work with this as a new array you can use the copy method so dot copy and if you do that you see this change does not get implemented on array a it's only implemented on array A2 so that's about it for lists tuples are quite similar to lists in that they also store data in non in an ordered manner so you can create Tuple instead of using by instead of using square brackets you use the normal brackets so over here I can say Tuple one equals and you use a pair of brackets over here and I can have one comma 2 comma 3 I can print the first element of the Tuple which is the zeroth index I can yeah let's just do that for now and you see we get one over here so that's how tuples work it's very similar to list but they have a few distinctions that you need to keep in mind one of the distinction is that a tuple is immutable so if I try to do the following Tuple one zero and I'll try to change the zeroth index so let's say the number five and I save it you see we get an error Tuple object does not support assignment so this is why tuples are immutable they can't be changed whereas lists are mutable so if I do list one equals 1 comma two comma three and then I do list one zero is equal to 5 and let's comment this one out and I run this you see we don't get any error over here and let's just print list one as well if I run this you see we get 5 comma 2 comma 3 because lists are mutable but tuples are not one additional thing you need to note about tuples is that if we have a element if you have a tuple with one element then you can create them by using the following notation you do not you can't have no comma over here because if you do brackets one brackets that will mean that this is just a number inside a pair of brackets it does not resemble anything but if you put a comma over here you would realize that that's a tuple so in fact let's try and see the instances were whether it's an instance of Tuple or not so let's print is instance Tuple one of double if I run that you see we get false but the second I put a comma over here I'm telling python that this is a tuple I want to create this as a tuple so if I run this you see we get true over here now it's also possible to convert tuples to lists and list tuples so I'll delete all of this now and I can say list one equals Tuple or equals list of Tuple one and if I print list one you see it will be a list as you can see and if I do this one over here and let's create a list over here and I'll do tackle one here and let's create a tuple from the list you see that that too will work we get a tuple over here so that's about it for tuples let's move on to the final sort of simple data structure which most of you might already be familiar with but I thought it would be a good idea to give you a refresher about these data structures see the last one will be talking about is dictionaries and then we'll move on we'll move on to few Advanced data structures like Stacks or binary trees which we will be using in this course so I'll see you over there so how do you create a dictionary in Python well we use there are two ways to do it the first way is a simple one you just use a curly brace pair of curly braces and then the first thing you mentioned in a dictionary is the key so in a dictionary you have key and value so you have key value Pairs and an example of this will be the following so let's say I have an employee and his name is John so over here name is the key John is the value this employee will have an age and you have to also include that in double quotes and his age is 19. um this employee will have a profession let's say it's accounting so that's this that's how dictionaries work you have a key you have a value and these pairs you can have n number of them in a dictionary stored in a dictionary so the purpose of dictionaries is that they can store two values key they can they can store two pieces of data key and value and they're actually pretty useful when for instance creating Alexa where each token will have of a data type and a value like for instance the number five has a type of integer and has the value of five so in that sense dictionaries are really useful because they allow us to store two pieces of data how do you access uh values so you can say dict one um say the name of the key so let's say the name and let's print this so similar to an array how we use the square brackets to access a certain index we will use a square bracket to access the value of a certain key let's print this run it we get John we can do age and we'll get 19 and this doesn't necessarily have to be a string it can also be a number so for instance let's say 5 is um I don't know 26 okay this makes no sense but I'm just trying to show how you can also store the key as an integer as a number so over here I can access the key 5 and that will return 26. one more thing you can do in dictionaries is Traverse through them iterate through each item of a dictionary and you use a for Loop for that so I can run a for Loop we can extract the key and the value indict one by using the items method the items method is a certain method present in the dictionary class which is inbuilt in Python just like the list class and the Tuple class so over here we're extracting the key and the value and I can print that in F string I can print key with the space bar and then value and if I run that you see we get name John age 19 professional Accounting in a new line every single time so that's the basics of dictionaries and that's all you need to know for this course and with that knowledge let's now move on to a few more complicated Concepts in data structures in this section of the course I have brought an interesting activity that you can do using the existing knowledge that we've built so far so we are going to create our own class for data structure known as a stack now a stack is effectively just um it's just like that it's just what the word describes a stack you can have items stacked on top of each other you can add an item at the top of the stack but you cannot add it in between the stack like we did in a list where we added items in a certain position of the list where we can't do that with Stacks the only three operations you have is you can add an item on top of the stack you can remove an item from the top of the stack or you can read the value of the item at the top of the stack so I have an activity for you how about try creating a class that performs all of these uh functionality so we'll have a class called stack and it will have an init method of course but I won't write that for now it will have three functionalities push which means adding to the stack adding an element to the end of a stack to the to the top of the stack we have pop adding an item to the top of this removing the top most item from the stack and you also have Peak which is reading the value of the item on the topmost of the stack so these three functionalities push pop and Peak can you try executing them using python list so you will be using python lists as a data structure to create the stack so now let's move on to the task how does this work so I'm going to first create the init method which takes in self and it will yeah that's it self and over here I'm going to create the stack now the push method adds an item to the top of the stack so this will simply append to the list Whatever item so we need to take self over here first of all and we also need to take the item that you want to push to the top of the stack so I'm going to say item over here we're going to append item we can pop as in remove the item at the topmost of the stack and for that we can use the pop method in in list so you can do pop and I'll also accept selfio and we can return self.stack.pop this removes the topmost item from the stack Peak we'll just return the topmost item from the stack now in Python to extract the last item of list because ins since we're using list to represent the stack the topmost item is the last element of the list so how do you extract the last element of the list for that I'm gonna use self first of all and I'm gonna say last underscore element is equal to self dot stack the length of the stack minus 1 because the indexing starts from 0 and in this way we're extracting the last item of the list which corresponds to the stock topmost element of the stack so this is the last element and I'm going to return that last element so now let's try working with the stack so I'm going to say stack one is equal to stack and I'm going to stack one dot push let's push um the number five stack one double push number three stack one dot push the number seven and now I want to pick I want to see the topmost element of the stack so I'm going to print stack one dot Peak which is which will Peak at the topmost element of the stack since the first the bottom most is five then in the middle there's the number three and then the top of the stack is seven we should get the number seven so if I run this I get seven over here so that's it from this section I feel that this was a good exercise to get us warmed up for our upcoming challenges in creating the programming language so with that exercise let's move on to the next section where we will be talking about binary trees a binary tree is a form of hierarchical data structure it looks something like this so you have um the following placeholders you have a you have B C all of these points and these points represent a storage of data they're called nodes nodes are a unit of data it's a representation of data it's a placeholder for a day for a piece of data so B over here C and then we can do d e like so and this is a binary tree now a binary tree means that each node has a maximum of two children the child of node a is B and C so this is the left child this is the right child so the children of node a are the left child and the right child which is node B and node C and in a binary tree every node has a maximum of two children as you can see nodes d and e have no children and they are called Leaf nodes node D has two children node C maybe we can have one child to it like that so the idea is simple binary trees have a maximum of two children every node in a binary tree has a maximum of two children a bit of more terminology is the fact that every single level is given a number so this is called level one and it includes only node a this entire thing is called level two and this entire row is called level three so that's just the uh terminology used in describing binary trees but what's the use case of it how does it work we'll look into that in the next section the most important part the most important part of binary trees is a way in which we Traverse to them the way in which we visit each node and analyze and process each node so there are three ways of traversing a binary tree and just before we get into that I'm going to talk about something called a sub tree so I have the root node over here uh this is called the root node which is at the top of the tree and it has a few children two children maximum of two children and every single node after that also has a maximum of two children until we get to the leaf node which have no children so d and let's do e over here so in a binary and I'm going to do one more F over here in a binary tree we also have sub trees so this entire region which is uh enclosed by the dotted line is a sub tree it's a tree within a tree and now that we understand what subtrees are we can try and understand the traversal methods how you visit each node of the tree traversal refers to the fact that you have to visit above you have to visit each and every node in a binary tree so how do you do that there are various ways in which you can Traverse through binary tree and we're going to talk about three ways the first is called preorder traversal preorder traversal refers to the fact that you first go to the root you first visit the root node then you visit the left subtree and then you visit the right subtree so I'm gonna call the subtree over here subtree one and this subtree will be 2. so how can we Traverse to this entire tree Traverse through this entire tree by using the preorder traversal method so the first step is going through the root so we start off with node a then we go to the left subtree so then we Traverse through left subtree and then we Traverse through the right subtree now we need to understand how we Traverse to the left subtree which is subtree one and we use the same pattern over here we start off with the root root so we go from B then we go to the left sub tree and the left sub tree is just node D so this is the left sub tree over here so that's node d then we go to the right subtree which is node f so that's what the preorder traversal of subtree one looks like the period of traversal of subtree 2 will look like first we start off with the root node there is no left subtree so we don't do anything then we move to the right subtree which is e over here so in preorder traversal the order of traversal is a B d f c e and this is known as preorder reversal we sometimes use preorder traversal we visit uh D3 in such a way to accomplish certain tasks in our scenario where we will be where we want to pass inputs parse uh inputs in a certain programming language and then given then execute it we have we'll be using post order traversal so let's take the example of an expression one plus two times three now how does all of this relate to a binary tree so we can represent one plus two plus times three instead of this expressed in a linear way like a list of tokens which is what we do after step one after lexical analysis step two involves making this linear data structure and converting it into a hierarchical binary tree so how can we express this expression as a binary tree so we start off with the plus operation which is the topmost which is the root node then we go left which is the number one then we multiply 2 and 3. so this is the binary tree of the expression 1 plus 2 times 3 and the way in which we Traverse it affects how we get how we evaluate the expression so in post audit reversal so we talked about preorder traversal in the previous section now I'm going to talk about post order traversal in post order you start off with the left subtree then you move to the right subtree and then you move to the root node so the left subtree is the following dotted line the right subtree is also the following left sub tree it's just um so I'm going to call this subtree a I'm going to call this sub tree B so subtree a is equal to just 1 you start new that's the only thing you can that's the only way in which you can Traverse subtree a sub tree B if you want to do a post order traversal on this you start off with the left subtree which is the left node over here the node two then you move to the right subtree which is node three node three and then you do the root node which is multiplication so now finally to evaluate the binary tree we start off with the left subtree which is a to be to the root and that's 1 comma 2 comma 3 comma multiplication um yeah comma root so that's the way in which we Traverse through the Stream it's called post order traversal and the idea in personal traversal and how it relates to Computing or expression is the fact that the order of operations with higher precedence lie lower down the tree and do in Expressions when evaluating expressions we give preference from left to right so if you compute compute seven divided by 2 divided by 3 we compute this first and then the answer of that we divided by three so the higher presence is given to left than the right so this is one fact and the other fact is that we give precedence to to multiplication and division more than the preference to addition or subtraction so in this scenario the order of operations with higher preference are lower down the tree they have a higher level so remember this was level one so they'll be lower down the tree will have a higher level and by traversing them in a postorder manner like one two three multiplication and then the root node by traversing them in such a way we are first Computing one then we are Computing the multiplication and then we are adding those two together that's what the effect of post order is so now let's understand how post audit reversal relates to Computing and expression so let's say we have the following expression one plus two times seven so over here we're gonna have addition first or in fact I'm gonna um do multiplication first because we already used a similar expression let's do one times eight plus seven so plus and then multiplication one and eight and seven so in this example over here let's start to do Post audit reversal so remember it's left subtree then it's the right sub tree and then it's the root node so that so the left subtree is the following and in here again we have to do Post audit reversal so the left subtree of this sub tree is the number one then you go to the number eight then you go to the root node which is multiplication and then again we move to the right subtree which is 7 over here this is the right subtree and then we move to the operation Plus so that's the post audit reversal of how this works and now let's try and see how we can compute an expression using post order traversal so I'm gonna erase this bit and over here uh yeah so over here let's see by following this order of operation by following this order of traversal how we can compute the expression so remember the first thing we're going to do is visit the root node the the node one which is over here the first thing we do is visit this so we visit this a then the second thing we do is visit this so B third thing we do is visit this so C then D and then finally we visit the plus operation so e so we start off with first then eight then multiplication then seven and then Plus so how does this relate to Computing and expression so we first visit root uh we first visit this node over here so I'm going to call that node a we first visit node a and we process it so that's the number one so we first process that um so let me keep that over here so one we first processed that process that then we go to root B and we process that we get the number eight so now we've processed that as well and it's the number eight then we go to root C and we process that okay now we see it's the multiplication of one and eight so then over here all we do is 1 times 8 which is equal to eight so in multiplication so there are two types of visiting one you visit a number in which you just return that number one or eight the second type of visiting is when you visit a binary operation over here plus is a binary operation is adding two numbers multiplication is a binary operation it's multiplying the left child node and the right child node so when we visit a binary operation we have to multiply the left trial node and the right child node so now we visited the multiplication node which is which was node C and we computed it it turns out to be eight times one which is eight so we visit uh we visit one first we visit eighth then then we use multiplication so we're done with this this and this then we visit node D and we compute it it turns out to be value of 7. 7 I'm sorry I just glad had a glitch over here so after we've processed node node 7 the the following node over here after we've processed that then we go to the root node which is over here and we do a binary operation we check the left node we check the right node and we compute them we add them together and the output turns out to be 15. so that's how we will be interpreting our input expression and this can be replicated for all of the input expressions in the programming language like say for instance we have an input a equals seven so then the operation would be equals and then a and then seven then we'll have to uh Traverse in the post order method and we'll have the similar output so that's how we're going to compute Expressions that's how we're going to interpret our parse Tree by following a post order traversal method and with that knowledge and I hopefully I hope that you understand how we are going to compute Expressions because this is an integral part of our course so now that you've understood it let's move on to the next section where we will be constructing a binary tree and doing some exercises with them so in this section of the course we'll be creating a binary tree essentially representing them in a programming language as of now we've just been drawing them and talking about them in a theoretical way but now we'll be creating a binary tree in the Python programming language so the first thing we need to do is create a class for the binary tree in fact I'll just call it 3 for now and this will have the init method and it will take in a root node to start off with and the root node I'm going to assign it the value of let's say 5. but I don't want to work with just numbers for now because I know that nodes denotes can also represent other pieces of data so to represent a node I'm going to create its own class so I'm going to create a class for the node as well the node class the node class will accept one parameter it will be the value of the node and I'm gonna say self dot value is equal to value and the node has two parts as you remember in a binary tree a node can have a maximum of two children so I'm gonna represent the left child by initially none so initially the node has no children and the right child will also be equal to none now let's go back to the tree and let's set the root to be equal to a node with the value of the root so over here we can create our first basic Tree by saying okay the tree is equal to an instance of the class tree and the root node will have a value of the number five so this is just creating the number five it has no left node it has no right node for now but let's add those parameters in so I'm gonna say tree dot root so the root uh variable now we're accessing that since it's uh it has a class of node I have access to these parameters left and right so I can assign these values I can say three dot root dot left is equal to 3 and 3 is equal to node three let's do node three and three dot root dot right is equal to node 4. what is the effective representation of this this has five at its root and it has three as the left child the right child of this node is 4. so this is the diagram this is the tree diagram um that we have created using python code so there is a tree it has the root of 5 and that's just a node with left and right assigned to be 3 and 4 and the left and right nodes of 3 and 4 are by default sent to none so that's how we can create a binary tree in Python now let's go ahead and do preorder traversal on this tree to perform preorder traversal I'm going to create a method called preorder in the tree class itself so I'm gonna say def preorder and this will take in self and the first parameter the first parameter it will take is the starting point of the preorder and this will be the root node but as you will see we will change the starting node and we'll be using some recursion in this algorithm so uh yeah so the starting dot initially will be the root node but we take that as a parameter and another thing we're gonna take is the records field and I'll explain what this means in just a second but for now I'm gonna say if the starting point is not none which means if the starting point exists because remember for the left and right notes we set them as none so all we're checking is if they're not none that means if the starting point exists if the node exists itself then the first thing we're going to do is we're going to append that node to the records list so the records over here corresponds to a list which will be an empty list for now and over here we're going to append it uh the start dot value so let me talk about what this means again so remember in preorder traversal we go in the order of root then we go to the left subtree and finally we do the right subgrade so in this case let's look at the uh the diagram so it's five the three diagrams so it's 5 starting off with five then we go to 3 in the left node and then over here 4 in the right node so we want to start off with the root so the in the preordered traversal over here we're going to start call to preorder so I'm going to say tree dot preorder and I'm gonna pass in D root first so I'm going to say three dot root that is the starting point and Records will be an empty list so now let's see what happens so the first parameter is three dot root second parameter is an empty array so tree dot root is the starting point and start is not none and therefore it will append the starting point which is the root itself to the records records will be tracking our visits so the order of wizards that will track the order in which we Traverse through the nodes so the first thing that will be appended to the records list will be the root itself and that confirms that uh pertains to our rule of preorder reversal where we start off with the root so indeed by printing I'll be by appending the starting point value which is roots value to the records list we are abiding by the rule set by preorder reversal now let's go ahead now we want to do preorder traversal upon the left subtree because remember when we were Computing a preordered reversal we started off with the root then we went to the left subtree and we did preorder traversal within that left subtree so now to compute the left subtree we need to do preorder traversal in the left subtree so I have to do records equals pre self dot preordered reversal so we have to do a preorder traversal on the left subtree itself so the starting point now won't be the root it will be the left node left child of the root so I'm going to say start dot left so over here the starting point is root I am going to say start dot left we want to do a preorder traversal on the left subtree itself so this is where recursion comes in recursion is the act of calling your own function inside the function so we're calling the preorder method inside the preorder method itself so over here we're doing uh start dot left so we want to do preorder reversal on the left child on the left subtree so how will this look like so we start off with five then we go left and we start off with number three and we do preorder traversal on the sub tree over here so right now there's no subtree but let's say there was so I'm gonna move them to the right and over here I'm going to add one final uh item it's going to be let's say the number two and over here we have um two child nodes for this node three and let's say eight so over here we start off with the root tone append that to the records array and the first thing we have is the is the root perfect River it's working perfect so now we move on to the left subtree we do preorder traversal upon this node 3 over here and that will call again that itself will call start dot left so it will do preorder traversal on this left subtree itself so we are calling preordered reversal on the left sum trees until we hit a leaf node until we eat a leaf node well self dot left is equal to none and we break out of this so that's the power of recursion so now we're going to do records so remember we had to compute root then left subtree and now we're going to do right simply so records equals preorder start dot right and over here I also need to provide the records list itself as an input so now let's see how this works so I'm gonna list and I'm going to print the output given and if I run this file you see we get five three four so okay I shouldn't have deleted that comment over there so I'll just copy all of this and bring that tree okay there we go so let's paste all of that again so this is how the tree looks like five three four so we start off with the root note then we move left we compute that left subtree then we move right we compute the right sub tree so from root the left and then right even if we have a more complicated three like for instance we're gonna add uh let's say we had that the left sub tree within the node three so let's create that over here we're going to say tree dot root dot left which is node three for that node we're gonna add another left and that will be node node two and then three dot root dot left dot right it's right child will be equal to the node eight so even if we have this complicated expression how would the preorder traversal work we'll start off with the root then we'll compute the left subtree and we'll do preorder traversal on that left subtree so we go from root against 5 3 and then we start off let's subtree which is 2 and then eight so we should have the expected output to be 5 then compute left subtree so that's we compute left sub 3 using preorder traversal so that left subtree is three to eight so this is the left subtree over here uh if I can highlight just that part okay if I can't do that right now but let me delete that so the left subtree is this so how do we compute that left sub tree using preorder traversal we start off with the root so three then we go to the left subtree of that left subtree which is two then we move to right okay and here it was I believe the number four and then we move on to the right subtree which is the number four and this should be the order of preordered reversal so if I save and run you see we do get five three two eight four so this is what recursion looks like now if you still don't get it it's perfectly understandable because this is a complicated concept to grasp initially so I recommend you to move on to the next section understand recursion how recursion works and we'll be looking at a few algorithms dealing with recursion and then come back to this section where we will be talking about preorder traversal again so in the next section we'll be doing post order traversal and then after that we'll do uh recursion we'll talk about recursion and the types of recursion algorithm algorithms so for all of that and more I'll see you in the next sections now I'll be doing the post order reversal which is quite similar to the preorder traversal but except remember the fact that we have root over here that line corresponds to appending to root appending the route to the records list this is the left subtree feel like I've said that or not but uh yeah that's what recursions about doing things again and again so left subtree and this is the light right sub tree so this was the order in which we created the preorder method and over here now to do Post order remember that's just left right and then the root so all we have to do is say Define post order in fact I'll just copy all of this and starts with self start and Records and let's paste and over here instead of putting records.pend first instead of registering the root first I'm gonna register the root last so now let's try post audit reversal of this uh binary tree so I'm going to print three dot post order tree dot root starting at the tree dot root and an empty array so if I run this you see we get um okay we get none because I did not return so let's return as well let's return the records and now let's run and you see we get a different order of traversal remember the tree order traversal for uh post order so how does post order work you start off with the left sub train okay this seems to be a problem it should start with two and then move on to write and then to the operation I think I have made a mistake over here okay yeah so yes so I forgot to change this to post order because we will be calling the post order instead of preorder so I'll do Post order here and if I run this again you see we get the correct order of operations we start off with two then we move on to eight then three then four and then five so I'll do this one last time I'll give this a complete summary of the explanation if you've understood this completely congratulations you can move on to the next section where we will talk about recursion but uh I'll just I just want to summarize preorder and post order one more time so preorder this is how it works we have created this tree then we have the condition check if the stock is none or not root is no is not none so then we move into uh this if statement we append the route because preorder starts off with the root then the left subtree and then the right subtree so we append the route first to our records array and the records array symbolizes the order of visits that we've done so we first append the root then we go down here and we say records equals self dot preorder and we're essentially doing preorder reversal on the left subtree itself so start dot left now we make this the root and three to eight we make that the left subtree and we do preorder traversal on it itself then we do preorder traversal on the right subtree and then we finally append the records uh then we finally return the records so that's how preorder traversal Works post order is the same thing except we do the root at the last so I hope you get that and in the next section we'll talk about recursion so to get you more familiar with recursion I have prepared two problems in programming one is the Fibonacci sequence and the other is counting to a certain number so hopefully these two exercises will help you understand recursion which we will be using a lot in the later stage of this course so the first problem is the Fibonacci sequence now if you're not aware the Fibonacci sequence is a sequence of numbers that starts off with the first numbers being one and after that the from third number onwards the any nth number you take any nth number it's equal to the sum of its previous two numbers so the third number is the value three okay sorry the third number is the value 2 because 1 plus 1 is 2. now the fourth number what is the fourth number equal to it's the number two plus the number one which is three the fifth number is the number three plus the number two which is five so that's how you construct a Fibonacci Sequence now how do we come up with a program that will tell you the value at a certain position that given a certain input like for instance the number four it will give spit out the value the number three so how can we come up with other such a program given an input of the position of the Fibonacci sequence it outputs the value of that Fibonacci Sequence so how can we come up with such a program so first of all I'm going to use a function I'm going to call create a function called Fibonacci and it will take in the position and it will return the uh value at that position so we're going to use recursion to solve this problem now let's take any position like this is the fourth position at the fourth position you're summing the second position and the third position values so we can Define Fibonacci the we can say Fibonacci or let's say output is equal to the Fibonacci of the previous position position minus one plus the Fibonacci of position minus 2. so we have an output we are recursively calling again this is recursion because we are calling a function inside a function we are saying okay the output is equal to the Fibonacci value at position minus 1 plus the Fibonacci value at position minus two so at position 4 it's the one previous to that which is the number two and two times previous to that which is the number one so one plus two equals three now this works for most cases but except for the first two scenarios where the first two scenarios the output is just equal to one so to handle this case I'm going to say okay if the position is greater than 2 or let's say greater than or equal to 3 from here if it's greater than equal to 3 then we're going to use this expression else if it's not greater than or equal to 3 then I'm just going to return the number one because in that case it's either one or two and for both instances the output is one so we're using recursion to um handle to solve the Fibonacci problem we can return the output given a certain input so now a better way to write this is I am going to say output equals one output equals the following if it's greater than or equal to 3 output equals one if that's not the case and then at the end I'm just going to return the output so let's see let's test this out I'm going to say uh this response is equal to Fibonacci and let's say for the first number and that's pretty simple that should hopefully this uh respond with the number one and I'm going to print the response so if I run this you see we do get one pretty simple even if we do two we should get the same answer one now if I do 3 we should get the number two so let's see if that works I run you see we get the number two if I try the number four we should get three and indeed we do get three and if I try five we should get five as you can see over here let's try one more uh sixth number would be five plus three which is eight so if I do six here we'll get eight so that's how recursion works and uh to be honest this is not a very efficient algorithm because uh we'll have to eventually as the num as the input as the input number increases to maybe 40 or 50 this thing will take a lot of time to process so 45 if I input 45 over here you see It'll take like a few seconds to process we're waiting for the output still waiting for it and uh yeah I'm still waiting for it and this will take a lot of time actually so um let's try out just let's let's just try 40. 45 seems to be taking a lot of time so let's try 40 over here and even this 2 will take a few seconds waiting for the output still and yeah there we go we get it after a long period of time I think that was like seven or eight seconds so yeah so you'll clearly see that this is not very efficient uh a more efficient way of solving this problem would be to save um the Fibonacci value at any position that you compute so if you compute the Fibonacci uh value at a certain position you save it in a data structure like a dictionary or something like that so that eventually when you need that same value when you want to refer to that same value you can quickly refer to it instead of computing it again in the Fibonacci function so then that trick is also known as memorization it's part of dynamic programming but I won't go too much into it because it's not very relevant to our course so yeah with that knowledge we've talked about recursion I'm going to go through one more problem and that'll be in the next section our second recursion problem deals with counting to a certain number so given the input 7 I want uh the program to count to seven so it should output one and then two and three and then four and then five all the way up to seven so to create this we have I'm going to use the function count to num and a very simple approach which is the iterative approach and it's pretty simple to understand as well is to run a for Loop now I hope you might be familiar with for Loops so in a for Loop you say for I in range num plus one in fact because the bound is not inclusive it's exclusive so we need to add by one and then I'm just gonna print I so that should work and if I run this let's count let's call this function as well I'm going to say count num count to let's say 10 and let's run this and you see we get one two three four five in fact I don't want it to be from zero so I'm going to say one to num plus one and let's run it this time you see we get one two three four five six seven eight nine and ten so that's the iterative way of solving this problem iterative way I can say that before it's the iterative way of solving this problem now let's come to the more complicated and to understand recursive way but hopefully it makes sense to you after this section so over here I'm gonna create the same function count to num this will take an input parameter now and we want to use a recursive way to solve this problem now bear with me while I'm quote this up I'll explain how what it all means so first I'm going to check if the number is greater than zero that's the first thing I'm going to do and if it is greater than 0 then I'm going to count to num calling the function again with the num minus 1 and then I'm going to print the number and finally I'm going to count to num let's say 10 let's run this and you see we get the same output 1 2 3 4 5 6 7 8 9 and 10. so okay what what does all of this mean now in fact to make it more simple I'm going to use a number two first if you understand this you'll understand it for any number so let's run this again and the output should be 1 and 2. 1 and 2 as you can see over here so we start off with count to number two we give that as an input the number is equal to 2 and in this case the number is greater than 0 2 is greater than zero so then we count it up again so we say count to num num minus one at this stage within this Loop now what is num equal to num is equal to 2 but we're counting to num count underscore 2 underscore num 2 minus 1 which is one so now recursive function we again count num we go back here is 1 greater than zero yes one is greater than zero and in this situation num is equal to one and now we count to num to zero okay bear with me for a second so num equals one and then we count to num we count to zero because one minus one is zero okay now we count them to zero we enter this function again is 0 greater than zero no it's not greater than zero then we're gonna exit now over here we come back to this original situation where we had num equal to one and count from zero well count to num zero just return you just exited the function because number is not greater than zero so now we have processed line three we move on to line four what is num equal to num is equal to one at this point so it prints one okay we can now num is one now in the previous situation remember numbers two and count numbers one so after the after the after we process this num and after we exit this function we go back to the original position when count the numbers two num was equal to two and count number is one this line was processed just like before and num is two so we print two so print one and then print two it's it's difficult to understand initially but essentially what it's doing is it's counting uh it decrements so it goes from count to one so in the scenario but the count column is 10 we go from 10 to 9 to 8 to 7 to 6 to 5 to 4 to 3 to 1 to 0 when we hit zero num is not greater than zero and then we go back to the position in counter num is one now uh let me go back to the position where we print RAM and then count alarm is one and we go all the way up so while counting up decreases from 10 to 0 the uh printed output goes from one to ten so that's how recursion works it's definitely a much more difficult way of counting to a certain number but hopefully it makes sense to you now um after these two requesting problems I encourage you to revisit the preorder and post order uh functions that I talked about in the binary tree and after we've understood all of that it's time to move on to the next section of the course so I'll see you there so in this section of the course we'll start by building our Alexa which as I've talked about in the previous few sections uh decodes the input string so let's say we give the input expression 5 plus 3 our Pro this is a valid expression a valid input expression because our programming language should be able to do basic arithmetic so given this input the lexor or the tokenizer should be able to do lexical analysis and convert this into a list of tokens um five plus and three it should ignore any spaces like that and yeah that's the basic functionality of our lecture when we are making up making our programming language more extensive we are trying to include more functionality like strings or assignments variables if statements while loops and all of that kind of interesting stuff when we're doing that are we'll have to update our Alexa constantly but for now I'm going to create Alexa that will be able to process these numbers and these operations plus minus multiplication or division so for that I'm going to create a class called Alexa and this class will have the init method it will take itself which is the instance and it will take a second parameter which is the input text now over here I'm going to set text equal self.text equal to text essentially when I create the Alexa so if I do lecture equals Alexa and I give an input expression 5 plus 3. I'm assigning a property called text to self self being the instance itself and the value of that property will be equal to the input given over here which is 5 plus 3 so that's what I'm doing with this line self.txt equals text now the next thing I'm going to do is I'm going to create a variable called idx and set it to 0. idx is the index of um of because when we're creating the rexer we'll have to iterate through each item of this um so this there's an input string over here we'll have to go through each character and to keep track of which character we're currently on I'm going to use this idx it's initially going to be 0 because indexing starts from 0 so if I uh the zeroth index of the string is equal to 5 the first index is equal to the space bar second index is this plus symbol and so on now I'm going to create a variable called tokens and that will be just an empty array where we will store all of our tokens now after that I'm going to set the current character Char and that will be equal to the tokens uh that'll be equal to the text idx self.idx so initially the current Char will be the number five the current character will be the number five then uh we'll have to create a function called move which will which will move to the next uh idx it will increment the index and once the index is increment incremented it will update the character the character will be this so the character keeps track of self.char keeps track of the current character and after that I'm going to create one more property and I'm going to say self dot token is equal to null and this will be the value of the current token and you'll see what this means in just a few minutes so after we've created the init method I'm going to create a method called tokenize which will convert this input text into the output tokens and this will take in self as usual now to iterate through each character of the string I am going to use a while loop and I'm going to say while the index is less than the length of the text um let's just do print self.index for now and if I run this and if I do Alexa Dot tokenize and if I run this you see okay so I I forgot to uh increment it so let's just increment over here and if I run this you see we get 0 1 2 3 4 0 1 2 3 fold so we are going through each index of um of this input expression so let's remove all of that for now and now the first check I'm going to do so there are two data types as of now there's the number and there's the operator now a number Can it can be composed of multiple digits it can be this as well even this is a valid expression so a number can compose of a string of digits a combination of digits so one or more digits that's what defines a number so if we encounter a digit so if the current character is a digit now how do we check if it's a digit I'm gonna have to store all of the digits that exist let's say self dot digits equals zero one two three four five six seven eight nine so these are all the digits and then I can check if the current character is in self dot digits that means if it's if it's 0 that's in self dot digits if it's 7 it's in self dot digits if it's eight it's in self dot digits now a better thing to do is since self dot digits the digits that exist is universal it doesn't change for each lecture that we create so a better thing to do is make this a class variable instead of an instance variable so over here I'm going to create digits and I'll just copy this string over here let's paste that let's remove that line and I'm going to do instead of doing self dot you just I'm going to do Alexa dot digits so if the current character is in Lexington digits for instance the first character is 5 it is in like certain digits then I need to extract the entire number the token is not just the number five the token is the entire number 5885 so we need to create another method that upon uh enter upon facing a number upon facing a digit this method will extract the entire integer the entire number so to do that I'm going to say uh the current token selfdraw token which is set to none I'm going to make it equal to self dot extract number so let's create this method over here extract number so this extract number is if the current character is in digits like over here it's the number five extract number will extract the entire number 5885 so to do that we're gonna uh first of all store the number as a string and then while the current character is in a self dot digits lecture or digits my bad because this is a class variable and that's it for now and also I want to ensure that we are still in the within the text so we're not the index is not greater than the length of the text and self dot index is less than the length of self dot text if this is the case then I'm gonna add the number add the current character to the number now how do I increment the index so okay so when we hit the digit we call Self DOT number as self x dot extract number and then 5 the current uh character is 5 so that will be added to the string over here and the string will be 5. now how do I increment the index I can't just do self dot index plus equals 1 because I then also have to update the current character so I can do self Dot character equals self dot text self dot idx so updating it but we'll this is a common functionality we'll have to do this a lot of times we'll have to move a lot of times we'll have to move to the next character a lot of times so to move to the next character I'm going to create a method itself let's call it move and I'm going to say self dot idx plus equals one and if the self.idx is less than the length of the text then I'm gonna increment then I'm gonna update the value of the character set that to self.txt uh at the index position of the updated index which is plus equals one so whatever the index was before now it's incremented by one and the character is the next position so instead of doing this I'm just going to call Self dot move so that's our while loop essentially we still have to detect um floating Point numbers which have decimal points in them but we'll talk about that in just a few minutes so as of now I've set the number and then I can't just return the number over here because remember we want to store tokens tokens have two aspects to them they have the value and the type so now the type over here is an integer and the value is a number wouldn't it be better if we had a different class itself for the token where uh instead of returning number I can just return the token itself and given the number and the type let's say integer and that's it that's all we return and the token class handles the rest so for that I'm going to create another class let's call it token and I'll remove this over here let's create class token and over here we're gonna have an init method this token pass will have a value and a type let's let's do type first that makes more sense and over here I'm going to say self DOT type equals type self dot value equals value and I'm gonna do one more thing instead of returning a token I'll I'll just return um another class which is the class of an integer so I'm going to create a class called integer and this class will inherit from the token class so and I'll pass over here so instead of returning the token all I'm going to do is I'm going to return the integer itself the integer class itself now why am I doing this because the first of all integer floating points strings and all of these numbers inherit from The Base Class token because all of them have a type and a value so that's why I'm doing the inheritance and why I'm creating all of these subclasses the integer float strings is because these subclasses may have their own methods like for instance the integer class may have methods like converting an integer to a float the float class may have a method to convert a floating Point number to an integer so these classes will have their own custom methods if we have a class of a string which we will create later on this class string will also again inherit from the token and this class string may have its own additional functionality like for instance you have to concatenate two strings so this will we can write the method for concatenating two strings inside this class itself so that's why it's better to create these classes and have them inherit from the main token class now um if if I use the integer class over here and I have to pass the type and the value so the value will be number and type will be integer um like that now my problem with this is that even though I have defined the integer class I still have to pass in and that will always be the case so this is a form of code repetition how about I just passed the number and the integer class manages to do the rest so for that I'm going to use the super function so I'm going to call the init method again and this will take in just one parameter of the value and in the integer path itself I'm going to hard code the value int as the type so I'm gonna you do super which is the token class now in the token class I'm going to call the init method and the type will just be integer and the value will be whatever is passed over here so what am I doing with this I'm saying okay extract number and uh I'm gonna return a type integer the value of that integer is number over here which was which we extracted that is the value of this integer now over here when the init method is called when we create this class when we create this object the init method is called and in this init method the super classes init method is called which is the token class and here we assign type as int and value as value which is whatever is given over here instead of passing in hint every single time we create an integer which is a form of code repetition and is not varying it is not very efficient now let's try and handle floating Point numbers as well floating now let's try and handle floating Point numbers as well so a floating Point number will have a dot in them a decimal point in them and so I'm gonna first create a check is float as false because whether it's floating or not will depend on our output if it's a floating Point number we'll return a class of a float we'll return the float object and if it's not a floating Point number we'll return the integer object so over here is float is false and if the current character is in digits or self.char is equal to a decimal point so this is possible as well and if this is the case I'm gonna say um if self.r is equal to a decimal point that I'm just going to do is float equals true and I'm gonna add the current character as usual and now over here I'm gonna return the integer class if is float is false that means if not is float this is a way of checking if is float is false if not is float I'm gonna return an integer else if its float is true that means the number is a floating Point number then I am going to return a class of float and given number and now let's create the same class again I'm going to create a Class A float and the data type over here let's do FLT standing for float so that's integer that's float what next now in the next part we have to also talk about operations so the in car as of now arithmetic Expressions we can input numbers we can input operations so we need to deal with operations as well over here so I'm going to do L if um the current character in Alexa dot operations and let's store operations over here operations is equal to plus minus divide multiply so over here let's say self.token since these operations don't span for multiple characters like the digits they spanned for multiple characters you had five six seven or six seven eight three the span for multiple characters six seven and eight three but the operation is just one character so we don't need to call an external method over here all we can do is say search token is equal to first of all we need to create the operation class but the value will just be equal to the current character so now let's create the operation class this will inherit from the token class as usual self and value now let's call Super and in the init method I'm gonna pass operation up and the value will be whatever is passed so now I think this is pretty much it let's try and run it and see how it works actually one more thing I forgot to do is I forgot to return the token from the tokenized class from the tokenized method so let's go ahead and return self.token and now let's see if this works so I'm gonna run this and I'll create a shell in fact a shell.py and the shell.py will be used to interact with our programming language using the terminal over here so first I'm going to import from the lexap class I'm going to from Lexa import Lexa then I'm going to say tokenizer is equal to Lexa and over here I'm gonna run a while loop essentially taking input and input expression uh indefinitely until the user quits the program so while true tokenizer equals Elixir and we need to take an input expression so let's say text equals input Shadow script that's the name of our programming language if you remember so this is the input we're taking we will pass that input as a parameter to the lexer mac object to the Alexa class and over here I'm gonna do tokens equals tokenizer Dot tokenize and let's print the tokens so if I run this and let's do one plus one okay so it's still indefinitely uh present over here I think I made a mistake I did not move uh after the operation so over here in the extract number method I move to the next character and uh that we don't need to add another Movement we don't need to call move over here again after line 15 but in Lexington operations I did not do that so I'll have to do search the move again and now let's run this see if it works I have to quit the program first and let's run let's do one plus one and okay another problem here we don't have to return self token with returns after tokens and over here in the while loop after we've um uh received the next token I'm gonna append to its F1 to the tokens list so append self dot token so hopefully now it makes more sense let me just recap we run a while loop we extract the token uh the token can either be a digit or an operation and once we find that token we append it to the SAS dot tokens list and then we return self dot tokens so now let's run it hopefully it works this time if I run and the one plus one okay we get a list and these are the classes over here integer operation and integer again now this is a way an ugly way of looking at uh the classes so I'm gonna use another special method called the representation method and I actually forgot to talk about this in the uh in the object oriented implementation objectoriented programming implementation but essentially what this does is if I print the class itself the representation will be printed so now when I print the class I get this ugly representation but I can customize that representation using the repr method and the representation will just return the current value in the self.token pass and since all of these subclasses inherit from that these two will have the same representation so let's run it again if I run it now and do one plus one you see we get the tokens one comma plus comma 1. now a problem we'll hit is if we use spacebars so if I do one space one we haven't dealt with spacebars we haven't told the program how to process face bars so if I run this we'll see that we don't get any output so to handle this issue I'm gonna create a list of stop words and stop words are just chunks that you ignore because they're irrelevant to your program so over here I'm going to create stock quotes and for now stop for the only stop code Will Be A spacebar so over here I'm gonna say l if self dot character is in lexa.stop words in this case I'm going to move to the next character and I don't want to append anything so I'm just gonna break out of this iteration and move to the next iteration so I'm gonna hit continue so now if I run this again and now I do one plus one you see it still handles if I have multiple space bars it doesn't matter we still get the same output so that's basically it and apart from that yeah okay so that's basically it for the Alexa as of now we've handled floating Point operations as well and even I can do I can even do one prime two plus seven point eight and that two will work I can do 7.5 multiplied by 3 and that 2 will work and you see we are lecture is working perfectly fine and this is a good base template to work from now whenever we have to add additional functionality like variables if statements and while Loops all we have to do is modify these classes modify the um while loop over here the contents inside the while loop and will be done so that's about it for this section hopefully you understood all of the uh code related to Lexa and now we'll move on to the parser how we can create a pass tree okay how we can create a tree to represent these arithmetic operations and then finally in The Interpreter we'll Traverse through the tree and compute the operations so for all of that and more I'll see you in the next section so in this section of the course I'll be working on the parser which will create a list representation of the binary tree so you remember how we talked about list representations and binary trees in the theoretical aspects of how the passer worked so it's good to just review that section but as just as a quick reminder let's say we have the expression 1 plus 2 multiplied by three the parser will create a binary tree using just lists one plus and then it will have a nested list inside of it 2 multiplied by 3 and this is effectively the list representation of the binary tree where the following highlighted bit is the right sub tree and this is the left node and plus is the root node so now let's create the class I'm going to say class passive and over here I'm going to define the init method which will take in self and the tokens and over here I'm going to say self dot tokens equals tokens now one more thing I'm going to do just like how we did it in the Alexa I'm Gonna Keep An idx and I'm also going to create a move method to keep track of our tokens previously in the lecture we did it to track the current character now we're going to do it to track the current tokens I'm going to say self.idx equals 0 and then self.tok token equals self dot tokens on the current idx now let's define the move method as well this will increment the idx and it's going to do if D self dot idx ft index is less than the length of the tokens only then is it going to update the token value so now let's go ahead and create the method for passing our tokens so this will be the method pass and this method will compute an expression now remember how we talked about nonterminals and the different types of nonterminals that we have we have the expression we have the term we have the factor so these are three nonterminals and we're going to create three different methods to define the grammar rules for each of these nonterminals so we're going to first of all return self dot expression this is like the highest nonterminal we want to compute the expression and over here I'm going to Define first of all let's define the factor nonterminal the factor nonterminal is pretty simple we're gonna check if the token type is of integer or float so I'm going to say if self dot token DOT type is integer or if it's float in that case I'm just going to return the current token so let's say the current token is the number five the factor will check if the number 5 is an integer which it is so then it's going to just return the current token and that is the factor now the term is slightly complicated remember how we defined a term to be a factor multiplied or divided by another Factor zero or more times so I'm gonna first say the left node of this term because right now let's say the term is okay let's just take an example 1 multiplied by two over here we'll have 1 as the left node multiplication is 0 node and two so this is our list so the last representation of this will be one comma multiplication comma 2 and this is the term that we're talking about now how do we construct this term first of all we need to extract the left factors I'm going to say left underscore node is equal to self dot Factor then we're gonna move and then we're gonna say as of now I'm going to assume that there's only one multiplication there's only one operator but as you know the factors can be multiplied or divided by each other zero or more times so it doesn't necessarily have to be one so I'm gonna say selftop move so zero more times so the term could just as well be a factor itself so I'm gonna first of all say output equals left underscore node in the case where there is only the out there is only one node and they are not multiplied to another Factor zero more times so it's just a factor itself in that case the output will just be the factor but in this situation where the operation value is equal to multiplication or division in this situation where the operation is multiplication or division the output won't just be equal to the factor rather the output will be equal to first of all we need to save the operations I'm going to say operation equals self dot token then I'm gonna move self dot move then I'm going to say right unless control is equal to self dot Factor again and in this case now the output will be equal to this list so how we construct the output it'll be left node operation right node so I'm going to say output equals left node operation right node and now let's return the output so I hope that makes sense in the case where the term is equal to a factor there are no multiplication or divisions in that case we'll just return output as the factor but in this situation where there is multiplication division in between the operands in that case I'm going to make output equal to the left node left node multiplication which is whatever the operation is multiplication or Division and right ornament and then we're going to return the output and I'll remind you we're not talking about multiple operations so this cannot handle stuff like 1 times 2 times 3 it can only handle a simple expression like 1 times 2 where there are two operands and one operator now let's do the same thing for the expression and in fact I'm just going to copy this code because it's pretty simple too it's pretty similar to the same code and in fact one more thing I forgot to do was to move after the right node and why am I doing this so when I call self.t term in line 25 instead of self dot factor in the expression the left node will be self dot term I don't need to move after this so I'm just going to remove that self.move method that I'm going to call over there in fact I can do the same thing over here I'm going to do self dot move or or rather let's just leave it like this so whenever you're calling a factor you have to move after that because all of the factors return the token but whenever you're calling a term you don't need to call self.move because it is all selfdoubt move is already called in line 19 after the right node so we don't need to call search dot move in this situation so that's it that should work now I as I just need to change this to plus or minus and let me save this and I'm gonna do I'm gonna run shell.py so let's run it let's do something like one plus two multiplied by four and okay I have to call the passer first false I'm going to import so there we go let's run it again 1 plus 2 multiplied by 4 and okay we I think I made a small mistake over here I forgot to change this to self dot term so let me save now and run it again hopefully it works this time one plus two multiplied by three less to 3 and in this case you see we do get this list so how does this work let's just go through it left node equals self dot term in this case the term is just equal to a factor because there is no multiplication or division following it so then the term is just equal to the factor one and that's what we store as the left node then we check for additional subtraction which is the case then we move to the operation store the operation and then we saw the right node is self dot term and this time when we compute the term there is multiplicational division and that's why the term returns a nested list so this works perfectly fine this is in fact how our binary tree will look like even if we do one multiply by two plus four the this is the exact this is exactly how the binary tree will look like when we convert the python list to the binary tree but we haven't solved one problem which is multiple operations as of now we're only checking if there's one Opera if there's one operation plus but let's say we do one plus two plus three you see we have a problem it's not giving the appropriate output so how do we solve this I'm going to make two changes first of all I'm gonna run a while loop I'm going to continuously check if there's addition or subtraction and I'm going to continue continuous continuously check if there's multiplication or division so those are the two changes two changes I'm going to make and one final change I'm gonna make and I'll explain what this means in just a second is I'm gonna do left node equals the following list and I'm gonna return let node I'm going to do the same thing over here I'm going to return left node and get rid of this output business and make left not equal to that so let's quit and run again and I'll explain what this means in just a second so 1 plus 2 plus 3 you see we get 1 comma two plus three if I do one plus two plus three plus four we get the following output now how did this work so effectively by iteratively changing the value of left node every single iteration of the while loop we're changing the value of left node and we're assigning it the previous value but by doing that we're effectively pushing down the left node of the tree so let me construct the tree and show you how it looks like so this is how our tree looks like and by continuously updating the left node's value and assigning it what the previous subtree was so by continuously assigning this let's go through this one time so let's try one plus two plus three and in this case we get the left node as self dot term and search for a term over here is just the number one and then we run a while loop to see okay we each time we look for a plus symbol we store the operation we move and then we get the right node as self dot term again so this is one plus two is the um is the list over here left node operation right node but we assign that value to the left node so essentially that list itself becomes the left node and then plus and then the number three and by doing this iteratively for all of and by going down the left node every single time by reassigning the left node we are creating the right tree as you saw over here so that's the basic process we are to summarize again we are on in every iteration we are updating the value of the left node and we are assigning it the previous left node operation and right node so what we previously had like over here what we previously had was one comma plus comma two so whatever we previously had we assigned that to the left node itself followed by plus followed by three so that's the process we used to accept multiple additions so that we can say okay now of an expression is equal to a factor added or subtracted by another Factor zero or more times now we've dealt with that zero more times aspect to it so that's the basic uh summary of passing stage and now let's move on to the next section where once we have created the tree we'll have to Traverse to the through the tree so we'll have to do Post order traversal and follow that and more I'll see you in the next section so before we move on to the interpretation stage I made a few changes to our Alexa code instead of storing the tokens and the token types in the elixir of UI file I thought that would be better to store it as though as its own external file over here and that's the same same code except for the fact that in the representation method we return it as a string because the repr and there's also another method called string def unders underscore string self and they are pretty similar they have a few minute differences which I'm not going to go into but they're pretty similar in nature and so these both of these methods return output as only in string format they don't return integers or floating Point numbers so it's better if we clarify that over here and return it as a string itself although in the lexical analysis stage we did implicitly Define the number as a string and then pass a string over here uh it's just going to explicitly Define the output to be of type string so after that change let's move on to The Interpreter of py file where we will be creating our interpreter so over here I'm going to create The Interpreter the init method and this is going to take the tree as its input just like how the parser took the tokens as its input now The Interpreter will take the tree as its input so after that I'm going to create a method called interpret and the interpret method is responsible for computing our arithmetic expression so as of now I have not talked about brackets how you can compute expressions like OnePlus 2 in Brackets multiply by three now we haven't talked about these we'll talk about that in the next section but as of now we can we should be able to compute expressions like one plus one or 15 minus 6 multiplied by 5 whatever we should be able to compute expressions like this after the interpretation stage so in The Interpreter we'll have to do Post audit reversal now if you remember how the tree representation looked like let's say for an input 1 plus 2 multiplied by 5 the tree representation would look something like this you'll have one over here you'll have plus and then you'll have a nested list to multiply by fine so that's how our uh our nested list how that's how the parser creates the creates a representation of the tree and we have to now interpret this we have to Traverse through this tree and how are we going to Traverse it using the post audit reversal method and if you recall post order traversal refers to the fact that you have to Traverse through the left subtree then the right sub tree and then after that if the Traverse you have to go to the root node now let's for a second assume there are no sub trees and let's just read the binary tree with two levels so there'll be only two levels here there will be a root node let's say a and then there'll be B over here and see over here so let's just treat it it should be here that's better doesn't seem right yeah there we go so that's let's just assume that the tree is pretty simple it has two levels and there are no subtrees in such a situation how will we interpret it so an example of an expression like this would be one plus one or five plus six or some five plus six or something like that so how can we interpret such a simple binary tree so first of all we have to go through the left node then the right node and then the root node so to do that in post order traversal form we'll have to first go through the left node so left node and in our tree let's say we have the expression one plus one the tree would look something like this so the left node will be surf.3 the zeroth index so the first position over here that's the left node the right node is equal to self Dot 3 2 so we are traversing through the left node then the right node and finally we'll go to the root node and we'll compute the root node by adding the left and right nodes so let's say the operator is equal to self dot three one and over here we can return compute binary this will have to create a function for this and self compute binary so given the left node right now and operator we this function will calculate then the output and return it so here we'll give a left node operator right now so this is the left subtree and a sub tree which contains only one node as of now this is the right subtree and this is the root node so that's our post order traversal now let's create the method compute binary so we'll take in the left node so left up and right now remember we can't do the following so if this is how it will typically look like so we'll say if the operation dot value is equal to addition then return left plus right so this is one way of doing it but it will be wrong because right now the left token is a string it's not even if we do left dot value over here and write dot value these token values are stored as strings remember over here we store the number as a string and then we stored the data type which is integer we in that we passed a string number so we can't perform this operation right now in fact we have to convert the left or right values into whatever that data type is like for instance if it's if if the expression is one plus one let's say so when given the expression one plus one the first token will have a value of 1 and a data type of integer so then we have to convert from a string to an integer we need to convert that value from a string to an integer so one way we could do this is we can say okay if left dot value left or type is equal to integer left equals int left L if left to type is equal to float left equals float left and then over here let's do if try to type is equal to end same thing and you you'll see now that this is pretty inefficient and will come up with a better solution but just to illustrate my point that's uh now let's go along with this if you write the type okay so after all of that mess and it's really disturbing to see to the eye but anyway after all of that mess let's do if operation dot value is equal to Plus then I want to return left right and let's just handle this one now so I'm going to save this and let's let's close this over here I'm going to delete this itself now I'm going to call The Interpreter so I'm going to say interpreter is equal to interpreter this will take in the tree and this should be small so interpreter dot interpret so then I'm going to say result is equal to that and let's print this result I'll save I'll click on run and let's do one plus one okay we get an error all right so this should have been left dot value and not left so left up value write dot value I am purposely doing this to show how inefficient this way is no I don't value okay here we go one more time one plus one and that seems to be a problem okay this has to be LF okay my bad let's run this one more time and hopefully it works again one plus one okay we get two perfect let's try five plus three we get eight but again this is a very in very inefficient way of doing this problem so how can we solve this issue where we all our task at hand is to extract the type of the of the of the data of the token and then depending on the type whether it's Intel whether it's float using that type we convert it to its necessary data integer or float so how can we accomplish this task so the first thing we need to do is we need to extract the type so I'm gonna say left underscore type is equal to left DOT type and right underscore type is equal to right DOT type okay so now we've extracted both types what next so there is a function in Python called get attribute and to show you how this works I need to create two methods before and then you'll understand how this works so let's say the first method is read underscore int and just bear with me for a second when I do this and it will take in a value and this will return the integer of that value and they'll be refine read underscore float and it will return floating point value so there is a method there's a function in Python known as get attribute and we are essentially trying to find a method within the self instance the name of the method is the second parameter what's the name of the method it's equal to read it starts off with read then there's an underscore but now we don't know what the latter part of it is I'm gonna say the latter part of it is equal to left underscore type and I'm going to call it and it seems like a lot but it's actually not not that much okay so what does this mean so over here I'm saying okay now left is equal to read underscore left underscore type so if left DOT type is let's say integer it will find the method read underscore int and it will call that method by giving the value of the token as a parameter over here so okay let's let's not complicated first over here so now I'm gonna say get attribute within this instance find the method read underscore left underscore type so left under Skype underscore type is equal to integer so find a method called read int within self and once you've found that method call that method and the parameter which is value with as passing the value left dot value so pass the value of let left as a parameter to the read underscore int method of the read underscore float method depending on what the data type of left is and I'm going to do the same thing for the right as well so get attribute self read underscore and over here we're going to do right type and the parameter I'm going to pass is the value of write so write dot value so there we go let's save this and I'm going to try and run to see if it works one plus one we get to same output but it's much more easier to look at and much efficient much more efficient code so now with that sorted out we have to again look at the interpret method because we have still have to figure out sub trees now if I do something like 1 plus 2 plus 3 you see this will start giving errors because we haven't found a way to deal with subtrees so let's remember now let's consider a sub tree over here an expression which has a sub tree so 1 plus 2 plus 3 what is the list how will that list look like so let's create it so there will be one plus two and then after that plus three so that's how the list step presentation of this of the binary tree will look like one plus two plus three so that's the representation so until now we were thinking we were assuming that every single node will be just that will be a node there won't be any subtree but now a node can be the value the node can be a sub tree as well so how do we deal with such situations the first thing we need to know is that if it is a sub tree it will be it'll have a type of list notice that this is not a subtree this node is not a sub tree and that's why it has a type of integer but this node over here is a sub tree and that's why it has a type of list so we need to First detect whether a tree whether a node is a subtree or not so to do that let's first do it for the left node and I'm going to say if is instance I'm checking if the left node is an instance of the inbuilt class in Python the instance of the class list so if it is an instance of the class list then we know that we need to compute this nested list as well and to do that I'm going to use recursion so how are you how are you going to do it I'm going to say left underscore node is equal to self dot interpret calling this method itself and the parameter I'm going to pass is this nested list so I'm going to pass this nested list to the interpret method and it will treat this as its own separate tree it's going to compute it and that value will be stored in left node and if there is multiple subtrees it will go recursively down this process is known as recursive descent parsing by the way and it's gonna for every single time we have a new sub tree within a sub tree it's gonna go to each subtree compute it and eventually it's gonna come to this higher level this topmost node which with an interpreted value so once we interpret left node we need to do the same thing with the right node so I'm gonna say if is instance right node of a list if it is a list then I'm going to say write node is equal to self dot interpret right so there we go those are our two evaluations and now we can deal with subtree so I'm going to say evaluating less sub tree and this is evaluating write subtree so we're done with both instances over here and this is finally the root node operation so with that done it's time to run our code let's see if we run our code what output we will get but actually before that we need to also modify our compute bin method because as of now it's only having handling addition so we need to manipulate that as well so I'm gonna do L if op dot value equals minus return left minus right and if and in fact are not going to do return I'm going to store this is an output because this is an intermediate representation we still have one more uh one one more piece remaining so instead in fact I'm just going to store this as the variable output so I'm going to say output equals this left plus right output equals left minus right LF op.value is multiplication I'm going to say output equals left multiplied by right and finally LF op.value is division I'm going to say output equals left divided by right so and we're going to return output over here not not just yet let's let's keep this for now so I actually figured that'd be one problem over here notice that the interpret method is not accepting a parameter it's using the original self.tree as a default tree to work with but we don't want to do that in cases when there is recursion I want to pass in my own custom treat which is the subtree and I want the interpret method to process that subtree to process that nested list so how can we do that so I'm gonna come up with a efficient way to do this so instead of passing in the tree in the interpret method which is one way you could solve this problem rather I'm going to create a variable called 3 equals none and what this means is to say that if and if The Interpreter method does not get a parameter it's okay it's not going to throw an error it's just going to set the tree parameter to none and that's the first case over here when we don't provide a parameter so in the case where it is none if tree is equal to none 3 is none in this case I want to make self.tree tree equals self.3 so if it is none we're going to make 3 equals self.3 and we'll be working with only the tree we won't be working directly with self.tree let's remove that as well but in the case when it's not none like this situation where we are providing our own custom uh tree over here in the but in this situation when we are providing our own custom tree over here like left node and right node in these two situations it will be using the tree parameter that will be passed in line 36 and line 41. so I'm going to save this and now let's go back to the compute bin method so in this scenario I don't want to return the output as a default python integer or a floating Point number instead I want to return it as my own class I want to return the integer floater operation because that's the point of having our own data classes so how can we do that now if the output if left or right are both type of integers then the output will definitely be an integer but even if one of them are a floating Point number then the output will be a floating Point number like for instance if left is equal to 2.5 and right is equal to 2 the output will be a float if left is equal to 2 and right is equal to 2 the output will be an integer and let's say if left is equal to 2.5 and right is equal to 2.5 the output will still be a float so if if even if one uh even if one of these numbers is a floating Point number the output will be floating Point else it will be an integer so for this I am going to say return integer and see this is where separating the data as its own custom file makes sense because now I can import from this file itself so I'm going to say from tokens import integer and float so return the integer value of output if left DOT type left underscore type let's deal with those left underscore type and right underscore type um let's say left under the sky is equal to integer and right underscore type is equal to integer if both are integer return the output as in the format of integer else return the output is a float so now hopefully this works we have the compute bin method written up we have the interpret method written up using post order traversal and if I run this entire let's see if it works so if I do let's start off simple let's do one plus one we get two let's try 1 plus 2 we get three one plus two plus three we should get six which we do let's try one plus three times two and over here it'll be 1 plus 6 rather than 4 times 2 it'll be one plus six so that should be 7 which we do get and I'm gonna try floating Point numbers 2.5 into 2 we get 5.0 notice that even if one of the numbers is floating point the output is printed as a floating Point number so there we go our entire function is working I'll do one more test to see if it's working and again the output is floating point so our interpreters working and for the first time we have a running program that can compute arithmetic or uh Expressions as an input so this is a huge step now because we have our basic Foundation laid out and after this things get very easy all we have to do is write down our grammar rules compute make modifications to the Alexa the parser and The Interpreter I removed the password yeah so all we have to do is make changes to the Alexa interpret return passer and we should be able to work with variables if statements and all of that so in the next section we're going to compute variables so of all of that interesting stuff I'll see you in the next section so click quickly before we move on to variables I also need to talk about left brackings and writing brackets and how we can use them to change our order of operations so over here in the operations I'm gonna also add in the pair of parentheses which are valid Expressions which are valid tokens as well oops all right there we go so which have added tokens as well so now let's go to the parser and over here how will the camera look like the grammar rule will be changed just a bit remember when we said that the factor is um we set up was just an integer zero one or two whatever it's just an integer well now it can also be a left bracket and a right bracket followed by an expression inside so uh and then these brackets you know can contain expression so to extract the expression we can use the Expression method now so over here I'm going to say l if self dot token that value is equal to the Open Bracket Open Bracket and in this case I am going to say surf dot move to move to the next token because the open record is not very useful we move to the next token which is the start of the expression then I'm going to say expression equals self dot expression now we have extracted the expression and with that with that extraction now we can return the expression so if I save and now let's go to the Shell and I'm going to run this file 1 plus 2 multiplied by 3 gives you 7 but if I now enclose this with a pair of parentheses you see we get one plus two plus three one plus two times three equals nine and we can even deal with uh multiple parentheses over here so if I have let's say 1 plus 2 multiply by 4 divided by 6 we get 2.0 so now finally we are going to be able to work with variables assigning variables and again as usual now we're going to use the same pattern we're going to start off with Alexa update the Alexa update the password and then finally update The Interpreter so to do this I'm gonna first talk about the grammar rules that that are involved the first grammar rule involved is in in terms of the variable is the fact that the Declaration is going to be made by the keyword make so like in stuff like JavaScript you have let you have VAR in Python you don't have a declaration as such but in our programming language Shadow script the Declaration will be make so it's going to be make and then the variable name and then that's gonna equal something let's say 50. so that's going to be our grammar rule for creating a variable so we're going to start off with make so for that we need to to accept these uh text based inputs we need to accept letters so for that we need to First create a constant over here to check if there is a letter or not letter so so with that we have defined the letters now let's go ahead and uh in the tokenize method I'm going to say l if the current character is in Lexa dot letters so in this case that there are two possibilities the first possibility is that the letter makes up the Declaration the second possibility is that the letter makes up the variable name so over here we need to ensure that we take care of both situations so I'm gonna say first of all we need to extract the entire board be it be the Declaration be the variable name so just like how we had to extract number method I'm gonna run an extract word from uh method over here so I'm going to say word is equal to self dot extract underscore word and let's create that method just below the extract number method so over here I'm going to say extract underscore method extract unscope word and over here I'm gonna say the word is equal to an empty string for now while the current character is in lexa.letters same thing as before and the current index is less than the length of the text in in these two situations if both are true then I'm going to say word plus equals the current character and then we're going to move to the next character and at the end I'm going to return the word itself so over here we have extracted the word and after that we have to check if it is part of the Declaration so let's create a list for declarations I'm going to say declarations as of now it's just going to be one item the make declaration but if we intend to have multiple declarations like in JavaScript you have let you have var2 declarations so if you have multiple of these uh maybe when then we have to update this list so for now let's keep it as a list and then I'm gonna say if word in declarations or Alexa dot declarations in this case I'm gonna set the token type to a declaration so I'm going to create that data type over here in the tokens.py file I'm going to copy this init method and the the name of the type will be decl standing for declaration so now I'm gonna say self dot token is equal to declaration and we'll pass the word as the Declaration and that's import this in our extra PMI file one more thing we need to import is the variable class and let's create that as well be the same as our previous classes and over here I'm gonna create variable and the name of this data type will be VAR standing for variable so now that we've imported the variable and we can move on to the next uh situation in the case when it's not in the Declaration so else I'm gonna say self dot token is equal to variable and now we have the token stored so I'm not going to run the rest of the stuff let's just print the tokens to see what we get so if I print tokens and one more thing minitro is is we need to handle equal signs so over here we have the equal symbol so that is another operation that I have added over here so now let's run the file let's run shell.py and I'm gonna write make a equals 50. and you see we get the Declaration make a equals 50 the tokenization process works just fine so now I'm gonna go back to the Alexa I think we're pretty much done with the tokenization process now let's go ahead to the passer where things get a little bit complicated now we need to um okay let's go to the passer now so to handle the uh to handle the variable assignment part how can we handle this so we need to create a new method I told you for every grammar rule we'll be creating a new method and now I'll be creating the grammar rule for a statement now variable assignment is a statement it's a type of statement there will be other types of statements like if statements while Loops there are different types of statements but one type of statement is the variable assignment so how can you handle these variable assignments so for that I'm going to create a method called statement if the first token so if self dot token DOT type is equal to declaration then this will be a variable assignment statement but if the self.tok token DOT type is equal to integer or if it's equal to float or if is equal to operation like for instance we can have the left brackets so if it's equal to operation in these situations in these three situations I'm gonna set the statement type to be equal to arithmetic expression so now in this situation you have a arithmetic expression in this situation you have variable assignment so the first thing I'm going to do is I'm going to call statement like so now over here in the Declaration I'm gonna one once we know that it is a declaration I'm going to move to the next token next token will be the variable name and to extract the variable name I'm just gonna create a new method called variable so I'm going to say left underscore node is equal to self dot variable and in fact we can create a binary tree of this as well so how will the binary tree of make a equals 50 look like it looks something like this so we have the equals operator and then we have uh we have that connection and then a and let's do 50 over here so that's the binary tree of a make a equal 50. so now left node is equal to variable name so self dot variable will extract the variable name then we have to move after that and then the operation we have to check if self dot token DOT type is equal to operation or let's just say if the value is equal to equals in this case I'm going to save the token so I'm going to say operation equals self dot token and over here finally I'm going to after we save the operation I'm going to say self. move move to the next token and then the next token can be any expression it can be an arithmetic expression it can be just 50 or it can be 5 plus 7 minus 3 multiply by 4 so we need to extract that expression so I'm gonna say right underscore node is equal to self dot expression so finally I'm just going to return the list left underscore node operation so now we've extracted the statement and if it's not an assignment statement and this is going to do self return self dot expression so let's save and I'm going to delete and I'm gonna run the parser now just see how the passer looks looks like so if I save this and let's just run it to see if we get any errors first of all make a equals 12. and we don't get narrow okay we haven't defined the variable let's just Define that really quick so here the variable method all it will do is it will first move because right now um over here declaration okay so we have already moved from the Declaration and now the variable method will check for the it will extract the token so it's going to say if the self.token DOT type is equal to VAR that means if it's a type of variable in that case we're just gonna return the self dot token so now let's check this if I clear and run again make a equals 12 you don't get any error you know the tokenization has worked perfectly now if I print the tree you'll see what I meant by when I said order of Precedence the um how we computed and all about the trees and when I talked about putting the expression it's been in a nested list in uh and the Declaration in an outer list so that's how it looked like so if I run this now and I say make a equals 50. and I run it you see we get a equals 50 over here and for now you can't see it but let's do make a equals 1 plus 2 multiplied by 5 you see now this expression is in a nested list it has higher precedence it's computed first and then after that the assignment works because we don't want to make a equal one and then compute we don't want to make a equal one and then compute the rest of that expression that makes no sense we want to compute the entire expression and then whatever the answer of that is we want to assign that value to the variable a so now we've modified the passer we have modified the Alexa and I hope that makes sense now let's go on to The Interpreter where we will be storing the variables in a dictionary so as of now we can compute basic arithmetic expressions and we have also deal with the code delt we've also dealt with the code regarding the tokenization and the parsing so let's say I create a variable and I will make a equals 5 so as you can see the parser and the tokenizer are working fine if I do make a equals something like 7 minus 2 then it knows that it has to encapsulate seven and two into its own nested list so we've dealt with the parser and the tokenizer now it's time to move to the interpreter but I realized just a few problems with our current code and I'm gonna fix them right now the first problem I noticed is that in the Alexa we are storing the variable and we're giving it only one value but in the tokens the type of the variable is just bar so effectively we're not specifying the data type so say for instance it's a variable with data type of integer so it's let's say we make the statement make a equals five so then the data type is integer and the value is 5 but in this case the data type we've kept it as VAR which is stands for variable and the valuable started as the variable's name so that's problematic we need to store three things over here we need to store first of all the variable name second of all the fact that it is a variable so R and third of all we need to store its data type now as of now like for instance let's take the example make a equals five we have not uh computed the expression over here so we don't know what the data type is it could be a float it could be a integer so we don't know what the data type is so initially what we have to do is set it as an empty data type and I'm going to do that using a question mark so how am I going to represent data type and variable well I'm going to say VAR and then I'm going to give a pair of parentheses and I'm going to give a question mark because we don't know the date of my data type as of now so this is what we're going to set the data type to as of now but later on in the interpretation stage when we have computed the value when we've computed this expression we're going to replace that question mark with the actual data type so that's the first change I want to make and over here let's go to the Alexa and yeah so so that was the only change I had to make so now the Alexa over here it will create variable from the word and in the tokens dot py file it'll it'll give the date time with VAR followed by a question mark over here now with that done let's move on to the next step now since we have changed our variable over here in the tokens we've created the type in such a manner we've changed it we cannot be checking for self.token.type to be equal to variables instead what we can check for is if it starts with the three letters VAR so we can use the starts with method which is an inbuilt method for strings in Python and this will check if the string starts with the three characters V A and R so similarly I just find the other instances where we have created VR and as you can see over here another instance so I'm gonna instead of making it equal I'm going to check if it starts with the variable and that's it so now that we've done this and now that we've changed the tokens.py file and updated the interdependencies it's time to move on to another file which is called the data.py file now the data.py file will be storing all of the variables in a class so this class will contain a dictionary and this dictionary will be keeping track of all the variables and their corresponding values so for that we need to go to the shell.pify file and we need to create or we need to create an instance of the data.priva file before the while loop we can't keep it in the while loop because if we keep the instance in the while loop the data would refresh every single time we get a new input but rather than doing that we want to keep track of the previous inputs as well so here I'm gonna say from data import the class data and I'll create it in just a second and over here I'm going to say base equals data so we're creating an instance of that data so I'm going to create class data and set the init method like so itself and we won't be taking any properties the only thing I want to run the first time the instance is created is I want to create the variables dictionary and set it to an empty dictionary so let's save that and the base is also set now I'm going to uncomment The Interpreter and pass the base as an input to The Interpreter so now The Interpreter can deal with all of the data so it can write to the dictionary when when like the action over here initially was with addition and subtraction the action was to add two numbers but in this time we have to deal with memory we'll have to add to the dictionary we have to interact with the dictionary and for that we need access to the base variable and that's why we're going to accept that base variable over here and we're going to interact with the base variable we're going to interact with the dictionary add variables to the dictionary change the values of variables to the dictionary and read from the dictionary so I'm going to say self.data is equal to base so that's it in terms of The Interpreter now let's go ahead and write the code for the data.py file so variable dot value refers to the variable name and now let's go ahead and refer now let's go ahead and save the data to the server.variables dictionary so I'm going to say surf top variables and in this the variable name is going to be the key and the value is just going to be the expression so that's what we've done we're done with the right method and now we're done with the data class itself it's time to move to The Interpreter where we have to save our data and sometimes you want to retrieve the data like for instance so we have two tasks now the first task is to save data like for instance if we have an expression make a equals 5 we need to save the value of a into this data dictionary and the second task is if we have it say another expression make D equal a plus one in an expression we need to be able to parse we need to be able to understand the value of a variable so in the past of py file we have to update our grammar to say that even if the even if the the gram we have to update the grammar in such a way that thing that a factor can be an integer it can be a float it can be an expression within a pair of parentheses also it can be a variable itself so it can start with the variable itself so that's the only chain I've changed I've made to the past of py file and I've written self dot token if it is a variable so this will just return the current token corresponding to the variable so that's it in the pastor py file and now we need to work with the interpreter.py file modify it so that we can be able to create new variables and read from the data py file when necessary uh during this expression during Computing during the compilation of such expressions so for all of that and more I'll see you in the next section so now in The Interpreter of py file I'm gonna treat the equal symbol similar to a binary operation there's a left part and the right part and we have to do some action with the operation the action being we have to set the left hand side equal to the right hand side and we have to save the data in the data.py file so how are we going to do this we can't make an alif and put it over here because we'll have we'll face problems in line 22 and 23 because they are reading the data as Floats or integers but now these are variables so before we hit line 22 and 23 we have to compute the variable assignment so over here I'm going to say if the operation of value is equal to an equal symbol now in this case what I'm going to do is I'm finally going to update the in in over here I'm going to replace the question mark with the actual data type notice that the right type is already computed we've already computed the type of the right hand side which is the expression so once you've computed the expression like for instance let's see the expression is make a equals 5 the right hand side is the expression the type of that is already computed in right DOT type and in right underscore type stores that in a string format so over here instead of the first thing I'm going to do is I'm going to update the variables type so how am I going to do this I'm going to say left DOT type remember left refers to the variable itself the token for the variable so I'm going to say left DOT type referring to here so left DOT type I'm going to update that left or type and I'm going to update that to equal VAR and then within the pair of parentheses I'm going to put in the the type of the right hand side which is the expression so if the expression is an integer is a type of an integer the type of the variable will also be integer so over here I'm going to set it to right underscore type so there we go that's the first thing I'm going to do I'm going to update the left DOT type and the next thing I'm going to do is I'm going to write to the data.py file so how I'm going to write it I'm going to say self dot data dot right and remember we had two parameters the variable and the expression so the variable will just have to pass it as is so the variable token and the expression I'm just going to pass that as is as well so the expression will also have a type of a token because remember in Computing a binary we return so because these expressions are sub list so even they have to be computed first and in computation of a binary we return an integer or a float and therefore even the right even the right expression is not just a number it is a type of token either of integer or either a float so that's it we're gonna write the data to served to the dictionary in the data class and once we're done with that I am going to test this so we won't be we haven't completed task 2 yet reading variables but we have we have the ability to write two variables so now let's see and just to see if it works on I'm going to return something so after we write I'm going to return the read all so I'm going to I want to see the updated variables list updated variables dictionary so to do that all I'm going to do is I'm going to return self.data dot read underscore all so let's save it and I'm gonna go to shell.py now and I'm going to run this so if I do make a equals 5 there we go we have a dictionary if I don't make b equals 10 that 2 will work this is the variable name and this is not a number don't be deceived by it that's just because we have set the underscore representation as a string of the value it's not a number instead it is the token class it's the instance of the token class it's the instance of the integer or float class so that's how we can create new variables now let's learn how we can read new variables so that we can even pass expressions like make b equal a plus 1. so to do that I'm going to go back to our interpreter of py file and remember we have made the exception of variables as factors we've coded that part in in the past wi file so now let's go ahead and do SEC part two let's handle challenge two in an expression like a plus one where we have to compute a variable we need to create a new method to read from a variable as of now in lines 27 and 28 we can compute methods we can compute an integer and a floating Point number using these two methods which are highlighted but we need to create a new method for reading a variable so let's read VAR and self and this will take in the ID so when we're calling it left dot value corresponds to the variables name so ID is what I'm referring to as the variable's name now the variable itself is equal to self.data.read using this ID because in this data.py file we assigned the variable the way the variable name is the key and the value we assigned it will be the expression and the expression is an instance of the classes integer or float so right now we have the variable we have the variable instance of integer offload now we need to extract the type so in Integrity type is n turn and floor T type is float so we need to extract that so I'm going to say variable underscore type is equal to variable DOT type so now we'll extract the type from that token remember over here we saved the token and the token could be integer float Now using that value I am extracting the type of the token whether it's integer or whether it's float and now from the read underscore VAR method I'm going to call read underscore in and read underscore float so over here I'm gonna say get attribute from the self itself I'm gonna say read and I'm gonna input variable underscore type as our variable in this string inside of here so we're going to embed variable underscore type in this string over here and so we need now we need to call it and we'll call it using the variables value itself so what is the value of the variable that is equal to variable um it's over here it's not it's equal to variable dot value corresponds to whatever the expression evaluates to type corresponds so value corresponds to whatever the expression evaluates to type corresponds to the type of that expression whether it's integer whether it's float so that's it so now we have the get attribute function we're calling the get attribute function and from the get attribute function we're calling the read underscore in and read underscore float methods now I'm just going to return this and hopefully this should work now so if I save and just one more change I need to do here just one more changes in let's look at 933 and 34 left underscore type in this case let's say it's a variable over here so what will left underscore type B equal to it'll be VAR int it'll be equal to VAR in but the method's name is underscore VAR it's not equal to VAR unders so how do we handle the situation so I'm just gonna say left type we're going to make it equal to variable the type will be equal to variable if the string starts with variable so even if the type is this I'm going to assign the even if type is VAR int I'm going to assign the type to be equal to VAR so that when we reach 934 and 33 and 34 rerunsco bar is called and not read underscore brackets int so this is what I'm going to do I'm going to call I'm gonna make the typewr instead of VAR end of our float whatever if it starts with bar as it's just the normal number and in that case I'm just going to return the type left DOT type and similarly I'm going to copy this paste it over here we have to do right this time and let's save and hopefully it works this time so now I'm going to clear everything Let's test our program out so I'm gonna run it let's make a equal to 5 I'm going to make b equal to 10 and then I'm going to make c equal to a plus b and there we go C is equal to 15 and our program is successfully working so that's all about variables and next up we're going to talk about unary operators I left this thing out during evaluation of arithmetic Expressions but now we're going to talk about unary operators so for all of that and more I'll see you in the next section so unary operators are simply operations that occur on just one operand so an operand is like a number so a binary operation remember was 5 plus 2 that's binary operation the first operand is five second operand is two you have two operands and one operations five plus two is a binary operation a unary operation is something like plus five or it's something like minus five since something like plus five or minus five so to handle such Unity operations to handle such Unity operations I'm gonna change the factor a bit I'm going to modify this Factor method a bit to accept even an operation so a factor can now be equal to an integer it can be equal to an expression inside a pair of parentheses it can be equal to a variable it can also be equal to an operation plus another integer so over here I'm gonna do L if self dot token dot value or let's do type DOT type if it's equal to op if it's an operation uh what do you do in this scenario in fact I'm not just going to do operation I'm gonna um because in the Lexus of py file we defined even the equal the equal sign to be an operation so rather than doing that I'm just gonna use plus and minus because those are the two possible unitary operations you can have so here if it's Plus or if self dot token type is equal to minus in this scenario I'm gonna first store the operation operator equals self.token then I'm gonna self dot move and then I'm gonna do operand is equal to self not Factor again so if it's an integer it will just return self.token and we get the operand as let's say plus 5 plus will be the operator and then operand will be safe dot Factor will go back here and say 5 is an integer so we get 5 and plus 5 will be the operator plus operand now finally I'm going to return an array operator operand instead of using three items in one area now we're gonna have only two this is a unary operation the operator and the operand and we need to handle this special case in the interpret method over here I'm gonna say if the if the tree is an instance of a list first of all it has to be an instance of list so I'm gonna say if tree is an instance of a list and after that and the length of the tree is equal to 2 which means it's a unary operation only the operator and the operand in that case what I'm going to do is I am going to compute it now I'm going to compute the unary operation I'm going to say return self dot compute underscore unary and the operator will be 3 0. operand will be three one so let's Define compute unary this will take itself this will take in left or operator operand and this should just return the operator upon the operands of it should just do operator or in fact I'll I'll do it in this way I'm say if operator is equal to plus and this time you have to still check for Value if operated at Value is Plus I'm gonna return Plus operand and we can't do operand here directly because remember we still have to configure the the left and right the operand the same in the same way we configured the left and right values and so I'm going to copy all of this over here it can be equal to a variable as well plus a for instance so it's just going to be for the operand this time operand is equal to variable operand DOT type and operand type again so one final thing I'm gonna read operand again yeah so yeah okay so let's do operand and operand so there we go now L if the operator dot value is minus in that case I'm going to return minus operate operand so now let's run this function so I'm gonna say in this uh your return compute unary so this should work and one more exception is let's say we just input a number like one or let's say we input a number like two we can't handle that right now because we are assuming there is a valid binary operation there is an operation but there is an exception where the user just does not have any operations just one number inputed in that scenario I'm going to do L if um let's say L if not is instance of list if it's not even a tree in that case I am just going to return the tree so if it's not a list like for instance uh if there are if the only input is the number one the input is the number one in that case our tree will look something like this it'll just it'll just look like the number one but instead it's actually the integer class so it's the integer class with type of int and value one so it won't be a list it'll just be this one value over here so if it's not an instance of a list that means the user has just inputted the value one or the value of two let's just input is the number in that case I just want to return that out because you don't have any operation to do else if none of these are true we are going to do our usual binary operation so let's delete and this is the urinary operation and this is no operation so let's save and I'm going to run the shell if I do plus five I get none this time let's see where we went wrong let's print the tree actually see if that's working plus five no even the tree is returning none so there's a problem over here itself okay that's not tight that should be value not type so that's my mistake so I'm gonna close this again run it I'm going to do plus five okay and now we get a proper error this time let's let's look at this look into this one okay so it turns out I made two mistakes the first mistake is that I'd install this as a type this is actually the type not the operand itself and I'm going to run type again and the second mistake I made was in the parse method I did not so this is value I store this is type so I wrote self.token.type instead of self.token dot value so let's save now and hopefully it works this time so if I run again class 5 we get the output is 5 let's do minus five I get minus five I'm going to make a equal to 10. and then I'm going to do minus a and we get minus 10. so that works now we've computed unary operations and we've also handled the scenario where we have no operation like let's try no operation just the number one we get one outputed so another proof computed unary binary and no operations were effectively done with arithmetic we can do complicated arithmetic as well and we can handle variables we can store them we can read from them and now we've covered most of the basics we have some additional functionality to add but it'll be really easy now since we have the basic Foundation uh mapped out so now let's move on to the next section so in this section of the course we'll be talking about compare comparison operators and Boolean operators now Boolean operators we've talked about this way back in the start of the course where we talked about logic gates and we said that there are three main Boolean operators as the and gate the or gate and the not gate so in programming as well you require these three logic kits you require these three operators you require these three Boolean operators to perform logical operations like for instance I can find an instance over here where we use the logical operation in Python itself so it only seems viable to it only seems logical to give these operators to your users who will be using our programming language for them to for to allow them to create more useful and logical code so that's about Boolean operators comparison comparison operators and stuff like greater than checking if two numbers are greater than each other less than greater than n equal to less than equal to if two numbers are equally then to each other so these are the sort of checks that comparison operators do and remember all of this write down in the fundamental level is just a bunch of logic gates operating and that's why I had talked about logic gates in the start of this course so to manage these operators first I'm going to talk about the Boolean operator so we're going to first create a list of Boolean operators I'm going to say Boolean Boolean operators let's just do Boolean and over here we're gonna have ADD the second one is r and these third one is not and after that I'm gonna go to the tokenize method and over here these are examples of words so in this will come in the lecture dot letters condition and we first check if it's a declaration and if if it's not a declaration then we're gonna We're Not Gonna immediately assign it a variable for which gun check if it is part of the Boolean operator so I'm gonna say and if word in lecture or Boolean operators lecture of Boolean and then I'm going to set token equal to class Boolean and inputting the Boolean the name of the Boolean operator let's create this class Boolean and I'm gonna call it I'm gonna I'm sorry I'm gonna call the init method inside still taken self value and super not underscore in it Bool and value so let's say that and let's import Boolean from the data types that we've stored so after that now we're pretty much done with the lexor now let's move on to the passer in the passer instead of calling the expression method I'm going to call another another method called Boolean expression now what do the what is the grammar rule for Boolean look like the grammar rule will be like something like this so we'll have Bool expression and that will just be equal to a normal expression and then the Boolean operator name let's say and it can be or it can be not and that's going to be in small case and or not and followed by another expression so two expressions followed by the Boolean operator so to implement this I'm gonna create a new method let's call it Boolean expression Boolean underscore expression self so left underscore node equals self dot expression then while the current token same thing over here and we're doing a lot of copy pasting so it seems logical now to assign this same boilerplate code this uh basic code as its own method and then we call that method every single time instead of rewriting all of this code which kind of gets a bit messy now we've already done it Thrice so now after I create the Boolean expression and the comparison operator expression I'll be wrapping all of this code highlighted over here I'll be wrapping all of this code into its own new method and we call that method using in the Boolean expression in the normal expression method in the term method and so on so over here we're gonna call self.expression and if the token type is of Bool that's it that's the only check in that case the operation self.token and self dot expression over here so let's save and I'm gonna check if this works in the parser itself so I'm gonna comment Out The Interpreter okay it's already commented out and I'm going to run this okay I'm gonna run the shell if I run and now let's do the Boolean operator five and six you see that works okay it's only it it did not work um so type Bool left underscore node is self dot expression so the token the it seems to be working in the token the token seems to be working well the problem comes in parse okay that's because we haven't called Bool unsca expression my bad so wherever we have called expression now self dot expression wherever we will call that we're gonna replace that with bold on expression so over here I'm going to say self dot Bool underscore expression so let's replace it I think that's the name of our method yes it is Boolean expression so let's replace the first one second one let it be like that third one let it be like that and let's replace this one as well and this one as well so there we go I think okay there's one more remaining so I think that's it I'm going to save now and I think it should work this time so let's go to the Shell let's run let's run again and I'm gonna do five and two that works let's say if I do um five plus three or seven plus six and these operations don't mean anything as of now they only make sense when combined with the comparison operator so over here you see we get 5 plus 3 or is the Boolean operator seven plus six and notice I've given this higher precedence sorry lower precedence over the other operators I want this to be done last because that's how you do it you don't want to do three or seven and then the addition that doesn't make any sense you wanna give this the lowest precedence so now let's move on to the conditional operators so I'm going to say conditional or whatever I keep saying conditional it's comparison comparison comparisons let's do comparisons and then the first one will be greater than next one will be less than third one will be greater than and equal to fourth one will be less than or equal to and to check if two things are equal and python it's done as equal equal but in our programming language it's going to be question mark equal because I think that makes more sense we're checking if it's equal or not so we use a question mark so now we need to create another variable special characters and only if the character is in these special characters do we check if it's in the comparison comparisons list so let me greater than less than equal question mark so these are the four possible special characters now let's go over here and I'm gonna say l if L if self dot character dot special characters in that case I'm gonna make the compare comparison equal to an empty list for now comparison operator let's do there is an operator and over here I'm going to say while serve dot character is in Alexa dot special characters and self dot index is less than the length of the text in this case I'm gonna add the current character and then I'm going to move and finally I'm gonna token is equal to this time it's not going to be a Boolean it's going to be a comparison it's a comparison and we're going to feed In the comparison operator here let's create that as well comparison and I'm going to call this comp is the data type so let's import that finally comparison save and hopefully it works now so I'm gonna go back to the first of py and remember where in Boolean expression we called expression now we're going to call comp expression the comparison expression and comparison 2 is pretty similar in a comparison components per expression that's just equal to an expression greater than or equal to less than or equal to another expression you get the idea all of the comparative Expressions so we add a five in front of each of them and all of them together and followed by another expression so we are going to create one define com underscore expression so we'll take itself the left node will be self dot expression and now we need to change this to make it com underscore expression and comp on this expression expression left dot equals F dot expression and while self dot token DOT type is comp same thing I'm going to copy this and I'm going to do yeah that seems fine lastly we need to return the left mode so let's return left node and over here instead of calling expression I'm going to call comp underscore expression save it and let's try and running it I'm going to file let's check if Phi is equal to 5 and 7 greater than 2. so it groups this first as expression and groups the second expression and checks and and adding the Boolean operator between both of them so for The Interpreter I created the following code it's really messy but essentially what I'm doing is the same as what I did before if left is greater than right I'm going to Output 1 which stands for True else I'm going to Output 0 and I'm going to continue for this for all of the binary operators except not now not all there is a Boolean operator is a unary operator because it does not apply on two different operands it applies on just one operand so to handle not we have to form a different mechanism over here so in the past the py file I created not for the unary operator and I said okay this is how we made plus M minus unary operators I'm going to make not a unary operator and return the operator and self the Boolean expression just like how I did over here so because you can also have an expression not just a factor like for instance you can have um not 5 equals five so the Expressions 5 equals 5 and not is the unary operator and it actually turns out that even you can have the same thing over here since you're falling self tough factor I think it'll be more wise to call Self the Boolean expression over here itself so there we go now we're done with the parset of paper file and one more change I did it was I allowed for not so as of now we only call Boolean expression if it if the first token is integer floater operation now even if the first token is not like for instance not Phi equals 5 so this is still an arithmetic operation that I want to calculate and therefore I go into self dot Boolean expression so that's the two changes I made to pass the p y now let's go to The Interpreter and handle the not keyword in The Interpreter so over here it's a unary operation but do not that I just realized this that the in in the universe unary operation the operand can be an expression it doesn't necessarily have to be an integer like for instance you can have minus 5 times 5 this is a valid expression as of now I only thought of the possibility of maybe if minus five but it's not necessarily the operand is not necessarily an integer or a float it can be an expression as well so to handle that scenario I'm going to say expression equals cell a tree one I'm gonna say if expression is an instance of list that means it has a sub Tree in it so if expression is an instance of a list then I'm going to say expression equals self dot interpret recursion again expression so now instead of passing in tree one I'm gonna pass in expression itself so I'm going to save this now and let's go up to the compute unary method and over here let's add one final unary operator if operator dot value is not then I'm going to return 1 if not operand is true else I'm going to return 0. so let's save all of this let's go to shell.py and I'm going to run this now I'm gonna do not 5 equals 5 that means 5 equals 5 is once not 1 should be 0 and that indeed is the output let's try something else let's try Phi equals 5 and 7 greater than 2 that turns out to be 0 yes because 5 is equal to 5 and 7 is greater than 2. if I do 5 equals 5 and 7 less than 2 we'll get 0 but if I do 5 equal to 5 and 7 or 7 less than 2 we should get 1 which we indeed do so that's all about conditional operators and Boolean operators sorry comparison operators and Boolean operators and we'll use these two concepts to form our if statements and finally in the end we'll run a while loop as well so for all of that and more I'll see you in the next section so in this section the course I wrote the code regarding the if statements now before we go into it let's just talk about syntax so the grammar rule will look something like this we have an if statement followed by an expression and after that we can have L uh sorry the keyword do so expression and if the expression is true then do statement so that's the rule for if statements and also that can be if Alice statements as well in this so you can have if these statements not true then you have L if another expression followed by do another statement and this can go on and on the alif statements can go on and long and then finally at the end you can have an else statement followed by do and statement so that's the way in which we're going to create our if statement number I've already written the code for the Alexa and parser because this stuff is pretty repetitive and I don't want to write it all again so over here I've created reserved keywords as its own list now it has if alif else and do and in the tokens.py file we've also created a class for reserved tokens now after that I went into the lecture and apart from checking for Boolean values and declare declarations I'm also checking if the word is in the legs is in the result list in that case I'm going to add it to the instance of a reserved class now after that I'm going to go to the passer the passer has three aspects to it first of all in the statement method we check if the token value is if if it is if if it is if then we go to self.if statements we run the self.if statements method and the self.if statements method runs over here it stores the conditions and actions in two arrays so the conditions correspond conditions correspond to these expressions stored in a list and statements correspond actions correspond to these statements stored in the list so we store both of them as initially they are empty and then we call if statement make itself dot if statement now we go to this method Self Storage if statement which is responsible for grabbing the one con grabbing one condition and grabbing one action pertaining pertaining to one if statement or one alif statement so it first of all moves from the if for alif statement so it moves from the if statement goes to the condition and then it stores the condition as a Boolean expression then if these token dot value is due as we saw over here then we grab the statement we move up from the do and then we grab the statement and store it as an action and we return it now this second elf statement is for a special case when when we have unary operations now when we have unary operations and parentheses we call Self the Boolean expression within it and tend to move a point after the do keyword uh so we tend to move ahead of this so this second statement which is over here the second statement checks for if the the do keyboard is in the previous token in that scenario we return the condition and action so that's the alif statement and we run a while loop for all the LF statements in the end we check for an else statement we move from the else statement we move from the to keyword and then we we grab the action and store it in a list of three items if there is no else statement we store in it store the output in list of two out two items now let's go back over here the final output will contain self dot token and that is used to we are explicitly declaring if the statement is in if statement not because that makes it easy to detect the statement in The Interpreter so that's what the self token does in the first value and cef.if statements is just the output that we saw previously the conditions actions and else action now let's go to The Interpreter in The Interpreter we have okay so yeah over here in The Interpreter we check if the first value is reserved we first of all check if the instance of the trees list then we check if the first value is reserved and then we check if it's an if statement so we're using the so we're using this first item over here we're checking if it's reserved we're checking if it's an if statement in that case we are gonna iterate through each condition in the conditions list and we're going to also store the index of our Loop then we're going to interpret the condition and if the evaluation turns out to be to have a value of 1 then in that case we need to we're going to use the corresponding index and match the action using that corresponding index and we're going to interpret that action finally if the length is 3 that means that there is an else statement I'm going to interpret that else statement but and even if both of those conditions fail that means even if there is no l state if there's no else statement and the if conditions fail and the LF conditions fail in that case I'm just going to break out and return so that's pretty much it I noticed one error I had made beforehand is that in the compute unary method I've forgotten to return the output in the form of an integer float and I updated that as well so finally I'm gonna go to Shell and I'm going to run this we can have expressions like if I is greater than 2 2 make a equal 3 and you see we get a equal to 3 and this is my printing from here so let me just delete this evaluation print so let's control C clear I'm going to do if 5 is greater than 2 do make a equal to 3 . 3 we get a equal to 3 if 5 is less than 9 or 7 is greater than 3 do make a equal to 6. we can we make equal to 6 if 5 is greater than or equal to 5 do make a equal to 9 a becomes nine if let's see if a is equal to 9 and 7 is greater than 3 do make b equal to a plus 1 and B becomes 10. so that's the if statement covered and with that we have completed if statements variables and expressions so in this section of the course I created the while loop and first of all I modified the lecture and before we do that we need to think about the grammar Rule and this is how it looks like it's similar to the if statement where you have a while divide keyword followed by an expression followed by do followed by a statement so I just add a while to the reserved list and that's it to the Alexa now I moved the passer in the passer apart from the if statement check I also need to check if it's a while statement and I need to return accordingly I am returning a while statement over here so self dot while statement so I move from the while keyword and move to the expression and then over here I store the expression as a condition then if the value equals to if the next value is equal to 2 in that case I'm going to move and then I'm gonna store the action and then I'm gonna return this list and again for that special case when you're using unary operations you kind of move ahead because you call Boolean expression within the factor method and that's why I need to add this additional check over here so that's it in the passer now let's move on to The Interpreter so The Interpreter remember we had the check for if the value was an if now let's check if the value is wild then these are just some checks all right there we go now we check if the value is while in fact I don't even need this action over here so then I store the condition self dot interrupt three one zero that is the condition that we passed from the passer to The Interpreter then while the condition.value is one that means while that condition is true I'm gonna do the action and print out the response since after interpret the action then again I'm going to update the condition because if I don't do this the condition won't get updated and I'm going to update the condition and then again we're going to go into the while loop and check if the value is one so with that with those changes let's go and run the shell so I'm going to click on run and now let's do make a equals zero while a is less than 10. do make a equals a plus 1 and if I run this we get a equals 1 2 3 4 5 6 7 8 9 and 10 and finally we get none printed out so I don't really want that so I'm gonna go to the Shell and I'm gonna say if result is not none only then I'm going to print the result else you're just gonna leave it empty so let's do make a equals 0 while a is less than 10 do make a equal to a plus one and that gives our correct response over here and as you can see it converts it to floating Point numbers for some reason and these are just some minute details that are that are a bit buggy in our code it's not 100 full proof it's not as good as the modern programming languages but the goal of this course was to teach a few Concepts and create a simple programming language which can compute arithmetic operations and also some additional functionality as well