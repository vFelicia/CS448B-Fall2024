hello world by all means uh this isn't so much a vm as a machine that is less underpowered than the netbook i normally care around with me this netbook has many hours of battery life it's extremely portable and it's powered up it's powered by a windup toy so if i actually do test builds for you we'd be here a while all right i pretty much am forced to start let me see did i decide to go with index or index two yeah i think index two six and one half dozen together um i'm pretty much forced to start with the concept of circular dependencies when you are building a linux system if you've ever installed things there are often other prerequisite packages well when you get down far enough the dependencies become circular you can't install a system without boot media a usb or cd to boot it from you can't create a boot media without having a running system you know way back in the dark ages we had punched cards and paper tape that you could physically write information to or the switches on the front of the altair that you know you could flip here's the address here's the here's the value the right button and you could literally toggle in a program if you had hours to do it that went away a long time ago we now have you know millions of bytes of stuff and when you're putting together a system something you're going to hit a lot especially if you ever deal with something like linux from scratch is you have to build packages before you can build other packages and in order to avoid bits of the host system leaking into the target you sometimes have to build something that you're not actually going to install but you're going to build against so we'll get to all that but the reason i introduce with the concept of circular dependencies is i have spent two weeks attempting to come up with a nice linear index of here's the topics i want to cover in this order and it's circular dependencies all the way down so we're going to be explaining some stuff and then coming back to explain why that was incomplete or wrong a little later all right so circular dependencies so there are four let me there are four basic components of a build environment of a linux system that's capable of rebuilding itself under itself from source code those four are a kernel a c library a set of command line utilities and a tool chain and a tool chain is what all the embedded geeks call a compiler and linker and the make program the set of build utilities that actually let you compile stuff when you are creating a system though it doesn't have to be able to rebuild itself under itself your your tiny little embedded ones generally don't so your build time packages and your runtime packages one of the ways that you break circular dependencies is by separating them okay one of the things i did as okay one of the things i did is back story to this a long time ago is starting like 15 years ago i created a project called aboriginal linux from the latin ab originate from the beginning where basically i started with linux from scratch and i went okay what is the smallest simplest build environment i can get capable of building itself from source code those four packages i talked about are conceptual packages i got it down to seven actual packages uh which were the linux kernel you see libsy at the time um make bash bin utils gcc and i list them here and busybox and in order to make that work i wound up actually maintaining busybox for a while because i did so much work with you know if i want to replace the new version of said with busybox said um it didn't work so i upgraded it to the point where you know i i upgraded their sort command i upgraded their mount command and it got to the point where the previous maintainer just handed it off to me for a couple of years and then i handed it off to dennis flozenko but busybox has had a lot of work over the years to make it provide the set of command line utilities all in one package and that was an explicit goal that took years of work the others you know the tool chain i used at the time was bin utils plus gcc plus make so three packages there and by the way uh even busybox at the time i was substituting in bash for its shell because i never got around to upgrading it shell that's why there's a seventh package there um busybox has had some work on its shell since then and it's possible that you could build linux from scratch with busybox ash these days i haven't tried it recently this was an old version of gcc that had been utils in gcc as two packages now they've metastasized to five packages you know so the simplest system with modern packages is less simple than previous systems were fun stuff linux is still linux for a while linux needed perl to build because peter and decided that was a thing in 2625 and it took me several years of submitting patches to remove pearl as a build requirement before that finally went away in like 2013. um okay so let me start by the simplest thing you can do to boot a system is because i'm in the wrong uh let's see yeah i haven't the intro file no okay so how simple can we get here is a page where someone booted hello world on the bare metal okay and you can easily google for this or you can go to that url i'll post a list of the urls i went to after the talk but basically what what he did is he has a little function that just repeatedly writes to the uh the output register of the serial port and has that iterate through a string and then specially builds it with a little assembly header and with a linker script that puts stuff in the right place does this stuff which you know the assembler gcc for the c part linker running the special linker script and then a program called obj copy that takes it from the elf format and copies it to a binary it basically the l format is a bit like zip or like tar it's an archive format for storing executable data so there's a variant of elf that stores shared libraries there's a variant of elf that stores dynamically linked programs there's a variant of elf that stores dynam statically linked programs it's basically the same archive with different header information and what this does is this extracts just the raw binary blob output format binary and puts it to test.bin and one of the things i did is hello hardware make.sh the other thing i have to introduce is the concept of cross compilers we'll get to that i mentioned circular dependencies and so if i run make.sh which i ran on that machine and the paths are different of course just make mcm two ha there i have it so this is actually the machine i muscle cross make two output let's try that now hey so that just compiled the the programming created a test.bin and then run is copied from his thing where we call qemu's system arm tell it machine uh versatile pb is one of the arm systems qmu no simulator does anybody here not know what qamu is okay qemu is an emulator it's a program that creates a virtual machine and runs the code you feed into it it has a builtin bootloader where basically you can go this file copy it into the virtual memory and jump to the start of it you know if it's in a known format it can actually read the header on it and go oh this is an elf file i'll do basically what obj copy did copy into memory myself and jump to the start information out of the header uh here we already did the obj copy so you know the bare metal one the dash kernel test.bin argument is basically telling it use your builtin bootloader to load this into the virtual machine's memory dash no graphics says instead of popping up a window with the bitmap output of your emulated video card you know whatever the program that's running wrote into the m you know it tried to access the emulated hardware and its its driver intercepted that and wrote it into the window instead of doing that just have a serial port on uh on the standard in and standard out of the qemu program so that whatever you write to qemu's standard in goes to the serial port and whatever the serial port you know whatever the program writes back to the serial port goes to standard out of qemu so that you can actually you know interact with it on qemu's standard in and you can actually do things like use tickle to script emulator instances that way it's it's very useful uh the dash m128m says 128 megabytes of memory is how much should be installed into the virtual machine this says basically what motherboard to emulate um what board board is shorthand for um for motherboard it basically says put this processor input memory at this location all the information about you know all the information that would be in device tree when we get to that you know all the information that the colonel needs to know where to look for these devices well qemu similarly needs to know where to put the emulated versions of them so we told it this is a common type of very old armboard from i think the 90s the versa the arm versatile board and then this is just me telling it don't attempt to emulate an audio device because if you do it will spam standard out with a bunch of i failed to to connect to oss and it's like i just don't want that so when i do that i get hello world it booted a virtual system which wrote something to the serial port and then just spun okay so this is about the simplest thing you can get a machine to do and actually see the output and my fan is starting up because it is spinning you'll notice there's a cpu pin and the other fun thing about this is we're now going to tell you why it's wrong and the reason that it's wrong is oh come on i have it in here somewhere um the reason that it's wrong is that real serial hardware only works at a certain rate you know it has a uart buffer that can fill up if you just spin writing to its output register it's going to start discarding data fairly quickly what you need to do is you need to read a status register that will have a bit set that says i am ready for the next byte or not and you can actually fetch that out of the linux kernel source code in uh it's under drivers yeah tty serial amba pl 011.c and then uh put uh yeah console put character um it's doing a read from a register and ending it and while it's doing that you know cpu relax is basically a way of telling the processor not to overheat it's it's a no op that takes a little extra time and then write the character once it frees up so you know that a driver attempting to talk to real hardware is doing an extra step that the emulator is not doing and we're going to hit that a few times in here but the really fun thing about this this pl 011 console putcare is a linux driver that's designed to work before interrupts have been enabled early in the linux boot process early print k we'll get to configuring the kernel in a little bit and that means that before linux has really initialized most of the other hardware it may want to print stuff out very very early on which means if you know what your serial hardware is and where it's configured you can basically look up what these macros are and substitute in the constants and cut and paste a line or two that let you stick print statements into anywhere you can stick it into a bootloader you can stick it into early boot you can truly debug almost anything with print statements you know so that's actually a nice little technique to have in your back pocket and we will get back to that so the other thing that's wrong with that is we're doing the simplest possible linux system and clearly hello world is not linux so let's actually do what it says on the tin and i should have done that beforehand because i want to build uh 410 and i don't know how slow the you know the net here is going to be too slow all right can you give me four nine i don't know when the next time last time i did a poll on this machine was all right so the other thing other than circular dependencies is we're going to have to define simplest what i'm going to show you right now is the simplest way to build a linux system hello what are you doing where are you at random thing in 2016 now right lovely do i have any others i have a bunch of others well here's three five right sure that's ancient still works the same way though did you finish yeah what the downside of switching to a much faster machine right before the thing is my careful setup i ran through is right there yes the 4.9 4.9 there we go all right so it's gonna boil down to we're going to do a yes which of these yes i know all right did i put it in here sure okay the theory behind building a kernel always boils down to you're going to do a make config you're going to do a make and then you you install and boot the result a lot of the times we're going to be cross compiling cross com the the difference between native compiling and and cross compiling is something that i'm going to explain on an x86 64 system we're going to start with the available def config so if you go make help grep underscore def config it should list for the architecture you've selected the available are you still checking out no no you're not come on there we go so it has i3 386 def config which is 32 bit and x86 64 def config which is 64 bit if i selected a different architecture a bunch of architectures in the arch directory if i selected you know make arch equals arm i'm going to get a whole bunch of def configs but for right now the simplest way of doing it is to build for the same architecture as this thing to not deal with cross compiling at all first and i'm going to go make x86 64 def config that's an underscore there i don't think you can actually see it seriously there we go and then make dash j8 as soon as we're done come on you can do it j8 and this is going to build an awful lot of kernel and that's going to go for a while so meanwhile in another window the reason i opened the second window let's build a hello world binary so the reason for this instead of exiting is that i'm going to run this as pid 1. when a kernel boots it needs first it needs a bootloader to have run to load it to load it into memory and there's a couple of times that it can load run straight around but we'll get to that then the kernel needs to know the board layout you know where to find the physical memory where to find the serial port if you're using a serial console where to find the i o devices even if you have buses you can scan you need to know what buses there are and where to find them so it needs some starting data before it can even scan the rest of the system to see you know what's plugged into usb well where's the usb controller and then it needs a root file system in order to load its first program from and it needs the first program to run and we're going to provide all those things in the little system we put together here we are going to use a knit ram fs and we are going to use a statically linked hello world program as init and we're going to boot this under qemu so that you can see basically hello world run in a different context so this is a second layer of useless before we start getting to actually useful now you'll notice this is this is building it at a reasonable clip you know this is an eightway smp machine and it's still building quite a lot the thing about def config is it's got how many symbols so that's 1164 that are just set to y uh actually okay there's the number that are that are set so 1252 symbols which select a lot of stuff you know we're not going over all of these symbols we do not have time so what we're going to do instead you know so make dev config is simple to build it is not going to result in the simplest system i thought it would take less time than this and then to package this up we are going to we are going to do this little invocation find period to cpio dot o dash h new c pipe it did to gzip and we're going to do that in the directory that has our new root file system so gzip i don't need i don't actually need the parentheses and then redirect that to the directory above this root.cpio.gz so this has created uh yeah i did i didn't strip that that's statically linked against glibc which means it's flipping enormous and it even has the source code in there but that won't that won't bother us when the linux kernel boots it starts by mounting a root file system there are a couple of ways you can specify where the root file system lives you can statically link in a cpio archive into the kernel binary which will be extracted into memory in a file system called init ram fs and ram fs is an instance of either ram fs or temp fs in more recent ones here doc documentation file systems i uh years ago i wrote documentation on this so if you want to uh you know read through all that this is just the very quick summary cpio is an older archive format that predates tar but still works just fine they used it because it's simpler tar is actually a lot more complicated under the covers that gets extracted into ramfs ramfs is a rambased file system there's four kinds of file systems there's block backed which is the conventional ones you're familiar with like ext2 there's a there's a block device which is a fixed amount of storage that gets formatted and interpreted through a second driver that tells us what kind of file system there is there's pipe backed which are called different things sometimes you hear them as network file systems fuse is another example of this where basically you're talking through a pipe to another program that speaks a protocol and that other program is providing your file system so that program may be samba that program may be you know there's a bunch of things it could be um pipe backed ones don't have to be network file systems but people usually think of that the point is that it's a serial protocol the third kind are the ram backed file systems where your your files are stored in memory where basically the linux disk cache the page cache and the deentry cache that store copies of the file you know copies of file data on their way to whatever backing store there is because if you're writing faster or if you've read them in and it doesn't want to redo the transaction with either the block device or the server you know the cache storing the data in the case of rambac file systems has been plugged so that there's nowhere to flush the pages to when you write data into a rambased file system there's two instances of them there's ramifest and tempfs in the kernel when you write it in there it it has nowhere to go so it stays and when you delete the files out of them it frees up the memory so that they automatically resize themselves to how much is actually being used now note that the older ram disk that you've probably heard of isn't actually a ram bass file system it is a block backed file system where you have a device driver that turns a block of memory into a block device it exposes it in dev as slash dev ram zero or something like that and then you use a second driver as the you know ext2 or vfat or something like that as the lens you look at that block of memory through you run a formatting program on it to put it in you know the right format you copy files into it and then you look at it through a second driver that is a convention that is a block based file system not a a ram based file system so a lot of people to this day still confuse those rambased file systems are actually a lot more memory efficient because the thing about a blockbased file system is you've got the copy in the block device and then you've got another copy in the page cache so it actually you know it it's actually less memory efficient to use the older format and a lot of people still don't understand the difference between those uh the fourth kind is synthetic file systems where there is no backing store when you read files or you write files you're talking to a driver that can do arbitrary stuff with them proc is an example of this sysfs is an example of this the contents of proc are just hallucinated by the driver it makes it up and then when you write stuff into there it can call any arbitrary function in the driver to do anything it wants you know so those are actually four different categories of file system and generally when you are telling the kernel you know when the kernel is booting it can extract a cpio archive into the ram fs instance it already has and this is called an it ram fs the older way of doing it before linux implemented any ram based file systems it only had an it rd the initial ram disk the block backed version so it could allocate a ram block disk and take something like an ext2 image and copy it in there it could take a gzipped ext2 image the same way that you'd uh you know you take an iso image for example that you ripped from a cd and then you can gzip it well you could you could copy that into the uh the ram disk and mount it using the iso 9660 driver as the lens you look at it through um and then the third thing it can do is if you didn't provide either of these two or if you did provide them but it couldn't find an init program to run out of them in in it remfs it looks for file slash init it looks for file init in the top level directory that is execu that has the executable bit set if it can exect that it'll stop looking further and it'll just launch pid 1. in the uh in the older ram disk based one it looked for a different name linux rc which uh is just historical interest don't go there and in uh init main dot c the in the linux kernel source code in init main.c there's a there's a function start kernel so if you go into the linux kernel source code and look in init main.c function start kernel you can actually trace through how the linux kernel starts up because this is the one that actually does it it has a bunch of different places it looks as fallbacks it looks for sbin in it it looks for etc in it it looks for bin in it and if it can't find any of those it'll launch been sh this is for the fourth sorry for the third place it looks if there is a root equals argument on the command line it goes ah this is a block device mount it and then try to find an init program in there that used to be you know that's that's the fallback root file system so those are the three different places that you can tell the linux kernel here's where to find your root file system and then within that file system you have an init program so the kernel has finished building and at the top level there's a file here called vm linux this is an elf program and i mentioned that elf is an archive format and you saw that obj dump trick will they do a variant of that object trick and then stick a little header on the front to create arch asterisk boot the the file arch x86 boot bz image and you'll notice i mentioned that this one's enormous we're going to go into kernel configuration stuff after this so what we do is we go qemu um let me see i did a uh i did a yeah yeah so oh this little trick here make dash j dollar sign parentheses n proc there's an nproc command that tells you how many processors this machine has so if you want to automatically do smp at the level that this machine does you can just you know that says run a command and turn its output into an argument so make dash j n proc will automatically do make dash j however many processors are in the machine that's what that little trick does it's fun thing so we did the make deck config we did the make and then this is kernel command line which is similar to the bare metal one qemu system i386 instead of arm this time because i'm running an x86 laptop dash no graphic is the same don't pop up a window instead give me a serial console on standard in and stand it out dash no reboot says when the system in here tries to reboot the hardware just exit qemu instead rather than restarting it here is where that kernel image we just built lives dash init rd of a file rd is as i mentioned there's the older uh boot mechanism that did initial ram disks i mentioned that you can statically link a cpio image into the kernel at build time well the method of pro of having the bootloader point it at an initial ram disk image that usually was a compressed block device boot loaders still know how to do that and the colonel still knows how to listen for that but what it does these days is first it checks the type to see is that a cpio signature at the start instead of ext2 or something like that if it identifies that you've fed it a compressed cpio image it goes oh i'll just extract this into a nitram fs and use initramfs instead of an it rd so it can auto detect the format so what we're doing is we're taking that archive and feeding it in through the external uh a nit rd loader and the reason we do that is every time we change the file system we don't have to rebuild the kernel because if it's statically linked in the kernel we'd have to rebuild the kernel and that's slow and then the last part which i screwed up there should not be a space there is append this is qemu ease for provide these extra arguments to the linux kernel command line what is the linux kernel command line there is a another one of these kernel.org docs capital d documentation is the online place for the documentation directory in the linux kernel source code under the linux kernel source there's a capital documentation directory with lots and lots of files in it i've already shown you documentation file systems fs root fs and ramfest.txt which is the documentation ramfest now let's look at they moved it recently it is now in oh oh okay they moved it between 4 9 and 4 10. it's in a different place now but it's the only old one here it moved into a sub directory but it's the same file name kernel parameters is a very nice file that just lists all the keyword equals value names that you can provide on the on the kernel command line to tell it to do stuff again as with the configuration symbols there's lots and lots and lots of them most of which aren't very interesting the ones that you are required to provide are well the the main one and that's wrong too if you're using a serial console you're going to want to say console equals the device the the name of the serial device that you're using you don't have to say slash dev if you do it'll recognize it and and chop it off but you have to identify which serial device should the should the serial console attach to because otherwise you won't get any console output and then panic equals one here says if the kernel panics reboot after this many seconds rather than hanging and remember that will make qemu exit so that's a lot more convenient here so we take this big invocation and we go and this will die because on this machine i have the root file system in another place but let's just use the one that i built a moment ago which is that root.cpio.gz that we just did so let's go back to here and go root.cpao.gz and now in a moment we should get come on hello do i have a broken qemu on this machine all right you're a much faster machine but i'm going to go back to the one that i actually did the initial setup on because this is silly oh that yes that would be wrong that would be why and it didn't make it far enough to panic so it never tried to exit qmu system x8664 yes that's much happier thank you so here are you know you'll notice there's lots and lots of boot messages what are you doing clock source switched to clock source tsc yes i saw that come on you should finish booting oh do i have a weird version of qemu on here oh yes i do blah it just it was booting asynchronously so it yeah so it continued to spit console messages after the thing so as i said this is very simple to build and pretty much useless we need to make the kernel smaller we need to make user space bigger well the next way to make user space bigger what have i got in here is i have a copy of busybox checked out here and what i'm going to do it is config prefix so i'm going to go make def config um who here has not configured a linux kernel okay we're going to get to configuring the linux kernel but busybox actually copied uh kernel configuration infrastructure so if i go make menu config i get an interactive configurator program where i can cursor up and cursor down and i can hit enter to go into a menu and i can hit space to select a symbol or deselect a symbol or sometimes it'll it'll cycle through asterisk m and space where the m means build this as a module rather than statically linking it into the kernel and if you don't understand what modules are just don't use them modules are a thing you level up to when when you need them it basically means that after the kernel has booted you can tell it here's an extra chunk of code using the ins mod or mod probe program say insert this module into the kernel and you can also tell it remove this module from the kernel at which point it will hide it from you but not free up the memory unless you've configured the kernel in a way people usually don't and provide an extra flag that will from that point on mark your kernel as tainted so that if you submit a bug report after doing it the kernel developers will explicitly ignore you yeah because removing bits from a running kernel is just not something that can ever quite be done safely or at least they haven't convinced themselves that it has and they just they don't want you to do that um but people like red hat with you know large amounts of money from corporations where the system should never be down even for maintenance they love you to do that so they'll argue with the kernel developers but anyway this menu config program is basically just a way of configuring stuff and then when i'm done do i want to save the new kernel configuration in this case no well now if i go to busybox and busybox make menu config there is a similar menu config here where you know here's stuff that would be in the new core utils package that was completely reimplemented you know here's you know do you want the dos to unix command do you want the df disk free command and they have a whole bunch of sub things of do you want it to have these features and back when i was maintaining this sucker i i did a policy that there is there are a bunch of yeah make help on a lot of packages will actually provide here's various make targets that's a good thing to know and you can then grep for the ones that have config in their names config is the default configuration you know you'll notice that we did the x86 64 def config over in the the kernel land well in busy box make def config basically says switch on everything that is sane don't switch on the weird debugging stuff don't switch on like the se linux stuff that won't build if you don't have the right headers installed but if it's a feature switch it on give me a configuration that includes pretty much everything we know how to do so this is the biggest busy box you know you can get and then you can go into make menu config and start switching stuff off to pare it down there's usually two starting points with any menu config based thing there's all no config and all yes config all no config is basically if you went into menu config and switched off everything that could be switched off this would be your config all yes config is the opposite switch on everything that you can switch on and the reason that busy box def config is different than busy bucks oh yes config is that in busybox all yes config is insane and switches on stuff that no sane human being would ever want and usually whatever your system is it won't work because i mentioned we're debugging stuff so make def config is a good starting point so what i did is i did make def config and then we compile it which shouldn't take as long as the kernel did and i don't know if this is a release version this is a random git snapshot but it should still work i've built it before if you're going to deploy it use a release version okay and then make help grip install which has config prefix so make config prefix equals i can just do pwd is an environment variable that is my current directory slash walrus just some name that i know isn't already there so i told it install into a directory that doesn't exist and so it populated this new directory oh yes you know my redeye flight that i had to get up at 3 30 a.m for was yesterday you'd think i'd be recovered by now that's why i got this the drink that chases unicorns into the ocean ah nasty stuff okay so so this popular director remember i said the older linux rc name that nobody uses anymore well busybox has been around for a while and it hasn't necessarily cleaned out all of its old stuff so what i do now is i do the same trick of find period pipe it to cpio dash h new c dash oh i never remember that part i wrote the documentation on this so i wouldn't have to remember it yes yes yes okay dash o all right dash o pipe it to gzip and root2.cpio.gz and now what we do is we take our earlier uh qemu system x86 64. and we cursor up and we tell it instead go to busybox busybox root2.cpao.gz and now we add one extra little thing rd init equals bin sh what i'm saying is instead of looking for a file called init in initramfs look for this file instead as your init program the name rd init dates back to when we were using ram disks instead of ram fs but it it listens for both so what that should say is do the same big long overcomplicated boot and no it didn't okay and you know what i did wrong i didn't statically link it all right let me explain more need more exposition so what it did here is it failed to boot it it panicked at the end and the okay freeing unused kernel memory is the last thing it says before launching a nid in this case it's freeing three different chunks failed to execute slash bin slash sh error negative two uh error negative two in the case of the the file is user include assem generic airno base.h if you you know know that and eno int you know negative two in this case enond no such file or directory but bin sh is there yes but the dynamic linker wasn't because i forgot to statically link it wherever it is bin sh is assembling to busybox busybox is a file that is dynamically linked and it is looking for the first thing it's going to look for is this file which is the dynamic linker that is the program it will actually execute and then this program will be the first argument to that it's kind of like when i have a shell script it has pound sign exclamation point and a path to the thing to actually run and then the thing that you actually run gets this is an argument so that pearl or python or the shell can interpret this script well dynamically linked elf binaries work the same way they have a dynamic linker program that runs and then loads all these other libraries in you know from the library search path into memory links all the references out of this thing to them and then jumped to its start and what it was basically saying is this misleading error message the no such file directory was saying the dynamic linker in this thing wasn't there all it had was a number and the number did say what the problem was but it didn't say what file the problem was so if you encounter that kind of thing you know you you learn you learn to debug this kind of stuff okay so what we do is we build again and this time um make clean make i don't have to do a make clean but i don't remember the way to tell it to so ld flags static make j8 right and we build again and then when that's done i can test that the busybox file is statically linked while it's doing that let me point you at a couple other interesting web pages so yeah what's the difference between rv um in current kernels not as much in current kernels i believe that a net ramifest will fall back to looking at init equals that went in like four six four seven or something it's fairly recent within the past year um init equals used to just tell the colonel what in it to look for when it was mounting a block device on you know stage three the root equals file back after it couldn't find a statically linked in it ram fs and then it couldn't find a an external rd image so it didn't have anything in it ram fs or an init rd then the third thing it would try to do was mount a block device and init equals used to only apply to that block device you needed the other argument to tell init ram fs what in it to look for okay i think that that has recently changed so i could say init equals and i'm using a four four nine kernel so we might as well try let's see so that will have okay so what i was pointing you to here let me finish the thought um i wrote a lot of documentation in that system that i have since stopped working on but you know i did this one for 15 years and i still answer questions about it but you know aboriginal linux our motto was we cross compiled so you don't have to where it booted these the smallest simplest development environment capable of rebuilding itself under from source under itself from source code and building linux from scratch under the result and that meant you could natively compile anything under qemu that you wanted to without ever having to cross compile again cross compiling is very hard i wrote documentation i meant to hand this out to the group i wrote an intro to cross compiling that explains you know basically what cross compiling is and why cross compiling is hard this is very polite because this was written not to scare people away from cross compiling this was sort of you know so you have to cross compile my sympathies here's how to do it um if you can avoid cross compiling try because cross compiling is really really nasty you have two contexts you have two sets of headers you know the one for the system that you're building on and the one that your system for the system you're building for you have two sets of of libraries you're linking against one for the system you're building on one for the system you're building for most systems go configure make make install and you know configure asks questions about the system you're building on and uses them to you know apply to the system you're building for and when they're two different systems the whole of configure is asking the wrong questions you know about half of cross compiling is figuring out how to lie to auto conf or to just get it to stop because it's like well let me build a little test binary and run it to see what the output output produces well you can't when you're cross compiling it won't run on this system that's sort of the point of cross compiling um and your build system if you are building something locally that like generates a header file you know a lot of times you will run a small c program to produce code that that or modify code that then gets compiled so you need a native compiler you need what's called a host compiler and you need a target compiler to build for the target and so you have two separate contexts and have to keep them separate you have to prevent bits of your host system from leaking into your target system and what you wind up doing is you know just natively compiling on a bunch of different targets it's like i tested it on an arm i tested it on spark i tested it on power pc i found slightly different bugs in each case but that's okay there's a linear number of them well when you're cross compiling i tested cross compiling from this system to that system and i got slightly different bugs every from system so it's hosts times targets so your testing you know attack surface is just exponentially larger and then there's the fact that only about two percent of the developers will ever care about cross compiling at all you know uh debian has over 40 000 packages in its repository maybe a thousand of them have ever been crosscompiled on a good day with a tailwind and so it's just cross compiling is a thing that can be done but the point of this entire project was native compiling under emulation is so much easier and then the trick i did was i fired up uh disc cc and taught it to call out uh through through qemu's emulated network to the cross compiler running on the host so configure ran fine the you know there was one set of headers the header information was preprocessed before dc sends it out to the compile node um linking ran fine because that happened inside the emulator i could install the result into the system so that my dependency recognition you know worked fine but the heavy lifting of compilation was moved outside of the emulator to some place that cpu was cheap and i had access to smp you know so that was a that was a fun thing i i did it for a long time and it's sort of out of scope here but feel free to read about it what i'm actually working on now is a project called make root which basically one of the things aboriginal linux did is it built its own cross tool chain and its own native tool chain well there's a project out there now called muscle cross make by the guy who does muscle libsy rich felker which is a tool chain builder that not only creates cross compilers but creates native compilers which is the thing that i couldn't beat out of you know build root will create cross compilers it doesn't want to create native compilers cross tool ng look right cross compilers it doesn't want to create native compilers you know um code sorcery would give you cross compilers they wouldn't give you native clouds there's a bunch of places i get cross compilers from but if i then wanted to build stuff in the resulting system i didn't have a compiler i could install into the thing i could fish them out of debian debian has native compilers for all the targets it supports but they depend on debbie and they're dynamically linked not statically linked so i would need glibc installed for like super h and stuff like that and it's like well now i have i have a package that will actually give me the native compilers which is why i started over and i went i can be much much simpler about building a thing and what this is is this is a shell script that builds a root file system which i'll i'll go through this in a little bit after after i go through configuring a kernel i'll go through this as here's how you make a simpler route file system but it's it's a shell script that will basically populate one of these directories you then cpio up and then run it out of ram fs and that gives you a nice starting system once you have one of these things if you want to repackage it as ext2 or repackage it as squash fs there's a make squash fest utility you can read the man page of i can walk you through how to do that too basically creating a file system for one of the other file formats is either run a utility like make squash fs or gen ext2fs that works like tar does here's a directory here's the output file it just puts it into the thing or what you can do is you can use a loopback device anybody here not know about lootback devices okay loopback devices if you need to create a block device file system you have to do it as root uh you can uh let's see dd e i f equals dev zero o f equals blah dot img bs equal block size equals one meg count equals let's say 256 so let's create a 256 megabyte capital m shouldn't have to care so that created a 256 megabyte blah.img and then i can format it yes come on come on there we go and then i can go mount dash o loop blah.img i need to create a directory for it mount show loopblah.img subdir and then there we go and subdir is that file system a a loopback device is a special block device that creates um it it basically is it's another type of lens remember how i said ext2 is a lens you look at a block device through to make it look you know like a directory full of files well this driver lets you look at a file and make it look like a block device it shows up as dev loop zero or dev loop one there's a bunch of them you know um these days it it dynamically creates more there used to be a static number of them kind of like uh ptys you know they're dynamically allocated now they used to be statically allocated they split the difference by statically allocating the first view and then dynamically adding more is you asked for them um and what you can actually do is you can do ello setup dev loop zero which i believe by default will tell you what it's associated with you know so if i say devloop one it says it's not associated with anything but dev loop zero is associated with this thing if what the mount command is doing behind the scenes is calling ello setup to associate file name with loop device there's a man page on elo setup if you want to know and then when you unmount it the unmount command recognizes oh this is a look this is a loopback device and calls ello setup dash d to deassociate that loopback device with that file and the advantage of this is i can is i can copy a file into here that's two.txt into subdir and then i can unmount subdirer and then i can gzip blah.img and i i have just created a compressed ext2 image of 256 megabyte size that's the basic procedure for if i want to create block device images now this works for normal block devices it doesn't work for flash devices flash devices aren't exactly blocked devices because the way flash works normal block devices have a granularity of like 512 bytes or these days 4k and the file systems have a block size of like 4k this is the the size that they upgrade with if your underlying device has a has an upgrade update granularity larger than the block size of a file system bad things happen because if your flash every time you write to the flash it's updating 128k chunk and you think you're writing 4k sectors so you have ext3 journaling and it's like right we write these things into the journal and then we update just this sector and we haven't written anything before it and we haven't written anything after it so we don't need to keep track of that and if we lose power in the middle of it all we have to do is replay the journal and that'll tell us you know what what changes we were in the middle of and then when we tried to remount it oh the entire directory is gone because that 4k was in the middle of 128k of directory and all of it got zeroed and then didn't get written back because the power was interrupted and oops my flash file system is corrupted because i'm using a file system type that isn't aware of flash's erase granularity this happens it's a bad thing so they have what's called log structured file systems that are designed for use on flash that the first thing they do is they do a special i o control against the block device that says what is your block what is your erase granularity what is the update size and alignment and stuff where are your erase blocks so that every time i update i am updating an entire erase block and they do things like they pack the data into the erase blocks so that they're not doing extra rights to you know we only updated a little of this thing so we don't want to erase and rewrite the whole thing we want to save our rights and and you know round robin around the disk because that's better for flash because flash wears out you know so they they work in a completely different way and if you try to mount one on a normal block device or on a loopback device it goes i can't figure out what the erase block size is that's part of the format of the file system i fail and it refuses to mount so if you mount one of those you have to provide if if you're faking it on something like a block device these days i believe you can provide an extra dash o option to to tell the driver and pretend your erase block size is this size so i can make a flash file system that i can then copy into flash but that's a whole area you now know you need to look it up but i can't cover it in any reasonable detail here okay so meanwhile going back to here we have built i opened a lot of windows didn't i i wonder which one is okay here we go so did i install no i didn't so make i should still have it up here make there we go oh did you have a question okay so we install into the thing now we and it's the same thing except walrus statically linked no dynamically linked darn it you didn't recursively remove the wall yeah it should have installed over it anyway you want to try that yeah yeah yeah yeah yeah yeah i didn't actually do a make clean this time did you detect that i changed the c flags and you're rebuilding everything okay statically linked all right let's do that install again what are you compiling i just built oh you're going to rebuild the thing and i didn't do the sea flags here i note that i haven't maintained this project since 2006. you can blame me for this but i will complain alright so file wara spin busybox static and let's do the cpio thing again which should still be in the command history and now let us go to wherever i had that kernel launch invocation too many open windows here we go and let's try it now hey all right i have a shell prompt so i have now made a simple to make kernel and root file system the kernel is still six and a half megs containing as you saw from the boot messages lots and lots of stuff we don't need and the root file system still has rather a lot of stuff we don't need it's the biggest busy box you can make and also you know i uh well it doesn't have a it doesn't have an init script so i have to mount t proc proc uh makeder proc i didn't make the directories and then i should be able to if config and you know nothing set up the network you know we need an init script that actually does some stuff so actually i'll get to the kernel let me go to the root file system stuff first this is that root file system builder i talked about so let me walk you through what it does you can you know github.com landley slash make root there's one script make root where you can basically just let me see if i let me check out a fresh copy of it i don't know just do i have no i do not have it extensively locally modified here woot january 31st is that current let me see yes okay so the first thing it's building is when i left busybox i started over from scratch in a project called toybox because i felt i could do a better job toybox is now the standard command line of android i am attempting to turn android into a selfhosting development environment i'm using what i learned on aboriginal linux to basically make it so that what's installed by default on android should be enough to build aosp let alone linux from scratch so that having an android phone is sufficient to develop for android um it's got usb on the end of it if you plug it into a usb hub you can add a usb keyboard usb mouse use chromecast to put it on a big screen and you know this is a gigahertz processor with at least half a gig of ram you know it it's a reasonably powerful system and if you plug it into usb it's going to be charging itself so i i gave a talk about that here at 2013 the android guys went basically sure why not and started merging my stuff and that's taking up an awful lot of my time oh what i didn't do is i didn't tell it to use the current version of toybox but i'll just grab the one of the things i did is i made it so that if you uh if you have an extracted directory in the packages directory with the same name it'll use that instead of extracting the tarball um you know 300 something line script but it actually does a lot so let me walk you through it so it's building toybox instead of busybox because i am migrating all my own stuff from busybox to toybox um it it's a somewhat cleaner implementation if you saw uh the the talk a couple of sessions ago on uh on shrinking the linux kernel um he he was comparing toy box to busybox um the the really fundamental difference the reason that android can use it and couldn't use busybox even though busybox predates and you know busybox is older than android and you know you're not gonna wait for them to start shipping it it's they're they're not shipping it for a reason is that they have a no gpl in user space policy gpl v3 happened about the same time that android did and they responded by throwing out the gpl v2 baby with the gpl v3 bathwater you know now that now that there's no such thing as the gpl anymore and you have warring camps that can you know the linux kernel and samba can't share code even though they implement two ends of the same protocol and each has to police their their submissions to make sure that they didn't get code from the other one because that would be incompatible and they'd get sued it's like android just went nope opting out and you know they rewrote they rewrote their bluetooth demon they threw away the one they had that was gpl and wrote one that's apache license they're they're slowly going through and removing that so toybox is under a public domain equivalent license that looks like a bsd license to make the lawyers happy and you know that's why they can merge it um okay so i did just build the thing and what that did is that created a directory called root that has a bunch of stuff and in the build directory it created a root.cpao.gz and this is a mix of toybox and busybox you could use just busybox but as i said my own personal development i am migrating from one to the other i'm only using busybox for the commands i haven't implemented a good enough version of in toybox yet so walking you through what this does this is the script on github uh it starts if you you know if you don't run it with any if you run it with unknown commands it prints out a help message it figures out if you've set the environment variable cross compile if so that is what cross compiler to use that says i'm not building it for uh the the host system i'm building it for arm or power pc or whatever the cross compiler is so it you know figures out a couple of things from that and it makes sure that it can actually run the cross compiler because if you point a cross compile you know compiler that isn't in your path it'll go uh no those directory names i mentioned above you can you can replace them if you want to it checks to make sure that you can build static binaries because it turns out on things like fedora unless you install the package that contains libsy.a it doesn't install the static libraries by default so you have to install an extra package in order to be able to link stuff statically it when you install a tool chain it can only do stuff dynamically because ulrich drepper hated static linking and even though he left to go work at the bank of evil goldman sachs um they haven't undone all of the damage uh static linking is very useful you'll you'll notice i i hadn't copied the shared libraries into the root file system i could run the ldd command to see what shared libraries do i need and copy them and then remember to run ldd against those libraries because libraries can link against other libraries but that's that's a lot of work up to that the simplest linux system as it says in the title of presentation is not going to be dynamically linked because dynamically dynamic linking adds complexity statically linking dynamic linking is worth it once you have reached enough different files sharing the same libraries that you're saving enough memory to care and it that won't be for a while okay so this is a thing that basically just extracts a tarball into a working directory and it checks to see if there is an extracted version and it will use that instead um it's only a few lines you can read that you know so and then cleanup is the one that uh deletes it afterwards this is basically tar extract and this is rmrf only they're you know kind of fancy versions but every time you see that one of them is tar extract this does a w get of the source tar balls from this url and checks the sha1 sum so these are the toybox and busybox packages we will be building and then the first thing it does is it sees if there's an airlock directory that contains the toybox binary because i mentioned that when you are crosscompiling it's easy for bits of the host system to leak into the target system and you have that combinatorial problem where it built slightly different on ubuntu than it did on red hat that it did on this thing and instead of one set of things to test it's one for each target so it's number of hosts times number of targets and that is going to get out of hand and you will have stuff that you haven't tested well the way i solve that is i spent years making sure that busybox provided tools you could build a whole system with and these days i'm doing the same with toybox every tool that is in toybox dev config is good enough to build a system with not all the tools are there but you know the ones that are there my set can actually run autoconf that kind of thing so what i do is i build toybox install it into a directory and then i have a list of files i need to copy out of the host system because toybox doesn't implement a reasonable version and then and there will always be a few because i don't include a compiler so i'm copying gcc i'm sim linking to the host gcc i'm sim linking to the host bin utils in this directory of commands and then i set the path to just that directory and this is called the airlock step where once i've done this i'm using this little tiny system i built to provide a known build environment to isolate against variations in the host system now aboriginal linux was doing a whole lot more sanitization it had a white list of environment variables where if it wasn't one of these recognized environment variables it would unset it and it was doing a lot more cleansing and stuff and 95 of the time you don't need to worry about that so this is you know this is a little more than the 80 20 thing this is like the 90 that gets you 95 of the thing so i this is creating an airlock step which is strictly speaking optional but it means that i'm building in a known environment i then um this is basically just dependency checking because you know in case i don't need to rebuild stuff that skip that step then what this does is this creates the directory layout this is doing a make deer of all the standard directories in one line this is pretty much the directories that packages expect to be in and with this set of directories i can install all the linux from scratch packages linux from scratch is an online book that tells you how to create a very large very complicated about 110 megabyte system using conventional gnu packages but it's the base of most os versions it's nothing remotely like the embedded world uses and i as i said i spent many years making it so that a megabyte and change of busybox could replace 100 megabytes of gnu packages but that is the old reference build that i use because you know if you want to use the big version of said you can mine should be a drop in replacement for it but in order to ensure that it's a drop in replacement i need to test against the old one and i need to test that it can build the old one in case i am missing anything um so you know there's an exception directory a tmp proc sys dev home m t root and then under user there's bin s bin and lib and then there's a directory there and these are pretty much the directories that linux expects to be there there is a standard called the linux standard base lsb that unfortunately the linux foundation took it over the linux foundation was formed when the um when two black holes of bureaucracy combined to form voltron of bureaucracy and um one of those was the free standards group the other one was osdl and when they combined the the focus shifted from maintaining this standard to asking donors for money and unfortunately what this meant is that the linux standard base was so badly maintained that a year or so back debian when the 5.0 release came out threw up its hands and said we're done we're not paying any attention to the standard anymore which is kind of sad because there should be a standard for this stuff so there's still 4.1 lsb 4.1 and it does describe the layout of these things etc directory is where a bunch of config files traditionally live temp was the directory that unix used for temporary files proc is where you mount procfs sys is where you mount sysfs those are two synthetic file systems that let you give you an api to play with the kernel so that ps can see what processes are available and you know ins mod can see what hardware is available and stuff like that uh dev is the directory that the device nodes go in i mentioned that the the serial console device is one of the devices in dev dev lo setup sorry devloop0 when i was showing loopback devices home is the directory under which the user accounts live mnt is a directory for additional mounts that's the traditional name for it the modern systems added one called media that does the same thing but they liked it um root is the home directory of the root user this is fallout from the days when uh home used to be on its own partition a lot and in case you hadn't you know in ca if you ever trash that partition it would give the and had to log in as root to administer the system it would give the root user you know somewhere to have his files um user bin s bin and lib actually exist because um ken thompson and dennis ritchie on their original uh pdp 11 in 1971 filled up their first disc their their root disc was a half megabyte very fast disc and then they had what was called an rk05 disc pack which was two and a half megabytes of external space basically like a usb disk today um slower but much larger and when they filled up their their root partition they leaked it into the user directory where they had the user accounts and then when they got a second expansion disk they moved all the user accounts to the new disk and they called that one home and they left the user directory to be eaten by the operating system and then people retconned all sorts of rationales for this but no that's why it happened and these days when i'm making a system you'll notice i just sim link user bin to bin user s bin to s bin and user lib to lib so you know there's there's there's a bin an sbin and a lib at the top directory that i just sim link to the second copy of them collapsing together because i don't care it doesn't matter you know but i researched why they did this in the first place and dennis ritchie wrote it up as a historical anecdote and i went oh that's why they did it now i know that we don't need to do it anymore a lot of this researching why we do things in the first place if you drill down into it a lot of times you can figure out it's okay to do it differently and it's okay not to do it at all once you understand why it was there so that's an example of that and then the var directory was um it was a place to put things that should persist across reboots but should be writable because etc could be in a readonly directory you know so config files versus dynamic config files so those are basically the the directories it expects to be there and you can just copy this snippet right out of my thing or just run this file then i create an init program now you'll notice i said you know init is pid one it is the program you run when the system first comes up and i actually wrote up a little things i probably won't have time to cover but should okay so um a knit is weird and i wrote down why and yeah these are a bunch of different examples of types of init you may encounter using bin sh's in it you've seen me do that um your app the hello world was an example of that but a lot of internet of things thing will just run you know they're in it as pid 1. um here is a shell script running as a knit and then at the end it execs another program um i wrote one called one it there's system five init which was the conventional one everybody was using 10 years ago then android uses its own init program these days there's a horrible one called systemd um and then there's others like upstart and open rc when people were trying to move beyond the the main problem with system five in it is it predated the widespread use of smp so it brought the system up in a single threaded manner and people wanted to paralyze parallelize the init to bring it up to bring the system up faster and they couldn't quite agree on that because you know well this has to come up after the network interface comes up so suddenly we have a dependency resolver where everything has to know what else it depends on and people wrote up a lot of different things and red hat basically shouted everybody down by having more money okay so pid one the first process that linux launches is special and what's special about it is to start with uh it has no parent it is launched directly by the kernel if it ever exits the kernel will panic you saw that colonel panic earlier of you know we couldn't find init because it was where we couldn't run in it because it was dynamically linked so we got a panic message and then qamu exited and otherwise would have rebooted the system um because init should never exit um init has most signals blocked specifically the way they implement that not exactly but you can think of it as sig default is sig ignore for init where if you get a signal the default handler for it will ignore it rather than killing the program and if a program's parent process dies so that you have an orphaned child that when it exit it wants to send sig child to somebody to notify it of its exit code but its parent has gone away it will be reparented to init and it is the reaper of orphan children okay so and it does a lot of things um if you run init equal slash bin slash sh your system will accumulate zombies if your shell does not know to listen for sig child which most of them don't there is actually a workaround if you set sig child to sig ignore in the signal handler tell it you know instead of having a signal or handler just set it to sig ignore sig child will be delivered and the fact that it was ignored is fine and then the child can exit so when you are running an init program if you're not going to handle sig child set the signal handler to sig ignore and you have you have to actually do that explicitly because the default one being like sig ignore isn't good enough in that case um so yeah and another thing is for example um init can't reboot the system because the reboot system call exits your process so the kernel will panic before rebooting so you have to fork a child have it call reboot and then you hang and wait yes i've i i mentioned that i wrote one it one it is a tiny little init program it's in toy box uh you can find it on the busy box mailing list way back when but they didn't merge it where it does just the basic setup another thing about init is that it inherits file handle zero file handle one file handle two pointing to dev console it starts with a standard in standard out in standard error pointing to whichever dev console you had on init ram fs if you didn't have it in it mfs or if you created an init ramifest but didn't add a dev console to it which you'll notice we haven't in any of the ones we've done so far those opens will fail and your standard in standard out and standard error in it will be closed meaning anything you write will be ignored and if you try to do that as a shell prompt you know if you try to then exec bin sh it will exit immediately because it has no input to read from and no output to write to and it basically gets a sig pipe and goes nope um so what this init script does this init script you know we start with pound sign exclamation point ben sh we then set a home directory and set a path because we didn't necessarily inherit one our environment is mostly blank so if we want you know some basic environment variables that you just sort of expect to be there we have to set them ourselves um we mount proc on proc we mount sysfs on sys the reason that it's doing this is i sometimes use this subnet script to change root into a directory and when you change root into a directory the system may already have some stuff there um so that's why i'm checking if they're already mounted uh is just for change root it won't be in your systems i then mount dev temp fs dev temp fs is a file system that was added a few years ago that automatically populates the dev directory with all the devices that are there so you don't need something like udev or system systemd to do it you don't need a demon listening for hot plug events and creating device nodes the colonel can do it for you and it took several years to browbeat greg crowe hartman and and company into going you know the kernel can really do this for you but what names will we use okay you notice how under sis fs cis class like you know mem there are names why don't you use these names eventually they went all right we'll use those names they are unique and it's like yeah so you know you you get a set of devices from uh dev temp fs and then pts is the pseudo terminals if you use the new pty format that auto you know that automatically allocates them rather than the static link from ones from way back when that requires a file system to you know every time you create one it shows up in this directory so that's where it expects it um so yeah that that does amount of dev pts amount of dev temp fs amount of cis fs an amount of proc it then does an if config of e0 and a route add default gateway for qemu if you are using qemu's emulated network this is the address that if you ran dhcp this is the address it would give you and this is the gateway that will talk to the outside world through its basically faked ip masquerading that it does um and then i attempt to set the the date in case i am emulating a system that doesn't have a persistent clock because you know some arm or sh boards or stuff like that it's like this system doesn't have a clock so the kernel doesn't know what to set the clock to so i can do it once i brought up the virtual network i can do a transaction with a host that says hey what time is it and get that set up i then figure out when i you know the kernel command line is available i think this is actually the uh yeah this is the kernel i just built so this is the emulated system actually that is still running under qemu but and proc command line this is the command line that i fed in you may remember that from the qemu command line so in procfs i can see what my command line is and what i did here was i ran said against proc cmdline to see if there's a command line argument if so i figure out what device it is and the reason i do that is remember that standard in standard out in standard error that init inherited go to slash dev console well dev console is a device that is an alias for whatever actual console device you're using to talk to the outside world but it does not provide a controlling tty so if i hit ctrl c it doesn't send a signal to my program and if i accidentally if i run like ping that just endlessly pings stuff and doesn't exit and i'm going ctrl c ctrl c ctrl c and it's ignoring me and i'm going right i have to reboot my emulator because i screwed up you know well what one it does is it closes the standard in standard out and standard error that it inherited and opens the ones from the actual console device the serial device that does provide a controlling tty so that if i'm connected to that one and i hit control c it sends the program a signal okay so that's why i'm doing that thing with the console you don't necessarily have to do that in your thing if you don't expect to have a command line running as pid 1 you know your init will also do the proper setup to that thing if you run sys5 in it or something like that but i'm doing that here because trying to be simple um and then i figure out you know okay what program do i run next by default i just run bin sh but i can set the environment variable handoff in all caps one fun little thing about one fun little thing about this is let's see any unrecognized keyword equals value argument on the kernel command line it will set as an environment variable so i can set any environment variable i want to tell my init script to do stuff on the qemu command line so that's you know just a fun little thing now notice i had to put that before the rdnit line because init equals or rd init equals it will think that it's an argument to sh okay one once you get to that point everything else becomes an argument to sh so it would have to it does have a positioning dependency all right so getting back to this script so i create my init script and here is the eof of the here document if you know shell programming i just wrote this out as a here document so that the contents of the script could be in the uh in the script and then i change mod plus exit because if it can't execute the init it won't run and you can't run a shell script unless it has the executable bit set i then write out an etc password file to say these are the two users that are on the system and this is in the format that etc password has been in forever and i write out an etc group file i did not write out shadow files so there's no passwords associated with this i can't log in as any of these users but s u if you're switching user from root doesn't care and you know i could have set up a shadow thing but then what passwords would i assign to them it's like i just didn't bother but this lets me this lets them know uid 0 is root you know which uid 0 is always root but this lets it know that the name root goes with that and if i log in as root my default shell should be bin sh and my home directory should be here and then i created a guest account to be uid 500 and i told it you know here's your home directory here's the shell to run that's just what the etc password format is there's a i think there's a man page on it um and then i wrote name server 8.8.8.8 into etcresolve.conf the file slash etc slash resolve dot conf is the file that the c library reads every time you attempt to do a dns lookup it goes where are my name servers 8.8.8.8 is the ip of the google dns pool so i don't actually have to even put in a second one you're supposed to have fallback servers but like that's a pool of 30something machines around the world that it does the automatic magic routing to the closest one to the through the weird backbone stuff um and that basically means that should all if i can get out to the net that's the dns server that should be up barring nuclear war and even then maybe um so then you know i so those were actually the directories i created and the uh the configuration files i added to give me a basic system where playing around on a shell prompt if i do lsl it should give me like usernames for the files at least the ones belonging to root and group sort of thing then i build and install toybox which you know it it's only this and the only reason it's it's weird is you know i i did a make you know setup four is the thing that's basic guitar extract to the tarball make def config just like busy box um i then changed one of the symbols because the muscle libsy maintainer and i have this longstanding disagreement about how no mmu should be configured if you're not using a nom immune system this does not apply to you at all and i've actually updated that but i haven't pushed it to the repository yet so it only does it for no immune systems um if you care about no mmu's stay after we don't have time but i've done a lot with them i mentioned that elf is essentially an archive format for binary data well there's a slightly upgraded version called fdpic that annotates it with slightly more data and the reason for this is no mmu systems can't have two processes using the same address space to see different things because it doesn't have a memory management unit it can't remap them it can sometimes have you know low water marks and high water marks where if you access memory outside of this window you'll get a seg fault but if you can access that address you see the same thing for every process meaning if your elf thing wants to be loaded at address hex 1000 and you have two instances of it running you can't because the second instance would need to load at the same address as the first instance and they would get sad um and the way most elf programs are linked the you know there's like four interesting segments there's the code segment the data segment the uh bss and the other one um i'll think about it as soon as i stop trying um but the the problem is they're all put right after each other in memory and the addresses of them you know this piece of machine code will go where i am you know or the start of this you know the start of the program plus this many bytes for the data or for bss is the um ah ro data is the other one uh there's one code segment and three data segments basically one of the data segments is for data that you can uh that starts initialized to a value but you can then modify it afterwards it's basically your global variables that are initialized to a value bss is for your global variables that are initialized to zero so their contents don't actually have to be stored in the elf thing it basically maps a segment of memory there that isn't backed by the file and then goes you know have at and then the ro data is the stuff that's initialized to a value but then if you try to write to it you will get a seg fault because it is not writable you know and they're basically all glued together in elf as one big contiguous chunk of memory what fdpic does is it says these are now four con four distinct chunks of memory load them wherever you can fit and that means you can share the code segment with other programs that think they've you know loaded this and it they also it's a pick position independent code normally we only link libraries that way where we say we have saved in a register or saved in some global thing that you know either ties up a register or causes an extra indirect you know load to slow your assembly down but that means that wherever it can be loaded at different starting addresses and that means if you have shared libraries well each shared library doesn't magically know what all the other shared libraries you have running are so they can't at compile time pick a unique memory location to be so they have to be relocatable because they could be used in combination with who knows what other libraries well what they did is pi position independent executables are executables built as pick so that they can be relocated the security guys love this because that way if you try to exploit it using an absolute address and it's loaded at a random location each time you load it's harder to exploit well the no mmu guys love this because it's like i can have three instances of this loaded at different locations and they don't you know it's not going to conflict with other programs that think they're using the same thing but what fdpik lets you do is it lets you say okay the readonly section can be shared with other instances of the program the code section can be shared with other instances of the program the data section and bss you need your own instances of because you're going to write to that data so these two are shared wherever they can fit these two are unique wherever they can fit however if your memory is fragmented you can't use the mmu to collate it but you can fit it into smaller chunks because we've broken the program into four different pieces that can load wherever you can fit them fdpic is much much nicer for no immune systems but it means you need a different kind of program loader you know so it when you build the program you need to produce a different output format so again went off on a tangent um but anyway that me arguing with the muscle libsy maintainer uh yeah so anyway it it does a build statically linking and then it doesn't install and then cleanup is that rmrf thing and then this is a busy box install where i did something called mini config and the the last little bit i'm going to get to and i think i'm going over time probably but the last little bit i'm going to get to is configuring you know drilling down into the kernel config this is the same format as the kernel config what i did is instead of a def config busy box i told it these are the symbols i want only these symbols start with all no config and there's there's a bunch of them you know but you know this is less than 100 symbols and busybox has hundreds and hundreds of symbols a full config file for busybox which i just built is 1097 lines this is it ends on line 261 and it started on line uh 191 so 150 symbols instead of a thousand and stuff and that's for selecting you know rather a lot of stuff and what this is this is a format called mini config which i did write up documentation on once here i tried to send this upstream to the kernel of documentation on how to do it you'll notice this was 2005. i resubmitted it again a year later to see if they change their minds like no bunch of people are using this doc documentation on it is not submitted upstream of the kernel if you ever think about linux kernel stuff oh well any interesting idea immediately gets implemented and done by the vast hordes of kernel developers i will point you at the fact that the squash fs developer the squash fest developer spent something like seven years attempting to merge squash fs into the kernel he took a year off to full time push it upstream into the kernel after it was already in red hat susie debbie and gentoo and like everything else it had been merged everywhere and the kernel developers wouldn't take it i spent something like seven years getting pearl removed from the kernel build environment from the first oh wouldn't it be a good idea to use temp fs for init ram fs from me first mentioning on the mailing list of you know is anybody working on this to me actually sitting down and doing it was something like nine years okay so yeah the the the normal state of things is for somebody to do it off in a corner and then it's abandoned and it never goes upstream into the kernel if you know brow beating all these developers for you know oh you implemented stuff for your company and you've been using it inhouse for years but it isn't upstream in the car that's actually fairly normal uh it's sad but it's normal so before that tangent i was attempting to explain oh what was i attempting to explain i closed the window i don't need oh i was attempting to explain mini config where i did i actually did documentation describing you know all sorts of stuff about mini config but i will walk you through it right now basically what you do is you have keyword equals value config symbols like this in the same format they appear in the config file but the question you ask yourself is if i start with make all no config in the linux kernel in busybox and anything that's using menu config and i go okay i've switched everything off now i want to pull up that menu config tool and i have a checklist written down of look for this symbol and switch it on and every time i do so there's a dependency resolver that may switch on other symbols for me or change their values or whatever well that runs every time i poke a symbol in menu config switch it on or switch it off it may have fallout with other symbols in the curl but i don't really care all i care about is i started with all no config and then i went down my checklist switching on these symbols and then i saved the result and i built it i know how to do that by hand can i automate this process and yes you can that's exactly what miniconfig does and the magic line here is make all no config k config underscore all config equals the name of the file containing all these symbols it's a horrible name a large part of what that patch i had from many years ago was having a make mini config target that among other things would tell you if you tried to set a symbol that didn't exist instead of silently ignoring it it would go oops error you screwed up you know that kind of thing um and there was bike shedding from a guy named roman zippel and even though he's not there anymore it's i tangent tangent so this is a fairly useful technique for configuring busybox a lot more you know concisely and it used ldl oh it said it as an environment variable not on the command line make is terrible um i'm sorry it people give python guff about the significant white space and totally ignore the fact that make requires tabs not spaces in a lot of places like no it it combines imperative and declarative code in the same context where you have to care what order things happen in but have no control over it it's like no tangent there's a whole rant on there um yeah configure make and make install all kind of need to be replaced it's just nobody can really agree on what i already went into the whole autoconfiz you know totally does not work with cross compiling and half the things it's checking for specified by posix anyway and if your build environment isn't posix fix your build environment um and make install of course has no idea what a package manager is so things anyway but meanwhile we do configure make and make install and config prefix just tells it where to install and i'm installing the unstripped version in case i want to you know run gdb against or something and then this was my attempt to copy the dynamic libraries out of the cross compiler onto the system to give the option of dynamically linking and just ignore this entire section because it doesn't work you can actually see that it's my second attempt and the problem is i can get it easily to work with any one cross compiler getting it to work with all cross compilers which may be using different c libraries there's a lot of testing there it's on my todo list so just ignore the thing about trying to make that work and then if i want to build additional packages you know i have a second example here that you know what if i want to cross compile more stuff well here's cross compiling you know zlib and dropbear and installing those into the system here's just examples of using the same infrastructure to do that with different packages in case you want to cross compile more stuff and then at the very end you may have noticed i kept pulling up this file to look at the end where it's like and here's the invocation to turn that into a cpio.gz file you know so that is what this build script does and if you feed it one of the muscle cross make uh tool chains which i've been talking to rich felker he and i actually worked together um to try to get him to do binary releases so i could just point you at a url of download the binary of the prebuilt tool chain extract it add it to your path and then follow along building the thing and it's not up yet because he's been really really busy and i'm not hosting it anywhere because it's gpl v3 and i don't want to get any of that on me um i launched the first gpl enforcement suits that actually wound up in court suing people back when i was busy box maintainer i know a whole lot more about gpl enforcement than any sane person would ever want to and after a year of empirically going through and proving that none of these companies that were shipping busybox binaries had any code we wanted not adding one line of code to the busybox repository after looking at a whole bunch of sourcetree dumps i basically went i i don't want to go there and i really don't but but it made me a lot more careful about license compliance stuff because you you can't you can't spend a whole lot of time dealing with legal stuff without being really careful to make sure you don't have to again okay so that is an example of building a simple root file system but building a simple kernel def config was terrible so let's walk through real quick because we're short on time let's walk through kernel building so i actually i showed you the start of this this file before um see i configure creates a config file um i haven't really had time to talk about device trees but when the kernel boots um the bootloader there's actually two bootloader stages on real hardware you have a bootloader stage one that does two minutes lovely okay um ask me afterwards the the real hardware does things that qmu doesn't have to um so cumulus are built in bootloader we've just been using that and explain it now so so we start with all no config and in order to do a standard x86 system these are in theory the three symbols you need what board am i using and where is my serial console so i set these three symbols i then do the make i then boot it and i get no output and the reason i get no output is that printf is switched off why is printf switched off because the symbol config embedded was broken by him by this commit which was really stupid special case nonsense that that says when all no config happens switch this symbol on which results in opening a menu so that a lot more symbols can be switched off and this this winds up switching off printf so what you actually do is you do a special commit oops um so you have a line that looks like this config embedded is not set which ordinarily and which is how you tell dot config a symbol is switched off yes pound sign means a comment but this special comment is functional so we add this line and then we get output but it says no file system could mount root so we have to tell it to enable the check for external and nrd which are these two symbols and then it says it couldn't execute bin sh so i have to basically switch on config bin format elf so it knows how to read an elf binary and then um then i get to the point where it reads hello world um in order to be able to do a shell script i have to switch on config bin format script and then i can run my init script except it can't mount dev temp it can't mount dev temp fs so i have to switch on two symbols in order to get the file system that gives me the dev directory and i i could i could go into more but basically this is the kind of thing that you know the the minimal set of symbols that i was using for each target back in four three uh let me github.com landley back when i was doing aboriginal linux the set of symbols that i used for uh each target was in the targets directory there were a bunch of things like here's the one for rmv5 in order to boot a system i needed to know what arch equals value to tell the kernel when i built what path the resulting bootable file would would show up at that's for building gcc you don't have to care about that um what console value to feed it because which which console device am i using and then here is the all no can here's the symbols i added just for this architecture for this board and the set of devices on this board and here's the qemu invocation i would use to to load it and that set of symbols was actually added to base config linux which has more than you actually need but these were the common symbols that i would set on all the targets so you can actually read through and see what those symbols are you don't need a lot of these and if i if i had a little more time i'd go through the here's the list of the ones you need but unfortunately i am over time i can probably take one or two questions i cannot okay oh sorry somebody needs the room i'm sorry ask me afterwards