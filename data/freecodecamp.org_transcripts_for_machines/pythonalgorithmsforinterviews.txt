so the primary purpose of this video series is gonna be for analyzing not just algorithms but also primarily pieces that are can be utilized not just a computer science but also for interviews and we're gonna be starting up with something called the Big O so really quickly and we're gonna be doing this all in the Jupiter notebook primarily because it's not that difficult enough that we have to use pycharm and it's also a little bit cleaner looking so why analyze algorithms in the first place so an algorithm don't get nervous but the word is just a procedure or formula for solving a problem some of them are so useful that we've given them names like merge sort or bubble sort etc and then one of the important things were going to come across you're gonna see very quickly is how can we compare the algorithms you know which is better and by better it's gonna be relative term to the task at hand but typically there's gonna be two avenues for analyzing if an algorithm is better than another and that's going to be either by speed time of completion and that's gonna go into its scalability and also memory its size allotment and its requirements and so forth so really quick let's jump in so in this first segment of code I said it magic about this function this is just defining a function called sum of 1 it's taking one argument n so then we have final sum equals zero so we have an object final sum and we're giving a assignment of zero and it says for X and range n plus 1 so we have a for loop here range is gonna be whatever we define it for in terms of the hands I'm plus 1 equals final sum equals front of sum plus X and then we're returning the final sum so I'm just going to shift enter so that it actually loads into the jupiter notebook and then i have here some one and calling five is the argument and you'll see that it prints out 15 so what this did was with a with the object having the argument of 5 and the formula essentially the algorithm for this was for x and range so for each number in range and plus one and was 5 so in 6 you have to remember for range we started zero so we had to add that one of wanted to really get 5 actual numbers so cos 0 is not gonna have any implication for addition and the final sum was starting with 0 so if we did 5 times 4 we're gonna have 9 at 9 plus 3 is 12 12 plus 2 is 14 14 plus 1 is 15 so of course we got the answer to be 15 that's appropriate so let's see what this is all going towards anyway so again this is a function that we've created defining a sum of 1 and we got a result of 15 when N equals 5 we're gonna go down here now for this point and let's assume that you gave me this function you called it some two also taking only one argument of N and you instead of doing a for loop you're just returning n times n plus 1/2 and let's see what we get I'm going to shift into through that as well and same argument of 5 and we also get 15 same as that function if you actually did this math by hand of course PEMDAS is gonna hold place so parentheses are always gonna be first so you would have had 5 plus 1 which is going to be 6 6 times 5 is 30 30 divided by 2 is going to be 15 so what's the point of this essentially we got the same answer with two very different functions that's essentially that's that's the point of this so this is my function I created and this is the one that you created both getting the same result so function one is someone's gonna complain about that I and a few so function of someone it's using a for loop to iterate iteratively add across our range of plus one so here's our for loop and we're just iterating over the range that was dictated by the input n and it's adding across that range number two is simply just taking advantage of a formula it's a formula basis solve a problem both of these are technically algorithms because remember the algorithm is a procedure or a formula for solving a problem so we're solving a problem and here we're suffering a problem this is just more formula based and this is an iterative four loop that we're running so now the question is gonna come how do we compare them how do we determine whose function is better mine or yours and that's gonna become relative to what it is you're trying to determine defines is better so we have to objectively be able to compare them and the two places the two avenues I mentioned before that we can do the for is memory which is space allocation within the computer or the time to run how much time is it going to take to actually run that software so we're going to use builtin magic magic commands in the note the jupiter notebook times I might call ipython that's the old connotations back then it was just pi thana now it's multiple languages so they call it Jupiter notebook so first of this this is a magic command using the % side time it and I'm saying I want you to time it for the sum of one function with an N of 100 so I'm gonna shift unto that and right now what it's doing it's doing that for loop so there we go we got a hundred thousand loops bestofthree three point seven four microseconds per loop and then I'm gonna do with these same magic time at some two with a hunter as the input and then did you do oh it's doing the computation now it's like a second there depending on your computer it's going to determine if it happens faster or slower so for the same n of 100 which we know that they're going to give me the same answer and you can ignore this for right now it's just talking about caching that's the 344 but now this is nanoseconds so and I put down here just for those human I know micro which is up top here is ten to the minus six nano is ten to the minus nine so that means nano is a smaller number by a factor of three and so this is faster so in the two different functions we had function of some one a function of some two for the same n my algorithm your algorithm your algorithm was a function was much much faster you are nanoseconds that was a microseconds for time of completion but now that's not necessarily the endall beall because that's the time of completion of my computer your computer the time of completion might be faster or slower now of course granted we're talking micro in nanoseconds that difference can get very large when we have much larger inputs to deal with and some systems will be faster and slower but at the end of the day regardless for loops row is going to be slower and that's why we try to avoid them and especially machine learning artificial intelligence so now that we have that I have your smallest numbers obviously faster we know that so we can't rely on just time to run because again all computers to different hardware is going to be different some are faster than others we want this to be Hardware independent and that's one of the big takeaways because there's you know hardware is constantly changing so how can we objectively determine if one function is faster or slower or rather is better or worse than another function if we can't use the time parameter per se because of the objective nature of different computers well that's where the Big O comes in so the Big O is a way that we can objectively compare the efficiency of those two algorithms so we're gonna compare the number of assignments of each algorithm you know there's some key phrases you know that we're gonna run through and this is what I want you to be cognizant of so we're gonna compare the number of assignments a feed that each algorithm makes or has to undergo so for the original some one function it's I'm gonna read this and I'll go back up to it and show you what I mean the original some one functional created assignment n plus one x we can see this from the range based function this means it will assign the final some variable n plus one x we can then set for that problem of n size in this case just a number n this function will take 1 plus n steps and this one's going to become meaningless so going back up to function number one or some one what it's saying here is that the allocation that this is going to that this is gonna require in terms of an assignment it's only in a the assignment is this so if my n is 1 it's gonna have two assignments it's gonna have the assignment of 1 and then the assignment of 0 cuz again we're dealing with the indexing of 0 and its arranging if my n is 3 then we're gonna have 4 it's going to be the assignments gonna be still be n plus 1 because whatever the N is gonna be it's gonna be linear as the point so we're gonna be looking at here but there's only one assignment that's necessarily going on within this and a final first assignment is 0 and then that assignments gonna keep changing based on an order of a n the N notation allows us to compare the solutions and algorithms relative to the size of the problem so since some 110 and some one of 100,000 we take very different times to run but using the same algorithm we can also note that n grows very large the plus one doesn't have much effect that's almost referring before some of these constant number is essentially when you start to get to numbers like infinity or if you're familiar with calculus may get some limits that constants the constant numbers just drop off they no longer have a real effect on me on the ultimate coding and you'll see that in just a minute so how can we how can we still quantify this how can we still compare the functions and that's where Big O notation comes in it's describing how quickly the runtime will grow relative to the input as the input gets arbitrarily large and again this is how we're gonna measure one algorithm over another or even one you know different coding aspects like using numpy in an instance where it so it can be a heck of a lot faster than if we were using a builtin list sequence and in python using data frames instead also utilizing pandas so it's a Big O what I want you to upon your head is how well can it scale as the data increases because Big O has a lot to do with scaling that scaling can either be in time or it can be in memory so we're comparing how quickly the run time is going to grow not the exact run times since those are going to depend on the hardware so at least this way I can know it doesn't matter the system if I have two different algorithms I can tell you that one algorithm is going to have some element of time and this other algorithm is going to have a comparatively different relative amount of time regardless of the hardware one's going to be faster than the other if I can see the code and I do the Big O notation so as the end gets arbitrarily large we're only worried about the terms that will grow the fastest design gets large so essentially if you're looking at an algorithm and if you're trying to which we're gonna get down to just a second you trying to determine which element in that code is the driving factor which one's still which one's going to actually impose the limiting behavior on the execution of that code well that's going to be your Big O and everything else is essentially going to drop off and in math that's this this idea is called asymptotic analysis which is just describing limiting behavior so it's kind of looking at a whole picture so we're gonna get to this guy in a second so asymptotic analysis is looking at this return here and pretty much saying who's the limiting factor in here who's gonna limit what my n is going to be able to do which one of these guys is going to mess with scaling the most or of the most impact or the least impact on scaling and then you can go from there so again which part of the algorithm has the greatest effect on the final answer which part of the algo is the real bottleneck which is the limiting factor that's for the syntax someone can be said to be this is the notation here so they say this is a big all and since run time grows linear with input size so let's go back up to summit one so what we're saying is second this was big oh if I was to do it in that notation it was essentially just this but again the Big O that's that was going to be the objective nature of pick on rotation for this linear event but the one as n gets larger and larger and larger this number one falls off so when n is 1 or 5 or 10 you'll see an impact of the 1 but even just getting to a hundred and then a thousand this one becomes meaningless so we end up with a Big O notation N and again this is not supposed to make a lot of sense you just yet it will as we get further down when you can see the stuff in a graphical analysis so I wanted to bring this idea again of describing lipid behavior from an asymptotic analysis standpoint so here it is created a function called Big O with one argument hand and this is simply us returning 45 times n cubed plus 20 times n squared plus 19 and if I call Big O with an N of one I'm just gonna get 84 if you wanted to do that math you absolutely can just don't forget you have to do operations so the it's one cube times 45 and then 1 squared times 20 and then plus the 19 and they add it all together so if we just did one of the variable we're gonna get 84 so what happens if I do just two we oughta make the joke made it 42 459 so what I want you to see is just looking at these two here all we do is change n by a factor of 1 correct and yet our result substantially change but you the point is that this 19 it had an effect here even if from a percentage standpoint when n is 1 19 had an effect but when n is just 2 the 19 is pretty much becoming meaningless so this would not contribute to our computational intensive time because it's not really having any kind of an overall effect it's not limiting how we're progressing in terms of scaling so what happens if we go to a Big O of 10 so now we're up to 47,000 so now looking back at our RPC I'm gonna get to the second going just from 1 to 2 to 10 the 19 we already know is pretty much out of the picture 19 is not going to make a big difference here in terms of computational intensive requirements so then the questions had to come down which one of these is it I'll tell you right now but can you ignore the constants never look at constant numbers so we're really focusing on is n cubed and then squared and then we're pretty much saying which one of these is going to be the bottleneck which one of these is the limiting factor for this particular function well it can be seen that the 19 is at how much weight anymore we came to that conclusion already the 20 and squared in this case is 2,000 so out of 47,000 if we took out 2,000 we're not that far off you don't forget 45,000 if we go to the 19 so again 45,000 or 47,000 is not that big of a difference so we can pretty much conclude that the N squared it's not gonna be the living factor within this particular function so then we have the again the constant 45 don't care about per se but the N cubed I do and with our hand of 10 it's gonna be 45,000 so 45,000 and forty seven thousand have much more of a percentagebased impact on its outcome of the performance of the calculation of that particular function so in this function this entire piece here you would say this is essentially going to be you're controlling Big O this is what's going to determine your scalability this is what's gonna determine eight let me factor this is what's going to determine who's gonna have the biggest bang for your buck within your function and which is gonna require the most computational time in your system so this part of the Algol I realize a lot to do the fun answer as the data scales it's not going to be the 45 again here we have it's not me the 45 but it's gonna be the end cubed so this algorithm has an order of n cubed so it's a Big O whoopsadaisy let me put this in here so this is gonna be a Big O and then we'll just keep it this way that's what that would be the order for this particular function now what I have here this is just a big ole complexity chart we have horrible bad fair good and excellent so what this is showing that these are different elements and then we have the operations so if your function has a Big O of 1 or a big old log of n which is still going to be quite linear you can see that our performance here as n grows and is getting bigger bigger bigger bigger bigger bigger and this is the the operations the amount of operation to the be performed you can see that we're in the excellent range here excellent and good range for those particular big O's but then once we start to get to this is over the function of n which is very much like our our original function that we did somewhat 1 you can see we're in a fair from a performance standpoint as n grows so too does the time but the complexity of the nature that is not is not obscene and then we start to get bad once we get to Big O and log in and then we're getting into the horrible territory when n is squared 2 to the exponent of n over here you would have n cubed n cubed is even worse than 2 to the N in terms of operational performance this is something you can memorize I have two different charts here you can look at how you can go through so for the big oh I dig of one that's called a constant which is exactly what we'd have is it's going to be whatever if it's a you know Big O is 10 then it's gonna be 10 that's gonna be the constant number log of n logarithmic and linear we saw that log of N and the constant and the O and linear they're pretty fair in terms of after your elements grows your and grows your operational computation intensive doesn't grow substantially that it's still it's still considered a valid function of valid formula you're going to be using and then we go and log n log linear we're getting in today what was that fair no bad so we left fair weren't bad territory already just because of the amount of computational intensive that is putting on the system regardless of your system and then we have N squared + to the third then we have to n in terms of quad cubic exponential so this is just things you can start to memorize anymore you're going to be doing is this is what we're looking at when we're determining our function where does it fall in terms of the pit go this is a more broken down version of the Big O showing our one like a blog and logout and so and so forth going in this to what their actual from functional name is gonna be called if you were ever describing it what I have here this code I'm not gonna go through per se I'm just using this from demonstration purpose but we're importing log importing numpy importing matplotlib i'm gonna have map table in lime which you're gonna see in a moment setting up run ten comparison so what we're doing this we're using numpy to create a line space one two ten and then we're giving a different labels constant log linear a log linear quadratic cubic exponential and then what we're telling it to do here is the actual calculations each one of these calculations is corresponding to its particular label so therefore this could have been done even like a dictionary if you're going to do key values and then we're just setting up our figure size and we're going to be plotting it and then this is do to do this is how we're actually gonna go through the calculation piece what i'm gonna do is go through that and here we go so what this is just another graph version showing you that the n increases with the relative runtime on a particular system so in this case this is my system and it's giving you a color code below that were constant log linear log linear quadratic cubic exponential so again you can see we're in good better worse and then just asinine territory so even with the N of four you can see the relative runtime performance are here but we're in constant and log so we have constant log at for our relative runtime as you know you could say it's like one in change and now once we start to get up to linear log linear even with the vent of four we're still under ten for relative runtime so it's not it's not crazies because it can be somewhat grouped together but now we're launching out of it out of the territory R with quad cubic exponential we're just weaving with the end of four we're hitting relative run time substantially and look with a head of four we're looking to go off overall to one time here before a cubic and we're out of the ballpark and when what did we find four cubic was that's exactly what did you do this big onotation was for this particular it was cubic run so it's bigger was cubic so in terms of its relative performance you could see with a small n now with an N of 1 and n of 2 we saw a substantial change then ahead of and of 10 it just skyrocketed so we're here with a nun of 10 you can see how the relative run time if we ever even get up to the cubic it just rises at exponential the rises at a cubic rate so clearly we want to choose algorithms to stay away from any exponential quad or cubic behavior in terms of computational intensive typically mathematics and you're gonna see us when we're doing machine learning and AI and we're gonna use we're gonna use we will do exponential quadratic cubic behaviorists but we don't want to be doing them on large scale so if we're gonna be doing them we want our ends to be relatively smaller so if we keep our hands small we can keep our relative runtime in a manageable fashion but again this is exactly why if you're running certain neural networks on particular models on different pcs why you can have runtimes ekko hours days and two weeks depending on your system and why things like the GPU and it's parallelism why it has such a massive impact on decrease the amount of time that we can run with ml ai and DL and even some you're gonna see soon coming out which is the Nvidia Volta well it's already out one of the biggest pieces of that is its its ability with tensors and when you have a GPU that is primarily focus on tensor mathematics and manipulation you're gonna find that the scaling of that is going to be astronomical and the speed of that's gonna be high qualify so we currently have even we say the Titan X pain running up with Pascal so that's gonna be it for today again this was beginning of algorithms and we start with a Big O notation so and this this information that we're doing now is not just for like say for a computer science and it's not just for your knowledge all of this is even if you start going to interviews for computer science you're going to be dealing with functions or formulas that are going to be looking where are they falling in this are they computationally intensive from a memory standpoint or from a time standpoint how could you make them better what could happen that could make them worse and how can you make them functional in terms of what they're doing because again you can code and incredible piece of code but if it if it can't be run on you know 70% of systems in the world then what good was the code so you have to keep these things somewhat logical bigoh examples first for a Big O of one a constant numbers so we have here creating a function function is constant we're gonna put a values of the argument all we're doing is printing in this case the first item in a list of values that admit us our first item because we're indexing at 0 it's gonna be our first item so we're printing out values whatever we're going to run through values of the argument and printing out the index of one so we're calling that function here function constant one two and three so out of this list that was we're passing through our function of function constant give me the index position of 0 and sure enough it gives me one because that's appropriate now the point of this is that it doesn't matter how large my values list becomes this values list I could have made this four and I'm still gonna get one because doesn't matter if this was infinity digits long I'm only grabbing the first index position which is always going to be one and it's also in the first spot so this algorithm is only gonna grab the intercept 0 in that list no matter how many times I run out I'm gonna have me this list is so this is a constant this is a Big O of 1 in constants as you remember from the chart from yesterday have one of the lowest computation intensive impacts on a computer system in terms of performance so scalability this is nothing this is easy as balls you can scale this as much as you want we're only grabbing the first index position so now we're going to move on to oh and Big O of n which of course is going to be linear it's not a constants linear so linear is slightly above in terms of we're still in good performance on a Big O performance chart so regardless of n we still can get fair computational intensive out of the system so here were defining a function and we're going to put a list through there so we have four Val and list so that's going to be for our values in the list we want to print the values so it doesn't matter what our list is gonna be it's simply going to print this you know what I'm gonna do let me do this so you guys can see the outputs as we run it so I don't want you feel like your brain is cheating so you're going to pass the list of 1 2 & 3 through my functionalist Dodd defined function and all it should do is print out each one of these values within the list so we're going to shift through there so of course it prints out 1 2 & 3 so if every values gonna print no less each time the list gets larger though what's gonna happen to our what it's also gonna get larger it's not gonna be a constant it's gonna be linear so if right now if it's 3 it's gonna print out 3 conversely if it was larger it would print out a larger list so our list growth does have an impact on the computational intensive of our system and it has a has a a competition ance of risk up so you'd say Big O to the N as a linear growth rate so as our list grows with this particular function as our list grows so too does the computational not to the point that it's disasters though because again computers can do a hell of a lot of math but again the point is it has to do the whole list whatever I do pass through here so that's why Oh and linear is going to be a little bit more computationally intensive than Oh 1 constant so what do we have every valuable print the list each time so larger list gets the bigger the Big O yet that's exactly what is covered so now we're gonna go to quadratics this is gonna be Oh with n is square it so we're gonna create a quadratic Big O function so in this case we're gonna do that just by doing a for loop in a for loop so we're gonna do a functional quad we're gonna have a list and what we want to do is print a pair so for item 1 in list and then for item 2 unless print item 1 print item 2 nothing crazy will make our list just for fun we'll make it a little bit bigger want this to be neat and then we're just gonna call our function and function quad and then put our list through our list that we produce of 1 2 3 4 5 6 so what this is gonna do it's gonna go for item number 1 in the list and then it's gonna print one it's gonna print it's gonna print 3 it's gonna be so it's going to be 1 1 1 2 1 3 1 4 it's gonna do this for each item in the list as it goes through most one and list two so sure enough we have 1 1 1 2 1 3 1 4 2 1 2 2 2 3 we're never dropping anything off 3 1 3 2 so it's creating a ere's list all the way through this but the point of the matter is that this is going to be one iteration for the computer system number one let's stick this is take one one element within our list so for the first element it has to do this run and then it has to do this run so it has to do n times n for each element that's in our list but this doesn't matter how big this is doesn't matter if this is one number or one element doesn't matter if it's a million elements infinity elements the point is it's always gonna have to do n times n such that we're gonna our ends squared that's going to result in this that's that's exactly we're getting from we're gonna have a quadratic representation of this on the graph which is we saw from from last week bring that up when we get into quadratic again we can see that our from our as the elements grow very quick let's say you know we're at 0 and then 1 and then 2 is there elements grows or n grows the operations are gonna be in this case exponential that's where n squared it's because we have two loops one less than side the other as we said for list of n items we also perform n operations for every item in the list that means a total will perform of and times and assignments or N squared so if we have three assignments let me show you so if we only have here we have 6 so we should have 36 so if you counted this down 1 2 1 2 whoops you should have 36 so let's keep this a little shorter so it's easier to see so if we have three elements we should have 9 1 2 3 4 5 6 7 8 9 so that's our n times N or N squared whatever our n is going to be N squared in terms of the computational intensive for that particular system how many operations are we actually performing or performing this and operations for n operations in a loop of loops it says you can see how very dangerous this can be for lower very large inputs this is why Big O so important to be aware of when you're creating software hence the input of 3 gives us 9 outputs that's what I just showed above we have 9 outputs for an three calculating scale of bigos so insignificant terms drop out of the Big O notation and this is exactly what we saw yesterday when we did nope here we go in terms of these are called insignificant terms the 45 the 20 the 19 but they're always going to go in a backwards order meaning that the lowest term is gonna be the 19 and then it's gonna be our square that's gonna be our cube in the terms of the constant that stands before them so as you saw just going from a big off one to Big O of 2 or 19 start to become very insignificant and then from a Big O of 2 to 10 not only do our 19 become insignificant but so too did our 20 and our 45 what came significant though was the cubic even our square started to show that it was not it was falling off rather quickly so as the N increased that N squared is going to become smaller and smaller compared to what the cube is going to contribute to the ultimate outcome of your answer so when it comes to the Big O notation we only care about the most significant terms remember is the input grows larger only the fastestgrowing term will matter this is again like taking the limits toward infinity if you're familiar with calculus so that's that's we always want to focus on what is the most significant term and that's what we were heading on here out of this whole function this is the most significant term because as n grows this is going to contribute the largest to the overall answer in proportionate to the other values that would reside within that function so here we're creating a new function to find print once and it's gonna print all the items once so for the values are for Val and let's print about printing list print once and there's gonna call our list what list is this well it's gonna go by our last list that we ran in the Jupiter note books was gonna do list 1 2 & 3 so if you wanted to see that you could also run it it's gonna print the list 1 2 & 3 so we can see how the growth is linear for this particular input so this is just going to be since it's a linear growth it's gonna be Big O to the head and you would say yeah it makes sense right for every value in the list if there's three we're only running this end times event is one and we're going through this once if n is two we're going through it twice if n is three we're going through it three times so it's a linear growth rate for the function that we're dealing with her being in regards to pick out here were defining print three we have our list but now what we're doing is we're printing it three times so for each value that's in our list we're doing it three times for each particular n so for our list it goes through print if I in a list it's going to be one print value list two three one two three one two three it's just printing this three times because again that's that we have three different for loops within our function there so again this is gonna run three times for each of the hens this becomes an order of three times and now notice it's still linear it doesn't automatically becomes n cube that would make any sense because each of these are going to be run in a sequential fashion so it's just gonna be three n but it's still linear the important thing here is this three times infinity is not really different than infinity so we can drop the insignificant constants and that's why this three n you'd be technically correct to say this is a Big O of three to the N as n grows you're our computational test is going to be three times that n however as n becomes infinity 3 becomes inconsequential because it's an insignificant constant so should it be a Big O of n so this is no different than this would be in terms of it's a Big O notation where would you say this it was gonna run faster than this absolutely but we're talking very small lists right now when we get to very very large lists those times this should still always be longer than this but it becomes inconsequential in terms of the difference and here we have a new function we're defining a cop it's gonna have take a list as an argument so now we're doing three different things and you can ignore this right now let's disco dance weirdo so we're printing the list of the first position that's what we're doing first and then we're creating a new variable called the midpoint we're gonna take the length of that list and divided by two and then we're taking a for loop for the values in the list from the beginning to the midpoint print that value and then for X in range 10 so we're going to go to 0 want to do 4 minus X 999 print the number so I'm gonna shift enter through that so it can actually create its part autosaving oh Jesus Chris I never called I'm like why is it white running I never called my actual function that we created so here I have my list I have 1 2 3 4 5 6 7 8 9 10 and then I'm calling the function we just wrote up above and I'm passing through this variable so now we have 1 1 2 3 4 5 and then we have the word number printed 10 times so what is the Big O of this particular function so if we're looking through this again you might recall this from yesterday all we're doing here is taking our list that we have here I'm pulling out the first indexed position that's going to be a constant of 1 always right it's our Big O of 1 that's a constant so we have here this first function is gonna print a Big O of 1 is going to be a constant nothing special there this is just creating a variable midpoint we're taking a length the first dividing by 2 and then we're using that in this piece here so what we're doing is what we're doing is printing the first half of the list so we're from the beginning of the list to the midpoint print those values so if a list of 1 to do so the midpoint you're going to tell me is going to be 5 so go from the beginning because it's 10 divided by 2 is 5 and then go from the beginning of the list to the midpoint it's gonna print 1 through 5 that's what going to do for this point so for this one this is going to be that's we have here it's why doing half the list so it's Big O and divided by two because it over my N is here my n was ten so the big oz n divided by 2 is 5 because we're gonna have an output of five different elements and then for the last one for X and range 10 so we have a constant here right doesn't matter what this is constant orderings printing your numbers this is going to be o to the 10 a Big O of 10 or a Big O constant so what we have here we have a one constant we have oh and over two and then we have Big O town which is also a constant if we were to compare all three of those since we're doing down here we've got 1 plus n over 2 plus 10 what did we say though about constants constants are gonna fall out as the end gets larger and larger and larger as we're scaling up you're gonna see how the number one in the number 10 are gonna quickly mean absolutely nothing to our overall answer for computational intensive on a Big O and even the divided by 2 is going to begin to have no effect either so what we're going to be ending up with is a Big O of n this is also going to become a linear growth rate based on the N because the constants of they do have a mathematical impact early on that impact falls off dramatically as we scale up so another piece that we're going to speak about when we get to Big O is an entire Big O notation in computational intensives and algorithms is worst case versus best case there's no point in really concerned computing a best case other than knowing what your best case could possibly be but we usually it's best to do your Big O notation in a worst case scenario so that's why we usually consider what the worst possible case of an algorithm because then you know what your worst case scenario is gonna be and you're gonna work up from there but an interview setting it's important to keep in mind that there is a worstcase in the bestcase scenario and they can have very completely different Big O times they should have very complete different Big O times so we're gonna do here is we're gonna create a bestcase scenario first off so I'm going to create a function and they call it match or it's gonna take a list and it's gonna take a match so we're having two different arguments so I'm gonna pass through this function and then for item in the list for item if item equals match return true otherwise we're gonna return false from and follow the loop so I'm have a list we already have a list produce I have LST here I'm just gonna run the cell to see what our list is so it gives me the output our list is one through ten all right sweet and then what I'm doing here is I'm calling the function is created matcher and I'm saying for the first argument its list that's what I'm putting through ears list and I'm putting in number one so a match of one so what it's going to do it's going to say for item in list for number one two three four five six seven eight nine ten if item if this equals the match and the match here that was our argument here's match here's my argument if any one of these equals this it's going to return true otherwise return false so it doesn't say it says if any item essentially so we're doing in that list so what do you think we're gonna get for this one here well we're gonna run it we're gonna get true sure enough within this list there is a match for the number one now the reason that this is the best case scenario is because where is the number one that we're trying to match it's in the bits in the index position of zero it's at the very very first of our list so a computer is gonna go sequentially when it's dealing with a list or you know when we gets a different kind of algorithms you can see you know you could say what could split it we can do higher lower and go from there and just break it down half and half and half and half but in this particular example our list what we're matching is very the first element so the list goes is number one yep true that's our bet so that the time to compute that is very very low now in terms of a false we're just going to go to make sure it's working so we have our list we're passing a twenty there is no number twenty within our list so we're going to get a false now this is essentially technically a worst case scenario because in order to find out if this was true or false in order to make this part of the code to determine if we were going to fall down into the true or if we were going to jump out of the loop and return false the computer had to go under had to go number one and then I had to go two three four had to sequentially go down this list to find that there's no number twenty so in the first run match our first one we only had to go through an element of one to find the true and match her list twenty we had to go through ten different elements to find out that it's false so technically this is a worst case scenario because we have to go through our entire data set to find out that there's no match so that's a worst case because again the entire list must be searched and I'll at the an worst case becomes linear this is a big off one the constant because again once I was gonna be in the first net sex position within this particular list lastly we're just going to talk on space complexity so not only do we talk about how obviously the huge time complaints time complexity with Big O notation and functions and algorithms but there's also a space complexity it's also concerned with how much memory space and algorithm uses if you've ever tried to do data work with al AI m LD L on images on image net or in any particular kind of cago piece if you have a crappy GPU it's going to come out and say memory error because you're you're trying to allocate the algorithm is trying to allocate a certain amount of memory to the problem which it does not exist so it's telling you I can't run this crap is you need more memory than what a connection what you have so this notation of space complexity is the same but instead of checking the time of the operations were checking the size and allocation of memory so in this quick example is creating a function called memory and we're putting it N equals 10 so then if we look at the code it says for X and range and AG am was 10 we're gonna print memory so we're gonna print the word the string memory then we call memory 10 I was gonna be our arguments actually take that out because we assigned 10 to our argument and we ran the code so of course very complex code right it's gonna print the word memory 10 times but if you're looking at this loop what we have here is this first piece is a time complexity because if n is 3 then it's gonna run through this three times if n is infinity it's going to run through this infinity times this is a time complexity so this is o to the N because as n grows so to all the time this is a linear growth right here it's only one element it's only one operation to run through to me to make that sufficient now for print memory this is gonna become a space complexity and we have a Big O of 1 for space complexity because memory is a constant meaning that it's not printing it's not creating 10 versions of this it's creating at once and in terms of space complexity so spring are one consonants running at 10 times but the point is this is the lowest computational intensive that we can deal because it doesn't matter if I made this as a hundred and ran it not going to move me through that for you but it's not going to have any kind of effects effect on the Big O in regards to space complexity but will have effective time complexity so we have o to the end for the time complexity which we already came to that conclusion the space complexity and memory doesn't need to store ten versions of memory it only needs to store one string that's going to be the constant so again in terms of you said which one of these is more efficient you would say the constant is more efficient than the time complexity so in this particular code if you were dealing with a larger piece of code and you had time complexities and space complexities and if you had a space complexity if they go to the one at time complexity a Big O to the N if you had to manipulate some aspect of the code or to store something you rather do from a space complexity standpoint because a computational intensive of that from the Big O of a constant is much lower in terms of scalability and in terms of limits then the time complexity of Big O n because this even though it's still linear this is going to grow at a much much faster growth rate in terms of computational intensive than the space complexity of a constant one now again I don't expect all of this to sit within the first time that we're doing this but that's why you have videos you can go back and do this again and again and we're just going to have more and more examples and the whole point of this again was for algorithms for also playing with Jupiter notebook more so for algorithms and then even doing with interviews because it's beginning to ml and DL and AI a lot of those algorithm based and even if you're doing something with an umpire pandas with cycad or risk you learn it's important that you understand what that algorithm is doing just from a complexity standpoint so as you grow and trying to scale things and if you're hitting limits or walls you'll know what those limits are walls are caused from so in Python with our 8 sequences there are three different types of rays you can have a lists array a tuple and a string now these are all different three types of arrays you can see that the list is going to be identified by the brackets tuple parenthesis with a comment between them and then a string is identified in between parentheses with the quotations what makes all three of these unique in terms of Ranieri sequences all three of these can be manipulated by indexing they all support different index and parameters so to quickly understand some of the basic theory before we get into even the question the interview question to understand how arrays work when you understand lowlevel computer architecture so what I have here is a members I assume this is like your RAM or random accessible memory within the computer and each one of these numbers 21 44 21 45 46 etc are like address locations now memory is stored in bits but eight bits is a byte so we go by bytes when we're looking at this data and then there's a memory address for each byte so in this one byte here 2144 it actually has eight bits within it that's how well that's how we're visualizing this now what's interesting about at least with the arrays is that they're stored and retrieved in Big O one it's a constant time so it does not matter if you're at the beginning of a right middle of a right at the end of the rape you're indexing its position anywhere along this memory sequence the the Big O at the time is going to be constant regardless of where you're doing it and against its theoretical but it's also pretty much in practice so the idea is no matter how much you have stored in memory if you're using indexing you can recall it the same at a time regardless of if you're using a list tuple or string and also regardless of its index position so if you have a book that's in all on one string if you're indexing the very beginning of it or the very end of it it's going to be able at the same kind of a recall time because of its memory address location python is represented in unicode characters with 16 bits and again if there's 8 bits in a byte then 16 bits gonna be 2 bytes so in 2146 2147 if we had the string sample it would show me an index of 0 in that string is going to have the element s for sample and it's going to take up 2 bytes within this memory so you guys to address 2146 2147 so if i index 0 or if i index 3 the Python is gonna know exactly where into memory what address to go to actually recall that element that exact that resides within that list tuple or string so we have sample of six characters it's gonna be 12 bytes because again it's 16 bytes for 2 bits 16 bits or 2 bytes are um we haven't a right here of 6 characters 1 2 3 4 5 6 index and 0 to 5 each character is going each card is going to take up a cell so this cell s is actually being composed of two different bytes and then index describes the location of course 0 1 2 3 4 5 is describing our location of our string tuple or list and this is just for knowledge we're gonna be using when we use when did the work that we do is going to be higher level abstraction this is considered low level abstraction the very lowest level you can get into in terms of arrays so quickly talking about lists and references so looking at this image here assuming we create a list and we named it primes and it's storing the prime numbers 2 3 5 we created this list and it's storing it within these index locations here within memory so now you know that index of 0 1 2 3 is actually going to correspond to a physical address within the memory in the computer these are the reference points that it's going to have now assume we create a new list say we have like a you know temp list and we wanted to reference a portion of the list like if you were splicing a list the point is it's not going to create a brand new list all it does is it takes a temporary list that you created here and it just changes the index assignment of that list to reflect where those elements are within memory so down here we have if you want to change it index assignment to a new templates that we did temp index of 2 is 0 1 2 so that's this location here of 13 right now it's pointing to 13 within the previous list of primes all it's doing is referencing Prime's index of 5 which is at 13 it says indexing that temp 2 is indexing at 13 it's just referencing that particular element within stored memory if we want to change it to 15 the original list is not going to change all that's going to happen is right here this right now it's referencing 13 this two will then point over here in reference number 15 it's not going to actually change it's not going to append or amend this list with that exist within primes it's just gonna change its pointer and that takes us to a topic called pointers and in regards to memory and I very crucial at the low level aspect of understanding computer science and how things are stored in memory and recalled and referenced but the important thing here is that the original list is not changed to 3 5 7 11 13 17 19 that's not changed if I change this temp index to 215 it just comes over here and references a different location in memory that's storing the 15 it does not mess with the original list so we have here the take away this new list create a shallow copy meaning you're only changing or creating your pointers you're not duplicating objects in memory and much of what we're doing is manipulating references and calls not the object itself we're just we're manipulating the reference and the calling of the elements not we're not actually changing the physical object that's resides within memory a quick little exercise here or importing sis it's a module within Python creating N equals 10 data is an object that we're creating with just an empty list and then for our I in range and again n is written out 10 so it's going to be 4 1 4 2 4 3 4 5 and it's gonna go through this a it's a variable that we just saying give me the length of the data at that point data again right now is an empty list so at the first point it's going to say 0 B equals Cystic get sizeof get sizeof is a method that resides in the system module and we're saying give me the size of data and then I'm printing on the bottom here we have a string it says length now this it looks like a dictionary right it looks almost like a key value pair that we have here but what this is is this is string formatting and what I'm going to be doing is if you see this and then look at this so what this is saying here is at index 0 of format so dot format index of 0 is going to be a and a is gonna reference this data so it's saying I want you to put life and then I want you to give me the value of a and I want you to only take three integer places that's that's all that's messing with right there and then size and bytes index of one which is going to be the value of B B is generated here and we're saying give me B and take that for integer places now you'll notice you can also do left and right alignment so if we're calling for three integer places and we only have one number you're gonna have two and one a left of it because it's gonna automatically default to right alignment but that's what this dot format method is it's take I'm saying dot format format a into this position zero and format B into this position here when I print my string out so data dot append and again this is just saying with my empty list here appendant with the number n so right now it's empty we're gonna fill it up so I will run the cell even though I already have a ring run down below and I just want quickly go through what this means so a length of zero because the original data is gonna be zero that the length of data starts off as zero Python automatically reserves 64 bytes in memory even though the length of the list has not changed yet and I'm gonna bring this down so we can see this image down here when it goes to length of one the size and bytes does go up to 96 but then with the length of two the size is still 96 three we're still 96 four we're still 96 once we get to five elements within our list now we go up to 128 five python is increasing and then it runs at 128 1 2 3 4 instances before it runs up to 92 what is this doing the point of this is that Python we don't have to we don't have to dictate the size of the array before we create it in Python it's gonna grab a little bit more memory than what its gonna need and it's gonna fill up that memory and when it gets to the point of where it's it's can't fill up anymore it's going to create a new sized array it's gonna copy over the previous array and then it's gonna almost almost double what it's doing depends on your bite size so down here if you have this array that has four elements one two three and four so four if our length of zero one two three we're good but then once we start to get to four five six it's gonna have to jump down to a new size array so that's what we're showing here with B so B is an empty array and it's gonna take the elements of a because B is bigger than a it's gonna take all the elements of a and it's gonna point them to B so here's our elements here's our elements first a is referencing now B is also referencing and then a is gonna become garbage B what was B is going to hold those elements and it has more spaces here now to take on more elements more pending of that particular array and you can see it's just changing assignment to a because this became a garbage array which we get into another time but the point is you could see you could even make this whatever the heck you want and you can just see that it's gonna it's gonna create a new sides and it's gonna hold it as long as it can and then it's going to move that array into a larger array of memory so that it can hold those put but it's not point four point it will hold it for a certain number of time and as the length increases then it will jump to the appropriate size of memory of course until you get a memory error all right guys that's it for today on the arrays sequencing again we have lists tuples and strings they all support indexing that's one of the main takeaways there there we just did some lowlevel pieces of memory called data storing for arrays and just showing you how exactly those things are stored and how we can jump through how Python can increase its memory size of arrays if necessary any of you questions for me are things that you should pretty much kind of sort of have memorized one for the point of recall to memorizing code does have a huge impact in terms of if you have to utilize code later on you could has recalled of course but also you can use parts of code when you're building new new pieces so this is just for dynamic arrays interview questions and we're gonna have a couple of and your questions for a raise as we go through this work so the problem you're given we're given two different strings we want to see if they are anagrams so an anagram is just when two strings or you know two words or a sentence if both of them can be written using exactly the same letters no repeats in terms of you can't have one that has seven a is one that has a days but they don't have the same letters throughout the entire sentence phrase or word all you have to do is rearrange the letters get a different phrase or word so for example public relations is an anagram because I can take all of the letters of public relations and I can create crap built on lies isn't that ironic you know Public Relation crap anyway so without having to increase or decrease in amount of letters the spaces don't matter so it's just about the letters Clint Eastwood those letters can be a rearrange to make Old West action so we want to build the software we want to create a function rather that will take in a string and two strings as arguments and compare them to see are they anagrams we want to ignore spaces and capitalization and that's pretty easy to do so again D space geo is an anagram for God ignoring the capitalization ignoring the space here so we're gonna do two different solutions for this the first one we're gonna do in Jupiter notebooks and the next we're going to do in pycharm so for the first one here we're creating and I'll explain you why we're doing two we're creating the function anagram and we're taking in two arguments s1 and s2 and the first one we want to do is we want to tell Python whatever string we give it for s1 and whatever string would go for s2 first and foremost get rid of the spaces so s 1 equals s 1 dot replace so this is a method that exists within Python we want to replace spaces there's a space here I'll show you I'm going to take it away and back replace spaces with no spaces and lowercase everything and we want to do the same thing for the second string as two equals s to not replace tickle your spaces get rid of your spaces and lowercase everything wonderful that we're doing is we're going to return a boolean for a sorted match sorted essentially putting them you know alphabetical order or numerical order so if they if the letters in 1s one can also be used to make something else in s 2 then they would have the same letters so if they're sorted they should be equal so returns sorted s1 equals sorted s2 it's either gonna be true or false so we run at first we have we're gonna call our function anagram that we made above and taking our two arguments first dog and then God and we run it and sure enough it's gonna tell us true and that is correct same thing for clint eastwood old action I'm gonna run it true and then we get a false here for anagram AABB why they have the same number of letters absolutely 2 & 2 but you can't make BB from a a or viceversa conversely if we made this a capital T it would still give me a true because we are lower casing our letters if I added one more letter I do get a false because now it's saying you can make oldwest action from clint eastwood but now you have au here so we have a letter that's left over that oldwest action did not use so it does not an anagram of that example now we can make a back to an anagram this is not an optimal solution for an interview because you're using a Python module we're using dot replace here and I don't say it's cheating but if your interview was in if it was in Java or JavaScript if it was in a different language SEPA plus you're not going to be using Python modules and so you want to be able to also do this anagram solution we using accounts and dictionaries and that's exactly what we're going to be doing in PyCharm here so I'm gonna run through the code and then we'll actually run it you'll be able to see what it's doing so we're defining anagram to again same two arguments s1 and s2 and we're doing the same thing in the beginning we're taking this one and we're doing s1 dot replace we want to get rid of the spaces and replace it with no spaces and also lowercase everything same thing for s 2 s 2 dot replace get rid of the spaces no spaces lowercase everything then we want to do is we want to check if we have the same number of letters in each of the strings if we have the same number of letters that's a start if we do not have the same number of letters then we know off that that we do not have an anagram so if the length of s 1 does not equal the length of s 2 return false and that's exactly what we want to be able to do because again if it was going to be true if they did not equal each other which true then that means one string has a thirteen no one has 16 it can't be autographs so if they do not equal each other return false then we can keep rolling through so count frequency of each letter count we're just having as an empty dictionary and Lotus our brackets there so we have an empty dictionary for count and now we're saying we're gonna create a for loop for letter in s1 and I'm gonna actually do debug this so it makes more sense for you for a letter in string one for every letter in the first string if letter in count counts gonna start off as zero but if the letter is already in the dictionary then I want you to add a 1 to that count for that so if it's gonna be like a key value so if the first letter and kleenex what is C we're gonna start out with a zero so then I want to make it C equal one else count is this gonna equal one if it's not already within the dictionary that would created here of is it which is empty at this point and then we're gonna do the reverse for the second string the reverse meaning we're going to subtract it so we did here was to change the plus over before to a subtraction now we want to subtract one so we want to count all the letters up and then bring them on back down and then at the end here we're just saying for K and count if count K does not equal zero return false because every letter should equal zero after we count up and then count down and then lastly if all of this is met to do for this function you can see how we're doing our indenting we can return true and then I just have here x equals anagram to Clint Eastwood Old West action you can see I capitalized West at capitalize CM a but we already know from the previous example that these are anagrams and we're gonna print X and see if we get a true or false so what I'm going to do is I'm going to come up here debug it and we're going to run are a debug yes for anagram and I don't care about that console for now so bring this down a little bit all right sweet all right so I'm gonna come to the first line we're gonna f8 through this so again you can see where from line 1 to line 32 because when we're debugging it doesn't go through a function until the function gets called so here in the variable X we're calling the function a degree 2 and we're giving it two arguments s1 and s2 clinics would an old ways action so now we can actually run through our our function and you can see here it put into memory s1 Clint Eastwood it's a memory s2 oldwest action and you can see we maintain the capitalization so far because we didn't do anything with the code f8 so now we can be within the function because we have our arguments s1 equals s1 not replace so it should if you look at if you're looking at s1 watch us one as IFFA through this you're ready set go so you can see that it got rid of the capitalized see the capital e and it got rid of this space and it should do the same thing now for s2 and go oldwest action great so now we have two strings in a both lowercase and no spaces within them now we want to check if we have the same number of letters so let's see what happens we're gonna f8 through this and it jumped from if length is not equal return false and then orden then go down to count so this went through this did not meet the requirements so it jumped down to the next piece because they do equal each other so count equals an empty dictionary so let's FA through that and sure enough in memory it creates an empty dictionary how lovely and now we're gonna go through our actual bring this up a little bit so it's you can see it better now we're gonna go through our actual s1 which was Clint Eastwood no capitals and no spaces so I'm gonna f8 and you can see it gives me Freight off the bat a letter C and we're gonna f8 through here it gave me the letter C so it's an if letter in count which it was not because C was not in count count was empty so letter C was in count nope so it's gonna jump down to else count equals 1 so watch what's gonna happen here to count once ifá through the next line of code for count letter equals 1 BAM now we're creating the dictionary the key C a value of 1 now if I come across anymore sees that see is going to turn into two because it's going to say if letter in count yeah season count letter equals one plus one at that point it would be two so now it's going to go through each letter so first see then we're going to see L so we're gonna f8 through this and sure enough it tells you over here letter is now out if letters in count L is not in count because we can see an account we only have C so then it's gonna jump to the else which is the count letter equals one and we're gonna have an our dictionary up above L and one so I'm just going to go through this i n t a s now we already had a t so when it got to east e AST it did not create a new key value it changed t to number two because now we had two instances drag this over a little bit how do I do I can do pop pop pop but up now it's active better to write you saw fraps give me soft raps Oh didi ah I didn't want to go into s2 yet so it was Clint Eastwood and it didn't do Altos action yet so we got to Clint Eastwood and that's what it did East wood Clint Eastwood pas TW ohohoh is its Y and then D alright and now it just brought in the letter O and that's the beginning of our second string so all we did so far was in this in this for loop in our counter just empty dictionary we now have a filled dictionary with a key value for all the letters in Clint Eastwood now in this second for loop here it's going to do the opposite now it's gonna go through Old West and it's gonna say is there an O if the letter isn't count is o in count well yeah we have two O's and count from before so it's gonna go minus one if it didn't exist then it would do a one so the idea is all of these should be 0 by the time we're done with going through Old West action we can see there's two T's and O blue section we have two T's in Clint Eastwood's so it should go down so I'm just going to again start FA ting through this and you can see up here if you watch up here as i f8f aid through all this you're gonna see all these numbers to go down one by one until they all get to zero and it's not that they're all going through zero that the variable on line 12 is also changing each time we go through the loop now they all came through on zero we went through all the letters and s2 and we can see that they're all zero but that doesn't mean anything here for the code because now it's going to do for K and count k4 see if K count is not equal zero return false so we know that all of our all of our Kaizen count are going to equal zero zero zero zero zero which means it's going to jump out of this loop and return true so it's just going to go through n te a and it's going to go through every letter within our count and you see here in memory X is true FA through it print X and we can see I'll bring it up for you you can see in our console it printed out true so now we know that it is an anagram now I know that seemed a little normally when you're doing this you're not going to be debugged debugging through it but I wanted to only get rid of that so you can see the line better I should change that highlighting I wanted to show you the code and debug through it so you can see again what's happening in memory when we're creating an empty dictionary adding two with the count base of a key value and then deleting from that count so this way no matter what language you were doing this in you could do the same kind of a same kind of a process to check if something was an anagram or not also good exercise with for loops indentation the replace method and lowercase always good practice we have another coating example we're gonna go through and essentially utterly memorize so that we have more tools within our toolbox so today for a rare pair sarey pair some excuse me so we're gonna be dealing with so again for raise you could have lists tuples of dictionaries those are all different arrays we're gonna be utilizing but this is gonna be a rate pair of sums so given an integer array so say we have an array of 1 3 2 2 which you can see down here that we've already defined in pairs some given an array in the teacher array 1 3 2 2 I'll put all the unique pairs the pairs of these of these integers that can sum up to a specific value of K so that can sum up to a specific specific value of 4 so our input we're gonna make a function called pair some we're gonna pass through argument wants is going to be the array and then argument 2 which is going to be the value of K or some kind of specific sum that we want these to see if we have any pairs that add up to so in this case if we ran this if we have our function improperly it should return two different pairs 1 3 and 2 2 because 1 3 else adds up to 4 2 2 adds up to 4 and 1 3 and 2 to our integer pairs that were within the array that we're passing through so let's get coding first off we need to define our function and like I said we're passing through it an array and a value of K that's gonna be our first piece there now before we even get into anything we want to make sure we have some way to troubleshoot this so we don't get errors what if our array only had one value in it 1 integer one element well then that's gonna be a really crappy array and we don't want to go any further so first off the bat we can say if the length of the array that we're gonna be passing is less than 2 well what do we want it to do if it's less than 2 he'll just return let's do a print function and say too small so we know so that's how we can take care of that if the length of the array is gonna be too tiny to begin with now something I want to do because I already know how I'm going to code this we want to have a way almost like counters we want to have a way of counting exactly keeping track of what we see in terms of our array pairs and also outputs of our different array pairs so we're just going to create two different empty variables that are gonna sit in memory and they're gonna get filled as we go through in this case a 4 so we want to go through it we want to use a forloop to go through each of the elements within our array and somehow compare it to our target to see if it's gonna be a match so for each target and number we're gonna get a nut we're gonna get an output and that output might be a good that number target might be a very good match for our number of for our specific value in this case which is K so with that being said let's just run through it'll make sense more sense to as we go through and then as we debug it of course so for the number in the array that we're gonna be going through what we want to do it for each number in the array well I want to compare it to another variable I'm gonna create called target target is going to equal K minus the number that we're gonna be going through in the for loop so for a number in array target equals K minus number so what does this mean if we if I if we go through the beginning of the array it's gonna first go through the number 1 and K is always gonna be 4 in this example so 4 minus the numb for minus 1 is going to be 3 so in this case when the target variables created in memory it's going to fit that with the number 3 when it does that in in memory so what do we want to do with that if that's gonna be the case well if the target is not seen I want to somehow take that that target that I get in this case it's gonna be 4 minus 1 which could be 3 if that target is not seen what do I want to do so if the target that work that we're computing is not in seen and seen as the variable that we have created above we're gonna want to take that scene and add the number to it so again the number is gonna be this portion here we want to add the number that we just computed that target with and this will make sense because we're doing in pairs so this is 4 minus 1 and we're gonna get a target of 3 so we care about the 3 and we care about the 1 because we already know now that that's gonna be a pair that's gonna equal up to our ultimate value of K so now as we're starting to adjudicate this list we're saying alright if it's if the target is not in the scene add it to seeing what else and what are we doing Python way since we want to put an else statement and to say you know if it is in the scene what do I want it to do well if I know that the if the if the number that were utilizing to create the target is already in scene well then I know I have a combination now of target and scene I'm sorry target and number that are going to combine together as a pair to make the value of K why the hell's that mean meaning in this example we'll do 4 and 1 again so 4 minus 1 equals 3 so now going through this next line here if target if 3 is not in scene well scene is empty at this point and the number and the number 1 so then we're should we should get out the number 1 to pop up here but then what's gonna happen is the next time I go through I go through this piece here it's gonna say the next loop it's gonna say for num and array well it's gonna be then 4 and then 3 the reason the next number in there right target equals 4 minus 3 target's now gonna equal 1 if target not in scene well we just know in the last for loop we have a number 1 in here so it is seen so what do I want it to do well so now I have a combination of 1 and 3 I'm sorry this is gonna be 3 at that point so I'm gonna have a 1 in scene and I'm gonna have a 3 in num so what do I want to create that pair that 1 3 pair that's gonna equal 4 so what I'm going to do within our else loop we want to we want to now start to adjudicate our output and this is how we're gonna sever go do so we're gonna take our output or empty variable output and we want to add to it we want to add we want to add the minimum of what well of number or the target so in this say so the first one is 4 minus 1 and it was gonna be 3 and that was and then the next time we had 4 minus 3 is gonna be 1 so we want the minimum of that number target combination so the minimum the second time it runs through when you this will make more sense to go through the minimum when we do this it's going to be this will be 3 and this will be 1 so the minimum between 3 & 1 is 1 so it's gonna it should print a 1 first and then I'm going to then whoopsadaisy then we want to do the maximum of the same thing of that same combination get rid of that another way so now what I wanted to do is say begun again between one and three now can be the maximum of that number see if our cool our parentheses match up yes yes and we're in the add method wonderful so again as we as we go through this in the debugger it'll be a lot cleaner for you and then as we're going through this I want to do one more piece in this for loop which is then we want to give an output right so I'm just gonna put just for the sake of cleanliness have a new line and to that we're gonna join I want to join something this will make sense to you again as we go through the debugger I want to map and the map I want to create a string and I want that list to be from the output that we created which again is going to be this right now is just an empty set but it's I want it to print out that output and that's what we're adjudicating here in this else statement so as I go through so I check my parentheses good good good sweet all right so now in order to make any of this even do anything after we printed out a tuple answer we're gonna see if we have the right answer we're gonna first have to call this function and into place first off so how do we do that well I'm just going to put pass through call our function pass through the the function here pair sum so we're calling the function we created I need a first put an array and we said we were doing what do we say we're doing 1 3 2 & 2 that's our array and then I have to also give it a K value in this case you're doing 4 so let us pop it in and run the debug we're doing pair some says we're gonna run here and I can do a console but we don't even do this right now but it's gonna keep popping up I believe so start off in the beginning that's that fade through there so first off again remember for functions whenever you're running through a function in the debug or even in Python code it's not gonna run the function until you call it so that's why it jumps from line 13 where I started all the way down to line 31 because now it's calling the function pair some and it's checking do you have two arguments otherwise we'd get an argument error it's say you know you're trying to pass two and once three or or vice versa so pair some we're giving two arguments we could see in our function wants two arguments so we're gonna get to the next line so in memory we have an array which is a list and it's one three two two and then we have our K which is equal to four so now we are good we can start to run through the code so if the length of the array is less than two it's not our array has four elements in it if the index is zero to three so that's going to be a false so it's as false it's not gonna finish that loop it's gonna jump out of the loop and go to the next line of executable code which in this case now we're at scene so scene is gonna be a variable it's an empty variable just gonna create set so in memory we're gonna see the variable seen created and it's gonna have an empty set same thing for output nothing special there so we can see in memory what we're creating down the computer now first for loop for the number in the array so for the first number in the array that's number one so it's gonna say give me an uncle's one target equals K minus 9 minus num so that means target is another variable we've created and it's going to equal four minus one which is going to give you three so now it's going to save targets gonna equal three now this is where I want you to pay attention so if the target is not in scene so we can look at seeing right now scene is an empty set up top here if the target is not in the scene will target it's three it's not in scene I want you to add the number and the number right now in memory is 1 so since 3 is not up in here add the number we're gonna have faith through there and sure enough in seen now we have a one and now we can go to the next number in the array because we're still within this loop here so for a number in array so now the number is three in the the next number in the array which is correct now we're gonna have target equals K minus num or four minus three so now our target is gonna change with the memory and sure enough it did now watch what happens here if target not in seen target is one is target not in seen that would be false it isn't soon so we're not gonna add it we don't want to add it 11 again it's not gonna make any sense we already have one within the scene so that means this is gonna be false and it's gonna jump to the next executable line of code so it better go down to line 27 sure enough it does because now we're in our else statement because that if statement was false so it's got to go to the next X could have a line of code we have to keep going until we hit it true so now this is going to be this else statement is simply adjudicating the output set that we have appear at empty set so we're saying an output I want you to add I want you to add the minimum of the number or the target or right now the number is 3 and the target is 1 so the lowest of that the minimum is going to be 1 so the first element here and this tube is going to be 1 and then for the second element and once you give me the maximum that is of the number or the target number is three targets one maximum is three so now this tuple had better print out a 1 and a 3 if we coded properly so I'm gonna f8 through there so now in our output sure enough we have a 1 and a 3 good so within this dictionary now we have a 1 3 2 bowl sweet I like it now we still have more numbers in the array to go through so now we're gonna FA through there and the number is gonna change to 2 so now we're gonna have 4 minus 2 it's gonna equal to now if target not in seen target is it is not in scene so it had better go to the next line 24 and add it and sure enough it does wonderful so now we have 1 comma 2 within the scene the next number that's in our array is the number 2 again so that's going to stay too like all good math targets gonna stay if target not in scene will target is right now and it isn't a scene so this is gonna be false so we have better jump to our else statement and sure enough we do same thing now output right now output has a 1 comma 3 tuple and we want to add to it the minimum of the number target well the minimum for a number target and memory right now is a 2 and the maximum of our number target in memory right now is also 2 so we have better get a 2 to show up in memory and sure enough we get a 2 and we can kind of see our code is working because 1 3 is 4 2 is 4 so this and it should be right I mean it makes sense we're doing the math right here in this for loop so now we run through all the numbers in our array so when I f8 through this for loop here it's gonna leave and sure enough it did it left the for loop why because there were no more numbers in the array we were done next I could executable line of code outside the for loop is this print statement and that's what we have print is equaling 1 in new line and we want to join and by that join I'm gonna map we're gonna create a string of our list of outputs so right now we have two outputs and that new lines just gonna mean that's gonna take 1 3 and on a new line I'll put 2 2 again if I did this properly so I'm gonna f8 through there everything's out of memory and I just want to see if it actually did it right hey there we go awesome so I'm in the console now so this was the let me bring this up and let me go down here so we can see it so this is the printing out at the end and here in the console we print it out I wanted a new line and I wanted to join and then map creating a string of the list so we have a tuple of 1 3 and a tuple of 2 2 and it got those from the output dododododo from the output variable who created right now it's empty memories done because the code is done but you saw the output was growing every time we got through this else statement within the code that output was growing so this is a good opportunity you can look up join method you can look up the map method if you need to play with this change your pair sums get to and add another number and see what happens is you run through your code try to break it and then debug through it and see where it's going wrong and maybe what other tests you might need to put into the code to make it executable I highly recommend memorizing this this aspect of code again as another aspect of the array job interview questions for algorithms for array algorithms not I mean done a race Pacific boat that we're using it for this example this one is primarily just called the largest sum or we're gonna take an array that has positive and negative integers and find the maximum sum of that array so first off we're simply just gonna create will call largest nothing to odd nothing too crazy there we're gonna pass an array through it so first off we want to make sure that the array is even in appropriate length in order to to create a sudden so we're just gonna have if the length of our array equals zero well what do we want it to do we can return to small nothing fancy there so it's putting in a check into the code early on if the array is gonna be if the actual element counts gonna be equal to zero there's no point running this code and we don't want to crash it so we're gonna tell it to print none so first off we're gonna set the first element that was within the first index position within our array we're gonna set it to something that will just we'll name it a variable with max sum and that's going to equal we want another variable and this is going to equal the first element within our right now we're creating two different variables maximum sum and current sum are both equal in the argument I'm sorry the array the first element of the index position 0 the reason that you're gonna see in a second why we want two different Maxim's and current sums as we do the calculations so we're going to create a simple for loop for enum and alright and what we want to do is we want to make sure we can go from we already accounted for the first index position of array 0 in line number 10 so now we want to go from the next index position which an index position of 1 the second number in the array and go all the way to the end so that's just going to be starting at 1 and then the column four going to the end then we can close it off so in our for loop we want to count for each number but again we don't need we don't have to account for the first index position because we already did here in this line so now we can start from the second in this position and go to the end of the array in this counting essentially what we're doing now what we're going to do is we're going to compare the current sum which as you can see is set to the first element in the array of indecision zero we want to we want to compare the current sum to the maximum of a Newsome compared to the number that we have so what does that mean so we're gonna redefine the current sum here we're gonna say current sum is gonna equal the maximum well the maximum of what won't either the current sum oopsadaisy plus that number that we're going to be calculating so this is going to this is do I have what I want to put oh yes but I'm or or the number so if we want to calculus ining what current sum is going to mean let me get this out of the way here just for a second so this is like a current sum tracker if you will this particular line so what we're saying here is we want to redefine the current sum to equal whatever is the maximum is the current sum the maximum plus the number so if it was I would say 2 and then now the number is 3 so is it the maximum 5 or is it the number 5 I'm sorry 3 that's gonna be the maximum whichever is the maximum we want to add that to current some stupid and then that we also want to create compare the maximum sum to that current sum so we're gonna have we have a current sum tracker so now we'll have a max sub tracker so that's is simply going to equal the maximum of the current and we're gonna we're gonna of course debug all through this our current sum or the max sum so you get out of there I don't I don't want those greens in place so we're tracking the current sum which is simply whatever number that we're iterating through in this for loop we're adding it to the previous current sum and then we're or the number we're gonna compare the maximum which is gonna be greater that number or the current sum plus the number and then we're also gonna be tracking the maximum sum which is the maximum of the current sum which we just computed a new current sum or the maximum which we already have starting at our first index position of zero so this is just creating a like we said are running sum essentially a maximum sell largest continuous sum of the numbers largest continuous sum so of course when this is all said and done we need to return something right so let's come out of that for a loop and let's just return max sum that's what we're after so now in order to even call this and run it so we can't bug it we're gonna call our defined function we call it largest and in that largest we're gonna call the function that we are now we're gonna put our brackets to create a list so we're gonna put up I want to start with a naught a 1 so when we debugging it makes sense in terms of the coding negative 52 crazy negative 12 3 21 the negative 19 all right so we have our array that we're gonna pass through so first off let's let me run this do I have largest sum even here yet now somebody's come across here and let me run largest continuous sum and we're gonna get 38 so at least we don't have any errors yep let me get this out of the way so we can see everything one shot whoops excuse me awesome so now we're gonna go to plug this and we're gonna see exactly what's happening within within the code so we're gonna run our debug and this is largest continuum sum all right so of corresponds we're starting our debugger on our defined function but as the FAQ that it's gonna jump right down to the next executable code because we don't execute functions so until they're called so now we're calling it within this print function we're calling the largest function so we have our array so we assumed that in memory which it did its gonna place that array within memory so there we have our array as a class list so first line if the length of array equals zero well that's false so we know it's gonna it's not going to return print too small it's gonna jump out of that client it's gonna jump out of that if loop because we it's greater than zero so that's false so we want to go two lines at only true so next max sum equals current sum equals argument is zero so it's gonna be true so it's going to create in memory it should create the array of it should create Maxima khals current sum equals seven because that's the first element within our array of Indic position zero so we're gonna fade so sure enough we have maximum is seven current sum is 7 so now we have two new variables that exist within computer memory now next line for a number in the array that we created starting at index position one going all the way to the end so and if someone's already counted for in their previous line ten so now we're gonna be starting in this example the array of restarting for number one all the way to the end we're gonna go number by number so first off it puts in memory a number of one so we want to say current sum let's let's this was our current sum tracker so current sum right now is seven so we want to equal the maximum of seven plus one or one well clearly that's going to be seven I'm sorry eight excuse me so you can see up here current sum now change to eight so that was appropriate now we're gonna work with the maxim tracker but it's good the codes gonna take the maximum of you the current sum which right now is eight or the maximum sum which is seven so it's gonna take eight it's gonna redefine Maksim to now be eight so if you see up here fade maximum Sun chart turned to eight so max M is always going to come after current sum because we're taking the maximum of this continuous value so now the next index position of two is actually the number two so we're gonna fade through this so sure enough our number number two changed now we're going to do current sum is going to equal maximum maximum of what well the maximum with the current sum which is eight plus two of ten or two so that's going to turn the current sum to ten and then the maximum is all the maximum of what will the current summer with Maxim well the current sum is ten the max is eight so what's called your trends to ten and they keep doing some way to get a negative one so current sum is the maximum of the current sum plus the number so that's gonna be ten plus a negative 1 or negative 1 well 10 plus negative 1 is gonna be 9 so it's gonna create it to 9 so here we have the maximum something this is why we did that Maxim counter because now look what happens so far into this code we've always seen the current sum being greater than the maximum now we're seeing the opposite of that so now the maximum sum equals but whatever is the maximum the current sum or the maximum well it's currently the maximum sum we want the largest continuous running sum of the array so it's not going to change the maximum to 9 it's going to keep it at 10 as we go through the next number which is now going to be 3 so now we're gonna have fade through that so now the current sum is 12 and Max is 10 so you know what's gonna happen it's going to turn the max to 12 and we're gonna go through this I like the negative numbers because it really brings it home here we got negative 12 let's run through current some calculations and our current sum is 14 because we did 26 plus negative 12 and that was obviously going to be less than the number of negative 12 even though it was going to be 14 so the current son became 14 but the maximum is now looking at what's greater than Maxim with the current sum and clearly it's the maximum sum so it's going to take 26 I'm just going to completely ignore that 14 and it's going to go the next line of code which is gonna be 3 so now as 26 is gonna eventually gonna come up into uh Oh No see that yep so we still 26 because current sum is only 17 we wanted the largest continuous running sum so now we currently is now finally greater than the maximum so now the maximum sum is gonna update so they were going on with Maxima 38 so I'm just gonna finish running through this and I got to run to HP the last one return the max um and it sure did we'd have another consult of 38 so this is not just a simple addition this is we wanted to go through and find the maximum the largest running continuous sum that we could find within the array so nothing too fancy nothing necessarily new here in the code the only thing we've done a little differently than previous as we both started off with both variables being tied to the same input and then being adjudicated later differently depending on the running sums and the the the the some trackers we were using if their current sum or the maximum sum just start to put these into memory so you have your your interview algorithms at call whenever you need them and the largest benefit of all of this is that when you are working on different projects you can always say well I I need to do X and I can pull that from this array or I can pull this from this server how the hell do I go from beginning to end how do I go reverse oh I can take this from this array that I've memorized so that's the importance of memorizing fundamental pieces early on so then you always have them at your disposal yeah the array it's gonna be given a string of words we want to reverse all the words and we want to do this first we can show just using Python builtin methods how we can utilize that but then I'll say I you can code it from by hand from scratch without using builtin function so if you were doing this in a different language you could pretty much do the same thing so if we're starting with a string this is the best how can we finish with the string beste is this and you'll notice we also did preserve the spaces in between the words and we can also insert something else instead of the spaces should we want to utilizing the join method so first off let's just start to call we'll call it reverse and we're gonna pass a string we'll just call it s for this purpose so we're gonna pass a string as the argument through our to our function that we're creating and what if I I could have simply I could just simply say and I'll explain what all this means I'm gonna return and I'm gonna put a dash in here just so you can see what that's gonna make what is gonna make the code do so then you can understand reversed and we're gonna have to split our particular string that we have so let me just explain to you exactly what I have in here we're gonna kind of and remember it so just like in mathematics or PEMDAS parentheses always take priority and we work from the inside out so starting with our first set of parentheses and they're highlighted here in green so s dot split so what is that actually doing so s is our argument that we're putting through a function reverse that we defined and we're splitting it we're applying this split method on it so what does that do I wanted to quickly show exactly I may bring up I think I'll bring this one up for now so let me copy what we have here and I just want to show you something so what if we did and I'm going to show you like a backhanded way in a sense of doing this if I wanted to if I wanted this to make it as simplified as possible so what what I'm essentially doing when we do this to make sure we're tabbing is appropriate I'm saying take the the argument s that and I want you to create that new variety a split so what does that do so all we're doing is we're taking our argument here we're playing the split method me it's going to split that that string up so what if we passed will pass this copy we're essentially going to be calling our method that we have there reverse and I'm putting in that string that I just copied from before this is the best so right now my return is it's calling for the ssplits so we've we've covered that so we could take this part out right and then we have the reversed function here that's being utilized now there is also a reverse in Python that's reverse and there's a reversed and one's gonna be on the string and one's gonna be on an object so all I'm gonna do again to keep with this method of simplicity I'm gonna get rid of all this for just a hot second so we've taken our argument s which is a string we're saying take that string and now here and split it into pieces and then with those pieces we have a new s now which is a split version of that string meaning it's just segment so we have the string this is the best so it's gonna take this and it's going to take this and it's gonna take it down it's gonna take paths it's gonna separate them it's gonna split them up and then I just want you to reverse it I'm gonna put the reverse method the dot reverse method on that string and then I want you to return to me well s right that's what we're doing so I'm calling down this print function here I'm calling the reverse and let's actually run it and then make sure we can debug it to make sure it makes sense to us so beste is this so first off notice it returns a list the letters are not reverse the words are reversed the elements of each of the words are reversed and they're separated here by commas because it is a list so we don't have anything representing the spaces except the space here there's a space here and there's a space here so let's do let me go through this so first off it's gonna create the variable essence but this is the best so it's taking a string that I'm giving that I'm assigning into this function reverse that we just defined I'm gonna have a through it as split so you can see really quick with the S dot split what did was it took that string that we had this is the best and it broken up into it now it's a list C class list this is the best so it just broke it up into four different elements 0 1 2 3 instead of our list and now we're gonna take that new string s or that variable s we want to apply the reverse method to it so fa through that and now you can see up here beste is this and then we're just returning what s is now that's it so that's exactly what we saw down here in the console so we know we're working so what is this is kind of doing all of that with one modification this is doing all of that that one line of code that I'm going to show you next is doing all of this plus one more thing so we have our s we're splitting it we're reversing and I notice this is not reversed this is reversed because that's going to be on an object and then we have the dot join method so the dot join method and then we there's two point two parts excuse me to the join method so this whatever we have in between the quotations here we're telling Python to join the sequence that we're creating in this case via we can make it whatever we want I'll show you how we could do that in two different ways in a second calling the join method is just going to return a sequence that's joined by the separator so we're telling Python here's the separator that I want to use and what I want you to do with that separator I want you to join what you reversed after you split it into a list all right so with that said let's be consistent let's take this and I'll bring you over here so of course this is under assumption traversal so I'm going to run it let's see we got beste is this so we reversed it appropriately we don't have we no longer have spaces now we have our separator is the so to show you let me make it a dollar sign we'll run it again so now best I'll assign the dollar sign is dollar sign this so all I did was with the dot joy mat that we're giving the separator how we want it to be separated and then we wanted to join it and if you want spaces then put it in your separator and now you'll have spaces surrounding the dollar sign and the dot joint method after we reversed it after we split it up into a new list so this is one quick way you could reverse a string utilizing Python builtins another simple way I can think to do it let's I'm actually going to do I'm going to keep this piece doo doo doo doo another way a simple way you could have done it is simply just almost doing well not almost doing actually doing indexing through it so if I'm just gonna I'm gonna go back to return and I want to keep it let's do a star this time let's do a space on it so I wanna call my join method and what I want to do with this join method I'm gonna say we're gonna skip the reverse directly and I just still want to split it alright so we still want to split but now in addition I'm actually gonna call my list and I'm gonna say start in the beginning going all the way to the end and then reverse that burrow so let's run it now send reversal beste is this so I have my string it's split it or rather if we go inside now for parentheses we did split it first and then we reversed it via end using indexing from the beginning to the end then reverse that order and join it up with the star with the space on each side so there's two ways we could quickly do it utilizing Python builtins now for like I said we'll get rid of this will keep our reverse the string and we'll keep our print statement that we're going to use with the actual string element that we're going to do let's do another one one that would be more appropriate for an interview because it's not use it not utilizing Python builtins so first off what we're gonna do we're going to just we care about the length of our string all right so we're just photos we're gonna first call off our length and we're gonna say that's gonna be the length of s alright nothing too crazy there and what I'm gonna do is we're gonna have an index track or I need something to tracked us with and what does that mean when we do this first and then I'll make sense and again yes well we'll debug as we go through this this is gonna be my index tracker that I have here so uh that didn't mean to do that and the reason I have that it's called what I'm gonna say is wile hi is less than the length so what are we saying here I mean we have the length as a variable create up hit the length of the string so we know this string is going to be one two three four five six seven eight nine 10 11 12 13 14 15 16 16 different elements we have to include the spaces because whitespace is included in Python when it counts so we have the length with it's the length of the string and we're saying while I is less than the length the length of the string probably could have gotten where two lengths and wrote the length s here and we already have I is starting at zero because that's gonna be our index counter what do I want to do while the eye is less right now zero is less than the string absolutely what do I want to do with that well we're gonna jump right into an if loop as well and what I'm doing here is I'm saying if string at that position so right now I'm at zero position right because I is equal to zero so I'm saying in the indexed of 0 of my string which is going to be here that the t in this case if the interposition of string is not in spaces meaning we don't have any spaces in place right now right now python is gonna be saying to me what the hell does spaces mean and that's we're gonna come up top here and we're going to tell python what we want to call spaces and space is is simply going to be whoopsadaisy excuse me a space so what I'm doing is I'm putting it as a list because this is all going to be broken down the list and we're index I'm using indexing so if the index is not in spaces meaning it's not a space the element is actually a letter what I want to do if the element is a letter because if we're not in a space here's a space if I'm not in a space that the first one's not going to be in a space you're gonna see we do this when we debug it in memory it's gonna pull that T out if index of zero goes starting at zero not in space as well it's non spaces that's gonna be true so what do I want to do if it's true well I want to create some kind of a another variable worth going to maintain that letter so we're gonna call it word start and will it just make it equal to I so that we know where the word is starting for this index that's all it's doing this is just let me note that a word is starting and it's going to equalize so word start in this case well then equal zero when I do this this first piece so I know that zero is going to have the start of a letter now I still want to stay within this this while and if loop because what I'm gonna say next is while and it can this will make more sense to you well we debug it if if you're not getting yeah while the length and I like I like dupes I like doing some loop within a loop in a sense while I is less than the length and we're gonna see that that's pretty clear at this point and the index at I is not in spaces what I want to do so while I is less than length and we're at that position not in spaces that's toda been true at this potion here right well it's sure and I want to add a 1 to the I until we hit a space that's what I want to be doing so we're just gonna simply do I equals plus equals 1 I plus equals 1 so that's again equals I equals I plus 1 we just want to increase that I counter until we hit a space because I haven't hit a space when I first start this index of the string that we're passing to the definition and well that what I want to do if if I am actually doing that I want to add that letter to another variable that I don't yet have so what I'm gonna do is I'm gonna come up to the top again and we're going to create a new variable just um we'll call it words that's what we're doing right we'll make an empty list so now what I can do is we can say within this while loop outside of the while loop mean if once we get past that know that piece of the code because this is going to be independent of that I want to append I want to take my words empty last list and I want to append it what do I want to pend it with well clearly for my string I want to take words start and that's what we have up here that's going to be our I at that moment so we're just recording that variable word start from the beginning to I and I is going to be adjudicated right up above here so it these two pieces of code here this line 20 and line 23 are going to run both of them will execute with the same eye and then what I just want you to sit in again this will make more sense when we debug it we're adding the word that we collected or the letter that we collected in that while loop into a space so if we collect at a letter in here so while little is a non spaces so this would have been so far as we run through this we've so far we have the letter T so if if index of zero of the S is non space that's true its T word start equals I word start is down below here so equals I so that's the equaling zero at that moment which is actually going to be the S word start we're calling the index here of zero to the I which is going to be then at that point one and that's going to give me the letter T so I'm taking the letter T and I'm going to pend that into words and that's going to be up in here so what else do we need to do well number of things one we have to then add that and that's what we're going to do right now let me go into the if loop here so why am i doing that because if I'm going to get a space Y lies less in length if s is not in spaces if this becomes a false meaning I have a space BAM I want to come down and I want to increase my I so I can go to the next element that's within my string ergo the argument that I'm passing through the function that we are defining and when all is said and done what do we need to do we need to return something so let's and I want this lined up with my while so I'm going to return what are we returning I'm gonna put a space there because I just want to put a space in between my join method that we're going to be using so it's a little cleaner and what we reversed because we collected our word list our words variable here is going to contain the breakdown of this is the best this is a lot of work just to break this down so that it's in a complete same thing this is the best and you're going to see that and then at the end here we're going to call the reversed on an object and we have our object is s that's what I call to correct yes s so that's all we did there so nothing crazy so let us debug well first off let me run it so this is sentence reversal so now we have this is the best and if I didn't want those spaces and the letters we can do that but you'll notice here not only did we reverse the letters River I'm sorry the words we reverse the letters as well so let's debug and go through this and see what's what I want to see if I can open it up so we can get everything yeah it's gonna be enough let's go like that so we can see the whole shebang all right run I want to debug this and this is sent a traversal all right we're gonna see everything on the screen all right let's go I fade through it so like all code it's gonna not gonna do the function I'm gonna go down to our print statement works we're calling the function we define and putting in the string this is the best now first thing the length length of s it's gonna give me a 16 and again if you count the letters you have to also count the spaces and then we have spaces this is empty list nothing special to it with this with a space in between words is also going to be an empty list and then we have I equals 0 so it's gonna create I equals 0 so Y is less than the length old length we could see is 16 up top here and the length the I right now is 0 so that's true so we go to the next line within the loop if si not in spaces so I is 0 index of 0 is T it's not in spaces because spaces is an empty space so that's true so it's gonna go the next part of the loop word start equals eyes so now it's going to create a new variable in memory called word start it's going to equal I and this point I is 0 next line while I or 0 is less than 16 in this case which is true and remember and loop both have to be true NS I which is 0 which is T not in space is true so true and true then it absolutely will execute this next line in here I equals I plus one so now I is going to go from zero which will start out now to one and then we're gonna go to the two ah I messed up my spacing did I no thought I messed up my space in there for out second so let me I want to start that over for you guys no I don't want to do that I wanted to bug let's get it in there let's get it in place I want to show you exactly where I went ahead of myself so let me go to where we got so Y is less than length and si not in spaces I equals I plus one so we did that we got the one and we can see that we have nothing in place yet now while I equals less than two so it's still doing work start still zero while I is less than like NS is not in spaces we want to keep adding to the I so what you're gonna notice here is what you don't see it happening in memory except for the updating of the I we're going through this first word here because we haven't gotten two spaces once we get a false here it's going to stay in this loop here this while loop but once we get a false then we're gonna jump down below and we're gonna append so right now in memory we have an index of zero and one which is T and H so we're gonna have faith through there now we have an index of three here so 0 1 2 3 so sf8 now we're at index of 4 acid an index of 4 is a space 0 1 2 3 4 so now i is a space so while I is less than length well that's true 4 is less than 16 and the index of that position for not in spaces will not in space as a space that's a false so it should jump me out of the suit and put me into words down below there we go so now what's gonna happen we're in words that append words was an empty list you can see it here in memory and empty list words dot append we're appending from our string s words start words start 0 to RI or what is my IRA now for so it's going to take index of 0 T 2 4 1 0 1 2 3 4 so when I FA through this it should pop the word at this there goes this into the words empty list because we rant we hit a space so that jumped out that first word so I equals now we still want to increase our I 1 more to get out of that space because though is gonna be stuck in number 4 so now I equals 5 so now what's in 5 it's the letter I so I'm gonna go through words start is now gonna be 5 it's gonna equal I that's fine 5 is less than 16 5 is less than 16 that's what we have here well 5 is less than 16 and the index position s 5 is not in spaces well we know in Nick's position 5 in the S is I so that's true so what's gonna f 8 so we're gonna go to 6 for the I and that should be the same true here for success 6 is good now 7 is a space so it should jump me out of this while loop again and go down and append the word is to my word list the empty list that I had here same thing now now it's just gonna be for the we increased our I to 8 so that we can get to the T in the word the so 8 is T 9 is H 10 is e 11 s a space word append this is the you can see now in the words variable we now we have the the and again we're gonna go F 8 again same thing while eyes lesson length is 12 absolutely is not in spaces nope nope word starts going to be on 12 which is excellent that's going to be the B and the word best so we're gonna be going 13 14 15 so we get to 16 so now there's no space after this so it's not gonna jump me um out of the loop because of the spaces while I is less than length look what happens now when I get before execute this code we have a next video we're just sitting on it I is 16 length is 16 this now loop becomes false it's why I loop now becomes a false so we're gonna skip this and we're gonna go down to words append so now when I execute this words append now we'll get the word best up in our variable top here and there we go we got best I equals plus one it'll execute it now it's 17 while I is less than leg 17 is greater than 16 this whole loop now becomes a false I'm not going to get past this first line so I got to jump down into my return and what am I saying here return with no spaces join these because you'll see we have spaces already in our words list join no space join this reversed s the string will print it out and I can go to my console where did my console go that was rude and we're printing out letter for letter of exactly how we how we did that and you'll notice the difference we got the letters this time and not the words from before is we reversing the entire string and if you recall in memory that the string was not it wasn't split into its constituents whereas in the code we did before we were calling the split function to break up those pieces if we utilize the split function in this we would have gotten the same outcome in regards to the words going backwards so just really quick another way I want to show without even having to use the join method if I did reverse this let me just quickly say this is the one that I would memorize I mean the other ones you got the functions you got the the builtin functions in Python and that's cool but this is the one that I would pretty much memorize and work with not only is it I utilize another language as long as you have loops of course but it makes the most sense in terms of going element by element creating taking that string as an argument and breaking it down element by element and creating counts and indexing counts and then building and rebuilding that list and then doing what you want to do with it and having a number of different loops within loops and different conditional statements where we using the end a boolean end statement to get a true and a true otherwise we're going to jump down to the pen so this is this is a really good exercise but I just want to show one more semi piece if I simply just had do to do to do we could return and if I return ass because that's what you can't see it now but let me get rid of this I'm sorry that's what we're calling so if I took my ass and I split it just like I showed and then we simply could ask Oh beginning to back I gotta go to test now because that's where I am I want to quickly show that what you could do is not only you sit there and say we didn't reverse anything the point I wanted to make with this was inside the pit print function since now this is a string that I have I can call the reverse instead of not reverse for the D but just reverse on it so I can run it and then I'm gonna get my split on the list grant M ILO so it's actually going to take my string it's going to reverse it I'm just gonna reverse a string that it returns after it goes to this reverse function that we have I should probably call this something else so it's not confusing let's just call it Rev so I'm calling my function that we have hello I am grant so the functions gonna take that string hello I am grant it's gonna split it so we're going to have one list with each of the elements and its own forward and then we just did beginning to end minus one so I think I showed you guys that one earlier on I just I really like this one personally because I like the idea of the indexing because when we get into data science and machine learning we really utilize a lot of this indexing when we're messing with data bases and so forth two arrays were swimming no duplicates within those arrays is one array a rotation of another if it is we're going to return true or false so they have to be the same size and the elements same size and elements but they're going to start at a different index location this is gonna be a big goal of man it's gonna be linear now we're gonna go through each array two times but it's Oh times two and again the two is not going to count because constants are going to be nothing as you get infinite infinitely large we want to select an index position in list one get its value and we're going to find the same element and list two and see where it is in that index and then from there we're gonna go index position index position because again they should be in the same same size same elements and starting the same it says start index in different locations so as if if I get to index position 0 of list 1 is the number two and number two is index position 4 and list 2 then when I go to in x position 5 in list 2 and 1 in list 1 it should be the same next number so have fun with that let's run forward so we're just going to call it rotation and just like I said we're passing one list and two lists those are gonna be our arguments for the for the for the defined function and then we're going to do a quick edge check here if they're not the same length then they're certainly cannot be a rotation of each other right so simply if the length of list 1 we do want to close that off does not equal the length of list 2 so what we're doing here again is saying if it doesn't equal to list 2 then what we want to do if the lengths are different and even rotation the lengths have to be exactly the same the elements have to be the same just a different index location well we just simply want to return false so we have an edge check in place now we want to do is you want to in memory you want to create the first element of list 1 we want to store that into into memory so we're just going to simply say that we're gonna call it the K and that's going to be a 1 and how do we call the position just 0 ok that's okay it's a list so we can just index to it in X position 0 so we have our first variable and the second one we're going to call heat index we're going to create a counter and we're going to initialize it to zero now this is going to be what we're going to be counting as we're looking through the second list to see what the net number what that value is in that index position should nobody want to iterate through lists to trying to find this key starting at index zero because remember when I pass the list 1 I'm already gonna have in memory key the first element of list 1 so now I want to pass through lists to and say hey we're in your list or what an index position do you have this value whatever this value is here so I wanted to do that point to do our good old for loops also for eye and we're simply gonna do the length of list 2 so now we can iterate through list here trying to find this case that what we want to do is you have our for loop for I and range or doing the range because of course we want to go for the full length of the list and we're doing index positioning so we wanted to start at 0 because length of the list which is count the elements so if list too because we're doing two right and we want to see if the index position of two so if the index position that I is currently at an index number two if it equals the key well what I want to do so if list two has the same value that we've sorted in the key well I want to create an increase and a key index I want to change the the key key counter I wanted to make that index sorry so what this is going to mean is that as we go through this let's say I is at two so for two in range because there will be more than two numbers if list I at if the element that's at position number two and let's say it's five equals the key let's say the first element list of almost five so let's say they equal each other and I want the key index to now be five but what the key index I'm sorry too cuz I was gonna be to want the key index to be so then what that would tell me is is that for list 1 this element the element of this location the value of this location equals the value at list to index location at index of whatever was at that point of index of index of 2 and yes we're going to debug this of course as we go as we go through now once we have that piece in place next thing I'm gonna want to do is I'm going to want to break out of this code so but because I want to force it to the next line so once I once I find the index in list that is equatable to the appropriate index of list 1 I then want to break out of the code we only need to do this we don't have to do this once and we won't this is because we want to jump out of the loop that's how what let's how you're forced to jump out of the loop so now we're gonna say if our key index equals 0 which we don't want it to write this would be true if we didn't find the key endless so that's the only time that this would be true is again if we did not find the key in list so we're gonna return false because it means that we're we don't we can't even do a rotation because it doesn't have it's missing one of the key values this is missing the same value so now we're just going to now we want to go through list 1 and we're going to iterate through the list 1 but we want to iterate through we're gonna iterate through list 1 I mean want to iterate through this one until we find that element of list that matches so again this will make more sense as well primarily as we'd be bucket of course that's the best way to learn anything so we're just going to do the right range of length of list 1 I'm too far and again this will make more sense so if if list 1 index 0 equals the value of 1 and we find a one and list two it index 4 than the canned X at that point it's going to be for this appear is going to be 4 so the value of index position 0 list 1 it might be 4 but the key the 4 in list 2 is not showing up until index position 4 so this again this will make more sense when we when we debug everything so now what I want to do is I want to create another variable we're gonna name it T and what I want to do is this is just going to create the as you know we'll call it the new index for list 2 so we'll say L to index that's what we're gonna call this one now what we're gonna take is we're gonna save our key index and we're gonna add it to X and this would be good exercise for modulus as well we want to take a modulo length of list 1 and this is going to become the index now for list 2 what we're doing is we're gonna reassign the index for list 2 and this is where you're gonna see the comparison so f list 1 position of X alright so if the index position X does not equal plus two and this is where we're going to change its index l2 index so we're getting the value we're getting the value that we've created here and we're checking that index of what we're saying is if if the list 1 if the value at that index position does not match the value at this index position then of course our good oldfashioned we want to return rerun Jesus Christmas we'll want to return false all right but otherwise we want to return true if this first line of code here is going to hold is going to hold right so why do I have oh we got a call in that loop right I wanted to break inside that loop okay what I was looking at just now is why I had I had a read up here telling me if there was an error and my break was on the outside of the loop but I want this break to be inside this loop so that once I actually do satisfy this I want to break out of it break out at that for loop and jump into the next if loop and it's all so let's actually run this through and let's see if it works and then we can debug it so we're gonna call we're gonna call our function my goodness I can't do this so early in the morning we're gonna call our function that we created now we can we're passing to list so we're gonna do brackets so we'll put this one in order and I guess we'll go up to 7 and we'll do a comma we're gonna do another list now this next list has it has the same seven elements right but and the the order has to be the same but the starting point the indexing point will be different so we'll do it as seven and then we went to one two three so that's one two three four five six seven so we have this is a rotation so this should return a true but like I said we're going to go into bug it and then we'll go through that so I'm already in a red rotation I'm gonna run it through and we get a false and we shouldn't I just said we should get a true didn't I so why is statistically something almost same order so let's go through the color my getting the wrong answer then I think they they will return so it's quite a jump it at us it's gonna go here we'll create those two variables for high and range so this would be starting at zero if this equals key key index one can tax I break if this is a false I watch this huh let me try it now true yep so I was breaking out of this loop too early my mistake so now we got it true so now we can actually debug this I'm going to hit their array of rotation let's load our piece into memory alright actually we'll keep it on the debug for now I'm just gonna bring this down a little bit so we have our two pieces in memory we have our list one in our list two and their proper values and you guys don't need all of that so we can just do this see a little bit more if length of this one does not equal length to return false it does equal the same length so it's going to jump down to the next aspect of code which is we're gonna create a key list 1 index 0 and memory and that's actually gave us the values so if we look at list 1 the first index position value is 1 that's why it's a one key index equals 0 that's just the variable key index where you going 0 now for I in range this is the length of list 2 so it's going to iterate through list 2 so the first hit the eye is going to be 0 because that's what we're starting if list 2 eyes so if the index position I so if I look at list to the first indexed value is gonna be number 4 in index position 0 if it equals the key you already know the key equals 1 then we can then we'll jump down a mobile break and we'll go down otherwise the key index is going to equal I so let's watch this go through so if Liz to I equals key it did not equal key because 4 does not equal 1 right now the key is 1 and and the first element this index position unless too was a for some we're going to go check it again now it's going to change up to index position 1 well list to an acquisition 1 is a 5 and we're looking for one so we're gonna have Fate it's going to go through it again and now it's gonna change to I equals 2 key and still 1 because that's what we created and in a position to is a 6 so it's not gonna be satisfied it's gonna be false and now it's 3 and if it's in 3 is a 7 it's still not a ones we're gonna have faith through that now it's a 4 0 1 2 3 4 and now at index position for of list to the number 1 equals the key index of 1 and list 1 so now that they match it should take us out of this loop it should go to key index equals I so it should change the in Dixon out of four good which it did appropriately ups up here now the key index is for now we can break out of this loop because we're done finding the matching sequence if key index equals zero so key index it started zero but we've changed it this is what it is in memory now it's four this is almost like it to another kind of another edge check if you will and we're simply gonna kind of skip over that because that's going to be false because it's not a index is now for now what we're gonna do is we're gonna this is what we're gonna go over at least one changing the index of list to constantly upping it by one to see where it is that we're going to be within that list and I'm gonna when I'm done with this I'm gonna do a little lesson on modulo because it may not make sense to some people so for X and ranged length of list so X is going to be zero because we're starting at position zero when it for the range l2 index equals four so how do we get that well the key index right now is 4 plus X X is 0 4 plus 0 is 4 for module the length of list 1 is 7 so we can go 1 2 3 4 5 6 7 so for module 7 is 4 if you don't understand that I'll do a quick video showing how that comes about in just a moment if list 1 X does not equal the list of l2 index and right now it does not the index position of 0 is 1 and the list 2 and at position of 4 0 1 2 3 4 is 1 and 1 so it does so if they don't match return false but they do match so now it's going to go to the next one X is going to be 1l indexes of an a have to go up to 5 so now it's checking the the values at index position 1 which is 2 and list 2 index position which is now this a 5 which is a 2 so you see how it's going element 4 element now so I'm just going to go through that that matches so it's going to go to 2 and 6 so now we're at 3 and 3 and they actually do equal each other so this is going to be false so it's going to jump back into loop now we're at 3 & 6 so we're at 4 0 1 2 3 so when I went 4 for X and a position of 6 so 0 1 2 3 4 5 6 and we're going to be matching up the the we didn't even do it it's not for insects it's got to be three and seven yeah I didn't I didn't go through it yet so it goes to an index of zero because again zero to six is one to seven but we're doing a range so now we're matching up through index position three of list 1 and X position 0 list 2 so 0 1 2 3 so that's 4 & 4 so which is it to jump into the list so it's going to do this until we extinguish the range of the list and that should be it for the range because when I get up to 6 so once we jump out of the range and we're going to return true because we've we found that these al these two lists they have the same length they are composed of the same elements and the elements are in the same order the only difference being the starting index position so and of course if we have a do that then in the consoles is going to show us the true that we have so if people didn't get this the module before if you're sitting there saying how the heck and for module 7 equal 4 it doesn't make sense some people maybe even thought on might even three or whatnot let me quickly just show why that is what it is so I'm just gonna quickly open up this program here when they throw on the tablet and move this so it's most people you can actually even make this closer to 3 that's excellent do a nice bright green for this so if I did 12 modulo 5 most people are going to tell me why no 5 can go into the 12 it's it's the way that we wait you is supposed to be doing this is 5 times 0 5 times 1 5 times 2 5 times 3 and we're gonna get 0 5 10 15 and you see that it fits in here so it's going to be we have we have a 2 in that spot so then and then how do we get to this level if you're a 10 well it's 12 minus 10 it's going to equal 2 so that's why it's equaling so with that being said what we had we had four and seven that this is where it gets different because four and seven where we're used to the bigger number being first but now with four modulo 7 what we're saying is for four goes into seven four zero times so four times zero so so how many times does four go into seven well 7 times zero is zero seven times one equals seven so we can't use we have we have to use the zero this is my point because seven is already larger than four so for taking that zero 4 minus 0 equals 4 so that's my form modulo that is for module seven is going to be four if we go to five let me do this I'll keep it if we went to five modulo 7 and say what is that equal to well again we're at 7 times zero is zero seven times one is seven so we're still in this middle point here so we have to select 0 5 minus 0 is 5 so 5 modules 7 to be 5 we get to 6 so it'll be the same thing when you get to 7 and this will make more sense to you now oh my goodness so 7 modulo 7 everyone knows is going to be 0 we have no remainder left over but why well 7 times 0 is 0 7 times 1 is 7 so we can select this and then we're doing 7 minus 7 equals 0 and that's how we're getting that number so modulo czar always easy whenever we're whenever it's you know it's somebody who's gonna be doing that who is gonna be doing the remainder when the top number when your numerators larger than the denominator it's fairly simple to do but it becomes as people got confused when the numerator becomes smaller than the denominator so you have to actually understand how you're how you're doing the math so and that's exactly why in in our example if I'm gonna do this that's why in our example that was pretty cool for modulo 7 and because this was at that point 4 plus 0 and so this was our our key index value plus the X at that moment and it was modulo of the length of list 1 and this was seven because we had seven elements within the list one so for modulo 7 again was going to that's why I was going to equal 4 because we were going to end up getting 4 minus 0 so I just wanted to quickly explain that because I could see people coming up with a question saying how the heck did you get that we want to return the common elements as an array between two sorted arrays of integers hey sending reduce things not going to matter I'm an example the common elements let me just quickly do this I'm still on softwraps it's ending in the order entered a standing order example the common elements between 1 3 4 6 7 9 and 1 2 4 5 7 5 9 and 10 are 1 4 & 9 so if we want to just take to a different race and tell me which two elements are the same between them so let's first off name it up but what are we going to take through this we're going to take like I said 2 different arrays so we'll just name them a and B for this argument so now we want to create pointers that are going to point each index and compare the values so we want to have a pointer that's going to you know point look at this index 0 and index 0 and X 1 and X 1 we want to find the common elements that are going to exist between so we're going to use pointers first off to then append into a list so I'm just going to create pointer 1 and what do we think we're going to do we're going to set that counter to 0 all right so this is pointing at index is 0 for a fro it's gonna be for a essentially and that's how we're going to tie it together and pointer to what do you think is going to be at da right the same for big nothing special there so recording two different pointers we're going to tie those two a and B later to dictate a index position and like I said I do want to have an empty list cuz we're going to be appending this let's just keep it proper context so we're gonna do a while loop we want to go through the length of the list essentially and check the corresponding index position to know if the index value is the same and we want to add that element to the result if it's not the same that's how we're gonna get the the end product so while p1 which was the end of which is one of the variables we created while p1 is less length and length of a that's what we're comparing it to and I love using an ellipse p2 is less than what do you think the length of B so while and it's a bit both of these conditions that the point I want to make is both of these conditions have to be true in order to get to the next line of code so if while we're going through the loop if a so what does this say so while we're going to the loop if the index location of a is what equal to the index location of being so if the value at that next location is the same if the index value is the same then we want to add the element to the result so how do we add an element to the result well the results up here is the variable that we created which is an empty list so we're just going to good oldfashioned result append and what are we appending we want to append the value at that point whatever p1 is going to equal for that index location of a since since they're equal it does not matter which one you're gonna add from this could have been be p2 it doesn't matter the point is if because it's there the same if you're appending your empty list result we're only doing so when these two equal so whether you did a p1 or b p2 it's the same value that's that's all that's that's that's gonna mean and now what do we do whenever we want to move to the next index location we're gonna have to simply change our count right so now we can actually move through the iteration appropriately now we want to do we have to cover for other ups look at that I forgot a call we have to now account for other instances so what if P 1 because we have if they're equal to each other what if it's a greater than what if it's greater or if the values give if the index at a element is larger than the one that's at the B element we want to move point we want to move our pointer in bei only so how are we gonna move our pointer nothing crazy where it's gonna say P to cuz again that was our pointer we want to move it up by one we're only moving the pointer in point B since the a element is larger all right that's gonna cover if that's the case but we need one more condition right we're gonna use an else the only other possibility is that the value at ap one is smaller than the value of B p2 so all we're gonna do in that case is increment P one we're gonna increment our pointer RP one pointer so that it can then still stay within this while loop because that's what we're doing and what do we want to return at the end of all of this we want to return our result that we have here to see what it's actually going to put within that list so let's actually run this bad boy and see how we're doing common elements and oopsadaisy look at that otherwise we can see what are we passing through or passing through two arrays right so let's do 1 3 4 6 7 9 then we have to do a second or right because we're taking 2 so we'll do 1 2 4 5 9 and that will say 10 so we have 1 2 3 4 5 6 1 2 3 4 5 6 we have 6 minutes they don't have to be the same dodododododo all right so let's run this bad boy common elements yep so it comes out it tells me you can see that 149 let's quickly look before we start to debug it make sure we're good so let's check Athena positions are correct we're checking common elements so they both have a 1 that's true they both do not have a 3 they both have a 4 they both have a 9 so 1 4 9 excellent so again but this was the common elements of A to B so you'll notice it didn't put a 10 where you would think you know I didn't but it's not a common element so it is checking good to be against the a as well so let's debug this let me hop up here let's run our debug bring this down just for we have a little more space so it's going to put into memory are a and B arrays that we have so this is just our two variables p1 and p2 is just gonna put those in memory we have encounter at 0 nothing special there the results the same thing results with a variable to an empty list now we're gonna do our first of all P is less than the length of a call the length of a as well as at 6 1 2 3 4 5 6 it is to the right now P I p1 and p2 are both 0 so it's definitely less than like they and p2 is also less than like BAE so what's gonna run through though that while loop and it says if a p1 equals b p2 result append a with p1 so they did 1 & 1 are the same index position so p1 was 0 the index position pichação is B 0 a 0 well a 0 is 1 and B 0 is 1 so they add each other so we're appending our results up here we're adding that value which is appending with the value of a2 p1 it could have been B it doesn't make a difference again because they're equal to each other but now we want to move our counter from Indic resistance 0 to end of position one and same thank you both lists so our peas are gonna change now we're going to go through our list again and do they equal well now we have a three and a two they do not equal so it's going to go to our elseif it's the a is the value larger it is larger because in a it's three and then B it's two so what is it gonna do we're gonna go down to our else P we're gonna we have to increase our iterator so now we're running for the loop yet again now we're finding our we edit it ended for it appended for trying to see if we can see a list better because now an index position too we have a for an index position too we have a four involve list so they are equal to each other so we're going to increase the iteration of both our pointers we're gonna go through our list again and we're gonna find that it is not the next position is not sure now we're at a pi/3 and a p2 of four for our positioning so three and then four is because they're not going to equal each other so we're increasing our counters now to now match each other now they're back to four and four because we went through our else loop you're gonna see that third part of the loop come into play when we get to the number ten going through the same thing five four results they did equal they both equal nine position one was that five so that's zero one two three four five we had a nine and that's position for zero one two three four and B two so it did they did match up they were equal so it is going to append it now we're at six and six that's going to be a nine of ten so it's gonna return the result because we're outside of our while loop we no longer have our piece and if I bring our console up we have one for nine so took us out of the loop simply because when we got to the PS the piston is six we have one tooth will zero one two three four five so when the p1 and p2 the pointers became six that's outside of a range it's outside the array it's it's not permissible so it's going to take us completely out of the loop and then hit to the return the next executable code which is the return result all right this is a pretty simple exercise guys run through a play with it see what else you want to do change up the numbers mirror this is all about finding the common elements so do it with different sequence of numbers and do it in different orders and you'll see different aspects of the code as you debug it so the question write a function that's going to take three arguments three and in those three arguments one of them one of the arguments can be multiples but at least three first one of the arguments gonna be bombs what we have here we're gonna list the bomb locations this will be very similar to those who know the game minesweeper we're gonna take rows and columns so this is what it's going to look like minesweeper here we have to bomb locations this is going to be a row and a column row in a column is that that and then we have our matrix if you will a 3 by 4 matrix so we have our two bomb locations and our three by four matrix now the bomb at row index 0 first bomb this one this one give you its own location it's a 0 0 so row 0 column 0 bomb at row index 0 column index 1 is the second bomb that's right here three rows three columns that's what this translates to and just so we can you know me I'm a visual guy let me just bring out the tablet real quick to give you an idea of what it is we're talking about so we just had zero our first bomb was zero zero and our second bomb is zero one so if we have this I'll do that and this is where our other parameters came in so we had our bomb locations right so that it's gonna be those two arrays and then we had 3 by 4 so that's rows columns shell that means that we are rocking out in terms of the this is going to be the columns so we're 0 1 2 3 and we also correspondingly have our rows 0 1 2 so we can see we're indexing so we have 1 2 3 rows and we have 4 columns now just like we did with some of our other previous Python exercises we're creating a matrix if we're creating like a grid I want you to think of so the first bomb location and we're gonna identify bombs by negative 1 when we're doing this code that's how we're numerically gonna modify them so 0 0 is row 0 column 0 so there's gonna be a bomb and row 0 column 1 there's gonna be another bomb so those are our two bomb locations you can change my however you want you know maybe for this exercise we'll do let's do this instead so then when we're doing part of our loop it will make more sense to you so I'm actually going to adjudicate this and instead we're gonna make our second bomb it's row 1 column 2 that's going to be our second bomb location so we're gonna have a bomb and a bomb and then we also have to numerically represent these other spaces here all right they're either gonna be a numerical value that's going to represent that it has a bomb how many bombs at us how many cells away so example this one has one bomb one cell away it has nothing else here if I had a matrix if I had a 3 by 3 1 2 3 4 5 6 7 3 by 3 & 9 square matrix and if I'm here in this cell here this number one I only have one bomb one cell away over here I would have I have two bombs at this moment I have this guy he because I'm looking at this 3 by 3 matrix if you will to see adjacent cells so I got a bomb here and I got a bomb here so this would be a number two so this will be actually be fun to do so I'm actually going to change that to 1 comma 2 when we get back into the code so like I said we're going to come back in and I said we're going to do Row 1 column 2 for this example this is actually we're gonna run through our our example so this would not be accurate then that's gonna end up being here whoops that will not be accurate so we're actually gonna take this out for now so we're still going to return to 3 by 4 array that's appropriate because we that's how we defined it here so this make a little more space and let's start this bad boy I'm gonna move the tablet for now but we will be coming back to it momentarily because there's some good examples that we can utilize it for them so first we're going to write out exactly how we defined our function and I said we're taking 3 arguments right so we're gonna be taking bombs that's gonna be our are that the first augment that were putting through then we're also calling and our number of rows and we're calling in you guessed it number of columns I'm gonna close off that function so we have at least three arguments but in the bomb argument we can have more than one row column combination so first we want to create a proportionately sized array filled with just zeros so we know we have in our example we want a three by four array and we want to be filled with zeros first off so we're just gonna call it field that's gonna be our variable that we're gonna create and it's gonna be a list so and we're gonna do 0 because that's what we want to fill it in for for I hope so Daisy 0 for I in what and range of one of the arguments that we have our number of columns right and then for those we want to put a zero for every I number college right now columns is four so we want to have zero zero and all the columns but then we also have to do that accordingly for it's only one bracket at that point for what for J in range realize what we're gonna do now here number of rows we have to have this set number the rows otherwise we're not going to be able to do more than one row just do the four columns that won't stop at that point so this is just saying we're putting a zero we're taking the range of the number of columns and we know we already know we're gonna have four four number of columns when I take that range of zero one two three and we want to put a zero in any of those categories and then for J and range a number of rows number of rows is three so that's going to be zero one two we also want to put a zero in so we're just doing this is a two different for loops and one line of code if you want to see what that's gonna look like we could even just and for argument's sake we're going to get this guy already ready so we're gonna have minesweeper we have our function I forgotten a mistake and then within that function we're putting in a list and then the first we're doing a list of list in the beginning so I said we were gonna do a zero zero for our first bomb correct and then in our second bomb we are doing one comma two for row column closing off that closing off the first argument comma and we said we want a 3 by 4 matrix all right so let's run this and see what we get so now perfect so we have this is our it's not as a list of lists here if you want to print it more like an umpire way that's a different story but we do have a three by four three column three rows rather one two three with four columns and they're all filled with zeros so we kind of go all right sweet we're on the right path here all right so I'm going to take that out just for now because we don't need that in our code so now we want to we want a for loop to take our BOM arguments and add them to the array that we just created so just created that array of zeros we want to get our BOM locations from the arguments that we have into those locations and we're gonna do that with a for loop so for bombs like jumpstart we're gonna do it as bomb location because that will make more sense when we debug everything and bombs so for bomb location and bombs what we're gonna have to say what bomb location is gonna mean right well we know that it's going to be the 0 0 0 and the 1 2 that we have so it's a row column right so what we're saying is BOM row this is kind of the orientation that we have our our raisin at the moment so we have our BOM row and our BOM column and what is that equal the bomb location so now right we're starting to get the for the format in place to what we needed now we want to update the field to show that the that this cell is a bomb right so how are we going to do that very simply we're gonna call field and what are we going to do in field we're gonna change some of its positions and we're gonna do that simply by BOM row that's gonna be our first index position and then you guessed it BOM column and what do we want it to be and we said we're gonna make it negative 1 negative 1 is gonna be a location of a bomb within this three by four array that we created so just so you could see it let's go back to field we're gonna print the fields so now we have our BOM locations we said they were at 0 0 1 2 so row 0 column 0 that's correct and row 1 column 2 0 1 2 that's correct so now we have negative ones where we wanted our bombs within our array all right so let's get rid of this all right so we're making good progress at this point now we want a way to select we need a way to select all the surrounding cells and I'm going to do this in a particular way with the idea of debugging in mind because if I wasn't debugging I would do this slightly differently but I want to do it this way because I want you to be able to see exactly what it is that I'm going to be messing with so we're gonna call this first one row range and what is row range going to equal well it's going to be the range of the bomb row minus one and you're going to see why we're doing this in a second bomb row and then we're gonna add plus two now this was so we could have a distance of three of the matrix that we were doing if you recall on this picture here when we were doing our imaginary matrix we wanted we want to take whatever location our row range is that at that moment we want to create a whatever row barbed or whatever so were at that point we want to be able to do a for loop that's going to go through the rows and the columns to check the numerical value of that cell and this is how we're gonna do it in a way where we can easily debug it so we're gonna do the same thing for column range and that's that's going to simply just be the range of what column same thing minus one plus two so that I'm looking at them like why is addison's I like that space as image of my numbers just makes it for me visually easier to read so now we have always selected our surrounding cells the surrounding cells from the position that we're currently at at that moment in time so now we're gonna do a for loop in the for loop so now we're already in our primary for bomb location and bombs loop and within that loop we are going to now for I in what well we want to first go through bro range right we're gonna go through our rows first and I'm just again for the sake of debugging Kurenai equals eyes so we can see it I just want to create a variable so that we can see this now another loop inside of a loop J is going to be tied to the column range and same thing I want to be able to see what that current J is going to be sorry just so we can see it as we're debugging that's the only reason I have those in now what we're doing is as we do this for loop so it's going to be for I and I so for row zero then we're gonna have to iterate the four for the columns zero zero zero one zero two zero three and then after we exit this column here then it's going to go back to the original for loop and do Row one and then inside that Row one iteration we're going to do column 0 so 1 0 1 1 1 2 1 3 so we're iterating over the cells in a toptobottom righttoleft fashion and then well what the hell are we gonna do in those cells and again this when we debug it or I'm I'm gonna write this out on the tab because it'll make more sense for you what we want to do is we have I alright so first we're looking at I and we're also gonna be looking at Jane so what do I want to know I want to know if I is less than the number of rows not only that but I also want to know if I is greater than or equal to what 0 in this case it's gonna make more sense now as we debug everything so now this just says I when it does this if loop if I is greater than or equal to 0 and it's less than the number of rows so we have our first conditional statement there and it's gonna get really fun we have to do the same thing for who well for the columns and the columns are represented by J and then they have to be less than the number of columns so this is all we're I'm gonna have to do yeah that's gonna be fine I close it off go away and 0 dododododo dododododo James Lawson no columns are just making sure everything where I needed to be and if you're not if you have to follow the numbers and num columns is where it's up here in our arguments so now what are we doing in that if loop if we find that condition it's not just we're not just stopping there so we have if and end I actually didn't want to close that off just yet why I'm adding another end so what we're gonna be doing is we're gonna be finding if we're in the proper row column location and we want to make sure there's no bomb in there at that moment right so how are we gonna do that well we already know in our field where the bombs are so we want to make sure that the being the the field is not that the IJ that we're currently iterating through we want to make sure that it is not equal to a bomb that's where our negative ones gonna come into play so we're going to need a true and a true and a true in order to execute for the next loop and what are we gonna do if we did find this condition well we want to update that cell in the field and again we're at the IJ cell is what we're trying to do and we want a plus or minus one we want to up that index that's exact to do I'm missing yeah that's pretty now we just want to update that particular cell of the field and then when we're all said and done we want to return our field that we created make this a little tighter here so what we just did with that with that particular code we're gonna iterate through the row columns and we're saying if the row is greater than 0 so let's say I'm in here it's greater than or equal to 0 so that would be true and column is greater than 0 and less than the row calls which I'm the number of columns which is true because it's 0 and it's greater than 0 greater than equal to 0 and it's less than 4 so we have a true and a true and the field I J which is 0 0 does not have a negative 1 this does have a negative 1 so this would be a false and we jump out of that loop and go back into our for loop until we got to a true so this should become a true and then with this being a true would also say there's no bomb in here this cell the row is greater than 0 it's less than 3 the column is greater than 0 and it's less than 4 we don't have a bomb in it the field I J which is field zero one does not have a negative one so then what we're going to do is we're telling it in this field update it's a plus one so that would simply then take this and make this a one which would tell the player at that point that they're from this cell there's one cell around here in this tube two by three matrix that has a bomb and of course it's right here and then as we go through the code and we get to here and here this wouldn't reality become a three because there's three bombs within this cellular matrix and again it's cellular matrix just to separate it would be here and theoretically would be up here but we don't have any cells up here so this particular cell has a bomb here we have a bomb here I'm sorry I thought this was also a negative one so I'll make it that way so then we would have three and this number telling us that three of its six cells have a bomb all right if you're not confused yet good let's debug alright so it looks like it's gonna run let me see what I get first off if I run it let's move my output is negative 1 2 1 1 1 2 negative 1 would be here that's why that's 2 because I have a one on one all right and then you have an adjacent bomb yes you do my third row 1 2 & 3 should all be ones they're all ones cuz there's a bomb all right cool so it's it looks it looks like it's appropriate so let's do our favorite thing let's run this debug I'm gonna f8 we're going to hit our print function and go back into our function and we have here our bomb class list which was just our input let me bring this down our field this is where we did the 0 for I and range for the number of columns and japheth and I'm arrangers creating our matrix filled with zeros so it did that appropriately now that's annoying I wanted to see that I wanted to bring just so you can see it here so we have our zero zero matrix there now for bomb location and bombs so we're gonna go bomb locations right now it's a list and we're at zero zero where did it get that zero zero up for bomb location it got it from our first argument our first argument here is bombs and we have to within that argument now we're just breaking down the bomb location that zero zero breaking it down into a bomb row and a bomb column so we're gonna get bomb row and bomb column do we have a zero zero that's appropriate now the field we want to update the field we want to tell our field hey we know where there's a bomb is a zero zero bomb right now our field as you can see up top here is simply just all zeros so we're gonna update it with a negative one meaning what again we're telling our field now where there's a bomb make it a negative one and you're gonna say well it didn't do it for one well no because we haven't gone through that bomb location yet we're still going through the code for a bomb location and bomb that's true that's true that's true we're still within this four loop when we jump out of the for loop then it'll go and look for another bomb location so now we're just going to create a row range and I just want to quickly say before I even go through this I have for I in range this row range could be taken out and you could put this code in there and it's the same thing I pulled it out of that for loop cuz I want to actually see the varial produce in memory so that I have something I can visually track as I'm running the code so row range is simply the range from the bomb row negative 1 to the Brahma row plus 2 so we have a row range range negative 1 2 and then we have our column range negative 1 2 totally that's appropriate cuz we're 0 0 at this point 0 minus 1 is negative 1 and 0 plus 2 is 2 for both of our row and our columns now I'm just gonna quickly jump over here for a second to show you what this is gonna be so we just did a range what are we going out negative 1/2 so that's appropriate so we're negative 1/2 I just want to run this show you what the outputs gonna be may bring this over so you can see the output actually no I can keep it like this and I can I didn't mean to do that let me bring it up to a float window so we have a 0 and a 1 why well because we're only printing out the eye for the ranges thereof one two two we're only getting two values within that so what happens if we make this a three for I in range zero one two three we're still getting a one two we made this a zero and that's not proper so I had to make this bigger because we were getting the wrong answer so if we were zero we'd go back where we were one day what was it originally I mean move you for a second negative 1 to negative 1/2 so if we run this we should get a negative 1 because okay perfect so we have a negative 1 and then we're going to numbers index is 0 and X is 1 so it's negative 1 0 1 that's for the ion range of 1 2 if we increase this to say 5 we're gonna get the negative 1 it's still going to count up to 4 which is going to be 5 numbers of the range 1 2 3 4 5 and conversely if we did it to negative 3 then we would have 3 to 1 so this is why we're not having a problem with calling cells that are outside of our actual matrix because right it's not gonna these negative numbers are gonna just simply equate to less than 0 so it's not going to be an issue all right so back to the code so I'm fading through for I in range and I just want to show you what that I is that's why I have that current I equals and current I that current I and the real range is negative 1 Y it will roll range the first I is gonna be negative 1 that's appropriate for a J what you think we're gonna get you should get the same negative 1 so we've negative 1 negative 1 so now as we go through this piece of code here this is exactly what gonna be looking at we're gonna have negative 1 I'm gonna do it one time on here and then you can do it for the future times if you like so let's clear this out let's whatever that's fine so we had negative 1 negative 1 corrects ya negative 1 negative 1 so if we're rockin ah OC days so we have I is negative 1 and J is negative one all right so this is our row and our column piece that we're playing with so when if you if you follow this with a code what are we saying we're saying if if zero is less than or equal to negative 1 and negative 1 is less than the number of rows which was 3 well that's true is negative 1 greater than equal to no so this is a false so right there that codes going to cut out so we can see what's going to happen is we're gonna run right down into the J and if when we try to run through this loop here it's not going to go so I'm going to f8 through there and we're gonna go back up why don't we go to I because we're still in the first row we still have 3 more values in the range to go through so now G is going to turn into 0 why again because we were negative 1 to 2 so it's gonna go 0 and then after that a guarantee it's gonna go 1 and then it will then will go to the next row so now we are negative 1 0 let's see what's going to happen so if we're hanging out here at negative 1 0 so let's do it a little just for fun all right so now we have an I is negative 1 and J is 0 so is negative 1 greater than or equal to Z no I'm still at a false now it doesn't even matter what J is in either of these examples yet and our for loop we're still getting a false so we're not able to proceed within our code so I'm gonna be pulled out of that loop now go back into J and now J is gonna be a 1 so now I'm negative 1 1 this is the last cell of the first row so now we're negative 1 1 and you should know the answer to this I'm not even gonna change the damn color cuz now if I'm I neg ative 1 and J 1 we did not matter what J is yet because we have not even gotten a true statement yet on our I because our I was in this case it was 3 the number of rows so we have not even gotten a true on this you know we're gonna true or I has to at least be 0 we haven't even gotten a 0 I so let's see what's gonna happen and it should go I fade through this back up to 4 i in row but jumped here and I thought there were no more in the range for column range I went to the I range which is appropriate so we're going to FA through there and the current is going to change the zero that's appropriate because we'll go negative one zero then one and that's gonna be our two values starting from the negative one so now we're at zero we have to f8 to change our column that's gonna be negative one all right so appropriate so now what's going to happen and you probably might have guessed it now we're 0 1 so we're going to let's clear this layer so now we have our I is 0 RJ is what Noah yeah zero negative 1 I was going to say I think that's wrong negative 1 so now our I and this is just how we're going through the code so now we're at 0 has to be greater than or equal to zero and has to be less than 3 so I have a true but then I have end negative 1 greater than equal to 0 I'm at a false right there so I'm already jumping out of that code so until J gets to a 0 I can't even go any further right so what you're going to see it should it better jump out of this good ah now we're talking now we have an I of 0 and a j of 0 so let's see what we get within this code all right so now we have an i of 0 we have a J of 0 so we have 0 is greater than or equal to 0 that's a true and it's less than 3 sweet so we have a true and 0 is greater than or equal to 0 that's a true and it's less than 4 I have 2 truths but I'm not done I also have another end and the field for I J which is 0 0 that's my row column right cannot equal negative 1 meaning it cannot have a bomb there well let's look at our field at 0 0 do we have a bomb so if we go to 0 0 do we have a bomb row 0 first row column 0 negative 1 son of a we got a bomb so what just happened to our code but you should have somewhat presumed which is now we have a false so true and true and false equals false so we're jumping out of that code we're not able to come back into that code so now we've got to jump out f8 now we're gonna be at zero one and just for before we even get there let's quickly look at our field and look at zero one row 0 column one it's a zero so we do not have a bomb in that location right awesome so let's see what this should do for the math so we have a zero one alright bring this like this let's clear out the level all right so now we have AI is 0 and J equals 1 I'm just I'm anal retentive I'm going to make sure it's right all right good so we write 0 and 1 so we saw up a form that we have I'm sorry 0 is greater than or equal to 0 that's true and it's less than 3 so I have a true for my first and 1 is greater than or equal to 0 that's true when it's less than 4 sweet and the field at 0 1 does not equal a bomb I got a true so now I got true true true so that all looks like boobs so then we can go to the next line of code and the next line of code that we're gonna have is gonna say we're gonna take our field at where do you think location 0 1 that's my I am I J and I want to do plus equals 1 so what's gonna happen now my row of rows I'm gonna have a bomb and then this should be a 1 right now it's a 0 but it should update to a 1 and then it should go all the way back and then run that code again so let's see how we're doing f8 now good we got to line 30 that's our field IJ equals and then you can I'm gonna see if I can make it like this so we can watch here we have negative one this zero should turn to one on the next execution and the bastard jumped on us negative 1 1 there we go so we have our 1 so now we know that in this cell the representation represented cell of row 0 column 1 that if you if you if you were to click this cell this I was exposed it's gonna say number 1 telling us that one of the adjacent cells we're not calculate above obviously go to row 0 has a bomb all right so that was successful now I'm not going to keep going through this for each location I just wanted to do that for observation for your ownself but now that you're gonna see we went through range negative 1 0 1 for column as we're done so now it's got to go to row number 2 which is index of 1 so when I FA through there it's gonna change now now it's gonna start going through this row we're going through that row at this point now so let's go and start going through 1 negative 1 1 negative 1 1 0 up so far we can see based on that we're getting executing codes that we were able to adjudicate and we got another one in our list so I'm just gonna go through all of this now you can see bomb location it went through all the rest of the arrays bomb location is now gonna change because we ran through the 3 by 4 matrix for this location now we're going through the matrix for this second bomb location same exact thing we're gonna run through this for loop come on baby 1 3 2 3 2 1 2 2 2 2 take us out of a loop there's no more bomb location so for bomb location and bombs we're done so now we're gonna jump out of that final loop and be to return fields and if I f8 through that we're gonna come out and we're gonna be given weight bring this up there we go so now we can see where we put our bomb locations in these are the negative ones and then the two the one the one the one the two the one the one the one 101 all those ones and twos were controlled by this for loop with what we were doing is in the whole point of the loop again we were trying to find where the bomb locations were so that if I expose this cell I know that I have two bombs that are nearby so if I brought this out I was trying to make this as visual as possible for you guys let me do this let me bring you up clear layer whatever I'll draw the I'll draw the matrix in this so we did a three all right so we have this and of course I'm not gonna draw up but you know we have our rows and I'll just do this I'll do row 0 Row 1 Row 2 column 0 column 1 column 2 column 3 it's nice and bright so now what I want to do is let me get rid of this guy we are a negative 1 to 1 1 negative 1 to 1 1 we are one second I bring this where's my pen 1 2 negative 1 1 going backwards all right so this is what our matrix ended up filling out remember we start with all zeros and then after we started with all zeros then we put in our bombs with the negative 1 that was a simple just rearranging within our list of substituting new values from from our argument so now we had these guys in place and then we did our for loop and when the for loop was going through again we went 0 it started at 0 and then 0 0 0 1 0 2 0 3 and then it went Row 1 0 1 1 1 2 1 3 so that's how it was going through the cells and when it's going through the cells what it was doing was it was trying to find those and and then if we had all three combinations appropriate so in this particular one here remember it starting was started as a 0 and the first time we went through it we turns it into 1 because we got to a point where row 0 was greater than equal to 0 in his lesson 3 and column 1 was greater than equal to 0 and it was less than 4 we had true and true and there was no negative 1 in this in this in the cell that was true also so we upped it to it would change to a number one but that one happened when we went through this row we went through bro 1 and when we got to when we got to examining this particular cell cuz they're gonna win it's gonna iterate through the loops yet again this was going to end up getting changed to 2 simply because now it had this number right here is represented by this cell this cell this cell this cell in this cell so this particular cell in its neighbors it has two bombs this salad oil is one bomb and its neighbors who's doing pretty much for doing depending on the cell size cells 3x3 because if this did not have one I'd be checking here here here here here and here here here and here but that's what the iteration on our for loop was doing and you may sit there and say how the hell I did have a student once asked me this how did ah let's make a little different how did if this was originally zero and we got to one like they understood that part they understand how we got to one but then when we got to this room we came and we got to this number here we got to this cell here how the hell did the code note it back to essentially space zero one and change it from a 1 to a 2 how denoted it well you have to remember when we first did this when we first did the first row zero row one row two this was not yet here it was only after we finished all 12 cells that then we went back up to the original for loop for bomb location and then bomb location then changed this cell to a negative one and then it goes again zero zero zero one zero two zero three and when it got to this location here when it was doing its check it found that it did have a bomb location it was gonna it did have an end and end and an end and an end and an end and it was oh it judicata self up to it that's all that happened there if that it's not not clear to you let me know but that's how we got it essentially when we ran through this loop the first time then we came back up to bomb location in bomb and then it put in this second location of the second bomb then it went back through this four loop yet again to adjudicate what it was a one into now a two based on this parameter of the code here so pretty pretty involved granted I'll give you that but an excellent excellent excellent exercise not just in Python and for loops and nested loops and nested loops within nested loops but even in how you can do like I think this is a really fun piece of code here this this particular line right here I thought that was really good it's a great way to make it visual I think this was a great let me get rid of this guy I think this was a great piece here I like how he got to use one word argument bombs but we were able to pass a number of different a list of lists for that one argument so even though we have three arguments so it's taking one two three four different parameters if you would pretty cool then if you didn't put this as a list of lists then you should get an error yeah perfect so we're gonna get an error so that was good glad to see that that works that would be for you that's for you oh that's why I have to if I did this we should get a different error yep see it takes three positional organs but we gave four that's because we as far as we know we gave it one two three and four so we want to encapsulate this entire list of lists as one argument so then when we run it we'll get the appropriate output given an array what is the most frequently occurring element within that array so this is gonna be done in linear time so a Big O of n essentially what it's gonna do is create a empty dictionary to keep track of the occurrences and then we're gonna return the element with the largest maximum count so nothing nothing too monstrous today so we'll call it most frequent and what are we passing we're gonna pass through a list into this function of course we want to create our count my set that's going to be an empty dictionary all right so the empty dictionary we want to key value for the count and we're gonna set our max count we'll set it to zero for right now we're just initializing max count that's gonna keep track of the number of times each item has occurred and then we're gonna have a maximum item which as of right now it's gonna equal none because we don't have any the max item is just another variable it's gonna keep track as a counter in real time for the most frequently occurring item that we have this our thus far so for I and list was going to iterate through the list that we're given in the argument for the most function if the I is not an account well what we want to do if the i sorry before i not in count we we want to index we want an index item that has not been saved yet that's what that is for i've nine count it's not in count count right now is empty so it was not an account we want to do something with we want to index it we want to put that element and count and that element is gonna be i at that moment right we want to give it a count of one so we want to actually load whatever the element is if we if this if this list has an element two and if there's no two and count yet then we want to add two to this empty dictionary dictionary called count else jump down we're gonna throw our else in this means we have to see we also have numbers that we've seen before so if we've seen the number before what we want to do with count well we want to add to it right so now we have a way that we've seen the number before we can add one to its value in the dictionary key but what if not whatever but rather we also have to we're also going to have to make sure we have max count max item so now we have to go through our max count and max item and see if they need to be adjudicated as we go along so the so make sense if count of I is greater than maximum count this is comparing the value of the elements in the dictionary to the maximum count so whatever value in the dictionary we've built in this loop we're comparing it to the max count for that particular I all right nothin monumental there so if the max count of I is greater than max countable we want to update max count because it should be the maximum count right so we want it to be the count to that I so that it updates the maximum count we want the maximum counts reflect the maximum count for that particular key in the dictionary and then of course we also want to update if if it is so it's a new king of the max location so if max count is updated then that max item is also going to take the cake for right now so all of this is doing is just updating these two variables here as we go along iterating through our list and then simple is sweet we want to return what let the max whole point of this to get the maximum item right give it an array what is the most frequently occurring element we want to return the max item so no errors showing up yet we have call our gonna call our why are you oh my goodness I really should have my coffee fresh in then we're gonna open and close and I'm also going to open and close the function out just so we're consistent and now within this we're gonna be passing a list I'm going to put that list in so let's say we did on three three another three two one oh one one so we can tell that our we should get a 1 as our output but I wanted to have the 1 after the 3 because I don't want it to be numerically validated and you could also you should be able to do negative numbers in this as well so let's see we're gonna rock here so we have a 1 alright so that word alright so we can debug through this I'm just going to argument sake I'm gonna increase it to 3 and run it again and see if we get 3 okay cool so just close that out get rid of a 3 so we can keep it a 1 because I like the idea that it's value wise is less than a 3 and it's after 2 3 so make sure that we're actually iterating proper properly so let's debug through this bad boy not gonna need you we're gonna go down to our print get our list now we have our list in memory count as an empty dictionary in memory max counts a variable set to zero and dictionary max item is to none now we're gonna interact through the list so I is gonna be 1 because that's our first element in the list if I is not in count count right now is empty so it's not an account so that's gonna be true so we want to increase that to 1 so now it's gonna say 1 1 because the dictionary so now we have one we have one occurrence of the number one so far in our count we're going down if count is greater than max count with max count of zero so that's true so it's good should update the maximum count to one and the max item we're going to update to whatever is at that moment I write now is 1 so now we have our king of the hill is max item is 1 now we're gonna go through the next number so it should be 3 so when we go through 3 it's gonna add it to the list max counts greater than max count nope it's 1 so 3 as occurrence of one one has an occurrence of 1 so there was no update to have to be done now our I enlist now we're going to know we have the number 3 again so count was in there so now we're gonna hit the else loop so count just increase it by one so this three one should become three two when I go through this line excellent if count is greater than max count max count is one count of I right now is two so this max count I have max item here should change to three and the max count should change to two two and three excellent all we do is update the max count to do count of I in the max item to BI and we're just going to keep going through this we have three again now we have three threes so the max count was updated max item was already three now we are number two but number two which was it was never seen before so it created the key value of two one but it did not the max count at the right now is 3 so 1 is less than 3 so it didn't have to go through this code down below and we're just gonna keep going we're gonna get our ones now we have four ones so now max item right now is set to three max count is 4 because I won as the 4 so max count 3 should change to 1 right now excellent so now that we're going through this let's see so we went through the whole for loop now we're just gonna return the max item and that would have been Z number one which we have over go to floating mode you just do that automatically which we have is the number one if we wanted to make these the negatives not going to make a difference because it's checking the occurrence of each particular element it's not checking the numerical value of it so you can see we have negative one as the return so a another quick function just to show us how we can utilize for loops iterations if loop else loop and just some creative some variables inside that will create a counter so you'll notice a lot of what we doing in a lot of our rate problems with creating counters or creating pointers to iterate through through arrays or couldn't counters in dictionary style so we have a key value count to go through this equally enough to find the least occurring element at a very similar fashion which we've done before so we have most frequently occurring element and we've done least as well and this one's going to be based on strings and I remember strings are gonna be different than arrays arrays are easily mutable strings are immutable characters so or rather elements so we have to do things a little bit differently so this question given a string or all the characters unique so we should give a true or false return first I'm going to show you how you could use this if you're just using by Python builtin structures and then I'll show you how we could create our own lookup function first off we're gonna define what unique is gonna be and what are we passing through nothing more than a string could even write string if you want um first thing I'm gonna do I'm gonna replace spaces so let me let me first show you what I'm gonna be passing through all right so when we're very done with it we're done with the whole thing I'm gonna be passing through the following string a space B space cdef so we're gonna be passing again if all the count of all the characters are unique but I had these spaces in here because I don't like when people just do like you know a abbc it's just it's not it's not reflective of what you do in real world real world they're gonna have spaces you're gonna have capital she's gonna blow up cases and it's a good idea to understand replace methods lower case methods and and so on and you're gonna see me use it a lot and a lot of the algorithms that we use so I just want to get rid of any spaces that are in there so to do that we're just gonna reassign what string is gonna mean and I'm just gonna tell it I want to replace it so we're gonna dart that replace method what I want to do well I want to tell it right now there might be spaces and I want to replace it with no spaces all right so that's what we're doing there we're just gonna fix that up so string is a little bit cleaner now I'm we're gonna the easiest way to do this using Python builtin structures with a set and remember set is an unordered collection of unique elements so it's giving us unique elements it's just not going to be ordered we don't care about order so therefore if we can create both of can create our string that is going to be in a set then it's very easy to see if comparing the length of but if it's going to be unique or not so all we have to do at this point is do a return what a returning I want to return the length of set string whoopsadaisy so we're creating a set of the string and I want to know is it equal to the length of the string am i on unique I'm on unique let me drop this down to a floating window so it tells me true so remember whenever we're doing anything with with parentheses always work from the inside out so this is going to be dis operations gonna be done first it's gonna create a set of our string which the string is the input again remember the string we took we took out the spaces so I just do this let's debug it as we go through it nope I wanted to run debug yep I'm not gonna need anything else that's fine so it's gonna put our unique string into memory and we can see we still have our spaces or held intact I'm gonna get to this next link as we execute line number nine it's going to replace the spaces so you can see in memory now we no longer have spaces on our string so now we're taking take a set of this string this has already ordered it doesn't make a difference but asset is unordered so take a set from our string which is going to G it be exactly this only unique elements so we'll do repeats in just a second and then does that equal the length of the string well the length of the string is one two three four five six and how many unique elements are there going to be in this asset of the string is going to be six so it does the length of 6 equals six doesn't link that's to equal say yes it does it's true so it's gonna return true so we'll finish this to bugging in this so you can see that was gonna be a so let's um let's mess a fit let's put a non unique element in so now I get a false why and I say because the the B is redundant that's true but let's see what's going on in the code so we have our string Sharif going to take out the spaces so now if you wanted to see a length of the string is what 1 2 3 4 5 6 7 so that's equaling 7 right now the length of a set of that string remember set is an unordered collection of unique elements only well this was 7 for the length of the string how many unique elements do we have 1 2 we're skipping that second because it's not unique 3 4 5 6 so does 6 equal 7 false so that's it's a nice quick way you can use builtin Python structures for that operation now we're gonna do the same exact problem find the unique elements but without using Python builtin give me that without using Python builtin functions so the way we're gonna do this is the same thing in terms of defi unique we're gonna pass what's called s4 now it's easier to type we're gonna define the function unique it's gonna pass a string through it and just like before I want to replace the spaces with no spaces because again the inputs are gonna be I want to make this a little bit more real life I know what we're gonna do is we're gonna take our characters we're gonna make a variable characters characters within the element and we're gonna put them into a set now we need to iterate over this string to see what we're going to add in to remember we only want to add unique elements into this set and again yes it will be unordered so for letter NS subsidising we're gonna iterate through that string that we're putting through so again just so we have a mental idea of what we're doing and the string that I said will pass what did we do before we did a space B space C the EF so we'll pass our string which right now we know has all unique elements so it'd better be it better be true in terms of the return so for letter in s we're gonna do now that if if the letter in characters if it's going to return false or if it's going to return true so four letters in s is that is that in characters because remember characters is a set at this point and if it's not and we want to do something with that so if letter in characters right now it's an empty set nothing to we want to return false because if this is going through let's say we have this B being well as it goes through the code we're gonna do an append in a moment or added to the set imagine there was an A and there was a B when it gets to this second B if the letter is in characters B is well that's true then we wanted to return false because then it's not a unique pair of elements so we want to do that if it's not if there is nothing in characters that if that particular letter or element is not in our character set yet what we want to do well we want to add and what are we adding we're the letter because that's what we're iterating through it could have been I or you know a soar and whatever you wanted to put in to identify your iterator that's what you would have done there so characters not add letter so now if it does not exist within characters set we're going to be adding it and then when we're done with that loop when we're done with the iteration we're going to return true because if we did hit a repeat letter we are already are gonna be stopping here returning false if we do not hit me repeat letters then we will return true so let me see unique I got a false oh because I put a baby haha so we return to false if I take out that B we run it again I should get a true good let's take them out of sequential order you know alphabetical order rather let's do lkj re w so we know that this these are all unique characters so we got it true and if I replicate one of them I'll put a J over here and we should get a false awesome so let's just quickly run through a debug on this so we can say we're a thorough I fade through it and gets out of the way for a second so you can see in memory we put our string into memory we're gonna replace out the spaces so we just have a set string characters equals up empty set and so we're gonna have right now memory so for letter in s s is our string above up here for letter and character so we're gonna FA through so it's gonna take the first letter which is i if letter is in characters right now characters is empty return false but that was false so we're gonna skip that and jump down in the next piece otherwise characters dot add letters all right now letters I so we're gonna add what characters dial I so when I go through this it should add I wonderful and then it's gonna go through L if lettering characters is not in characters so we're gonna jump down to our else statement which is characters add so we're just adding these individual elements and let's get to a J and would go with the J and you will notice that or am I here I want to get to that second J so you can just see how up dammit I missed it there's J I remember again a set is an unordered pair so this we're running at this time it's a different order than it was before what are we now we're on e so the next letter is gonna be J so now we're on J but look at our character set we already have a J right here so if letter is in character set well that's gonna be true it is in character set already we're looking at J right now is it through this iteration and it isn't the character set so what are we going to do if this is true we're going to go the next part of that if loop which is going to be return false so return false is now going to be executed and sure enough in our output will be given a false because it is false and if we took that out did it end and then going through it same thing we're gonna have it replace it out it's just gonna run through the characters for each individual letter and it's never gonna find it's gonna always find that every letter is unique every element is unique it does not find it within the character set that we created so we'll end up returning true at the very end of it all non repeat elements so we're taking a string or gonna return characters that never repeat if there's multiple unique it's gonna return only the first unique and then after this is done I'm going to show you how you can return every single element that is not repeating this has huge implications in security so for those of you who are like well how am I ever gonna need this so what is it not only is this great practice for Python and for algorithm learning for interviews but this is also very applicable to data security so let's jump in and not to mention this is also linear time solution so what so we're gonna do a nonrepeating that's we're gonna name our function today and all we're passing through that is a string now from the last video remember the first thing I'm gonna do with any string that I'm messing with is we're going to replace what spaces with no spaces and on top of that I want to make this all lowercase just otherwise if I didn't have it lowercase a capital A and a lowercase a are different elements so if I you would say you sit there and say oh my god it it didn't gave me back an a a big and a little a and you say those are not unique those are the same but they're not the same they are unique they have very different binary codes so they are unique so we're just gonna make everything lowercase for simplicity sake now how are we gonna even do this one we're gonna create a dictionary and again the dictionaries are our hash tables putting our language they're all gonna track the key value pair for each character in the string so we're just creating a count you know it's not very different from a lot of the stuff that we've done just done it a little bit of different way so we're gonna create a character count and again that was just gonna be at this point in empty dictionary all right now for character in s or for C NS we'll keep it nice and simple what do we want to do if the remember that you guys have seen this whole time if the character is in the character count then we can add 1 to it if it's not then we want to add 1 so what does that mean okay well we did for character in us if character is in character count if it's in character count then I want to take character cow and I want to add one to it for that particular element oh so I need to do I am say I almost made a booboo this is for that see only for that letter see I want to add for that that particular interval iment that we're using at that moment which in this case is C for character in C if C is in character count if it is then we want to for that particular C we want to add +1 for that value and then of course we always have the well what if it ain't so then we're gonna have to do our else so if character is not in character count that what do I want to do I just want to simply take character count and for again for that particular say don't forget that part and we want to add it there we want to give it its first value of 1 now we're going to iterate again and then we're gonna we're going to do a second iteration to return the characters with only one count meaning the unique characters so how are we going to do that well still within this function or we're gonna back out cuz it's a whole separate for loop if you will for C NS so same thing there if character count for that particular C because again we're iterating so we're going one by one equals one if it equals one that means it's unique right so we want to return C come on otherwise if I'm gonna back out of this I'm gonna return none come on and stop that I want to return none otherwise if if if none of them are gonna equal one which means that there if there are no repeating elements within that particular string then damn it I wanted to tell me so so let's do this we named this non repeating there we go it's a string so I'm gonna put quotes inside that function string and we're gonna do I Apple eight peels now I did this on purpose so let's run it run non repeat again let's make this a floater and we go we got a floater and it returned I so is I the only one it's not repeated I is not repeated a is repeated Pease obviously repeated L repeated he is repeated there's no the unique so that is appropriate now just for argument's sake what if I did I want to prove a point if I do this and if I take this out later it will give me all of them see now first let's give me a capital I it's only returning the first one though but it would have also the reason for that is as it goes to this loop and it creates it counts for the dictionary when it goes through this and it gets to the letter I because that's the first one that that's that it's coming across if the character count equals one that one does so it's going to return C and it's gonna completely take me out of the loop at that point it's gonna stop going on but you're gonna see later how we would have to we would get multiple returns four unique elements and I'm gonna take the lower out just to show you what it's doing so let us um we'll debug it real quick you know I think the next one the debugging is gonna be a little bit more appropriate so let's let's debug it I don't need this so let's f8 our way through we're gonna put our string into memory I Apple a peels I start replace nothing new there it's going to lower case and it's gonna remove all the spaces character counts an empty dictionary so now for C in s so its first one's gonna be I foresee and character count character count is going to equal C it's not right now this C is I so I is not in the character count so it's gonna go down to my else else make it one so now we're gonna have an i and a comma 1 or colon one I'm sorry because its dictionary it's not a tuple so now for C and s now we're gonna go to a and its gonna do the same thing you're not in there so we're gonna go to the Alice we're gonna go to an a we're gonna go to P so the first time it's seeing P now we're going to pee again so again we're at the second P in the word Apple for character in character count it is right now P is right here and has a count of one so all I want to do is go to the next line of code because that was true character count of the index C at that moment which is P equals whatever P is right now 1 plus so it's going to change that to two so now this is how we're getting nonunique elements and as we go through this whole loop wait till we get to the L we have our L so next is going to be s s is not in there so it's going to add a character kind of s one excellent now we're going to jump into this for loop you're going to see that it's going to try to find a for C NS but all the seeds are done so we jump it up for loop now we're down below for C NS if character count equals one so we're going to FA through if character count equals one well the first C and s is I I equals one yeah that's going to give me a true it's going to go the next line of code returns C it's going to return that I and as far as the code is concerned it's done but we know that that is not true so there we go we have our I because we know that there could have been other letters that repeated and if it wasn't the first letter that was the unique element then if carrot when it got through this line here line 21 it would have went it would've went for 222 when we executed 22 would have skipped this and it would have returned not at that moment I'm sorry now I'm lying it wouldn't back to the for loop and it would have done the second C which at that point would have been the a and it would have been looking for them for the first time that character count equaled one character count being that dictionary we created for the key value pairs so what would we do to this get rid of that for a moment what would we do to this if we wanted to make this account for all of the non repeats well to do that we're gonna sit within the code that we've already started I'm just gonna bring some of this together so we a little bit more space on the screen so what would we need to change if we wanted to return not only the first element but any at all a total of the unique elements well let's go line by line so we can obviously keep this we can clearly keep this there's no change in their character counseling we have two dictionary we're still gonna be able to keep our first for loop let's actually do this so a little bit of separation visually we can still keep our first for loop there's no reason we have to make any change in that we're still creating a dictionary with the characters and the count for that but now it's going to get a little bit different so what we're going to do is we're actually going to get rid of this second for loop and what are we going to do instead well we're gonna create a list so to do that we want our final answer and it's gonna be at this point an empty list all right actually let's rename this let's call it all uniques so we're gonna make a list of all the unique elements that exist within the string that we're putting through so we have an empty list we want to sort our dictionary now so that the values control the order of the keys and we're gonna do this in an ascending fashion so a nice little quick way to do this is we're gonna create a variable Y you know just so we have something to plug this object orientation into we're gonna take a sorted so we have sorted and what are we sorting well our character count that we have from above and we're sorting it by the items that are within side of it now by doing this what we are that's not right that's better I'll lab them because I do want to add one more piece to this so we're sorting we're taking our dictionary that we've created and we're sorting it based off of the items that are within that that's going to put this in an a sending meaning that the lowest count to the highest count of the elements so we're already it's it's a it's sorting it for us now with something else we're going to be doing is we're going to add a key lambda key equals lambda and I'm gonna say at this point X and I'll get to this in just a second X 1 and of course so oh wait no I don't want to do an order versa now I wanted to show you that port later because right now I want a sending right yeah well we'll do a sending so lambda is it's something we haven't covered before and I'll cover it in another time but lambda is a way of almost like doing this whole defining of a function piece it's a function of itself and it's going to carry out whatever that function is that we're that we're specifying at that particular moment so all we're doing is we're saying we want the key to be that second position because the first position is the key the second position is the value we're looking for this x1 that we're going to be executing and so then then what we're going to do is we're going to compare the index 1 position of each tuple because again we have a list and if we have a key and a value that's going to be separated by a comma in a list not the dictionary where does it semicolon and then so then we have a tuple then it's exactly what we're going to have so if we did this just further so you can see it let's print Y so you can see now that we have Y is now it started out as an empty list and now it's it took exactly what we're going to have done here so based on this you can see that our we have two unique elements we have I and we have s which is true we have two unique elements last time we only returned the high because that alphabetically became first that came first in our sentence rather on our string but now this time we should be getting an i and an S because they both have a key value of 1 the lowest values so what it did was it sorted it took our character count or dictionary it's a character count by the items and then it's sorted that and it's sorted it well how we need to tell it we wanted to do by lambda we want to sort it by the not the first part but the second part which is this is 0 and this is 1 that's where this is coming into place so we want to take our entire list X take our entire list and we want to take that second index position as our as our key of how we're going to do the sorting and then I just want to print this to show you exactly what that I is going to look like an accord this nun here is just referring to the fact that we didn't print out our function because we did not finish it yet so we don't need this in the end so I'll take it out for now I just wanted to show you that so now what am I going to do so we have Y we have our tuples instead of a list so we're just going to do four items in Y right we want to iterate through this now what we want to do we want to compare the index position of each tuple so how do I do that well I'm just going to say if the item and I care about that position the second position if it equals that sequence it's getting that then what I want to do we named it all unique we're going to append it with what the item and then of course we always have to give our good old we want to return all uniques I gotta put an S I didn't put the s there I apologize alright so now they're all the same so yeah when you're high like that get all three it shows me well those variables show up so I know they match all right sweets bring this down to spit so we see everything so what I did was we created another for loop iterating through it and we're saying for each item in Y and again this is how we separated them out if item in the that's the second position equals the same Y of the one position for the value aspect of that tuple then we want to append it into all uniques so let us actually now I'm sorry let's run first because we do actually have a print statement below and it gave me I and s and just for argument's sake I do want to show you if we take this out and if I make this a lowercase a and then we should get more because there's no other ease in there right yeah so yeah see that's what that's what I want to show you so now we have I got rid of the lowercase so now we have one unique upper I one unique lower a one unique upper a one unique upper P one unique lower s now it's kind of being a smartass because we both know that those are not unique elements hence the lower method that we're applying here so that we only get the real ones that are resulted only one time so let us do bug get out of here so I'm gonna run my debug on the non repeats excuse me and I'm gonna f8 so it's gonna put I Apple eight peels into our string for the argument in the function and all we're doing here is replacing all of these spaces with no space and lower casing the entire string character counts empty dictionary nothing new there we already saw this loop before it's going to be the same exact function so let's go through this come on baby s awesome so now all uniques is an empty list so we have that in memory and then dude Richard y equals the sort of the character count by the items and how we doing that we're using a lambda which is the function of the self and we're telling exactly what let me get so as you can see that what we're left with we're left with exactly what we printed for Y before that same kind of a class list it's got with tuples so you can still think of it like a key value but it's not it's more of a in X position 0 index position 1 within each individual tuple that comprises the list so for item in Y well it's going to tell me what is item in Y well the first item is i1 so for item 1 while item is right here this is 0 this is 1 if it equals y of the first index position that second is position then all uniques dot append item so now you can see that was true and true so in all uniques are empty lists we appended it with the i1 because it equaled 1 now we're going to go f8 second item is now s1 so we should also add that s1 so it's going to go to the next well why'd you freeze on me so now we have a and now a happens twice within the string so it does not equal that one position so it's not going to go to the lines 23 of the all unique so we're not appending our all uniques list same thing we have a 2 we have a 4 we have a 4 did not work be in the sense that we we didn't no longer hit a 1 in that second index position so we're returning all uniques nonrepetitive so in our console we should be left with FA through that last list the only two elements that were non repeats throughout the entire string and the count which we know is going to be 1 in this case so I feel that this one is much more productive that this this particular code simply because of the fact that we were able to return all uniques all non repetitive x' within that string and that non repetitive is life ii based on the lowest lowest key value and again this has huge implications in data security and encryption so with that said guys have an excellent day and I will see you all at the next video