Hey, what's up guys, it's Pedro here from New cutter calm. And in this tutorial, we're gonna learn how to install Node j s, as well as learn how to actually run code using node j s. So to get started, we're going to actually have to download node j s. So if you go to Google and type node j s download, you should get a web page similar to this. And I will be leaving a link in the description in case you can't find it. So go ahead and download eight, point three lt s. Now once you download that, run it, install it enjoy all that good stuff. And within these tutorials, I'm going to be using Visual Studio code. And if you don't know what Visual Studio code is, it's an editor. Now, you can use whatever editor you want. But the reason I'm using Visual Studio code is because it has an integrated command prompt. So once you download these two things, I'm just going to head over to my desktop. And let's create a new folder. And I'm just going to say no JS tutorial. And now I'm just going to head over to Visual Studio code. And you should have a welcome screen like this, go to File, Open Folder. And we are going to open the folder that we just created. So I'm just going to select this. And now I'm just going to hit Ctrl N control and is going to create a new file, I'm going to hit Ctrl S. And we are going to save this file. And I'm just going to say app dot j s. And this is going to be a very, very simplistic JavaScript file. And we are just going to run it. And this is just a test to see if you installed node j s correctly. So if I hit console dot log hello world, from node j s. Now if I save this, and I'm actually going to exit out of this, but you saw that this just popped up on my screen, if I go to terminal, here is our command prompt. So I'm just going to exit this to show you how you can bring this up whenever you want to run code using the terminal. So I'm just going to close this. I'm going to hit Ctrl B, I am going to go to View, I'm going to go to integrated terminal. Now by default, Visual Studio code has it on PowerShell. So if I go up here, you can notice that mine says cmd. So if I hit Ctrl, Shift P and type default, I can say select default shell. Now I have three terminals installed on my computer, you probably have PowerShell, and you probably have command prompt. And I also have get, go ahead and click command prompt. hit this plus button, this is going to bring up a new terminal. So if I was to hit this or bring up another CMD, and this should say cmd. So I'm just going to remove for me, I'm going to remove one, since I already have one open. And now all I'm going to do is type node, and then the name of the file. So the name of the file that we just created was called app dot j s. And here we go, we get an output of hello world from node j s. Now let's say that you're not using Visual Studio code for whatever reason you have your own editor of choice, what you can do is you hit the start menu, type cmd and then go to command prompt. And then you can see that we get something very similar to the integrated command prompt, but we're in a different location. So if I go to my desktop, open this folder. Let's copy the path that this folder is located. So I'm just going to hit Ctrl C to copy, head over to my command prompt. I'm just going to type C the CDs stands for change directory. All that means is hey change folder. So right now I am in a folder called users Pedram makhado. I need to be in this folder. So now I'm just gonna click this. Go down to edit, click paste. And that's our path. So now if I hit Enter, you can see that our path has changed. And now if I type node app.js You can see that we get a Hello World from node. So either way is fine. If you want to use Visual Studio code and its integrated terminal, you're more than welcome to, if you're using a different editor and it doesn't have its own integrated terminal, you're more than welcome to use the command prompt. In this tutorial, we're going to be talking about node modules, or a node module is is basically a JavaScript file. It's a way to separate concerns for our application. So for example, let's say that I have an app.js file. And in this app.js file, I have maff, a bunch of API requests and database calls. Instead of putting them all on one file, what we can do is separate each of those concerns into their own files. So to get started, I'm just going to hit Ctrl. B, I'm going to say Ctrl N. So we're going to create a new file. And I'm just going to say Ctrl S and we're going to save it as the tutorial, dot j s. Let's save that Ctrl B. And now we could focus on this new file or this new module called tutorial dot j s. So to get started, let's actually give our tutorial module something. So I'm going to give it a function. So I'm going to say const, some, and it's going to have two parameters, and all it's going to do is add and return them. So number one plus number two. Next, what I want to end up doing is I want to expose this function to the outside world. Because right now, if I hit Ctrl S, and if I was to try to use this function, so I'm just going to delete this. So if I was just to say sum, one plus one. And if we were to actually run this, you can see that we get an error, some is not defined. So you might be saying, why is some not defined, I just defined it here. Well, I need to expose this function for the outside world to use. So I need to let know know that this sum function within my tutorial module is available to be used. So in order to do that, or I need to do is type module exports, and pass it in some like so. Now that this is available to be used, I need to tell my app.js file where this sum function is located. So what I can do here is declare a variable. So I'm just going to say Kant's. tutorial. And now I'm just going to use the word require. And then we're going to give it a path. Now the path is dot forward slash. So where did I get dot forward slash from? dot forward slash means that it's within the same exact path that this file is currently in where app dot j s. So if I was to hit Ctrl, B, you can see that I that j s is on the same level as the tutorial dot j s, and that they're in the same folder called Node JS tutorial. So if I hit Control V, again, get rid of that. And then I pass in the name of the file, which is obviously tutorial dot j s. Now you do not need to pass in the extension, all you need to do is pass in the name of the file, Node. js automatically assumes that it is a JavaScript file. And now, if I was to print out tutorial, two, let's see what's inside it. And now let's get rid of our son call. We're gonna call some a little bit later, I just want to show you what the variable tutorial has. So if I was to save this, and let's scroll down, I'm going to type CLS, hit enter. That's going to clear the terminal. And now I'm just going to run node app. And you can see that the tutorial now holds a function called sum from our tutorial module. So now if I want to actually use that function, I can say tutorial and pass in one plus one. And let's actually print out the results. I'm just gonna say console dot log it. Let's save it, execute it again. And you can see that we get our desired output of too and that we are indeed importing from our tutorial module, the sum function. So now that we know how to do that, how will we import ml To pull stuff from modules. So for example, if we head back to our tutorial module, let's say I have multiple functions or multiple variables, or even a class, how do I export more than one thing? Well, what you can do is I can say, and just for the sake of example, let's add more stuff. So I could say Kant's. Hi, and just gonna set this the 3.14. And let's create a class. And I'm gonna say some math object. Let's give it a constructor. And I'm just gonna say object created. Okay, so now I have some pi and some math object. Now, I want all three of these to be exposed to the outside world. So that app.js, for example, can require them and then use it. So how do I do that? Well, one way to do that is to add properties to the module dot exports object. So for example, I could say dot sum. And I'm just going to copy this. So now experts, that sum is going to have the sum function exports.pi is going to hold the value of 3.14. So I just set it equal to pi. And some math object, it's going to be madrona exports dot some math object is going to be equal to some math object. Now if I was to save this, head over to app, and let's just remove this for now, I want to print out what tutorial is holding once we require from our tutorial module. So if I save this, and now let's execute this, you can see that we're getting an object back tutorial is now an object. And now this object has the properties of sun. And it tells you that it's a function, pi, the value of pi, and some math object. And you can see that it's our class. And now if I want to execute this, it will be like accessing a normal object. So for example, we have tutorial. And let's say we want to use the sum function. So just saying tutorial, and I'm passing the two numbers, I could say tutorial, sum, and pass in the two numbers. And I'm just going to copy this. Let's paste this two more times. And now if I want to print pi, package, say tutorial, pi. And within here, the same thing for the object, I can say new tutorial, dot some math object. And that's going to create a new instance of our some math object. And now if I was to save this, and run it, you can see that it executes as expected. So tutorial sum, gives us to pi has the value of 3.14. And you can see that our constructor gets executed object created. One more thing to show you before I wrap this up, if this is an ugly syntax for you, for example, saying module dot exports, that sum equals this module.exports.pi is a bit repetitive, what we can do is, instead of exporting each of these individually, I'm going to let's remove two of them. And instead, what we can do is export an object literal and tag along the properties. So I could say sum is going to be some pie. This is going to be pi. And then some math object is going to be some math object. And if I'm to save this, and now execute it, we should get the same exact result. So let's execute that. You can see that it's working beautifully. And this tutorial, we're going to be talking about the events module, particularly the event emitter class within the events module. Now all the events module allows us to do is basically bring Event Driven Programming to node j s. So to get started, we're going to actually have to require the events module. Now the events module is actually built into node j s. So I'm just going to say Kant's. Event emitter. Now this is going to be the class that we get from requiring, from the events module, I was just gonna say equals require event. Now from here, we're going to have to create a new instance of the event emitter. So I'm just going to say const, event emitter, I say, new event emitter. So from here, we're going to start getting into Event Driven Programming. Now that I have my event emitter object, let's actually attach a listener to it. So I'm just going to say event emitter. And I'm going to call the method on now, this method takes on two arguments. One is the listener that you want to attach to this object. So I'm just going to call it tutorial for this example. And the second argument is going to be the function that you want to execute. When does the tutorial event occurs. So let's just pass in this function. And I'm going to say is console dot log tutorial event has occurred. So now if I save this and run it, so I'm just gonna hit Ctrl S to save. And I'm just gonna say node app, you can see that nothing happens within our terminal. Now, why is that? Well, I have this object. I've attached a listener call tutorial. But I haven't emitted a tutorial event. Remember, this code here, is only going to be executed when a tutorial event occurs. So now let's emit a tutorial event. So I'm just going to say event emitter. And now I'm just going to pass in tutorial as the first argument. And that's it. So now, if I was to hit Ctrl, S to save, and now execute this one more time, you can see that our tutorial event gets triggered whenever we call the emit method. So now what happens when we actually want this function to have parameters? Well, I could give a parameter so I could say num, one, num, two. And just for argument's sake, so just to show on the console, we're going to print out the sum of number one and number two. So now how would I call it down here with the emit method? Well, I'll just pass it in an argument. So I could pass in one, and two. So if I save this now, and now go to node app, you can see that we get the value of three. So you just pass in the argument. Now, this is all fine and dandy. But how would I create a custom object which takes advantage of using events? Well, I could just inherit from the event emitter class. So for example, let's say that I want to create a person class. So I say class person. And I could just extend from the event emitter class. And now from here, let's give it a constructor. Now let's call our super function. So I'm just going to say super. And this is going to allow us to use that this property within our class. And now I'm just going to say this, that underscore name is going to be assigned value name. And now let's actually pass in name to our constructor. And now let's give this person class a getter. So I'm just going to say get name. And all this is gonna do is just return this dot underscore name. So now that we have our person class defined, let's actually create a new instance of it. So I'm just going to go down here. And I'm just going to say, let Pedro equals new person. And let's pass in Pedro. And now here remember, when I say new person, person extends the event emitter class, which means that Pedro is also an instance of the event emitter class. So now I can add a listener to the page or object so I could just say pedro.on and And I'm just going to call it name. And we're going to pass in our function. And I'm just going to print out my name is so and so. So I'm just gonna say console. dot log, my name is. And we're just going to say Pedro dot name. So now that we've attached our listener, obviously, we're going to have to call the emit method. So we're gonna emit the event has occurred. So I'm just gonna say Pedro dot emit, and we're gonna pass in name. And now if I was to save this, and now execute this, you can see that we get the desired output of my name is Pedro. So that's how you would extend using the event emitters class. And for our final example, let's say that we have more than one person object, so I'm just going to create a new person, I'm just going to call let's make it a girl, I'm just going to call her Christina. I'm going to say new person. And we're going to pass in Christina. Now let's add a listener to the Christina object. So I'm just gonna say Christina, that on name. And you could use a loop for this. But since I'm only creating two person objects, that doesn't make sense for this example, but you can use a loop to do this on one shot. And we are just going to copy this. paste this in here, I'm just gonna say, Christina, that name. Alright, so why did I go there to bother are showing you that we create it to person objects, and attach listeners to it? Well, what I want to show you is that when you emit an event to occur, the event gets executed synchronously. So for example, if I say, Pedro, and I say, Christina, and now if I was to save this, and now execute it, you can see that these get executed synchronously. So because Pedro emitted first, Pedro gets executed first and then our Christina object, so they get executed in the order that they admitted in so they execute synchronously. In this tutorial, we're going to be talking about the read line module. Now, what the read line module allows us to do is prompt the user as well as get user input. So to get started, we're going to have to require the module. So I'm just going to say const. reline is equal to require read line, and this is going to bring in our relying module. Next, we're going to have to create an instance of the read line interface by using the Create interface method. So I'm just going to say read line dot create interface. And within here is going to take an object. Now we're going to give this object two properties. And this is basically our configuration file. So the first property I'm going to give it is input. And then we're going to give it an object. Now this object is called process not process is a global object. So you don't have to require it. It's already given to us by node. And here we're going to say STD. And now input is going to be the STD in input stream. And then here, we obviously need an output. So I'm just gonna say output, and we're going to give it process that STD out. And that's going to stand for output stream. Now, when this method is executed, is going to return our read line or the face object. So let's save it inside a variable so we can use it. So I'm just gonna say const RL is equal to this. Now let's say I want to ask the user what two numbers added together are equal to. So for this example, I'm just going to generate two random numbers between one and 10. So I'm just going to say let num one equal math floor math dot random. And we're going to times this by 10. And we're going to shift that over by one. So this is going to give us a random number between one and 10. It's copied us twice. Paste that, too. And we need the answer. So I'm just gonna say less Answer equal number one plus number two. All right. So now that we have this, we're ready to ask the user what these two numbers are equal to. Now in order to do that, I'm going to use our read line interface. And our relying interface has a method called question. So I'm going to say RL question. Now, the first argument is going to be a string, the second argument is going to be a function. And basically, the first argument is going to be the question we would like to ask the user. So I'm just gonna say back tick, what is not one plus num two? Question mark. And I'm just going to hit enter here, because I want you guys to see this on one line. And we're going to include our callback. Now, this function is going to get the user input as a parameter. So I'm just gonna say user input. And for now, I'm just going to print out user input onto the console, just so you guys can see that it's actually working. So now if I was to save this, head over to my console type node app, it's going to say what is four plus two, I'm going to say banana. And there you go, it prints out the user input. It's important to note that if you take a look at our console, the application is still running. So I'm just going to hit Ctrl. C to break out of it. And what we need to do is actually close the read line interface when we're done using it. So in order to do that, let's actually add a couple of things. First thing, I want a new line, right after this question mark here. So I'm just gonna say forward slash n. So when I prompt the user, the users input instead of lining up right next to it, like so there's gonna be underneath. Alright, so I fixed that problem. Next thing I want to do is actually test the user input to see if he actually got the answer. Correct. So in order to do that, I'm just going to say, if user input. And it's always important to trim the users input, if you ever accept anything from a user, just to get rid of the trailing whitespace. And we're just going to say if the user's input is equal to answer. So if they answer the math question correctly, I want to close the application. So I could say, RL dot close. And here, and now if I was to save this, and now execute the program, so I'm just going to write node app. And it's going to say, What is 10 plus four, and I'm going to answer with 14. And you can see that we answered it correctly, and therefore our application closed. Now, what I want to do is actually add a listener to the close event. Now, the read line interface is actually an instance of the event emitter class. So what we can do is actually scroll down here. And I'll add it towards the end. And I want to say our own.on. And basically, I'm going to say, hey, I want you to listen for an event to occur, I'm going to say close. And we're going to give it a callback. And this function is only going to execute when we close the reline interface. So now I'm just going to say console dot log. And basically, I just want to let the user know that Hey, you got the correct answer. So I'm just gonna say correct. So now if I was to save this, and now execute it, node app, what is six plus three, I'm just gonna write nine. You can see that correct, gets printed out onto the console. Now correct gets printed out onto the console. Because when we use the method close, it emits the close event. And since we're listening for a close event, this callback function gets executed. And on that note, I better add a semicolon on there. And let's see that. So now that we handled what happens when the user inputs correctly, what happens if the user gets the wrong answer? So in order to do that, let's create an else statement within our question method here. So I'm just going to say else. And what I want to do basically is re prompt the user. So I'm just going to say rl.com. That set prop. And set prompt is basically going to take an argument of string. And it's going to ask the user, basically what you want to know. So I'm going to say to the user, incorrect response, please try again. And let's add a new line here. And now in order to use the Prop, I actually have to call it. So the first method is to set the prop. The second method is going to be to call on discussing our prompt. So now, I'm just gonna hit Ctrl. S to save. And now I'm just going to execute this node app. And he's gonna say what is one plus five, and I'm going to say banana. And it's gonna say incorrect response, please try again. Now, I actually haven't told it what to do once the user inputs. So let's actually write the code for that. Now, what I'm going to do is actually add a listener to our read line interface. So I'm going to listen for the users input. And the event for that is rl.on. Mine. And then we're going to pass it in our callback. Now this callback is going to have the user's input. And now we're going to decide what to do once we get the user's input. So obviously, what we want to do is check if the user's input is correct. And if it is correct, we are going to close the application. And now what happens if it isn't correct, we're gonna say else. And then I'm going to reset the prompt. So I'm just gonna say R dot set prop. And I'm gonna say, let's actually make this more informative. So I'm just gonna say your answer. And then we're just going to print out what they wrote. user input, is and correct. And we're going to build a forward slash. And before that, I'm just going to say, try again. So now let's enter. And now remember, once we set the Prop, we actually have to call it. So now I'm just going to say RL dot prop. And now if we just take a look at what we have so far, this is basically going to give us a loop. So we set a line event listener. Now when the user enters input that's going to trigger this line input, we're going to test to see if what he gave us is correct. And if it is, we're just going to close that but patient. And if we close the application this on close method is going to execute, it's going to say, correct. So now let's see what happens if we give it the wrong value. Is it going to execute the else statement? And it's going to set the prompt your answer have so and so is wrong. And that is going to prompt the user again. And basically, this line event is going to keep executing until the user enters the correct input. So let's actually take a look at this in action. So I'm just going to clear the terminal. And before I execute, let me just say, intro as to say, oops, Ctrl S to save. And now I'm just going to hit node app. And it's gonna say what is one plus four, I'm going to say banana. Incorrect response, please try again, I'm going to type banana again, your answer banana is not correct. And you can see that this will go on indefinitely. Now, if I go back up, and let's actually see what it was, what is one plus four, I'm just going to type in five. And you can see we get the output of correct and then exit the application. And this tutorial, we're going to be talking about the file system module. Now what the file system module allows us to do is work with the file system. And what I mean by that is that it allows us to create files, read files, delete files, create folders, stuff like that. So to get started We're going to have to require the file module into our project. So I'm just gonna say const Fs is equal to require Fs. So now that we have the file system module within our node application, let's actually use it. Now. If I hit Ctrl, B, you can see that all I have is my app.js file within my Node JS tutorial folder. So let's actually create a file. So this one's gonna create a file. And we're going to say Fs dot write file. Now, the first argument is going to be the name of the file. So I'm just going to say example, dot txt. The second argument is what you want to write to the file. So I'm just going to say, this is an example. And the third argument is going to be a callback, and this callback is going to have a parameter of error, in case anything goes wrong. So I'm just gonna say error. There we go. So let's actually finish writing this. So I could say, if error, we're just going to print out the error. Otherwise, we can say, file successfully created. So I'm just gonna write file successfully created. So now if I was to save this, and let's run this node app, you can see that we get file successfully created. And now if I hit Ctrl, V. good not to be in the console. And when I do that, Ctrl B. Now, you can see that we have a newly created file called example, dot txt. And if we look in it, we see the data that we wrote to the file. Now that we created this file, let's actually read it, let's open up and read it. So if I was to say Ctrl V again, and I'm just going to go to App dot j, s, and within this else statement, let's put all this code within here. And now I'm going to say Fs dot read file. And within here, the first argument, much like the right file method, is going to be the name of the file that you want to read. So I'm just going to say example, dot txt, the second argument is going to be the encoding type. Now I'm going to leave this blank because I want to show you guys what happens when you don't leave an encoding type. And then the third argument is going to take a callback function. And this callback function has two parameters, it has error, and it has the file that you actually want to read. Now in here, I actually want to show you guys what the file looks like. So we're going to do the same thing that we did and the right file method, I'm going to check if there's any errors. And if there are no errors, I just want to print the file itself. So now if I was to save this, go to node app. Now you'll see that the file was successfully created. And then you see that when we print out the file, we get this buffer stream. And then we get this bunch of numbers following it. Now the buffer stream stores data and binary. Okay. So what we need to do is specify the encoding type that we want it to be displayed as. So up here, we're going to go up here. And I'm just going to pass in you TF a. So that's the encoding that I want. And now if I was to save this, go to node app. You can see that file was successfully created. And we're successfully reading the contents within the file. Alright, so now that we know how to create and read files, let's actually cover a few more methods. So what I want to do is start with a fresh examples. I'm just gonna comment this all out. I'm just going to highlight everything Ctrl backslash, and that's going to comment everything out for me. Now what I want to do is let's say that when I created this example dot txt file, that I really didn't mean to call example dot txt, let's say I wanted to call it example to, for instance, well, I could use the Rename method. So I could do something like this, I can say Fs dot rename, and rename is going to take in three arguments. The first argument is going to be example, dot txt. And that's going to be the name of the file that we want to rename. The second argument is going to be what we want to rename the file to. So I'm just going to say example two, dot txt. And the third argument is going to be their callback function, which has a parameter called error. And we're going to do the same thing, as we've been doing for all these asynchronous calls, we're just going to say, if error, we're just going to print that out to the console. If there's no error, and everything went fine, we're gonna say successfully rename the file. So I'm just gonna say successfully rename the file. So now, if I hit Ctrl, S to save, and now let's run this, you'll see successfully renamed the file. And it says the leader from this, and that's probably because it hasn't updated yet. So if I close this, and I'm just gonna hit Ctrl, B. And you can see that within our package explorer, that our file has been renamed to example two, dot txt. And if I open this as the same exact file that re created, couple more methods that I want to go over. So I'm just going to hit Ctrl. B. And let's say that, once I comment this out, let's say that when I was creating the file that I forgot to add something towards the end of the file, so what do you want to do, I want to append data to the file. So I'm just going to say Fs that a pen file is going to take in three arguments, it's going to take in the name of the file, I'm just going to say example, two dot txt, the second argument is going to be the data that you want to append to the file. So I'm just going to say some data being upended. And the third argument is going to be the callback function. And this is going to have an error as a parameter passes and, and we're gonna say if error printed out to the console. Otherwise, we're gonna print out that we successfully appended data to the file. So I've successfully appended data to file. I'm just gonna move this over so you can see. And now if I save this, and execute this, so node app, you'll see successfully appended data to the file. So let's actually take a look at our file. And you can see that our file has been changed. So before we had this as an example, and then we appended on data to the end of the file. And the last method that I want to cover within this tutorial is how do I delete a file. So for example, we did all this and let's say that I've had enough with this file, I just want it gone. So let's just comment this out. And this is going to be the final method that I go over. So we're just gonna say Fs dot unlink. And the first argument is, obviously, you guys should get this by now. It's going to be example, two. Example two dot txt. And the second argument is going to be a callback function and have the parameter of error. And within here, if ever printed out to the console, if there's nowhere where we're just going to say successfully deleted the file successfully. So now if I was to save this, and now execute it, you can see successfully deleted the file status up here deleted from this. So if I close this, and if I was to hit Ctrl B to bring up the package explorer, you can see that the file I no longer exist. And this tutorial is going to be part two of my file system modules tutorial. Now in the previous tutorial, we went over using the file system module to work with files. And this I want to go over how to work with folders. So to get started, we're going to have to require the file system module. So I'm just going to say const, Fs equals require, and then Fs here. Alright, and now what I want to do is I'm going to say fs.mk Dir. And what MK dir stands for is make directory. And our directory is is a folder. So now here, it's going to take in two arguments, one is going to be the folder name that you want. So I'm going to give it the value of tutorial. And then we're going to pass in the callback with an error. And we're just going to say if error, console dot log error, oh, we successfully created the folder so on so say, console, log folder successfully created. So now if I was to save this, and now before actually run this, I'm just going to hit Ctrl. b. So you don't see that there's any magic happening. So all I have is my Node JS tutorial folder, and app.js file. So now, if I go here, type node app, you can see that we get the output a folder successfully created and that our tutorials folder has been created. Now let's say that I actually want to delete this folder. So I'm just gonna hit Ctrl V again. And this is actually going to give us an error, but I'm just going to show you what the error is, is basically going to complain that this folder really exists. So I'm just going to say Fs that are m, and r M stands for remove, and then dir and that stands for remove folder. Now I'm going to give the folder name, so we call it tutorial. And this is also going to take a callback, which gets an error. So now if I say if error, console dot log the error, oh, we're gonna say successfully deleted the folder successfully deleted the folder. So now if I was to save this, and now execute it, you see that we get an error file already exists. And that's because the tutorials folder already exists. And we're trying to create another folder named the same thing. So I'm just going to hit Ctrl V. Again, delete that tutorial folder, I'm just going to hit delete, confirm that Ctrl V again, let's execute this. And you can see that we successfully deleted the folder. So if I go up here, hit control B, you'll see that it doesn't exist. So first thing we do is we create a folder called tutorial. And then if this is successful, then we're going to delete the folder called tutorial. And you can see by output that we successfully deleted the folder. Now this is too fast. And that's why you wouldn't be able to see it if we had the package manager open. So now that we know how to create and delete a folder, what I want to do now is create a folder and then create a file within that folder. So I'm just going to hit control B. And we can leave this make directory. So we're going to make a folder called tutorial. And if it's successful, it's going to execute this else block. So let's remove this. And then within here, we're going to create our new file. So to do that, I'm just going to say Fs dot write file. Now write file is going to take in three arguments. It's going to take and the name of the file, but in this case, we've got to give it the full path. So I'm going to say dot four slash. And what dot forward slash means is I want you to start relative to App dot j s. And then I want you to go inside the folder called tutorial. So I'm just going to hit Ctrl B just to show you. So app dot j s start here. There's going to be a folder called tutorials. I'm going to go in inside that folder, tutorial. And now I want to you to create the file called example, dot txt. So if I hit Control V again, and then the second argument is going to be what the data that you want, I'm just going to write 123 doesn't matter for this example. And then the third argument is it going to be a callback function which gets an error. And then within here, I'm going to write if error, console dot log the error onto the console. Oh, we're gonna write successfully created, file, successfully created file. So now let's save this. So I'm just gonna hit Ctrl. S, down here, node app. And you can see that it says successfully created file down here. So now if I hit control B, and I'm going to go up here and then hit control B, you can see that we have our newly created tutorial folder. And within here, we have our example dot txt. So if we go in here, you can see it has the data of one, two, and three. Now, what I want to show you is, how would I delete a folder that has a file within it. So you might be saying, if I just go back here, hit Ctrl B, that can't I just use Fs dot remove directory in order to do this. Well, I am actually just going to comment all this out. And what will end up happening if I use the Remove directory function is that is that I'll get an error. And the reason for that is, because if I use the Remove directory function, it has to be used on a directory or folder that is empty. So just to show illustrate this, that's going on right this quick remove directory function. And if there's an error print it else, we're just gonna print deleted folder. So I'm just going to hit Ctrl S to save. And I'm just going to type CLS to clear the terminal node app. And you can see that we get an error directory not empty, that we're trying to remove a directory that has a file within it. So in order to fix that, let's delete the file first. So I'm just going to say Fs dot unlink. And the first argument is going to be the file. So remember, dot forward slash, and then we have to go into the tutorials folder. And then I named the file example dot txt. Next argument is going to be a callback function which has an error, I'm just going to say if error, print that out. If there's no error, then what I want to do well, if there's no error, that means that I successfully deleted the file, which means I can now successfully remove the file. So I'm just going to copy this. And I'm going to put this within the else block here. Add some semi colons. And now if I was to save this, and now execute it, you can see that we have deleted folder. And you can see up here deleted from this. So if I go hit control B, you can see that the folders been successfully deleted. So what did we do? First, we deleted the file that was within the folder. And then if that was successful, then I wanted to delete the folder itself. Last example that I want to do is what happens when there are multiple files within a folder, and you want to delete all those files. So I'm going to cheat a little bit, and we're just going to create it within our package explorer. So I'm just gonna say new folder, and we're gonna call it example. And I'm just gonna give it two files. I'm just gonna say a dot txt. And the second file is going to be b dot txt. All right, so now I have my folder and I have my two files. So how would I go about doing this? Well, there's a method called Read directory. And what read directory does is it gives you back the list of files that you have within that folder. So let's actually call it so I'm just gonna comment on this out. comment this out. And then I'm just going to type Fs dot read directory. Now the first argument is going to be obviously the name of the directory. And in this case, we call it example. And then the second argument is going to be a callback function. first parameter is going to be error. And then second parameter is going to have files now files is going to be an array with the name of the file. So now, we can test if there's an error, all we're gonna do is print out the error, there is no error, we're gonna print out files, I'm just gonna print out files just to show you what files contains. So if I save this, run this and the console, you can see that we have our two files stored within an array, a dot txt, and B dot txt. So now let's actually loop through this array and delete everything. So now I'm just going to say for let file of files. And then within here, we can start deleting each file individually. So I could say Fs dot unlink. And then we're going to give it the file name. So it's going to be dot forward slash, example, then it's going to be the name of the file. After that is going to take in an argument callback for an error. And if there was a problem deleting that file, it's going to print it out to the console. If there wasn't, we're just going to say, successfully deleted file. So and So So, so successfully. deleted file. So now if I was to save this, and now execute this, you can see successfully deleted file once twice. And if I hit Ctrl, B, you can see that we have an empty folder called example. In this tutorial, we're going to be talking about the readable and writable screens. Now what these screens allow us to do is basically be able to read and write data more efficiently. And the way that they accomplish this is by reading and writing data, and chunks as opposed to reading and writing the data all at once. So to get started, we're going to have to require the FS module or the file system module. So I'm just going to say const. fs is equal to require Fs. Now that we have our file system module included, we're going to create a readable stream. And there's a method called Fs dot create reach screen. And now I need to give it the path. So if I just hit Ctrl, B, you can see that I have an example dot txt file here, and it has a bunch of texts that we're going to be reading in. So if I head back to App dot j, s, hit Ctrl V, again, we're just going to give it the path of dot forward slash, example dot txt. And then that's it. Now this is going to return to us a readable stream. So I'm just gonna save it within a variable. I'm just gonna say cons reach stream is equal to Fs dot read stream. And then here, what we can do is listen for an event. Now the return object inherits from the event emitter class. So that means we could listen for events to occur. And one event that we want to listen for is the data event. So I'm just going to say read stream.on data. And then this is going to take a callback function. And now we're going to get a chunk of data and return. So every time we read a piece of data, this event data is going to be invoked. So this callback function is going to be called every time we get a piece of data. So now I'm just going to print out the data onto the console. And you're going to see why I call it a chunk and not the full file in a second. So now if I save this, go to node And you can see that we read this data within two chunks. So we have to print out here, we have a buffer here, and a buffer here. So let's actually set the encoding type. So it's a lot easier to what the sources, and we're just going to set it to UTF, eight, and save this. And now let's rerun this application. And there you go, you see that we read our text file. So what are the benefits are reading this in a chunk, as opposed to loading the whole file? Well, for one, when I get this chunk, I could immediately start manipulating that chunk. So I don't have to wait for the whole file to load in order to manipulate it. Or let's say that I don't want to manipulate this chunk of data that I got already, I want to send it to a new file, well, I could start sending that data to a new file, while I'm reading in the data itself. So let's actually send it to a new file. And for that, we're gonna have to create a writable stream. So I'm just going to go here. And I'm going to say const. Right stream is equal to Fs dot create, write stream. And within here is going to be the name of the file that I want to write to. So I'm just going to call it example two dot txt. And now within here, what I can do is, instead of waiting to get the whole data, I can start writing chunks to the new file. So within here, instead of just printing out console dot log, chunk, I can say, right stream dot, right. And I could write this data to a new file as I'm reading it. And so I could say chunk here. And let's say that. And now if I run this application node app. So now if I hit Ctrl, B, you guys see our newly created file. And if I go here, you can see that we wrote onto a new file. So basically, what's happening here is I'm able to write chunk by chunk, and our example two chunks, in order to get the full file, I'm able to start writing before the file is fully loaded. And that's pretty much the power of using a stream. This tutorial, I'm going to show you guys why you should be using streams by trying to read a very, very large text file. So to get started, I'm just going to show you how big the file is. So I'm just going to hit Ctrl. B, we have our large file dot txt file here. And if I click review and explorer, right click Properties, you can see that the size it's about 2.7 gigs. So let's actually take a look at what would happen if we were to use the read file method from the file system module. So now, if I was to execute this and type node app, you see that we get an error and the error says file size is greater than the possible buffer. Now, what does that mean? Well, the read file uses a buffer, but it uses a full buffer. Now what that means is that I need at least 2.7 gigs in memory, in order to load this file, because this file has to be loaded, because this file has to fit within the buffer. And it's saying, Hey, your buffer size is just too small for this file. Now, I'm just going to comment this out. And now what we're going to use is a readable stream. So I'm just going to comment this out. And then we're going to uncomment this. And by the way, I have tutorials on both readable streams and using the read file method. So now I have the stream will look what happens when I execute the code now. So if I was to save this, and now execute it, you can see that are readable stream has absolutely no problem reading this file. So I'm just going to hit Ctrl C to cancel this, because I don't want it to finish, you know loading the entire thing. But why can this be accomplished with streams but not using this read file method? Well, one, a stream uses a buffer awesome, but it doesn't use a full buffer. It uses a very, very small buffer and what That allows us to do is basically what's happening is that you're ending out reading the file in chunks, you're not reading the entire file at once. So basically, every time a data event occurs, I am getting a chunk of the file, I'm not attempting to read the entire file at once. And therefore, the buffer size could be a lot smaller, as opposed to a read file method, which uses a full buffer, which needs to be big enough to load the entire file at once. And then server streams allow for smaller buffer size, which is memory efficient. And for data to be read and written and chunks. And this tutorial, we're going to be going over pipes. Now what a pipe allows us to do is basically take a source stream, which is just a readable stream, and send it over to his destination, which is just a writable stream. So in the last tutorial, we went over readable streams and writable streams. And basically what we did was create a read stream. And then from there, we create a write stream. And then we attached an event listener to the reach stream. And every time we got a data event emitted, we read a piece of the chunk from the read stream, and then rewrote out that chunk to where we wanted to send it. So there's actually a much more simpler way. And the much more simpler way is just to get rid of this. And all we're going to do is say restream dot pipe. Now pipe is going to take what restream gives us and it's going to pipe it into our right stream. So now if I was to bring up the terminal, and just type node app, and hit Ctrl V, you can see we have our example Tex. And then we created our example two dot txt. So the pipe method is basically a shorthand version for all that stuff that we wrote in the last tutorial. So all we need to remember is, in order to use a pipe, we need two streams, we need a source stream. And we also need a destination stream. In our case, the reach stream is our source, this is the file that we want to read in, then we call the pipe method on the retrieve. And then this is going to take the destination where do we want to send this data to, and that's to the right stream. So now I want to talk about pipe chaining. So let's give a more complicated example. And for that, I'm going to bring in another module. And I'm going to bring in Kant's z lib. Now z lib is a module that is for basically compression, compressing files, I'm just going to say require z lib. Now what we're going to do is create a transform stream. Now, what a transform stream is basically is what it does is it takes the input. So for example from our read stream, and then when it receives that data, it manipulates that data into something else. And in this case, what it's gonna do is compress the data. So I'm just going to create a transform stream. So I'm just gonna say cons. Gs is equal to z lib dot create jesup call that method. Now this is going to return our transform screen. And now within here, a set of saying reach dream, what I can do is send that data that reach stream is giving us and I could pipe it into our Gs. Now what GS is going to do is take the chunks of data that is reading at a time, and it's going to manipulate it and compress it basically. So you're going to get a compressed version of the read stream. And then from here, we're going to pipe it out to our destination, which is our right stream. So now if I was to run this, let's save it. Now I'm just going to hit Ctrl B. And if we go here to example, two dot txt, you can see that we accidentally did not change the type and that's my fault. So the type that we're creating create write stream should not be a txt file. It should be a.gz file and that's the compression type. So I'm just going to save this and let's run this application. Again. Now I'm going to hit Ctrl B. And you can see that we get an example two.txt.gz file. Now, if I clicked it, it's going to say that Visual Studio Code cannot open this. So I'm just going to right click it, reveal an explorer. And you can see that zip file is basically a compressed file. And I'm going to double click it. And you can see that our example two dot txt files here and with our tax. So now let's give just one more example just to get the hang of it, chaining pipes and using a transform stream. So we saw what happens when we compress the file and then write it. So let's go and reverse, we're going to take our source, which is compressed, we're going to uncompress it, and then we're going to write it. So from here, let's just go back to Visual Studio code. Let's go back to App dot j s Ctrl V. And instead of saying create jesup, what we want to do is create unzip. So I'm just going to go here and say create g unzip. And we're going to change this variable to unzip. And now this is going to be our transform stream. So I'm just going to copy this, paste that here. And now what happened, well, read stream has changed, right, so now I want the compressed version of it. So let's go over here, we're going to get rid of the encoding type. The compressed file is called example two dot txt Gz. So I'm just going to copy this, I'm going to paste this in here. Now this input, this reach stream is going to be piped to G unzip, which is going to basically uncompress the file, and then it's going to send it off to our destination. So what do we want our destination to be called, we could pretty much name this anything you want. So I'm just gonna say uncompressed dot txt. So now if I was to go ahead and save this type node app, execute it, we hit Ctrl B. And you can see that we have our uncompressed txt file. So if I click this, you can see our example Texas here, and that is successfully uncompressed. In this tutorial, we're going to go over the HTTP module. Now what the HTTP module allows us to do is basically create a web server with node j s. So to get started, we're gonna have to require the HTTP module. So I'm just gonna say const. HTTP is equal to require HTTP. Now from here, we can call method called create server. And this is going to give us a HTTP server object. So I'm just going to say const server is equal to http dot create server. Now, this method is going to take a callback and this callback is going to give us a request object as well as a response object. So let's just do that. Now, the request object is what the client requests from us. So for example, if I am on Google Chrome, and I type in www.google.com, I am requesting something from Google. Now Google server is going to take that request, and it's going to send me a response back. So the most simplistic example that I could give you is I could send a basic text back to the client. So I could say rez, and that's going to be my response, I'm going to say, right, and I'm just going to pass in a string. So I'm just going to say, Hello world, from node j, s. Now within here, I haven't actually sent the response back, I just told it what it is. So in order to send the response, I'm going to say res dot. And now this is going to take care of our HTTP dot create server method. Now there's one more thing that we have to do to get the server up and running. And that's the total node j s. What port that I want to listen for requests that song is going to say server dot listen. And we're gonna listen on port 3000. So now if I was to save this, and now go down, Here type of node app, you can see that our server is up and running. Now I'm going to go to Chrome. And within here, I'm going to type local host, colon, and then the port, which we assigned was 3000. So that's where we're listening for requests that if I hit Enter, you can see that we get a response back from the server, hello world, from node j, s. So now from here, what we can do is actually listen to requests, different routes. So let's actually take a look at a property of the request object. And one of the properties is called URL. So instead of just saying, hello world, from node j, s, I only want to say hello world from node j. s, if it is the root domain, so I'm just gonna say request dot URL is equal to forward slash, then I'm gonna say res dot write Hello, world from Node JS. And then don't forget that we have to send the response back to the client. So we're going to call resident and and now if I was to save this, and we're going to is going to hit Ctrl. C to kick us out of the server. And then we're going to start the server back up again. So we get our updated changes, we're going to go back to Chrome, hit Enter. And you can see that it works exactly the same. If we were to add an else statement here. So let's say they are not using the root domain, aka, say rez dot write using some other domain, and then we're going to send that out to the user. And that's actually Ctrl. C this to stop the server. And before we start up the server, I have to save so I'm just gonna say Ctrl. S to save node app. And now here, instead of localhost colon 3000. I'm going to say local hosts, banana. And let's see what response we get. And the response we get back is using some other domain. Now this response is going to be for anything we type because we put it in the else block. So if I type that, I'm going to get the same response. And then if I go back and just have the forward slash, you can see that we get the Hello World from node j s output. And this tutorial, we're going to be going over how we can serve static files, using the HTTP and file system module. So to get started, I'm just going to hit Ctrl. B to bring up the package explorer. And you can see that we have a static folder. And we have three static files. Now, these files is a JSON file, an image, a PNG file, and an index dot HTML file. So what I want to do is make a request to the server and have the server send these files back to me. So I'm just going to hit Ctrl B to get rid of that. And the first thing we're going to do is actually required modules on this gonna say const, HTTP equal require HTTP. And then our second module is going to be the file system modules, I'm just gonna say require Fs. Now, first step to do this is to actually create the server. So I'm just gonna say HTTP dot create server. And this is going to take a callback, and we're gonna have a request object and a response object. Now I'm going to call a method on that server object. So I'm just going to say that listen, and we're going to listen on port 3000. Now, let's say that I want to read in a HTML file, for instance. So let's go up here. And what I can do is create a readable stream. So I'm just going to say can't reach dream, it's going to be equal to Fs. dot create, reach dream. And then within here, we're going to pass in the path. So I'm going to say dot forward slash, because it's going to be relative to App dot j s. Now I need to go inside the static folder. And then the name of the file that I want read in is called index dot HTML. Now what I want to do is actually write a header for my response. Now what a header is responsible for is the let the client know what kind of data that I am expecting. So I'm just gonna say rez, that right head. And then within here, we're going to pass in the HTTP status code. So I'm going to pass in 200. Now 200 means that everything went okay with your request. And then the second argument is going to be what the content type, so I'm just going to hit content type. And then we're gonna pass in text slash HTML. All right, so now that we've written our header, I'm just going to take you guys to Google Chrome real quick just to look up the status codes. Now you can see that HTTP 200 means that the request has been successfully completed. So whatever the user requested from the server, that means everything went fine, as I said, and there's a bunch of HTTP status code. So let's look at another one. So another common one is four, four. So you're going on a website, and you accidentally Miss type the URL and they give you a not found error. So that would be a 404 error. Now, let's go back to our Visual Studio code. And let's complete this, I'm just going to go down here. And within here, I'm just going to pipe the reach stream into where I want to send it. So I'm just going to say reach stream dot pipe. And where do I want to send this file, I want to send it to the user. So I'm going to pass in rez, now read the response object is also a writable stream. So I'm piping it to the response object. So now I'm just going to save this. Let's go back to Chrome. I'm going to go here, Google, and I'm going to type localhost 3000. And I should probably be noted that you should start up your node applications, I'm just gonna type node app. Now let's go back to Google Chrome, hit refresh. And you can see that our HTML file has been successfully sent. So let's actually try to send the other static files. And this was pretty much straightforward. So all we have is if I hit Ctrl, B is an image and a JSON file. So I'm just going to hit Ctrl V, again, now all we need to do is obviously change the file that we're reading in. So instead of index dot HTML, let's do example dot JSON. Now I'm the content type is obviously not a text slash HTML file. So we're gonna have to pass in application slash JSON. And now, if I was to save this, hit Ctrl C, so we're going to restart the server, I'm just going to clear out the terminal node app. Now let's hit refresh. And you can see that our JSON file gets loaded and sent to the client. Now let's load up that image. So now the same exact thing, I'm just going to hit Ctrl B, because I forgot when I named the image, I named it example dot png. So I'm just gonna change this to P and G. And instead of application dot JSON, we're gonna just gonna remove this. And we're just going to go here and type image slash PNG. So now if I was to save this, now, we got to restart the server Ctrl C to cancel that out, no app. Now, if I go to Chrome, hit refresh, you can see that my image has been loaded. So that's basically the ins and outs of how you would serve a static file using the HTTP module, as well as the file system module. In this tutorial, we're going to be going over how we can create our package dot JSON file. Now what the package dot JSON file is responsible for is basically holding all our metadata for our project, metadata being the name of the project, the version number, etc. So to get started, what we're going to use is called the node package manager. So I'm just going to type NPM And then I'm going to type in net, which means initialize, I hit Enter. And you'll see that we get a bunch of jargon. So what do we want to name, the package, by default is going to be called the name of the folder that you're currently in. So up here, you can see no GS underscore tutorial. And it says the default will be no GS slash tutorial. So I could just hit enter, that's fine with me the version number 1.0 dot zero, that's okay. Description. So what is this package about? What is your project about? And we're just gonna say tutorial, because that's what we're using it for. And then the entry point is pretty important. And it lets us know which file should be used to start our node application. So for example, if I was making a website and uploaded to a server, it will let the server know that that was our entry point to our application. Test command. Let's ignore that for now. Enter, and Git repository is pretty self explanatory. Is it going to be your Git URL, hit enter keywords, we're gonna leave that blank as well. Author, go ahead and write down your name. license is C as defined by me, then it's gonna say Is this okay? And we're just gonna say, yeah, that's fine. So you might think that nothing has happened. But if I hit Ctrl, B, you can see that we have our package dot JSON file created. And if I take a look at this, open it up, you can see that package dot JSON is just a JSON file. And it has our configuration setting. So the name, the version description of our application, the entry point, scripts, author, and license. And basically, in the next tutorial, what we're going to end up doing is actually going out and installing external packages and including them within our own project. This tutorial, we're going to be going over to node package manager in order to install packages. Now our package is is basically reusable code that we can include within our own application, it's a folder with one or more modules within it. So to get started, we're actually gonna head over to Chrome real quick. And there's actually a website called NPM, J s.com. Now NPM, J s.com is where we can actually look and discover new packages that we can include within our application. So I'm just going to pick out a package, and we're going to install it and then use it. So I'm just going to scroll down. And you could use the search up here. Or, let's just pick a popular package. So you can see packages that a lot of people are installing. and scroll down more. And let's pick lower das. And then here, we're given a bunch of instructions. So it says in order to install this package, I just have to type in this command NPM i i in shorthand for install, and then the name of the package. So in this case, the packages name is lodash. So if I head back to Visual Studio code, and I type NPM, install lodash. You can see that it goes out, and it downloads the package for me automatically. And now if I head back to my package dot JSON file, the JSON file that we created in the previous tutorial, you'll notice that we have an extra property. And within this property is called dependencies. And then it gives us the name of the package we installed, as well as the package version that we installed. So now if I was just to hit Ctrl, B, you would see that we have a extra folder and this extra folder is called node modules. So if I opened this up, you can see that our lodash installation is stored here within this folder. So now this is all fine and dandy, but how would I now use lodash within my own personal project, so I'm just going to hit Ctrl B. And we're going to close out our package dot JSON file. And we're going to go to App dot j s and basically what we're going to do is require it so I'm just gonna say cool. underscore is equal to require lodash. And now from here, let's actually use it to prove that this is working. So I'm just going to say underscore dot fill. And fill is basically going to take an array. So I'm just going to pass in an array 12345. And the second argument is going to take an A value, what do you want to replace these numbers were, so I'm just going to say banana. And the third argument is going to be the start index. So what I want to do is start at index one. And the last argument is going to be the end index. And since we have five elements within our array, the last index would be four. So let's actually store this within a variable. So I'm just going to say let example is equal to that. And we're just going to print out this onto the console. So I'm just going to hit Ctrl S to save when I go to node. And you'll see that we require lodash into our application. And we've tested that one of the methods within lodash is actually working. So we get a new array, and we filled in index 123 with the value of banana. And let's say that for whatever instance that you installed the wrong module, or you want to get rid of a module, so if I hit control B, and we're just going to bring up the package dot JSON file and hit Ctrl V again, what I can do is I can say NPM, uninstaller, and then the package name, which is going to be lodash. And you can see that lodash is removed from our dependencies. And if I hit Ctrl V, you can see that our node underscore modules folder no longer exists. And that's because we have no dependencies that our application is using currently. In this tutorial, we're going to be talking about semantic versioning. Now, what semantic versioning is, is basically just a standard that a lot of Node JS packages follow and allows for us to know what kind of changes have occurred, and the updated version of the package. So to get started, you can see that I have my package dot JSON file open. And I have a dependency install called lodash. Now within here, you see the version of the package that I installed with the carrot sign. And we'll talk about the carrot sign within this tutorial as well. But for now, I want you to focus on these three numbers. The first number four is going to represent the major version of this package, the second number is going to represent the minor version. And the third number is going to represent the patch version. Now the major minor and patch numbers all have different meanings. So for example, right now, the latest version is four point 17 dot 11. If I wake up tomorrow, and lodash is updated, and it says the latest version is four point 17 dot 12. That means that that was a patch update. Now all I patch update means is that they implemented some bug fixes. Now likewise, same thing happens, I go to sleep, they update lodash tomorrow, and instead of four point 17 dot 11 is four point 18 dot 11. So that means that there was a minor update. Now when a minor update does is it adds new functionality. And it might deprecate some of the old functionality, but you could still use it. So it's a non breaking change update. And finally, if I was to go to sleep tomorrow and wake up new version of lodash is updated. And this time we get version 5.0 dot zero. So what does that mean? That means that there was a major update pushed out to lodash. And what a major update indicates is that there was a breaking change. So that means version 5.0 dot zero is not compatible with the code four point 17 dot 11 or any version of four. So now let's talk about this carrot character. And this carrot character was put there automatically When we type NPM, install lodash. Now what this carrot character symbolizes the following. So the following rules, if you will. So this means that whenever I use the carrot character, that I do not want you to make any major updates. So that means right now I'm on version four as the major. But if there is a minor update, or a patch update, go ahead and download those new packages. Now, there's another symbol called the tada symbol and total symbol is right next to the number one on your keypad. And that means that you want the following to occur. That means you only want patch updates. So let's say I'm on four point 17. Right now, that means I only want you to change the last number. So for example, if for Part 18 comes out, this total symbol will say, hey, do not update to that package. And last but not least, let's say that you don't want the tilde or the carrot sign up here. So for example, you don't want the carrot sign to update the minor or the patch. And you don't want the Tilda to just update the patch, what you can do is remove the carrot or the tilde a sign. And this guarantees that the only version of lodash that you will ever have within your package will be four point 17 dot 11. In this tutorial, we're going to set up our first Express server. Now all Express is is basically a web framework for node j s. So in the previous tutorials, we use the HTTP and file system module, in order to serve static files. With Express, however, you can see that we can accomplish that and much more with much less code. So to get started, I'm just going to go over to Chrome. And here is Express jSs official website. So you can see up here that they have guides for you, you could reference the API. And basically, this is just the documentation for Express. And you can see that they give install instructions here. Now, if you didn't go to the official website, or you didn't know that they had an official website, he probably would have went to NPM j s calm, that Express is a publicly available package for you to download and install. And you would have just typed Express within the search bar here. So I'm just going to head back to Visual Studio code. And the first thing that we need to do is actually create our package dot JSON. So I'm just gonna say NPM and net, and I'm going to pass in the flag, yes. Now, when you pass in the flag, yes, you basically skip all these configuration questions that they ask you when you type NPM. And net. So now that we have our package, JSON, we can actually install express itself. So I'm just going to type npm install, express, you can see that it's downloading right now. And now from here, let's actually require Express JS into our project. So I'm just gonna say const. Express is equal to require Express. Now, when I require this module, this Express module, what I'm getting back is a function. So I'm just gonna call that function. So I'm just gonna say Express. And this function is going to return an object and this object is going to have a bunch of methods that we can use within our application. So let's store this object within a variable. And by convention, we will call that variable app. So I'm just going to say app is equal to express. Now from here, what I can do is call a method called get. Now the first argument of get is going to take the route. So we're just going to say forward slash. And then the second argument is going to be the callback function. And it's going to be request and response. And then all we're going to do is say res dot send. Hello, world. So this is going to be our first application using Express. So when the user visits the route forward slash, what we're going to do is Sunday response of hello world and that with a semi colon And then the last step that we need to do is actually give it a port to listen to. So I'm just gonna say app dot listen. And we're just going to listen on port 3000. So now if I was to save this type no app. And that's going to run the server, head over to Chrome. Now, I'm just going to open a new tab. And I'm just going to type local host 3000. And there you go. This is our first Express JS application. And you can see that we got a response of hello world. And in the upcoming tutorials, we're going to dive deeper into the Express web framework. In this tutorial, we're going to work more with the HTTP GET requests. And we're going to be talking about Curie string and route parameters. So to get started, we created a basic Express application from the previous tutorial. And we gave it one route, which is basically the index route, or you could refer to it as the homepage. And we just said, Hello world. So if I was just to run this node app, go to Chrome. Go to local host. And we're going to put 3000, because that's the port, and you see our basic route. So this is the forward slash route. So now let's give it a another route. So I'm just gonna go here, I'm just gonna say app get. And we're going to give it another route. And I'm just gonna say example. And within here, we're gonna pass in a call back. And now we're just going to say rez, that send heading example, route. So now if I save this, I'm just going to hit Ctrl. C to kick us out, we're going to restart the server, so that it starts with our newly saved file, head over to Chrome, hit refresh, you see that our index page is still working. And if I go here and type example, you can see that we create another route, and that it's hitting the example route now, as opposed to the index route. So now let's go back here, this is all fine and dandy. Now I want to talk about Curie strings and route parameters. So I want to start off with route parameters. And we're going to create another route. So I'm just gonna say app dot get. And I'm gonna say example. And within here, I'm going to give it these colon, and I'm just gonna say name. And that's going to be the name of that route. And I'm just gonna say, ah, and then the same exact thing. So I'm just going to pass in a callback, I forget to add. And then this time, what I want to do is access from the request object. And I'm just going to say params. And what we want to do is actually print this out onto the console. Let's see what we get. And the idea is that I want to get the value of name. And ah, so we're just gonna say res dot send. And we're just gonna say hitting, actually, let's say example, with route params. So we're just gonna save this, hit Ctrl C, I'm just going to say CLS, no app, head over to Chrome. We're going to hit refresh. So our examples working, but now, we're going to pass information in so I'm just going to pass in name. So Pedro and an age, I'm going to put 99. So I'm going to hit Enter. And you can see example with rope params has been executed. So now if I take a look back at Visual Studio code, you can see that when we hit this route here, and we print out what's within our request dot params, we get an object. And this object contains the properties name and age, and the values of Pedro and 99. So let's give a more detailed example. Instead of just giving a generic answer. I'm just gonna print send the user back his name. So I say name plus Here, I'm just going to say ah, and don't forget that this name, property and age is within our requests that params. And all request dot params is, is an object. So I could say request dot params dot name to access the name value. And I could say request dot params dot age to access the age property. So now if I save this, and we're going to reset the server, CLS to clear the terminal node app, head over to Chrome, hit refresh. And you can see that we're sending back to the user Pedro in 99. And that we get the same output because we're still printing it. So that's how we would get data from the user using route parameters. But there's also another type of data that you could send back. And that's called Curie string parameters. So what is that? Well, if I go back here, and actually, let me just type this up, I'm going to say console dot log. And again, we're going to use the request object because the request object is basically what the client is sending us. So I'm just gonna say, request that Curie. And here in Google Chrome, let's actually cancel this server. I'm going to save this file, restart the server, head over to Chrome. Just going to go up here, hit refresh. Go back to Visual Studio code. And you can see that we get an empty object. Now this empty object is going to be our request, Curie. So it's just a Curie string parameter. And the reason it's an empty object is because we haven't actually passed anything into it. So in order to do that, there's going to go up here, we're going to use a question mark. And then it's going to be the name of the property that you want. So I'm just going to make it up right now. I'm going to give it a name of tutorial, and then followed by an equal sign, and then the value you want to assign it. So I'm just going to say params. tutorial. And now if I hit Enter Here, you can see that's pretty much the same thing that's happening. But if I go back to Visual Studio code, you can see that our request, Curie object is no longer empty. We have a property of tutorial, and we have params tutorial as a value. So now let's say that I want to pass more than just the tutorial. So how would I pass multiple query string parameters. And if we head back to Chrome, all we have to do is remember to start off with a question mark, the name of the query string, and then the value. So if you want to pass in a second, curious string, what you can do is use the Add sign or the app or stamp, whatever you want to call it. And I'm just going to give it sort. And then I'm just going to say equal. And I'm going to give it the value of by age. And if I hit Enter, head over to Visual Studio code. And you can see now that when we print out our Curie string, you can see that we get an object that has tutorial. And it also has the property of sort. So now you might be asking yourself, when should I use a route parameter versus a query string parameter, you should use route parameters when you must have that data. So for example, let's say name was an absolute must, I cannot have a blank name. And I cannot have a blank age. So I would use a route parameter. And let's say that I want to give some optional settings. In that case, I would use a query string parameter. So for example, when we pass then sort, we could be sorting the data by age, and that would be an optional setting, but I would need the name and the age to begin with, so I would use a route parameter for that. And if the user wants to sort the data, then I will use a query string parameter for that. In this tutorial, we're going to be talking about serving static files using Express Now what do I mean by a static file, I mean, your HTML files, CSS, client side JavaScript, images, videos, stuff like that. So to get started, we're just going to require a path module, and is basically a utility module that deals with pass, just to make our lives a little bit easier. And we're finished here, if I go down here, I can say app not use now use, whenever you see app use, it means that I'm using middleware, the first argument is going to be the alias for our static folder. So for example, if I was to hit control B, you can see that I have a static folder here. And what I want to do is give this static folder, an alias, I don't want people outside of my server to know that this folder is called static. But let's take a look inside of it. We have an index dot HTML, we have example that j s. And we have a main dot CSS file, just for an example. So now if I close that Ctrl B, I'm going to call it public. That's going to be the alias for my static folder. The second argument is going to be a middleware function. So I'm going to use a convenient method that express provides us so I could say Express dot static. And then I'm going to say path dot join. Say dirname. R stands for directory name. Now, dur name is a string. And this is going to give us where app that j s is. So if we take a look, by pressing Control B, is going to give us where app dot j s is located. Now I want to go inside to the static folder, because this is where all my static assets are. So if I hit Control V, again, we'll pass in as a second argument, the name of the folder static. So I'm just going to end this call in there says there's some error, and I'm missing a parentheses. So now here, instead of just saying hello world, let's actually send a file. So I'm just going to remove this, say res dot send a file. And we're going to use our path module. Again, to make things easier. I'm going to say path dot join, we're going to give it the directory name that we're currently in. We're going to go inside the static folder. And then I want to serve the HTML file. So the HTML file is called index dot HTML. So now, if I was to save this, go down here, type node app. Let's go over to Chrome. Now we're going to go up here, type localhost 3000. And there you go, you can see our static HTML file has been served. If I type f 12. Let's take a look at the source real quick. I can actually see it. And you can see within our HTML file that we're using public. Now remember, we don't actually have a folder called public, we have a folder called static, but to the client side is called public. And this main dot CSS file. Now this main dot CSS file is working, because you can see that our h1 tag is red. And now if we go back down here, you can see public j s and our example dot j s. And if I go to console, you can see that I printed out onto the console testing client side. So that's basically the basics of serving static files using Express. Now you can use this to use images and videos, and it'll be the same exact process. In this tutorial, we're going to be talking about handling an HTTP POST request using Express. Now an HTTP POST request is typically used when working with forms. So I have my form set up right here. I have an email address field and a password field and if I was the hit submit, that would be an example of a POST request. Now, obviously, we're getting an error from node cannot post to this route. And that's because we haven't actually coded anything yet. So if we take a look at Visual Studio code, you can see our form that I set up, action is going to be the route that we're going to code. So I just put forward slash, the HTTP method is going to be a POST method. Here, we see that we have our email field, and our password field, and our button of type Submit. So now I'm just going to head over to App j, s. And I actually want to code the app dot POST method. So if we take a look at our application of this, it's currently All I have is an app dot get. This is the route and I want doing is serving the HTML file to the user. So in order to remedy this, we're going to use a module that's going to parse the form data for us. And that module is called the body parser module. And that module is called the body parser module. So to get started, we're actually going to have to install this module. So I'm just going to come down here, cancel our server, I'm going to say NPM, install body parser. So let that install. And now from here, what we're going to do is require it into our application. So I'm just going to say Kant's. Body parser is equal to require body parser. And now from here, what we're going to do is use middleware. So every time we use middleware, we're going to call app dot use. So here, I'm just gonna say app dot use, then I'm gonna say body parser dot URL encoded. And then within here, we're gonna pass in an option called extended. And we're gonna set that to false. So and that was the semi colon. And all this is doing is allowing us to parse URL encoded forms, it parses the data for us and attaches it to the request body, the extended option is set to false because we aren't dealing with any complicated objects. All we want is an email and password, which are both strings. So now that we have that set up, let's actually code or app that post HTTP requests. So we have our get here. And now I'm just going to go down here. And instead of saying app dot get, I'm going to say app dot post, the first argument is going to be the route. And as you saw on the HTML file, the action route is the forward slash. The second argument is going to be a callback function with the request and rez object. And now from here, remember what the body parser does, it parses the data for us, and then attaches it to the body of the request object. So now what I can do here is I could say console dot log request dot body. And this is going to give us an object with the properties of email and password. And now from here, usually, when you post something to the server, you usually use whatever the user inputted, and you do some database work. So I'm just gonna say database work, here. And once that database work is done, you assign a response or user. So I'm just gonna say res dot send successfully, post that data. Now, I'm just going to hit Ctrl S to save, go down here, I'm going to type in Node app, start up my server. Let's head over to Chrome. And now if I hit refresh, just to reload it, let's type some random email. Random password, hit submit. So now what happened here was I filled in my email and password I posted to the server, I got a response back from the server saying everything was posted successfully. So if I go back to Visual Studio code, you can see that our console dot log is working. We're printing out the request dot body, and you can see that our form data has been successfully parsed. So if we take a look down here on to the console, you'll see that we have an object With the property, email and its value, and you also have property of password and its value. So that's pretty much how you would make an HTTP POST request using Express and the body parser module. In this tutorial, we're going to be talking about how we can handle JSON data using Express and the body parser module. So in the previous tutorial, we talked about using the body parser module, in order to handle URL encoded data. So what we're going to do is take this form from the last tutorial, and convert it to post JSON data. So to get started, I'm just going to head over to Visual Studio code. And right here, I have my index dot HTML file and our form pulled up, what I'm going to do is add an attribute to the forum. So I'm just going to give it an ID, and I'm going to call it form. And the reason for that is I want to prevent the default submission, I want to post data using jQuery Ajax. So that's how we're going to post JSON data to our server. So now that I have my ID, scroll down, and I already put our jQuery CDN here, just to make the tutorial a little bit quicker. And we're just going to go here, and we're going to include our script. So I'm just gonna say script. Now from here, we're just gonna say document dot ready. And the first thing that we want to do is get our form. So I'm just say dollar sign, pound sign form. And we're going to attach a submit handler to our form. And this submit handler is going to take a callback function, which has an event as a parameter. So now, what I want to do is prevent the default Submit. So we're just going to take the event that we get, and we're going to call prevent default. And from here, we're going to use Ajax to actually make the POST requests. And what we're going to do is post JSON data back to the server. So I'm just going to say, dollar sign, Ajax. And this is going to take a bunch of configuration. So one of the properties that we can use is called URL, and this is going to be the endpoint that we're gonna have at our server. So I'm just going to say forward slash, second property is going to be type. And this is going to be what kind of HTTP requests that we want to make. And we're gonna post JSON to the server. So I'm just gonna say post. third argument is going to be the content type. And the content type is obviously going to be JSON. So I'm just gonna say application, slash JSON. Next property that we're going to use is called data. And this is going to be the actual form data that we want to pass in. So how do we get the form data? Well, I'm just going to say, get our form. And then I'm going to serialize it using the serialize array. And basically, this is going to take our form data, so our email field and our password field serialize it within an array. And this is going to be a JavaScript array object. But remember, we're posting JSON back to the server, because that's the content type that we want. So we're just going to say JSON that string of phi and pass in this data as an argument. So this is going to take the serialized array, and it's going to convert it into JSON for us. Next, we're going to say success. And success is going to be invoked when we have successful response back from the server. So I'm just going to say response. And we're just going to print onto the console successfully. Got response. And we're also going to print out the response that we actually got from the server. So once all this is done, let's scroll down a bit. Everything looks good to me. So I'm just going to save our index dot HTML file. We're going to head back to app.js. So this is our server. And down here, remember that we told our Express application how to handle URL encoded data Now what we need to do is just say app dot use body parser. And this has a method called JSON. Now this method is obviously going to parse JSON. And it's going to attach it to our request dot body. So now if I just put a semicolon there, and when we scroll back down, you can see our original post request is handled here. And what I'm going to do is, instead of saying just plain text, we're gonna respond back to the client using JSON. So I'm just going to say, res dot JSON. And we're going to pass an object. And we're just going to say that it's been successfully posted. So now obviously, what res dot Jason does is takes a JavaScript object and converts it into JSON for us. So now if I was to save this, and I'm just going to go to terminal new terminal, and I'm going to say node app to run the server, go back to Chrome, when I type localhost. And now to test this out, let's give it a dummy email and password, click Submit. And now if I hit F 12, you can see form serial array is not a function. So let's take a look at this. And we're getting an error. Let's actually take a look at that part of the code. And that's because we did not include the dollar sign. So let's include that now. Let's save it. Go over to Chrome. Now we're going to hit refresh. And type whatever we want. hit submit, go to console and see that we successfully host that JSON to the server. A server responded by posting this object back to us. If I go back to Visual Studio code, you can see that we have our serialized form data, you can see that we have our serialized form data. And that it's not JSON, that this is just an array. And the reason why you're not getting back JSON. And it's because our body parser module sees that it's JSON and automatically converts it to a JavaScript object. In this case, it's an array. In this tutorial, we're going to be talking about validating user input using joy. So what we're going to do is validate the data coming in from this form. Now, the reason you would validate user input server side is because you can never trust the data that you're receiving from the user. So to get started, let's actually head over to Visual Studio code. And I'm just going to cancel out our server. And I'm going to type NPM, install joy. And this is going to install the joy module. Now from here, what we're going to do is actually require it into our application. So I'm going to go up here, I'm going to type const, Joy is equal to require joy. So now that we have joy in our application, let's actually go down to our request. So we have our GET request, which basically serves the form to our user. And we have our post request, which is going to get the data from our user. So from here, what we want to do is actually validate the data that we get within our request body. And in order to do that, what we're going to do is create a schema. So what's a schema, a schema is basically a blueprint, a set of rules that we want our data to have. So we have an email field, and we have a password field. So what I want to do is make sure that the email that the user gives me as a valid email, and likewise with the password field. So what we can do here is I can come down here, and we can create a schema. Now remember, this is just a blueprint, I'm going to say joy dot object. Now this is going to give us a joy object. Next thing we need to do is call a method called keys. Now keys is going to work the same way that a regular JavaScript file would work. You will have your key value pairs, and we're going to pass in the options. Now within here, what we want to do is set the rules that the data that we're receiving must follow. So we have a field called email. And within here, I'm gonna say joy, I'm going to say string. So what I'm saying is, the email field must be a string value, I'm going to trim that data that I'm receiving, I'm going to call a method called email. This is going to check to see whether or not this is a valid email. And I'm going to call one more method called required. Now required does is if the user sends me a no email, in other words, the user doesn't fill out an email, I'm going to get an error because this field is required. So let's go back to our another property. And the next property we have is password. So from here, I'm going to do the same thing, joy, I need it to be of type string. And let's change it up for the password field. So let's say that I need the password to be at least five characters. So I'm going to call the min method and pass in five, I'm going to call the max method. And I'm going to pass in 10. So right now, this password must be a minimum of five characters long, and a maximum of 10 characters. So between five and 10. And the last method I'm going to call is required. And now let's end this with a semicolon. So now that we have our blueprint, let's actually use it. So we're going to call a method called validate. So I'm just going to say joy dot validate. And it's going to take three arguments, the first argument is the object that you want to validate. In this case, remember, we use the body parser to parse the form data and attach it to the body of the request object. So this is going to be our first argument. The second argument is going to be our blueprint, which we just created, it's called schema. And our third argument is going to be the callback function, that's going to take two parameters. First one is going to be error, second one is going to be result. And what we can do is find out our result. So if I say if error, this is going to execute true, if there's something wrong with the data, so error is not know then this code will be executed. So if error is executed, we know something went wrong. So I'm just gonna say res dot send, an error has occurred. But if there is no error, what we can do is we could just say res dot send. And I can say, successfully, post that data. Now just for the sake of this tutorial, I'm going to print out result, just so you can see what the result is. Now, the result is basically just going to be the data that we passed in. So it's just going to be the request body. And I'm going to go up here, and I'm going to print out the error object. So now that I have these two out, what we can do is get rid of our old code from the last tutorial. I'm actually going to save this, we're going to type in Node app. Let's head over to Chrome. And from here, I'm just going to type in, actually, let's just refresh the page real quick. Let's type in an email. And let's type in a password. And then if I hit submit, you can see successfully posted data. So if I go back to Visual Studio code, you can see that our email is right here. And it probably hit Submit twice because I probably clicked it twice. And you can see that our result that's getting printed out is just the request that body is whatever the user posted. And you would do all your database manipulation and calls here. So now let's actually go back to Chrome. And this time, we're going to type localhost again. And stead of giving valid data. Let's see what happens when we post invalid data. So I'm going to post valid data for email. And for the password. Remember, we have to give it between five and 10 characters long. So I'm just going to give it two characters long and let's see what happens. I'm going to hit submit. And you can see the response we get an error has occurred. So let's actually take a look at this in Visual Studio code. You can see this big long mess of mumbo jumbo So I'm just going to go back up. And you can see the error that we're getting. It says validation error child password fails, because password must be at least five characters long. So you can see our validation is working. And this is pretty much the ins and outs of validating user input using joy. This is going to be part two of my joy validation tutorial. So in this tutorial, we're going to be covering how we can validate a nested object, as well as how we can validate an array. So to get started, I pretty much stripped out all the Express stuff. And we're going to simulate a user's requests. So for this example, we have this user input, and it has a nested object. And it has a property of personal info with the properties of street address, city and state. And we have preferences, which is going to be our array, and you can see what values their array contains here. So the first values that we're going to start off with are string values, and then we're going to move on to objects. So the way that I'm going to tackle this problem is, I'm going to look at our user input, and I'm going to break it down into sections. So for example, I'm going to develop a schema for personal info, and then I'm going to develop a schema for preferences. So to get started, we're going to develop the personal info schema, first, I'm just going to copy this, I'm going to come down here. Now I'm gonna say Kant's, personal info, and then I'm just gonna add schema. Next, I'm going to create a joy object schema. So I'm just gonna say joy dot object. Keys, we're gonna hit enter a semi colon down here, we're going to go up copy street address, would just develop a schema like we normally would. So I'm just gonna paste that street address is going to be joy dot string, dot trim, I'm going to make this required, we're going to do the same thing with the other properties, go to city, copy this, go down here, paste, and street address and city, we're going to make the same exact thing. And last but not least, we're going to take the state. And it's going to be the same exact joy schema, except that we're going to add that it has to be of length of two. So I'm just going to copy this, paste this here. And we're going to use the dot length method and set that to two. So we're going for state abbreviations. So now that we have our personal info schema out of the way, let's develop a schema for preferences. So I'm going to copy this, we're going to go down here, I'm going to say Kant's, preferences, schema. And this time, instead of using joy dot object dot keys, we're going to say joy dot array. And this is going to give us an array schema. And we're going to use a helper method called items. Now what items is going to take in as an argument is basically any schema you want. In this case, what we want is an array of strings. So I'm just going to pass in the schema, Joy dot string. So this is going to make sure that all the items that within their array are off strings. Last but not least, let's actually combine these two to form one schema, I'm gonna say Kant's schema. And I'm gonna say joy dot object, dot keys, pass in this object. And this time, we're going to say personal info. And that's going to be equal to the schema we just created up here. So we have our personal info schema. So I'm just going to copy this, paste this here. And now if I go back to my array, we call it preferences. Copy that has this here. Preferences schema. Next, let's actually call this so I'm going to go down here, I'm going to say joy that validate the first argument is going to be the same as last tutorials. So we're just going to say user input. second argument is the schema. So we're going to use the built in schema Now that we made, which consists of the two different schemas that we created separately, last argument is going to be the callback function. So I'll just say error result. I'm going to say if error, we're just going to print out what the error is. Else, just print out the result. And the result is just going to be the user input. So I'm just gonna save this, let's actually add a semicolon here, save this, we're gonna type in Node app. And you can see that our data is validating. So the basic premise is, if you're given a complicated object, break them up into their individual schemas. And then you could combine them like so. Now I want to talk about, let's say that I want an array of objects as opposed to an array of strings. So we're just going to go up here, we're going to change preferences to reference array of objects. And then we have an example object here. So this is a very simplistic example, we just have a property of code example. And it has the value of a string. So example, one, two, and three. So we're just going to change this through an array of objects. Let's go down here. And instead of specifying joy dot string here, because we're not looking for strings anymore. We can say joy dot object, that keys and then we just build our schema, like we did before. So in this case, we only have one property, it's called example. And we're gonna give it the value of joy dot string, dot required. So this was a very simplistic example, if you had a more complicated object, you would do the same thing like we've been doing. So I'm just going to save this. And let's actually execute this code, see if it's working node app. And you can see that it validates, and we didn't get any errors. So that's basically how you can develop a schema for nested object, and how we can develop schemas for arrays, and even create our own custom schema objects for those arrays. In this tutorial, we're going to be talking about e j, s. Now what ej S is is a template language. And that's going to allow us to write more dynamic web pages. So to get started, what we have here is a static HTML file, you can see that we have dummy data here. So when it says you searched for stuff, and we have search results of dummy data, now what we want to do is use this HTML file as a template that we can use for serving dynamic data. So one way to do that is if we go back to Visual Studio code, we can set the view of our Express application. And in order to do that, we would go here, and we could say, app dot set is going to take into arguments, we're going to specify the view engine, a second argument is going to be the template that you want to use. So we're just going to say e j, s. Once we set the view engine to ej s, we're going to have to hit Ctrl B. And we're going to have to create a folder called views. And this is going to store our E j s templates. So I'm just going to go down here, right click New Folder, and we're gonna call this views. Now Express is going to automatically know that our templates are located in the views folder, because that's the default folder that looks for. So now if I create my views folder, if I right click new file, and instead of saying index dot HTML, I specify index dot e j s. So now that I have my index.js file, I'm just going to go to my index dot HTML. I'm going to copy all this. And I'm just going to paste the code within my index dot e j s. So now I'm just going to save this. I'm going to go to App dot j s. And what we do with templates is that we've rendered on to the user. So I'm just going to hit Ctrl B and get rid of the package explorer. And instead of sending a static file, this is going to remove this and now we're going to say res dot render And then followed by the name of the file that you run to render index. Now, you do not need the specified a dot e j s on the side. And that's because we already told express that we are using ej s as the template. So now if I was to save this, just gonna hit Ctrl C, node app, head over to Chrome, we're going to hit refresh. And you can see that we get the same exact output. So what happened here? Well, when we render this index.js file, what's happening is the server is going to look at this E js file for e. js code, it's going to execute it and then send back to the client an HTML file. So now let's actually send data to sun back to our E js file. So from here, I'm just going to give us a route parameter, I'm just going to say user query. And here we're going to pass in an object. And this is going to be the data that we want to display within our index.js template. So now I'm just going to give it a property. First, I'll say data, then I'll give it a property of user query. And then we're going to pass in request dot params dot user query. So now if I save this, I'm just going to hit Ctrl. C, just to exit out of our server. Now we're going to go to our E js file. We're gonna go here to our template. And now from here, we're going to specify less than or sent sign equal. What this means is I want you to output onto the HTML file. Next, what we're going to do is access the data that we just passed in. So how did we do that? Well, we gave it the property data, then we said, dot user query, afterwards, we end it with percent sign, and then that. So now this is gonna look at our app dot j s, it's gonna say, Okay, I want to render the Index page. And this is the data that I'm receiving. So we went to data dot user query. So now if I was to save this index.js template, let's start back to server, no to app. Let's go to Chrome. Hit refresh. And you'll see that we get cannot get forward slash. And that's because we added a route parameter. So let's say the user searched for books, for example. Then it says, Hey, you search for books. So imagine if this was a real website, and we were on Amazon or eBay, you would do a search. So then on top of that web page, you would get Hey, you searched for books, you searched for PCs, you search for whatever. So that means I could use this ej s template for all the items within my website. So now, let's actually add some dummy data. So if I go back to Visual Studio code, and what we're going to do is instead of having hard coded stuff here, when the user types in, we searched for books, we're gonna display a bunch of books. So I'm just going to go to App dot j s, we're going to pass in more dummy data. So we have data user query, we're gonna pass in another thing. And I'm just going to give it a Enter key to make it fit on one line. And we're going to pass in an array, and this is going to be the search results. search results. Pass in an array, and we're just going to say, book one, book, two, and Book Three. So now if I save this, go into my index, e js file. Instead of saying dummy data, what we can do is, we could go to data, because that's the object that we're passing in. We're gonna say search results. And then since it's an array, we can access index zero. And this is going to give us our first position. And remember, since we this is an E JS template, we're going to have to wrap this up within the following. And now if I was to save this, let's go SQL Server restarted up, go to Chrome, hit refresh. And you can see that now we're dynamically populating the web page. So now let's head back to Visual Studio code. And what I want to do is, instead of just outputting data that search results that index zero data that search results index one, what we can do is use a for each loop. So for example, let's get rid of all this. And I started with that, we're going to pass in less than percent sign, we're going to get our array. So what's our array at data, that search results, dot for each, we get our result. And remember, we're going to end this with a percent sign less than, and the reason why we don't have an equal sign here is because we are not outputting this onto the HTML file. So for example, if I want to output this equal sign, if you don't want to output it, no equal sign. Next, within here, what we're going to do is, we're going to display what we want to output. So now what we're going to do is use less than percent sign equal, because we actually want this to output to the HTML file. So I'm just gonna say, oh, II result. And let's close our Li tag. So now we have to end this. So we're just going to end it with percent sign, we're not going to use the equal sign because we do not want to output this to the user. So now, if I was to save this, we can go down here Ctrl C, node app, go to Chrome, hit refresh. And you can see that our search results gets dynamically added. So if we search for books, and there was a million books, this code will work for a million books. If we searched for iPhones, and there was only three types of iPhones, this code would work for three iPhones. So now let's do an example involving conditionals. So we're just going to give a simple if statement. If the user is logged in, we want you to display this, if the user is not logged in, then we're not going to display anything extra. So now if I go back to Visual Studio code, let's write an if statement underneath our h1 tag. So I'm just going to go here. I'm gonna say this. If data logged in, and this is going to be a Boolean containing true or false, but and this here, and now the meat of our if statement is going to be the HTML output that we want to do. So now I'm just going to say h2. You are logged and as data dot username and sent sign, and then let's close our h2 tag. Now we have to wrap up our if statement. So let's close our if statement. And all we're going to do is do the following ecgs. close our if statement. And remember, we're not using the equal sign because we're not wanting to output this. And we're not using the equal sign up here because we don't want to output this if statement. So now if I was to save our index.js file, let's go to App dot j s. And we're going to pass in those properties that we added to our index.js file. So we passed in logged in. And for this example, we're just going to set true and the username is going to be this. So I'm just going to go to index that ETS just to see if we matched up properly. Otherwise, we're going to get an error. logged in username here. Make sure everything matches up. Let's save this Ctrl C, node app. Head over to Chrome, hit refresh. And you can see that since we are logged in, we're displaying our h2 tag, you are logged in as so. And so if we set that to false, our h2 tag wouldn't appear. So that's basically the ins and outs of how you can use ej s within your Express application. In this tutorial, we're going to be talking about what middleware is, and how we can create our own custom middleware. So middleware is basically the code that gets executed between the user request and the server itself. Now, in the previous tutorials, we already used a middleware, and that middleware was within the body parser module. So if we take a look at our Express application, on line five, we say app dot use, and then as an argument, we pass an A function. And this function is a middleware function, that when the user makes a request, this function will take the user's request and process it. In this case, the body parser dot JSON function checks to see if the user have sent any JSON data, processes that and then attaches it to the request dot body. And then it calls a function called next, to let the server know that, hey, we're done processing this request, you can send a nother request. So to get started, we're just going to go down here, I'm going to say app use. And then we're going to pass in our own middleware function, that's going to get executed whenever the user makes a request. So this should be very familiar, we're going to pass in the first parameter is going to be the request object, their response. And then the final parameter is going to be the next method. So now we already are familiar with the request object and the response object. So what is this next method, this next method must be invoked whenever you create a custom middleware. So what the next method is responsible for, is to let Express know that, hey, I'm finished processing this request. If you do not call the next method, what's going to end up happening is you're going to timeout the server, because it has no idea whether or not you're finished processing that request or not. So right now, I'm just going to say next, and we're just going to call it. And to make things a little bit more interesting. let's actually go up here. And I am going to print out the request, that URL and the request dot method. So now, if I was to save this, let's actually restart the server, I'm just gonna hit Ctrl. C, node app, we're going to go to Chrome. I'm going to hit refresh. Now when I hit refresh, what I did was make a get request to the server. So let's actually take a look at Visual Studio code to see what happened. And you can see that our middleware is running. So we made a request, it gives us the URL, it gives us the method of the request. So we made a get request when we hit refresh. And then we said next, which let Express know that, hey, he's done processing this. And then it got to this point where we just sent res dot send middleware onto the user. So that's why you see that we got this. Now let's change this up. So instead of saying, forward slash, because we got to get route there, let's just make something up. Now, if I hit Enter, you can see Can I get whatever this route is, but that's okay, because we're not interested in that. We're only interested in the middleware for this tutorial. And you can see once again, that our middleware is running fine. So whenever there's a request made from the user, this middleware function is going to get executed. And you can see that our route was printed out. And the type of request was also printed out onto the console. Now, this is all fine and dandy. But as we have it right now, whenever we use App dot use, and we have our middleware, any user request is going to get processed by this middleware. Let's say that I only want this middleware to execute when a certain route gets requested. So right here, I'm just gonna go here, and I'm just gonna say example. This is gonna be our route. And now, whenever we call this example, route, it could be any type of request, that could be a get request, post request, put, elite, doesn't matter, this middleware is going to execute. But if it doesn't match this example route, then it's not going to execute. So let's save this. And I'm just gonna hit Ctrl, C, node app, start this up again. And now I'm just gonna hit refresh. Go back to Visual Studio code. And you can see that our middleware is not executing. But if I go up here, type example. Go back to Visual Studio code. And you can see that our middleware is executing just fine. And the last thing that you should note that middleware functions can do is modify the request object and the response object. So going back to our body parser example, it parses the user's request and searches for JSON, and then attaches it to the request dot body. So to give a trivial example, I can say take the user's request, and I can add a property called banana. And I could assign it the value of banana. And for the sake of simplicity, since we already have this route here, we're just going to get rid of all this. And within our get route, we're just gonna say, console dot log requests that been then. So let's end that with a semicolon. Let's double check everything. And this looks good. So I'm just going to save this. And we're going to restart the server. Now, the app, we're going to go to Chrome. And we're going to hit our root. And there we go. If we go back to Visual Studio code, you can see what's going on here, we made a request to the server, the server did some processing the same thing that body parser did, and then adds to the request object. And in this case, we just added banana, gave it a value of banana. And then here, when we got the request, from our get route, you can see that we get the output of banana. So that's pretty much the ins and outs of how you can create your own custom middleware, and how middleware works in general. In this tutorial, we're going to be talking about the Express router. Now what the Express router allows us to do is separate our routes into different files. This makes our code a lot more manageable, as opposed to just sticking our routes within the app dot j. s file. So to get started, I'm just going to hit Ctrl B to bring up our Explorer, I'm going to create a new folder to store our routes. So I'm just going to right click here, new folder. Let's call that routes. And we're going to create a new file called people. So this is where we're going to store our our people routes. So I'm just going to hit Ctrl B again. And since we're using the Express router, we're obviously going to need to include the Express module. So I'm just going to say const. Express is equal to require Express. Next, we're going to call Express dot router, which is a method that's going to return to us a instance of the router. So we're just going to say that within a variable. So I'm just going to say Kant's route is equal to express dot router. So now that we have our router instance, what we can do is setup our route. So we already know how to do that. So I could say route back get. And we're just going to give it the path. And we're going to give it the callback. So the request object response. And we're just going to say res dot send forward slash being hit. Now let's just create a another row. So I'm just gonna copy this. For example, and I'm gonna call this example. And let's say example, being hit. Now, we're not done yet. So right now we have this route here. But how do we expose this route so that our app.js file can access Well, in order to do that, we're going to have to use module dot exports. So I could go down here, type module dot exports. And then we're just going to export this route that we created. So now I'm going to save this, we're going to head back to our app.js file. And now down here, we're going to have to actually require the people route. So how do we do that? Well, I'm going to create a variable called people. And we're just going to require the file. So I'm just going to say dot forward slash, I'm going to go inside the routes folder. And then I'm going to include our people file. But we're not done yet. Remember, on line three, we created an express application. So now we need to tell our Express application that we want to use this people were out. So let's go down here. I'm going to say app dot use. And we're going to give it the base URL. So I'm just going to say for slash people, and then we're going to pass in the people route as the second argument. So it's going to pass on people. So now if I was to save this, head over down here, node app, let's go to Chrome. And I type localhost Port 3000. And that's because we do not have a base URL. Remember, we gave it people. So this is our base URL for this peoples row. So right now, this forward slash would be accessed if I just typed people at the end of localhost. So I'm just gonna add that people. And now you can see our four slashes being hit. And if I add another forward slash, and do example, you can see our example route is being hit. So now what happens if you want to add middleware to these routes, so I'm just going to go back to Visual Studio code, we're going to go to our people route. And within here, I could say route.us, and then pass in our function, our middleware function that we want to execute. So I could pass in my request object, my rez, and next. And now I'm just gonna say, console dot log middleware being used. Now when I use route that use, all requests is going to go through this middleware. So remember to always call next, if you ever creating your own custom middleware. And now if I was to save this, let's hit Ctrl C, node app. When I go to Chrome, hit refresh. And you can see that our middleware is being used here. Now, this middleware is only going to be used within our people out. If we had another route here. Let's say instead of people we had an animal route, this middleware is obviously not going to get executed because this middleware is only specified to work with our people route. So that's pretty much the ins and outs of how you can use the Express router to actually separate your routes from the app.js file.