improve your go programming skills by developing three different projects in this go course experience developer Akil Sharma will teach you how to build a website Health Checker a program to encrypt text and a program to encrypt files hey guys in this video we're building three awesome projects with goang now these are beginner friendly projects and awesome additions to your portfolio in case you're applying for a goang job in the first project we're going to be building a goang health Checker where we'll check the health of a website so you'll just have to enter the domain name of a website and you'll come to know if it's live or it's down the second project is about encrypting files so we'll start with the PNG file and we'll encrypt it we'll try to access it without the password and then we'll access it with the password to see how encryption works the third project is about encrypting a string with goang so all these three projects you learn quite a bit a lot of goang so if you have basic goang skills you'll be able to refine your skills and build on top of that not knowledge so let's get started hey guys welcome back in today's video we're building a very simple project we're going to build a goang project which checks if a website is running or it's down and accordingly we'll show the appropriate message in the terminal saying the website is up or running or it's down or not running right and you'll find these kind of projects uh very easily on Google if you go and if you check if the is the website on there many projects like these and they basically run it free of cost but then they show ads so if you want to do that you can do that as well but it's just a great project to build and to basically practice your goang skills right uh now this project is going to be a part of the uh goang playlist goang Project Playlist so in my YouTube If you go to the playlist there's a goang playlist it right now it has 46 projects so I have called it the 46 killer goang projects playlist but then the number keeps Chang changing so once I put this video it'll be like 47 goang projects right so depending on when you watch this video the number would have changed but then you know it's important to know that that playlist exists and you can and what I'm trying to do is I'm trying to arrange those projects in the increasing level of difficulty and this project since it's very small and very simple we'll place it towards the beginning of that playlist even though I'm releasing it quite at the end but I'm going to actually position it towards the beginning of of the playlist okay so with that out of the way we can get started I'll show you a couple of diagrams just to help you visualize what your building uh and then we'll just go ahead and build it all right now just before we get started I just want to tell you that a very common name for this project that we're building is called the health Checker right so for any project that you're building you might also want to create a health Checker microservice in case you don't want to launch this as your own project on the internet completely fine uh but you can but usually when people build let's say a project and then they usually build a microservice which checks health of their own project so with with the project that we building you could do that like check the health of your own project or you could check the health of any website that's up or down you can check that state status of that website all right now we can get started so now I think you can see my screen here uh we've just represented what we'll be doing in our code so we'll have a main.go file which will have the main function and all we doing is importing the CLI package so it could be any CLI package like you could be using something like uh Cobra or something like that but I'll be using something very small and basic in this project because this project is small right and um we'll be passing two things we'll be making use of two things one is Flags so we'll set two flags which is the domain and the port and the action for the CLI tool tool would be to call the check function okay the check function is is going to be defined in a file called check. go it's going to accept destination and Port because that's what we'll send from here to this function destination and port and the whole business logic here or the Crux of the entire program is the dial timeout function this function you get in this package called net the net package very popular package to work with uh web web related things in goang right so we'll use D dial time out package and finally we will return the status of the website whether it's up or down so that's the entire business logic here in the in the project so now let's go ahead create a new project and get started all right so now we'll start building our project everything that I'll be showing you in this video is already there in my GitHub account so make sure you check out Akil Sharma 90 which is my username on GitHub all the projects are there check out the code in case you get stuck somewhere we just create a new directory called go health check YT so we'll CD into it and what we'll do is we will um go mod in it and I'll just give it my username go health check right okay so now you can see the go mod file already has been created and we will just open up our vs fold and check out that yeah everything looks all right now I have decided upon the uh package that I'll be using it's CLI version two and I found it on this uh project on this profile called yourf This is a common package it's very very light so if you're not building something huge like a proper CI tool I recommend using something like this something very light like this there thousands of packages like these by the way but if you're building something serious then obviously Cobra CLI is is the way to go anyways now we'll create two files as you know one is the main.go file and the other is our check. go file okay in the main. go file we will do the regular stuff package name import the import statements and all of that and in the import I want to put this package so that it's clear that we're going to use it and then you have your fun main that's how you start that's the most important part in your main main. go file obviously and I'm going to go ahead and create an uh create app which is basically C.A right CLI being the package that I'm using and this helps to create a complete CLI tool where I can give it a name I can show how the tool is used I can give in the flags we've already talked about the flags and I can talk about the action it's supposed to have happen when the you know the right commands are or the right yeah the right commands are given what's the action that's supposed to happen all right so yeah now for for the name what we'll say is we'll say let's call it health checker and the usage let's usage basically basic text of how this product is going to be useful say tiny tool that checks whether a website is running or it's down and then there are the flags so CLI do flag okay and here you have the name which is domain aliases string D and the usage which is the this is where you'll enter the domain name like for example google.com that's the domain name to check whether it's up or down so that's domain and it's obviously it's required so we say required is true without this there's no point of the app if if you don't have this right all right so uh in the flags there's one more flag that we going to have which is the c. string flag it's going to be name will be Port Al s's string B Visage port number to check and required false right now for the action you're going to have c. context and we might return an error and let's define the port which is C do string and the port and if c. string and Port is null which is empty then the port will be 80 right so what's happening here which is standard basically whenever you check anything you're checking on Port 80 which is like the most common Port right where the uh the hand check would happen anyways but let's say um you but you can you can say any port you can mention any port here but if you have not mentioned any port here the default Port which is 80 which is the one that that's always checked that's the one that will be um set right for the port variable and then you have status is equal to check so this is the check function I was talking about which which we will create in the other file called the check.of file and you are checking the domain and the port so we sending two things to the check function which is domain and the port which is what I had shown you in the diagram and we're going to print the status and return ma for the error if everything go well here we'll say error equal to app. run okay so you say app which you just created the whole app using the CLI uh package and you're going to say app.run passing in the OS arguments and you're also handling the error so if there is an error you can do something about it if the error is not equal to n that means the error is there it's say log dot fatal and you'll print out the error all right and now we can work on the other file which is check. go so now we're going to go ahead and create the check. go file before that what I'll do is I'll just say go mod Ty just to create the go s file there seems to be some problem we'll fix fix it no problem so right now let's just create the check. go file okay so say package main also this part of package main only not creating a separate package and here uh there are a few more packages that I've used actually like fmt and all those and somehow they've not come up so usually when I save the files they come up like my plugins are not working I think right now I'll just copy and paste them on my own anyways all right so here also I'll need some packages I'll just say fmt time and net the most important one obviously here is the net package you know that because the net package has the um dial timeout function that we'll use to actually check the status of the website so we'll say fun check destination it's a string and Port which is a string and return the string string being the status so we return the status from the check function so here we'll say address equal to destination Plus Port right destination being the domain name and Port being the port that you pass in or or even um Port 80 which is the default right so we'll say for the duration of 5 Seconds is a time out so within 5 seconds if you get a response back from the website that means the website is on otherwise it's not okay this is the main part which is we're using the net package and the dial timeout function we need to send in the address which is basically the destination the port both combined with the timeout which is 5 seconds in our case and let's create a variable called status which is the one that we're going to return from this function and here this error that we have which is we're checking we'll have to now check for that error so we'll say if error is not equal to nil means there is some error then we'll say status would be fmt dot Sprint F down website is not reachable so to print out the name of the website star V sorry percentage V is unreachable the website is not reachable and you can print out the error for percentage three and here the actual variables which is destination and the error all right else we will say status we FMP do printf and we say up percentage V that's the basically the website is reachable and then we'll print out from which address we tried to which address that means the destination comma connection dot local address right so your connection variable will have a copy of local address the address at your end which is making the conect the the request and the remote address basically the website and the port that you had mentioned just above and finally when your the status okay so all okay here I think to get rid of the error just remove this quickly and let goang do it for you so just say go mod tid it'll get all the packages right that you're supposed to have and it'll also generate the go. sum file for you here in the main. go file there's an issue because there's a small spelling mistake it should have been adss and uh but I see one more error so me quickly check yeah the other thing is that there's another spelling mistake here it's CLI all right so hopefully everything should be fine now but I still see one more error all right so uh yeah that's one more issue which is spelling of name is wrong I'll just save it everything seems fine now to me uh here so by flag you know what you mean by flag is that when we run this uh tool now we'll have to pass the flag so let me actually show you how to do it so we'll say go run do minus minus domain which which is the flag now in our case and it could be tel.com so it's saying it's reachable right so if you say google.com and amazon.com yeah so all the websites are up at the moment all of them are reachable all right so that was our simple yet effective tool that we've built and we've done we've done quite a bit in this tutorial uh it's a very very tiny tool but then a lot of Concepts have been used here so I hope you've learned quite a bit thank you so much for watching do make sure you watch all the other projects in this series because there so much to learn right and thank you so much for watching and do subscribe hey hey hey in today's video we are encrypting files with goang so in my root directory of this project I have the img.png file which I'm going to now encrypt so as you can see I can I can see the file now right but if I encrypt it so I'll say go run encrypt uh and I'll say img.png which is the name of the file I want to encrypt and I'll enter some password it'll confirm the password and it'll encrypt it for me and say it'll say file successfully protected and now as you can see I can't see it anymore I can't see the file anymore but now if I go and if I just decrypt the same file it will ask me to enter the password it will say file successfully decrypted and now again sorry now again I can see the image awesome right so how is this happening so let me let me take you through it so in the beginning what will happen is we will accept the um r arguments from user which is uh the basically the file the path to the file or the file name we'll validate if the file even exists or not and we'll also ask the user for the password and we'll validate the password in the sense if both the passwords match this is for the encryption part right we'll check if both the passwords match password one and password two then we'll encrypt the file and then for decrypt we'll again check the password after getting the password we check the password okay so it's really straightforward for for from a 10,000 ft perspective this is what's happening just getting arguments from the user validating the file getting the password from the user and cing the file by validating the password and then decrypting the file with the same password that's what's happening but if you look uh more if you look a bit deeper then you have two parts encryption and decryption in the encryption part uh we follow multiple steps so we first check for the source file we open that source file the one with the plain text which was our img.png and and then we'll re read that plain text now it could be the data from the PNG or it could be a text file right whatever it is it's basically plain data from the source file then we'll create an empty uh variable called a nuns this will be 12 bits or 12 bytes in our in our case and we'll create we'll randomize it so we'll create a random basically 12 byte uh variable we because we want to use it later on so firstly you have the password that we'll use to encrypt the file right so the the password and then there's something called as the length in the sense what do you want to get after running a derivation function so we'll basically be running a password based derivation function I'll talk more about it the first thing you need is a password the next thing you need is the bip length in our case will be 32 then the algorithm with which we want to encrypt it and the number of iterations in our case it will be like some somewhere around 4,000 iterations iterations basically make it more difficult for the party that wants to uh hack this or or break the encryption just makes it more difficult for them okay okay so uh with the password based key derivation function this is a function in which a key will be generated from the password so we'll take in the password and we'll add in a few different things as you can see and we'll get a key and this can be used as an encryption key or the hash value so we basically just hashing the password now this is very similar to how you um take the users's password you hash it and then you store in the database right because you don't want to store the passwords directly in the database because otherwise people can steal or get access to the database steal all the password right so you always hash the passwords with some salt and that's what's happening here right so uh this is the salt in this case the nuns so with the password based key dation function you get something called as a derived key now the derived key we'll run it past uh AES or Advanced encryption standard this will give us some solid encryption abilities after after getting the key from the password and we'll and this by by running it through the a a cipher we'll get something called as a cyer for block and that again we'll run from uh through something called as the uh galwa counter mode now this is spelled as g l o i s but I think this is like a French word so you say gal galwa or something like that I'm not French so I have no idea so it's the GCM I call it the GCM galwa cter whatever blah blah blah but GCM basically right and GCM gives you more encryption with data Integrity checks now GCM generates a tag which is appended to the C Cipher text at the end and this tag is used to verify the Integrity upon data encryption now you had some data you encrypted it but then how do you know that the data that you got back is actually the correct data and that's why we using GCM because that gives us the tag to verify the Integrity of of the data upon decryption and GCM uses AES so we as as you know we have already used AES before it uses AES to encrypt the plain text this operates in a counter mode and hence the name and and generates a stream of encrypted blocks that's what GCM does finally we use this uh function called AES GCM which AES GCM is what you get so you already had the AES Cipher which is the ciper block then you run it through GCM you get AES GCM and you run this function called AES GCM do seal this is the main function now this is uh just to use this function we had to do all of this basically all of this part because we wanted to run this function called the seal function and the seal function is what takes the plain text from our file from our IMG file or any other file and convert it into Cipher text and it then creates a source file for encrypted data and we write Cipher text to the new source file so the the file in our case Remains the Same but then again we have to create the source file for the incryptor and write the cipher text Cipher text is basically text that we can't then access right so that'll be written to the source file so that's the encryption now let's go over the decryption for the decryption it's very very similar uh we'll check for the encrypted file so here we were checking for the source file that had to be encrypted and now we'll be checking for the encrypted file because uh to our program we will be saying that hey this is the encrypted file please decrypt it for me so we'll check for the encrypted file we'll open that file we'll read the cipher text from the enced file right the text that we can't open in our IDE but it still can be read from our function now to convert the cipher text into uh regular plane text we have to again run the password based key activation function so we'll have to have the same password which we used to enp we you have to have the same password to decrypt uh decrypt it as well same bite length same algorithm sh one and the number of itation should also be the same and then the nuns uh as you remember we created a nuns here a randomized nuns and uh the the GCM basically uh appended the nuns to the cipher text and exactly that's what we want we want to get the nuns from here uh which will be at the end so the the last 12 digits of the encrypted file will have the nuns you want access to that so all of these uh five things we'll pass to the password based key derivation function we'll get the derived key again the same thing as Cipher we'll get the cipher block GCM you'll get a GCM now we did again we did all of this so this was important obviously you know that you have to use SOL to Hash the password this is perfect but these extra steps we only did because we wanted to use this aesg cm. openen function which takes in the cipher text to this function without the NS obviously and gets you back the plain text now the pl text is what you will write again to a file which will have the decrypted data or the other PL text and that's the one that you will write back to the file and that's how you'll be able to read the file again so that's what's happening in your encryption and decryption so in our program in the code what we'll need to have is we'll need to um do all of this like the whole entire Logic for the encrypt function and the entire Logic for the decryption function and I'll keep opening this diagram again and again in between just so that we able to refer it while we are writing the code but the program also needs to do all of this so we'll the way I'm thinking of it is that I'll need one file which will have the encryption decryption functions and I'll need one file which is the main.go file which will will have all of this thing which will print out stuff to the terminal and accept uh values from the user from the terminal so all of that logic I'll put in main.go file okay so now we can start writing our code now before we start writing our code just want to tell you that um on my channel this particular video that we creating right now will show up in the 48 killer goang project Series so this is a playlist which basically is uh which has 48 projects now but I'll add this one so it'll be 49 projects and um this playlist right is in the order of difficulty so we have smaller uh simpler programs earlier and then more difficult programs later on this will be somewhere in the middle it's not or somewhere towards the end but not at the complete end because this is not very difficult to build what we building today today uh so um just make sure you you go through all the videos in this playlist and you build them one by one and once you've done that you will no goang better than more better than 90% of the people or 99% of the people actually out there because I mean uh how many people do you know who build like 50 50 projects with goang right not many so this will seriously give you an edge if you build all the projects in this playlist all right and and uh I also wanted to tell you one more thing that if you go to my channel uh you get access to this Discord link here as you can see this is the Discord link for this community out here which is uh where we discuss a lot of stuff around golang and we share our learnings what we've been learning today uh we have a lot of um like forums where we uh discuss issues uh that we that you're facing blah blah blah so lot lot of stuff here so uh a lot of cool discussions happening so make sure sure you join this because uh I mean if you want to learn if you want to learn goang this is the right place to be this is the right Community to be at all right because I'm here quite a lot as you can see it's always open on my browser these days so I'm always there replying to messages all right so uh I have now talked through all the things that I wanted to talk through so now is the time to start building the project what I'll now do is I'll create a new uh directory called go file encryption by the way this program this project already exists on my GitHub so in case uh you are are already following me on GitHub uh you will see this program there the F encryption one um in case I don't put the link to this project in my description of this video please know that my GitHub is Akil Sharma 90 ail s RMA 90 the project is there in case you get stuck somewhere um you can access the code you can look at the code and build along with me all right so here I will CD into it I will CD into go file encryption and we will say go mod in it github.com sharma9 SL code file encryption this creates a um go. mod file for us which will have the list of all our dependencies and I'll just go ahead and open this up in my code infl here I'll just create a um main.go file and I'll create a folder for file Crypt and there will be a file called filecrypt okay now I told you that I'll divide the logic into two different parts one will be the uh interfacing with the user part and the other will be the actual encryption and decryption so let's talk about the part where we'll accept user values so we first start with sorry package main not M we start with package main all right and there will obviously be Funk main which is from so main is the most important file main. go is the most important file which is obviously the main package again and then it has the main function which is where the uh program begins from or Origins everything starts from here and then this is why from this function we have to call all the other functions this is like the root or the source of everything then there will be an import statement here and I'll import multiple um packages in a while so firstly I want to check if the length of the arguments now to to work with arguments to print out messages to the CLI we could use something like Cobra which is a CLI tool and I have and I already have uh projects with that I think uh that's very commonly used in goang as you know Cobra uh we're not using it here because we have like very few operations and we can do that uh on our own we don't need to import a complete Library just to print out stuff to the terminal and to work with some arguments right and uh here we're just checking of the length of the arguments is less than two if it is less than two then we'll print help and print help will basically print out uh so there's a function called print help it's print help which basically tells the user and how to actually use this uh project so if he's not if the user user is not uh entering let's say encrypt or decrypt and the name of the file that means it doesn't know how to use this function right so you'll just print help out in that scenario and the other thing is function equal to OS do ARS one and we'll switch function so what do you want to do so do you want help if you want help we'll just print help we'll just call the print help function if you want to encrypt we will call the encrypt handle function if you want to decrypt you will call the decrypt handle function and then there is a default which is run encrypt to encrypt a file and TP to TP right just telling the user that hey please run encrypt to encrypt the file and decrypt to decrypt the file okay so that is our main function now as you know we're calling three functions from the main function which is the print help encrypt handle and decrypt handle so we're going to call we create all those functions uh so we have the we'll have the encrypt handle function and we have the decrypt hand function there are three more functions that we'll need in the encrypt handle there is the um get password to get the password from the user and then we have the validate uh so we have the get password function we have the validate file and validate password functions so let me create those password and frun validate validate file okay so and the print help print help is going to be very straightforward so I'll just go ahead and copy and paste actually don't have to write this whole thing on your own so this is basically saying file encryption simple file encryption for your daytoday needs uh which is the name of the program and then what it does and then showing you usage that you can go run and uh when we say dot basically means it runs all the files in uh at the root which is our main.go and also our file. cp. go uh folder package and it'll basically uh you want to pass the path to your file in our case we'll just say img.png which will be a file that I'll copy and paste here you can copy and paste any file here I'm just using this apple file here and then you have the commands the commands like encrypt decrypt and help you'll have three commands encrypt will encrypt a file with a given password decrypt tries to decp a file using a password and help which displays the help text which is uh this particular function gets called there now for the encrypt handle which is the most important one uh sorry the encrypt and decrypt actually are both uh really important because that's the logic main logic so here we'll check if OS do if the length of os. ARS is less than three that means uh you have written you have written that uh you want to run the program and you want to encrypt but you've not passed the uh the pass the file right so it's argument sesson three then you will print Ln you will print out missing the part to five for more info run um so encrypt we say from the help command all right and os. exit Z if everything is all right then what you want to do is you want to get the arguments or which is basically the uh arguments at the second index which is the third argument uh which in our case is the part of the file you want to get it in this variable called file and you want to Val validate so if not validate file and you pass the file there and we'll just Panic file not found so what happens in the validate file function and this gets called it basically it takes in the file which is string and it passes back Boolean which is that's how we checking it it here you know true or false this exclamation helps us check that so if it's not uh valid then we say file not found okay and how does it return the Boolean it's basically using the os. stat function on the file and saying if ederal to OS do is not exist return false if it doesn't exist return false if it exists return true that's how we're checking for it out here so for the encrypt part we have checked um the validity of the file and not found now the next step is to ask for the password so we'll say password is equal to get password right so we already have the get password function so what is do it do it Returns the password which is a slice of bites and how does it accept the password it says first it prints out enter password then it's going to use the terminal terminal package to read the password and going to capture that in the password variable so when you if you remember when we were encrypting the file we didn't only just accept the password we also asked the user for the confirm password as in confirm this password so you want to print that out as well so you're going to say sln confirm password and we want to again read the password okay and this will be password to and here is where we will validate if the password one and password two are the same they're matching so we'll say if not validate password which will will pass password one and password two basically this function the validate password function should return back to us a Boolean and here we say fmt do print passwords do not match pleas try again turn get password if the password don't match we want this function the get password function to be called again and again Ask the pass uh the user password so if everything went well we just want to return the password from here which is a slice of bites okay now in the validate password function let's come here so it's going to accept something called as password one which is a slice of bites and password two which is again a slash of ptes return back a bilion and in here you want to check if the bytes are equal if everything is equal in password one and password two it's not equal return false if it's equal return true that that's our return uh validate password function which got called here and we'll go back now to our encrypt handle so after calling the uh the get password function we will say fmt do print Len and inform the user that hey we've started encrypting the file so we say encrypting and we'll use the file Crypt package the file Crypt package is our own we'll create the file Crypt package out here so we say file Crypt do encrypt because we'll have the encrypt function we'll pass it the file and the password and we'll print out FM do print Len you'll say file success detected so that's our encrypt handy function now in the decrypt handle function we will again check the same thing which is this like has he given us the file uh the part of the file if not we want to exit and we want to then validate the file again and we want to ask the user for this password so we say do print enter password and we want to say password terminal. read password and after taking the password we'll just print out instead of encrypting we'll just print out decrypting and instead of encrypt file the uh function encrypt function we'll just call the decrypt function passing the file and password and here instead of protected we'll just say decrypted so we have the encrypt handle and decrypt handle functions perfect clearly get password validate password validate file and CP handle print help and name now in the import statement we should have um all the files which file Crypt is my own package which I'll get from here the xterm package is the one that we're using here term uh the one that we're getting to to using to read the password and then we have byes fmtn okay so that's how it is now I can already see some issues and errors and some of them should go away once I've completed my file crypt.of file but then there will be many others that we fixed not a problem and now let's go ahead and start working on our file crypt.of file so starting with the filecrypt Dogo this package is going to be called filecrypt and we'll import some packages of course then we have two functions one is the encrypt function as you know and the other is going to the decrypt function okay because from here we are calling the encrypt and the decrypt functions so in the encrypt handle and decrypt handle respectively you call the encrypt function from file Crypt and the decrypt function from filecrypt those are the ones that we working on at the moment so in the E encrypt function you take in the source which is string and the password which is bite it's a slice of bytes okay so now this uh Source in our case is the file right because if you check here we're sending the file and the password so file and the password right so for the file we want to check if the file let me actually open up the browser and show you the diagram again and we'll follow the exact same steps so here it is we'll check for the source open the source file read read PL text from the source file create an empty nuns randomize nuns Let's do let's do those steps so first is os. stat then the source. is not exist and if it doesn't exist we are just going to return an error so first we checked for the file now we'll open up that file so we'll say os. open source and we'll capture that or store that in source file and if error is not equal to n panic errors at the end of this program when this function stops running we want to also close that source file so that's why we'll say differ Source file. flows now we'll read all the plain text from the source file so to read the pl text from the source file we'll use io. read all and source file what you get back is plain text and now we'll handle the error also error is not equal to n banic now the password that you have you want to store it in a variable because we want to work with it so we'll say key is equal to password and and now we'll create an empty nuns this is an empty nuns make and it's a slice of bite and of 12 so it's going to look something like this it'll be 0 comma 0 comma 0 right 0 0 0 till 12 so 12 different values all of them zero that's what you create with this now and now we will randomize the nuns okay so we have created the empty DS now we'll randomize it we'll put random values in it and the way to do that is we'll say IO do read full random. reader so fill it with random values and error is not equal to nil Panic error dot awesome what's the next step now so on my screen the next step is we pass all these values to create into the password based deration key derivation function okay so the password based key derivation function is available to us in a package of the same name P key PB KD F2 and that function we pass the key the nuns 4096 as the number of iterations 32 as a length and sha 1. new as the algorithm so if you look here we passing the password to encrypt the file the nuns the number of iterations sha one and the B length which is 32 in our case and this is the number of vibrations what you get back from his this is called as the derived key DK so we just in short it's DK this package that we're getting everything from is is this package pbkdf2 so now we have the derived key now we will create we will run it past by the advanced encryption standard so we'll say a. new Cipher DK and we'll get the block and we'll handle the error also so let say if error is not equal to n Panic error okay so we have this now the cipher block and now we want to use the galwa whatever ever it is you know GCM I'll call it GCM so it's the new GCM function so I'll say cipher. new GCM function and I'll pass in the block and what you get back is AES GCM if error is not equal to nil Panic error dot error okay so as as you know we did all these steps to to be able to run the seal function here which is what creates the which is is what converts the pain text to Cipher text so coming back here let us use the AES GCM do seal function this is what's going to take the plain text for us and send back the cipher text and you uh append the nuns so there is one thing that I have not drawn here but I have actually talked about it here is that we add the 12 by nuns at the end of the encrypted file so we want to do that now we want to append the nuns to the cipher text and store that in the cipher text itself so now we have the complete cyer text now we want to create a file source file for the encrypt data and want to write the data to the source file so what you'll do now is we'll call it the destination file. create create that file handle the error also here panic and at the end of this function when this function uh has done processing you want to close this file as well so you have created the file now you just want to write Cipher text into that file so write the cipher text into the file but this is the de file you'll say destination file. light and you will get the error if any if error is not equal to n Panic error okay so this was our encrypt function so far so good and as soon as I uh hit uh save it got me all the packages that I needed and now we want to work for the decrypt uh function the decrypt function is very similar it takes in the the the the path of the file and the password with the help of which we will decrypt this and first things first you want to check if the file that to be decrypted the the request that's coming for decryption if the file even exists or not so do the same thing .at Source this do is not exist error and here you will this is the error you're handling here and you're just saying Panic error okay and actually some of the part from here is going to be similar so I will just um copy this part all of this part till here I'll just copy it uh once again after this so here you will have uh SRC file where you'll open that source file and at the end you will close it also and here instead of plain text you'll just have Cipher text because that's what is in the file now because you have already encrypted the file and you're passing the encrypted file to this decrypt function and that's why whatever is there in the file is now Cipher text so we have done in the decryption part we we're done with this check for the encrypted file open the encryp file and read the text Cipher text from the encrypted file all of this is done okay so the password that you will receive in this function will again be stored in the variable key then we'll have a variable called salt which will basically have Cipher text and length of Cypher so without the last 12 okay and x dot and code to string the salt which is basically the nuns the last 12 is the nuns right you'll have it inall in Sal and we will use the hex package to decode this string and we'll store that in Str Str sorry this will be NS now okay okay so what do you pass again in that function the password based key derivation function for decryption you pass the same password to to that will be used to decrypt the bite length 32 chart 1 iterations 4096 and the NS that we got from the last 12 uh digits of the cipher text and the same thing you do here you say new Cipher sorry new yeah a. new Cipher and you pass the derivation key derivative key and you'll again get the block and again you can have handle the error if error not error not equal to nil and then you want to pass that block to uh the cipher AES Cipher so what I'll do is I'll yeah we've already done that and now we want to pass it through the CGM GCM sorry yeah so the same thing that we done there we're doing it here and now there's only one little difference uh which is that instead of using the as GCM do um seal function we'll just use a GCM do open function so here we'll have the nuns the cipher text which is everything apart from those last um 12 and what you get back from this is the plain text okay so what you're seeing now is uh step by step we're just looking at the diagram and we are uh converting the diagram into code okay so our flowchart into code again let's handle the error here and then we'll again create the file like we did last time the destination file so I'll copy and paste that part Here and Now we will write plain text to this file so instead here we wrote the cipher text to the file and now we will write the plain text which we have received to the file so here what was happening in the encrypt function what was happening is that you ran that function called uh the seal function which gave you the cipher text to run the seal function as GCM seal function you had to uh do all of these steps which is get the plain text and then create your nuns have your password ready uh create a derived key with PB kdf function use Advanced encription standard new Cipher create a block Cipher block pass the cipher block uh with GCM and get AES GCM and then you were able to call the seal function to get the cipher text with all those values here exactly the same things you just had to call the as GCM do open function because this will give us the plain text from the cipher text Cipher text is everything apart from those 12 last digits which actually was the nuns in our case for nuns right the salt which we can convert into nuns here and uh then finally just like we did in the encryption file we created a file and then we wrote plain text back into that file and now when we open up this file we'll be able to access it right so as you can see I have a lot of errors and I'm not at all scared because now when I go ahead and run this program uh I will come to know what the issues are so I'll say go run encrypt PNG and here I see all of these issues it says uh file Crypt to add file Crypt and yeah so xterm and file CPT are not there that means I need to say go mod tidy so first I'll get these packages let's I can see some issue there but let's see if it still works yeah still the same issues I'm getting so let's try to fix it now one issue out here obviously is this part which is I've copied the link from my previous project now this is obviously my GitHub and this should be the name of the project right and I'm and I'm calling file Crypt package but the name of the project is wrong that I have to go and get from go mod so the name of the project is actually go file encryption in this case and I have to go ahead and get it here and this issue will go away uh now what we'll do is we'll again go and run go run encrypt IMG or PNG and now we'll get a list of issues okay so now uh on line 68 file Crypt line 68 file Crypt as I can see it's should have been error okay now let me check out line um 83 line 83 key is not used yes because I was supposed to use key here by mistake I've written name and here also I can see one more issue it's key should have been key right uh now the other thing I can see is um 88 which is undefined yeah it's the same thing this one the issue 988 all right so that's solved but now I can still see four issues in main. go so what we'll do is we'll go ahead and run this again uh here now we can see some issues from main.go file and the um first one is on 50 okay and then online 66 and then on line 87 print line uh 102 right so what I'm trying to show you here is with if you're working with Technologies like goang and rust you don't have to worry at all about making mistakes the code so don't depend too much on extensions right so many people would tell you get extensions that help you uh not make any mistakes in the code while writing the code uh for spelling and for for uh you know goang so don't I would suggest don't don't depend too much on that as you can see I I wrote everything myself and uh I just depended on the on the goang compiler to tell me the issues and I just solve them one by one so just just depend on Goan compiler because when you're in an interview when you're giving the interview for some company uh you're not sure what kind of environment you'll get to write the code with mostly it's an online environment right and you have somebody on a call you have an online environment and you have to write the code in that online environment that won't have the extensions that you want and that you work with so it's highly recommended that you don't depend on extensions I've had many of my friends get into a lot of trouble because of that um but but know how to work with the goang compiler a lot like get very very good at debugging code okay so uh now things should work so it says ask me to enter the password and I will enter the password it will ask me to confirm the password I'll confirm the password it say file successfully protected try to open up the file I'm not able to okay and now what I'll do is I'll just run this um again with instead of encrypt it be decrypt and I'll just enter the password I had Ed earlier and now as you can see I can check out the file I can look at the file okay so this was our project everything works perfectly fine thank you so much for watching uh this I would say is is an intermediate level project it's not very Advanced it's not very simple uh like it's not a beginner level project probably and it's not an advanced project also somewhere uh in the middle but I hope you learned a lot thank you so much for watching if you haven't subscribed to this channel make sure you subscribe I'll come up with awesome content like this in the future thank you so much we're building something really interesting in today's video what we'll do is we'll just take some plain text encrypt it we'll get the encrypted text we'll then run it through a decryption function and then we'll get the decrypted text so it's quite straightforward it's something we haven't done before on this channel right it's uh working with encryption algorithms so we using a very simple encryption algorithm called the C are Cipher in this project and let me give you a quick demo on how this works so if I run go run main. go my plain text that I had given to the program was hello world and I get the encrypted text which is c z g g jrj mg Y and when we decrypt it again we get Hello World back right and in the program itself you can uh give it some text that it will encrypt and decrypt you can also build a CLI on top of it to accept the text from the user I haven't done that because in this project I want us to focus only on the encryption and decryption part we don't want to focus on the CLI part because I've already done that in many other projects okay so how this is working is we first take some text hello world right and by the way uh this is very quick visual programming visual planning that we'll do before we actually start programming so that we know exactly where we going and this is just a quick demo to show you how and uh how we're going to build it and what exactly uh is it that we're doing so we have our text hello world that you saw in the demo and we give this a key five so this key can change could be seven could be 10 whatever but in my case I'd given it the key five okay and I'll I'll tell you what that key means so with Caesar Cipher what what what happens is you pass in let's say all the uh alphabets so in my case in my program I had passed it all the alphabets you can also pass in numbers to this program and you can also give it special characters and what we want to do is with CES Cipher we want to replace uh this text with some other uh alphabets from the alphabets that we we have given it right so this one is going to be called as the original text because from this we will select uh some other characters that will basically replace this text of powers right so in the in the end you get something like this is CZ e jrj mg Y which is the encrypted text which nobody can understand but when you decrypt it the person who's supposed to uh receive this will get Hello World back okay and by the way uh in the beginning of computation this is how many encryption algorithms worked and now you have obviously much more advanced algorithms and that's what you see when you see WhatsApp saying it's end to end encrypted they're basically encrypting all the text that you're sending and you're getting back uh the user is getting back the actual text but then there's some encryption happening in between so that nobody can intercept those messages and read the meaning or read those messages basically so um the way this is working is first we'll take 26 which is the length of all of these uh all of the basically characters that we have sent the original text length is 26 and then we'll subtract the key which is five from that okay and then we'll create two different uh versions of this original text one is from 0 to 21 because if you subtract 26 from 25 you get the number 21 so from 0 to 21 you'll separate that into a different bucket and from 21 to 26 you'll separate that into a different bucket right and then what you do is you attach this in front of uh this part right so the one from 21 to 26 you attach that in front of this these remaining uh digits or the remaining uh alphabets or letters and you get something like this this is something called as the hash text hash text and essentially what you have to do now is you have to take H and find a uh corresponding or an equivalent um letter from here that will basically replace H okay so how do you do that first what you do is you find the index of H in the the original letters so you go to the original letters which is the original text and you find the index of H so it's a b c d e f g h this H this is H here it's the number is seven so that's the index of H in original letters which is seven and then you apply this formula this formula basically gives you the uh this this formula will give you the result of the index of the uh the corresponding uh alphabet that you have to pick up from this particular text the hash textt right so so you get i'll repeat again you get the um the position or the index of uh that number that you want to encrypt from the original text and then you run a formula and you get this is the main formula for cyer Cipher uh Cipher algorithm and then you get the position or the index of the uh alphabet in the hash text and that's the one that you want to replace this with so uh in the hash text right so firstly let's run the formula so the formula basically says the position in the original uh text of H which is 7 plus the length of the original letters which is 26 and uh modulus with the length of the original letters which is again 26 and the answer that you get here is basically uh 7even so uh in in our case uh the index of H and original letter of seven and the index of uh uh the the index from the formula that we got by running the formula is again 7 so we have to look for the seventh alphabet in the hash text so it's like 1 2 3 4 5 6 and then 7 7 is B in our case right as you can see B so we replace H by B and similarly you can run e which is hello world right that's the text we want to encrypt so e you take e and then you do the same same thing and what you get is e will be replaced by Z right so Z is and how that happens is because in the original text uh e is the fifth digit right so when you when you run this formula again you'll get five here and when you uh go to the fifth digit here 1 2 3 4 5 Z is the fifth one so that's why you say five and now you don't even have to run the formula you can just get all the other digits very easily because L is the 12th right so if you go to the original text so L is the 12th so it's 1 2 3 4 5 6 7 8 9 10 11 12 L is the 12th and that's why in the hash text also you will also look at the 12th uh alphabet or the 12th letter so it's 5 6 7 8 9 10 11 12 which is in our case it's G so that's why both the L's have been shown as G out here okay then you can get the others also really easily and this is how basically this entire um algorithm is working now this is very predictable like uh if you give this to somebody and they figure out uh like the corresponding of H and E for example in this they can easily figure out all the other letters and this is a very very simple uh encryption to break it doesn't take a lot of brains to uh to break this encryption so that's why this is like the simplest simplest encryption uh that I wanted to show you and then you've seen my other videos on on the blockchains and how we've used Shard 256 right to encrypt and they those uh more advanced algorithms have more advanced properties you have the Avalanche effect and you have uh uh what's the other term I'm forgetting the term it's basically but but the property is that no particular letter corresponds to another letter another letter right so that property is called something I'm forgetting the name right now but the Avalanche effect again is that if you change one thing in that encryption everything uh the complete uh signature changes so you have those Advanced properties that you get with Advanced algorithms you you don't have any properties with this is like very straightforward uh this this has existed from the time of Caesar I think that's why it's called Caesar Cipher it's like Way Beyond way before um the the invention of computers but it's a great algorithm to know it's it's great to get started with it encryption and it's a great project to build with goang because we'll work with uh this this little algorithm but we'll also get to apply our goang Concepts and that's what what will make us a better goang developer okay so with this out of the way let's get started now before we get started I just want to tell you that this particular uh video will be part of the 47 killer goang projects CD so I have this playlist on my uh channnel it has 47 projects in goang so in case you didn't know that you want to check you might want to check them out uh so this 47 will now become 48 because this video will will be there in that and what I'm trying to do is I'm trying to arrange these videos in the level of difficulty where some some of them I've not still not arranged them in the right order but I will do that and then eventually they will be in the right order of difficulty and you want to start from the beginning and start building projects uh one by one all right that's how you want to go about these now the next thing I want to tell you is is that we have this Discord server for my YouTube and everyone is allowed here and we discuss really awesome stuff uh like you know what we're learning today and we're having a lot of discussions so like let's say if you have any goang issues you can come here and post the issues um and we we're discussing about any issues about goang you know I I help quite a bit on this community so if you if you want you can join it all you have to do is the the link I think is out here so you have to just go here and this is I think the link for joining the community if you're not able to join it let me know I'll uh I'll make sure I'll send the new link with you okay so that's one more thing I want to share with you and the code for this particular project and all the other projects is on my GitHub so in case I don't share my GitHub link with you you have to know it's Akil Sharma 90 on GitHub and you'll find almost all of the projects here this is the one that we're building today sorry not this one this is the one that we're building today simple encryption decryption with goang using Cesar Cipher right so the code is already there uh all you have to do is just come here and uh in case you get stuck you just have to refer to that code all right so everything is uh clear now now what we have to do is we have to um I will just go back to my um the the place where I keep all my goang projects and I will just create a new directory I'll just say go um encryption YT okay and I will CD into it and here we will go mod in it and I'll just github.com ail Sharma 90 SLO encryption y so what this does for for us is it creates a go. mod file which will have the list of all the modules that we use in this particular project we're not using uh any third party modules I think mostly so you don't need to worry too much about it but still we'll just have it uh in any case here I'll just create the main.go file and this is a very small straightforward project there's not a lot of uh Engineering in this but uh it's it's small and straightforward like I said and uh it's a great project to build like great uh beginner level project to build so in my main go file I'll just say package main which is the first thing you write anyways in your main. go file and then I'll have some import related stuff right so I'll have I'll just write import here and accordingly I'll import the stuff that I want to import I'll have uh the main function obviously Funk Main and here is where I will Define my plain text which in my case is hello world you can change it also and then I'm going to print it out I'm going to print out the plain text as it happened in our demo also right same way plain text and we print we print out plain text then we have our encrypted text which is uh what we're going to get when we call our encrypt function that we will create now so we'll create an encrypt function it will take in the key in my case will be five and the plain text right so this means that here up here somewhere will be our encrypt function so it'll say funk encrypt and it will take the key which is the integer and the plain text sorry PL text which will be string and this will return to us the result which will be the string the encrypted text obviously right and then obviously uh apart from the encryption function if we have an inun function we also need the decryption function this will again take in the key the encrypted text and it's going to return back to result which is the string so once you've encrypted it you have this uh in this variable called encrypted and we will print it out first so we say I can do a print Len and encrypted text will be encrypted and then we have decrypted is equal topt five comma um and then we'll print it out decrypted come on decrypt so to the decrypted decrypt function you are passing the key and the encrypted text and you'll get that in the decrypted uh variable and then we'll just print that out so that's it that's all our Funk name is doing okay at the top I will say my original letter will have all the 26 a b c d e f g h j k l m n p q r s t u v x y z okay so original will have all of this original letter basically means this the original text this has all of the uh letters this is the plain text and this is the key five which we've passed okay now we want the hash text so for the hash text we need another function let's call it frun hash letter function takes in the key takes in the uh original letter it'll take in the original letter and we'll say result and string okay now here the first function that's called is the encrypt function so we'll start building upon the encrypt function so as you remember in the encryption part the first thing we do is is we first want this right and then we'll find the index of H the first letter we'll start we'll start letter by letter the first letter which is H we'll find the position of H in the original text but we also want this right you want the hash text because after we run our formula we want to find the uh that particular index what's the value at that index in our hash text so that's why we need this also first so well we'll call the hash letter function so we'll say hash letter function we'll pass it the key and the original letter original letter being this we'll just pass it there and to start with we'll say V hash string isal to empty now hash string is what you want to return from here so there this result that we sending back is the hash string and one by one you will keep adding to this uh empty string some values so for example for H the first value in our case as you saw here uh we'll get C right so whatever we get here C and z and G so one by when we'll keep adding values to it we'll run things through a loop and we'll keep appending things to this hash string uh and that's why first we'll start with this being empty and then we will run um actually at the end here we will will have this function called strings. map and we say find one comma plane text so strings. map what this does is it takes in uh the plane text okay in our case the plain text is actually hello world so it takes in hello world and one by one it'll send it and call this function called find one so it'll take uh H first and then e e next L lse we'll take all these things one by one strings. and then call the find one uh you know function so what is find one so find one is equal to a function it's a function which takes in r as a rune and returns a rune now what does that mean so Rune help so runes basically help you um with unicodes so what we're saying here is that um a run represents a single uni code character okay so for example a the value of a is 65 so you get the ask2 value and now you can uh work with the letters in a much more flexible way so you get separation between all these letters so for example A B C D E F because you're sending them one by one but then with run you're able to work with them in like much more easily uh because here what we have not covered is is that the runes that you'll get here also you'll use Rune to be able to work with that so we'll be using run basically all throughout to be able to uh iterate over all these letters and work with those letters uh and then perform operations on that so it'll take in our run so for each uh letter like H we take each letter from the pr text which is like the hello world right so H we take that and we send it to find one and then what the find one function is doing is it's taking in that H and returning us to us the equivalent letter uh in the in the encrypted text so in our case it will be C now how do we get from H to C let's take a look so uh first I think I'll just build the hash letter function because otherwise there will be just confusions because you know I wanted to explain the Run Part before we wrote Rune here because we using it in the hash function so I didn't do that uh my bad but I think I'll just build this function before we work more on the encrypt function so that it just makes more sense so this hash letter function right all it's supposed to do is it's supposed to um take in this key and then divide this into from a to Zu and from V to Z divide uh the original text into these two parts and then also put this in front of this and then return that part that's so we want to return the hash text from this function so we'll say last letter key equal to string runes length of letter letter being original letter in our case so from here to here the length is obviously 26 so we'll say length of letter minus key to length of letter so this is Runes of 21 is to 26 so from 21 to 26 what are the things which is in our case v sorry 2126 v w now x y z so these five things will basically come in the last letter key and then we'll say the left over letters left left over letters letter is equal to string runes and zero length of letter minus okay so 0 to 21 so this is length of letter which is 26 minus ke which is key is 5 so it becomes 21 so 0 to 21 will come in uh one place like I said and 21 to 26 will come in another place so this has 0 to 21 and this has 21 to 26 so last letter three and the left over letters now all we have to do is we have to return I told you right we'll return This plus this so we'll return the uh last letter and followed by the leftover letters so let's do that so we'll say FMP Dot Sprint F here let's say percentage s and percentage s comma last letter two comma left over letters so we able to return what we promised from this function which is the string which is the hashed uh the hash text from this function so in the encrypt function we were now in the find one function and here we will first start with the positional strings. index why the position uh if you remember I had told you that what we'll do is we'll find the index of H or the position of H and the original letters That's How we'll get seven right so this is the original text and we have to Now find the index of H there since strings. index and the original letter comma string and that there will be uh run R and now we'll get the position of that letter now uh if what if the original text that we passed original letter text that we passed somehow we forgot to write there was a type of we forgot to write H there right then Position will basically become min1 and that's what we want to check for so we want to check if position is not equal to minus1 that means the letter that you want to encrypt is actually existing in the original letter you want to find the position if it's not equal to minus one then we can do something about it otherwise it's a problem right other you just want to return the same thing return R um and finally from here we want to return the hashed string as you know hash string which is now empty we want want to fill it up so if everything is all right and it's not uh minus one then we'll say letter position is equal to position plus length original letter percentage length of orig letter and hash string Hash Hash string plus string hash letter letter position okay so what's happening here is we first find the position and then we uh run our modulus function so if you remember I told you the function or the formula looks something like this where we add the position plus the length of the original letters and we mod we run mod modul which is length of position dat so in our case be 7 + 26 modulus of 26 you get 7 right so that's what we're doing here so you get the letter of the position uh which is seven and now the next step would be to look for that uh letter which is at the seventh position in the hashed text and that's what we're doing so we're looking in the hash letter that we have hash letter hash text we passing this letter position and getting that particular value converting into string and adding that to Hash string so each each of these values from the plain text one by one because of the help of strings. map one by one we'll take it like H and e and l and O and then we'll pass it to find one find one is accepting it as a rune and also returning a rune in our case and then it's um adding everything to hashed string that's what's happening adding everything to Hash string finally we'll have as string that that's what we'll return from this function okay now the decrypt function is going to be the exact opposite of this the decrypt function is going to basically um have same method which is calling the hash letter function and we'll capture that value in a variable called hash letter so the hash function will pass the key and the original letter and again you'll start with the hash string which is entty so with the with the decryption we have to uh find again you know that value in the um in the hash letter index so let's so this is what we'll start with okay in the beginning and we we'll find the value of let's say C so in in the in the encryption we started with the original text now we'll start with the hash text so let me write it here this is decryption sorry you start with the hash text and you see that the uh hge right is of particular value and um and this is the original text here yeah so like I was saying this will happen before so we'll first check the value of that uh you know letter here let's say in our case C right so we'll notice the value is 5 6 7 uh 8 1 2 3 4 5 6 7 8 so this will be eight in our case right and then then that eight we have to find in the uh in the hashed text sorry the sorry in the in the original text so the original text is different right it's so decryption will exactly be the opposite of encryption so an encryption we first found the position of the value in the original text and then found an equivalent in the hash text and decryption will be completely opposite we'll first find the position of that particular um so C for example we'll first find the value of that letter in our hash text in this case C and then with that position we'll run that formula again and we'll get some value and then that value we have to pick from the original text and that's how we'll get back uh hello world from this text so that's the entire method that we have to follow now okay so let's do that so for encryption for decryption we say hash string is completely empty and then we say find find one and who's going to call find one um out here we'll just say strings. maap find one comma encrypted text and return hash Str right so the other thing that's changing here is that with uh with encrypt we sent the plain text to our find one but in decryption uh we're passing the encrypted text to our find one function and then find the F final function we'll say funk R Rune and Rune okay so that that was one change which is passing plain text versus passing enry text the other change which I was showing you in the diagram was that we will find the position of the uh of the the the word in this hashed letters so earlier we found it in the original letters right the first position now we'll find it in the hash letter and we'll say string run R and again we'll check for the same thing position uh is not equal to minus one check for the same thing from here we'll go R yeah this if you remember we checking because that that uh particular value that's coming in here needs to be there in the hashed text right so not the original letter in this case is the hash letter so it has to be there in the hash letter the position otherwise will be one minus one so only if it's not minus one we can uh proceed and this is how we'll proceed so we'll say letter position equal to You'll again apply the formula plus length of original letter percentage length of original letter which is mod modular and then origal letter and we'll say hashed string equal to Hash string plus string and original letter letter sorry letter position forgot the return are here okay right so uh main main differences in decrypt and encrypt is like I said we're passing the encrypted text here we're passing the plane text there and here we check cheing for the position in the hash letter hash letter being this one and here uh in the encryption we were checking for the letter position the original original text original letter here for finding the letter position formula we again we use the length of original letter only that's not that's not different that's the same thing and finding the hash string finally at the end we found here from the the hash letter we found the equivalent text and now to Crypt it back we finding it from the original letter the equivalent uh you know letter so here we'll get the back to decrypt decrypted text now uh I don't see any issues and or any errors here in the in the code so what I'll do is I'll just go here and I'll just say go run main. for so if there are any errors we'll get them here but there were not any errors luckily so we had our PL text we got the encrypted text and we got the decrypted text okay so I'll just quickly go over it again in case you missed anything uh we started with our plain text we uh got the encrypted text which is this we sent it to the decryption function got the decrypted text started with Hello World text we want to replace each single letter uh with with different alphabet the key that we passed was five and the original text we pass was this so this can have numbers this can have small characters also this can have special characters also and when we pass the key as five we run this through the original text through a hash hash function which basically subtracts five from the length of the original text so we get 21 so we divide the original text into two different parts one is from 0 to 21 and from 21 to 26 then we pass the hash text back so which is this uh before the uh before this text and we pass this back to the function in the encryption function the first thing we do is we find the index of the first letter which is H in the original uh text so in this case we get seven now we run our formula which is position plus length of original letters percentage or modul length of original letters and then we get again uh 7even and we find seven in the hashed text because we want to convert from original to the hash or the enry encrypted we'll find an or uh like a like a corresponding uh digit or letter from here and B so we found that H is equal to B Because B is on the seventh position after we ran this formula and that's how from Hello World we actually got this in this description it works the completely opposite because you find the position of C in first in the hash text and then we get that position and then we basically run it through the formula and then we get the original uh text sorry and and yeah and we get the position in the original text of that corresponding letter in this case it will be H now guys uh there's one thing that I have uh you know made a small mistake in right and I want you to to uh find that out in case you haven't figured out in the whole program one thing that I've been missing or and messing up with uh just so so that you know uh in case youve understood it please let me know where I've made that mistake uh there'll be basically ensure so if you if you go through the video again look for the mistake things will become much clearer to you and you'll be able to um completely understand this concept right so let me know if you found that mistake uh I'm going to tell you the answer anyways if if in case if you have not found it so the mistake is that the value uh the actual position of H is not seven it's 1 2 3 4 5 6 7 8 it's actually eight not seven so that's why you have to write here eight and you have to write here8 you have to write here eight then have write here 8 and should have in C right H should be equal to C and not b and that's how you get C right here right so I made that mistake um and now you can actually go and run the actual values and you'll see everything is consistent all right so that's perfect I hope you were paying attention now when you looked at the mistake uh everything will make sense right so um so what I want you to do is I want you to uh run through uh the entire code once again and run through those values once again so that you basically internalize whatever I've taught you uh try try to put different values here like smaller text and then special text characters all of that try and and see uh how that works and thank you so much for watching this video uh I hope you will join our community on Discord where we'll get to hang out and you'll watch all the other videos in this um in the uh in the in the goang playlist all right so thank you so much and I'll see you in the next video