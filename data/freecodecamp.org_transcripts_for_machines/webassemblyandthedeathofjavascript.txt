i'm talking to you today about web assembly and asking the question uh is this going to be the death of javascript and yeah it might not be the best meetup to ask a question like that if you feel like throwing something at me that's fine just wait till the end that's all cool so i'm going to start off in typical fashion with a brief history of the web and i'm i know the web is a complex complex set of technologies i'm mostly going to be looking at javascript and as i think most people have worked with javascript for a while know the language itself was invented in a very short space of time by a chap called brendan ike he invented it in just 10 days and back in 1995 the web was a very very different place it wasn't the kind of dynamic single page app react type environment that we know right now it was mostly static pages the occasional form and javascript was there to just add a little bit of interactivity on top of an otherwise pretty static web since then other languages have come along and java applets activex flash you might have used some of these silverlight my apologies if you've used that dart and so on and that's it that's the history of the web done because 2018 it's still javascript it's still only javascript javascript is the only language which is officially supported by the web but the interesting thing is the way that we're using javascript has changed a lot in the 20 odd years since it was originally invented i guess without going into too much detail one of the things that's that that i've observed is that we collectively we write a lot of javascript and when i say a lot i mean a lot of javascript and just the other day i i started up a new react app so i used the create react app package so this is me creating a new application uh and then finding all the the javascript files within the project and doing a line count 79 000 lines of javascript that's a lot of javascript and the thing is we we're we're using javascript uh for far more than just adding interactivity on web pages which is the world that brendan ike uh was was creating javascript for we're using it as build tools we're using it on the server we're using it on mobile devices we're using it all over the place but the weird thing is the way that we're using the language itself has changed quite a bit many years ago i guess when i first started using javascript it was quite simple you'd open up a text editor you'd write some javascript it would be served over http and exactly the code that you you had written would be executed within the browser that doesn't happen very often these days typically the code that you write will be transpiled it will be minified it will be bundled it will go through all kinds of really quite advanced transformations and by the time it lands in your browser it will look a bit like a garbled mess and that's led a few people to consider javascript to be the assembly language of the web it's it's a compilation target as well as the language we use uh to write our applications but this is where sorry move my cursor this is where the problems start to surface because javascript actually isn't a very good assembly language and it's no surprise again reflecting on the context within which it was invented in the first place it was never designed to be an assembly language it was never designed to be a compilation target and to understand why it's a bad uh compilation target why it's not a good assembly language you have to understand a little bit more about how javascript is executed within the browser so this is a diagram that i took from a a mozilla blog post where they were giving a a rough overview of how javascript is executed within the browser so the first bit on the lefthand side is a bunch of characters come along over http and they're parsed into a thing called an abstract syntax tree it's a it's a treelike representation of your code after that it it generates some by byte code which is then run within an interpreter and then this is where the really clever stuff starts happening many years ago that was it that was the way that javascript was executed these days a lot of work has gone into optimizing javascript so what will happen is the runtime will start to look at your code look at the execution and make certain assumptions if you've got a function that is always called with a pair of integers for example it will generate an optimized version of that and the execution of that function will become faster and i think it was the um safari browser has something like four different tiers of optimization and your code sort of moves up and down these tiers so as it as it can spot optimizations it moves up a tier but if the assumptions it makes about your code is false it has to push it back down again it's really really complicated and as you can imagine this isn't an efficient uh compilation target and how how does this actually manifest itself one of the things that as a javascript developer most of us or pretty much all of us are concerned about is the execution speed of our our code within the browser and there's the one of the most important things something that people have been focusing on a lot recently is is the time to interactive the time it takes to load all your code and actually start doing something and this is a timeline that i shamelessly borrowed from this fantastic blog post by lynn clark it's it's well worth the read she does an excellent job of describing why webassembly is needed but i'm just grabbing this diagram here this is a timeline that approximates the execution of javascript within your browser so the first thing it does is it has to parse your parse your javascript the next is it has to compile and optimize it and then potentially it will have to reoptimize it and then afterwards you've got a certain amount of execution and garbage collection the timeline you see here the the pass time the compile time the optimized time has a significant impact on how long it takes for your application to actually execute and be interactive so this is again why i'm saying that javascript isn't a good assembly language this isn't if you were designing it from scratch you wouldn't design it like this and i guess this this little quote here i think summarizes it quite nicely this is a quote from the team that created webassembly and they mentioned that the web has become the most ubiquitous application platform ever and yet by historical accidents the only natively supported programming language for that platform is javascript and this is coming from a bunch of guys who are uh web developers and they love javascript so it's not that they're not against the javascript languages itself but the the situation we've found ourselves is is a weird quirk of of history so that brings me onto webassembly if you look at the webassembly specification the webassembly website they describe it as a new portable size and load time efficient format suitable for compilation to the web so it was designed specifically to solve some of the problems i've been talking about now hands up if you've heard of asm js before okay that's that's good so an interesting part of the history of webassembly is quite tightly related to asm.js don't worry if you've not heard of it before it doesn't matter i'll give you a quick illustration of what it is and hopefully that will help you understand some of the design goals of webassembly so asmjs was a a bit of an experiment it was actually a bit of a wacky idea that was uh created by mozilla i think around about five years ago and at that point in time there were various other pluginlike technologies being uh considered in the standard plugin model is you take some other runtime and you kind of bolt it onto the side of the browser that's how that's how plugins worked and at that time there were other people considering other plugin style models whereas the mozilla team came up with this slightly crazy idea of why don't we create this sort of virtual runtime that sits within the javascript virtual machine so they said okay we need memory so we'll just have an array that can be our memory we need instructions so we'll create effectively patterns within our javascript that represent those instructions so i'll quickly illustrate what it is and then show you why that is a great demonstration of a slightly better way of doing things so here's a here's a bit of code this is some asm.js code don't don't worry too much about the detail at the top this is a a um a function written in c that does your standard fibonacci calculation i'm compiling it using a tool called m script and into asm.js and that's what you see at the bottom there so asmjs is javascript but it's a particularly peculiar looking kind of javascript i'll highlight a few things i won't go into all the details but the first thing you'll see here is the reassignment of the arguments to this function so a equals plus a so typically you'd use that to kind of coerce something to be a number b equals b or zero which means that it's exactly the same as it was previously these are type hints these are telling the runtime that one of these is a float and one is an integer you can see at the bottom it's returning plus c again you can see the pattern here that res in my c code is a float you can see that we've got in the javascript code a for loop asm.js doesn't support for loops here you've got a do while instead so that all looks a bit crazy and you might be asking why on earth would you do that getting back to the way that javascript executes within the browser you can see what they were trying to achieve with asm.js so what happens with within a browser that understands it well firstly if the browser doesn't understand asm.js it doesn't matter it's just plain old javascript and it executes as normal however if the javascript recognizes asm.js and it does that by looking at this use asm literal string at the top what it does is it starts doing the usual thing it passes it into an abstract syntax tree but then immediately it spots the patterns it effectively reads the asm.js assembly language and immediately is able to push it right up the um right up to quite a highly optimized version of the code skipping some of the quite timeconsuming interpreter steps and optimization steps so as you can imagine this is quite a neat idea but i think asm.js was only ever put together as a a technical proof of concept because one of the things they could never get around is the very first bit at the beginning the parsing the javascript language and as you can see it's asmjs is itself pretty verbose so as you can imagine parsing it to the abstract syntax tree has got quite a lot of overhead but asm.js was a great proof of concept that there might be a better way of doing things and their early demos were really quite impressive the m script and tool they use also had logic in it to convert opengl code into webgl code and they were able to take some game engines and do some pretty impressive things so asmjs pointed pointed people towards a a different and interesting approach to solving this problem which was quite different to the standard sort of plugin model as a result the webassembly working group was formed and it was formed in 2015 with with representation from all the main browser vendors and a bunch of others and quite impressively within the space of two years they managed to design their mvp scope for web assembly and and get it released in the wild so in november last year um it was turned on in all brows all major browsers without the need for flags so it's officially out there in the wild it's also in node version 8 and and beyond and just earlier this month w3c published their first public draft as well so they managed to get this done in a very short space of time and i think it was mostly because asmjs effectively created a blueprint to demonstrate some of the concepts here so i've talked a lot about webassembly but i haven't actually shown you any webassembly so i thought the best way to do that was to actually show some code and talk around the code just so you get a better idea of what it actually looks like in in real life so switching to code this is obviously where it all goes horribly wrong um okay so i'm going to start with a very very simple example this is a function that adds two numbers together and even though this is visual vs code that's actually c which is horrible and dirty and makes me want to wash my hands but there you go there's an add function and what happens is with my build my tool chain i'm not going to go into too much detail about that my tool chain is compiling that into webassembly and there are two distinct formats that you can use to view your web assembly the the obvious one is oh tiny tiny is in hex so the output of webassembly is a binary format so again uh recalling how javascript is is processed by your browser it no longer has to pass the characters into an abstract syntax tree it's a compact binary format but the more useful way of looking at it is the um actually they've changed the file extension for this it's the watt format web assembly text format it's a shame they didn't go for webassembly text format wtf as an extension that would have been awesome but anyway this is my c code so i'm adding two two numbers together and this is what it looks like as web assembly so a few little bits and pieces here we've got the concept of memory so memory within webassembly is very similar to the memory concept they invented with asm.js memory is a contiguous array of bytes and that memory is actually shared between the webassembly runtime and the javascript runtime so you can you can make rights to the webassembly memory from your javascript code it defines functions it's got a whole load of instructions there are about 60 odd instructions and it works as a stack machine if you've done any if you've done any programming with some kind of assembly language of some sort the full instruction set will look quite familiar to you webassembly can also export and import functions so you can export a javascript function from your webassembly module so you can export a webassembly function from your module and invoke it from javascript and vice versa you can import a javascript module so that it can be executed by your javascript so that's that's my web assembly and we've got the binary format and i'll show you how it's actually loaded instantiated and instantiated and executed now because i can't be bothered by with creating a html page to house this i'm just doing it within node but it's pretty similar within the browser so we're we're loading the webassembly binary format and we're constructing a module from it and then from the module we're creating an instance from the instance we can invoke the exported functions so here if i execute add it tells me that two add three equals five so here i've gone from javascript it's executed a webassembly function within the webassembly virtual machine and return the result that's all all pretty straightforward i'll show you now some of the areas where it gets a little bit tricky and now i feel like i'm showing you a bit of a tip of the iceberg in that it's not a simple case of just writing a whole load of code in webassembly um creating an api layer and invoking it from javascript at the moment it's relatively challenging to do that one of the reasons for doing that is that webassembly has a very small number of builtin types it only has four types and they're all numeric so it's got two floating points and two integer types what that means is if you want to do something with something a little bit more advanced like strings it gets quite complicated so my next little demo is just something which returns a simple string from my webassembly function and renders it from javascript so i'll just um pop back there okay so this is my c code so what i've done is i've created a a hellowasm string which is referenced as a character pointer and i've got a function which is get message ref so what that's doing is is returning the reference to the message if we look at the compiled output it's a little bit more complicated this time we've got these things called data sections within our webassembly module and these are basically ways of instantiating your webassembly module memory to a known state and here you can see it's actually writing hello wasm it's writing something else which i think is the offset to uh actually i'm not sure i'll have to check that it's writing something else and here is how it's actually executed within javascript and here you can see that simply by um changing it from an example based on integer types to strings things get a little bit more complicated so we've seen this bit of code before this loads our webassembly binary and instantiates a mod module but now to return the string the the get message ref function isn't returning a string it's returning an integer which is an index to the location of that string within linear memory so i'm having to get hold of a reference to my linear memory create a create a buffer and iterate over that buffer populating it with going by byte across my linear memory reading the data out and if i execute it and it does indeed say hello wasm and that's by all means not an exhaustive exhaustive demonstration of webassembly but hopefully it gives you a bit of a feel for how whether how you use a web assembly module from from within javascript and some of the current limitations that there are so a little bit more on the webassembly architecture so webassembly itself is a stack machine as i mentioned it has four builtin types 67 instructions importantly it's designed to support streaming compilation so there are some features that are specific to webassembly which reflect the context it's used within for the vast majority of use cases your code is being streamed over http so it makes sense that webassembly can be compiled in in a streaming fashion and what that means is your your browser is able to chop up the webassembly module and compile it in parallel on multiple threads so again it's been designed to be very very fast it all also has some very simple validation rules javascript and any other webbased language has a lot of validation rules that ensure security webassembly is just the same but again they've been designed in such a way that they can be processed and in serial as it's streamed in and as i mentioned before exports imports functions and has a concept of shared linear memory with javascript now one of the first questions that people ask when they look at webassembly is oh great this is going to be super duper performance it's going to be really really fast and i must admit i've read a lot of blog posts which makes some quite um quite impressive and to be honest quite incorrect claims about the performance of webassembly i've seen blog posts claiming that it's a hundred times faster than javascript unfortunately most of those blog posts suffer from the classic problem of doing micro benchmarking and either bench benchmarking the wrong thing as well so what i did was created a slightly more representative test case i created a a mandelbrot and rendered that using c javascript and a bunch of different mechanisms for for generating webassembly modules and i perfor i compared the performance of them and as you can see the black line here is the native performance so that's my c code uh compiled directly on my mac and executed natively and the interesting observation immediately is wow javascript is really really fast it's only about 20 slower rendering a mandelbrot and that's because of the many many years that's gone into compiler opt the runtime optimization for javascript disappointingly when i ran it within webassembly it was actually a little bit slower and using wasm assembly script and a few other different approaches i eventually through a number of optimizations managed to make it just a little bit faster than javascript so i must admit i was a little bit disappointed by that result i've had a look at other benchmarks and other results and most importantly the the paper that was published by the webassembly team the uh the accepted sort of general feeling is that web assembly should be around about 20 to 30 percent faster at runtime execution than javascript but because javascript is is really quite fast there are there isn't that much of a performance gain to be made where they expect webassembly to beat javascript significantly is the parse time and the initial compilation time so the time to interactive with webassembly should theoretically be a lot less than with javascript so in the future one of the things i mentioned was that webassembly was developed over a really quite short space of time and partly that was because they had asmjs as a kind of reference implementation another reason is the current webassembly release is very much an mvp they were quite aggressive about ensuring that they had a very small set of features so they could release quickly and the idea is that they're going to be releasing new features over the over the coming years so some of the things that it doesn't have at the moment is a garbage collector and i'll explain why that's a bit bit of a pain later on in the future it will also have threading support a thing called host bindings which is a way as i showed you the interface between javascript and webassembly is a little complicated at the moment and if you want to start doing dom manipulation from webassembly that's hard with host bindings in the future that will become a lot easier so one of the final things i want to look at is um web assembly language support and what some people are actually doing with the language so i showed you a little bit of writing a bit of c code as a way to show you what webassembly actually looks like the text format and so on but most people aren't going to write webassembly in its its machine code well in its binary format or in the text format most people are going to want to use a language maybe c maybe not rust go people are going to be using other languages and treating webassembly as a compilation target so i'm going to quickly look at the different languages and their current level of support so the first one is c or c plus plus and this is the the very first language that that gains webassembly support and again that's due to its heritage from asm.js there's a tool called mscrypton that you can use to compile c to web assembly and m script and does a lot more than just um a straightforward compilation it has as i've mentioned it's got the opengl to webgl bindings and it's got a whole load of other things that make it quite easy to take an existing c code base and compile it to webassembly and put all the glue that's required around it to actually make it work as i mentioned it was originally used to create the asm.js concept some of the practical things i've seen people do with it there's a there's a company that have a thing called ps pdf kit um it's basically a pdf renderer and um just last year they started exploring the use of webassembly so they've got a c plus code base and they explored the use of webassembly as a way of of using exactly the same code base to do pdf rendering on the web and they they found it quite a good experience they managed to create something which i think they're going to actually ship as a as a product and with very good performance this one's a fun one uh jsc so the javascript core which is the javascript machine that runs within within webkit is itself written in c plus plus now using m scriptin you can compile c plus to webassembly so what that means is you can take javascript core compile it to webassembly and then run it on top of your javascript virtual machine so what this is is um the the uh safari javascript virtual machine compiled to web assembly running on chrome which is great it's exactly what you need finally um one thing you'll probably notice here is at the moment a lot of people are essentially experimenting with this technology there aren't you won't find a huge number of really practical use cases yet i think that's still to come although where i work at scotlogic we've done a bit of work with a company called active financial and they provide they provide market data for people that need high frequency data so people that are doing um algorithmic trading for example and all of their distribution logic all their serialization logic is written in c and c plus plus and they've been getting a lot of requests from from their their clients who want to start using it consuming this data from within javascript either perhaps aws and a lambda function or perhaps within the browser so we help them take their c plus code compile it to webassembly and use exactly the same code to to to parse their packets of data and deliver their high frequency uh data to the web so that's something that we were able to achieve with webassembly uh oh that should say c sharp that's a mistake anyway so c c plus plus that's the story um java and c sharp these ones are a little bit more challenging because as you're i'm sure you're aware java and csharp are languages that both rely on garbage collection whereas c c plus you manually manage the life cycle of your objects and because webassembly doesn't have garbage collection yet that means it's a it's quite a a problem it's quite a challenge to take java and c sharp code and compile it to webassembly there's an experimental project called blazer that's become an official i think asp.net experiment which uses mono some of you may be aware of mono as a way to run java and csharp within webassembly and what they're doing is they're experimenting with a couple of different ways of doing it one of one of them is interpreted mode so they've basically taken the runtime and compiled it to webassembly and they're executing they're executing csharp dlls directly within the browser the other one is ahead of time compilation so they're actually compiling the dll directly to webassembly and they're they're experimenting with these two side by side blazer is a project that wraps around mono's webassembly support and it's a fully featured singlepage application framework so there's a lot of csharp developers getting quite excited about the potential of blazer i don't have anything practical to show on on csharp and blazer because it's very very new and i don't think anyone's done anything practical with it quite yet so i guess one of the final ones to talk about is is javascript so why why shouldn't you compile javascript to webassembly and then there's a lot of people writing react applications and all kinds of other based applications and and you look at the features you get with webassembly and you think yeah i'd like some of that i'd like my javascript to to pass more quickly to be optimized immediately so there are a lot of people trying to find creative ways to compile javascript to webassembly and obviously there are even more challenges there so firstly you need a garbage collector secondly it's not statically typed so you've got typing as a bit of an issue there are a couple of projects i've been keeping an eye on that are trying to tackle this first is called walt which is a javascript like syntax for webassembly so what they've done is they've taken that textbased format which i've shown you and tried to map it as closely as possible to javascript so it's it's a thin veneer on top of the webassembly text format the other one that i've actually had a bit of a go with is assembly script so in order to solve the typing issue that's pretty straightforward with javascript these days you've got things like flow and typescript that introduce typing so with typescript you can enforce typing of your code and use a very similar compilation path that you do for c and c plus and at the moment that project is is in its early stages and they're currently awaiting news of when garbage collection will appear within webassembly to make some fairly critical design decisions about how they how they tackle that i've actually got a bit of a demo uh hopefully i typed in the wifi password so has anyone used d3 before yeah cool yeah everyone loves d3 so this is a d3 force layout but what i've done is i've taken d3 force layout and taken all the algorithmic code and rewritten it using typescript and compiled it to webassembly so basically the um the standard sort of end body algorithm and the kind of hooks law spring concepts are all being computed here within webassembly using typescript and it was quite an interesting experiment for me to see how easy it is to take a a javascript application that wasn't written in typescript add type information to it and then compile it to webassembly and work out how to manage the interface between the two so actually if you scroll down uh if you scroll if i scroll down you can see it's got it it supports exactly the same api as d3 itself but all the computations being done in webassembly that that was good fun i enjoyed that actually i'm going one thing i'm going to do is i'm going to get rid of that demo because it's got a memory leak yeah i know the final one i want to briefly touch on is is rust um has anyone used rust here before no definitely the wrong room for that oh a few yeah so rust is is gaining popularity quite quickly if you ever have a look at the sort of metrics stack overflow does a survey every year and they do quite a lot of data analysis and rust seems to be a programming language that makes people really really really happy so it's a modern language it's a very very popular language significantly here it doesn't require a garbage collector it's got quite an interesting memory model that has the concept of ownership so every every object that's allocated on the heap is only ever owned by one reference at one point in time which makes it very very easy to reason about memory and clean up memory it's hard getting your head around it initially but it's a good concept so within rust what they did was they used the m script and tool chain and are actually investing time in creating some better tool chains and i found this quote actually from someone within the russ community who says we're poised to be the language of choice for for webassembly and the reason for that is it's a much loved language and because it doesn't need a garbage collector it's actually in a great position for for being compiled to webassembly right now so um i had a bit of a play with it myself i created a a chip 8 emulator so chip 8 is a a pretty old um engine for for playing arcade games i say engine it was it was one of the very first virtual machines actually it was developed by someone who at the time came up with a concept for a virtual machine for playing games that could then be incorporated into a number of the the current computers at the time it was a great idea it wasn't terribly successful but it's great for people who who want to experiment with creating emulators because it's actually quite a simple machine to emulate so for me this was great fun having a go at rust i'd not used rust before so trying to do rust write an emulator which i'd not do before and then compile that to webassembly that that kept me up a lot of nights but that was good fun but having said that um people are doing some really practical and useful stuff with rust and webassembly and again a lot of this is coming out coming from mozilla so in a very recent blog post um they've talked about some of the work they've done on source maps so source maps uh is if you if you're not aware of what source maps is source maps is a technology that allows you to map that highly mangled version of the code that runs in your browser to the source code that you created in the first place so source maps are a way of mapping from one representation of code to another and source maps as you can imagine quite computationally intensive but the most popular source maps uh library that supports um parsing and understanding source maps is all written in javascript and the team behind it decided to take some of the most performance critical logic rewrite it in rust compile it to webassembly and then evaluate the performance and you can see here one of the performance metrics they were looking at was the time it takes from setting a break point to be able to actually inspect your code so basically to be able to to pass i don't know if pause is the right word but understand the source maps and map the breakpoint back to your original code and as you can see here the webassembly performance i know the text is a bit small there at the bottom but the web assembly performance is these little blue clusters so a couple of observations the first one is clearly webassembly is is quite a bit faster in the order of two to three times faster but another interesting aspect here is the javascript performance you'll see quite a spread in performance and that is because again of the nature of the way that javascript is executed it goes through multiple tiers of of optimization where it might be optimized and then deoptimized and what that means is your runtime performance isn't terribly predictable whereas within webassembly the runtime performance is highly predictable in comparison so that was that was a fantastic blog post and a really interesting read and the interesting thing is even though this was done as an experiment and if they're happy with it if all the unit tests run they can put that in production now and everyone who uses source maps directly or indirectly is then going to receive the performance boost so finally um i want to do a bit of crystal ball gazing so as i've shown you that the current state of webassembly is is is variable depending on language and in terms of what people are doing with it again there's lots and lots of experimentation but now i think we're starting to see the signs of where it's actually going to be used in future and how it's practically going to be used so my prediction for 2018 is as you can imagine lots more creativity mostly coming out of of languages like rust but we're also seeing a lot of creativity with c sharp i have a feeling the swift community are going to be very very keen on this because swift has a lot of common attributes with rust it's a modern language it's quite a pleasant language to use and also using um arc ultimately yeah automatic reference counting it's got a memory model that's quite compatible with webassembly also within 2018 uh i don't know if you've noticed two days ago there was a new webpack release version four and that included webassembly support so webassembly as a top chain now allows you to import rust directly within your code and web assembly webassembly sorry webpack because it's magic will do its magic and the right thing will pop out the other end hopefully if you get your configuration right so yeah if you get configuration right it's great if it's not right then it's hell but um i also think that within 2018 you'll start to see webassembly sneaking into your daily workflow without actually knowing it so as i showed you right back at the beginning when i create a react application it adds 79 000 lines of javascript to my machine and most of that code is is being used at build time very little of it is actually being used at runtime i think that 79 000 is going to start going down as people start to use web assembly to hit performance critical parts of your of your tooling another thing i think you're going to start seeing is native node modules using webassembly i don't know about you but i find it quite frustrating that the workflow involved in using node modules that have native code there's a lot of friction there now there isn't a terribly good reason to do that anymore you can actually ship webassembly instead so 2019 within webassembly itself i'm pretty sure we'll start to see garbage collection host binding threading we'll start to see webassembly itself become a lot more powerful as a result c sharp and java some of the languages that require a garbage collector will become firstclass citizens of the sort of webassembly ecosystem i think we're also going to start seeing um wasm ui frameworks so we're going to start seeing ui frameworks that are targeted that are entirely written as web assembly and and and geared towards um perhaps csharp or java developers and we're already starting to see that i saw a project which was called asm dom which was a virtual dom so modeling the react concept a virtual dom written in c plus plus compiling the web webassembly whereas next year i think that'll actually start to become a practical option also i think we'll see more of our our general plumbing move to webassembly for example again using react as an example it does some computationally intensive tasks to do the dom diffing why not put that in web assembly uh others other frameworks for example there's a thing called the glimmer vm which is a templating engine which i is in one of the ui frameworks whose name i can't remember but i'm pretty sure that will move to webassembly as well interestingly though i think we're going to start seeing rust go swift and other languages start to gain some web market share you might think that's a good thing you might think that's a bad thing but i honestly think it's going to start happening 2020 and beyond again i'm going to go back to that quote the web has become the most ubiquitous platform ever yet historically by accident the only language that is supported by the browser is javascript i think in 2020 we're going to see that that being challenged um javascript will no longer be the only language of the browser and the web i also think people are going to start making significant progress towards compiling javascript directly to webassembly again for the very reason that javascript is a perfectly good language for writing web applications there's absolutely nothing wrong with it but at the same time as javascript developers start seeing rust developers and swift developers benefit from webassembly they're going to be wanting to get some of that as well my gut feeling is that the javascript language itself will start to move towards some of the typescript concepts to allow webassembly compilation if you've been following the way that typescript has evolved over time typescript has deliberately stayed on a relatively convergent path with the javascript language itself i have a feeling that some of these features typing for example might become a first class feature of javascript in order to allow us to compile to webassembly finally i guess it regretfully i do honestly think javascript's popularity will decrease a little bit is anyone going to throw anything at me quite yet now maybe leave it a little bit i'm a big javascript fan myself honest no but i do honestly think um javascript has got a monopoly at the moment and and the web platform is ubiquitous it i don't i think it's a safe bet that javascript will start to have a bit of a fight with some of these other languages but at the same time i think the reach of the web will increase even more so i think through progressive web apps so progressive web apps are currently talked about mostly within the context of mobile but progressive web apps make a lot of sense on the desktop as well so i think a combination of progressive web apps and the ability of webassembly to allow you to do computationally intensive complex operations will mean things like photoshop for example will become a progressive web app i think things like autocad the autocad team already are looking at webassembly i think the ubiquity of the web will increase or the ubiquity of javascript will and webassembly will increase and move more onto the desktop so yeah that that pretty much brings me to the end web assembly and the death of javascript and i'm going to say no it's it's not going to die but i think it's got a real fight in its hands and if you disagree you can start throwing things at me right now