hey folks today we are gonna build this plugin from scratch using modern cplus plus and the juice framework in this free course check the description for links to the repository and to download the final build okay what is this thing this is the little brother of this other plugin which is my new course for pfm c plus four musicians which is where you can build this other plugin which is also where you can learn modern c plus and the juice framework from scratch taught from the context of writing audio software in a mentored environment you're not following videos you're not watching someone else code and you're not copying them you're coding it yourself and i'm reviewing your work all right enough about those let's learn about what we are going to build today this is a 3band equalizer with a spectrum analyzer at the top it has a lowcut band it has a high cut band and has a parametric band in the middle the lowcut band lets you cut out all of the low end of the signal you can also control the steepness of the cut the high cut band lets you remove all the high frequencies and you can also control how steep that cut is the parametric band lets you add notches or boosts and we can also control how wide or how narrow those boosts are and we can control the frequency everybody's familiar with this type of swept frequency sound above that there are bypass buttons which allow you to disable individual bands which is always helpful when you're working on audio and above that is the response curve which gives us a visual representation of what the filters are doing then behind that is the spectrum analyzer and this shows us what we are hearing and these always use a bunch of cpu so there's a bypass button for that as well we're going to learn all the dsp that's going on in the background that makes this thing work we're going to learn how to draw everything how to draw the sliders the bypass buttons how to draw the response curve and make it respond whenever we adjust the sliders and how to draw the spectrum analyzer okay that's the feature set for this plugin and for this free course my name is chuck i go by the name matcat music on youtube and instagram once again check the description for links to the repository and to download the final build of this plugin so let's get started and write some audio software using modern c plus plus and the juice framework from scratch all right the first thing we need to do is get set up with the juice framework now if you've never done any audio programming before fear not the only things you need are two tools the juice framework and then an ide to write code in that could be xcode or it could be visual studio it depends on what operating system you're running i'm on mac so i'm going to be using xcode for this video if you've never set yourself up with an ide before i have two videos linked in the description they take you through the process of setting up your computer with an ide getting the juice framework setting up producer setting up a git repository making your first project and then um pushing changes to that and um yeah it basically gets you familiar with the flow with the workflow that goes in with being a software developer in the context of writing audio software okay so the first thing we're going to do is go get the juice framework so let's do that right now i'm going to open up safari because that's just um this is like just a blank os install and i'm gonna install um i'm gonna grab juice so juice framework just gonna search for it it is hosted on github so i'm gonna go grab it here now what i'm going to do is i'm going to clone the repository and the reason is because um this is an active repository they make a lot of changes to it okay so especially on the develop branch we want to make sure that we have all of these changes because stuff's getting fixed all the time features are being added that sort of thing so if i have the repository cloned i'm able to pull in those changes this is different from if i had just downloaded a zip file so that's why i'm going to do that okay i'm going to go to terminal if you don't have terminal open just you know terminal open it like that or open some kind of command prompt shell okay then i'm going to uh let's see i've got my um my users folder right here and i'm just going to clone the repository right into that so git clone and then the url just like that that's going to make the juice folder and it's going to download this repository into this folder and it's in it's going to include all of the commit changes as well so let's just wait for this to finish all right there it goes there's the juice framework now what we want to do is switch to the develop branch because as i had shown it is um more it contains more recent changes than the other branch you can see that the develop branch is 19 commits ahead of the master branch so to do that we need to type in terminal uh first we need to go into the juice folder so let's do that right now cd juice dot slash juice and now we need to do git check out develop like that all right switch to a new branch develop okay cool now i prefer to use a git gui so i'm going to be using fork from now on in the course of this simple eq that we will be building so i'm going to open that now so we can see what this repository looks like in that sense so i'm going to open up fork fork is available from fork.dev okay so here is the repository i had already added it previously um and you can see here's all the commits that have been added and all the basically all the work that they've been doing on it and you can see how frequently they update the develop branch okay our next job is to open up producer and use producer to make a project pro juicer is found in the extras folder inside producer now inside here you're going to find a builds folder and in there is a project file for each operating system you got linux you got mac and you got windows so if you're on windows open the solution file depending on which version of visual studio you're running if you're on mac you're going to open up the xcode file if you're on linux there's a make file and you linux users know what to do with make files so i'm not going to talk about that okay i'm going to open up producer the solution file that's going to open up xcode and now all i need to do is just build and run okay so we just need to wait for this to happen apologies if i start speaking fast i like doing this stuff a lot and when i get excited i start to speak really fast so if i happen to speak too fast i'm probably gonna take a step back and repeat what i say slower so just apologies in advance if i start speaking really really fast all right so let's wait for this to finish building build succeeded now it's going to run it and then we will be able to configure uh this stuff all right so let's get this set up okay we are presented with the new project wizard before we do that we want to go to producer and we want to configure our global paths and these need to point to the juice folder and the modules folder now the juice folder by default if you clone the repository to your users folder this stuff is going to be set automatically it's going to go right to your users folder and the juice thing however if you decide to put it somewhere else you need to customize these modules so click on this button right here and then navigate to wherever your juice folder is stored for setting the path to juice then do the same thing for the modules click click that button navigate to your juice folder and then navigate to the modules button to the modules folder inside of that okay and then if you rescan it'll tell you if there's any issues or not once that is done now you can go to the plugin right here basic and we're going to create a project called simple eq and then we can do create project and it's going to ask me where do i want to save this create project i want to save it to this programming folder and there it goes it's going to save it it's going to make it and now if i reveal in finder here is my project so i'm going to make a git repository next before i actually take a look around at the code because it's always important to set yourself up with the git repository in case you have to backtrack and undo some stuff or whatnot so i'm going to do that next all right so in the interest of keeping everything neutral i will not be creating the repository in fork but i will be doing it in terminal because everybody's computer has a shell it may not have fork in it so what i need to do is first navigate to the folder that my repository is in so i'm going to do that cd i'm just going to drag this folder in here now i'm inside that folder and now i'm going to do git init like that okay now uh i'm not seeing it so i'm gonna turn on um hidden files and now here is my git repository okay so what i need to do next is create a i need to do an initial commit and commit the state of this now i do not want to include everything that's in this builds folder and i do not want to include uh everything that's in this juice library folder because a juice library code folder because every time we resave this producer file it recreates these folders the only thing we want to keep is the juicer file and the source file so i'm going to add a git init file first or a git ignore file sorry so i will do touch dot get dot get egg nor like that that creates a document which i can open with a text editor and specify that i want to exclude this builds folder and this juice library code so let me go do that i'm going to open this with uh i'm going to open it with text edit that's fine and i want to write star star slash builds caps star star slash juice oops library code okay that's the name of these two folders and then uh because this is os x i'm going to do star star slash dot d s underscore store like that we're not seeing any of those files right now but sometimes we will that's um basically it's the if i can figure how this folder looks um it's gonna get stored as a ds store file and those are super annoying to include um in your repository so it's very good to keep them excluded okay next i'm going to do git um let's see git commit dash m this is my initial commit let's do a git status first let's see what we got get status we can see that there are no tracked files so let's add our files git add and you'll notice that it's the untracked files does not include anything in the builds folder and the juice library code folder and that's because of the git ignore file it's doing its job let me just move this out of here so you can see what i'm talking about so if i do that again um let's see let's do um get status we can see we've got these new files here but it's also not tracking these guys so there is a ds store somewhere there's a builds folder and there's a juice library code okay as i said before we don't want those included so i'm going to put that back and then we'll do git status one more time okay so we've got our git ignore the juicer file and then the four source code files all right now that we have those ready to be committed let's make a commit git commit dash m initial commit whoops i forgot the closing quote all right that's fine good enough okay now i can open this in fork i can do file open repository so now i can actually see what's going on and here's right here's my initial commit all right good times okay so if we want we can go make a repository on github and push the code there um or you know just keep it local but either way now we can keep track of everything okay so i'm going to give you a quick overview of where everything happens in the source code now before we actually start work on this okay so this is going to be a brief overview of how these plugins work and um what where we will primarily be spending most of our time doing edits in the code so we have four source files right here we've got plugin processor.cpp pluginprocessor.h plugineditor.cpp and plugineditor.h in uh let me pull up the assistant editor so that we can see what's going on on both sides okay plugin processor.h um in a juice plugin you've got two main functions that are the most important there's your prepare to play function and then there is your process block function prepare to play gets called by the host when it's about to start playback and then process block is actually what happens whenever you hit the play button in the transport control when you hit that play button the host just starts sending buffers at a regular rate into your plugin and it's your plugins job to give it back any finished audio that is done processing you cannot interrupt that chain of events if you add latency or whatever it can cause clicks and pops in your speakers and that has the potential to damage speakers as well as explode eardrums just imagine this scenario that you're at a club and the sound system is super loud and your plugin causes a pop or a glitch the sound you know the sound engineer or the dj or whatever has their thing totally cranked and there's this huge pop and everybody's ears just go like that so that's why um that's the big thing about audio processing is you can't um interrupt this process block and anything that goes on inside it you have to just kind of um you got to figure out how to get all the all the work that you need done by your code done within a fixed amount of time okay so those are the two big functions we're going to be spending most of our time with prepare to play and then process block now um let's take a look at what happens over there so in prepare to play use this as the place to do any preplayback initialization that you need and then in process block this is where you get your actual block of audio data um and if you're using a midi controller these are where the midi messages are but basically um this is where we do all of the work we're gonna be typing all a bunch of code here and we have to make sure that it um doesn't happen in like more time than we have been allotted okay let's go take a look at plugin editor now plugin editor is where we set up all of our visual elements and um there's some basic stuff you got your basic constructor you got your paint function your resized function uh painting you know it's what we're gonna see right now we're showing a hello world if i run this real quick so before i get into showing how to run it um yeah right now we're just going to see a hello world displayed at the center of the screen um and then if we have any child components like buttons or sub components or anything like that we'll lay them out here in the resized function okay so that's a basic overview we're going to be basically making child components to represent the knobs and the sliders and the spectrum analyzer and the response curve and then we're going to be you know drawing them in there based on some you know audio parameters that we've got okay so let's run this for the first time what we need to do is go to our particular scheme we have a few targets we've got a vst3 format we have an audio unit format if we are on os x and then we have the standalone version okay so i'm going to put this on standalone in visual studio you'll do something similar you will set the target to run to be the standalone version and then all we need to do is just run it build and run it's going to compile these four files it's going to compile any module files that are being used all right here's our standard plugin it's not doing anything it's just displaying hello world but it is processing audio so yeah that's it there's our basic plugin we're going to turn this into the thing i showed at the very beginning i wanted to add a quick note right before we get started writing actual code what you need to do is go to producer click on this gear right now for the project click on this gear scroll down and you need to change the language type to be c plus plus 17 okay a lot of the stuff we're going to be using this involves c plus plus 17. okay once you've done that just click save and open in ide all right let's start coding navigate to the audio to the plugin processor.h file because we need to declare some variables audio plugins depend on parameters to control the various parts of the dsp juice uses an object called the audio processor value tree state to coordinate syncing these parameters with the knobs on the gui and the variables in the dsp so we need one of these in our audio processor and it needs to be public so the gui can attach all of its knobs and sliders and buttons and combo boxes and stuff to it all right so let's declare one of those all right we need to give it a name i'm just going to call it ap vts and then we need to make sure that we use curly braces here not parameter not parentheses when we declare it all right uh the audio processor to connect to is going to be this audio processor we are not going to use an a an undo manager uh we're going to just call it parameters and then we need to provide a function here to give us a parameter layout so the ap vts expects us to provide the list of all parameters when it is created so we need a function that will provide that for us in the form of an ap vts parameter layout so let's create that now all right and we can just call it and actually let's make it static since it doesn't use any member variables and i have an extra colon okay let's declare this guy right here now for this project we will keep the dsp and the gui simple we are only going to have three equalizer bands low cut high cut and peak for the low cut and high cut bands we will be able to control the frequency cutoff as well as the slope of the cut off for the peak or parametric band we will be able to control the center frequency the gain and the quality meaning how narrow or how wide the peak is all right so we will start with the low cut and high cut frequency parameters and juice has an audio processor parameter class and let me pull up the documentation for this real quick actually all right so juice has an audio processor parameter class this class is a generic interface towards all the different audio parameter formats that different plugin hosts use for example audio unit on os x is used by apps like logic or final cut or garage band vst 3 on windows and osx is used in apps like cubase or ableton live reaper or bit wig and then there's aax for pro tools okay now the audio processor parameter class has several derived types that represent things like sliders and switches and combo boxes and for our needs the audio parameter flow type is used to represent parameters that should be represented on the gui with a slider of some kind so we want our frequency range to be adjustable over a wide range so we are going to use an audio parameter float for this so let's declare our let's declare one of these and i hope the font is big enough for you to be able to see what's going on we're going to return our layout and now we can now we can add um an audio parameter float to this so like out dot let's see add and these things want unique pointers so we'll use uh make unique for this make unique and we want a juice audio parameter float we want that guy all right the name of this is going to be low cut freak the parameter name will also be low cut freak um the normalizable range is the next part now the human ear has a range of roughly you can pick up sounds from 20 hertz to 20 000 hertz so that will define the range for our parameter let's uh create one of these oops normalizable range here's the where's the one that has that takes parameters this is the one that we want okay uh we're going to make it use type float okay now the range start is going to be 20 and the range end is going to be 20 000. now the interval value we're going to use a interval value of 1 and what that means is that our slider will change the parameter's value in steps of one we could use bigger steps if we wanted to for example we could drag the slider um if this was set to 10 then our slider would go from like 20 to 30 to 40 to 50 every time we drag it but as we get in the upper uh range of frequencies that could be helpful more than this lower range the audible effects of like 20 hertz versus 25 hertz like they sound like different notes on the piano whereas 2000 to 2050 does not really sound like different notes on the piano so we're going to keep this at a step size of 1. okay the skew factor now the skew parameter lets us change how the slider responds what that means is that we can skew the slider such that the majority of our mouse movements are covering the lower part of this parameters range for example i'm reading my notes over here for example i could set this skew value such that 75 of the sliders range covers the values 20 hertz through 1000 hertz leaving the last 25 percent of the sliders range to cover the remaining frequencies one thousand and one hertz to twenty thousand hertz or i could skew it differently so that the slider's bottom ten percent covers from twenty hertz to one thousand hertz and the remaining ninety percent of the sliders range covers one thousand and one hertz to twenty thousand hertz and since i don't wanna be doing any skewing right now i'm gonna leave this set to one all right and then the last thing is that um the default value for this parameter now this is the low cut parameter so we will give it a default value of 20 hertz because that's the bottom of the hearing range and we don't want to hear this parameter do anything unless we actually move it all right so that takes care of the lowcut parameter let me hide this plugin processor and just show the plugin plugin thing so you can see the full name of this guy right here all right we've got our name we've got our parameter name and we've got our normalizable range right here and this is our default value we are going to do the same thing with the high cut frequency the only difference will be that we will set the default value to 20 000 hertz because it's at the top of the human hearing range and we don't want to hear this parameter do anything unless we decide to change the value so i'm just going to copy this i'm going to change the name to high cut high cut and then this needs to be 20 000. now let's do the same thing for the peak frequency we will use the same range of 20 hertz to 20 000 hertz um the same step size of one and the same skew value of one the only difference is we will set the center frequency to a default of 750 hertz and let's change the name to peak for the peak gain we will be expressing this parameter in decibels and a good range of values to use here is negative 24 to positive 24. a step size of 0.5 means that when we drag the slider back and forth it will represent a change of half of a decibel and we want this slider to behave in a linear fashion so we will use a skew of one and we don't want this to by default add any sort of gain or cut so we're going to use a default value of zero so i'm going to copy this we're going to change the name to peak gain the range is going to be negative 24.f with a max of 24.f uh our step size 0.5 f our skew of 1 and our default value of f 0.0f that's our gain next the peak band's quality control the quality controls how tight or how wide the peak band is this is kind of an abstract number and it doesn't have any units you can have a pretty narrow q which is reflected by having a high q value or you can have a very wide q which is reflected by having a very low q value so let's give ourselves a low value of 0.1 and a high value of 10. though i'm going to copy this let's copy this parameter change this to quality change that's quality so we will um yeah so we're going to give it a low value of 0.1 and a high value of 10. i'm going to use a step size of 0.05 which means when we drag the slider it's going to go 0.1 0.15 0.2 these can be pretty granular sizes which means we can have a lot of control which is good and always we want a linear response so we will set the skew on this to one and on top of it we want to use a generic default value of one for the queue one dot f all right for the low cut and high cut filters i want to have the ability to change the steepness of the filter cut so i will give myself some four different options okay our cut filters are normally expressed in uh decibels per octaves or their responses are normally expressed in decibels per octave sorry the way the math behind the filter equations works ends up expressing these choices in multiples of 6 or 12. so that means we can have choices like 12 decibels per octave 24 36 so for this project we're going to stick with four choices 12 24 36 48. so because we are using specific choices and not a range of values like with these sliders this means we get to use the audio parameter choice object so i'll show you what that's like uh audio parameter choice so that's this thing right here this thing uh it needs a string array that represents the choices and because both the low cut and high cut will use the same set of choices i only need to create this string array once so we're going to do that first let me get rid of this line let me scroll up okay so let's make our string array and now we're gonna do four choices and now we're going to construct uh something that says 12 db per oct or 24 and we can do that like this all right that should make a lot of sense default value is zero so we've got i'm sorry i's first value is zero so we've got 12 plus zero then 12 plus 12 12 plus 24 12 plus 36 that gives us 12 24 36 48 and then we're just sticking uh db per octave on the end of that string all right now we just need to create the audio parameter choice and give it the string array of choices and use the default value of 0 meaning the filter will have a default slope of 12 db per octave let's create that now this is going to be called low cut slope choice is going to be our string array and our default index will be zero all right and we just need to duplicate this line for the high cut as well all right now we have got our parameters set up in our parameter layout so we can just return it and pass it to the audio processor tree value state constructor which we have already done we already did that right here all right now if we run the app as it is right now we are not going to see anything other than that hello world and that's because we haven't added anything to our gui but if i go up to the create editor function we can use the generic audio processor editor to see what our parameters look like so let's do that we're going to comment that line out we're going to write return new generic audio processor editor and it's going to be uh this okay so if we run it and take a look first of all make sure you are in standalone mode if we run it we are going to see some good stuff okay if we look at our combo boxes we can see that our slope controls show up this way there's our 12 24 36 and 48 peak control default value of one we can see it goes you know zero point one one five two five all the way up to ten and then for our gain we've got twenty four we can see that it's stepping by um half of a decibel every time okay so next we will work on the signal processing side of things that's the next step to make all these parameters actually do something all right we've got some parameters set up now this would be a good time to make a commit and um you know commit what we've done so that way if what we do in the next step gets messed up we can always revert back to here and try again so added parameters we can see what we did we created the audio processor value state created the parameter layout then we added our parameters and created the made it give us the generic audio processor editor whenever we go to look at stuff and then we also changed the language to c plus 17 and did an export for in my case os x in your case it's probably for perhaps it's osx or windows um anyway we'll add those things stage those and make commit all right so the next thing we're gonna do is add uh some dsp now before we do that before we actually start writing dsp code we need to add the dsp module so go to producer click on the modules thing right here then click the plus button and you're going to add a module global juice global juice paths and go to juice dsp all right once that is in there then we can click on this guy and now we have access to all of the uh the juice dsp modules okay i'm going to switch back to the single view for right now so let me hide this and then go back to pluginprocessor.h back to my script if you have never written any audio software before or used any type of audio software then you might not be familiar with the concept of audio channels and stereo versus mono audio so stereo means there's two channels mono means there's only one now each of the signal processing classes in the dsp namespace is set up to process mono audio unless it's declared as stereo in the documentation so what that means is that it's only going to process a single channel of audio and since this plugin is going to be processing stereo audio we need to duplicate all of the stuff we are going to use and the dsp namespace uses a lot of template meta programming and nested namespaces so let's help ourselves out let's create some type aliases to eliminate a lot of those namespace and template definitions first thing we're going to create is a filter alias we're going to be processing floats and not doubles in this project that's our first alias now i said before how we can set the slope of our cut filters to be multiples of 12. each of the filter types on in the iir filter class has a response of 12 db per octave when it is configured as a low pass or high pass filter so if we want to have a chain with a response of 48 decibels per octave we are going to need four of those filters now a central concept of the dsp namespace in the juice framework is to define a chain and then pass in a processing context that's an important term pass in a processing context which will run through each element of the chain automatically so we can put four of these filters in a processor chain which will allow us to pass it a single context and have it process all of the audio automatically so let's do that using cut filter equals so third chain and then this is where we do one filter two filter three filter four filter as i mentioned earlier if you configure the filter as low pass or high pass it will have a 12 db per octave slope we can also configure that filter to work as a peak filter or shelf or notch or band pass or all pass there's a couple other types this means we can use one of these filters to represent the parametric filter so now that we have the peak filter and the cut filters represented as aliases we can define a chain to represent the whole mono signal path so we'll do that using mono chain equals juice dsp processor chain and we will do a cut filter then a normal filter and then a cut filter now we need two instances of this mono chain if we want to do stereo processing and to have access to the filter instances in order to adjust their cutoff gain quality or slope so let's declare that now mono chain we got the left channel and the right channel cool now before we can use our um our filter chains we need to prepare them so let's go over to our prepare to play and do that we must prepare our filters before we use them and we do this by passing a process spec object to the chains which will then pass it to each link in the chain so let's declare one of those and it needs to know the maximum number of samples that it will process at one time it needs to know the number of channels mono chains can only handle one channel of audio and it needs to know the sample rate now we can pass it to each chain and they will be prepared and ready for processing and let's just make sure everything's cool and build it build succeeded okay step number three this requires us to jump down to our process block now the processor chain requires a processing context to be passed to it in order to run the audio through the links in the chain in order to make a processing context we need to supply it with an audio block instance now the process block function is called by the host and it is given a buffer which can have any number of channels so we need to extract the left channel and the right channel from this buffer and the left and right channels are typically channels 0 and 1 respectively so the first thing we have to do is create an audio block which wraps this buffer so let's do that first we're going to get rid of this stuff right here and this is a block and it is initialized with our buffer now we can use the helper function in the audio block class to extract individual channels from the buffer which will then be wrapped inside more audio blocks so we can do auto left block equals block dot get single channel block we want channel zero do the same thing for the right channel now that we have audio blocks representing each individual channel we can create processing contexts that wrap each individual audio block for the channels process context replacing it's a float we're going to call it the left context it's going to be initialized with the left block make another one all right so we have our block representing an individual channel we have a context that kind of provides a wrapper around that block that the chain can use now we can pass these contexts to our mono filter chains left chain dot process and we want the left context and then right chain dot process right context now if we run it it will work but we will not hear our filters do anything because we have not set up their coefficients so this is going to be a good time to set up the audio plugin host so we can feed some actual audio through our plugin and show that the filters are not doing anything but until then we can actually just run this and you'll see that it's not going to do anything cool so we can drag all this stuff there's no audio running through it so we're not going to hear it do anything okay let's get set up with audio plugin host this is uh this comes with juice navigate to your juice folder and then go to extras and now go to audio plug and host and now open the you can open the juicer file if you want i'll do that now i've got this here it's just like the other thing where we have all our source and our modules and whatnot so all we're going to do is just save and open in ide wait for this to open and now we just need to build it all right build succeeded so we are done with um this project now that was very easy okay what we have to do now is run it outside of our project so go to the builds folder go to your particular operating system i'm going to go to mac os go to build debug and now run it all right it's going to want access to whatever device you have what we have to do now is scan our system for the plugin i haven't built it yet i've only built the standalone version so i'm going to change this to all and i'm going to build it now and what it's going to do is it's going to create a vst3 it's going to create an audio unit and it's going to copy them to the relevant locations on the computer now i can go back to audio plug and host and now i can go to the options menu and edit the list of available plugins and now under these options button here this is where you're going to scan for both if you're on mac audio unit and vst3 so we'll do vst3 first it's going to find our simple eq because we built it that way and then for audio unit do the same thing my case i have a bunch of uad stuff so it's going to find all of that okay so now that we have all of our audio units that are built into the computer and our vst3 close this available plugins list window now we can right click right here go to the uh your company unless you put something else in and pick um vst3 for right now here's our plugin so those good times now we want to run some audio through it so what we want to do is right click here um on os x you're going to go to the apple menu you're going to go to the au audio file player now this little plugin lets us load files and play them yeah we can load sound files and then play them so we're gonna wire this up connected to our audio output and then be able to hear audio running through our plugin so just drag like this and drag that to our audio output and um the other thing to do is you need to make sure that under your um options go to your audio device settings and this is where you're going to configure your audio on what you have now i'm going to set this up with an audio file that i have feel free to set it up with your own i'm just pulling something that i got from youtube's free audio library so that way this video doesn't cause any sort of copyright issues or anything set it up with whatever you have and then um i'm also gonna configure it so that it plays through um so that the audio that i play shows up in the video instead of just going out of the audio output all right so standby for that okay i've got my au audio file player set up with a file that is not going to trigger a copyright flag with youtube i've got it wired up to this simple eq that we've been working on and it's connected to the audio output so if i push play i'm going to hear it through the speakers and you guys are going to hear through this video so check it out all right cool so uh obviously this stuff is not gonna do anything if i adjust that all right so that's the next thing we are going to work on we need to set this as what opens by default when we run our application so we will do that next a good thing to do once you get this set up is save the setting save the filter graph setting i'm going to save it with my project that's a good place to put it programming put it right here and just call it simple eq photograph okay so now i can save that now i can quit this and now i can configure the audio um configure my project to run audio plug and host when ever i run the project so i'm going to do that with a vst3 go here for os x you're going to go here you're going to go to edits the scheme and you're going to configure the executable so do other and then just search for audio plugin host and there it is choose close and now if we run it it's going to run audio plug and host and it should load our saved file there it is okay so now we can um now what we can do is actually debug our stuff so if we add a break point right here um it's gonna pause execution right on that which is cool so now we can actually debug our code and whatnot while it's running in there okay so we are done with audio plug and host for right now okay we are going to connect some parameters to our filters but before we do that let's make a commit and just you know jot down what we did so we went through this and we initialized our chains and we got our chains up and running basically you could say we added our dsp added dsp right so here's where we created our chains here is where we initialized our chains here is where we started running audio through our chains and then this is where we did this is where we set up our filter graph and then here is where we added the dsp module okay with that out of the way now we can start configuring our filter chain so go to the plugin processor dot h and we're going to go up to the top now let's start by extracting our parameters from the audio processor value tree state and a data structure representing all of the parameter values will keep our code nice and readable so let's do that first and now next let's write a helper function that will give us all of these parameter values in our little data struct all right let's go to our cpp file now i'm going to implement this near where i created the parameter layout so it's easy to see the names so i'm going to put that right above this we'll just add this here chain settings okay now there are two ways to get parameter values from the ap vts the first way is to call get parameter and then get value like this vts get parameter some parameter name like low cut freak and then get value but the problem with that approach is that we are given a normalized value all of the functions that produce coefficients for our filter expect realworld values not normalized values so we're not going to use this one what we can use is a different function we can use apvts.getraw parameter value now this function returns the parameter in units that we care about units based on the ranges that we set up when we defined the parameters so for instance for the low cut frequency it's going to return a unit that's within this range instead of a normalized value between these two values so let's initialize all of our data structures all of the properties in our data structure using this function these raw parameter values are atomic which is handy when we are interacting with the gui later i'm not going to talk about any of the thread safety issues that come along with audio development in this particular course but you can learn all about that stuff in my course which teaches how to build the full channel equalizer and in several talks on youtube from the audio developer conference so let's go through these and start setting up our settings okay there's all the parameters getting them all low cut free high cut freak peak freak peak gain making sure we're using all the names that we used here let's go up to our prepare to play function all right we're going to do this after we've prepared our chain now that we have our settings we can start producing coefficients using the statter static helper functions that are part of the iir coefficients class so we can do this auto chain now we can do auto peak efficience equals make peak filter now we need the sample rate and our center frequency which is going to be chain settings oops chain settings dot peak freak chain settings dot q quality and then for the gain parameter this particular parameter expects a value in gain units not decibels so we must convert our decibel value to gain thankfully there is a handy helper function to do just that so that's juice decibels class and then this function and we feed it change settings dot peak gain in decibels all right let's put all that stuff on its own line so it's easy to look at now that we have our coefficients for the peak filter we can set our filters coefficients accordingly now you can access links in the processor chain via a get function like this left chain dot get and it's templated this function wants an index to a particular element in the chain via its template argument so let's help ourselves out and define an enum that represents each link's position in the chain and use it here all right so we're just going to leave that the way it is let's go back to our header file we'll go down here to where our chain is and let's define and enum here enum chain positions and we're going to have low cut peak and high cut and this goes along with what we have here we have a low cut the peak band and then the cut area right here we could change this to parametric if we wanted okay now that we have that let's go back to our cpp file go back to prepare to play all right let's use it to access our peak filter link and assign some coefficients so we're going to go chain positions peak like that all right that's how we get that particular filter link all right now the coefficients object this thing right here is basically a reference counted wrapper around an array that is allocated on the heap now we want to copy its values over so we need to dereference it and don't ask me why the juice people decided to design their coefficients object this way allocating on the heap in an audio callback is bad but we're going to ignore that design flaw for right now and just keep moving forward alright so we are going to access the coefficients and we're going to assign it across peak coefficients like that and now we just need to dereference them and then we'll do the same thing with the right chain okay at this point our peak filter has been set up and will make audible changes to the audio running through it if the gain parameter is not zero however any changes we make to these sliders will not cause audible changes because we are not updating the filter with new with new coefficients whenever the slider changes so let's do that next in our process block so let's go on to our processing process block and we need to do this before we run audio through it always update your parameters before you process audio through them okay so let's just copy the code we created and prepare to play right where we created our coefficients we can refactor this later let's just copy that for now go to process block put this right after this buffer clear stuff happens after that put it right here okay again we can refactor this later even though it's identical the only thing you need to change is this guy let's fix this so we can just call get sample rate and now if we run it and adjust the gain q and frequency sliders we will hear some audible changes okay i have run it and let's see what it gets see what it gets us okay we're just going to mess around with the peak frequency stuff okay all right it did something cool so you might notice that the filter slider is kind of wonky that's because our ears hear frequencies sorry that's because of how our ears hear versus how frequencies work if the sound goes up one octave the frequency doubles so this is an instance of where we want to change the skew parameter of our frequency slider let's play around with some different values until we find something we like so we go down to where our parameters are created um let's see which parameter was the skew parameter i think it was that's step size yeah that's step size so it's the last parameter so i'm gonna just try 0.5 for the um let's see i'm messing with the peak frequency so we'll do that one first go like that let's rerun this stop i'm going to change it to 0.5 basically what it's going to do is adjust how the filter responds when i drag the slider okay all right now this is going to be more noticeable when you are messing with um actual like an actual graphical slider that you're designing versus these um sliders here so either way i'm gonna keep messing with this and we'll see what value i end up arriving on so something you might notice here is like um the range is 20 to 20 000. um if the slider's in the middle you would think that a value of 0.5 would result in 10 000 hertz but we don't actually see that until we're way over here this is what i was saying before about the skew thing so i can i can based on this skew that i have right here of 0.25 the um from 20 hertz to 10 000 hertz is spread out across this range and then 10 000 to 20 000 fits here in this little range right here so that's what the skew parameter lets us deal with okay so something that i'm noticing when setting that skew really far down like 0.15 or whatever is i hit the bottom of the range here and it doesn't go up to the next frequency until right there so that's a big chunk of the slider that's not usable based on this skew valid sku value of 0.15 so i'm going to put this back to 0.25 and i'm going to use that for every other frequency parameter okay so with that said we you know added a little bit of code so let's go ahead and make a commit this is going to be um let's see we implemented all right sorry we connected the peak filter params to the filter all right let's go ahead and commit that stuff all right on to the next step okay we are going to get the low cut filters connected to the low cut parameters now if you remember if we jump back over here the cut filters were built with their own processor chain instance and that instance has four filters within it as i said before each of these filters has a 12 db per octave response if it is configured as a low pass or high pass filter we are going to use a helper function from the juice framework that allows us to define iir filters with custom orders and we've been describing the slope in terms of decibels per octave but the slope of cut filters is also known as its order okay also a low cut filter is also called a high pass filter and likewise a high cut filter is also called a low pass filter so let's go take a look at the helper function we're going to use let's jump over to plugin processor go to the end of prepare to play and we're going to we're just going to call it so we can jump to the definition of it all right just give us some default parameters it is the design iir high pass high order butterworth method okay so just jump to the definition of that that's going to take us to the declaration but we want the actual implementation of this okay if we take a quick look at the implementation for example this little loop right here we'll do this loop because we're going to do even numbered orders okay right here if we look at the implementation you will see that it creates one iir filter coefficient object for every two orders so if the order is two we are only going to get one of these that's what i mean how like uh this gives us a 12 db per octave cut if it's four if our order is four we are going to get two sets of coefficients if our order is six we will get three et cetera et cetera so what we need to do is produce the required number of coefficient objects that are needed based on what our slope parameter is set to now remember the this parameter had four choices it was 12 24 36 48 let me jump over to plugin processor and go down to where we created our parameters i was down here we had four choices total all right so the first choice is at index zero if our choice is 12 db per octave which is index zero we want to get back one coefficient object and to do that that means we need to supply an order of two okay if our choice is 24 like if we're doing i equals one we need to supply an order of four in order to get two coefficients back okay ergo our possible orders are then as in i'm talking about this parameter right here this parameter our possible orders are 2 4 6 and 8 okay so we need to add 1 to our slope choice and then multiply that by two to get the order to use when calling this helper function okay once we have done that we can get our array of coefficients from this helper function okay i'm going to say that one more time our possible orders are 2 4 6 8. so remember our slope choices are 0 1 2 3 so what we have to do is add 1 to our slope choice and multiply that sum by 2 in order to get the correct order to pass to this function okay let's do that now go to plugin processor go back up to the prepare to play function and we're going to just get rid of this line we're going to do auto cut coefficients equals and now we're going to call that all right our frequency is going to be the chain settings low cut frequency sample rate sample rate and our order is going to be remember we're going to do our chain settings our slope for the low cut we're going to add 1 to it we're going to multiply that value by 2. 2 times that all right let's put these all in their their own line so it's easy to look at okay chain settings remember this is a value between zero one two and three so we're gonna add one to that that's gonna give us one two three four and then we're gonna double it which is gonna give us two four six eight okay now we need to start let's start by initializing the left chain first all right so let's get the low cut filter chain so we'll just do auto left low cut we're gonna get it chain position whoops all right now first we are going to bypass all of the links in the chain all right remember there are four positions so we need to bypass all four right now it would be ideal to be able to switch based on the slope setting so to make the code more readable let's define another enum that represents our slope setting since enums decay to integers which is what our choice parameter is expressed in let's go to the top of our plugin processor.h we're going to define an enum up here so i want to have the slope amount in the enums member names and since we can't use numbers to begin identifiers in c plus i'm going to put slope before that so we will do enum slope and i will do slope 12. all right now let's um let's adjust what the filter chain slopes are specified as let's change this guy right here so instead of it being low cut slope expressed with an integer let's express it with a slope all right we'll do the same thing for the high cut okay now if we try to compile we will get an error let's fix this error next all right what we have to do is change the data type right here to uh we're just going to cast this to that slope type right here do the same thing for this line and try building it again cool problem solved all right now we have our enum which gives us you know specific types that we can switch on let's go back to our prepare to play function oops all right that's down here now we can do a switch statement so switch and we want to do uh chain settings low cut slope i'm too lazy to type the switch types so i'm going to let the autocomplete do it all right add missing switch cases yes okay now we just need to fill them in if our order is 2 meaning a 12 db per octave slope the helper function will return an array with one coefficient object only so we will assign those coefficients to the first filter in the cut filter chain and also stop bypassing that filter chain so we will do um let's see left low cut dot get first filter in that chain we want the coefficients and we're going to assign it to our cut coefficients the first element now remember we have to dereference and then we are going to stop bypassing this particular chain all right now for the next choice we will do the same thing that we did when the slope was 12 however the helper function will return an array with two coefficient objects so we will find we will assign to the first two links in the filter chain and stop bypassing them all right i'm just going to copy this and then copy it again and change these to one all right we're going to repeat for the third and fourth option when the slope is 36 and when the slope is 48. all right now that's obviously not you know optimized there's a lot of repetition in the code going on we'll deal with that later okay all we have to do now is repeat this for the right chain and our slider and combo box for the low cut filter will configure the filter properly so we are going to get the right chain and let's just copy all of this and replace all of the left low cut with right low cut okay all right as i said there is a lot of repetition here and it could do with some refactoring but let's not do that just yet okay first let's copy this chunk of code to our process block just like we did with the peak filter and we should be able to run it and test the sliders in the combo box and hear it adjusting the low cut filter all right so just grab all of this grab cut coefficients like that jump to process block we're going to put this after our peak coefficient stuff right like that okay the only difference is uh sample rate we need to call get sample rate again all right let's run it okay we should be able to adjust the low cut frequency as well as the low cut slope and here it make a difference all right let's adjust the slope i'm going to put it around 2500 put it around 4 000. we can definitely hear there's more bottom end when we use us a more gentle slope versus a steeper slope all right i'm happy with that okay let's uh make a commit since we did some good work right there we added the uh let's see we connected the low cut parameters to the filter we made our enum we adjusted our chain settings how they are defined and we added our coefficients and we got them working with our um working with the filter and then we also updated how we pulled them from the uh from the process block or from the apvts all right cool on to the next thing we will refactor what we are doing okay let's start the refactor with cleaning up the stuff that configures the peak filter let's just do a uh a function here at the bottom all right we're going to update the peak filter with the change settings i'm going to implement this beneath where i am getting the chain settings now i'm going to just copy the implementation from the process block paste it here replace it in the process block and then do the same thing in prepare to play i'm just gonna copy this stuff paste it here and now i'm gonna call this i'm gonna do the same thing in prepare to play very easy now let's add a helper function since we will be updating lots of coefficients like we are updating them here we're updating them here here here here okay so let's go back to our header file and let's do that here now i'm not sure of the exact type that the dsp iir filter class uses for its coefficients if we take a look over here it uses this thing which is an alias to whatever this is but we can make an alias to that alias very easily and now it's very easy to declare this helper function that will update those coefficients now it doesn't use any member variables so it could be a free function or it could be a static member variable a static member function so i'm going to go with static for this particular instance because i'm already right here i don't want to have to scroll up to make a free function all right and let's go implement that below where we implemented our update peak code okay remember they're um reference counted objects allocated on the heap so we need to dereference them to get the underlying object now we can use it here the old ones are going to be this thing the replacements are going to be this thing we'll do the same thing for the right chain okay let's run this and then move the sliders make sure it works and if it's cool then we'll delete this old code and then do the low cut filter next okay so we're just going to mess with the peak filter all right it's making changes make it tight give it a little sleepy heat cool all right let's clean this up and then commit our changes let's build just to make sure that what we deleted is cool all right let's make a commit all right here we go commit that stage all this stuff boom okay we can refactor how the low cut filter gets configured next and then we can use that same code to configure the high cut filter let's refactor how the low cut filter is updated so we'll be able to use this later for the high cut filter now i'm not sure what type names to use for the parameters here so i'm going to use a templated function so let's go to our header file and put this down here template type name chain type and then void update cut filter now a trick one refactoring something like this is to use the same names you were using in the unrefactored code so i'm going to use uh if we go take a look at our plugin processor i'm going to use the same names here where i've got cut coefficients and then left low cut and then low cut slope i'm going to use those same names for right now okay so we're going to do a chain type of left low cut i'm going to use a coefficients type of cut coefficients and then i've got my chain settings const chain settings chain settings all right so let's copy over the stuff from process block first and call it in process block and then comment and comment out the old stuff and we will fix any errors along the way so let's go to our plugin processor we're going to grab this cut coefficient stuff and then all of this code right here and now let's comment it out and call our function all right we want to call it with our uh left low cut let me call this after this point so i still need this thing all right so let's see and i still need my cut coefficients too okay cut filter we're going to call it with left low cut we're going to call it with cut coefficients and our chain settings let's uh give that a quick build just to make sure that that works as expected all right we have some errors going on here oh yes okay so we're not passing this and we're not passing that so comment that out and that should be good to go all right so we need to add some template keywords right here template and that also needs to go here in front of these since these are template functions we have to express we have to explicitly declare that they are templated like this it's one of the more obscure uh c plus plus rules all right okay cool build succeeded all right the left cut filter is configured so we can tackle the right cut filter with our helper function now so we just do this same thing comment out all of this code call our helper function and use the right low cut we'll do a quick build just to make sure build succeeded all right cool now we aren't using the entire chain settings object we're only using the slope so let's go back and change our switch statement okay we're going to get rid of this and we're going to change our parameter so we're going to get rid of this we're going to change this to be const uh slope low cut slope and now we can change this line to be switch low cut slope let's build it we should get some errors because we need to change what we're calling it with this is where we need to do low cut slope and then on the next one as well all right and if we build it we should get no errors okay cool no errors so let's revise prepare to play now let's go up here to prepare to play and we need our coefficients our left low cut as well as our right low cut so let's get rid of uh this code and this code and now let's call uh we'll get rid of that code too and now we can call our code we can call our function we'll start with the left low cut filter chain update cut filter with the left low cut chain and our cut coefficients and our left low cut uh this is where we need our chain settings dot um low cut slope and then do the same thing for the high cut or for the right low cut our slider and combo box for the low cut filter should configure the uh dsp filter properly all right let's test out our refactor and if it's cool we will delete all this code and um do commit okay let's run it and see what we get okay so we are going to mess with the low cut now and the slope that's working all right i am very happy with that let's clean this up and make a commit all right let's clean up our header file okay let's build it just to make sure all right looking good updated or refactored low cut configuration load code filter configuration all right this is where we added our helper function this is where we deleted our helper our old code and now call the updated stuff now this is obviously very verbose so let's clean this up we're going to use a special trick just comment all of this out if we reverse the switch order we can leverage case path uh we can leverage case passthrough to eliminate a ton of code duplication here so i'm going to do that first all right we're just going to put the cases in the opposite order case slope okay the way this works is like if it's the 48th if it's if our slope is 48 we wanted to do this one and then we also wanted to do all of these so we can just make it instead of making it break out of the switch we can just do okay if it's 48 do this do that one here and then and then do also do the one that is required for 36. we can also write a templated helper function to eliminate even more duplicated code because we're doing this thing and yeah all right so let's write that next right above this guy all right so we're going to do template we'll add these parameters next uh void update so we're gonna need our chain we're gonna need the coefficients and then um so we're gonna need our chain type and our coefficients and then if you notice all of these make use of this get or set bypass and use as a parameter here so we are going to make this be the first parameter because if you didn't notice when we called this function we didn't have to provide any of these template arguments so the compiler deduced what to put here automatically so if we leave these as the later template arguments the compiler can deduce them for us and we only need to provide uh the um that index so we're gonna do that int index okay now we can just do that update coefficients function update coefficients and our old one is going to be chain dot this thing right here template get dot coefficients all right and our coefficient replacement type is going to be the coefficients uh cut coefficients is that the name i'm using there i'm going to change that name to just coefficients and the index that we use if you notice it's always when it's get zero we always use the zero with cut coefficient index when it's one we use the index one okay so whatever we put here our index is the same thing we're going to use here index all right how convenient is that and then we need to set the bypass state to false so we can call that chain dot template set bypassed index false cool all right now we just need to call it all right so remember if we're doing the 48 degree slope we want to call this all right and this is being replaced by that update function this is where we want index three and our chain type is left low cut and our coefficient type is the cut coefficient all right let me spell that right all right that gets rid of these lines all right we do the same thing three two one zero three two one zero zero okay let's test that out make sure that works if it does then we can clean this up all right so we're gonna run it we're gonna adjust this and adjust this all right that's filtering put this on 48 this to 5 000 and we'll change the slope and we hear more bottom end material not much more but all right cool awesome let's make a commit of that after we clean it up all right cool is there anything in here that needs cleaning up i don't think there is prepare to play nope all right let's make a commit of that so refactored chain update refactored update cut filter code very cool got some more advanced c plus plus stuff going on with that all right now we can uh connect the high cut parameters to the um to the filters all right so let's go over to our plugin processor.cpp and go up to the um go to the prepare to play function first of all now we need to um let's see go back to my notes here uh we need to rename our coefficients before we dig into high cut filter configuration so let's change this to be low cut con low cut coefficients all right now that we've done that now we can configure the high cut chain we're going to follow the same pattern uh we're going to call the helper function to get coefficients and then we're going to call the helper function to update the filters with those coefficients okay so we're going to do auto high cut coefficient equals juice okay we want the design low pass high order butterworth method all right same thing it's going to be the chain settings dot the high cut frequency same sample rate and then our order is going to be this same expression but it's going to be the high cut slope okay now we can get our left chain in right chain left high cut high cut do left chain and right chain okay and now we can just call this uh call this guy call it with left high cut and the uh high cut slope and then do it again for the right side and then we need to use our high cut coefficients and then we will do the same thing uh we can obviously refactor this later we can do the same thing in our process block now process block let's just put this at the end of our update filter code here and then oh we need our get sample rate and now uh now this is in place we can uh run it and test it all right so we're going to be testing the high cut frequency and the high cut slope all right so i'm going to set this around 2500 hertz now if i change the slope i should hear less and less high frequency perfect all right cool let's do a um don't repeat yourself refactor and um that'll wrap it up for the dsp side of things that was easier than probably you thought so the first thing we are going to do is go to our plugin processor dot h down here let's make a function that's going to update all the filters now we need a pair of functions one for the low cut and one for the high cut and this will be these will be called by the uh by this update filters function okay so all right takes care of those let's go over to our plugin processor dot cpp i'm going to jump to after the updates coefficient function update coefficients function i'm going to copy the relevant code from processblock to the implementation for the uh update low cut filter let me grab that from processblock all right let's just copy that paste that here make sure we're getting the coefficients and then updating both chains we're going to do the same thing for the high cut void simple let's go grab that code from the process block i cut coefficients update cut filter all right now we need to implement our update filter function so i'm going to do that below this now i just need to get the chain settings auto change settings equals get chain settings now i can call update low cut filters update peak filter update high cut filter now we just need to replace all of that stuff in process block with a call to that update filters function all right we don't need our chain settings anymore we don't need any of this update filters okay let's do the same thing in uh prepare to play all right we lose all of this code which is great all right let's run it just to make sure all right we're going to adjust all the sliders and we should work as expected there's our low cut all right low cuts working is the high cut working get rid of some more high end okay high cuts working let's mess with the peak so cool all right that works let's clean this up delete that code go to our process block delete all this code all right let's see if there's anything else that's commented out not just those guys just those guys okay uh dry refactored dsp config dsp filter configuration all right commit okay cool so that wraps it up for the dsp side of things okay so that's awesome all right the next stuff we get to work on is the gui side of things we get to design a custom interface and knobs and get the response curve showing up and the fft analysis showing up in the background as well okay see you in the next one okay before we start on the gui let's implement saving and loading of our plugins parameter state it's very easy to do because the plugin state is stored in the apvts's member called state let me show you what that looks like all right so right down here there's a public member variable okay this is where all of the um basically the generic values are stored in this okay so let's go back to our plugin processor dot cpp and we're going to go to the what's the name of this function get state information the state member as i said was a it's an instance of a juice value tree and those serialize to memory very easily so we can use a memory output stream to handle the busy work needed to write the ap vts state to the memory block that this function has been given by the host talking about this memory block right here alright so we can just make a memory output stream take one that uh writes to a memory block dest data yes we want to append to the existing content let's call it mls for memory output stream now we just write it a p v t s dot dot write to stream mos that's it how simple is that likewise we can do the reverse we can restore our plugin state from memory using a value tree helper function the only thing we need to check for is if the tree uh that was pulled from memory is valid before we copy it to our plugins state so let's use that function all right we want this one read from data we're gonna pass it data we're gonna pass it size in bytes okay once we know the tree is valid then we can replace our plugin state and also update our filters with these saved parameter values so apbts.replacestate with the new one and then update filters how simple is that so now if we run this in audio plug and host we should be able to tweak the parameters and then um it will be restored oh this i changed the folder name so i need to reload where this is okay so for example i'm going to change this from 20 to whatever that number is okay save it quit we're going to reopen and it's no longer 20 it is on 4573 cool all right we can double click to reset it back to the default value our parameters are saved between loads cool okay let's get back to using our editor instead of the generic one so we're gonna uncomment this line or we're gonna comment this line out and uncomment this one all right so now we are gonna be shown an editor that has no gui um it just says hello world okay so we're back to this all right so we're going to start adding knobs and sliders and all that kind of stuff okay so the first thing that i want to do we're going to switch over to plugineditor.cpp first thing i want to do is give ourselves some more room so we're going to make this 600 by 400. all right we're also going to switch to the standalone plugin instead of the host for right now okay if we run this we're going to see a bigger window cool all right definitely better now let's go to plugineditor.h now i don't want to have to type this base class initialization for every slider that i'm going to make because they're all going to be rotary sliders and they're not going to have a text box so i'm going to create a class that does this automatically in the constructor and just use that for every slider in the gui i'm going to put that right here we're inheriting from slider and then we're going to set it so that it's using the rotary horizontal vertical drag style and then a no text box position now we need to add some sliders so let's add them right here okay we're going to deal with the slope controls later for right now we're just going to show the frequency and gain and quality sliders okay so custom rotary slider and we want our peak freak slider we want our peak gain slider we want our peak quality slider we want our low cut freak slider we want our high cut freak slider now when i have a bunch of components that are going to be have that are going to have the same thing done to them all the time i like to add a i like to add a function that's going to give me all of them in a vector so that way i can just iterate through them easily so i'm going to do that next all right now it's very easy to implement let's go to plugin editor we'll put this after resized and all we have to do is just return a vector with um all of our components in that's super easy to use we just need to do it uh before we call set size so we're gonna do that right here for auto comp get comps and then we can do add and make visible all right the next thing we need to do is to position them all now juice live constant is a very useful tool for this we're going to put these right here yeah when it's time to dial in specific positions i will use juice live constant because it basically lets me adjust positions of things while the editor is visible which is very handy but for right now what i'm going to do is reserve the top third of display third of the display for showing the frequency response of the filter chain and then the bottom two thirds is going to go it's going to be dedicated to the placement of all the sliders so i'm going to do that next all right so the way this works is i've got my bounding box for the component i'm dedicating an area for the top basically like i'm chopping off a rectangle i'm chopping off uh 33 of the height that's going to get stored in this response area now i'm going to put the low cut stuff on the left so i'm chopping out 33 of the bounding box in its current form that's going to go to the left and then the high cut area so if you remember i've got basically 100 this is taking up 33 percent and so this is rep this bounds right now represents 66 percent so i want to take half of that which gives me another 33 that's going to be the right third of the display now i just set my um my low cut frequency slider and my high cut frequency slider to be in the left side and right side and then for my peak slider i'm going to set that at the top of that center column it's going to get the top third same thing's going to happen here this now after this call has a height of twothirds of what it used to be so we want half of that to give us onethird for the peak gain and then one third for the quality okay so if we run this we're going to see knobs or sliders or whatever we want to call them okay cool so here's our big old low cut slider here's our high cut slider and then here is our um peak frequency here's our peak gain and then here's our peak quality and you can see these guys are uh they each share uh 33 of the um of their allotted space all right next we're going to add these slope sliders all right let's go back to our header file we're going to add these over here they're just going to be they're going to use the same custom rotary thing these are going to be low cut low cut slope slider and then um high cut slope slider and we got to add them to our list of components and then we need to position them so let's put them after our low cut frequency slider we are going to make this uh let's see this is going to be low cut area we're going to we're gonna cut we're gonna divide the low cut uh side of things in half and then we'll do the same thing uh let's see this is where we're gonna do low cut slope slider not set bounds low cut area and then for the high cut we're gonna do the same thing we're gonna do remove from top make sure it's that guy and now we can do high cut slope slider dot set bounds high cut area all right so we are removing we're basically removing from the top of this low cut area um a a rectangle that is half of its original size and giving that to the low cut and then using what that leftover piece goes this to the low cut slope slider right check it out we're going to run it you'll see those two sliders have the same size on either side all right yeah these guys have the same size these guys all have the same size all right cool so though those are the uh sliders they have now been positioned on the screen okay the next thing we need to do is um connect them to our um to our parameters so let's make a commit added sliders to gui all right commit all right let us connect the parameters to these sliders now let's go down to um our plugin editor.h okay uh below where all of our sliders are declared the apvts has an attachment class which makes it very easy to connect sliders to the audio parameters however the name is very long so let's use a type name alias to help out with the reason with the readability here so using and using ap vts equals that super long class name and now we can create an attachment alias as well right now we just need to declare one attachment for every one of these sliders all right the next step is to initialize them properly so we go up to our constructor and we have to initialize all of them here so what we need to do is write um they take three parameters so let's see um peak freak slider attachment all right it needs the audio processor value tree state to use we're gonna use the audio processor abvts the parameter id peak freak and if we're not quite sure about that we can go back over here and double check so we got low cut free kicut freak peak freak peak gain peak quality low cut slope high cut slope so the good thing about this project is there are not a lot of parameters um which means we can kind of get away with typing them like this um if our project had way more parameters in it we would want to standardize how they are named um and use some kind of lookup table with std map or something so that way um it's impossible to spell them wrong here that sort of thing we can yeah just use the lookup table and some kind of enum system to index into the uh parameters okay so let's connect this to the proper slider peak freak slider all right that's one so we need to do this for all of these guys here okay that was this one we need to do it for all of these okay once we get to this point uh all we have to do is just test it and see that our sliders work as expected and their value is preserved when closing the gui or closing and reopening the app so let's do that right now i'm just gonna do the standalone version okay uh we're just gonna adjust this guy i'm gonna close it and reopen it cool that's at the same spot let's do it in um uh audio plug and host all right let's run some audio through it closing the gui reopening the gui where it needs to be save and click that and reopen it just to double check reopen our gui sure enough all right that was at 12 o'clock and now it's not it was at 0 db all right so that is working as expected cool so we have successfully connected our uh default sliders to their parameters and they save and load whenever we open and close the gui cool let's make a commit of that connected sliders to parameters all right that's where we added the attachments here's where we resave something in the filter graph here is where we initialized all those attachments our next goal is to display the response curve of the filter so to do that we need to give the editor its own instance of the mono chain and to do that we need to make all of the stuff that makes the mono chain public so we will move all of those type aliases out of the audio processor and also make the chain positions enum public so head on over to public to a plugin processor dot h we're gonna grab all this stuff we're gonna move it to the top put it uh below your chain settings and then grab that edom chain positions copy this guy and put that here oh now we're gonna have some duplicate definitions so let's get rid of this and get rid of this and clean it up head on over to plugineditor.h and we need to give ourselves an instance of this we can put that right here mono chain mono chain all right let's just give her a little compile test make sure it's cool all right cool build succeeded let's make a little commit of that gave editor its own mono chain stage stage now we're going to start drawing the uh response curve all right head on over to plugineditor.cpp we're gonna go to the paint function and that's this guy right here now the first thing we're gonna do is fill it with black so get rid of this actually i'm gonna we're gonna use the juice name space right here using namespace juice so now we don't have to type juice colon colon everywhere let's get rid of this colors black all right we're gonna fill it with a black um black background all right let's get rid of this stuff as well first we need the area that we will draw the response curve in auto bounds equals get local bounds and our response area was this thing so let's copy that and then our width is something that we will also need auto w equals response area dot get width next we will need the individual chain elements and then we will call the function get magnitude for frequency for each filter in the chain so let's get our get our chain elements so to use that function we are going to need the sample rate we can get that from the audio processor to use that get magnitude for frequency function so this is where we can do audio processor to get sample rate and we are going to need a place to store all of these magnitudes which are returned from that function as doubles now we are computing one magnitude per pixel so let's preallocate the space that we need now we just need to iterate through each pixel and compute the magnitude at that frequency now magnitude is expressed as gain units and gain units are multiplicative unlike decibels which are additive so we need a starting gain of 1. now we just need to call the magnitude function for a particular pixel mapped from pixel space to frequency space and we will use a special helper function for that called map to log base 10. we're mapping the normalized pixel number to its frequency within the human hearing range that looks like this our value our normalized value oops let me be consistent with how i'm doing my casting and our minimum range is 20 and our max range is 20 000. all right now we just need to call the magnitude function with this frequency uh what's it called get magnitude for frequency function and multiply the results with our magnitude right here okay so we just need to check if a band is bypassed because if the band is bypassed we're not going to do that multiplication so if mono chain dot is bypassed all right if it's bypassed ignore it all right if it's not bypassed then we're going to do mag times equals and here's where we do the peak band coefficients and this is where we're going to call that get magnitude for frequency all right our frequency is this thing right here and our sample rate is this thing we just need to do the same thing for every other filter in the low and high cut chains all right so i'm going to do that now and the thing to remember is that the low cut if you remember how it's defined it is defined as a its own processor chain so we need to get each individual element of it versus getting it from the mono chain all right so i've got that for the low cut so i'm just going to do that for all four of the filters in the low cut and then do the same thing for the high cut all right now we just need to convert this magnitude into decibels and store it now that we've got our magnitudes we can convert this uh vector of magnitudes into a path and we can build this path from the vector of decibels and then draw it okay so let's do the first thing let's build our path now we need to map our decibel value to the response area and a helper lambda will do the job we could also use a free function but i'm right here so i'm just going to do it right here let me define some maximum and minimum positions in the window i'm going to use jmap to map from my source input which is a range of negative 24 to plus 24. and my output is where it's going to map to the window position now i came up with this negative 24 and plus 24 because the peak control can go from plus 24 to negative 24. so i want my response curve the window for it to have a range of plus 24 to negative 24. so that's where these figures come from all right so let's see output min output max all right now we can start a new subpass a new sub path with the first magnitude start new sub path we're going to start it at our response area dot get x this is the left edge of the component and the first value is going to be map mags.front so we're going to run the first value in our magnitudes vector through this map function and we're mapping our decibels to screen coordinates now we just need to create line twos for every other every other magnitude all right response curve line two and we want to go to response curve uh response area get x plus i and then we want to do map mags i now let's give ourselves a nice background border and then draw the path g.draw rounded rectangle we're going to draw that response area it wants a float rectangle corner size let's use a corner size of four and a line thickness of one now we can uh let's use a white color all right g dot set color and now we can draw our path i'm gonna do a path stroke type of two this is gonna draw a rounded rectangle with a line thickness of one one pixel wide this is gonna draw with a line thickness of two pixels wide all right let's run this and let's see what we get let's open our gui all right cool we have a nice flat line inside a rounded rectangle right at the middle okay now why aren't we seeing anything if we drag these sliders this is because these sliders only update the filter chain in the audio processor we also need to make them update the filter chain in the editor because it's a different chain so let's do that next okay we need to do that whenever the parameters change all right oops i'm going to leave that open so that when this this opens automatically we get to see our gui every time we run it all right so we are going to set up the filter chain in the editor to follow the parameters next okay make your way to the plugin editor dot h now the easiest way to respond to parameter changes is to register as a listener to all of them so let's do that we're going to inherit from audio processor parameter listener now let's take a look at the documentation for this guy now it says here important note this will be called synchronously whenever a parameter changes and many audio processors will change their parameters during their audio callback this means that this this means that not only does your handler code need to be completely thread safe it's got to be very fast and avoid blocking okay okay what this means is that callbacks are going to happen on the audio thread most likely and this means we cannot do any gui stuff in any of these callbacks like update the editor's filter chain here and trigger a repaint but what we can do is set an atomic flag that the timer can check and update based on that flag so that's what we are going to do so first things first let's copy these callbacks all right let's go back to our editor all right we'll put them right here they're no longer virtual because we are deriving from them let's mark this as override all right let's go add um let's add our timer we're going to inherit from that so that way we can do the atomic flag thing i'm talking about juice timer now we need to include the necessary callback we go to timer we can see the callback is right here virtual void and it's pure virtual so we have to implement it let's see all right so in this timer callback we are going to query an atomic flag to decide if the chain needs updating and our component needs to be repainted so let's add that atomic flag right here below our processor parameters changed it's a good name for it give it a initial value of false all right now we don't care about um if parameter gestures happen so we can just give that an empty implementation the callback parameter that matters is this one right here all right now we're going to set up the callbacks all right below our um we're going to do this below our resized function in the editor.cpp so first things first let's um let's set up that parameter value changed callback parameter value changed and the only thing we want to do is set our atomic flag to true next we are going to just check if it's been changed in the callback in the timer callback if parameters changed dot and then here is where we want to see if it's true and if it is we want to set it back to false so that way we don't um we don't want to you know just like always be doing this because if we don't make any changes to the parameter we don't need to refresh the curve okay we're going to call that guy we want the new value if it is if our parameters changed is true then we want it to be set to false okay now if the parameters changed we need to update the mono chain from the ap vts we need to signal a repaint and yeah we need to signal a repaint so a new response curve is drawn unfortunately all the stuff that updates the mono chain from the ap vts is private in the audio processor so we need to do some refactoring first before we can do this and then do this all right so let's do that next all right head on over to pluginprocessor.h now all of these uh where are those functions okay yes all right all of these update functions need to be made into free functions so if they use member variables those member variables need to become function arguments so we're going to start with the function that updates the peak filter all right so what we will actually do is um we're going to start by turning the update coefficients function into a free function and then that way this update peak guy can uh be turned into producing a peak we can change it to produce a peak filter okay so let's grab these guys we're going to copy these we're going to move these up to the top here and put it below your chain position stuff and we can get rid of that static keyword and now we can make a uh function that returns coefficients and it makes a peak filter from chain settings and the sample rate all right let's go over to our plugin processor dot cpp we're going to go to our update peak filter function all right and this is where we're going to implement that free function because it's just convenient to put it right there all right so let's do coefficients make peak filter and this is where we want our chain settings and our sample rate okay so all we need to do is just return this call and instead of doing get sample rate we just need to do sample rate like that okay now we need to use that helper function here oh and this needs to be um we need to change this as well we can just comment that out all right so we just need to call this function here all right let's comment this out and call it auto peak coefficient equals make peak filter chain settings get sample rate and let's do a quick test to make sure that everything um works as expected still all right we're going to make sure the peak filter works let me open up the high pass i hear some sleeping let's do a boost sounds like it's working all right cool all right next we will get the editor to use uh this function let's clean this up uh let's do a little commit since this is kind of getting into you know micro code surgery that sort of thing let's get rid of that save this let's go over here we will say refactored how peak uh refactored peak coefficient generation all right that's where we did that okay we migrated this stuff up to there and made this uh make peak filter helper function yes uh then we implemented that stuff and started using it then here we implemented from uh parameter listener and timer and added the necessary callbacks and the atomic flag and then here is where we uh displayed our response curve oh that i forgot to commit that stuff so let's do that first all right because we want that step separated let's see here is where we drew our response curve let's add it let's do that first rendered response curve that's going to be this function that's all that is that's all that is we definitely want to separate that stuff because that was a big chunk of code that we wrote okay so i was saying this is where we um we factored the um let's see yeah what did we do we refactored how peak functions uh how peak coefficients how peak coefficients are generated refactored how peak coefficients are generated all right and this is where we also did that part as well and then here is where we set up for uh responding to parameter changes in the editor okay this is where we inherited from those things this is where we implemented the callback and the atomic flag that we will be checking and here is where we um updated that flag and then queried that flag cool all right make your way over to the editor dot cpp um specifically the constructor yes how can i can i help you okay now that we can update any peak filter link with the chain settings we need to listen for when the parameters actually change so let's grab all the parameters from the audio processor and add our cells as a listener to them all right and now let's just loop through them uh this function returns an array of pointers now if we register as a listener we need to deregister as a listener we'll do this same chunk of code here the new param remove listener this okay so let's go to our timer callback now that we are listening to our parameters okay if the parameter changed we need to update the mono chain so let's do that let's grab the chain settings let's make new coefficients and then let's update our mono chain and then repaint okay very simple auto chain settings let's make our coefficients for the peak band all right our chain settings and our sample rate and now we can update our chain's coefficients our old ones are the monochain dot get and we want the peak and then our replacements are going to be these peak coefficients all right and now we just repaint oh i forgot to call uh coefficients that's what we needed there we go all right let's give that a test see if we are there yet all right so if i adjust this are we seeing anything not seeing anything all right soon enough okay we'll get there we can add a debug statement ram's changed and we should see something down here if we move the sliders and we are not okay that is because that is because we did not start our timer okay so we need to go up to our constructor and start our timer all right let's do a 60 hertz refresh rate i knew there was something i was forgetting okay let's try this now this should work perfectly all right so i'm just going to adjust the gain all right look at that all right so now we need to get the cut filters uh the cut filter functions usable by the editor so head on over to your plugin processor dot h and we need to jump down to all of these update functions okay we need to make all of these public so just grab the grab these template functions all right and we're just going to cut them and move them up here we can put them after our uh make peak filter functions uh let's do a little build just to make sure that um we don't have to change anything all right those so those could have been public from they could have been free functions from the getgo so now we just need to add two helper functions for producing the coefficients all right so we're going to basically do the same thing we did this with this make peak filter and we're going to be able to call them from here so we can put them right here if we want to implement these functions in header files that are included in two places such as the uh plugin processor is included in plugin processor.cpp and plugineditor.cpp and plugineditor.h if we want to do that we need to use the inline keyword otherwise the compiler will produce a definition for this function everywhere that this header file is included and the linker will not know which compiled cpp file to use for the definition so that's why we're going to write inline auto i'm not sure what type to specify for what's being returned make low cut filter we need our chain settings again we need our sample rate and then we're going to use our filter design function again i can just go copy this from the plugin processor that's uh this thing right here let's see i'm doing low cut so i need this thing and here's our sample rate all right let's just do a quick build on that make sure that we're not getting an error cool all right let's do the same thing with the high cut go back to plugin processor i'm going to copy the uh update high cut filter is going to copy this code over oops this is what we want that goes here this is get this is just our parameter sample rate all right and we need a return like that format that properly and do a little build make sure we don't have an error okay cool now we just need to update our call sites head on over to the update low cut filter function and let's change this to make low cut low cut filter chain settings get sample rate same thing for the high cut we're just going to do make high cut get sample rate all right let's do a quick test before we get the editor involved all right this should still work okay rolling off all the bottom as inspected for this one rolling off all the top end perfect let's make a commit of that refactor because it's good to good to have it okay this is where we connected our parameters and got the display updating all right here's how we updated uh let's see this is refactored how cut filters are created that's what happened here get rid of that code same thing happened here and now this is where we um updated let's see this is where the um gui listens to param changes now cool all right we've tested our editor now let's update the response curve all right so go to your plugin editor dot cpp go to the timer callback and we're going to do uh the same coefficient update that we did here so auto low cut coefficient equals make low cut filter chain settings sample rate um let's cache that sample right now i'm just i'm feeling a little lazy i'm just going to copy that this can all be refactored later so we don't dry so we don't repeat ourselves we always want to not repeat ourselves dry don't repeat yourself okay here we go auto high cut coefficient make high cut filter chain settings copy that thing right there all right now we can update our cut filter our chain is going to be the mono chain um we want the low cut coefficients are going to be the low cut coefficients and our slope is going to be the chain settings slope low cut and then our update our cut filter we can do the high cut mono chain.get we want the high cut position we want the high cut coefficient and with the high cut slope okay let's test it out all right so i'm going to adjust this okay we are drawing outside of our response area we are drawing though that's cool so the response area should be its own component because components cannot draw outside of their balance unless you set a flag that allows that we will do that next but this is a good sign that our display is responding to controls and that what we are hearing sounds like what we are seeing or the other said the other way what we are seeing sounds like what we are hearing okay cool all right let's commit that response curve now shows cut filter response cool migrating this code from the editor to a separate component is relatively easy we need to inherit from the things the editor is inheriting and yeah we're really not writing any new code really we're just refactoring what we already have let's go to our header file first of all let's go up here now we need to basically inherit from all this stuff so let's do that first let's do struct uh response curve let me spell it right it's a component and then we need to inherit from these things okay we're gonna need the same uh basically the same constructor destructor pattern and we're gonna need to migrate over all of those callbacks let's just copy these all right we're not going to need this comment let's go to our cpp file now our callback migration we're going to need our parameter changed in our timer callback so i'm just going to copy these two guys directly move them up to the top put them up here and just change this to response curve component same for that we get a bunch of error messages it's fine we'll fix those in just a second and we need to migrate over the code that registered as a listener so let's do that here let's give ourselves uh let's see we need to initialize we need to provide ourselves with that same um same the same thing okay now we can initialize that guy audio processor all right now we need to migrate over the code that registered as a listener okay so let's do that next where was that found that was all of this stuff right here it's name for the timer we need that too those guys go there we need the destructor we need that code all right so let's copy this okay we're going to need a paint function so let's declare one of those void paint we can just migrate over the entire paint function from the plugin editor so we can literally just rename this i'm not going to do that though i'm going to copy it and do the proper thing but literally we can just literally copy this whole thing and put it down here we'll fix all those variables in just a second all those error messages number eight we need to migrate over the parameter changed atomic value so let's grab this from here that should go here we also need to migrate over our chain now once we've done these things we need to we need to give ourselves an instance so let's do that um i'm just going to put that here response curve component and then we can also get rid of our chain we can also get rid of our atomic in our plugin editor.cpp we need to go down to our function here and add it as one of our components all right now we need to initialize it so let's go do that in our um editor constructor pretty sure it's going to tell me that it needs to be initialized before the other response curve component audio processor yes this needs to be initialized before uh the attachment for all the attachments finally we need to give it some bounds so let's go to our plugin editor resized function and now we can actually use our response area cool all right so let's go to our plugin editor all right this is not going to inherit from uh parameter listener or timer anymore so we don't need any of these callbacks um we don't need this atomic we don't need uh the chain so that means we can get rid of these uh get rid of those functions as well all right so let's go to our plugin editor.cpp uh we are no longer listening for those and we're not a timer anymore so those go away same for the destructor stuff and then we're not doing any of this so we can just continue filling it entirely with black so we can get rid of all of this stuff and then we don't need our this callback that disappears all right and i believe that's most of the errors let's build it and see what it tells us that may have been it all right yep okay all right so let's run and test it all right so this is tiny for some reason that's way smaller than we wanted let's go to our resized function uh bounce remove from top bounds dot get height oh you know why it's because um our response area here in this um our response area should not be 33 of the actual component it should just be the get local bounce so i'm just going to get do that and then get rid of this line all right now if we run it we should be good to go okay cool so let's check if we are drawing outside of our bounds anymore and no we are not so that's fantastic i told you that would be easy okay let's commit that change oh created response curve component that's a fairly uh fairly aggressive amount of code surgery here's our response curve component with all the good stuff in it here's where we gutted the editor same for right here all right we've come a long way we've done a lot of stuff okay we are going to customize the slider visuals now for this slider class i want it to show the following okay i want to see the min and max range at either end of the slider and i want to see the parameters value in the center of the slider i want the slider to have some customized visuals outside of those pieces of text so i'm going to change this slider class let me go to my editor first i'm going to change this slider class right here to have a custom look and feel that will do those things so a bit of planning before we actually start and the juice look and feel system works as follows let me jump to that okay here we go all right look and feel methods for these slider clasps now the look and feel system works as follows okay inside the component paint function let me go to slider or paint all right here's what happens in the look and feel system when you're painting your components now things are a little bit different with the slider paint but the general practice works like this in your components paint function you're going to call get look and feel and then inside of that you're going to call one of the look and feel member functions sorry in the look and feel class there are several member functions for drawing different things and it's the way it's organized is kind of strange basically like we're in the slider class the slider has look and feel methods there's a look and feel bass class which inherits from all of these narratives from all these things i can pull it up in the docs and you'll see what i'm talking about if we go over here okay so you can see the look and feel class inherits from all of these different base classes you know button has look and feel methods text editor has their own tree view slider label tool tip window okay so what happens is the components they get their look and feel instance and then they call one of these look and feel methods so let me go to the slider.cpp and show you what i'm talking about in the sliders case it uses a pimple to deal with the implementation so i'm going to go to that so we can see what's going on okay so as shown here it's using a look and feel instance and it is calling one of those look and feel member functions okay i'll go back to this so we can see what i'm talking about uh slider look and feel methods okay here we go draw a linear slider the thumb if it's like a slider that's got multiple thumbs and stuff on it if it's a rotary slider a button where to draw the text box what kind of text box to display that sort of thing okay so it's going to call one of these member functions and then inside this member function is where all that stuff gets painted okay so for example the vertical slider is going to call get look and feel in the paint function if i go back here all right here's the get look and feel it's going to pass it to the pimples paint function all right and then that's going to call draw linear slider okay on that returned object okay now the idea is that anything you want to draw on the actual slider part of the component is drawn with that look and feel member function everything that is drawn outside of it is drawn in the component's paint function okay regardless of that i don't want to get lost in those details as i said everything that is drawn outside of the slider area is going to be drawn in um it's going to be drawn in the paint function everything that's part of the slider is going to be drawn in the get look and feel draw rotary slider function okay now i want the parameter value to be displayed in the center of the slider so for this reason i am going to display that in the look and feel member function since i consider it to be part of the slider itself okay i'm going to draw the min and max parameters in the paint function and call that look and feel member function from the paint function okay i know i need a bit of room for the text labels showing the range to be within this component so that means the actual area that the slider will be drawn in needs to be smaller than the component itself i'm also going to want to use a uniform text height for all of the text displayed here so i'm going to need a function that's going to give me that as well okay now the reason for this is because my paint function and the look and feel member function will need to call this get text type function since i'm going to be drawing text in both places and i want it to just look consistent okay i also want to customize the suffix that is displayed for each parameter so this way i will see things like 2.85 kilohertz or 12 db per octave all right we will figure out what to do for the quality parameter when we get to that stage since that doesn't have any units at all okay and then finally i'm going to need i'm going to need a parameter so that way i can get its value so let's go back to our plugin editor all right so we're going to just this class is going to have a lot of surgery done in it okay first let's rename this class and we're going to call this rotary slider with labels okay so the next thing we need is we need to give ourselves a parameter and a suffix like i had said so juice ranged audio parameter we're gonna do pointer to it the only the reason i'm using this thing is because this this is the base class for all of these um all of these guys even though and it derives from audio processor parameter and it contains a whole bunch of member functions that let me pull information out of this if i go take a look at it there's like let's see they're like i'm going to need these convert to zero to one and convert from zero to one that sort of thing and then there's a whole bunch of like you know get value and all this kind of stuff that it comes from the base class okay getting a little sidetracked some let's not get too lost in the minutia about that and just focus on following the code that is going to be written all right so there's my parameter i'm going to give myself a suffix all right now i'm going to update this constructor to initialize these two member variables all right and now let's let's populate that guy okay now we actually need a look and feel class okay we need an actual look and feel class that we can provide our um draw rotary slider function all right if we jump back over to um jump back over to this thing this is where i can go to that slider class here's the look and feel methods so we want to implement a rotary slider function okay so that's what we need to provide here let's make a look and feel all right these inherit from uh there's a few different versions we're going to inherit from the most recent one look and feel the version four and then this is where we are going to implement draw rotary slider so let's go to the slider class and look for that look and feel methods and we're gonna draw that uh rotary slider so just copy this guy declare it here override it and give ourselves a default implementation for right now and then make this um we gotta have that juice name space cool all right we have our look and feel object or our look and feel class we need to give ourselves an instance and then we can set that as our look and feel object set look and feel lnf all right now if we are setting a look and feel we have to remember to unset it in our destructor now as i said we're going to need a paint function because we're going to have some custom visuals so let's do that void paint i had said we're going to need the slider bounds which is going to be smaller than what we're actually going to it's going to be slightly smaller than the component bounds itself so we need some function that can provide that juice rectangle we're going to need that text height so um that's just going to be an integer and then we're going gonna need to get that display string okay that's what that's what's gonna show us that kilohertz or db per octave or um you know decibels if we're doing the gain slider okay so let's do juice string get display string like that okay now did all of these change if we go down to our plugin editor.h go way down here all of these rotary slider with labels yes they are okay all right now we need to initialize all of these guys so go to plugineditor.cpp go to the constructor and all these are declared before the response curve so they need to be initialized before the response curve okay now if you remember this thing needs um this thing needs uh what's it called it needs its parameter and then it also needs the suffix that's going to get displayed at the end so let's do the first one so that's going to be peak freak slider so the wants a parameter so let's use our ap vts to get a parameter and we already know the name this is the peak frequency slider so it's going to be called peak freak and the suffix is going to be hertz capital h okay that's one slider we got to do the rest of them oh this one's a reference not a pointer so we different dereference that okay let's do the rest of these guys and then we need our our units all right this is decibels quality has no units frequency also frequency and then the decibels per oct same thing for this one okay if we build it we should not have any errors oh we have an error what's the problem what happened undefined symbol why did that give us an undefined symbol oh we're missing a pain function that's why okay let's go to our plugin editor dot um dot h and our paint function needs an implementation so just we'll just leave it empty for right now all right awesome build succeeded okay so if we run this we're not going to our sliders are going to be blank because their look and feel is uh null is um drawing this our pain function is empty okay so that's why we don't see any sliders right now but that's okay because we implemented the skeleton so we can start drawing this stuff all right let's make a commit of that implemented skeleton for custom slider visuals all right here's our where we set up the parameters here's where we did all this code surgery it doesn't look like we wrote very much but it's a lot you know it's a fairly big design change first thing we are going to do is make this just a declaration and we will also do that with our draw rotary slider all right now let's go to our paint function which we need to implement now so let's put this at the top let's use one of these to add a space visual delineation so let's implement that paint function first floyd rotary slider with labels paint we're going to use that namespace trick okay we will begin by setting up the rotary slider to visually have a range of seven o'clock to five o'clock okay seven o'clock so here's 12 we're gonna go seven all the way to five this is probably backwards for you with camera but for me i'm looking at it if i had a clock in front of me this would be seven o'clock and then this would be twelve uh five o'clock okay seven o'clock will be where the slider draws the value of zero five o'clock will be where it draws the value of one so let's start by setting up some angles that represent seven o'clock and five o'clock and remember that twelve o'clock is zero degrees and we have to use radians here which is annoying auto start ang equals degrees to radians thank thankfully that function exists okay we want 180.f plus 45 degrees all right so this is 12 this is gonna be 180 and then we're gonna go halfway uh so it's more like 7 30 not seven but either way you know like this this would be nine o'clock this is six o'clock so 7 30 is 45 degrees away okay that's the start angle our end angle is going to be going this way and because we need it to be bigger than this side we have to go one circle around which is two pi and then go 180 minus 45. okay so auto and equals uh this same value but going the other way and then added a um added with a full rotation now the draw rotary slider function wants a normalized value passed to it so we will use the sliders range for that and then even though we haven't implemented this let's prepare for this and just assume we'll be drawing the rotary part of the slider inside the slider bounce so auto slider bounds equals get slider bounce okay let's implement that now all right let's put that right here i remember this is const oh let's just make it return local bounds for right now we will adjust this later so we have some basic information we can call the look and feel function now so get our look and feel and now draw rotary slider and now we just start filling this in okay first thing is g for the graphic context x is going to be our slider bounds x position same for the y same for the width same for the height our slider position proportional if you don't forget that we said we needed a normalized value here so we're going to map the slider's value we're going to map the slider's value from the start of the range to the end of the range and we need to map it from 0 to 1 all right and then our start angle we already have that and our end angle and then our slider is this okay that's a lot that's an annoying function to look at and fill in all the blanks if you don't know what you're looking at all right the important thing is this one this line right here this is where we map our sliders this is where we turn our sliders value into a normalized value so now that we've done this we can implement the draw rotary slider function let's do that up here void look and feel draw rotary come on autocomplete all right let's put that all on its own lines all right we'll do the same using j uh namespace juice trick here's what we're going to do in this draw rotary slider class we're going to fill a circle and it's going to act as the slider background we're going to draw a border around that circle and we're going to convert the sliders normalized value to an angle in radians and that's going to be between the rotary start angle and the rotary end angle we're going to create a small vertical rectangle and then we're going to rotate it to the angle in radians and then draw it okay so let's do the first thing before we do anything else we need a bounding box here we've got our x y width height okay so let's first create some circles that represent the rotariness of the slider now for these colors i just used the app digital color meter and it lets me you know just pick some random colors that i like you know maybe i like this yellow color maybe i like this greenish color or this color right here that's what i use to pick my colors so i'm just going to type in what i picked prior and use them here so g dot set color i don't know what that looks like right now i just know that when i first sketched this project out i liked that after i found it somewhere okay so g dot fill ellipse and this is where we want fill the bounding box let's do the same thing again with a different color and we're going to draw the ellipse which is going to give us the border we said we were going to create let's take a look at that we'll just see some circles cool circles let's make a narrow rectangle that goes from the center of the bounding box up to the 12 o'clock position now if we want to rotate something that's going to be drawn we have to define it inside of a path so let's create a path now and i like using the rectangle member functions to define rectangles as opposed to using the rectangle class constructor that takes an x y width and height because it just seems easier to visualize mentally where things are going to be okay so i'm gonna do that rectangle float r the left and the right are gonna be a couple of pixels off of the center so we can do r dot set left so we can do center dot get x and then two pixels off of that we can do r dot set the right side center dot get x two pixels to the right of center and then we'll just make the top be the bounds top will be the top and the bottom will be the center okay so r dot set top this is going to be bounds dot get y and then r dot set bottom is going to be center dot get y now let's add it to our path p dot add rectangle now we get ready to rotate so the first thing we want to make sure is that this thing is less than this thing otherwise we'll get some weird explosions so let's just add a quick j assert for that rotary start angle it's less than rotary end angle this is what i was saying of how we needed to add a full cycle to it because otherwise we would have 180 minus 45 as our start or 180 plus 45 which is like 225 or something and then this one would give us like um 135 which is less than this it becomes a problem when we do our jmap so now we need to map our slider's normalized value to a radian angle right so we've got autoslider angle in radians is jmap are we are mapping from our slider position proportional from a value of 0.0 to 0.1 and we're going to map it from i'm sorry that should be 0.f that's one dot f our target major in is going our target range min is going to be the uh rotary start angle and our end range is going to be the rotary end angle okay so we are mapping our normalized slider value to be between these two rotary positions which we defined here we can rotate the narrow rectangle to this radian angle using an afine transform and we have to do it around the center of our component all right so p dot apply transform here's we want an a fine transform we're going to rotate it we want the one that allows us to rotate it around a particular location we've got our angle in radians and our pivot point is going to be center dot get x center dot get y now we just need to draw it let's build and test just remember you know they're not we're not we're just drawing them within their bounding box okay but it is doing it and the when the value is zero the notch is straight up and down so that's cool all right so as i said let's see this is where it's at the five o'clock position here's where it's at the seven o'clock position so awesome okay so they look a little wonky let's fix that next but they are working okay we've implemented a customized look and feel the next thing i would like to do is add the center label showing the parameters value next okay we'll figure out that bounding issue in a minute as well let's make a commit of that added basic slider visuals here's where we made these deck made these implementations into declarations then here's where we implemented our first basic paint function which calls the rotary slider and then here in the rotary sliders where we actually draw the things okay okay let's start by drawing the slider bounds and start tweaking the get slider bounds function until it gives us a usable size okay so let's go to where we're getting our slider bounds and let's draw yes let's draw the slider bounds as well as our local bounds so g dot set color red and we'll draw our local bounds and then we'll use a different color for the slider bounds now uh before we start tweaking this let's just shrink this a little bit okay we're gonna want a square so our ellipses are actually circles so let's do auto size equals um and we'll find the minimum dimension of whatever bounding box is returned to us all right so we've got our bounds dot get width balance don't get height oh we need to get rid of this line that's right okay so auto bounds equals get local bounce so now we know we're going to display some text on either edge of it so let's shrink our bounding box by that size let's shrink our size our square size by that much so we'll do size minus equals get text height do it times two all right now we just need to move it towards the top of our component we need to move our slider bounds towards the top so let's create a rectangle that has our size but the top of it is it's so that it's positioned at the top of our component so juice rectangle r dot set size give it a size of give it a width and height of size so it's a square and then we need to set um i don't know what x and y to give it for the actual position because that's based on the upper left corner but i can specify where the center is and that's not going to change the size so i'm going to do that r dot set center i know i want that to be bounds dot get center x so that's going to put it in the center it's going to put the center of this rectangle in the center of my component and then i can set the y position accordingly r dot set y zero or just below the top i'm not going to do zero i'm going to do two so it's two pixels below the top of the component and the sent the center of our rectangle is going to be in the center of our component now let's just return it let's build and test it boom circles at the top slightly below the edge and they're in a square bounding box awesome all right let's make a commit of that because that's helpful all right uh sliders are now circles oh let's get rid of this um this line right there let's amend that commit oh wait no i don't want to amend it sliders are now circles there we go okay let's display the parameter in the center next we will keep the circles for right now let's go to our look and feel we're gonna keep these circles that are being drawn uh but for now we need uh the text height from our slider as well as the text itself so we already had some stubs for these functions in place when we decided we were to do get text height and then get display string right because we wanted to be able to figure out you know what do we display in the center so in order for us to call that we need to get a rotary slider with labels out of this parameter so to do that we are going to have to cast okay so after we get our um after we draw our circles we'll do a cast all right if we can cast it then we know we can call those functions all right so this is where we can do this put that there we're going to need our same path and our same rectangle stuff all right and then actually since our text is going to be in the center we need to adjust the bottom of our narrow rectangle so that it does not cover it up so it's going to be centered i get y minus um let's see yeah the bottom it's no longer going to be the center it's going to be the center uh sorry it's not gonna going to be the bottom of our bounding box oh yes sorry it's going to be um it's going to be where our center is and then we're going to subtract the text height which will put us back towards the top because top is 0 get height is the bottom okay so we're going to the center and we're going to go uh up by subtracting some text height amount okay so we'll just do uh rs rswl get text height and then uh maybe that much maybe two we'll have to see how it looks okay all right so this is where i'm gonna change this from being a regular rectangle i'm gonna add a rounded rectangle p dot add rounded rectangle because you know let's dial it up a little bit our let's do a corner size of two all right now this is where we do all of our rotation stuff so now let's make a now let's make a little rectangle that's a little bit wider than our text and a little bit taller than our text is so that way we can have a nice we know how roughly how much text we're going to need to display so let's make a bounding box that fits around it and then we're going to put that right in the center of our slider okay so let's first get let's first set our font accordingly and we're going to just use that text height as the font it's going to keep displaying whatever default font is currently being used rswl get text height all right this is going to give us this is going to use the default font at this height all right now let's get our text and then let's get our string width string width equals g dot get current font get string width text okay that tells us how wide we are all right we can use this same rectangle so r dot set size we're going to go str width a little bit wider than that and then the font height our swl get text height oops get text height a little bit taller than that okay so now we've got our rectangle r is now has this bound it's it's gonna basically be a little bit bigger than uh the bounding box for our text okay we need to just set the center of it to be the center of our bounds right here our dot set center center that's this guy right here or if we don't trust that we can always write bounds not get center all right and then let's just make a black background for right now g dot set color colors black and then uh we're gonna fill it in uh g dot phil rect r okay now let's use white text and just paint our text inside of that so g dot set color colors white and then g.draw fitted text our text inside of r and r is a float rectangle so we need to get it to um an int to let's see what do we got two nearest in good enough and then we want it centered choose justification centered and one line of text now it's not going to build because we haven't implemented yet display string yet okay so we need to implement that next all right let's put this near where um we build our uh build our slider bounds all right so juice string rotary slider get display string this was const if you remember and we will just do return juice string and we're just going to return our sliders value let's build and test we should see a rectangle in all black with white text in the center of every slider showing some numeric value okay cool so we got twenty thousand it's working as expected all right this is giving us one two three these are the indexes in that string array of choices we created at the very beginning here's our q alright and here's our here's our gain for our slider okay cool so we are not seeing suffixes but we are seeing our values okay the only thing we're not seeing is the proper slope okay we should be seeing 12 24 36 48. we will deal with that next let's make a commit of that displaying basic param values cool okay we are trying to represent two parameter types a float param and a choice param and the choice param has a list that we can use directly if our parameter is a choice then let's just use that choice param so let's get rid of this line and we can do if auto choice param equals dynamic cast um let's see juice audio parameter choice if we can convert our ranged audio parameter to an audio parameter choice then just return that choice param get uh what's it called get current choice name now for the gain and the hertz parameters we need to amend our suffix to the parameter value also i want to truncate the hertz value if the frequency is over 1000 so that it says kilohertz instead so first we need a string object for that and if we and then we need to specify if we're going to add uh the k or not so let's assume we are not going to okay now i don't like to make guesses about what type of derived class my parameter actually is so i'm going to use a cast here to check if it's actually an audio parameter float now i know i haven't added any other parameter types in this project but just in case i'm going to add a little j assert in case one happens to sneak in later in the project all right so if it's this i know i'm cool otherwise j assert false if you recall the values that our parameter ranges had you know that the hertz parameter is the only one that can possibly get over 1000 so that means we can just check if our value is over that and then divide by a thousand to get a kilohertz value once we have that then we can say yes please add a k to the suffix and we can convey that with that boolean flag we used earlier so if value uh first we need to get our value float value equals getvalue if our value is greater than um if our value is over is 1000 or higher then um this is when we want to display it as kilohertz so we will say vowel divided by equals divided by a thousand so if it's um if the value is one thousand hertz we're going to see one k h z like this add true okay now the string class in juice has a constructor which lets you convert a floating point number into a string and one of the parameters is how many decimal places to use now if i'm displaying a value as kilohertz i only want to see two decimal places we already know that dividing um one thousand and one divided by a thousand is going to give us let's see one thousand one thousand one divided by one thousand will give us one point zero zero i don't want to see that okay i just want to see two decimal places so according to this constructor let me pull that up real quick this one right here float value okay it says number of decimal places if this number is greater than zero the number will be formatted using that many decimal places adding trailing zeros if required if the number is zero or less the number will be formatted using the c plus plus standard library default format which uses scientific notation for large and small numbers according to the documentation if you go back over here according to the documentation for this constructor if a 0 is provided for the number of decimal places the number will be formatted uh using the stl with however many decimal places are needed so this will work out when we are displaying decibels or quality versus the hertz okay so we're going to do str equals juice string um where is that one it's down here somewhere this one float okay our float val for our number of decimal places if we are adding the k we want to see two decimal places otherwise the stl formatting is will be just fine so add add k for adding the k give me two decimal places otherwise give me however many are actually needed to display the parameters value all right now the final thing is that we had said that the quality property does not have any units which means we did not supply a suffix if you go back down here you'll see what i'm talking about okay hertz and decibels have a suffix but quality does not have a suffix so if the suffix is not empty let's add a space after the number and then add the suffix if suffix is not empty we can do str um add the space and then um if we are doing a hertz value which is over one kilohertz let's add the k if add k str add that little k like that now we just add the suffix and then we're done return the string okay let's run that and check it out boom 121hz and let's raise that to be over a thousand there we go 1.01 awesome okay and then these guys cool all right i'm not too mad about when it's showing a negative and it's not showing the um uh it's not showing it the rectangle is changing size it's you know that's just like a minor detail that we don't need to fix and now this is displaying the correct slope values so that's cool all right let's ditch those bounding boxes that we're showing the rectangles it's these guys right here i'm gonna leave them in as comments though um because you know if we ever need to debug this some more it's good to just you know it makes it easy to uncomment them and display them later let's take a look one more time and see what we've got all right that's nice and clean cool let's make a commit of that alright so implemented implemented displaying the parameter value with suffix cool let's add the labels next that will show the minimum and maximum values that our parameters can have i would like the minimum value to be drawn right outside of that seven o'clock position on the slider and the maximum value to be drawn outside of the five o'clock position here is how i have decided to go about implementing this okay we're going to have a simple data structure which will hold a normalized value and the string that should be positioned at that normalized position okay so we'll put that let's see let me go to a plugin editor.h all right we're going to put that right here okay so we'll do struct label position give it that normalized value and then the string that's going to get displayed all right now that we have this structure we can just give ourselves an array of them and then all we have to do is add some values to that array and then draw them in our paint function all right let's make our way over to the paint function okay we're going to draw this after we draw our slider so let's see what we need to do is create a bounding box that can encompass our text and then put the center of that bounding box at whatever normalized position we decided we have decided on around our sliders circumference once we have that bounding box we can just use the graphics function draw fitted text like we did right here we can do the same thing to we can do that to draw our label inside the bounding box so first things first let's get the center and radius of our slider bounce auto center equals slider bounds dot to float dot get center okay we want this in floating point numbers and then let's get the radius from that auto radius equals slider bounds dot get width and then give me half of that okay now let's set up the text color and size of the text i'm going to use the same text color uh no i'm gonna use a different text color i'm gonna use like a greenish looking thing again i figured this out using that digital color meter app this thing right here i found a nice green that i liked and just jotted down the rgb values let's do that next g dot set color i've got a value of zero unsigned in value of 127 172 right here for that and then one for the blue and then we need to set our font okay we're going to use the default font with this text height we need to iterate through our labels so auto num choices equals labels.size and here we go four int i equals zero i is less than num choices plus i all right now let's convert that normalized position into a radian angle auto position equals labels okay and we want to make sure that it's between zero and one just in case all right now let's jmap it like we j mapped um this thing right here actually we can just grab this auto angle equals this thing and this is going to be our position and our start ang is going to be um what we set up here same for the rotary end okay now we can use one of the point class member functions uh particularly this one point um i'll show you the member function get point on circumference we can use this member function to find the center point we will use for this bounding box with this particular radian angle we have our center that we will use so center dot get point on circumference our radius is going to be um radius plus get text height yeah we want it to be a little bit further out from our um rectangle so we'll do like half the um text height maybe a little bit of a another question and then our angle is gonna be like that so if you're wondering where this number came from let me turn this back on and draw this okay so i'm talking about here's our center of um that bounding box we're gonna go if if i go if i go radius away from this at this angle i'm gonna end up like right at this point right here so that's why i'm adding text height to it because text height is this amount so i want to go that much more away that's going to kind of put me near this corner right it's going to be different you know it's not going to be it's going to be like this vertical distance away from this angle that's why that's going to do that that's what this line of code does it's going to get me that point auto c equals that okay we have our center point now we can get the width of our string from the currently used font like we did up here i'm going to do that same same thing right here and then we're going to make a rectangle that's going to use that width as well as our text height to define its bounce so let's do rectangle float r um we need our label uh do we need that yet yes we need our label because we need to do r dot set size so auto str equals labels label okay and then we can do r dot set size now we will use the size using that get string width helper function like we showed before uh this is going to be g dot get current font get string width str and then our height is going to be get text height now we can just set our center r dot set center and then um maybe shift it down a little bit just in case so it doesn't collide r dot set y okay we'll get the current y as it is r dot get y and we'll just add a little bit um you know just shift it down just a little bit more okay and then now we can just draw our fitted text and hopefully this will be in the right position okay so g.draw fitted text our text is going to be our string area is going to be r r is a float rectangle type so we want to get the nearest end we need to convert it to integers we'll do the same centered and one line try to fit all the text on one line okay so just to recap we are drawing where we've got the center of our rectangle right here we're going to go at some angle away from it like this and then this would put us right on the edge of the circle and we don't want our rectangle to be centered on the edge of that circle we want it to be a little bit further out and then down a little bit so that way it doesn't collide with the circle okay so this uh this gets it right on the circle this gets it a little bit past the circle and then this shifts it down from the circle all right let's check that out okay why is this not displaying anything oh because we didn't initialize it duh we need to actually provide some labels first so let's do that next 36 step number 36 so we need to go to step number 37. let's go to our constructor in our um where is this this is in our plugin editor plugin editor okay so we will do this before we make our components visible let's add um our min and max ranges so we'll start with the peak freq peak freak slider okay and this is where we'll go to our labels and we'll just add one of these label positions so at position zero i want to display 20 hertz and then at position 1.0 we will display uh 20 kilohertz and then we'll do khc like that let's see if that looks like anything okay cool 20 hertz 20 kilohertz nice all right let's make a commit of that ram min max values stage stage all right let's do the rest of them we got 20 um let's see negative 24 db and plus 24. okay cool so my gain slider uh whoops i always spell that wrong okay so my gain slider is going to show negative 24 and plus 24. my quality will show 0.1 and 10.0 and then low cut and high cut are going to show 20 hertz and 20 kilohertz and then the um slope sliders are going to show 12 and 48 and i don't think there i don't see a need to make it display the decibels per octave thing um anyway let's run it and check it out okay oh let's get rid of these bounding boxes where was that that's up here somewhere that's right here they're handy to have um handy to be able to just pop them in there to help debug your visuals okay cool that's looking pretty clean i'm happy with that all right let's adjust these positions a little bit uh let's adjust these positions a little bit i'm going to make the display a little bit taller and then and i'm going to do that because let me put that back okay it's a little it's a little bit cramped for me here so i'm going to make this just a little bit taller and then we're going to use juice live constant here i want to change the height of the response area okay so get a little look at how that's done so we'll do float h ratio height ratio i'm going to use juice live constant here um we're currently using 33 okay so now we can do this here and we're gonna dial in our height ratio to figure out what size the response area should be okay cool so now we are looking at what am i adjusting all right okay i'm doing that because when this goes like that it covers up that so if i shrink this a little bit does that go away all right that seems okay i need the slider text to not overlap but it's doing it anyway so perhaps i need to shrink this length so it's a little bit smaller or maybe it's not a thing either way 25 percent looks good the knobs are a little bit bigger i mean if we wanted to we could just make this like really big but that just looks kind of weird and we don't even see our slider thumbnail so that's the big problem is i want to see more of the slider's thumb than i'm currently seeing right now which is why i'm making if that's like that i want to make this a little bit i want to see more of the thumb okay so i think 25 looks okay makes it's pretty easy to see where the thumb is okay so we'll stick with that we'll do 25 for that value okay so we'll change this to 25.f divided by 100.f and we'll just comment out because it's always you know it's always useful to be able to uncomment that and use it to dial in those other positions okay now i think if we take a look at that there's one other graphic change i want to make now i don't like this gap right here so i want to put a little bit of room between where the sliders are and where this component where this response curve component ends so we can do that by just removing a little bit from this bounce before we do all of this stuff that's pretty easy bounce dot remove from top i'm gonna just remove five pixels let's see what that looks like okay that's yeah that's clean i'm happy with that okay so let's open this up now i'm gonna let's see what this does i'm just gonna customize this a little bit save it close this okay so these parameters are not drawn on here right away okay so that's a bug that we need to fix so let's uh let's open this back up let's quit this let's see if we can solve that okay so this is caused let's go look at our um timer callback code response curve command okay the chain is only updated whenever the timer callback determines that this parameter is true and this parameter is only set to true whenever the parameter values change so if our gui is displayed have the parameters changed from the since they're since they were initially loaded no they have not okay so there's a couple ways we can do this um first of all the hacky way to do this would be to say you know what this parameter has changed the first time the gui loads but that's kind of hacky okay what we need to do is just refactor how that stuff gets set in the first place so let's make an update chain function and now we can just call this in our timer callback and from our constructor all right so this is going to update the chain during construction which means the chain will give us the proper magnitude values when we paint it for the very first time so let's do that let's add a uh let's put that right here okay we're just going to move that code out of timer call back void response curve component update chain we can just grab all this stuff we're not going to repaint though okay now we're just going to call it update chain and then we can call it in our constructor as well let's call it before we do our timer all right let's run it and we should see uh the chain get updated automatically whenever we close and reopen the gui okay so that's showing up is correct i'm going to change this param to that okay that's on 90b so notice there's a bump right there i'm going to close this gui reopen it and that bump is there cool bug solved all right let's make a commit to that what do we have going on here uh fixed response curve bug when first when um first opening the gui okay cool so we have our um this is where we started displaying the star values and then this is where we actually added those labels here's where we dialed in the um the final position for all the components and then here's where we fixed the response curve issue by refactoring what happens in timer callback into its own function that we can call from our constructor okay cool that wraps up the response curve and customizing the knob visuals okay the next thing to do is to put a grid behind the response curve and then after we do that we can add the spectrum analyzer and then after we do that we can add the bypass buttons okay so we got three big things to do before we are done with this component but we are almost done with this project so awesome it's progressing very quickly at a pretty good clip okay let's give this response curve a proper background component that's going to show the frequency plot and since we don't need to recreate this every time the curve is updated we are going to prerender it into an image so let's head over to our plugin editor.h and we will do that right here now we need a place to make this background image and the resized function is a good place to do this because it is called whenever the component bounds change and it is called before the first time that paint is called so let's declare that guy here all right let's go to our cpp file let's put this after our paint function the first thing we will do in this resized function is make a new background image based on the width and height of our component okay so first let's declare this void uh response curve component resized so okay we're going to create a new background image then we will create a graphics context which we'll draw into this background image and then from there we can just do the usual paint stuff except we are drawing into this background image directly using the graphics context that we created so let's start we'll start with that okay we're going to use an rgb context an rgb pixel format the width and the height for the dimensions and then we want to clear the background all right now we just need the graphics context now i want to draw frequency lines so i'm going to create an array that i can loop through and convert these frequencies to window space and then draw them as vertical lines and these values that i'm using for the frequencies are the standard values people use when producing these types of plots yeah i mean you can come up with whatever you want but these are the pretty standard um values that people use and they're in multiples of 10. uh are they um they um they scale up by a factor of 10 each time so let's do uh so i'm going to do 20 30 40 50 100. i'm gonna multiply that uh by uh 10 and then the last one since that's the top of the human hearing range all right now i'm going to uh set my color to white i'm going to loop through the frequencies i'm going to map them from i'm going to map them from this frequency linear space to a normalized position and then i'm going to draw a vertical line all right let's take a look at that uh i'm sorry actually uh before we even do that um we need to display it in pain but before i do that i want to show some gain lines as well so i'm going to do the same thing i'm going to create an array i'm going to loop through it and i'm going to draw i'm going to convert each value in the array to a window position and then draw it as a horizontal line so let's create that next i'm going to do i'm going to do lines every 12 decibels okay so remember i'm using 24 and negative 24 as my range because that's what our slider can um our gain slider can those are the ranges of that gain slider and then it's important to remember that the bottom of the window at the bottom we want this negative 24 to be mapped to the bottom of our component and then we want the positive 24 to be mapped to the top of our component and then we're just drawing a horizontal line from the left side to the right side all right now we just need to go to our paint function and draw it in the background g dot draw image image to draw as background it wants a float rectangle so get local bounce to float all right let's take a look all right cool it looks like something good times um so for this graphic stuff we're going to switch to the standalone plugin so that way um we don't need to deal with audio plug and host at the moment we're just looking at graphics changes let's look at that one more time okay so the first problem is that there's a lot of collision happening like our plus 24 line and our negative 24 line uh we don't even see them so we need to shrink the bounding box that we are using to compute these values within which means we also need to adjust how our path is going to get produced so let's go to our editor editor.h and then below this let's add a function that will give us the area we will draw our background grid in and also our response curve in i'm going to call mine get render area it's going to return a juice rectangle now go to our plugin editor.cpp and let's go to the bot um go to the bottom of that after the resized function all right so let's use some juice live constant to figure out the bounding box of this all we know is that we are going to reduce our local bounding box but not by how much so this will be a good chance to figure that out so we're going to use the reduce function i'm going to reduce it by some amount we'll do start with five i'm going to reduce both the x and the y and it's important to make sure you put juice live constant on its own line one instance per line okay for right now we're going to stop drawing the vertical lines as well as the horizontal lines and we're just going to draw the render area okay so let's run this and let's dial in the values here let's move this out of the way okay so if we increase this we shrink it we shrink the width and then if we do this one we shrink the height okay so let's figure out what looks good i know i'm going to want to have some text on this side and on this side showing like the actual values for the lines like you know 0 db plus 24 and minus 24 and then whatever i'm going to come up with here and then we need our frequencies uh to get displayed either above or below somewhere so let's dial this in all right and i like shrinking it by 10 i think this is a good width and then height wise i don't think i need that much i'm going to go with 8. so 10 for the width reduction and then 8 for the height reduction 10 and 8. so let me just make that change here 10 8 put this on its own line for right now okay i'm happy with that so let's make the response curve sit within this rectangle now all right let's go to our paint function now all we have to do is change this line right here response area is going to be get render area auto response area equals get render area talk about easy i am glad we planned ahead on that by using this response area to represent what we are drawing let's take a look okay cool so this is being drawn inside here it's also we're getting a little bit of the path being drawn outside of it because our response area is um is smaller than our component and this path is being drawn inside you know the entire component so we'll figure that out in a little bit but this is cool all right we're making progress now i'm going to change this from being reduced on all sides to being reduced mainly on the top and the sides we want to leave room for the frequency label on the top and the db levels on the sides but for the bottom i don't really care about that so uh we're going to get rid of that we're going to do bounce dot remove from top we're going to give us a gap of 12 at the top from the bottom we're just going to do a little gap maybe something like that and then on the sides um my i think we need more than 10 so we'll do 20 pounds.remove from left 20 and then bounce.remove from right 20. all right let's take a look at that okay cool so we've got two pixels of space here we got our 20 here this is plenty of room to have small text and then same for on the top we can put some uh low height um yeah like use a font that's not very tall for right there okay so let's go um let's separate the render area from the actual analysis area so let's add another function here and it's going to be called get analysis area and that's actually going to be what we draw the response curve within so if i pull this back up when we see our you'll have to just imagine the grid lines for right now but just imagine that like we're not going to have the plus 24 be underneath this like right at this orange line it's going to be slightly less than it and same for the bottom our negative 24 is not going to be on this orange line it's going to be slightly above it so that's what i mean when i say our analysis area is going to be a little bit smaller than our render area all right so let's implement this back to our cpp file put this right here all right we're going to start with our render area and then we're going to trim some off the top and trim off the bottom so that way we can see the um the top and bottom line of our um grid as i had explained as i had explained a moment ago balance dot remove from top a gap of four should be nice bounce down remove from bottom same size gap all right now let's use this instead of the response area in our paint function so response area uh not get local bounds or not get render area let's use get analysis area all right so let's take a look at that okay all right so we're still we're seeing our orange rectangle in the wrong uh wrong spot so let's take care of that that goes down here um that's at the bottom that's this guy right here so instead of using the response area we want to use the render area okay cool all right so now let's go back to our um our resized function and let's draw our analysis area right yes let's display our analysis area so we have an idea of where this actually is all right cool so yes um it's slightly in slightly set inside our um orange uh render area okay so let's see let's go up to our frequencies we want to be drawing inside of this analysis area instead of the local bound so let's cache some information about this analysis area let's do this right here we'll go to auto render area equals get analysis area and now let's cache the left right top bottom and width okay because we need the left and the right for our horizontal lines we need the the top and the bottom for our vertical lines um and then we also need the width for um uh is it this thing um well either way all right let's just start caching them auto left equals since the frequency labels as well as the vertical lines we'll need this x position let's just um cache this value into an array all right so we're going to use the same mapping code where we convert our frequency value to a a normalized position and then just compute that to a a window x position um based off of this left edge of our render area all right now we can actually draw our vertical lines let's get rid of this i'm going to use uh i'm not going to use white i'm going to use dim gray for this so instead of looping through our frequencies let's loop through our x positions and we don't need this line anymore instead we need uh this right here we're going to draw x and from the top to the bottom all right now let's go to our gain and let's see we can make it instead of using our get height and zero we can use our bottom and top okay and then uh i want to make the zero db line um have the same color as our min and max slider labels and everything else is going to be grace that will be it'll you know we'll be able to visually see where is zero so we will do g dot set color if it's zero then we're gonna use that one color otherwise we're gonna use um a darker color it could you know dark gray is cool all right let's go find that green color that's in our slider where is that order slider paint uh this color right here and this should probably be standardized into a static color at some point you know define it at the top of the header file but for right now this is good enough all right so we're going to use that right there all right and we don't need this border anymore so let's run it and take a look oh i forgot to uh draw the line so g dot draw horizontal line uh at y and then left right so we should see a green line in the center and there we go awesome it's looking good okay so the next thing to do is to draw the frequency labels let's make a little commit of what we've done so far right we basically roughed out the grid lines added grid lines added grid lines um into so uh let's see we actually um we added grid lines we also um prerendered grid into background image cool okay so frequency labels let's draw these down here get rid of that line we'll do a clean up at the end okay so i want to draw these with that light gray color so that way they pop out a little bit so let's set our color there we want to use a font height of 10. if you remember our um our render area we gave ourselves a room of 12 between the top of our component and where our render area is so i'm going to draw inside that little 12 gap so that's why i'm going to use a font height of 10. if i need to tweak that i can tweak it later all right so now what we will do is loop through our frequencies and x's and draw the text above the grid at those particular positions now i'm gonna use the same trick um that i used when drawing the uh labels uh for the min and the max range where i um added kilohertz use that same trick right here all right then we can just assemble our string lowercase all right and we're gonna do the same trick that we used with the string width and building a rectangle around it very simple stuff we've got a rectangle we're going to give it a particular size i know where i want the center x but not the y and that's okay because i can set the y after i have already set the x position all right all we need to do now is just draw our text all right let's run it and take a look all right cool uh we got some collision of text going on here that's okay though figure that out next all right so it looks like the 40 and the 30 and the 40 are getting pretty close 300 and 400 collide a lot 3k and 4k collide a lot so let's get rid of those and let's try that again ah much cleaners these are much easier to see now that they're not colliding on each other cool all right so let's add a commit for that added frequency labels and we also thinned out number of frequencies all right let's do the gain labels next all right let's go to where we are looping through our gain labels that right here so we're actually going to do this down here all right we're going to loop through our gain labels the exact same way we're going to need that y value all right now we need to make a string with the gain value if it's greater than 0 i want to see a plus sign if it's and if it's not it's going to be a negative number so let's do the same thing string str if gdb is greater than zero uh add the plus sign and then just feed in that gain value all right let's get the width like we did before and then we're going to build a bounding box around that just like we did before same thing here okay now we're going to draw these on the right side of the screen so our x position is going to be the width get width minus our text width and then our height is going to be um uh let's see we're going to i'm not sure where i want the y position to be but i do know that i want the center of this rectangle to be lined up with this so i'm going to use the r dot set center use this thing i know i wanted to use the current center x and i know i want um this to be y okay so like i said i know where i want the left edge of this to be i don't know where i want the um y position to be but i do know that i want the um the center of this text to be at this y position which is the same position we are drawing our gain lines so i can do that same trick where i've got um i know the x um the rectangle has the current x position so i can get the center x of the rectangle and then i can set the y i can set the center with this y value okay now let's just set our color i want to do the same trick i used here where i set it to green if the line should be green the only difference is i'm going to um i'm going to draw the text as light gray to match the other color i used for this text all right so this is going to give me a greenish text color for the 0db mark and then now we just need to draw our text it's this thing right here all right let's take a look at that all right cool we got plus 24 plus 12 0 in green uh minus 24 minus 12. awesome all right let's make a little note about that added uh gain labels to grid okay let's add another scale let me pull this up on this side since we are going to be doing an analyzer let's add another scale on this side for that okay now our gain range for the peak band was uh 48 you know we could do from plus 24 to 24 so let's do the same for the analyzer we'll do 0 to negative 48. so this is easy all we have to do is subtract 24 from the decibel value just do that right here we can go str.clear clear out our string um let's fill it in again this way since we we're not going to have any values over zero we don't need to worry about that so we can just do g db minus 24. right now uh let's just adjust the text bounding box like we did before so we know our x position is going to be on the far left not on the actual left but like one pixel off from it so r dot set x one uh we need to recompute our string width then we need to set our size accordingly then um we can set our color to just always be light gray that was written up here then let's just draw our fitted text inside this rectangle all right so that's good times all we are changing is the x position and then the actual size of it all right let's take a look all right cool we got our 0 minus 12 minus 24 minus 36 minus 48. cool all right so that takes care of that background grid let's do a little cleanup and then um yeah do that clean up let's take a quick look through all this stuff here we go get rid of that line get rid of this okay that takes care of those guys so what we're gonna do next is the fft analyzer and then the bypass buttons okay let's um commit that what we added here this is a code cleanup and then we also added analyzer decibel marks added analyzer decibel marks cleaned up code awesome all right let's head on over to pluginprocessor.h okay go up to the top now our analyzer will display two fft curves one for each audio channel that's because the fft algorithm operates on a single channel of audio okay uh we are going to express that programmatically all right this is uh effectively zero effectively one okay now the fft operates the fft algorithm operates on a fixed number of samples the host is passing in buffers which can have a variety of different sizes so we need a way to collect them into blocks of fixed sizes that's what this class does that's what this class right here does i'll zoom out a little bit i'm not going to explain how it works right if you want to know how this class works or how to make it you can check it out in my uh pfm project 11 course where i explain how to make every little part of this and how to get it all to work together okay let me zoom back in next while our single sample fifo is collecting individual samples from the buffers into blocks we need a fifo that the gui thread can use to retrieve these blocks that this single channel sample fifo has produced that's what this class does that's what this class right here does all right if you want to know how to make this or how to write it you can learn how this gets put together in my course pfm cplus plus for musicians all right you can check those guys out links in the description and all that good stuff okay let's go to the next part all right we need some instances of these things so let's go to our class down here now we're going to need one instance of this single channel fifo per audio channel remember we are working on stereo buffers because it is a templated class i'm going to create a type alias to the type that we will be passing into it so we don't have to type so much okay these also need to be public because the gui is going to need to access them okay we are going to need pointers to this class in the gui side of things and this alias will make it easier to declare instances to declare pointer instances of that single channel sample fifo so let's do that now and then let's declare our instances all right the single channel fifos need to be prepared so let's go do that in our plugin processor prepare to play a lot of pete words right there prepare to play go to the bottom of it after our filters this is where we're going to prepare our fifos left channel fifo dot prepare samples per block same thing for the right side okay now we just need to push buffers into it so go to the process block and at the very end after our processing is done we're going to update it with our buffer same for the right side okay let's go to our plugin editor dot h and we're going to go to our uh response curve component the bottom of it we are going to convert some audio samples into fft data this is not going to be simple okay we are basically going to build um this system let's see i have this kind of drawn out on this grid i'll let me make it bigger because it's important to know what's going on okay we are basically going to build this system right here so here's what happens the audio buffers from the host go into the single channel sample fifo right here okay the single channel uh single channel sample fifo spits out fixed size blocks okay then these fixed size blocks go into an fft data generator right and this thing spits out fft data blocks the fft data blocks go into a path producer right here and then the path producer spits out juice path instances and finally the gui consumes those and renders the paths okay so buffers of random size are fed into the single channel sample fifo right here this thing spits out fixed size blocks then those go into an fft data generator the fft data generator spits out fft data blocks then those get run through a path producer which produces juice paths and those get rendered and consumed by the gui okay that's what we're gonna build okay so let's give ourselves a pointer to one of the audio processors single channel sample fifos single channel sample fifo uh it's that block type simple eq audio processor block type this is gonna and we're doing a pointer to it left channel fifo we're just gonna do the left side for right now let's go to our cpp file let's go to our uh response curve constructor and we need to initialize this guy let's put this on its own line um this is where we're going to do left channel fifo and we want to pass it the audio processor dot what's the name of that thing the left channel fifo okay let's go to our timer callback now this is where we are going to coordinate all of those pieces of the system let me pull this back up we are going to coordinate um coordinate this thing with this with this and with this okay we're gonna coordinate all those little parts together first thing we're gonna do is the single channel uh sample fifo so here's the logic we are going to use while there are buffers to pull if we can pull a buffer we're going to send it to the fft data generator so the first thing we need is a temp buffer to pull into okay we're going to do this um before all of this uh parameters change stuff okay let's make our temporary buffer all right uh just before we do that actually let me go through and just clarify the interface um for our fifo guy single channel sample fifo all we need care about is like uh how do we feed it buffers how do we prepare it and how do we get buffers from it okay this is how we know how many we have and this is how we actually get a buffer from it okay very simple to use same thing for this fifo right here we just push stuff into it and pull stuff out of it and make sure that we've prepared it with however much preallocated space we need okay all right so we need to um go through this logic again you know while there are buffers to pull from the single channel sample fifo if we can pull it then we're going to send it to the fft data generator all right so let's add our while loop while left channel fifo get num buffers available if that's greater than zero there are more than zero buffers available to be pulled let's try to pull one get give me that audio buffer temp incoming buffer if we can pull one of these then we are going to send it to the fft data generator all right now it is very important that we maintain the order of the blocks coming in from the audio thread so before we send audio samples to the fft data generator which we have not written yet we have to make sure that they stay in the same order okay we also need to make sure that the blocks being sent to the ffd uh data generator is the right size so let's create a mono buffer first for that all right let's go over to our header file put this right here so this is what we are this is what the buffer we are going to create now is what we will be ferrying blocks of audio from right to left through so um let me see let me just draw a quick graph of what i'm talking about here okay so what i was saying about how the buffers need to be ferried from the right side to the left so this is an example of like of waveform you know t equals zero and then all the way to the end of it okay so what happens is the buffers are passed to us from the host and they you know that's what these a b and c blocks are so what happens is we're given a and then we need to basically when we consume things with our fft and our um single channel sample fifo we're basically taking one of these blocks and then running it through that chain that i showed before and then the whole thing needs to shift over uh this direction okay so the a block gets discarded right it was just consumed by the gui and then what was in block b and c they get shifted over like this so you can see the continuity of this point right here to this point right there same for that point right there in that point there here's the new data from the host it's getting um added to the waveform right here so it's all continuous and that gets now we consume this part right here okay then the same thing happens this little chunk of audio gets run through the fft stuff and produce is turned into a path and then that gets consumed and then the whole thing gets shifted over again so that's why you can see that this piece gets shifted to block number two then it gets shifted to block number one and then it gets consumed okay so that's what i meant about how we have to append uh the blocks um to the end of it and shift everything uh towards the front of the vector okay so we're going to implement that now okay so uh we are going to need a uh we're going to need a monobuffer because remember these are mono channels of audio um newest blocks are going to get stuck at the end and the oldest blocks are going to go at the front so that way everything gets kind of you know shifted over this way okay step 14. all right let's go back to our cpp file now that we have declared a mono buffer all right first we are going to shift everything in the mono buffer forward by however many samples there are in that temporary incoming buffer okay so let's get our size first all right now let's do the copy okay so we are copying everything from this point which is size samples across let me pull this picture back up okay so let's pretend that this is our monobuffer right here it contains this waveform in terms of samples okay our new chunk of data um is going to get appended here so what we need to do is basically copy all these samples starting at position b shift them over by however much this is this direction so that's what we do here first we get uh we're going to copy everything to the zero with uh index right there and then we're gonna start reading from this point which is b okay that's what this thing does that's our index size that's our index um right there and then we're gonna read uh this many samples so if our buffer is holding this long and we are going to read uh this many samples from it that's how much we have to shift over so we need to keep this much okay i didn't explain that very well but you can see from the code here what's happening so once we have done that now we can copy our temp buffer uh copy all the samples from that to the end of our mono buffer so our size we're going to copy that many samples put this on its own line our source is going to be the temp incoming buffer um it's going to be the zeroth channel zero with index and we're going to copy it to our monobuffer get right pointer copying it to the zeros channel and our sample index is going to be this position okay if this doesn't make much sense to you i suggest that you get out a a line graph uh draw a number line and then you know just like manually draw a block of data moving from one part to earlier in the chain to earlier in the chain and data being added after it and use varying sizes so you can see how what we how far we have it have to move it backwards uh sorry how far we have to move it towards the front is dependent upon what size of our block that is coming in is okay so that takes care of those things all right we're shifting over the data and then we're copying this to the end and the good thing um about this is that um the monobuffer never actually changes size so the next thing to do is to write the fft data generator however if you remember what i said earlier the fft requires a specific number of samples in order to do its processing so we must make the monobuffer have that same size and this is good because we don't know how big to make the monobuffer for us to be able to copy into it and to move samples around it like at this point based on our current code this is not going to work it's going to explode because the monobuffer doesn't have any channels and it doesn't have any samples so we're going to try to do like a negative we're going to copy like negative samples and it's just going to explode okay so once the fft data generator is built we will know what size to use for the monobuffer so we're going to do that next once we are done with those two things then we can start sending buffers from uh the we can start sending mono buffers into the fft data generator okay so let's make this next all right this is going to go up here all right this is the fft data generator all right let's take a quick glance at it it's got a lot of good stuff in it it's pretty it's a pretty complicated piece of uh software machinery now if you want to know how to build it yourself i go through the entire process from scratch in the pfm project 11 course all we need to know for our purposes is how do we feed it audio how do we get fft data out of it and then how do we configure it okay so let's do the configuration first uh configuration depends on this stuff right here here's how we feed audio into it and then here's how we get our fft data and here's how we see how much ffdata fft data we have available to us okay that's the basic interface all right let's give ourselves an instance of this after our monobuffer all right now the fft data generator operates on vectors of floats not audio buffers okay let's go to our constructor so we can initialize this thing okay go to our response curve constructor okay we're going to do this before we start updating our chain all right let's use an order of 2048 that'll give us some really nice resolution in the uh uh that'll give us average resolution um in the uh lower end of the spectrum okay we're basically going to be splitting the audio spectrum up into uh 2048 or 4096. basically whatever value we pick from here okay we can do 2848 4096 8192 basically what we are doing is splitting up the audio spectrum from 20 hertz to 20 000 hertz into 2048 equally sized frequency bins now these bins store the magnitude level for a particular range of frequencies i'm not going to get into the math behind this but here's the simple summation okay if we have 2048 bins and a sample rate is 48 000 then each bin represents roughly 23 hertz in our spectrum okay so that's very simple math if our sample rate is 48 000 and then we have 2048 bins each bin roughly accounts for 23 hertz so that means we're going to let this means we're gonna get a lot of resolution at the upper end and not a lot of resolution at the bottom end so let's just take a look um at our plot so you can see what i'm talking about okay you can see that like whoops yeah this is what i meant about how it doesn't um let me comment out that code this stuff right here let's comment this out so this is what i meant how like if each bin represents 23 hertz between 20 and 50 between this part of the display and this part of the display you know 20 plus 23 is 43 so that's how big one bin is way down here okay but way up here we've got 2 000 to 5 000. how many bins are there let's find out so 5 thousand minus two thousand okay divided by oops divided by 23. there's a hundred and thirty bins that are in between here so we're going to get a lot of resolution uh way up here but not a lot of resolution down here okay this is the big problem with fft but it's you know it's just that's just how it works okay so the lowest five percent of this fee of the frequency spectrum is going to represent 50 percent of the display and the remaining 95 percent is going to represent the other um yeah and it's going to represent the other uh 50 what is that referring to i am referring to where we've got one kilohertz is 50 of the display from zero to one kilohertz and our range is 20 kilohertz so that means this is 120th from right here to right here we cover five percent of our frequency range and then this part the other half of the display is covering the remaining 95 percent okay so all this is saying that you know um our we're going to get a ton of resolution here um not a lot of resolution here the only ways to improve that is to increase the fft order when you do that the fft ends up needing more and more cpu so there's a nice balance between 2048 versus 4096 versus 8192 in terms of these the order that the fft is configured in okay um that was kind of confusing but basically when you make the order higher you get more resolution in the lower end at the expense of more cpu okay so we're gonna put it at 2048 uh frequency bins for right now just so that way we don't have major performance impacts when we actually use this thing let's turn this back on let's go back to our constructor and now we're going to configure this left channel fifo left channel fft data generator dot change order and we're going to use fft order oops fft order and 2048. all right now that our fft data generator has been configured we can initialize the monobuffer with the proper size so we can do monobuffer dot set size we are processing one channel and our number of samples is whatever size this thing needs left get fft size we can uncomment these guys these guys are uncommented all right now that we have this and the monobuffer is set up and the fft data generator is ready to receive buffers we can start sending mono buffers to the generator so we can do left channel fft data generator dot produce some fft data we're going to pass it the mono buffer and we want to use negative infinity we want to use our negative 48 as where negative infinity is or we can change this value later okay so let's check this out i'll just put negative 48 because i want the bottom of my display bottom of my spectrum analyzer that grid point um i had set the scale to negative 48 so i'm going to use that right now for the concept of negative infinity okay so let's build it and see what happens all right build failed why are we failing too few arguments expect to call aha this is because our fifo class needs a second prepare function to handle when the type is vector not audio buffer that's over here in our plugin processor all right it wants this we are currently using this let's see what's going on prepares declared here we are instantiating it um where is this being called from it's being called right here where we've got an uh fifo uh with our block type of um where was this declared this was being declared with uh std vector okay so that means this fifo has a block type of std vector okay and so obviously std vector does not have a set size function so we need to create a new prepare function all right let's go do that all right let's use some static asserts to remind us if we are using to remind us which prepare function to use so we'll do static assert our expression is going to be std is same there it is all right if um our template type is t um we want to only use this prepare function if our t is audio buffer so prepare num samples okay it's helpful helping ourselves so check it out if we build it now static assert failed so that's fantastic failed to meet requirement and then we can see the message it should only use one fifo okay that's good times and it says right here uh instantiation of member std uh fifo std vector okay so we can you know help ourselves out that way let's write the other uh prepare function void prepare and this is gonna be size t num elements because vector uses size t internally we'll do the same static assert we'll change the message a bit instead of this we will use std vector and this should be num elements num elements should only be used when the fifo is holding std vector float all right let's uh loop through this here we're gonna go for auto buffer buffers buffer uh let's see dot clear clear at first then buffer dot resize num elements and fill it with zeros all right now let's build it all right build succeeded let's head on over to plugineditor.cpp now the fft data generator let's go down to our timer callback okay the fft data generator is producing fft data blocks for us so now we need to turn those blocks into a path instance okay so let's write a path generator class all right let's go up to our header file we'll go after the fft data generator before the look and feel guy now this class is going to take in this fft data a bounding box info about the fft size and the bin width and it's going to spit out a path okay now this is the this is a simplified version of the path producer in project 11 so if you want to learn how to make the advanced version check out the course you're going to learn to make all this stuff from scratch by yourself i'm going to give you the instructions and then review your code which is pretty cool all right let's do this all right i'm just going to paste it right here okay we can check this out in just a little bit okay all we need to know is how to feed it our data via the generatepath function and then how to get paths out of it that's what this does right here okay so we've got our number available we've got our uh our function that gives us any paths that we request and then here's how it actually converts that into data so again if you want to learn how to actually write this from scratch and learn how it actually works this is a simplified version of the big one in the full course okay all right obviously we are going to need an instance so let's give ourselves one of those that goes down here analyzer path generator we want to feed it juice paths or we want it to produce juice paths for us path producer now we can go back to our timer callback and use our familiar logic while there are fft data buffers to pull if we can pull a buffer let's generate a path okay so i'll just make a little comment myself if there are fft data buffers to pull if we can pull a buffer generate a path all right very simple okay now the path producer will produce a path inside of whatever bounding box we give it okay let's just take a look at this interface real quick all right so we've got it wants some rendered data it's going to want a bounding box and it wants to know the fft size the bin width and where negative infinity is or what value is being considered negative infinity okay so let's provide those things so our bounding box is going to be our fft bounds get analysis area and it wants it to be to float all right and it needs to know the fft size and the bin width and frequencies so the fft size as we showed in the constructor we can just get it right from the constructor like that or right from that uh fft generator class auto fft size oh these should be const because they're not going to change okay and then we need to know our bin width and that's going to be as we showed up here our sample rate divided by our fft size let me just copy this down here bin width all right so const auto bin width equals audio processor i'll get the sample rate divide that by our fft size convert it to double because sample rate is a double okay now we can implement our logic here while left channel f50 data generator um while it has fft blocks whoops right if it has more than zero blocks available let's try to get one okay we need a temporary vector std vector float uh fft data put past that here all right if we're able to pull one then we can pass our vector of fft data to our fft data to our path producer sorry okay one more time so we're going to check if we have more than zero fft blocks available good um if we if there are more than zero fft blocks available let's try to pull one and if we are able to pull one this vector now contains our fft data which we can then feed to our paths producer okay so let's pass that along fft data we know our bounds that's that fft bounds we know our fft size we know our bin width and we'll use that negative 48 again for the concept of negative infinity all right that should build without errors all right good times i'll let you see this uh fft this path generator one more time so you can try to copy the code real quickly scroll down a little bit you can just pause the video if you need to to see it good times same for this one right here all right there's the path there's the data generator okay all right so this builds currently um we are almost there we just need to retrieve these paths and then draw them all right go to your plugin editor dot h okay go down to after where we added our path producer all right we have at this point we are producing paths in our path generator now we just need a path to draw and to pull into okay because remember we're pulling it from the timer callback we need to get it into our paint function so it needs to be a member variable choose path left channel fft path okay that's makes sense why we have that all right let's go to our plugin editor back to our timer callback so at this point a path producer has potentially created a path for us so we need to try to pull them now what happens if we are producing paths faster than we can consume them we just want the most recent one so our logic is going to be while there are paths that can be pulled pull as many as we can because we only we're only going to display the most recent path all right so while uh path producer get num paths available now we can do path producer get path and we can use our left channel fft data path okay that has successfully pulled that path now previously we were only repainting whenever the um parameters were changed but because we're pulling paths all the time we need to repaint all the time so this gets commented out this goes here repaint like that all right now we just need to paint the actual path let's go here all right let's go to our timer let's go to our paint function and let's draw this where are we going to draw this let's draw this before we draw our uh where is this let's draw this before we draw our rendered area so it's behind everything okay let's do let's i'm going to use a blue color all right and we can just do g stroke path left channel fft data fft path and then i'm just going to use a path stroke type of with a thickness of one and let's run it we should see something oh my fault what is going on here i spelled that wrong i did spell that wrong okay let's run this um not as the standalone but as the plugin has the plugin in the audio plugin host okay we should see something once we actually press play okay all right we have a blue line what happens if we actually run audio through this all right it's doing something okay cool that is an fft that is a spectrum analysis okay now it's in the wrong place but it is working which is awesome so we can fix that positioning next let's make a commit of that because that was a lot all right uh implemented basic fft um design okay of course in the description i will have um you can the links in the links in the description the links in the description will um there will be a link to this repository so you can check out the code for yourself um uh once this video is out and then you can get the code for the single channel sample fifo the fft data generator and the analyzer path generator okay all right now there's a small bug right here with the way this stuff is getting mapped we are currently mapping from um we're mapping our bin frequency from 1 to 20 hertz but our frequency range is not 1 to 20 hertz it's 20 to 20 hertz so that's the first bug fix we need to do okay if we run this and check it out it should look a little bit different or the x positions should look a little bit different okay now it's hard to tell but basically we weren't seeing a lot of left stuff on the left side okay so that's a good time all right let's close that let's save this so our parameters are saved and we if we want we can use a different color to make the paths more visible it's you know that blue color is kind of hard to see okay let's start making this show up in the right spot okay let's go to our paint function okay now when the path generator creates a path it does not take into account the origin of the rectangle that defines the bounding box so we need to translate our path to the analysis bounding boxes origin okay right now this path is drawn at zero comma 0 and we need it to be drawn at um our response areas x and y that needs to be the left side of the path okay so we need to do a translate first so let's do that right here left channel fft path dot apply transform so we're going to do a normal a fine transform and we're going to add a translation to it so we want to do response area dot get x and response area dot get y okay what does that do if we run it that should be all we need to do okay cool this is like right the right on the negative 48 so let's push play cool so it's now drawing in the right spot i'm gonna use a different use like sky blue or something for this instead of that dark blue so we can see it a little bit better oh what happened here oh there's a bug for that that's right it's gonna do that for a while for some reason um we'll figure it out the fft data is just full of nands i'll just comment that out for right now okay let's press play all right that's easier to see that's all i'm trying to show okay cool all right we'll figure that out in a little bit all right let's make a commit showing um that we fixed the positioning because sometimes those types of bugs will take a long time to diagnose and then solve okay so fixed fft path position stage that stage that stage that okay next we need to verify the accuracy of the analyzer now to do this we are going to go to our pluginprocessor.h we are going to well we're going to switch to the standalone version and then we are going to we're going to use an oscillator to do this and we need to initialize it prepare it and then use it in the process block so we're going to feed it a test signal go way down here right down to the bottom after our update filters so juice dsp oscillator float like that okay that is now declared we're going to make this produce a sine wave at a particular frequency and we want it to line up with our we want it to line up on our grid where it should okay so let's go to our um where do we go next we go we need to prepare it so let's go to our prepare to play function let's do this at the end uh the oscillator wants a function that returns a value when you feed it a radian angle okay so std sine wrapped in a lambda will do that for us so oscillator dot initialize here it wants um uh lambda that takes in a number and returns a number so let's do that here's our number that it's going to take and then here's what it's going to return okay now we need to prepare it and we can use the same spec for our chain as long as we just change the number of channels okay previously we were given um we were saying our spec only had one channel we just need to change that spec.num channels equals get total num output channels sure and then we can prepare it ask.prepair the spec then let's give it a frequency of 200 because that's one of our points in the grid ask.set frequency we'll be changing that frequency for a while just to verify the accuracy so i'm going to go with uh uh that value 200 initially and let's see what comes next all right let's go to our prepare our process block because we want to use our oscillator to fill the buffer okay so we're going to do this before we um we're going to do this after our filters are configured but before we actually run the sound through the filters we don't want to hear any of the audio that's currently coming in so we'll do buffer.clear and then we need to make a stereo context and then give it to our oscillator to process that's all we have to do so let's see this block is already stereo so let's see i'm going to move this after this thing okay buffer's clear we need let's make our stereo context for this block stereo context from the block and then now we can just do ask.process stereo context all right that's it okay and we can now check the accuracy so apologies in advance for the annoying sine waves we're going to hear okay so our frequency was 200 so let's try 500 and 1050 and 5k and see what it looks like so i'm going to change this to a thousand we should see a little blip right at that point all right that's good for me thousand let's do the annoying one five thousand yep right at 5k yikes that's painful let's make this 50. this will be the last one that we test all right i'm not seeing anything at 50 so let's try 100. all right there's our 100 okay so 50 was pretty low for some reason it's pretty accurate it you know it's showing a peak at 100 it showed a peak at 200 1k 5k okay so that's good times um if we want to do more resolution in the lower end we could just change the order of the fft generator but this is good enough for this project you know like we're just trying to get our feet wet and understand how some of these uh things get put together in audio plugins so the next thing to do is to add a second set of generators that can produce a path for the right audio channel all right let's get rid of our let's get rid of that process block stuff this stuff right here let's just comment that out in case you know we're gonna leave the code in in case we ever need to test that again but that's you know we're going to turn that off because who wants to listen to those sine waves again okay let's grab everything we used in the single channel version of the fft and put it into its own class this is going to be the single channel fifo buffer the monobuffer fft generator analyzer path generator and the path itself so let's make a new class we're just going to migrate these things over there first okay so i'm just going to cut these we're going to go up here we're going to put it right here put them right there all right so we have moved those over okay this is going to produce a ton of errors if we try to build it right now but we will get to that now we just need to give our response curve a path producer for both channels okay next we need to add a process function that's going to basically do what the timer callback did let's jump to that so we can kind of get a feel of what i'm talking about um this process function is going to do this it's going to do this stuff and it's going to do this thing okay so let's declare that first um actually let's take a look at this so let's see right now um the only things we actually need from it are uh this temp buffer uh fft bounds and fft size and bin width um yeah okay so we just need and even then like this this fft size comes from this member variable um fft bounds that's just a rectangle we can provide that and then um we need the sample rate okay so let's do that let's go back here let's declare this let's make these guys private private void process let's give it our rectangle and the sample rate okay now we need a way to retrieve the path so let's add that okay all right now we need to do what the response curve constructor did to initialize the fft data generator and um the monobuffer so let's add a constructor all right let's go out of constructor let's do it in class for right now it's gonna take this same um this same argument s c s f and let's initialize that left channel fifo scff scsf okay now let's just migrate over that code from the constructor over here where was that that's this thing okay we're gonna just grab these two lines cut them paste them here all right now we just need to initialize our um path producers from our response curve so let's get rid of this line and now we can do path left path producer and this is where we need the audio processor left channel fifo address of that or not the address it wants a reference and then right channel path producer this one's the audio processor right channel fifo all right let's implement this um path producer process function let's put that right above our um right above this actually let's just put it right above this timer callback because it'll make copying the code easier so void we can move it later path producer process okay so we need our temp buffer these guys just go like that copy and paste it do the same thing with the fft bounds and through the path producer loops and now instead of doing auto fft equals get analysis area this is a function argument so let's get rid of that and then our bin with is using the sample rate very convenient all right so we took all of that code away and now we are going to call our process function instead auto fft bounds equals get analysis area dot to float and then auto sample rate equals audio processor dot get sample rate and then we can do left path producer fft dot process fft bounds sample rate and then right path producer process fft bounce sample rate now we just need to grab the paths returned from this in our paint function and draw them so let's go up to our paint function go to where those paths are drawn it's right here uh we will do auto left path fft sorry left channel fft path fft path equals leftpathproducer.getpath okay that takes care of that and then we can also uh let's see we're doing sky blue for that that's cool and now we can do the same thing with the right path auto right channel fft path equals right channel uh get path and do the same transform and then draw it the same way i'm going to do yellow for this guy i'll do a light yellow all right let's test it out we should be able to see two analyzer paths ah actually this is the standalone version so let me quit this and then run the vst version and now we can run some audio through it and it should be good to go okay let's press play we should hear some audio all right cool all right cool so i'm i'm so i'm i'm not seeing that so the solution well i'm seeing a yellow i'm seeing a yellow path um i guess our file is our file is this file that uses file that i'm using is uh fairly why is that only doing that interesting interesting we're not seeing we're not writing our right channel for some reason all right let's see if we can figure let's see if we can figure that out i found the error so the problem was i was drawing the left path twice that's all it was pretty dumb pretty stupid error that's what i get for copying and pasting and not being thorough the way i went about actually trying to debug it was going over to my plugin processor and then in my process block function i'm going back to using my test oscillator and i'm clearing the buffer and i'm writing the oscillators samples to only one channel particularly the left channel and then from there i was just checking to see like hey is this actually getting proper audio so it turns out it was and then after looking at all the other code that was copied over it literally was just me um drawing the left path twice okay so let me go turn off the turn off this code right here and then let's run this in the vst and we should let's run this in audio plug and host and we should see both the left and right channel all right let's try this again let's try this again all right right definitely have a blue and yellow line that is fantastic that is fantastic and if we roll out of the roll off behind all the behind all the highend stuff disappear same for real for falling off we get to see our frequency our frequency responder that get dipped out as well all right cool all right cool okay so okay so that's the analyzer you can check that out we can check that off make a commit of that commit of that right imprint fft from spectrum analyzer analyzer okay let's just stage all this stuff and commit okay so the next thing that i want to add is some bypass buttons for each band and then a bypass button for the analyzer because those analyzers always use a ton of cpu okay cool all right time for the bypass buttons now we have three bands and thus we need three boolean parameters to enable bypassing each individual band and i also want to be able to turn the analyzer on and off so we're going to need a boolean parameter for that so head on over to your plugin processor and go down to where your parameters are created and we're going to add some booleans for this okay layout.add std make unique and we want juice audio parameter bool i'm going to call this guy low cut bypassed and a default value of false meaning that they are not bypassed all right we're going to do two more of these for the um for the parametric band peak band whatever you want to call it and the high cut okay and then one more for the analyzer to be enabled and this one's going to be true meaning the analyzer is enabled by default okay let's go over to our plugin processor dot h because way up near where our chain settings are defined we need to supply the bypass states at the same time so let's add three boolean flags to represent that boolean uh low cut by past false peak bypassed false and then high cut bypassed false let's go back to our plugin processor.cpp let's go to where our um where we get our parameters get chain settings this is where we need to grab these guys now these are boolean parameters but the parameters are stored as floats so if the great if the value is greater than 0.5 that means it's true so we can do settings dot low cut bypass equals then get the parameter low cut bypassed it's atomic if it's greater than 0.5 then it is bypassed and do the same thing for the other two parameters okay all right let's go to our update low cut filter function now all we have to do here before we update the cut filter is set that bypass state so left chain dot set bypassed and then chain position low cut and then chain settings low cut bypassed all right do that for both chains whoops copy paste right chain do the exact same thing for the high cut all right we want the high cut position and high cut bypass and then finally do it for the peak filters well let's just copy this copy this line left chain to set bypass peak all right that takes care of the dsp our chains get updated with the bypass settings now we just need to add some buttons to the gui so let's go do that next head on over to the plugin editor dot h and we're going to go down to our editor and we're going to add um we're gonna add some toggle buttons okay i'm gonna use toggle button for right now because we can customize those visuals later we can customize those visuals later and this is just gonna do the job for right now all right i did all four low cut peak high cut and then the analyzer enabled button now let's go to our plugin editor dot cpp we're going to go down to our get comps function we're going to add those four buttons all right now we need to position them so for this let's go to our resized function now i want to give them a height of 25 i want them to sit above each of these stack of knobs that we got the stack of sliders so we've got our low cut area our high cut area so at the top of those is where i'm going to put this okay so let's do the left side first the low cut low cut bypass button set bounds and we're going to do a low cut area remove from top 25 all right we'll do the same thing for the high cut i cut bypass button set bounds high cut area remove from top 25 and then our peak bypass button peak bypass button let's set bounds equals uh bounds dot remove from top 25. cool we are going to do the um uh we're going to do the analyzer button in a little bit but we have these three let's take a look put it on the standalone version for right now should see three buttons right in the middle um right in centered among the three rows three columns of but of sliders and there we go here's our toggle button all right cool let's connect them to parameters next all right go back to plugineditor.h and we need to declare some button attachments so using button attachment equals ap vts button attachment and now we can declare four of them i'm just gonna copy these guys and then put attachment at the end if i put them all in the same line it'll make it real easy before i line them all up and i can do this cool all right so those are the attachments we're going to use them the same way we d we did with these sliders we just just need to connect them to the actual parameters we go do that in our constructor plugin editor constructor at the end of this list this is where we need to add the attachments uh lowcut bypass button um it's this thing it's this thing low cut bypass button and then the parameter id is low cut by passed all right and we need to do this for the other four buttons even though we're not showing the analyzer peak bypass button okay let's give that a quick build make sure we don't get any errors and let's run it to make sure that we typed our param names correctly but those should be connected now all right so let's run it all right let's run it with audio plug and host so we can run audio through it and see if we hear it do anything okay so i'm gonna set this up kind of high run some audio and then bypass all right so the bypass control definitely works but the response curve is not updating okay let's take care of that next all right let's head on up to our update chain function for the uh response curve component now we've got our chain settings right here so we're going to do the same thing we did with the process block we're going to update the bypass states of the chain accordingly mono chain set bypassed and then each of the indexes chain position low cut chain settings low cut bypassed all right do that for the other two chain positions okay all right once we've got these bypass states um let's go to our paint function because once we have these bypass states you know if the chain is not bypassed um we need to add the magnitude however for the low cut and high cut bands even though we bypass the entire chain this right here does not check if that actual link in the in the greater chain is bypassed so we need to do that for these guys we need to do if mono chain dot is bypassed all right if the low cut processor chain is not bypassed then we can check if the individual bands are bypassed we can do the same thing for the high cut all right let's test it out oh got this jscert that's happening we'll take care of that in just a little bit for some reason the render data is full of uh invalid values let's show me my plugin gui all right all right look at that it does it for this one that's bypass cool let's do it for this guy all right awesome that is working as expected all right let's uh make a commit that we have added bypass buttons added ability to bypass dsp bands response curve follows bypass state good times all right we can dial in the graphics next okay for this we want to use the toggle button um look and feel function draw toggle button let me pull up the documentation for that so look and feel methods version 4. let's see these are slider we want to look for toggle button where is that where are those look and feel member functions you know it's part of um the look and feel class okay so we've got uh draw button text draw a toggle button draw a tick box drawable button all that kind of stuff okay so we want to implement draw toggle button so let's go up to our plugin editor.h let's go to where our look and feel is declared and we're going to add this draw toggle button function i'm just going to grab it from the documentation give me some names for these guys let's put them on there online and then all these need that juice namespace before them okay all right and after these look nice it would be wise to make the toggle buttons actually disable the sliders for whatever band they are attached to so that's going to be one of the things we're going to work on as well all right we just need to give our editor a look and feel instance all right and we need to assign it to the three bands we'll do that in our constructor go down here let's do it after we add our make our guys come uh make our guys visible peak bypass button dot set look and feel no low cut and then we need to set these to null pointer in the destructor cool all right let's go to our look and feel implementations plug plugin editor.cpp go to where that look and feel implementation is it's way up at the top all right let's clean up this space now right here what i would like to do what i would like to create for these toggle buttons is a power button type of graphic and this can be accomplished by using the path function add centered arc now this function will let us create an arc which has a notch at the top and then we just need to add a vertical bar that goes from the top to the center and that's it okay it's super easy just use a wide stroke type when it's time to fill the path and it will look like a power button so let's do that all right using namespace juice because i didn't turn it on in processor in a producer that setting is um here by the way if you go under your gear then you can do add using namespace juice to the juiceheader.h it's disabled by default because the thought is that it's you're less likely to get collisions with other namespace classes such as the point class which is a default class on it's a it's one of the classes that comes with some of the os x frameworks so by turning this off it makes it less likely that you're going to get those types of namespace collisions with your class names okay all right enough of that uh let's see path power button okay first thing first is we're going to create a rectangle this rectangle is going to have equal length sides and in the center of that will be our um yeah this rectangle is going to be um center in our component's bounding box so let's do that first uh where's our toggle button we're going to do that same uh j min thing that we were talking about um we did that up for the um we did that somewhere somewhere we did a j min so that way our um one of these rectangles was a square inside of a nonsquare bounding box that right here this is where we did it in the get slider bounce okay we're doing that same thing right here all right so instead of it being exactly the exactly a square in the center of it we're gonna shrink it a little bit maybe like six or so we'll use juice live constant to figure it out later maybe maybe we'll do four uh no i'm gonna go back to six um if i want to adjust it i can come back with juice live constant and tweak it that way all right then auto r equals um bounds dot width size keeping the center so i'm creating a rectangle with this size whose center is the center of our toggle buttons uh bounding box all right now let's specify some angles to make the gap at the top of the arc okay i am um yeah we're gonna yeah we're gonna specify some angles to make the gap at the top of the arc and then we're going to shrink this square to be drawing um we're going to shrink the square just a little bit more we'll play around with it and we'll juice with juice live constant and you know get it to look the way we want it to look so float ang equals 30 dot f because it's radians because i don't know how i mean it's degrees because i don't know how to think in radians um we'll shrink this size a little bit maybe just a little bit more we can use juice live constant later now let's make our arc power button dot add centered arc okay so we're going to center it at r our radius is going to be half of the size of our box that we have size times 0.5 that's radius for both axes all right we're not rotating this ellipse at all so that means that 12 o'clock is still gonna be right here as opposed to if we had rotated it then it would be like negative 30 goes to here and plus 30 goes that way okay so we are going to do zero for that and then our from radians uh let's see if this is 12 o'clock right here at the top i want to go negative 30. oh no i want to go 30 this way and then i want to go uh 360 minus 30 for the second one so here we go let's see radians uh sorry degrees to radians and we've got 30 all right our angle and then the same thing degrees 2 radians uh 360 degrees minus our angle so if we want we can open this up and there's no you know we're using these variables so that way we can adjust the way these visuals look and then yeah this says there's there's an extra let's see power button dot add centered arc there's an extra parameter that's not shown up here uh start as new sub path so this this is the parameter i want to add this should be true all right now let's make the vertical line okay power button start new sub path and this sub path is going to be it's going to be at the center of our rectangle but then at the top and then we can do a simple power button dot line to r dot get center we're going center of our box at the top y equals zero and then we just go straight down to the center all right let's just create a path stroke type of two um norm you know normally when you draw a path you can do uh juice you can do g dot draw path or stroke path like that and then provide a stroke type that way but i want to specify some custom stuff so it will help me if i use the um path stroke type constructor this one right here so i can um use that joint style okay so i'm going to use a stroke thickness of we'll try to and then for the joint style if i use a curved joint style it'll give me rounded edges at the gap and then around that rectangle so i'm going to use that so i'll do curved all right now this just needs a name pst and now i can use that here pst and then the path is going to be the power button and then what is wrong with this why is this complaining oh is that because that needs to be to float yes this should be a float rectangle um now we just need a color so if the button is if the button is on we're going to use one color and otherwise we're going to use another color so what that means when the button is on is that the band is bypassed okay so that's so if it's bypassed let's use a gray color and then if it's not let's use that green color that we've been using in other places because it looks cool all right so let's see auto color equals button dot get toggle state oh sorry toggle button i get toggle state get the toggle state if it is on meaning the band is bypassed we're going to use colors dim gray otherwise let's go find that green color i think that's this i should really standardize that but you know it's a tutorial i'm not trying to show the best practices but i'm trying to show good practices okay here we go g.set color color all right so we're going to draw our path and then we can draw a uh draw a circle around the whole thing once we draw our path g dot draw ellipse and we can do r with a line sigma thickness of two all right that should look good all right let's try that out hey look at that okay cool so these are currently not bypassed so i'm going to adjust this and then do that so that's cool that works as expected if it's green it means it's active if it's gray it means it's not i'm happy with that that makes sense well that's kind of interesting if as long as we're clicking inside the bounding box uh it's gonna toggle it so something that we could do that i'm not going to do here is to set up the hit test region so that way if you only click inside this area it says yes you clicked on me um if otherwise if you click out of that no we did not click on you so for reference um i'm gonna just add a uh g dot set color colors red and then g dot draw erect just so we can see the bounding box i'm actually talking about um bounce so this way you can see what i mean about if you click outside of it okay so if we click anywhere in here we are technically clicking inside that toggle button okay but we only want to you know if we it's not something i'm going to do in this video but we could go through and say you know what it's only when you click inside this there's a special hit test function that we can override and say if we click inside here that means we actually clicked on the component if we clicked here we did not and that's how we can make it only respond that way but i'm not going to do that it's a little bit beyond the scope of this tutorial so i'm just going to get rid of that okay let's um add a commit for that so customized um customized the uh graphics all right before i do that actually i wanted to show the juice live constant thing so if we do this here juice juice live constant this was six same for this one this was also six and we can mess with this angle too um all right so this will be interesting we can see what that looks like let's change these numbers move these sliders we'll get to see what it looks like all right let's move this out of the way so we're changing the first one this is going to make these guys get smaller or bigger and obviously once we get past a certain point they start being drawn outside their bounding box now here's where we can adjust the angle so that's kind of neat all right so i like where we had it maybe 40 or 40 looks kind of cool maybe a little bit closer like 25 is good and then this one this shrinks that guy a little bit more so it's like this one changes the whole thing and then this one changes that inner arc all right so i'm going to leave those where i had them because i liked that positioning but you can do that same thing to adjust the placement of those guys all right i'll put this back to um put this back to 30 put this back to six and put this guy back to six as well alright cool let's make that commit all right now what i want to do is reuse that toggle button functionality for the analyzer button as well let me say that again what i want to do is reuse this toggle button i want to reuse this draw toggle button functionality for the analyzer button as well but what i want to do is switch based off of the button type in that draw toggle button function so i'm going to create two classes i'm going to go here in my editor i'm going to do this right above the editor i'm going to create two classes that inherit from toggle button and that's going to allow me to cast between the um it's going to allow me to cast that uh let me see let me go up here it's going to allow me to cast this argument to determine if it's one of these two types of buttons and then i can switch accordingly um in the actual implementation of that function uh just follow the code you'll see what i'm talking about i'm not explaining it very well here we go struct power button juice okay very simple struct uh analyzer button okay so that's step one all right step number two is to make the bypass buttons uh we'll make the bypass buttons become that class power button and then the analyzer button needs to be an analyzer button like that okay very simple all right now let's go up to our draw toggle button look and feel implementation this guy right here all i need to do is just cast and everything should work as it did before okay so i'm just going to have this power button path i'm going to cast um i'm going to make a check and if like i can cast this object to a power button type then i'm going to do all of this all right if auto okay so if we run it i'm going to put this back on the editor on the standalone version because it opens a little bit quicker um we should be able to run it and now we can add code that draws the analyzer button after this is verified all right sure enough we still have our analyzer buttons our our bypass buttons working as expected cool so let's add our analyzer code um where is this being added okay we're going to add our analyzer code here now i think it would be cool to see a randomized path drawn inside of this button to kind of you know reflect the fact that it is an analyzer so i'm going to use the same color settings that i used for the power button green if something is active and gray if something is not in this instance the toggle button will reflect the opposite state that it did with the power button which means i cannot use this thing i have to flip it around so let me add an uh if else or an else if right here to make sure i have an analyzer button go faster if you're walking copy this color line over and we need to flip that that's all because as i said if the toggle button is on then that means we want to use this green color otherwise if it's off let's use the dim gray all right g dot set color color okay next i'm going to start by drawing a normal rectangle auto bounds now i'm going to shrink it a little bit and then i'm going to randomly generate a path inside of that smaller rectangle i don't want it to look too crazy so i i will produce a line segment every other pixel so let's start with our path random path we'll use a random object and then now we can um start our random path we will start it at our inset and our y position will be in set rect.get y um plus inset height times some random float value right so our y value is going to be the top our height is the bottom so we're going to go remember this is 0 and this is height so we're going to go 0 down to height multiply height by some value between 0 and 1 to give us a random height between the top and the bottom all right now we just needed to perform a line to like this for auto x equals um in set rect dot get x plus one x is less than inset rect.get right plus uh x plus equals two then we just basically do this our x position is going to be let's see this is going to be line two oh boy line two get out of here trixie let me just type this line random path line two our x is gonna be x and then our y position is gonna be this obviously we should precache some of these positions because calling get y and get height every line you know it's not ideal but whatever we can always refactor that type of stuff later okay now let's just draw the path let's use a thickness of one all right that should do it let's get our analyzer button on the screen and using this look and feel so we can tweak this if needed head on down to our uh editor constructor let's provide that look and feel analyzer enabled button set look and feel all right and don't forget to disable it all right now i'm going to stick this right at the top of the gui on the left so let's see i'm gonna go like this i'm gonna go um auto analyzer enabled area equals bounds dot remove from top give me the top 25 pixels just a whole row 25 pixels wide 25 pixels tall from the very top okay now i'm going to do uh analyzer enabled area dot give me a width of 10 of um 100 give me an x of five so it's not uh right along that edge and then um give me just remove a little bit from the top of this analyzer enabled area so there's a gap between the top of the gui and the top of this rectangle all right now i'm just going to set that to be my analyzer enabled buttons bounds and let me give myself a little bit of a gap between the analyzer button and the analyzer itself and let's see what it looks like bounce.remove from top five okay so we should expect to see a squiggly line just like that all right okay this is neat so whenever we mouse over it it repaints and it produces a new path so let's make the path be a member variable of the class that is computed only once whenever the instance is resized so we know that our random path creation process works which is cool so we're just going to use that to make this path all right let's do that next all right let's add a commit for this analyzer button is visible path is created every time it repaints all right let's head on over to our declaration for that class there was here analyzer button all right so let's set this up with a resized function this is where we will compute the random path that the toggle button will draw so let's see void resized override all right we're going to need those bounding box we're going to need that bounding box auto bounds equals get local bounce we're still going to need to shrink it and then instead of creating a new random path we're just going to clear the existing one let's add that as a member variable juice path random all right so random path dot clear it's gonna clear it and then let's go grab our um other code that drew that thing that's way up here that look and feel stuff where is that this stuff all right let's just copy this comment it out plug an editor paste that right here okay here's our juice random except it needs to be a juice random all right there's our random path start new sub path same line two code that we had before all right let's go back to our plugin editor okay so the stuff we need to discard is the inset rect the random path we can get rid of that and now for this we need to write analyzer button oh boy random path like that okay so we're just going to draw that path member variable directly all right let's run it and see what we get all right cool so it's only changing right now let's open it only changed once when we use the standalone let's open this guy i'm going to run it in audio plug and host and see what happens when we open and close the gui okay so there's like an m right on this right edge let's see what happens when we close this gui all right that's kind of neat so every time we open and close the gui uh we get a new path which is you know it's kind of neat okay so the next thing to do is to make these buttons um actually disable elements in the gui all right when we click on this we want these sliders to stop working when we click on this we don't want to see the fft happen in the background okay we will do those next let's leave this open all right let's get rid of this code and make a commit uh analyzer path button analyzer button path is created only once all right now if we were real sticklers about making it only appear once every time the gui is opened what we could do is store this path um it could become not an audio parameter but it could be stored in the audio parameter value tree state state value tree it could be stored as like just binary data and then that way whenever the plugin is first created you get a customized path and whenever you load that in it just it gets stored with the plugin so that's you know that's a way to make it not have um not be it's random the very first time you open the gui but that's the only time once you um you have to create a new instance of the class or a new instance of the plugin in order to get a new path there but you know this is this is cool all right um let's see what are we going to do we are going to make our buttons actually enable or disable gui parameters next okay head on over to the audio processor editor constructor and we're going to go down to after our look and feel has been set now we are going to use the on click lambdas to change the enablement of the sliders so the reason i'm doing this here is because this is where all of these components can see each other right i'm going to make this button control this button is gonna control this slider and this slider this button is gonna control these three sliders this button is going to control uh the high cut buttons this guy and this guy and then this thing is gonna send a message to this thing to stop drawing um the analyzer okay so that's why we're doing this here instead of like inside um maybe we make some macro component that calls that owns the um the sliders and stuff i'm doing it here because this is where the the most common place this this is the place where all the components can see all the other components so it makes just the communication between them easier now as with all asynchronous callbacks we need to use a safe pointer to make sure that our class in this case the editor is still in existence when we try to use this particular on click lambda all right so let's get started with that auto safe pointer equals juice component safe pointer simple eq audio processor editor this all right now we can start declaring these guys so we'll do we'll start with the peak peak bypass button and this is where it wants a lambda lambda with no arguments and here's where we're going to do the good stuff okay first we have to check if our safe pointer exists so if auto all right if it does once we know it exists we can get the bypass state and set our slider's enablement accordingly so auto bypassed equals comp peak bypass button to get toggle state easy all right now remember if the band is bypassed that means the sliders should not be enabled or said in reverse if the band is not bypassed the sliders should be enabled so comp um peak frequency slider set enabled it should be enabled if we are not bypassed okay let's do it again for the other sliders this is the peak gain and the peak quality all right let's test it before we make the other bypass buttons work all right we did the peak one i'm not seeing it do anything hmm let's go up to our look and feel all right so here's our draw rotary slider what are we not doing uh we are not setting our colors differently if we are enabled or disabled so let's go up and do that next all right we can do that right here auto enabled equals uh slider dot is enabled now we can set these colors accordingly so if we are enabled use this cool color otherwise use um let's go the dark gray that's for the background circle same thing here enabled if it's enabled use that um i guess there's an orangey color it's the border um so we will do colors a different type of gray all right do we have any other colors that are displayed in here looking for set color that's for the text all right let's try that out one more time there it goes awesome okay so i would like the parameter text to also fade out but we can do that after we get these other lambdas set up so we're going to follow the same pattern let's go back down to our constructor we're going to follow the same pattern we're going to capture a safe pointer we're going to check if the component is valid and then if it is we will get the bypass state and then change the enablement of the sliders accordingly so let's do the low cut next look at bypass button.on click all right first make sure the component is valid if it is get the bypass state all right this is the low cut bypass button and then set the um set the low cut frequency slider remember it should be enabled if our button is not bypassed okay and then same thing for the high cut all right let's give that a test and see what's going on see if it's working as expected this is high cut high cut high cut low cut low cut low cut okay all right awesome cool let's add a commit for that oh i forgot to make i forgot to commit these guys all right those let me say um let's see bypass buttons toggle slider enablements that's what happened there and then also um yeah that's all part of that same thing all right our next step is to make the analyzer button toggle the um fft analysis the spectrum analyzer see if that make that do something all right so let's go right here we're going to do analyzer enabled button on click i'm going to capture the same safe pointer if auto comp equals safepointer.getcomponent all right now we need our enabled state all right and now let's call a function that doesn't exist yet um we'll add it in just a second comp response curve component dot toggle analysis enablement uh enable okay let's that's a good name for what this function needs to do all right let's head on over to our um header file uh editor.h and provide that function so we stop having that warning okay that's um where is that here's our response curve component so void bool enabled okay and now um let's see what do we need to do we need to have a flag that it can check so let's put that down here at the bottom should show fft analysis we'll set that to true by default and then uh we'll just do an implementation in class should show fft analysis equals enabled nice and simple all right let's head on over to our plugin editor.cpp head over to the um paint function and uh that's the wrong paint function response curve paint function and if our analyzer is enabled grab those paths and draw them if should show fft analysis do this here's where the paths are drawn put that right in there all right let's test it out oh before we test it out um we should not uh if we are where's our timer callback for this guy all right if our analysis is turned off don't do this stuff all right if we should show the analysis process um yeah the fft guys should the path producers should um produce the path all right now we can go test it all right let's run some audio through our plugin and check out that button all right cool that is working awesome so analyzer enablement button talk is implemented implemented analyzer enablement button i redid that there and did it here cool all right the last tweak that i want to do um let's head on up to the top we're going to head up to our drop rotary slider i had said i wanted that text uh to be um adjusted all right so let's do that right now um yeah okay so right here if we're enabled um use the black background otherwise use a dark gray background and then if we are enabled use white text otherwise use light gray text all right let's see what that looks like hey awesome all right i'm very happy with that okay cool all right let's make a commit of that tweaked uh button text when enabled or disabled all right that is the end of the tutorial i am going to dial in the graphics a little bit more but there you have it that is how to build the simple eq thanks for sticking with me to the end um well we learned how to make this simple threepanned 3band equalizer with fft analyzer if you liked what you experienced here you can check out my course project 11 where you will learn to build the project 11 plugin from scratch i also have a course that teaches c plus from scratch in the context of writing audio software the focus there is on mentorship and not on video tutorials programming is learned by doing not by watching so for that you're going to work your way through 10 10 projects i'm going to review your code every step of the way via pull requests on github and bitbucket because that's what we use in the real world um nine of them are pure cplus plus projects that will teach you the language fundamentals uh the tenth project is a multimeter audio plugin written in juice just like we used here it features level meters histograms go neometers correlation meters buttons and combo boxes threshold sliders saving and loading the plugandstay and a little bit of the dsp basically what you experienced here but with way more visual stuff being built and you aren't watching me build it either okay you are building it on your own i take on the role of your project manager i set up a jira board with all of the instructions because that's how companies manage projects in the real world i assign you issues from that board you tackle them i review your work and either help you when you get stuck or i approve it and assign you something new uh in the end you'll have built the whole plugin from scratch without me writing a single line of code for you you're going to do it all yourself i'm just there when you need help so it's a pretty cool experience i've had a lot of people uh go through it i've had a few people actually manage to land jobs at some pretty big audio company so check out the link in the description or by visiting www.programmingformusicians.com thank you again for tuning in i am chuck i also go by the name matcat music on instagram and youtube good luck on your coding journeys and i will see you in the next project you