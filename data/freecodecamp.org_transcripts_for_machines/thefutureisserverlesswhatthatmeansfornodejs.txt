i'm chris anderson i'm a program manager on the azure functions team um i actually started the functions project about two years ago and it was mainly kind of the background was as i was working on a product that was called web jobs which was for kind of doing background jobs in the cloud and it was mostly just an sdk framework you deployed onto your own you know instances your own vms you had to manage everything yourself and one day we tried to add node.js into it and ended up making it really really hard to manage it actually made it worse but the end product was really really cool in terms of what you wrote and so we discovered if well if we just run this as a service we'll end up with a better product and i'll kind of talk about why we ended up going with node.js as far as how that goes so serverless node.js i choose you there's really i think two kind of big things it also had to do a lot with javascript and then we'll also talk about node.js javascript i like to say is kind of the english of programming languages a lot of people can speak at least a little bit of it even if it's bad right it's not necessarily the perfect language but it's a language which is relatively easy to learn for a lot of people um it might not even be the most widely used language but it's used by a good section of the developer community out there especially in the kind of web application space so it's a very very useful language for us to choose it doesn't require any compilation which means that a lot of the goal that we had was for people to go ahead and get cloud running in the cloud as fast as possible our goal was that you were basically in the editor doing something in like 30 seconds and that you were actually walking away within five minutes having done something and have a service up and running in the cloud that meant that we having compilation having build even having an ide meant slow down to that time and so we really focused on that quick path first since then we've kind of gone back and said okay for people who do want to work in an ide for people who do want to have build and compilation they still can but we started that initial goal of cl of code in the cloud as fast as possible um and then yeah there's just a giant great community of which you guys are all a part of of course which made it easy for everything that we needed to kind of work out of the box or we have available to us and then node.js node.js is a great platform in the case of serverless because it's a very very lightweight framework when you go and just measure how fast it is for node.js to come up and start running for the first time versus how fast it is for say like java or even you know csharp in some cases to come up and run for the first time it's much faster and for the general case and that's really useful because in serverless it's actually not serverless there's servers back there but those servers have to come up basically when your request comes in or when the event shows up you know for asynchronous messages it's not the worst thing in the world if there's like a a second or two or you know a couple seconds of you know latency coming up but a lot of the times people are using these functions in http scenarios in which case any latency of bringing the instance up is impacted by the user that's trying to use that function and we know that in the case of like websites latency as far as like responding to the request can mean lost users and so we know that it's critical for things to come up as fast as possible and node.js is already kind of designed to come up nice and quickly so it was a great platform out of the box there and the other nice thing was that it was very widely used at microsoft we make sure that we kind of reach all developers developers running on windows max linux and linux and node.js was already really really good at running in all those places and so we know that we'd have the best support across all those various places we needed to run so what can serverless do for node.js developers you know we kind of chose node.js to go out with in the first place um because it was very easy for us to get going and we wanted to kind of get started we wanted people to be able to use it easily but for people who are just kind of already using node.js already used to using it why is serverless a useful thing well one of the things that i came across frequently when i was building node.js applications was while going ahead and you know building my server is really easy kind of doing background process of messages can be a little bit less easy to manage and maintain there's a lot less tools out there which understand frameworks for doing background processing and i also have to kind of manage the scale for those background processing it's really easy to scale on like http request messages in a lot of platforms but you know cues and things like that that can be a little bit trickier to get right and so serverless makes it so i can basically go ahead and have a function up and running and it scales dynamically to whatever i need to and since you pay for execution and most serverless frameworks out there you don't really have to ever overpay for your system it also means that things are much lighter endtoend frameworks become a lot less necessary since all i'm really necessarily having to go ahead and push is just a function i'm not having to worry about like having that full stack of things that's going to manage like the various http entry points i'm not having to go through there and worry about a lot of extra code a lot of the times especially if you take advantage and for instance at microsoft we have azure functions where we have actually bindings to various services you never actually have to bring in the sdks to talk to for instance like cosmos db which is a giant you know document based database that we have you can actually use our bindings and just return a json object from the function and it'll get stored to the database for you so you never actually have to deal with working with those sdks it makes it very quick and of course horizontal scaling high scale is easier than ever basically with functions we just keep on throwing new instances at you and you never actually have to see the instance account worry about managing the vms worry about patching things it just keeps on scaling and then as soon as you have no more traffic on your service the vms disappear and you don't really worry about when they're there and when they're not you'll just kind of scale out when you actually have requests when you actually have usage this has turned out to be really useful in a lot of cases one of the first places that someone came up to me and it's like oh yeah azure functions it was really useful because of that whole kind of scaling thing was actually at a conference someone had built the conference app using functions and it was really great because they got a lot of like random requests especially like the week leading up to the conference from the various project managers trying to do the conference and he would just go through there and add a random function to serve that purpose and then after the conference was done he'd have to worry about scaling down the vms or anything like that he just kind of walked away and he left it there in case people wanted to use it randomly and then he didn't get charged anything for those functions running in the meantime so it's very useful for those kinds of use cases um and just to give you a sense before i kind of move on to what can node.js do for serverless i just wanted to give you a simple sense of how this can work here i actually have the functions runtime running locally on my machine this is the simplest kind of demo of hello world so i've got the very classic case here your function in this case let me pull up this one your function in this case is just going to be exporting a function from the module so i've got a context object coming in a request object coming in i can go ahead and do some log statements i'm able to access it we actually purposely made the request object look like a connect or an express object so that way if you wanted to use connector express middleware those things can still work with inside of your function without having to do too many tweaks and then my response here i'm just able to add headers straight to the message do my body here and it just kind of works like normal and so here let's just kind of reset the demo you'll see here in the bottom right that i'll see various um kind of things scroll by here the way that i got this running is i just run funko start you can actually do npm install azure dash functions dash core dash tools dash d and then you'll have functions running on your local machine and you can run funk knit funk new function and then do funko start once you have your project going so that spins up it's listening on 7071 we can see our api hello function that's been hung out there because this function is called hello based off of the folder path and i can go ahead and run and it sees says please pass the name on the correction on the request body if we want to inspect why we got that logic back we can actually go ahead and just hit attach in vs code when you use functions we go ahead and actually drop a vs code file there with the launch.json which is preconfigured to talk to your local functions runtime so there's no setup there to get debugging working it just automatically drops that launch.json file there so now that i'm connected i can go ahead and hit enter again and you see that i've got this breakpoint set up here i can now go ahead and inspect the request object look at the query object and i see that it's actually empty there's nothing on there a query object which is why it's falling into this else statement which is saying please pass the name on the query string or the request body so we can fix that real quick and now when i do that i can go ahead and see the query object now has chris on it and name is now equal to chris and so if i go ahead and continue we now see hello chris with a question mark at the end of it and it's still really fast to develop this i don't need to go ahead and hit funko start every single time that i've got to change to my function i can go ahead and let's get excited rather than kind of asking questions about it hit enter and you can see there i go i got my exclamation mark so the host is sitting there constantly listening to file changes so it's very easy to just write some code change write some code change um the only nice thing with this is it's not just http though i'm using http right now because it works entirely locally and the internet's been kind of like in and out throughout the conference but it can also still listen to all your q services it'll listen to event hubs in fact if you configure it to listen to your production services you'll actually kind of end up with n plus one things because it'll actually collaborate in real time with the cloudbased instances the same way that all the cloud instances themselves collaborate with each other using a storage account with the covers so now i just kind of understand what this you know this is kind of what led us to you see how easy it is to go ahead and write this code if this was you know a language that required building for instance like you know java this would still be relatively easy to be a build step and then i'd have to go and hit run but because i can script it and i can live edit things we get a really nice kind of fast inner loop in terms of developing goes and then i can just deploy it up to the cloud or even do this from the portal itself if the internet was working a bit better so from there let's kind of kind of talk to about the next phase of things in terms of what has been weird about running node.js and serverless together and what can the node.js ecosystem do to think about serverless when you know we're doing the things that our community does um one of the things that i really liked about node.js and javascript was how easy it was for you know new developers kind of walk up and get started with it one of the nice things about node.js and javascript is since there's a lot of client developer clientside developers kind of already knowing javascript already used to how that language works it's very easy for them to walk up to node.js to have them start building their own backends if they needed to do that serverless in some ways kind of has a similar kind of thing about it where serverless is very easy to walk up to and start building a cloud service and get up and running you don't need to worry about setting up a vm and managing it you don't need to worry about antivirus software you don't need to worry about firewalls all that's done for you by the managed service so now those same cloud you know those same developers who might be able to get up that single vm but couldn't really reach scalable systems can now use serverless technology to deploy systems at scale for both you know frontend facing http applications but also backend systems that might have even been farther away from their area of expertise it's a very accessible thing to get up to so because node.js is already kind of the star language of serverless we're going to see serverless as it's becoming more popular bring even more people into the server into the node.js ecosystem but there's a couple of gotchas that those new people coming into the node.js ecosystem are going to have to deal with and some of them is that node.js kind of started ignoring some of the lessons that we learned from the web space and that we got kind of very comfortable with the fact that since these things are going to be long running on servers it doesn't matter if our packages are huge and we load everything in the world and through that process and you know as long as it's not taking up too huge of a memory footprint like who cares how many tiny little files that we have and things along those lines well as i kind of mentioned before about node.js is actually great because for the simple cases it comes up very quickly for the cases where you decide to go ahead and you know import low dash and import every single giant framework that you can think of into memory it takes actually a while to even just read those things from disk and the memory footprint then means that people who are using those libraries inside of functions have to pay more because they have to pay for that memory footprint to actually exist so if you load giant libraries into memory more than ever you're not having to pay for that if i can choose a library which is you know one megabyte versus a library which is you know maybe 30 megabytes that could mean big differences for my end of month bill in the case of serverless and so now as you know any package authors who are listening to this talk or here in the audience it really pays to be thinking about how can we go ahead and reduce what actually gets loaded there's lots of things that can help with this you know if we're now using you know the new kind of uh you know common gs stuff for it it'll only load the parts that it needs to in memory those are really good things i actually wrote a tool that's called azure functions pack which i actually go through there and web pack your code all together it doesn't necessarily do as much to reduce memory footprint for that you'd want to go ahead and run uglify on top of that the result of that web package but it does reduce the load time i actually did a lot of kind of testing of various impacts of i took the four largest node modules i could find i put them into a function and measured it on an i7 with an ssd so very very fast system it still took about two seconds for that function to come up for the first time because i had to start node.js and node.js had to read all that stuff into memory when i web packed it it actually took about 100 milliseconds so it's a giant improvement and when you're running inside a serverless on maybe a little bit more of commodity hardware you're going to be running it's going to take even longer to load those modules into memory so and a lot of the sales providers actually have limits on the amount of content you can actually put up there in the first place in the case of functions we don't actually have any file in the sizes we haven't hit those issues but they have existed in other platforms and so it's important to think as we're writing these packages especially if we want these packages to work instead of serverless um we need to be thinking about what those things are going to do there's actually a couple of examples of this out there in the wild already beyond just like things that i've seen as i've tried to work with customers using functions um like on postgres one of the bigger angular threads there for the the pg module is someone talking about hey this thing started consuming a lot of sockets without me realizing it because my function was kind of coming in there and using it and using it using it and opening up sockets and not closing them and to be fair they were misusing the library they didn't read the documentation properly they weren't kind of using it the way they thought it to but they used it the way that it felt natural to use it inside of their function and so we might want to think of especially for writing a package which we know will be harmful and to use wrong in serverless to include a section about hey if you're trying to use this inside of one of the service platforms like you know here's instructions on how to create a singleton instance of it outside the function so it stays in their memory here's how to write yours through the code for it to go ahead and close its connection before the function's completed and you know some examples can really help a long way with making sure that anyone news coming to this ecosystem from serverless into node.js has a good time because it'll pay to make sure that people are you know successful in that way and then there's one other thing that we should be kind of mindful of is that you know node.js and serverless and javascript has really gotten very far and the community's been doing really well because i think of the strong open source nature of things and how easy it is to get access to the parts the system runs on you know the even the core brains of like you know you know chromium and things like that or open source it's really really great just how fast and how much all of us are empowered to contribute to the platforms that we run on um and since a lot of the service implementations today are very vendor specific there is some risk there so it's something that's worth keeping in mind there's you know people out there that are thinking about problem uh ways to address some of these problems um like service framework is one of those cases there's you know apex which is more of a gobased one from tj a couple different examples um so one of the things that we're trying to do from the function side of things is even though we're a vendor and we are building a specific implementation that's mainly designed to run on azure it is all open source and we are working really hard to try to build it so it is a bit more of a portable system and so we really do want to make sure that you don't really feel like you're necessarily locked in even though it's built to run really well on azure we are trying to make sure that we at least build it in the open source and eventually we can work towards a way where it's even open platform so um with that in mind the future is now i encourage all of you guys who are thinking about trying to deploy services out into the cloud to consider serverless from you know whatever vendor that you feel is good it's all about trying to improve the agility with which we can deploy services and build services which we can trust will operate well at scale um node.js can build more with serverless since you're already in good shape because you know the language of choice on this platform so you're already kind of ahead of the game and i think serverless has taken advantage of the fact that node.js and javascript already had this great big open community and we should try to do our best to encourage that community as node.js you know community members to stay open so um thank you everyone for listening thank you for microsoft for paying for me to come here um and if you ever want to learn more about what i do for my day job check out functionsasher.com or tweet at me with candycodes thanks everyone you