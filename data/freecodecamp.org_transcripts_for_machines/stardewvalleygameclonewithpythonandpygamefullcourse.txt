what better way to improve your python and pygame skills than by building a clone of stardew valley christian from clear code makes amazing python game tutorials and in this course he will teach you how to build a clone of this popular game in this tutorial we will create a stadio valley style game in python and this is going to have a ton of stuff like farming and foraging we can cut down trees and trade items there's also a day and night cycle and different kinds of weather the entire game was also made entirely so you can expand it yourself speaking of i am using the free version of the sproutland asset pack by cup noodle which is amazing there's also a paid version with more stuff if you want to expand the game yourself although for this video you don't need to spend any money before i start i do want to emphasize that this is not a beginner's tutorial to be able to follow you will need to have a good understanding of pygame if you want an introduction or reminder i would recommend my introduction to pygame and my video on using delta time if you have those two you should have a really solid foundation during the video i will also mention a couple of videos that explain some more advanced topics in detail those can be helpful but you are not going to need them to follow along alternatively i also have a paid course where you learn all of my game by making 4 pretty cool games check this one out if you are interested and sorry about the requirements but if i did this tutorial from scratch it would easily be 20 hours long finally the entire project is inside of one folder and i will be working in the code subfolder i will explain while coding when and how to access elements in here i also saved the progress for every chapter and you can find that on github and with all of that i hope you enjoy alrighty so let's get started and i already have a couple of lines of code ready just to get started let's have a look at those here i have my code and i have main.pi and i have settings.pi both already have quite a bit and i am working in main.pi for now if i execute the code with all of this i can see a black window that doesn't do anything right now but we do have a start and all of the stuff in settings we are going to use later but well for now don't worry about it besides these two lines here those determine the width and the height of our window now if you have a very small or very large monitor you could change these numbers to something else whatever is appropriate for you the rest of the game is going to scale with that at least within reason don't make it 5x5 pixels that would be a weird game and i guess really quick let's go over what we have all the way at the top we are importing pie game and cis and settings pie games should be obvious but since we need all the way down here to close the game properly other than that we are not using it after the imports we are creating a class called game inside of that we have an init and a run method most of the game is going to run inside of the run method in here we have the game loop and this one is checking right now if we are closing the game here and then we are getting delta time and we are updating the game besides that in the init method we are creating a display surface we are creating a clock and we are also initiating pygame so all things considered a very simple class and finally all the way at the end we are checking if we are in the main file then we are creating an object from the class and then we are calling the run method and this run method contains the loop that contains our game so with that we have the main setup although there's one more change that i would like to make and that is if i run the game again in the top left we have a window title and right now it says pygame window which doesn't feel good so i want to change that one and this could be a really good exercise for you what i want you guys to do is to change the title of the window and if you want to code along pause the video now and try to figure this one out yourself after we are creating the display surface we have to call pygame dot display dot set underscore caption and in there we can type in the name in my case i want to name the game sprout land after the asset pack although you could name it whatever you want and if you run out of this now you can see in the top left we have sproutland this feels much better although granted a very small change but all right with that we have our setup now if none of the things i've just talked about make any sense check out my introduction to pygame this one is going to explain all of this in much more detail and if you are lost already the rest of the tutorial is just going to get harder so definitely get ready for it now there is one more thing that we do have to start thinking about because later on the game is going to become quite complex and i want to keep the basic main.pie as clean as possible it shouldn't really do too much as a consequence inside of this while loop i want to run another object and this object actually contains the level let me actually implement it and then you see in a second what i mean basically what i want to do is i want to create a new file and this one i want to save as level dot pi for this level i want to import pi game and from settings import everything and this level is going to be a class so class level and this class level is going to have one method that i'm going to call run this one itself and delta time because we need delta time available inside of our game to make everything frame rate independent and inside of this i want to for now just print run game and this is all we need in main.pi i want to from level import level and inside of the init method of the class i want to create an attribute level that is going to be the level and now inside of my run method of the game before i update the display i want self.level.run that way we are always calling this run method here although don't forget this one needs delta time the one we have gotten here if you don't know what delta time is it's a bit more technical but i've made a whole video on it so check this one out you basically are going to need it to follow along for this video so well it is getting quite complex unfortunately there's no way around it if i run all of this now we can see run game in the bottom left so we are continuously updating this method here and this means we can run the entire game inside of it which is helping considerably to keep the entire game clean and organized and for a project of this size this is really important now before i'm finishing this section there are a couple more things that i do want to do first of all when we are creating this class i want to run a dunder init method and in here first of all i want to create another attribute for the display surface in this one i'm getting with pygame.display.get underscore surface this display surface is the same as this self.screen here and this allows the level to draw straight on the main display that we are going to display to the player which makes organizing the entire thing much easier and let me add comments here to make all of this a bit easier to follow let's call it get the display surface now besides that we need sprite groups and for now i just want to create one attribute that i call all sprites and this is going to be pygame.sprite.group groups are a key feature of pygame and they help us to draw and update any kind of sprite in the game and sprites is what you use to basically do anything in pygame so our player is going to be a sprite any kind of tree or plant is going to be a sprite and none of this works without a group in my case what i want to do inside of run i first of all want self.display surface dot fill with a black color so we don't accidentally see the previous frame after that i want self dot all sprites dot raw and in here we need the surface we want to draw on and in my case i want to draw on the display surface meaning this is what we have to pass in here i can just copy it and paste it in here and besides that i also want self dot or sprites dot update now this method we are not going to use for now but later on this is what updates all of the sprites inside of it like the player for example but now back in main.pie i can run all of this and we cannot see any change and that is because we haven't really made any changes to the logic of the game although if you want to see something you could change this black to something like red and now we have a red background although i want to keep this black and there we go so with that we have a basic setup so let's get started with the player now the player is going to become quite complex so i'm going to do all of this over multiple steps but we do have to get started somewhere so let's create a really basic player here we are back in the code and for the player i want to have a separate python file meaning i'm going to create a new one and save it as player.pie just as before we have to import game and also from settings import everything once we have that i want to create a class layer and this one needs to inherit from dot pygame.sprite.spry because it is going to be a sprite in here we need a dunder init method and this one eventually is going to have a lot of parameters although for now all i want is self then i want a position and then i want the group the sprite is supposed to be part of and the first thing we have to do inside of the indent method is called super and dunder init and in here we have to pass in the group that way as soon as we are creating an instance of this class the object is going to be inside of this group which is super handy besides that we will need self dot image this is what the sprite is going to look like and this needs to be some kind of surface now later on we're going to import a lot of surfaces but for now we don't really have that available as a consequence i'm going to create a plane surface and this i get with pygame dot surface this one is going to need a width and a height and the numbers here don't matter since we are going to change them anyway but let me go with 64 by 32 now this image right now is going to be completely black and since we are putting this on another black surface as we can see in the level we are not going to see anything you change that i want to fill the image with a color let's go with green finally we are going to need a self dot rectangle and this one would take care of the position this rectangle we create with self.image.get underscore rect and in here as the argument we have to pass in where we want to place it and i want to place the center of this rectangle wherever the position is and this position we are getting from the parameters with that we have a very simple player spread class now we just have to use it and this is going to happen inside of level in here i want from player import player to keep everything organized inside of the level i want to create a setup method this one itself as always and in here we are going to create an attribute called self dot player and this is going to be an instance of the class player the player we have created here and this player is going to need two arguments the position and the group so let me copy both of them and paste them in here for now the position is going to be completely random but we are going to need a tuple with an x and a y position in my case let's go with 640 and 360 the middle of the screen besides that we need a group and the group here is self dot or sprites a group we have created earlier on and now we're just passing it in here we are nearly done the last thing that we have to do is to actually call the setup method and this happens inside of the init method so in here self.setup and now we should be able to see something so back in main.pi i am going to run my code and we can see we have a green thing although i realized i confused the width and the height so back in my player this should be 32 for the width and 64 for the height that is looking much better so now we can see something but we cannot interact with anything which means inside of the player i want to get some kind of input and don't forget self that one is really important now to get all of the available keys that are being pressed we need pygame dot key dot get underscore rest this one is returning a list with all of the keys that are potentially being pressed and this i want to save in a variable let me call it keys and this list i can access with for example via keys and then square brackets and now pi game has a couple of predefined names for example for the up arrow we need k up and if that is the case for now let me just print up all that is left to do now is to figure out when to call this input method here and for that we will need an update method then itself and delta time how this is going to work is inside of level we have our all spreads group and this all spreads group has a draw and an update method the update method is the really important part right now because this one calls the update method on all of the children meaning effectively what is going to happen is that this update method here calls this update method as a consequence for the level or the group more specifically we have to pass in delta time as well the delta time we get from the parameters here and this delta time we get all the way at the beginning inside of main in just a bit this is actually going to become useful but now inside of the player all we have to do is call self dot input and this should be working so now if i go back to my main.pi run all of this and now if i press up in the bottom left you can see up which means i get some input all we have to do now is to cover the other directions and then we should be good to go and the usual system works like this if we're not pressing up then i want to check if keys and pygame dot k underscore down so we are pressing the down button and if that is the case i want to print down for now and with that we have up and down besides that let me copy all of this i also want to check for right and i want to check for left and then obviously the text has to be right and it should be left and with that if i run main.pi we get left right up and down all of the four directions what we now have to figure out is how to translate all of this into actual movement and for that we need a few more attributes let me put it all the way in the net method with a comment let's call it movement attributes and the ones before let's call them general setup for the movement i want to have first of all self.direction and this is going to be a vector so pygame.math.vector2 and this vector is going to have an x and a y part depending in which way the player should move so for example if x is 1 then the player should move to the right and by default this vector 2 is supposed to be empty so it should have 0 and 0. and this is the default value so i can just leave it like this and all that we are going to do inside of here is change this direction so basically inside of keys for up i want to set self.direction dot y two minus one this i can now copy and do it four down this one is just going to be one for right we are targeting x and this one is going to be positive one and left is going to be x being negative one and with that we have the four different directions although now we do have a problem and let me isolate the vertical directions just to illustrate what the problem here is right now later on we are moving the player in whatever this direction is pointing at so for example if y is negative 1 we want to move up and this is what we are getting in here the problem is in this setup right now once we press up once direction.y is always going to be negative one even if we release the button and this is obviously not great because once you move up once the player never stops moving up which well we have to change this fortunately though is very easy to change because all we have to do is add another else statement and let me copy the direction here because now the direction should be zero which means now if we're pressing up the direction of y is negative one if we are pressing down direction is positive one and if we are pressing neither then direction.y is zero so we're not moving in the vertical axis at all and that is all we need here so i can remove the white space and for the horizontal axis i have to do the same thing so in here self.direction.x is going to be zero and with that we have our basic direction what i can do now at the end of all of this i can print self.direction and now in main.pi if i run all of this and i can have the different directions inside of my vector this is working really well there are two more attributes that we need to make all of this work the first one i always call self.pos and this is also going to be a vector so let me copy this one here and now we have another vector now if you are familiar with pygame you probably always store the position inside of the rectangle however the problem with this approach is that a rectangle always stores the position as an integer but if we want to use delta time so this one here to move everything in a frame rate independent way we are very often getting floating point values which wouldn't work here at all as a consequence i am going to store the position inside of a vector and this is going to be what self.pos is for and this is also what we are going to move and then at the end we are going to update the rectangle depending on where the position is all of that is going to make much more sense later on but for now for the starting position of self.pause i want self.rect.center finally i want self.speed and this is just going to be how fast the player is i put this at 200 but just choose whatever you think looks good and with that i can get rid of this print statement here and add another function or one method and this one is going to be move and here we need self and delta time and essentially what i want to do in here i want to move myself.pause and how i want to move it is by getting myself dot direction multiplied by self dot speed multiplied by delta time and after i have done that i want to set self.direct.center to self.poss and now after the input if i call self.move with deltatime we should be having a moving player so let's try and run main.pi and i can move around this is working really well and this is also frame rate independent and this is why this entire system is really important by using delta time again check out my video on it if you want more detail it does get a bit more technical but if you didn't do this and change the frame rate for example in this self.tick you could set the frame rate for example with 60 or you could set a thousand or you could set 10. with this setup the frame rate doesn't matter but if you didn't do it then the movement would be faster or slower depending on how the frame rate is which would be a massive problem all right in this case we have our basic movement now there's one more important thing that we have to do and that is inside of this move method if i run the code again if i move left and right or up and down i have one speed however if i move in the diagonal direction like this the player moves noticeably faster and that is a problem you can see it pretty well here now why is that happening and let me draw on the screen to explain if the player is only moving in one direction let's say the player is moving to the right like this at a speed of 1. that's not the actual speed but 1 is a very simple number to use and if we only move up we are also going to have a speed of 1. this is what we're getting from direction the problem now is if we're combining these two numbers we are getting a different kind of length so let me rearrange the drawing a tiny bit and let's say i want to move by one unit to the right and by one unit up then the actual distance i am going to move is going to look like this and the distance of this length here is what we are getting from pythagoras theorem it is 1 square plus 1 square and then we are taking the square root of all of this the result in this case would be something like 1.4 and this result means that if we move diagonally the player would move about 40 faster than if we just move left or right or up or down which obviously is going to be a problem so we have to adjust for that and the way you adjust for that is called normalizing a vector and normalizing a vector basically just means that well we're making sure the direction of the vector is always one and this is an inbuilt function into pygame so you don't have to think about it too much all we have to do is get self.direction and we have to assign it to self.direction.normalize don't forget to call it and we are nearly done the last problem we have is that we can only normalize a vector if the vector has a length and this should make sense i guess to illustrate what this one is doing is let's say we have a vector of 1 and 1. what normalize would now do is convert these two numbers so that the vector overall has a length of 1 which in this case would get us the numbers something like 0.7 and 0.7 i can actually demonstrate this a bit better so let me print a vector after we are normalizing it so now i want to print self.direction and run all of this again and we are already getting an error that we cannot normalize a vector with the length of zero and this should make sense for normalized to work pygame needs to know in what direction the vector is pointing but if the vector is 0 and 0 it doesn't point in any direction so normalize wouldn't work but this we can fix quite easily all we have to do is check if the vector has any kind of length and this we get with self dot direction dot magnitude don't forget to call it and if this is greater than zero only then do we want to do all of this and now let's try it again if i move left and right we have a direction of one if i move up and down it is one as well but now if i move diagonally it's 0.7 or negative 0.7 and this is important to keep the speed constant and all right i hope that makes sense there is just one more thing that i want to do before we finish off this part and that is later on i have to work with these two lines more to implement the collision mechanics and for that i have to separate these two lines into the horizontal movement and into the vertical movement so first of all i don't want to update the entire position vector i only want to update for the horizontal part the x dimension so for example instead of updating position by itself i only want to update x and as a consequence we have to update the other vector as well and update the rectangle 2 and this could be a really good exercise for you to finish off this section so if you want to code along pause the video now and try to update the vector and the rectangle and see how far you get for position.x we don't want to get the entire direction vector instead i only want to get x of the direction self.speed and delta time can remain the same then for the rectangle i don't want to set the center i want to set the center x and then this should be self.pos.x and with that we have the horizontal movement now i have to copy all of this give me some white space and paste it in here and now i basically have to switch all of these x's to a y and there we go the result in terms of if i run main.pi again we are not going to see a difference but later on for the collision we do want to have control over the horizontal and the vertical movement individually but this i will talk about in much more detail later on for now we have a pretty solid setup in this section we're going to import the player graphics and there's quite a lot of stuff that we have to import let me actually open the folder here we go and inside of graphics we have the character and then here we have all of the different animations for example down is the down movement and here we have the player walking down and well we have to import all of these different animations now you could do all of this by hand and it would be possible but not really practical because there are way too many animations fortunately you don't have to you can do all of this with python to automate the entire process so let's have a look at all of this here we are back in the code and i want to work inside of the player and let me minimize all of the methods so things are a bit easier to read for the import i want to add another method let's call it import assets this one itself and nothing else and inside of here i basically want to create a dictionary called self dot animations and this dictionary is going to have a ton of key value pairs for example one key would be up and this would be up walking and then the value associated with this key would be a list with a bunch of surfaces that correspond to the up movement now for that i have this is something you do have to copy from the notes this is looking like this here are all of the different states the player could be having we have up down left and right these are the movement ones then we have all of those with idle then with the whole the x and the water these are all of the animations and these also correspond if i open the folder again here we have all of the different states and therefore the name corresponds with the key of this dictionary so we have down here and we have down here this is really important because what this allows us to do is i can do for animation in self dot animations dot ease don't forget to call it and in here first of all i'm going to need a full path and the full path is basically i have to go up one folder then i have to go to graphics and then i have to go to character and don't forget another forward slash and then i have to add the animation because the animation name is also the folder name let me demonstrate what this means here is the file setup again and right now we are working inside of the player and from there we have to go up one folder to the project then we go to graphics then we go to character and now we have to select all of these different folders which is what we're doing with this line here along with the for loop and now essentially all i want to do is get myself.animations dictionary target one of the key value pairs and then i have to actually import all of the surfaces now this i'm going to do in a separate folder that i called import folder and this one is going to need the full path so it knows what to import and this import folder i generally put in a separate file because it's quite a handy one to reuse so let me create a new file that i want to save as support dot pi and in here we need a function called import folder and this one needs a path as a parameter but nothing else and this is what the player so inside of the player i want from support import everything so now we have to create this file here and let me add a bit of white space and now we can work on it first of all i want to create what i always call a surface list and this by default is going to be empty and in here we're going to store all of the surfaces and this is also what we are going to return at the end of this function so now we just have to figure out how to actually access the folder and for that we need a specific module is we have to import but it comes with python we need from os import walk and walk allows you to walk through different folders let me actually demonstrate what it does so for let's call it folder in walk and then we have to pass in the path and that is the path we are getting from the parameters and we're just passing it through and i guess in here let me just print what we get the folder and now since we're calling this inside of the player we just need to make sure inside of the init method all the way at the beginning this is really important i want to self dot import assets and this has to be all the way at the top of the indent method because later on when we create the image we need this self animations dictionary but now if i run out of this we are getting a ton of different things at the bottom and this is what work does it basically returns a list with all of the contents of the folder for example the first folder here is the up folder this one doesn't have any subfolders and inside of this folder we have a couple of files they are always called 0 1 2 and 3. they all have the same name but they are different files and this is what we want to use to import things now keep in mind a really important thing here is that all of these are just names we're not actually importing anything for pygame we are just going through a folder and looking at all of the file names but this is something we can definitely work with now first of all since this walk is returning a couple of things that we don't need we can unpack this quite a bit so the first one we get is the folder name the second thing we get is the always a list of subfolders and the final thing we get is the actual content let's call it image files now folder name and subfolder i just do not care about so i'm going to replace the folder name and the subfolder to underscores that way i indicate that i don't care about them so now let me print the image files and let's run main.pi again and now all i get is a list with names of images and this is what i really care about once i have that i need another for loop because remember image files is another list so i need four let's call it image in img files and now let's keep on printing things if i now print the image and run this again i am always getting the name of the image for each file now this right now is a bit confusing because the name of each individual image is fairly repetitive but these are all different files in different folders so all we have to do now is to convert all of this into a full path so now i have to do three things to finish off this function first of all i need a full path and this full path is going to be the path we already have that's a path to the folder and then we have to attach the name of the image itself after we have that i can create an image surface so this is the inbuilt pie game surface that we actually want to create and once we have that surface i want to get my surface list and append wow that is misspelled i want to append the image surface meaning we have to get the full path and the image surface and this i think could be a really good exercise for you try to combine the path to the folder and the image to get the full path and then for the image surface you have to import pygame and then use the full path to import one specific surface so pause the video now and try to figure this one out yourself ready for default path i want to get the path itself and this is getting me my folder and to that i want to add the image remember the image is just the name of the file not the actual image now this would almost work let me actually comment out these other two lines and let me print the full path you might already guess what the problem with this here is if i run this we have the name of the folder let me do this all the way at the top so up here for example is the name of the folder and then 0.png is the name of the file this is a really good start but we do need a slash to separate the two meaning in here besides the image we have to add e slash and now if i run this again we have the whole path towards this one specific image so i can remove the print statement and now i can actually use this full path to import an image as a surface now for that to work obviously i need pi game and what i want to do in here is pygame.image.load and now i need the full path although important here you also have to add convert alpha that way we are converting this image to something that's easier to work with in pi game as a consequence our code is going to run much faster now i can uncomment the append line and we should be good to go back in my player after i've run this for loop i want to print self dot animations and let's see what we get that is looking pretty good we are getting a dictionary with a key and a ton of surfaces as the values now we don't know what each individual surface looks like but i'm pretty confident that this is going to work all we have to do now if i minimize this method here is when we are creating the image i have to pick one of these surfaces now for that we need a few more attributes to make all of this work efficiently and the way i approach this is i add two more attributes the first is self.status and this could for example be up or it could be down or it could be something like down x if you want the downwards x animation but for now let's keep to down actually down idle is a good one i suppose besides that we need what i call the frame index and this by default is going to be 0. now the frame index is going to make much more sense once we are doing the animations in the next bit for now don't worry too much about it how we are going to use all of this is instead of creating a plain surface i want to get myself dot animations this is a dictionary with key value pairs where each key is going to be accessed via the status meaning inside of this i want to access the key value pairs with self dot status and this list i am accessing with self dot frame index and now i can get rid of the image fill and we should be seeing the player let's try and there we go we have one frame of the player now since we don't have animations yet this doesn't look too impressive but well what you can do now for example this could be down x and let's try this one there we have the first frame of the x animation this could also be let's say left water and then we get this kind of animation here or well it's not an animation it's just a surface but we do have a very good start in this section we're going to animate the player now for that we are going to need quite a bit of logic so let's go through it one by one here we are back in the code and i want to keep on working in the player now for the animations to work there are two things we need first of all inside of the self.animations dictionary we have to go through the list of surfaces because they are the animation and this is actually a fairly simple method this we can start with in just a second the much more complicated bit is getting the self.status so we have to know if the player is moving or idling or using the x or the water or the hoe and this is going to determine what animations we need getting the status is quite a bit more complicated but let's start with the actual animation that one is actually quite simple i first of all have to create another method let's call it animate this one itself and it also needs delta time and basically what i want to do in here i want to get myself dot frame index and increase it in my case i want before multiplied by delta time and then after that i'm going to get myself dot image so what the sprite actually looks like and i set this to self dot animations i get myself dot status and then i get myself dot frame index the way you have to think about it let me open the folder again and let's say for down inside of down we have four different images zero one two and three and we are using self.frame index to go through them so we have first zero then one then two and then three and all i am really doing is i am increasing self.frame index to pick up all of these numbers that's literally all that's happening here however there are two major problems here number one is that we can only ever take the index with an integer but this operation here is going to return a floating point number as a consequence this self.frame index has to be converted to an integer which is very easily done besides that the other problem is that each animation has a finite amount of frames for example down has four frames inside however this line here is going to be very quickly on a higher number than four so we have to make sure that we are always looping through this and this we are doing in an if statement if self dot frame index is greater or equal than the length of self dot animations and in here once again i need self dot status if that is the case i want to set self dot frame index back to zero so what this one does if i open the folder again and let me try to get everything on the screen something like this looks good we are basically starting with self.frame index being zero which is getting us this first image here after that we are increasing the frame index by a certain number and then down here we're getting the integer of that number so at some point this is going to be one this is going to be two and this is going to be three after that we're going to end up with a number larger than 3. so we are going to be somewhere down here which would be causing an error and for that we have this line here this one is making sure that this doesn't happen and instead we're moving back to zero and with that we have proper animations all that's left to do now is to actually call it so inside of update all the way at the end i want self dot animate don't forget to pass in delta time in here and now if i run this now the watering animation isn't great but the animation for down does look much better so there we go this is down movement if i just move down this is already looking pretty good and what i actually want to start with is down idle if i run this now there we go we have the player idling and looking straight at us this is looking really good so this was the easy bit now we have animations the one thing we now have to figure out is how to set this self.status to capture all of the different animation states and there are quite a few different states we have to account for all of these the really easy ones we can get in input because in here if we are for example pressing up we know that the player is moving up which means in this we can set self dot status to something like up then i can copy this and change this to down copy it again and change it to right and copy it one more time and change it to left and with that we already have the walking directions so now if i start all of this i can move left right up and down and we already have some very basic animations that look pretty good really good start besides that let me minimize input i want to check if the player is idling so if we go for example from moving up and we stop moving then i want to switch to up idle which in practice means i have to add underscore idle to the status of the player and to do all of that i want to create another method let's put it below input in here i want to get stat test needs self and nothing else and in here i want to check if the player is not moving then i want to add underscore idle to the status and again if you want to code along this could be a really good exercise for you so try to figure this one out yourself and see how far you get if you want a tip this should be doable in two lines of code first of all we have to figure out if the player is moving or not and this we have actually already done this happened inside of move because we know if self.direction.magnitude so the length of the direction vector if that is zero we are not moving so i can just copy it minimize the move method and now if the magnitude is equal to zero then i know the player is not going to move which is covering the first bit let me put it at the top here besides that i have to add underscore idle to the status which in a very simplified way would just be self.status plus equal underscore idle and don't forget this is supposed to be a string all we are really doing for the status here is we are manipulating different strings to represent the status of the player that's literally all it is now this is a good start but it would cause a problem really really quick let me actually demonstrate so after i'm getting the input and before i am moving or animating i want to get self.get status and now if i run main.pi we're getting an error that we have a key down idle and idle and basically what happened here is that if the player is not moving python keeps on adding underscore idle towards the status we're not stopping at one we're adding more and more and that way we're getting an error so we have to make sure that we only ever have a single underscore idle in the status which we can get very easily all we need is self dot status dot split and i want to split wherever we have an underscore and then pick the index 0. this one here is going to return a list and the first item of this list is always going to be the status so this would be up down left right and so on and only to that i want to add the underscore idle that way we will only ever have a single idle inside of any kind of status and this i want to assign i don't want to add it to the status and now the player is idling and if i move downwards we are walking this also works with up it works with left it works with right and this is looking really good so now we have some basic animations that are definitely improving already so let me get rid of the comments here and we have the first bit covered the other bit we need is the tool use i guess let me add general comments here to make this a bit easier to follow let's call this the movement actually the idle is better now for the tool used the code is getting quite a bit more complex because besides get status we also have to add the input and we have to be able to select different kinds of tools so let's do all of this in a separate section so let's work on the tools for this to work we need a few parts that interconnect quite a bit so well let's jump right in and let's have a look at all of this once again here i have main.pi and i want to keep on working inside of player and specifically i want to work inside of the init method and in here i want to add another section let me call this one tools and for now i want to add one more attribute that i call selected pool and this could for example be an x it could be a hoe or it could be water short for watering can i guess for now let's stick with the x that one is really easy to see and for now we don't have any way in the game to change the tool that's going to be in the next section because i do want to keep things a bit more organized but well now that we have the selected tool i want to go to my input and in here besides the directions let me actually add a comment directions i want to add another section and let me call this one tool use and in here first of all i want to check if we are pressing a certain key which i get with if keys and then pygame dot in my case for the tool i have k space now basically what i want to do in here is if this condition is true i want to run a timer for the tool use so for example if the player is pressing space then we should have half a second of tool use being activated in some sort of timer and if the timer is active inside of get status we are always adding underscore x to the status now for that we need a timer and this is not inbuilt into pygame so we have to make it ourself and this i'm doing in a separate file and this one i want to save as timer dot pi and here as always we have to import pi game after we have that i want to create a class timer and this one needs it under init method in here we need self we need a duration and then we need a function that by default is going to be none the duration should make sense this one is really simple it's just how long the timer is going to be the function is going to be if we want to execute some code once the timer has run out something we are going to see in just a second but for now don't worry too much about it inside of this i want to create some attributes so duration is going to be duration and self dot funk is going to be funk so we're just capturing the parameters besides that i want to have two more i want to have self dot start underscore time this one is zero and then i want to have self dot active and this by default is going to be false and for this timer we have a couple of methods we have activate we have deactivate and we have up date and all three will need self but no other parameter besides that and let me go through how the timer is going to work we always start at some kind of start time 0 by default and this is what we are getting here after we have declared that we will continuously check the time which means we are checking the time here here here here here here and so on continuously throughout and besides that we also have a duration and the duration could for example be let me put it here at 300 milliseconds and now all we are really going to do is we are continuously checking if these red dots are before or after the 300 meaning once that is the case we want to run some code so let's implement that first of all for activate this one is very simple all i want to do in here is if the timer is active i want to set active to true and besides that i also want to set self.starttime to pygame.time.get underscore ticks this is really important because this starting time here doesn't necessarily have to be zero we could very well start a timer at some point in our game so this zero might be something like 1240 which means we started a timer about one second into the game we're doing all of this in milliseconds and if the timer has a duration of 300 then this number here would be 1540. so these numbers are all relative it's really important for all of this to work now besides that if i want to deactivate the timer i want to set self.active to false and just to be sure self.starttime is going to be 0. finally inside of update the actual timer happens and this is some horrible spelling there we go first of all inside of update i want to have my current time and this i get with pygame.time.get underscore ticks the same line we have used up here the difference now is that this update method will be called continuously which means that this program.time.get will always get our current time and basically what i want to check is if my current time minus my self dot start time is greater or equal than self dot do ration for example if my current time is something like 1500 my start time is something like 1000 and my duration is something like 300 then the result here would be 500 is greater or equal than 300 which would be true so our timer should have run out now if that is the case first of all i want to self dot deactivate the timer i want to run all of this here besides that in case we have defined a function we want to run if the timer has run out i want to check if self.func so if a function exists and if that is the case i want to call self.bank and with that we have a timer class that we can use inside of the player now for that first of all we have to import it which we do with from timer import timer and with that covered i want to add another section let me put it before the tools and this i'm going to call timers in here i want to create a dictionary that i call timers in here we have a couple of key value pairs the key is just the name of the timer let's call this one tool use and now i can create a timer and let's say for the tool use i want to have a duration of 350 milliseconds and once this has run out i want to call a function that i called self.use underscore tool really important here you do not want to call this function you just want to pass it into this class and this one doesn't exist right now so we do have to create it let me put it actually right at the top here so things are easier to see so use tool and this one needs self and nothing else now this use tool for now is not going to do anything all i want to do is print let's say self dot selected tool later on this one is going to do quite a bit more but for now i just want to minimize it more importantly for now inside of the input i want to get myself dot timers and in here the tool use timer the one we created just a second ago and this timer i want to activate and now this we can use inside of get status and really all i want to do is if self.timers and tool use if this one is active then for now let me print tool is being used and let's try if this one is working so now if i press space we get tool is being used so something is happening but this is looking weird and it never stops so we do have to make some adjustments here now first of all the one thing i do want to change is the player should not be able to move once we are using a tool which means once this timer is active the player shouldn't be allowed to do anything else and for that i want to indent all of this one level and i want to have an if statement if not self dot timers and tool use if this one is active so only if we are not using a tool the player is allowed to move around and to use a tool we couldn't use a tool if the player is already using a tool that should make sense now besides that i also want to set self.direction to an empty vector so pygame.math.vector2 the reason is think of if the player is moving to the right and then starts using a tool here if we didn't add this line here the player would just keep on moving to the right while using the tool which would be very strange and we wouldn't be able to stop it because remember the player is not allowed any kind of input while we are using a tool so we have to stop the player otherwise we would get some weird results but once we have that inside of get status all i really want to do is update my self.status so that i have a string that could for example be right and x so x is going to be what we are getting from our selected tool could also be whole or could be water but for now i want to keep it with x meaning this is going to work kind of like this line here except now we're adding a different word after the underscore which means this could be a really good exercise for you copy this line here and adapt it so you are incorporating the selected tool let me minimize the input so we can see it a bit better if the timer is active you are supposed to have the status so up left down or right plus an underscore plus the x all right all you have to do is first of all copy this line here or this part of the line so we just have up left down or right by itself and to that i want to add an underscore and then i want to add self dot selected tool and with that we should be good to go let's try this one now and now if i press space we have something so we do have an animation the problem is the animation never stops which i guess is a start but we do have to work on it the main reason why this happens is because we don't actually update these timers what i forgot to do is to call this update method continuously and to do that let's put all of this in a separate method although it's going to be a very short one let's call it update timers this one itself and nothing else as always and then here all i want to do is for timer in self.timers.values because remember we have self.timers as an attribute this one is a dictionary and then the key is the name and the value is the actual timer and this is what we are getting here and all i want to do is call timer.update and now inside of the update method of the player i want self dot update timers and now let's try this again so now we have a animation that is very inconsistent though and the reason why that is happening is let me go back to input here we have to add one more line and that line is going to be self dot frame index is going to be 0. the reason we need that is let's say we have our frame index this could be 0 1 2 or 3. and essentially what we are doing is we always go from one to the other to the other and then we are going back to the start when we are pressing space so this line here we want to play a new animation the problem is frame index doesn't know that so when we start this animation we might already be on frame index being two and as a consequence we are playing not the first frame but we are playing one frame that is already maybe at the end of the animation which would be looking very strange and if we add frame index being 0 this is being fixed we always start the animation from the start so now let's try this again and there we go we have a proper x animation this one looking quite nice what you could also do is replace this x with a hole and now we have the hole and you could also change it with water and if i do that we have the watering can so with that we have our different tools although we are not able to change between different tools and we also can't see which tool is currently being selected i guess let's work on that in the next major part in this part we are going to work on switching between the different tools and since we already have timers there isn't actually that much to do so let's jump right in and let's have a look at all of this back in the code i want to keep on working inside of player.pi and now first of all i want to check if the player is pressing a button to change the tool this happens inside of input in here i want to add another section let's call it change tool and for this one i want to check my keys again and then here pygame dot k underscore q so we are pressing the q button on the keyboard i couldn't really think of a better one if you can't find a better key just go with that if that is the case i want to do something now what that something is going to be is going to be determined inside of the init method so right now the selected tool is always going to be one specific string but i want to make this a bit more flexible and what i want is first of all i want to have an attribute that is called tools and in here we have the whole we have the axe and we have water and besides that i want to have a seat index and this by default is going to be zero and then when we select a tool i am not going to get a string instead i want to have self.tools and then self dot this shouldn't be seed this should be tool index sorry about that so i want self.tool index and right now since our tool index is zero we are picking the first element from this list and what i basically want to do inside of this if statement here is i want to self dot tool index plus equal one and after we have that i want to update myself dot selected tool and this is just going to be self dot tools and then self dot tool index now this is fine in theory but in practice this is going to break let's actually try so may not pi i want to run it and now if i press q we are getting list index is out of range the reason is to us pressing q once might just be pressing q once to pygame it looks like we are pressing q for a certain amount of time and it keeps on adding this one to the tool index continuously i can actually visualize this that is much better than explaining it so if i print the tool index and run this again and if i now press q we are getting one two and three and then we are running out of numbers and i should get rid of the print statement let me look for it really quick let me comment out this print statement here and let me just add a pass in here that way it's a bit easier to see what's going on if i now press q we're getting one two and three and then we're getting an error because we are trying to use these numbers for indexing and this list doesn't have that many indexes as a consequence we are getting an error and the problem is that pygame tries to add more and more numbers the way around that is we need a timer that after every time we are pressing the button we want to wait a couple of milliseconds now fortunately we already have a very good system to work with timers so i want to create another timer and this one i call tool switch and this one is going to be another timer and this one has a duration of 200 milliseconds there's no second argument because we don't really want to call a function after this one is over we just care if this timer is active or not once we have that and not self thought timers and in here i want tool switch dot active the player should only be able to change the tool if we are pressing q and if the tool switch timer is not active inside of the if statement the first thing that we are going to do is self dot timers and tool switch and this timer i want to activate that way we are only ever adding a single number to this tool index and we're not doing it continuously so now let's try this again if i press q we get 1 we get 2 now we get 3 and we're getting an error this error we're getting because even though now i am only adding a single number we can still add as many numbers as we want but what i want to do instead is that if we are exceeding the length of this list i want to set the tool index back to zero so if tool index is greater than length of tools then i want to set the tool index to zero and this could be a really good exercise for you so if you want to code along pause the video now and try to figure this one out yourself this should be doable on a single line of code although two would also be doable alrighty basically all i want to do is i want to set myself dot tool index and now i want to get self.tool index by itself but this only if a certain condition is true and that condition is self dot tool index is smaller than the length of self dot tools and if that is not the case so else i want to set tool index to zero and now let's try this again now i can press q we get 1 2 0 1 2 and so on and i can never go beyond the length of self.tools and now we already have all of the tools because remember we are updating our selected tool and this is what we're using inside of the status so we don't have to make any more changes this is all we need so with that we are able to change our tool it wasn't actually so bad or at least i hope this wasn't too difficult now while we are here we can go in two different directions now we can either work on the overlay or we can work on the seeds now i think it's best to start with the seeds because the seeds work basically in the same way as the tools do and once we have that we can create the entire overlay in one go so let's do the seats right now and this is going to be started inside of the dunder emit method right below tools and here i want to have my seeds and for the seeds i want to have selfdoubt seeds and in here we only have two we have corn and we have tomato then we have self.seed index and this by default is going to be zero and then we have self dot selected underscore seed and this is going to be self dot seed index we are basically doing the same thing we have done for the tools except now we are storing all of this in different attributes which means now the tool use and the change tool are going to be very similar as well we have a seat use and we have a change seat part and those are going to be very similar compared those two as a consequence this could also be a really good challenge so try to copy those two to update the seed if you want to start if the player is pressing ctrl or left control then i want to use a seat and if the player is pressing e then i want to change the seat so pause the video now and see if you can figure this one out and remember here you are going to need some more timers all right let's try it together now first of all i need two more timers because i have a tool use i have a tool switch besides that let me actually duplicate both of those i want to have a seat use and a seat switch and for the seat use i want to have a method called use seat and you could change numbers here i really don't care about it now first of all i have to create another method just like use tool i need use underscore seed needs self and nothing else and for now let me add pass in here then i can minimize the function and now we can work on duplicating these two lines and we are very much duplicating them so let me copy and paste things first of all if keys and now we are checking k underscore and the name for the left control button is l c t r l short for left control if that is the case i want to activate my seed use timer and the other two lines i want to keep as they are after that i want to copy the if statement for change tool and this one is going to be k e and not timer's seat switch if that is the case i want to activate my seat switch timer and now the index here is going to be for the seat so i'm basically replacing tool with seed and that is all we are going to need in here now unfortunately there's no animation for the seed so instead what i want to do is i just want to print let's say for left control use seed and then for change seed i want to print self dot selected seed so we can tell what's going on and now let's try and we're getting an error that i made a typo somewhere so inside of the indent method this method here should be used not used seed so now let's try this again and there we go if i press left ctrl we get use seed and if i press e we get either corn or tomato so this is working really well and with all of that we have a ton of different inputs for the player without too much work actually so let me remove the print statements and now i can minimize the input this one is getting quite chunky okay i'm quite happy with this section so in the next section we are going to work on the overlay so we can tell what's going on in this section we're going to create the overlay which honestly isn't all that difficult all we essentially are going to do is put some images on top of the entire game and then those images are going to change depending on what the player has selected both for the tool and for the seats so let's jump right in once more i have main.pi open and i want to create a new python file that i'm going to save as overlay dot pi in here i want to import pi game and also i need from settings import everything and now i want to create a class called overlay there is no need for inheritance and i do need a dunder init method we need self as always and now we also need the player because the overlay needs to know what the player currently has selected inside of that i want to have a general setup in here we need two things first of all i need self dot display surface that is the same thing we have done inside of the level this way we can draw straight on the display surface and we can keep all of this inside of the overlay class all we need here is pygame dot display dot get underscore surface besides that i want to start a player in an attribute so self dot player is going to be player besides that i need to do some imports because in here i need self.tools and self dot seeds and those are not the same seeds and tools that the player has instead let me rename it actually these are all surfaces more specifically they are dictionaries with key value pairs for example one key for the tools could be x and then the value would be a surface of an x now for that we have to import a couple of images let me show you what we are going to import actually here is the project folder i want to look at graphics and inside there we have overlay inside of that we have x corn ho tomato and water and this is what we want to import now here you could import everything manually but once again that's not really a pleasant way to work in well any programming language so i'm going to use dictionary comprehension how that is going to work for the tool surfaces i want to have a tool and this is going to be the key and then i want to have a surface as the value and this i want to do for tool in layer dot tools which means inside of player i want to look at all of these tools and from this data i want to create a key value pair and the tool can actually remain the same so if we leave it like this the tool or the key would be hoe x or water which is totally fine the one thing we have to change is the surface what i want to do in here is pygame.image.load and inside of that we need an f string now to keep things a bit shorter i want to store the path separately so let me call it path actually let's call it overlay path that makes a bit more sense and all this is is a string we go up one folder we go to graphics and then we go to overlay and don't forget the final forward slash and this i want to use inside of this f string so overlay path after that i want to look at the tool so the tool could either be x whole water or could be one of the seeds and this is also how each of the files here are named so this is very handy finally one important thing don't forget we are looking at png files also really important you want to convert alpha all of this which makes all of this fairly long but very easy to work with and once i have that i can copy the entire thing and paste it in here and all i really have to do is to replace tool with seed make sure you call this player.seats and then this tool should also be seed but other than that we should be good to go let me actually print tool surface and seeds surface just to make sure that this is working oh actually we have to create the object from the class first of all and this happens inside of level so in level i want from overlay import overlay and now when we are creating everything i want to create self dot overlay and this is going to be the overlay class and in here don't forget we have to pass in self dot player now for that to work you have to create this overlay after the setup method because inside of setup we are creating the player and now once we have that let's run main.pi and we are getting an error the name tool surface is not defined let's have a look ah i forgot self here now let's try this again and there we go we're getting dictionaries with key value pairs that all look pretty good well i'm very happy with this so now we have access to the player and we have all of the surfaces that we do need all i have to do now is to create another method and let's call this one display in here we need self and nothing else and now i want to show the tools and i want to show the seats and for this one first of all i need the tool surface because right now we have a dictionary with key value pairs but what we want is one specific surface we have to select one surface from this dictionary and this we get with self dot tools surfaces and what i want to select from here is self dot player dot selected tool remember here the selected tool could either be x it could be whole or could be water and this is also what we're using as a key inside of tool surface and let's actually try so i want to display this tool and this i get with self.displaysurface.lit and here i need a surface which is my tool surface and for now i'm going to place this at position 0 and 0. with that covered i have to make sure i actually call the display method of overlay and this happens after we are drawing all of the sprites you could just run this line all the way at the end of the run method so in here self.overlay.display and now let's try and now in the top left i can see my selected tool and if i change my selected tool this graphic updates as well so this is very nice the problem is it shouldn't be in the top left and for that we have to update these numbers here or to have a bit more control i want to create a tool rectangle and this one we get with tool surface dot get underscore rect and in here since i want the tool to be in the bottom left i want to place the mid bottom and the position here i am storing in my settings because in there i have overlay positions that way it's a bit easier to adjust all of the settings later on there are a lot more similar dictionaries in here as well so these are the numbers i do want to use which is quite simple all i have to do is i have to get my overlay positions let me just double check if i spell this correctly actually let me copy all of this and paste it in here that looks pretty good and in here i want to get my tool and now when i am using the blit method i want to use my tool rectangle for the positioning and now let's run this again and this is looking really good and with that all we have to do now is to copy all of this for the seeds and i think this could be a really good exercise for you basically what you want to do is copy all of this except now it should be for the seeds so pause the video now and if you want to follow along try this one yourself just as before i want to create a seed surface and this i get with self dot seed surfaces and in here self dot player dot selected underscore siege after i have that for the positioning i want to get a seed underscore rectangle and this i get with my seed surface this should not have an s and get underscore rect once again i want to place the mid bottom and the position here i can copy it from the tools i want to get my overlay positions and get the key seat that is going to be this one here finally all i have to do is self dot display surface dot lit and i want to have my seed surface and then my seed rectangle and with that let's run main.pi and we are getting an error that i forgot the square brackets here now let's try this again and there we go now on the bottom left we have the seats and the tools and we can switch between them this is working really well and is surprisingly satisfying all right cool with that we have the overlay that was all that was needed now that we have the player we can start working on the camera and the floor those two kind of have to come together because without the floor we wouldn't see what the camera is doing and without the camera we wouldn't be able to see what the floor is looking like in total and i know i am repeating myself a lot but for the camera there is a whole set of logic i will go over the basics but i have made a whole video on cameras in detail in pygame so check this one out if you want to go into much more detail once again here i have the code and before i do anything else i want to close a couple of files we don't need overlay anymore and we don't need the timer.pi anymore those two are basically finished and well we don't have to worry about them and i do want to keep things a bit more organized besides that the level should be right next to main.pi because those two files are the most important ones and inside level.pi i want to create the camera this is going to be a separate class and let me call it camera group and this one has to inherit from pygame.sprite.group basically what this one is going to do or how this one is going to work instead of putting all of the sprites into a normal pie game group we're going to create a special kind of group and via this group we're going to get the camera for that to work though first of all we have to initiate the group by itself and this one itself and nothing else and in here we need the super dunder init method so that the group works by itself now once we have that i can replace the group we created like an hour ago with the camera group and so far since we have basically created another group there shouldn't be any difference meaning if i run main.pi nothing has changed which is a good start at the very least we didn't break anything but now that we have more control over what the group is doing we can customize this thing quite a bit and one thing you could be doing for example is get self.display surface in here as well with pygame.display.get underscore surface that way this camera group can draw on the display surface straight away which you could use by creating a customize draw method and this one itself and nothing else at least for now now the way a normal group draws is bright so this line here essentially all that it does is it runs a for loop with four sprite in self dot sprites don't forget to call it for some reason this is a method and now in here we are calling the display surface with blit and then we are passing in sprite dot image and sprite dot rect this is basically all that is happening inside of a normal group for the draw method which is also the reason why every sprite always needs an image and a rectangle if you didn't have those you wouldn't be able to draw the sprite so they are mandatory so now that we have a customized draw i can comment out this draw here and instead i want to run self dot all sprites dot customize draw and let's call it actually let me call it custom draw that makes a bit more sense custom draw that is better and now if i run this everything still works just as before there's no difference although now we don't have to pass in the display surface anymore in here which already is a minor improvement although not that much of a difference with that we have a start for the camera logic although we don't have a camera yet but well this method is going to become quite a bit more extensive although right now we have a problem because any kind of camera i would create would be impossible to see because the background is pure black so even if we move left or right you wouldn't be able to see it because it's well all black as a consequence we first of all need some kind of floor so we can see what's going on and for that we have to import the floor now the floor is very simple it is one big image if i open the project folder inside of graphics there we have world and inside of there we have the ground and i guess let me open this one all this is is one big image and you can see here we have for example the trader and we have a whole bunch of objects all the way over here and the rest of the map so all of this stuff here is really empty all of this is going to work in detail i will explain in the next few sections for now just don't worry about them but don't worry i didn't make a mistake all of this is intentional so let me move this away and this image we want to import although for it to work we first of all need another class to actually use it inside of pygame and for that i want to create a new python file that i want to save as let's call it sprites.pi because in here we are going to have more than one and i want to import pygame and from settings import everything and for now we just want to create a very generic class so let me call it generic and this one is going to be sprite so pygame.sprite.sprite in here as always we need the dunder init method this one itself and besides that we need a couple of arguments we first of all need to position after that we need the surface we want to import or we want to use then we want the groups so this is kind of similar to the player where we have a position and a group so where the sprite should start and what group it should be part of however for the generic sprite it needs a surface because we might add different kinds of images in here now first of all on here as always you need the dander indeed method with the groups inside that is missing something that's looking better and now we need self.image and we need self.rect the image is just going to be the surface which means we're taking the surface from the arguments and passing it in here that's all that's going to happen and for the rectangle we get self.image dot get underscore rect and now we're placing the top left wherever the position is the position we are again getting from the arguments and passing it in here now we just have to figure out how to use it and this i am going to do inside of a level which means first of all i need from sprites import generic and now inside of setup i have to import it by using this generic class i want to create an instance of the generic class and now i need the different arguments for the various parameters let me copy them and paste them in here and let me use named arguments so this is a bit easier to see the position is super easy it's just going to be 0 and 0. or the this is terrible formatting let me clean this up a tiny bit for the surface all we have to do is to import pygame dot image and load and now we need the file path which is one folder up then we go into graphics then we go into world and then we get ground dot png as always don't forget to call convert alpha on all of this finally we need the groups and this one is easy just like for the player we need self dot all sprites this one should be working already so let me try and there we go now we can see the background and now we need the camera to see the rest of the level so right now we can only ever see the top left of the map which wouldn't be helpful but this is already looking much better however before we can do that there's one major problem right now the floor is only behind the player because we are creating it before we are creating the player which means if i created the player before this generic class and run this again we wouldn't be able to see the player because the player is behind the ground which is not well good at all and this leads us to one of the 3d effects we need for the game if you look at settings we have what is called layers all of this and this i want to use to draw the different elements of the map most of the game is going to happen inside of main in here for example we have the player all of the plants and the trees and stuff like that and the ground should be all the way here what we are essentially going to do inside of this custom draw method we are going to cycle through this list and then draw things one by one meaning the water will be drawn first then the ground then the soil then the soil water and so on and the rain drops all the way at the end that way we get a threedimensional effect where different things are on top of other things there's actually going to be a second threedimensional effect but that's going to come later i don't want to overwhelm you guys now for all of this to work we first of all have to assign each sprite one of these layers which means right now the sprites need one layer and the player is going to need a layer and let me get started for the player right below the rectangle i want to assign what i called z and z is just going to be layers so the dictionary from settings and the player should be on main so i can just copy it and paste it in here and now the player has a z position this means that inside of the game every single sprite has an x position we have a y position and besides that we are going to have a z position x and y are always going to come from the rectangle here and z is going to be a separate variable but both of those work very closely together now besides that for the sprites we also have to determine what the z position is going to be and this might potentially change as a consequence i want to have z as a parameter although here i do want to have a default parameter where if we don't get an argument z should be on the main layer and don't forget to turn the parameter into an attribute so self.z is going to be z now that being said for the ground so the ground we are creating here the floor is not supposed to be on the main layer instead it is supposed to be so z is supposed to be in layers and this key here is called ground let me copy it and paste it in here now we have a z position we just have to figure out how to actually use it this is going to happen in here and this i believe could be a really good challenge for you so try to use this dictionary here and draw elements by the order inside of this layer's dictionary meaning the higher the number is the later it should be drawn if you want a quick tip this should be a for loop but pause the video now and try to figure this one out let's see if we can do it the way this is going to work first of all we have to cycle through the layers dictionary let's call it for layer in layers dot values we don't actually care about the keys they just don't matter and all of the drawing is going to happen inside of this for loop and all i really want to do is i only want to draw a sprite so after going through all of the sprites i want to check if sprite dot z is actually the same as the layer the layer being one of the values of the layer's dictionary and only if that is the case i want to draw this layer and that should be it let's try and now i can see my player again even though the player is being created before we are creating the floor which means this logic here is working just fine cool so with that we actually already have some sort of camera but not a real camera yet let's actually work on it properly now so for the camera and once again check out my dedicated video on camera logic this one is really important to understand but first of all what we need here is we have to create some kind of offset and this is going to be a vector so pygame.math.vector2 and how this is going to work think of this one here is the player and everything else so all of this stuff here is going to be the rest of the map and how the camera is going to work is if the player is moving to the right we are going to shift the entire map to the left now when i say shifty and time up to the left i don't mean to actually move it instead we are going to draw it in a different position the actual position doesn't change which means in practice when we are doing display surface dot blit spreader image is going to stay exactly the same which means in practice when we are calling thisdisplaysurface.blit this one doesn't change the position it just draws a sprite in a certain position wherever this rectangle is going to be but this rectangle you can move around perfectly fine and the way i want it to work is by making it relative to the player and for that first of all when i do custom draw i want to look at the player because this is what the camera should be following and now i want to have my offset dot x and i also want to do this for y and the logic here let me do it for x and y together because it's going to be fairly similar i want to look at my player.rect.center and for x is going to be x and for y it's going to be center y so right now i am getting the position of the player and from that i want to subtract this green and then for x this is going to be the width and for y this is going to be the height divided by 2 for both what that basically means is the offset is going to be by how much we are going to shift every single sprite relative to the player and we have to figure out by how much we want to move them and this logic here ensures that the player is always in the center of the camera if this one here is the player we always want to have an offset that points at the top left of the window which means we want to go half the screen width to the left and half the screen width up and then we're ending up on the point up here this is what we have to use to draw everything now for that first of all i want to create an offset rectangle and this we get with sprite dot image dot get underscore rect and this we get with sprite dot rect dot copy and this offset rectangle i actually want to offset so i want to get the offset rectangle again and now i want to move the center by minus equal the offset and this offside rectangle is what i'm going to use to draw the image and now there's one more thing we need and that is what i'm calling custom draw i have to insert the player fortunately we do have the player inside of self.player so let me pass it in here and now let's run all of this and now if i move around we have a camera and this is feeling pretty good we are definitely making progress although a lot of stuff is missing right now and this tends to look a bit weird but well we're getting there and i am fully aware that i didn't really go into detail for this entire logic so i hope you could kind of follow along but if you check out my videos on cameras this is explaining all of this in so much more detail so check this one out if you are interested the logic here unfortunately gets quite complex and i don't want this video to be 20 hours long but alright let me remove some white space and then we are basically done for this part in this part we are going to import all of the other elements and we are going to fake 3d a tiny bit more and i guess let's go for this one by one and let's start by importing all of the elements we have already done this to an extent but well now we have to do more of that now there is a tiny bit of theory that i do have to cover and that is that the entire game was designed entirely which is a free program that you can use to design levels it's really powerful and i am using another module called pytmx to import all of this data now let me go through what all of this means by looking at tiled here we go this is all of tiled so in here i could for example move things around and design the level to look slightly different and doing all of this took quite some time there's a ton of things in here so if you look on the top left there are a ton of layers that you could be working with and well all of this is very complex and once again i have made a complete video on all of this so if you want to have a ton of detail check that one out i just don't have the time for this video to go over titled separately all i am going to do is import all of this data into pygame so let's do all of that once more here i have my python setup and i want to continue working inside of level and let me minimize all of the methods so this is a bit easier to see and i can minimize the camera group now first of all i have to import pi tmx this happens with from pi tmx dot util underscore pygame i have to import load underscore pi game and really important here pitmx you have to install separately it does not come with python so either in the powershell or on the terminal type pip install pi tmx or pip3 install pi tmx depending on mac or windows now this i want to use inside of the setup method and in here let me add a bit of white space first of all we have to load a file if i open the project inside of data we have map.tmx this is what i want to import all of the data is in here and this i am loading with load pi game and in here i need the path to this file i have to go one folder up then i have to go to data and in there we have map dot tmx and now we have to import a ton of different things so let's start by building the house i think this is quite good to illustrate how this is going to work now the house if i go back to tiled the house consists of a couple of different layers let me go through them one by one so if i hide all of them and zoom in let me hide all of this as well we have a house floor then we have house walls then we have the furniture at the bottom and then we have the furniture at the top and all of these layers we have to import separately and really important all of these have to be on a different layer inside of pygame which means back in pygame or the house we have a couple of different layers most importantly house bottom is going to be for the bottom and the rest of the house is going to be in main and this is really important so let's go through it one by one first of all to access the data i need to store all of this inside of a variable let me call it tmx underscore data and now i can use it and this has a ton of methods that we could be accessing the one i want to use now is called tmx data dot get underscore layer underscore by underscore name and now we need a name of a layer the one we could be using in here for example is house furniture bottom and this if i look at tiled is this name here house furniture bottom and what i want to do is to add tiles after this that way i am getting all of the tiles inside of this layer and i can use them inside of a for loop and what i'm getting here let me add the for loop first so this for loop is going to return a list that i can unpack right away and the list consists of x y and a surface really quick back in tiled when i'm only looking at the house furniture bottom and let me hide everything else and this is in house decoration there we go in this we have a couple of different tiles and each tiles is one of these well little cells inside of a grid i just want to import this carpet thingy and this other carpet thingy here this is all i really want and each of those is going to have an x position a y position and then what you see is the surface this is what we are importing which means i already have a class to capture all of this data that is my generic class and in here i need a position i need a surface and i need my groups oh and also i need the z position first of all for the position you might be tempted to just add x and y in here but that wouldn't be a good idea because this x and y position is not a pixel position instead if i return to tiled and zoom out a bit there you go the position we are looking at is the x and y position on this grid so for example all the way in the top left this cell here has the grid position zero and zero and the one to the right of it so this one here is going to have one and zero but all of these tiles have a size of 64 by 64. so the actual starting position of this cell here is not going to be 1 and 0 it is going to be 64 and 0. we are essentially multiplying the position by 64 or rather the size of the tile and this position we have available in pie game as well it is inside of settings all the way at the top we have the tile size all i have to do is to multiply x and y by the tile size now the surface we already have it is just a surface we are importing up here then we need the groups and this one is also fairly easy because all we need in here is self dot or sprites and for z i want to have my layers and the house furniture bottom should be inside of the layer house bottom this one here let me copy it and paste it in here and this should be all we need there we go this should already be working now let's try and i do have to walk down a tiny bit because the house is somewhere down here there we go there we have a carpet and it is below the player because of the layers that is a really good start now there's a bit more stuff that i want to put on this layer and as a consequence i'm going to wrap this for loop inside of another for loop and what i want to do is four layer in the list in here i have house floor and then i have the house furniture bottom and now for x and y and surface is going to be for the layer this way i am using the same for loop for the house floor layer and for the house furniture bottom layer now if i try this we are getting an error because i forgot the colon so now let's try this and if i now walk down i should be seeing the house floor and the carpet this is looking pretty good although in here the one limitation is that this house floor has to come before the house furniture bottom this house furniture bottom is only drawn on top of the house floor because it's being created afterwards if we reverse the order here let me add it like this then you would not be able to see the house furniture bottom let me try it now and you can see you well cannot see the carpet but we only have two elements here so this isn't really that much of an issue this works just fine as it is with that we have two layers out of quite a few now this entire thing i now want to copy because there are two more layers that work in kind of the same way we have the house walls and we have the house furniture top those are going to work in basically the same way for this line and this line the one difference is that those two should be on the main layer and now let me try if i now walk to the house always takes a second yeah you can see the entire house right now it is always below the player but this we are going to change very soon but well we have a house admittedly this setup here could be a bit more elegant but i don't want to add too many for loops but you could totally do it if you want to there's quite a bit of repetition in these lines here alright there is one more thing that we do need and that is the fence let me illustrate this entitled he is entitled and right now everything is hidden so let me make most of the stuff visible so we can see what's going on the fence i'm talking about is this fence here this is what i want to import now and this is going to work very similar compared to the house which means this could be a really good exercise for you i want you guys to cycle through the layer is called fence cycle through this layer and import the surface with the x and the y position using the generic class and this should be inside of its own for loop so possibly now and try to figure this one out we need for x y and the surface in tmm x underscore data dot get layer by name and the layer we want to look at is called fence and here don't forget we need tiles once we have that we need the generic class and in here we need a position we need a surface we need a group and we need a layer or rather a z position the position is super easy this is the one we have already done multiple times let me just copy it from the house so position this one and surface we also already have now for the groups for now we only have a single spread group so self.all sprites is going to remain the same finally for z i do want the fence to be on the main layer and since that is the default parameter i can just leave it as it is as a matter of fact or this line here i could actually remove layers dot main because this is what we get anyway let's do it like this and now let's try and there we can see the fence this is looking very nice righty there are three more things that we do have to import we have the water we have the trees and we have some wild flowers and all three of those are going to be their own class because they are all slightly different so let's create some more classes this is all going to happen inside of sprite first of all i want to create a class called water and this is also going to be a sprite but the sprite we are getting from generic which means water is going to inherit from generic and since generic is a sprite water is also going to be a sprite and in here as always we need it under init method and this one needs self it needs a position it needs frames not a surface we need groups and we need z the major thing about the water is that the water is going to be animated and this means we kind of need the same setup for the animation that we have seen for the player it's inside of animate basically this kind of setup here so we need a couple of frames like we've seen in here and then we need an entire method to loop over all of these frames and the frames are going to be stored inside of the method frames let me add a comment here and let's call this animation setup in here we first of all need an attribute with frames and this is just going to be frames what we are getting from the parameters then we need self dot frame underscore index this is zero by default and once we have that we can start with the sprite setup and in here all we need is this super dunder init method and for this one we need the init method of the generic class all of these parameters here position is what we are getting from the position from the water and let me use named arguments here that is a bit easier to follow i think for the surface i want to get myself dot frames and then here self dot frame underscore index and this should probably be on multiple lines otherwise it's kind of hard to read for the groups all i want is the groups i am getting from the parameters of the water class and finally for z all we need here is inside of settings we have water this is what i want to pass inside of the z argument here and this doesn't animate yet but we do need a few more things so back a level let's start creating this thing and first of all as always i need this kind of line here so let me just copy it the name of the layer we need here is called water and what i want to do is to create a water tile although right now we don't have water available inside of level meaning besides generic i want to import water for this one we need all of these parameters position is going to remain basically the same i can just copy things and paste them in here the other easy one is the groups because once again we only have a single group so far so this is always going to be all sprites the problem we have is we need the water frames which if you open the project folder again are inside of graphics and in there we have water and we have four different frames and these we want to animate but for that we have to import all of them fortunately we already have a function that imports an entire folder and converts it into surfaces the same thing we have used for the player so we can reuse all of this for that to work though we first have to make it available inside of level.pi which means from support i want to import everything and now i can use import folder and for the water i want to have some water frames and this is going to be input folder and the file path we need here is one fold up then we have graphics and then we have water and these water frames we want to use in here and now let's see if this is going to work already so if i move over this side there is going to be some water this is looking really good and if i move further down we should be able to see some more water there we go so now we have water except it's all static so now we have to animate it that is going to happen inside of sprites and in here i want to create an animate function or well method in itself and delta time i think we could do another really good exercise so like for the player we have to create an animate function so try to create this one for the water basically what you have to do is copy the thing you have seen for the player and then make sure you're actually calling it so try this one yourself and see if you can figure it out i think a really good way here is to look at both of the files next to each other it's a bit hard to see but i hope you get the idea we are basically going to copy all of this so first of all we need self dot frame index and we want to increase this by a certain number for the water i went with 5 and multiply this by delta time but this 5 here is entirely subjective play around with this after that i want to check if myself dot frame index is greater or equal than the length of self dot frames if that is the case i want to set self dot frame index to zero finally i want to update self dot image and this is going to be self dot frames and in here don't forget we need an integer of self dot frame index and that is all we need all we have to do now is to figure out when to call this animate method and this we are doing inside of the update method in here we need self and delta time and all i really have to do in here is call self dot animate and pass in delta time technically you could just add all of these lines here and paste them inside of the update method it would work perfectly fine but i think this is a bit more organized it well it's entirely up to you but now we should be having animated water let's try and let's walk to the water and there we go we have animated water this is looking quite nice so i can minimize the water and now we can work on the next kind of sprite i guess a really easy one would be the class wild laurer and this one like the water has to inherit from generic and in here we need a dunder init method and this one needs self it needs a position it needs a surface and we need the groups and after that we need a super and a dunder init method and once again we need these three parameters we don't need z because all of the wildflowers are supposed to be on the main layer and the wildflowers for now are going to stay just like that we're not going to make any more changes although later on they are going to change a tiny bit which is why we need a separate class but now that we have them inside of level.pi i want to import the wild flower and this one if i copy these two lines here i want to look at the layer called decoration let's have a look at tiled how this looks the layer i am looking at is this one here decoration and in there if i hide and unhide it it's all of these small elements inside of the foresty area and these i want to import now there if you look at the layers in the top right these are slightly different compared to the tile layers we have already seen basically these are objects and this we can move around easily whereas these with the square icon are all tiles but again check out my original video it explains all of this in much more detail the difference honestly isn't that bad i shouldn't have actually copied this line instead what i should have been doing is for obj in tmx data dot get layer by name and the layer we are looking at is called decoration this one doesn't change and now in here we are getting an obj and this obj has an x it has a y and it has an image and this one is the surface so this is what we are going to use and now i want to create a wild flower and in here let me copy the parameters we need we need a position we need a surface and we need the groups for the position we need obj.x and obj.y and those are actual pixel positions so we don't have to multiply them with anything for the surface we need obj dot image and for the groups once again we need self dot all sprites let's run this again and now we can see a whole lot more stuff on the map this is already starting to look much better finally we are going to need some trees so i'm going to create a class called tree this one is also going to inherit from generic and in here we need a dunder init method with self we need a position we need a surface we need the groups and besides that i also want to have a name of the tree why that name is going to matter let me visualize all of this entirely inside of tiled here you can see all of the trees and they all have a name the name you can see here so a tree could be called small or large and this is what i want to use for the name that way i can tell if a tree is going to be small or large that's basically all it is although later on this is also going to determine where the apples are going to be on the tree for example for a larger tree we would have this entire surface to place apples or a small tree we would only have this surface here and inside of here i want to have a super dunder init method and this one is going to need a position a surface and the groups all of these we are getting from the parameters so we can just leave it as it is although later on the trees are going to become quite substantially more extensive but for now all we have to do is or obj in tmx data.get layer by name and the layer i am looking for is called trees and in here i want to create a tree although first of all i do have to import it with three and the arguments we need let me copy the parameters the position we can just copy from the wildflowers this one here so position is covered the surface is going to be obj.image for the groups once again we have self dot all sprites and for the name this one we get with obj.name and now if we run this here you can see a huge amount of trees and this is looking really nice so the entire thing is definitely coming together so there's only one more thing that i do want to cover although for that we need a tiny bit of theory let's talk about it i want the various elements to overlap at the very least the elements inside of the main layer so for example if the player is behind in the yaxis it should be drawn below the other elements for example if we have the player here and the player is behind a sunflower the player should be behind the sunflower or rather below the sunflower and if the player is in front and the y axis the player should be drawn in front of the other elements so if the player is in front of it it should be drawn on top of the sunflower and this effect is really nice in the game it makes it look much better it's also very easy to implement so let's jump right in back in the code i want to minimize the setup method and i want to work inside of the camera group i have to work inside of all of this and this line here in particular is really important because right now we are just drawing or well cycling through all of the sprites and this i want to sort and the way i want to sort it let's say we have two elements like this i want to sort them by the white position which means the further down the center of a sprite is the later it should be drawn in this case this right here should be drawn first and this sprite should be drawn after that that way this sprite here is always on top of this other sprite and since this is going to happen on every single frame of the game this can also change to get all of this we need a key for this sorted function this always has to be a lambda function and into this lambda function i want to pass in this sprite what i want to look at from the sprite is sprite.rect.center y that is literally all i needed so now if i run out of this again you can already see it with the fence but it's kind of weird but the sunflowers make it look much nicer so now the player can walk through all of this and it's looking significantly better so this is really really nice and that way the game feels much more threedimensional it also works with the house let me walk there so for example here we can walk through all of this and well this is very very nice cool this was a very large section but we basically imported the entire game so massive progress with the level and the player in place we can work on the collisions and let me cover a tiny bit of theory how the collisions are going to work first because that can be kind of confusing let's say we have an object here and we have the player moving in some kind of direction and we want to check if the player is colliding with this obstacle what we are going to do for that is we are first going to check if the player is overlapping with the obstacle for example the player could be here and we have an overlap detecting this is really easy the difficult bit is to figure out where the collision came from in this case it might look like the collision came from this side but it might have happened that the player was moving really fast in this direction for example or the player could have come down this side here as a consequence we're going to add a bit more code to figure out where the player came from in this case since the only object that can move is the player we can check the player direction so for example if the player was moving in let's say this direction here we know the collision must have happened on this side because the player was moving in this direction and once we have that bit of information let me clean this up a tiny bit if we know that the player moved in this direction and our collision happened here then we want to move the player back to something like this and then we have the entire collision logic it honestly isn't that bad but you do need some theory here and one more time i made a whole separate video on it so check this one out if you are interested but other than that let's implement all of this alrighty here i'm back in the code and i want to do a couple of things first before we start with the collision logic the most important part is that all of the sprites let me minimize them there we go all of the sprites and the player are going to need a hitbox or some kind of collision rectangle we could be using the rectangle itself but that would not be a good idea for two reasons actually first of all for the player the rectangle is going to be really large if i open the project folder inside of graphics and let's look at the character for something like left x in here if i open this okay it's going to be very hard to see but if i zoom in you can kind of see by the shade this entire surface here has a size of this this is the entire image and the rectangle we are creating from this has the same dimensions and this is much larger than the actual image the reason why it is so large is because we have to capture the entire image and the bunny has to be in the middle if that wasn't the case the character would move around if the size changed so all of these surfaces have the same size and that is really important because of that we couldn't use the rectangle but what we can do is create self dot hitbox and this hitbox is what we actually use for the collisions and for this one all i want to do is self door direct dot copy so we are copying the rectangle and this i want to inflate all that inflate is doing is it takes a rectangle and it changes the dimension while keeping it centered around the well center as an argument here we need a tuple with a width and a height by how much we want to shrink or increase it in my case i want to shrink it by 126 pixels on the horizontal axis and negative 70 pixels on the vertical axis next up this hitbox has to be moved along with the rectangle and this is going to happen inside of the move method so in here what i usually do is after i've moved the position i am moving the hitbox so self.hit that is terrible spelling self dot hitbox dot center x is going to be self.pos.x and then self.rect.centerx is going to be self.hitbox.centerx although in here i actually realized i forgot one important thing and that is that this self deposited x needs to be rounded if we didn't include that pygame would truncate these values which means a 1.9 for example would be truncated to one whereas the proper value would be a two and this is what we get by rounding which is why we need the rounding here if you don't do that you are going to get occasionally wrong behavior or well incorrect behavior but all right now that we have that i have to do the same thing for the vertical movement so self.hitbox.center y is going to be rounded self dot pos dot y and now self.record center y is going to be self.hitbox.center y with that we have a hitbox for the player and now all of the sprites are going to need a hitbox as well let's start with generic and in here i just want to create a hitbox with self.rect.copy and this i want to inflate and the number here i want to be a bit more flexible so for the wife i went with negative self.rect.with and multiply this by 0.2 then i'm going to copy all of this and then for the height this is going to be self.rect.height multiplied by negative 0.75 the numbers here you definitely just want to play around with it is fairly subjective it really depends how you want this to look mostly for the width you want to have a fairly small number because you don't want to shrink it too much on the horizontal axis for the vertical axis you do actually want quite a large number and this again is because of the overlap let me show the slide again actually the overlap for all of this works really well because when we created this there was no collision but once we have collision we really have to be aware that this rectangle here shouldn't be too tall because if the sunflower would have a collision rectangle that covers the entire height the main character would never be able to go behind it we would always get stuck on top as a consequence you do want quite a high negative number for the vertical axes all right with that let me minimize the generic class so we have a lot of space water doesn't need any hitbox because it cannot be collided with and next up we need the wildflower and this is now the reason why this is a separate class because in here i want to have a hitbox and this is going to be self dot rect dot let me copy it and then i want to inflate the entire thing and i want to inflate this by static numbers for the horizontal axis which is negative 20 and for the height i want to go with negative self.rect.height and this i want to multiply with 0.9 finally we have the tree although in here we don't actually have to make too many changes because the tree can take the hitbox from the generic class so this hitbox is still going to apply inheritance here makes our life a lot easier that covers a lot of the setup there's one more thing that we need back in level inside of the init method i need another group the group i want to create is called self dot collision sprites and this is going to be a plain pie game.sprite.group the only reason i'm going to create this group is because i have to keep track of what sprites can be collided with so any sprite the player can collide with is going to be inside of this group and inside of this group that way i can identify them easily which makes my life a lot easier and now when we are creating all of the collidable sprites that is going to be for example defense we can collide with so in here self. all sprites i want to put in a list and besides that self.collision sprites the same is also going to apply to the trees and to the decoration so let me target both and all sprites should be in a list along with self.collision sprites you might be wondering if house walls and house furniture top also need collision sprites the answer is not really but i'm going to cover that in just a bit but that's going to come in just a bit the one thing we need now is that the player needs to know where all of the collision sprites are because we are going to run the collision method inside of the player which means i want to pass self.collisions sprites into the player i do want to mention here for the player the player sprite is inside of all sprites and then besides that the player is going to have a separate parameter for the collision sprites but the player sprite itself is not inside of the collision sprite we just have a reference to it whereas the decorations are both in all sprites and in the collision sprites this is a fundamentally different concept here so i hope you get the difference but now to make all of this work inside of player the player is going to need one more parameter and let's call this the collision sprites and this we have to capture let me put it below the movement attributes in here we have collision and i want to get myself dot collision sprites as an attribute and i guess to keep things organized i could put the hitbox in here as well it does seem to make sense and now i can minimize the indent method and now inside of the move method we can work with the collisions or more specifically i want to create a separate method that i'm going to call collide actually i guess collision makes a bit more sense it doesn't really matter and in here i need self and i need the direction first of all in here i want to look at every single sprite inside of the collision sprites so for sprite in self dot collision sprites dot sprites in here i want to check has attribute if this sprite i am looking at has an attribute called hitbox they should all do but this is a good way to make sure and that we just skip any kind of collision if that isn't the case it well makes our life a bit easier now once i have that i want to check if there's any kind of overlap and this i get with sprite dot hitbox dot polite rect and now i want to check with self dot hitbox if that is the case we know there is going to be some kind of overlap the problem is we don't know where the overlap came from this is why i talked just a second ago so here we have an obstacle and the player might be somewhere here we know the overlap is here the problem is we don't know where the player came from the player could have come from here the player could have come from here the player could have even come from here and moved really fast meaning we have to figure out where this came from and the best way to think about this is first of all you want to separate the dimensions so we first have let me call it we first have horizontal and after we have done that we are doing vertical this is also the reason why down here we split the movement into horizontal and vertical movement in here the logic gets much easier we still have an obstacle and now the player overlaps again something like this but now we only have to check if the collision happened on the left or on the right now it's still perfectly possible that the player came this way here and moved really fast so i want to check the direction of the player meaning if the player was moving to the right i know that the collision must have happened on the left because if the player is moving to the right any kind of collision has to happen on the left of the obstacle meaning this side here and this is what we have to implement now first of all i want to check the direction and if this is horizontal then i want to check the player direction so if self.direction.x is greater than zero if that is the case we are moving right or the player is moving right as a consequence if there is a collision then i want to set self.hitbox.write is going to be sprite.hitbox.left and besides that if self.direction.x is smaller than zero this means we are moving left then self.hitbox.left is going to be sprite dot hitbox dot right there are two more things we need in here and that is we have to update self.rect.centerx so the rectangle the player actually sees because right now we are just updating the hitbox we're not updating the rectangle itself so where the player appears on the screen and this should be whereself.hitbox.centeraxis finally for the movement we have to update self.post.x and this i also want to set wereself.hitbox.centerxis and this is the entire logic for the horizontal collisions all i have to do now is after we have done all of the movement for the horizontal movement then i want to call self dot collision like this and pass in horizontal in here and now this should be working let's try if i now okay this is getting a bit weird because we spawned on something but if i just move left and right we definitely have some collisions now if i move up and down this doesn't work at all but just by itself this is looking pretty good which means all we have to do now is to also check if direction is equal to vertical let me add a bit of white space here and this is going to be your exercise basically what i want you guys to do is to copy the logic here and apply it on the vertical axis so pause the video now and see if we can figure this one out first of all i want to check if self.direction.y is greater than zero if that is the case i know i am moving down which means i want to set self.hitbox.bottom to sprite.hitbox.top i guess let me draw what this means this line here means we are checking if the player is moving down so the player like this is moving down and now we also know that there has been some kind of collision the collision object now is pink i hope it still makes sense and now we have to resolve this collision this is happening inside of this line here we are putting the bottom of the player this line here at the top of the obstacle which means we are moving the player up by this amount and that way it appears that the player is on top of the obstacle and it appears like that because it literally is so next up we need self.direction.y is smaller than zero and if that is the case we are moving up and this means top self.hitbox.top going to be sprite dot hitbox dot autumn besides that we also have to update self.rect.center y and this is going to be self.hitbox.center y and finally besides that self.post.y is also going to be self.hitbox.center y and with that we have the entire collision logic so let's try and we do have a bit of a problem because we always spawn outside of this fence which causes a few problems so let me move around here and now if i just move around the forest here there's lots of things i can collide with and we do have some problems so something is not right and i think i know what it is because back in the player i am not calling the collision after the vertical movement meaning let me copy the collision here and this should be vertical now let's try this again so now we have the same problem we are spawning right on top of a fence which causes weird behavior but other than that now we have proper collisions let's see if this is working this is looking pretty good and if i walk through here i can walk behind the bushes but i cannot walk through all of the trees and this is looking pretty good so i am quite happy with this nice this is working very well there are two problems we have right now number one is the starting position of the player meaning inside of setup the player is just being spawned in a random position which isn't ideal and besides that we need some kind of mechanism to prevent the player from moving outside of the map so like this and let's go through them one by one the starting position of the player is the easier thing and for that we need tiled once more if i open this one there is an entire layer called player and inside of that we have a couple of objects and one is called start this is a simple node and this one we can use to set positions and this is where i want to spawn the player which means back in my code i let me add another comment here player is probably the best name for this spelling it correctly would also help what i want to do in here is for obj in tmx data dot get layer by name and this layer is literally called player and what i want to check is if obj.name is equal to start if that is the case i want to create the player and the starting position of the player is going to be obj dot x and dot y if i run this again we are starting right in the middle of the map so this is much better now we have to figure out the other kinds of collision so let me run the game again i can for example just walk through the house which feels a bit strange for that if i open tiled again there is an entire layer called collision if i make this one visible you can kind of tell what's going on i basically drew a couple of tiles all across the level and this is limiting the player this is what i want to import and then use it for collisions this i am doing inside of level and let me do it i guess right before the player makes sense and here i want to have some collision tiles and that is some terrible spelling collision tiles since we are now working with a tile layer again i want for x y and surface in emx data dot get layer by name this layer is called collision don't forget we also need tiles in here i want to create a generic tile and this one is going to need a position a surface and a group what you have to consider here is that for the group i want to only place it in self dot collision sprites this is the one sprite that is not going to be in all sprites as a consequence it is not going to be drawn or updated but it is going to exist and since this one isn't going to move we don't really have to update it that way even though we have a sprite with a surface it is not going to be visible but besides that everything else remains basically the same so i have x and y and both of these need to be multiplied with the tile size for the surface all i really want to do is create a pie game dot surface and this one should be tile size and tile size that way we are creating a empty surface or well a black surface with the dimensions of 64 by 64 which is all we need for this sprite and with that we should be having collisions so let me run main.pie again i am not able to walk through the house anymore on top of that if i try to walk on the water i can also not do that anymore and if i walk further to the right this one also doesn't work so this is much better i guess i can demonstrate what would happen if we added these generic sprites to all sprites as well so if i add this to self dot all sprites it would look something like this so these are the sprites we are actually colliding with and well it doesn't feel great but you can tell what's going on so this is the entire religion map of the level but i do not want to show them so let me undo all of this there we go and now we have all of the collisions that we need in this part i want to work on the trees so that we can hit the trees and the trees all have apples there are quite a few different things we need so let's jump right in here we are back in the code and i want to work on my trees let's get started by giving the trees some apples for that first of all we need an apple surface this we get with pygame.image.load and the file path here let me just copy it to save me a bit of writing this file path here inside of the project folder we are looking at graphics and in there we have root and in there we have if i make it a bit larger we have the apple this is what we're importing is simple image after that we need a list of possible positions for the apple and this we have in the settings let me minimize all of this so it's easier to read we have one dictionary with small and large and the values here are lists with positions and these names here refer to small or large trees and these are positions on the tree where we could have an apple this i want to create as an attribute so self dot let's call it apple pos is going to be apple underscore pos that's the dictionary from the settings file and from this i want to pick the list that is appropriate and this i'm getting by using the name remember here the name of the trees is either small or large and this is why this works finally each of the trees is going to have its own sprite group which i'm going to call apple sprites this is just going to be pygame.sprite.group now once we have that i actually have to use that to create some apples this i want to do in a separate method that i'm going to call create fruit we need self and nothing else and in here basically what i want to do is for position in self.apple position i want to have some random number generator to tell if we want to create an apple in a position or not now for that i am going to need randint so from random import rand and now all i really want to do is rant in generating a number between 0 and 10 and if that number is smaller than 2 i want to create an apple and the apple here is just going to be a generic object this one is going to need a position a surface and a group all the stuff we're getting from the generic class up here let me go through them one by one because we do have to be a bit careful here although the surface is very easy all we need is self dot apple's surface actually this should just be uphill surface because it's singular for the position you might be very tempted to just go with position by itself here because if you look at settings we have a list and this looks like a position and it kind of is but it's a bit misleading the way you have to think about it if this one here is the entire map of the game and we have a tree somewhere here the position that is inside of the list refers to the position on the tree and the number is the distance from the top left of the tree not the top left of the entire game meaning every time we are creating an apple we have to add the top left of the game and then we have to add the offset of the apple and let's do this separately for the variables we have x and y and this i think could actually be a really good exercise for you try to get the actual position of the apple you want to get the position of the apple the position we already have and then add it to the top left of the tree and see how far you get all right let's do it for the x and i want to get position 0. that is always the x this is let me bring the drawing back up and let me clean it up a tiny bit this position 0 is basically telling me how far from the left of the tree i want to go to this i have to add self self.rect.left and this self.director left is the left side of the tree meaning this side here is this side or in other words it is this distance here combined we are getting this entire arrow here and this is where we want to place the actual apple at least on the horizontal axis for the y this is going to look very similar we want pause one and then self.direct dot top and this is the actual x and y position we want this is what i want to pass in here for x and y finally for the group i want to have two groups in here the first one is easy i want to have self dot apple sprites besides that i also want to put all of these apples into all sprites because that's the only way to display them to the player the problem is we don't really have those available anywhere inside of this entire python file we only really have them inside of the level so this all sprites now the work around here is every single sprite has the attributes of what sprites it is part of and this we can access with self.groups and these are all of the groups that tree sprite is in this i do have to call and this is going to return a list and from this list i want to pick the first element and this first element if i look at my level where i am creating the trees this one here the first element is going to be all sprites the second element is going to be collision sprites this is what i'm getting with this line here so that way i am placing each apple into apple sprites that's the sprite group of the tree and then into all sprites that way they are going to be visible there's one more thing that we need and let me put all of this over multiple lines with named arguments otherwise this is going to be very hard to read this one is groups and finally the one thing i forgot is we need a z position fortunately this one is very easy we need layers and inside of settings inside of layers we have a fruit layer this is where the apples should be on every time we are creating the tree i want to call self dot create fruit and this should be working let's try if i now run main.pi and look at a tree we can see quite a lot of apples this is looking very nice i am very happy with this we are definitely making progress next up i want to have the logic that we can hit the player and let me minimize create fruit we don't need it anymore so let me call this the tree attributes in here first of all each tree is going to have an amount of health which i'm always going to set to 5 but choose whatever you want in here besides that i also want self dot alive and by default this is going to be true if this one is false the tree for example wouldn't create fruits but this is going to come later besides that i also want to have what i called self.stump underscore surface and this is what the tree is going to look like if the tree was destroyed so once a life is false we want to display a sum surface instead of the tree and this we have to import with pygame dot image dot load and in here i want to create an f string because we have to decide between two different files so there's one stump for the small tree and one for the large tree for both we have to go up one folder then to graphics and there's a folder called stumps and here i want to work with variables and this should be small if name is equal to small and if that is not the case it should be large and don't forget this should be png this is getting really large and i made a typo so let's put this on a separate line let's call this the stump path so i want to get this out of here and paste it in there and place this stump path in here and now don't forget we also have to convert alpha this one there's one more thing that we do need and that is a timer so i want to have self dot involve underscore timer is going to be a timer that lasts for about 200 milliseconds why we need this timer i'm going to visualize in just a second for now just follow along but this is basically all we need for the three attributes now that we have that i want to create another method and this i'm going to call damage here we need self and nothing else this method is well damaging the tree so i want self dot health minus equal one and this is going to be damaging the three besides that every time we're hitting the tree with an x i also want to remove an apple but i only want to do that if there is an apple meaning first of all i want to check the length of self dot apple sprites dot sprites if this list here is 0 there is no point in removing an apple so i only want to do this if this list is greater than 0. if that is the case i want to pick a random apple and store it in a variable and to pick a random apple i need the choice function and this one i also get from random so besides randint i want to import choice and in here i want choice and i want self.apple sprites dot sprites and this random apple i want to destroy with the kill method so now we just have to figure out how to call this damage method and this is going to happen inside of the player although for that to work we need a few more things so let me minimize everything inside of the player first of all the player needs to know where all of the trees are and for that to work back in my level let me minimize all of these methods as well i want to create another group and this i called self dot tree sprites again this is just going to be pygame.sprite.group all of the trees that i am going to create which happens down here each tree is supposed to be in all sprites collision sprites and also in self.3 sprites really important here make sure that self.all sprites is the first sprite inside of the list if that is not the case then inside of createfruit this line here would not work anymore so be careful here but now that we have that i can minimize the setup actually i can't because i have to pass into my player this one here let me put all of this over multiple lines because this is also getting really hard to read we have a position we have a group i think it was a singular group right yeah just group besides that we have collision sprites and finally i want to add one more parameter and this is called trees and this is going to be self.3 sprites and now inside of the player in the init method i want to create three sprites next up i have to convert all of this into an attribute let me put it all the way at the bottom here and let me create another section that i call interaction there are going to be quite a few things we need to interact with but in here i want to have myself dot three sprites and this is going to be the tree sprites parameter now we have to figure out how to actually target this thing and this is going to happen inside of use tool remember this we created ages ago about 2 hours by now but this method is being called every time we are using a tool and in here i want to check what tool we are currently using so if self dot selected tool is equal to let's start with a ho if that is the case i want to pass for now besides that i can duplicate this line i want to check if the selected tool is an x and this is what we want to work on in this part but for now let me add a path in here and finally i also want to check if our selected tool is water although in here for now also going to be a pass if we are using the x i want to check for 3 in self dot 3 sprites dot sprites don't forget to call it and now i want to check if we are actually hitting the tree which means if 3 and now i have to figure out if we are actually hitting the tree the problem is i don't really have any way to know which point i'm actually targeting meaning let me comment out all of this for now and let me run the code and i'm getting an error because i didn't import the timer so from timer import timer now let's try this again we are getting another error that the player this is probably happening in level this should be tree underscore sprites now it's working right now i can use the different tools and this is working perfectly fine for all of them the issue is right now we have no idea which point we are targeting for example if i'm using the x i want to know that i am basically targeting this point here let me use the x again this looks about right and this point i have to get in my code so back in my player let me minimize the init method and in here i want to create another method that i'm going to call get underscore target underscore position and all i really want to do in here is i want to create another attribute that i'm going to call self.target position this is going to be the same for all of the tools which makes it quite easy to work with and the basic logic here is if this is our player and this is the center of the player for each of the tools for example if the player is looking to the left then i want the tool to be somewhere here a certain distance to the left of the player and a bit further down the reason why i have to move it down is because most of the tools like the x for example they go in this direction here basically what i want to do i want to get self.rect.center and then i'm going to need some kind of offset and this offset i am getting from my settings because in here we have player tool offsets and these are a bunch of offsets that we can work with meaning this is what i want to copy paste it inside of the player and now we have a dictionary that we want to take some information from notice here the keys are called left right up and down which is the same as the status of the player which is very handy because now we can get self.status dot split and as always we want to split it wherever there's an underscore and then pick the index 0 of that list and this is basically all we need for this one method i guess importantly do not forget to call it right after the timers so self dot get target position now the problem is that this target position is going to be really hard to see at least for now for testing purposes we do need some way to visualize it and i just realized this should be status not stats and since this isn't something the player is supposed to see we can just do this really quick so for testing purposes back in level dot pi all the way at the end of custom draw i added a tiny bit more code that looks like this if you go for this basically what we are doing is we are drawing a rectangle another rectangle and a circle the result is going to look like this this is telling us the red line is the rectangle of the player the green line is the collision rectangle and the blue dot this one here is the target position so if i use a tool you can kind of see where it's going and this also works with the x and with the watering can and well this way you can play around with this quite a bit more although for the actual game you don't need it so most of the time you're just going to comment it out or remove it entirely but i guess let me keep it for now because now we know that the target position so the blue dot looks pretty good now with that we can uncomment this part here and now for the tree i want to look at the rectangle of the tree and i want to check if this tree is colliding with a point the point that i want to check is self dot target position if that is the case i want to get the tree and then run the damage method which is this damage method here let's try if this is working so back in the game we are already getting a problem because even if i don't use the axe the apples all disappear which i guess kind of looks cool but not ideal also this one should be commented one of the main reasons why that happened is if i open the timer again in here this line is causing the problem because there is a chance that our current time minus the start time is bigger than the duration so this could run forever and as a consequence we might trigger this function by accident and a really easy way to fix that is to add another end statement here that we want to check self dot start time is different from zero and now let's run may not pi again and now if i am colliding with a tree nothing happens and if i use the x also nothing happens let's try different tools okay nothing happens in general and the reason why that is happening inside of timer every time we are deactivating the timer we're setting the start time to zero meaning this is not going to run the activate has to be after this if statement and now inside of the player let me just print tool use just to try if this is working so now if i use the x i can see tool use in the bottom left and i guess now we can try to hit a tree there we go the apple disappeared and this is working quite well and let me close the timer again now we are done with it back in the sprites i want to have another method that checks if the tree is still alive so check def and basically all i want to do is if self.health is smaller or equal than zero then the tree is going to die let me just print that we just have to figure out when to call check def in my case i went with an update method that needs self and delta time like any update method and then here i'm going to call self dot check def actually to be a bit better here we only want to check def if self dot alive is true and now let me run main.pi again if i hit a tree with my x we get tool use tool use and now we get that this is looking really good which means what we can do in here now is i can set self dot alive u volts although there are a few more things that i do want to change first of all self.image so what the sprite actually looks like should be self.stump surface and since we are updating the image we also have to update self.rect this i get with self.image.getunderscorerect and i want to place the mid bottom should be wherever the previous self.rect.mid bottom was what that means is if this one here is the original tree and we want to create a tree stump that is a bit smaller we now have to figure out in this line where we want to place this rectangle finally we also have to update the hitbox and this we get with self.direct dot inflate actually i think good practice here is to copy the entire thing and now in here we are going to need a width and a height or an x and a y basically the same thing for the three stems i always went with negative 10 and negative self.direct and multiply this by 0.6 let's try so if i now go to a tree hit the tree a few times there we go we have a tree stump i can do this with the other tree as well and we get a different kind of tree stump and this section is getting quite long so let's finish it now but in the next section we are going to finish up the trees we are nearly done with the trees there is only one more major thing that i would like to add and that is some particle effects so that when an apple disappears or when a tree disappears i want to show some white object that flashes on the screen you'll see in a second what i mean but it looks quite nice once more here we have main.pi and i want to work inside of the sprites inside of the tree in here whenever one of the apples disappears that happens here i want to basically create a white apple on top of the disappearing apple that way we're indicating which apple disappears also whenever the tree dies which happens inside of this method here i want to do the same thing for the tree so for a couple of milliseconds we have a white tree and then we can see the tree stump both of these are being created with another class let me create it right here and i'm going to call this one class partic kill this particle is also going to be a generic sprite so it inherits like all of the other sprites from the generic class in here as always we are going to need the dunder init method we need self we need a position we need a surface we need groups and we need a z layer for the parent class to work we need the super and dunder init method this one for generic add position groups and the z layer meaning i can copy them in here and most of them we don't really have to worry about too much as a matter of fact if you look at this closely those parameters and those arguments are basically identical the only thing i really want to change is i do not want to have the default argument now the way this particle is going to work is it is going to be a sprite but this sprite is going to selfdestroy really quickly it basically has an internal timer let's create this one actually right now we can use the update method here and this one needs self and delta time just so that we capture delta time in here i am let me save it as the current time the current time i'm getting with pygame.time.get underscore ticks once i have that all i really want to do is if my current time minus some kind of start time we'll create that one in just a second is greater than a certain kind of duration if that is the case i want to destroy this sprite that way we are only showing this sprite for let's say half a second and then it disappears besides that this particle is always going to have the same surface as for example the tree except it is going to color the entire thing white and that way we have some kind of particle effect it's a fairly minimal one but it does the job for this game we need to do two more things we need to get a duration and this one i should have put in the init parameters so in here duration and i do want to have a default value let's say 200 now that we have all of that i want to create self.starttime and this one is pygame.time.get underscore ticks i suppose i should mention the difference between this start time here and this current time is that the start time here is only being taken once it's basically one point in time whereas the current time is being continuously updated meaning from this point here we are checking another current time another current time another current time and so on and at some point we are hitting the duration meaning that this distance here is greater than the duration and then we are destroying the sprite besides that i have to store my duration as an attribute and this i just get from my duration and this is the basic setup besides that we need to create the white surface in this we are doing via a mask for that i want to create a mask surface this i'm getting from pygame dot mask dot from underscore surface this one needs one surface and the surface we have is self dot image now once we have that i want to create a new surface and this new surface we get with the mass surface and then to underscore surface this new surface now is going to be a black and white silhouette of the original self.image any pixel that had any kind of color value is going to be white and any kind of transparent value will be black i can visualize this in just a second actually but what we need to do now is to get rid of all of the black color values which we do with new surface and we have to set a color key the color we want to get rid of is going to be black so a tuple with 0 0 and 0. and this new surface i want to set as the image of this sprite there we go and this should be all we need for the entire class all we have to figure out now is when to create it and this happens for example inside of the tree for example when we are destroying an apple i want to play this particle effect let's do it right below the random apple i want to create a particle for this particle i want to have not these parameters i want to have these parameters i suppose for simplicity we could get rid of the duration here because we're not going to need it for now and well now we have to figure out a position a surface groups and a z and i think this could be a really good exercise try to pass in all of these arguments and see if you can create this particle effect it should already be working once you have created it let's put them all on separate lines so i can work with named arguments and that should make all of this much easier to read first of all we need a position we already have the random apple we want to destroy i want to get this random apple i want to get the rectangle of this random apple and then i want to get the top left because this particle should be in the same position as this apple along the same lines it should also have the same surface so random apple dot image for the groups we need to do basically the same thing we have done for the apples which means i want to have myself dot groups don't forget to call it and now i want to have the element with the index 0. now looking at all of this since we are doing this quite often it might be a good idea to put a reference to the self.all sprites inside of the tree but you can do this in your own time it isn't going to make much of a difference finally for the set parameter i also realized it doesn't really have a separate layer but you don't really need one you can put it inside of the fruit but also be inside of raindrops it honestly doesn't matter at this point let's go with fruit i guess it fits in there quite well we need layers and in there i want to have the fruit and with that we should be having a particle effect let's try if i run out of this it still runs that's generally a good sign and let's use this tree here and there we go we have a very basic particle effect it is indeed very subtle but it certainly does work let me minimize the damage method and now we want to do the same thing for the tree once the tree is being destroyed which we can also do quite easily once again i want to create a particle and now once again let me get all of the parameters we need and i guess for this one we can also change the duration so in here i want to have all of these arguments the position is going to be self.rect.top left the surface is going to be self.image spelled correctly would be good as well then for the groups once more self.groups with the index 0 and for that i want to have layers and i guess we can put this on the fruit layer as well since this is a slightly larger object let's go for a duration of 500 and this should be all we need let's try this one now and this one is only going to play once the tree is dead so we have to hit a tree a couple of times we go i guess the effect is a tiny bit long uh let's go with 300. let's try this one although at this point this is quite subjective so you can just go with whatever you think looks best and yeah i think this is okay and with that we have some basic particle effects and these we can also reuse later on for the plans which is very nice which means we have covered another major section to finish off the tree we have to create a player inventory so the player gets an apple or some wood whenever we hit a tree which means we have to connect the player and the tree with each other which is a fairly straightforward thing to do so let's jump right in once more we are in the code and first of all we have to look at the player specifically inside of the init method let me put it above the interactions and right below the tools and the seats this one i want to call inventory because if you want to add something to the player the player needs to have some kind of system to store data and for now the player is only going to have a single dictionary and this i call item inventory although later on there's going to be a bit more and in here we're going to have a couple of different key value pairs let me copy them in actually so you don't have to watch me right we have these four wood and apple is what the player gets from the trees and corn and tomato is what we're getting from the soil by default all of them are going to be zero and let me line them up a bit nicer so this is looking better and these numbers we want to increase whenever the player for example gets a piece of wood or an apple which means we have to connect the player all of this here with the tree and since they are in different files we have to work via the level to make all of this work and let me minimize everything so we're not getting lost right now the level only has three methods even though it is quite a chunky class already but i want to add another method in here and this one i'm going to call player underscore add besides self we are going to need an item so the item we want to add to the player what is going to happen in here is i am targeting the player i want to get the item inventory of the player the one we just created from the dictionary i want to get the item this would be one of these key value pairs and this i want to increase by one i suppose you could make this a bit more flexible by adding another parameter that would be the amount for example but in my case i would always stick with one because i do want to keep things simple and this tutorial is already getting quite long this method i have to pass into the trees which means inside of setup when i am creating the trees this happens here and once again let's do this over multiple lines with named arguments so we're not getting completely lost we have the groups and finally this one was called the name the one additional argument we want to add is let's call it player add and this is going to be self dot player add make sure here not to call it because we only want to call it from inside of the tree object which means inside of the tree we're going to need another parameter layer add and this one we also have to store somewhere in the attributes let's do it here and self dot player add is going to be player add now that we have that when we are damaging the tree this stuff here i want to run self dot player add and give the player an apple which should be all we need i guess inside of the level in the run method all the way at the bottom let me print self.player.item inventory so we can tell what's going on if i run this now you can see in the bottom left the inventory of the player and if i now hit a tree we have one apple this i can do multiple times we have two apples three apples that is looking really good so that is basically all we need for the apples the one last thing for the tree we have to do is whenever the tree dies we have to give the player some wood and this could be a fairly easy exercise for you so try to figure this one out yourself i hope that this one is fairly easy at this point all you need is self dot player add and then here you have to add some wood let's run all of this again and for this one i have to hit a tree multiple times there we go now we have one wood this is working very well with that i can get rid of this print statement here and minimize the run method in fact i can minimize all of these methods so things are easier to see and with that we are basically done with the basic tree although the next section is we have to make sure that the trees get new apples once we are sleeping which means we have to work on the logic to start a new day but that is going to be the next section so let's start to work on restarting the day for now all this means is all of the trees are getting some new fruits but later on there's going to be quite a bit more besides that we also have to work on some transitions but let's do all of this straight in code it isn't so hard it's more an organizational thing but let's have a look at all of this alright once again we are inside main.pie and let's start by talking about what we need basically i want to start a new day when i stand here or when the player stands here and presses enter so right next to the bat which means we have to check an input and we need to check if the player is on top of this carpet or at least inside of this area for this i already have some basic setup inside of tiled let's have a look at that here we have tiled if i zoom in there is one object that is called bed that is right next to the pad this is an empty area that i want to import and if the player is inside of this area and presses enter then i want to start a new day once again if you want more detail entitled check out the dedicated video now this i want to import but for the import i need another dedicated sprite that sprite let me put it right here i have called interaction once more this inherits from the generic sprite although other than that it is going to be fairly simple we have an init method as always and in here we have self we have a position we have a size we have the groups and finally we have a name we do not need a surface in here for the simple reason that this kind of sprite is never visible anyway speaking of we can just create the surface in here and the surface we are creating with pygame dot surface and we are passing the size in here that is the size we're getting from the parameters other than that i have to call the parent init method with superdunder init and pass the surface the position and the groups in here there's that position really doesn't matter because again this is not going to be visible so we can just leave it as it is finally we have to get self.name and store it as an attribute the name if i open tiled again is what you can see on the left side here we have a name besides the bat by the way this is what you are going to see in quite a bit we have the trader meaning if the player stands inside of this area and presses enter we want to open some kind of menu for trading but well that is something for later but now i just want to work with the bad but other than that we have finished the entire interaction class it wasn't actually so bad now we have to import it this happens inside of level inside of setup in here this is getting quite extensive the layer we want to work in is the player layer let me add a bit of white space here because this is the same layer where we have the player except now i want to check if obj.name is equal to that if that is the case i want to create the inter action sprite for that to work i need to import it meaning all the way at the top after tree i want to have the interaction sprite now back in here let me copy all of the parameters we need we need those four and all of those should be fairly straightforward for the position we need the same thing we have seen for the player so obj.x and obj.y i can just copy paste them and for the size we're doing something fairly similar except for x and y we need with and we need height for the group i actually want to create a whole new group let me do it all the way inside of the init method this one i've called self.interaction sprites but this is once again just another pygame.sprite.group self dot interaction sprites we don't need self that all sprites here because again this kind of sprite is not going to be visible finally we need the name of this kind of sprite you could write just bad in here this would be perfectly fine alternatively you could also use obj.name you would be getting the same result and with that we have an area next up the player needs to know about this area because right now these interaction sprites only exist inside of the level and the player has no idea about them as a consequence for the player which is right on top i want to add let me call it interaction and this is going to be self.interaction sprites that way the player has an attribute to know where these interaction sprites are so with that inside of the player we are going to need one more parameter interaction this i want to store below my three sprites and let's call it interaction is going to be interaction with that the player knows where these kind of sprites are all we have to do now is check if the player is inside of this area and presses the enter button which we are doing if i minimize all of the methods this is going to happen inside of input all the way at the bottom of this method i need another if statement if keys are pygame dot a underscore return this is telling me if the player has pressed the enter button or not after i know that i want to know if the player collided with the bad sprite for example and this i want to store in collided interaction sprite this we are getting with pygame.sprite.sprite or lite and in here we need three arguments we need a sprite we need a group and we need what is called do kill the sprite in this example is just going to be self and we want to check the sprite so the player sprite against all of the interaction sprites which we get with self.interaction do kill is supposed to be false and basically what it means is if the player which is self in this example if this one collides with the sprite inside of this group do we want to destroy this sprite which in this case we don't want to do which is why this one is going to be false and now that we have that i want to check if collided interaction sprite exists in the first place or rather if it is truthy because that is only the case if it has a sprite inside if that is the case i want to check my collided sprite the first item inside that can only have a b1 and of that i want to check the name that is the name we have created here if this name is trader for now i want to pass but later on we are doing something else in here obviously if that is not the case which means we have the bad then i want to do something else one thing i do want to do in here is add self dot status is going to be left idle the main reason for that is if this is the player and we have the bad here if the player presses enter i want the player to point towards the bat it would be kind of weird if the player looked to the right then we press enter and then we start a new day it's kind of feeling bad let's try this one actually it should be working and we're getting an error that element property with does not exist do you mean with this happened inside of the level and here we need with now let's try this again this is looking better and now if i look to the right and press enter the player is looking to the left so this is working very good with that we can tell if the player is next to the bat and pressing enter so with that we can actually start working on the day transition for that we have two elements we need to cover first of all we have to basically restart the level in our case this just means all of the trees are going to get some new apples if they are still alive besides that we also have to play some kind of transition that indicates we have a new day let's start by resetting the entire level which is going to happen inside of level and i really want to hide the setup method this one is really large and all of the reset logic should be in a dedicated method called reset this one doesn't need any parameters and in here we basically want to reset everything which for now is just going to be the trees or rather the apples on the grease the way i approach this i first of all have to get every individual tree which i get with four tree in self.3 sprites dot sprites in here we actually have not too much work to do because if you look at the tree we have a dedicated function if i minimize everything we have a function called create fruit and this one creates all of the fruits that we need meaning all we really have to do is call tree dot create root although now we do have a problem because we are not destroying the existing apples that however is quite easily done all we have to do is for apple in three dot apple underscore sprites dot rights don't forget to call it and i want to destroy with the kill method all of the apples with that we're getting rid of all of the apples and we are creating new apples which is basically a reset what we now have to figure out is when to call this method because remember we are updating the level inside of the player not inside of the level class itself which means i have to connect the reset to the player although there's going to be another problem because besides the player this reset also needs to be connected to a transition effect how that is going to work is basically the entire screen is going to go dark then we are resetting the level and then we are making the screen go back to normal inside of this transition reset is going to be played here which means we need a system where the player the level and the transition all work together and this well let's go for it step by step first of all inside of the player for the ending method i want to have one more attribute this i called self dot sleep by default this one is going to be false if the player now presses enter and goes to bad all the way down here i want to set self dot sleep who rue that way we know if the player is sleeping or not and this we can use to start a transition that is going to happen inside of the level inside of run all the way at the end i want to check if player this should be self dot player dot sleep then i want to do something like self dot transition this one doesn't exist yet dot lay and this one is going to need delta time now this transition is going to be a separate class and this class is going to call the reset method once we are in a certain point of the transition animation which basically means inside of the init method i want to create self.transition this is going to be a transition class we will create in just a second and this one is going to get self.reset and it's going to get self.player with that we can actually create this new class let me save it as transition.pi once again we have to import pygame for the obvious reasons and we need from settings import everything the class we want to create is called transition no need for inheritance but i do need a dander init method because this one needs self reset and the player inside of this we first of all need to get the display surface because we want to be able to draw on the level itself this one we get with pygame.display.get underscore surface besides that we have to capture the reset method inside of an attribute and we have to do the same thing for the layer let me call this part here setup and besides that we are going to need an over lay image for the overlay image we are basically going to create a black image and then we are going to change the transparency or rather the blending mode but in this case this is going to be the same i'm going to explain this as we implement it but first of all i need self dot image and this is going to be pygame dot surface and the dimensions here we are getting from the settings because i want to have the screen width and the screen height let me copy this screen width paste it in here and the second one should be screen height this right now is giving us a surface the size of the entire window that is entirely black besides that i also want to have self dot color this one is 255 by default and then self dot speed this one is going to be negative two how these two attributes are going to work i think the best way to explain this is let's use them right away so i want to have some kind of play method that needs self and in here i want to self dot color plus equal self dot speed and that information i can use to fill my image so self.image.fill and in here i need an rgb tuple we need red we need green and we need blue in this case since we only care between a black and a white color they can all be the same color this image i now want to blit on top of the entire game which means self.displaysurface.lit i need self.image the top left should be a position zero and zero and for now let's just leave it like this and play it because you're probably confused at this point things are going to make a lot of sense in just a second or at least i hope they will first of all for all of this to work we have to import from transition import transition that means this one here is going to work and now inside of the run method layer.sleep is also going to work although here that's a time we don't actually need now with that let's try main.pi and let's press enter next to the bat and we're getting some very strange effect and we're getting an error message let's try it again really quick if i run this first of all we get white and then we go darker and darker and that is exactly what i wanted the entire logic is going to happen inside of play in here self.color on the first frame is 255 which with the fill method here means we are turning the entire image white all of these self.colors are 255 and those are the values for pure white and if you put this on top of the display surface we are getting a white image however now we are updating in this line the color which means on every single frame the color is going to be a tiny bit darker because of that we started with a white image and it became darker and darker and at some point this self.color got negative and this is where we got the error and this doesn't seem very much right now but we can make this look much better by adding another argument inside of the blit method the argument we need here is called a special underscore flags what we can do with this is set the blending mode the one we want is pygame dot blend underscore rgba underscore mult and now if i run this and try the same thing again now we have a much nicer transition this blending mode works it basically gets rid of all of the white values so the brighter a value is the less visible it is going to be and the pure white value is going to be completely invisible that way at the beginning we are not seeing any of this image but the darker it gets the more we see of it and at some point it turns the entire screen pure black although right after that the entire thing crashes that we do have to work on fortunately it's not that difficult all we have to do is if self dot color is smaller or equal than zero and if that is the case i want to set self dot speed and multiply it with negative one besides that if self.color is greater than 255 because now after these two lines we are increasing the color continuously and at some point it's going to be greater than 255 which is also going to be a problem we do need to limit that one as well if that is the case at least for now i want to set self dot color to 255 and with that we should be having a transition let me play main.pi and let's see how this is going to look we are still getting an error let's have a look i guess the main reason here is that once we get below zero we are only changing the speed we're not changing this number and as a consequence for this one frame things are falling apart but that we can fix quite easily all we have to do is set self.color to zero with that it should be working if i now walk next to the bed and this is working really well we are very nearly done there are three more things that we have to do let me write them all the way at the top number one we have to call the reset method number two we have to wake up the layer and number three we have to set the speed to negative 2 at the end of the transition i am pretty sure you can already tell where this is going this is going to be your exercise work through these three parts and try to implement them yourself and see how far you get the reset method i want to call when we are reaching this point here all i have to do is call self.reset because reset we have stored here and this is the one we created in level.pi and this is all we needed let's try this one actually i created it but never tested it meaning now let's have a look at some trees you can see we have two apples on most of those trees and now if i go to bed and look at the trees again they are looking different which means the reset method has worked next up we have to wake up the player that should happen once the entire transition is over all the way at the bottom self.player.sleep should be false on top of that while the player is sleeping i don't want the player to be able to move that would be kind of weird this happens inside of the player and all the way at the top here i only want to allow any kind of input if we are not using a tool and if we are not self dot sleep this one we can also test quite easily now if i press enter i would try to move to the left and i tried and now i can move again after a couple of milliseconds meaning this one is working as well finally we have to set the speed to negative 2 at the end of the transition this is also going to happen at the bottom all we have to do here is set speed to negative two with that we are done this is the entire transition i guess we should probably try this a couple of times but this is working once if i try again now and this is working again and it keeps on working just fine with that we have a daytime transition and this one is going to update all of the trees as well later on once we have plans we are also going to make updates to those and that i guess we can actually start working on next with the trees finished we can start working on the soil and there is going to be a ton of logic in here basically what we have to do is we need one class that covers all of the soil and this glass has to be connected to all of the watering and all of the plants which is going to be a very chunky python file just to warn you probably for the next hour maybe two we are going to work just on the soil you have been warned but for now just to get started let's create the very basic logic for the soil so if the player uses the hole we want to create one soil tile once again i am inside my project and i want to create a new file that i'm going to call soil dot pi in here i have to import by game and i need from settings import everything with that covered i want to create a new class called soil layer no need for inheritance but in here i want to have a init or done the init method with self and for now all sprites because in here each of the soil patches is going to be a dedicated sprite and to make them visible we have to attach them to all sprites as a consequence we do need them available inside of the class inside of this class i want to add one section let's call it sprite groups and in here i want to have self dot all sprites as my all sprites besides that since i do want to have easy access to all of my soil patches i want to create another attribute that i call self.soil sprites and this is just going to be another pygame dot sprite dot group after that we are going to need graphics and for now this is going to be very simple we have a single self.soil underscore surface and this is something we are going to import here we have the project i want to go to graphics and there we have the soil and in there we have a bunch of different things for now all i want to import is the file called o what all of the other files do you will see in the next major part for now just don't worry about them it's honestly better for you meaning all i want to do is pygame dot image dot load the path we need here is one folder up then graphics then we need soil and in the app we have o dot png with that we do have a setup but now we do have a couple of problems first of all not every single tile in our map should be farmable let me demonstrate this entitled actually here's the entire level and i think it should be quite obvious that not every single tile here should be farmable in fact i only want this area here to be farmable this is also going to exclude the house and the path none of these should be farmable only the stuff that is inside of this area i hope you can see what i'm talking about for that there is a whole other layer called farmable if i make this one visible you can kind of see what i am talking about only the pure green tiles here should be farmable meaning this is what we have to import and then only if the player hits one of these areas only there we are going to create a soil tile however now we do have another problem and that is that we have to manage quite a bit of data and this i want to address early because is becoming really important basically later on for every single one of the tiles we have to check a couple of different things let me add a couple of comments here in terms of what we need so requirements for each of the tiles we need to know if the area is far mobile that's the thing you have just seen besides that later on for the plants we also need to know if the soil has been watered and we have to know if this soil has a plant already for example if we want to plant a new plant we cannot plant that new plant if the soil patch has a plant already i hope that sentence makes sense meaning we need to have quite a robust way to manage all of this data as a consequence i'm going to store all of this information in one grid that for now is only going to store if we have a farmable area or not but let's do all of this in a separate method that i called create soil underscore grid in here we don't need any parameters and in here i want to create one list that contains other lists and one list for each tile of the game let's do this in tiled actually so when you look at these specific tiles here each of these cells is one tiled and in the grid i am going to create every single tile is going to be one list and this list is going to contain a couple of different pieces of information the one we are going to care about now is if it is farmable or not which i'm going to do by just adding a capital f inside of the list if it is farmable and well there's not going to be an f if it's not farmable that way we can always tell which one we have although to create this we first of all have to know how tall the map is for that i have to import the background image or the floor this one i get with pygame.image.low the file path here is one folder up then we have graphics then we have the world and then we have ground dot png this one we don't have to convert because we're not going to show it to the player instead what i want to do i just want to know how many tiles we actually have in the entire thing i want to know how many horizontal and how many vertical tiles we actually have this information i get by simply taking the whole width and dividing it by the tile size for example for the horizontal tiles i want to get my ground and then get underscore with and floor divided by the tile underscore size this i also need for the vertical tiles and this i can all do on one line so v tiles in here and this one i get with ground dot get underscore height although this one also has to be floor divided by tile underscore size i guess while we're here let me actually print the h tiles and the v tiles also i do want to call this method here in the indented method so self.create soil grid although first of all i do want to create this soil file inside of my level that way i can show you what the progress is while we are making it that should make all of this easier to follow all i really want here is from soil import soil layer this soil layer should become an attribute let's call it soil underscore layer and here soil layer really important we have to pass in one argument and that is going to be all sprites which we get up here and now if i run all of this we can see we have 50 horizontal tiles and 40 vertical tiles which if i look at tiled and look at map and mid properties we have in the top left the width and the height and this is 50 and 40. so this one is working just fine this i can now use to create a list of lists with every single tile being one individual list this is going to happen inside of soil.pi and what i want to create is self.grid this one we are going to do with list comprehension and let me add a bit of white space in here because this one gets slightly more complicated first of all i want to go through every single one of my columns and i want to create an empty list for my column in range h tiles although this is only a single one so i'm going to put this in another list comprehension which is going to be for row in range v tiles now i can get rid of the white space and let me just print what we actually get so self.grid run all of this and we are getting a very long list of lists the entire thing is one long list inside of this list we have one list for each row inside of the game and then inside of this row we have one more list for each individual cell now that we have that we have to actually check inside of tiled let me open it again we have to know which of these tiles are farmable and for that we need pi tmx again meaning i want from pi tmx dot util underscore pi game import load underscore pi game once i have that i want to use load pi game and load my tmx data file that i get by going up one folder there we have data in there we have map.tmx since we are only going to use this once i can use a method straight away and that is get layer by name the layer we need is called farmer bill and on this one we want to get the tiles because this one allows us to use all of this inside of a for loop meaning in here this is the one we have already seen we have for x y and a surface in load pi game although for this one we don't really care about the surface meaning i'm going to use an underscore to just ignore it or to indicate that i don't care about it what i now have to do is to figure out which of these grid cells corresponds to the x and y values and then add a capital f for each of those which is honestly very simple all i need is self.grid and first of all i need the row which is the y position this is going to give me another list and on this list i want to get the x position which is the column and now i'm getting a list and i want to append a capital f to that that is basically it if i now print self dot grid and run all of this we are getting an even stranger list what we're seeing in here is every single cell where we have a capital f this cell can be farmed what you should be seeing here actually is the first couple of lists should be entirely empty because on the top of the map there's nothing farmable and we only get a bit further down an actual f tile i suppose we can make this a bit easier to read by going for row in self dot grid and then print the row if i now run all of this this is well still very difficult to read but you can see it a tiny bit better this one here is the first row there's nothing and this continues for a couple more rows quite a few actually and at some point for this row here we have a couple of empty cells and then we start having four cells that are actually being farmable if i look at this inside of tiled you can see on the first row we have a lot of nothing and then we have four cells that are going to be farmable which is a pretty good sign that this is going to work i guess for one double check on the next row we have a couple more cells that are farmable and then we have a gap and a few more cells let's check this one out on the next row we have a gap then we have six thumb cells then we have another gap and then a few more farmable tiles so this is looking pretty good with that we have a grid that can store at least one bit of information it is going to get a bit more complicated later on actually what we now have to figure out is how the player can hit all of those with the whole for that i want to create another method and this i called create hit rects no need for any kind of parameters here and what we are going to do is for every single tile we are going to create a rectangle that the player can hit this i'm going to store in self.hit rex which is just going to be a list and now i have to cycle through myself.gridlist and convert all of the cells into actual positions and for that i am going to need the enumerate method let's go through it slowly i first of all want to get for row in self.grid and inside of that i want for cell in row let me give a bit of white space here to explain what is going to happen we essentially have a list that is going to contain let me draw it really quick so we have a couple of lists and inside of each list we have a few more lists the first for loop this one here goes through all of the lists and then the inner for loop this one here goes through these lists here which is basically horizontal axis the problem we have right now is we need to know on what list we are on for example we have to know that this one is list 0 this one is list 1 this one is list two and so on and for that we need enumerate i want to put both of these inside of an enumerate function that way we are first getting the index we are on and then the actual information let's call this one the index row and the second one i called the index column inside of this we can actually check every individual cell and i want to check if f is inside of this cell if that is the case i want to create an x position i want to create a y position and then i want to create a rectangle and this rectangle i want to append to myself dot hitrex dot append dot rect and now for the position and the rectangle i think this could be a really good exercise i hope you're not entirely lost at this point but try to figure out we are now creating a couple of rectangles and for each rectangle we have to convert the position in the grid to an actual xy position inside of our game so try if you can figure this one out we know where each cell is inside of the grid we also know what the tile size is if you want a hint but pause the video now and try to figure this one out yourself this is actually fairly simple all we need for the x position is the index column multiplying it by the tile size for y this is going to be the index row also multiplied by the tile size finally then for the rectangle we have pi game dot rekt and in here we need x we need y and then we need the tile size and the tile size meaning for this rectangle x and y is the top left and the tile size is always going to be 64 by 64. and that way we have a rectangle created for every single cell that has an f do not forget to call this one now self dot create hit rex and now we actually have something the player can hit although i guess for this one we have to create another method let's call this one get hit in here we need self and i want to have a point and this is the point the player can hit in here i want to check for rect in self dot hit underscore rects and i want to check for each rectangle if the rectangle was being hit by the point we have specified in the parameter which we get with rect.collide point and the point we are getting from the parameter if that is the case i have to convert this rectangle position back into my grid and that way i can identify if i have a list with an f or not and well for that i have to do basically the opposite i have done here i need an x and i need a y position and for the x i want to get my wrecked dot x and floor divided by the tile size this i also want to do for y except now it's rect.y floor divided by the tile size the way you want to think about it let's say we have one tile here and another tile here the first tile starts at position zero and zero the second one at position 64 and zero these points here if we now for example for x have something like 91 if i floor divide 91 by 64 we are going to get one which is going to be this tile here that way i have converted a pixel position this one here into an actual tile position that we can use to get information from this self.grid and with that i can check if the string f is in self.grid and once again we have the entire list of lists we first want to get y for the rows and then we want to get x for the columns and now if that is the case i want to print let's call it farmer bill what we now have to check is how to call this self.gethit my solution to that is i'm going to pass a reference to the entire soil layer into the player which happens inside of the level inside of the setup method when i create the player the player is going to have one more parameter that i called soil layer this is going to be self dot soil layer that way inside of the player i can create another attribute soil layer don't forget to turn this parameter into an actual attribute self dot soil layer is soil layer and now when we are using the tool i can get rid of the print statement and when we're using the whole i want to get self.soil layer and that way i can target or use this method here which means inside of player i want dot get it and the position is the same target position we have used for the x target position in here and now this should be working let's try although we're getting an error the level object has no attribute soil layer let's have a look inside of level we need a soil layer and i think i just called it soil ah no the problem is i am creating soil layer after the setup method that is a very easy thing to fix all i need is the soil layer before the setup method now if i run this there we go and i can use the whole and we get farmable if i use this here but if i go further to the right and use it here we are not getting anything and let me make this a bit smaller there we go with that we know where we are hitting something or more importantly if that is farmable or not if that is the case i want to get myself dot grid with the y and the x and append a capital x this is telling me that on this tile we have a soil patch once i have that i want to run another method that i call create soil tiles this one for now is going to seem quite weird but it is going to make much more sense in the next video but for now all that this create soil tiles is going to do we need self in here as always i want to get rid first of all of all of the existing soil tiles which i get with self.soil sprites dot empty after that i want to look through the entire grid and wherever there is an x i want to create a soil tile which means once again i can basically copy all of this here paste it in there and in here what i want to check is if capital x is in the cell and if that is the case i want to create a soil tile this one doesn't exist right now let me minimize a couple of methods so we have a bit more space we don't need any of this although at the top i want to create another class that i call soil tile this one is a sprite so we need pygame.sprite.sprite after that we have to create a dunder init method this one itself a position a surface and the groups it's supposed to be part of then we have to call this super dunder init method and pass the groups in here after that we need self.image this is just the surface we're getting from the parameters and we need self.rect this one we are getting with self.image.get underscore rect and the top left should be the position the position and the surface here are really important finally this one is going to need a self.set position this one fortunately is very easy because if you look at the settings we have a dedicated layer for the soil this i want to copy and paste it in here and now we have a basic soil tile all we have to do now is to pass in all of the information into the class to create it for the position this is something we have already seen inside of create hit rectangles we basically want to do this one here again i guess i can just put it straight in here and with that we have the position the surface we also have that is inside of the dunder init this soil surface here this is what we want to paste in there finally for the groups i want to have self dot all sprites because they are supposed to be visible and then self but i called this one the soil sprites soil sprites and since this is getting quite long let me put it over multiple lines we have the position we have the surface and we have the groups that is much easier to read and with that we should have a basic start let's try all of this if i now hit the floor we have a soil tile this is working really well and if i hit some other field we are not getting anything with that we have the start of this soil tile and we also have a really efficient system to organize our data which is really important although this is getting a very long section so let's finish it for now let's keep on working on the soil patch graphics the one really important thing i want to cover in this section let me demonstrate it when we place one patch it looks like this when we place another one right next to it it looks like this which is okay for a basic game but ideally it should be looking something like this that is what we are going to create in this section we are going to create our own auto titling system that creates nice looking soil patches this is also the reason if i jump into my code inside of soil layer we have this weird setup here that every time the player is hitting the soil we are getting rid of all of the soil sprites and then drawing them from scratch what this allows us to do is to draw all of the soil patches together and that way we can control different graphics depending on the position of each soil patch or rather if one patch is next to another patch then they should get a specific kind of graphic that is what all of this here is for although for all of this to work we are going to need a whole lot more graphics this is going to happen all the way at the top right now we only have a single soil surface instead what we need if i open the folder again inside of graphics inside of soil we have to import all of these different elements this is what i've shown earlier and now basically what all of them do i guess i can't really make them larger but if you look at them individually for example here we have the left tile this is going to be placed if there is one tile to the right of this tile we also have a tile called lr short for left and right this one we want to place if there's a tile to the right and another tile to the left there's also a file called x all the way at the bottom and this one is supposed to be placed if we have tiles all around it so i hope the logic here makes sense basically each of these tiles is going to be placed relative to where the other tiles are but for that we have to input all of them now this i want to save in self.soil underscore surfaces and in here you might be tempted to use the support file this one here and use import folder that however would not work because we need to know which file we are working with in all of the examples so far we didn't really care about what specific image we had we just used all of them but for this one we need to know which tile we are working with as a consequence i want to create another function in here i want to create import folder dictionary we again need a path although now we want to create a surface dictionary what i want to have in here is obviously a key value pair with the value being a surface one of the surfaces we are going to import however the key should be something like right it should be left it could also be something like x or lr and this is what we are getting from the folder so i want the key to be the name of each of these files and the file itself the value and that is what we have to create in here and this i believe could be a really interesting exercise look at this logic here and adapt it so that we are creating a dictionary with key value pairs and at the end of it return the entire thing pause the video now and try to figure this one out a lot of the stuff i can just copy the first three lines are going to remain identical because in here we are just accessing every individual file path that we are going to need so no change so far as a matter of fact the surface is also going to remain the same so a lot of the stuff remains identical the one difference now is when we are getting the surface dictionary i don't just want to append something instead i have to get a specific key or rather i have to create a specific key this i want to be the file name which i get with image and the image right now would be something like l dot png the png i do want to get rid of that i'm getting with split i want to split it wherever we have a dot and then i want to get the index 0 of this list this is always going to give me the name of the file without the file ending this is going to be my key and the value is going to be the image surface and that is all we needed all we have to do now is to return this surface dictionary and we are good to go now back to soil.pi and in here i have to import from so port import let's say everything and now i want import folder underscore dictionary and the file path i need is this one here i guess just to try if this is working let me print self.soil surfaces and run the entire thing the game doesn't crash that is generally a good sign and now we are getting what i wanted we have a key with for example b this stands for bottom and we have a surface associated with it in this we have multiple times these are all of the files that we wanted with that i can close the support file because we are not going to need it anymore i can also get rid of the print statement here this one isn't needed either and with that we are coming to the really fun part basically what we now have to do is to create the entire auto tiling option so let me go through step by step first of all i want to add let me call it tile options in here i'm going to determine what is to the left to the right to the top and to the bottom of the current cell which means we are going to cycle in here through every single cell in our grid one cell could look like this i have to know what is on the right on the left on top and on the bottom this is going to determine what graphic we are getting in here so first of all i want to have easy access to all of these options which i'm going to store in a variable we have top we have right we have left and we have bottom i want to check if we have a capital x in for example for the top self.grid and then usually we went with y and x although those we don't have available right now but we do have the index row and the index column those we can use index column is basically x this one we can use like this and y is going to be the index row this we can use here although for the index row since we do want to have the cell on top of our current cell this needs to be negative one and i guess while we are here we can also do the bottom because this one is very similar we can basically copy the entire line and instead of a negative one we have a positive one for right and left we are also checking for a capital x except now we are checking in the row and we're checking index column 1 this is working because we have the row quite easily accessible and this we can use this i want to copy one more time oh and i just realized right should be plus one and left should be minus one and with that we know for each of the tiles what the neighbors are doing now this system is still fairly simple because if i open the graphic again for most of the tiles we are only checking the four directions but there are four more we have the top right the bottom right the bottom left and the top left i am not going to check any of those because that would become incredibly complex and i don't really need it but if you want to have a proper auto titing system you would have to do it which would lead to a ton of if statements but let's go through it one by one now first of all i need to get some kind of tile type and this by default is going to be an o if i open this thing here again o is the default one the one we have already seen and this is a nice default one if everything else fails having this one probably isn't going to be too bad and now this we can use inside of soil tile because in here we have a surface this i want to replace with soil surfaces which is a dictionary and this dictionary i can access with my tile type and let's try this one right now if i run main.pi and use the whole everything works just as before that is a good sign and what i can do now i could for example change this to an lr run main.pi again and now we are getting a different kind of tile all we have to figure out now is to make all of this a lot more flexible which is going to involve a huge amount of if statements let's start with the really easy one all sides this one should illustrate the logic here quite well basically what i want to check is all of these are either true or false and i want to check if all of them are true this could for example be if l and b and r and l if that is the case i want to have the tile type to be an x this should be an equal sign and now let's try this one so here we have the center tile and i want to create tiles to the left and to the right and now to the bottom and there we go the thing updated this was the easiest kind of side although this we can clean up a tiny bit this we're doing with the all function and the all function checks if all values inside of an iterable like a list are true meaning in here we can pass t r b and left and we should be having the same result also let me put all of this on the same line because we are going to have a lot of lines let's try this one again it should still have the same result and it does this is looking really good that is covering all of the sides so next up we can start working on the horizontal tiles only this means i want to check if i have a tile and if there is a tile to the left or to the right or to both sides meaning we are going to have three different if statements here the first one we want to check if l is true so there's a tile left and not any inside of top right and bottom any kind of works like all except now we want to check if any of those is true for all to work all of them have to be true for any to trigger only a single one in there has to be true and let me illustrate the logic here let's say we have a tile like this and we only want to check if there is a tile on the left of it this is what we are doing in here if this is true we would ideally want some kind of graphic that would look something like this this would be working by itself but we also have to check that there are no tiles on top to the right or at the bottom of this tile which is what we are doing here if that was the case we would be needing some kind of other condition which we are going to do in a bit but i do not want to confuse the different if statements here each of those should be unique if that is the case though i want to have my tile type and now the tile should be right which means if a tile only has a tile to the left and nothing else we want tile type to be right let's try this one i have a tile here and if i had another one this one is going to be to the right i can continue doing this and now you can kind of see the one to the right works really well but the one in the middle gets a bit confused but that is something we can work on although first of all i can cover the right side which is kind of simple all i need is if r is true and now this should be t l and b we are basically doing the inverse of this one here and this one should be l then i can copy this one more time and now i want to check if we have a tile to the left and to the right which means i want to check if r is true and if l is true and if we don't have top and bottom if that is the case the tile type i want is left and right with that i should be having the horizontal logic if i run this now i can create some tiles here and this is looking very good although if i go down we are getting some weird results but that we can start working on in the next part which is going to be vertical only in here i want to check if we have a tile on top and not any tiles inside of the list right left and bottom if that is the case the tile type i want should be autumn i can copy this one more time because now we can check if we have a tile at the bottom and i also want to check if we have no tiles to the right to the left and to the top if that is the case i want to have a tile with the type t finally one more time now i want to check if we have a tile on the bottom and on the top and not do the right to the left and that is it if that is the case the tiles i have are t and b with that we have the vertical tile types let's try this one so now if i only go down this is also looking really good and i can still use the horizontal ones as well although now if i connect them we are again getting weird results which means we need some more if statements let's go with the corners for this one if this is the tile i for example have to check if there is a tile to the left and the tile to the bottom if that is the case this should be a corner like that which if you could follow along so far should be fairly doable it's going to look kind of similar compared to these lines at the end here let me copy it actually for this one i want to check if we have a tile to the left and a tile to the bottom and i do not want to have a tile on the top and the tile on the right and if all of that is the case i want to have a top right tile this logic is going to continue like that so let me just copy from my notes it's going to look like this these are all of the different kind of corners we could possibly have if i try this one now i can go down and now if i go to the right we have a corner the thing we are still missing though are t shapes because if i do this things are falling apart once again which is going to be another section and this is going to be t shapes in here for example i want to check if we have a tile and there is another tile on the top on the bottom and to the right if that is the case i want to have this kind of t shape which means in here i want to have if all and the tiles i want to look at are let's start with top bottom and right also i have to check and not left if that is the case i want to have a tile type of ebr let's try this one now i have my tile and i have a tile to the top to the right i'm at the bottom and to the right and there we go we have a t piece and now if we add one more direction we have an x piece so this is working just fine this i now have to copy a couple of times because we have to cover the other sides as well next up would be top bottom and left and not right if we have that we have a title called tbl copy it one more time now we have left right and top and not bottom if that is the case the tile i want to use is called lrb finally the last one i want to check if we have left right and bottom and not the top and if that is the case i want to have lrt and with that we should have a proper auto titling system so let's try the entire thing now i can just go around create more tiles this is looking pretty good and yeah i'm quite happy with this although you can probably see there are some minor thingies these little bits here they exist because the auto titling system here is not perfect for example this tile here is technically a corner tile where we have a tile to the bottom and to the right and corner tiles always have this kind of bit here at the end this we could get rid of by adding a bit more logic for this tile to also check if there's something for the bottom right although in my case i think this looks fine and if we added more logic here this would become even more complex and i think this is already quite a lot of if statements so i'm going to leave it as it is and now i can minimize all of this and we have definitely made a ton of progress for this part we are going to work on the watering logic which with the current system in place isn't all that difficult to do let's jump right in and let's do it step by step once more we have the entire project and i want to start inside of the player let me minimize everything and we already have the use tool method here inside of there we have selected tool being water if that one is being triggered i want to once again get myself the soil layer remember here the player has access to the entire soil layer this we have also used for the whole however now i want to use a method called water which doesn't exist right now but will in just a second and here once again we need our target position and with that we can return to the soil file and all we have to do now is to create another method let's do it below get hit i call this one water in here we need self and the target position what i want to check in here is if this target position hits any of the soil sprites any of those here oh also i forgot the soil surface we can get rid of because we don't need it anymore for the water i want to check for soil sprite in self.soil sprites and there's already typo in there dot sprites i want to check if soil sprite dot wrecked dot light point and in here i can add my target position and let's try this one first if that is the case i want to print soil tile watered and the rest should already work let's try i want to create a water tile change to the watering can and now use it and we get soil tile watered which means this here is already working this means i have to do two things number one i want to add an entry to this soil red which means i want to add a capital w to the cell besides that number two i want to create a water sprite this is going to indicate that there is water on this tile let's start with number one in here we have the same problem again we have a position for this soil sprite but we need a cell position which means we have to do some conversion we need an x position and a y position and what we need in here is the soil sprite dot rect.x floor divided by the tile size this i want to do again for y let me copy the entire thing except now this should be rec dot y that way i can use these positions to access the grid which i get with self.grid and now i want to have my y then i want to have my x and then i get a list and to this list i want to append a capital w that way we know which tiles have been watered and which ones haven't besides that number two i want to create a water tile to visually indicate that we have indeed watered this soil tile this water tile i want to create inside of this python file which is class water tile once again this is going to be a sprite so pygame.sprite.sprite we also need a dunder init method for the obvious reasons this one needs a position a surface and the groups and we also need a super dunder init method this one gets the groups as well although this class is going to be fairly simple all we're going to do in here is self.image is what we're getting from the surface self.rect is going to be self.image.getunderscorerect with the top left being the position like this and finally we are going to need self dot z this self.set we are getting from layers and inside of settings we have a soil water layer this i want to copy and paste in here i guess if you're being specific here this water tile and the generic tile are basically identical but i do want to keep things as separated as i can here but you could be a bit more aggressive with inheritance here it's entirely up to you and with that we have the water tile i just have to call it now and for this one we need a position we need a surface and we need the groups and that is going to be your exercise there are a couple of steps to it number one copy the position from the soil sprite meaning this water tile should be in the same position as this soil spray here which should be very easy to get number two for the surface i want you guys to import the folder with the path let me copy it really quick the path is going to be this one from this folder randomly select one surface finally i want you guys to create one more group let's call it water sprites and the water tile should be in all sprites and inside of water sprites so pause the video now and try to work through all four of those tasks and see how far you get i guess to make it easy to read let's store it in a separate variable but all we really want in here is the soil spread itself then dot rect which stores the position and then top left that is basically it for number two we have to import another folder and this should happen inside of the init method let's do it right below graphics it does seem to make sense here i call this one water underscore serves and in here we only want to import a folder which means import folder the file path being this one here in case you are interested if i open the graphics part we have soil water and in there we have three different water kind of tiles from those we want to select one randomly again let's do that in a separate variable let's call it surface and in here i want to use the choice function which we don't have yet but we can get it with from random import choice and i want to get a random self dot water surface and this is going to be part number two and three actually finally we need one more group this i am going to do up here and i want to create self dot water underscore sprites i think i called it yes this is going to be just another group so let me copy it and there we go now when we are assigning the groups i want to have self dot all sprites and self.water sprites and that is all we needed with that i suppose i can get rid of all of the comments because they are getting a bit annoying there we go this feels much better and now if i run main.pi again i can still use the hole and if i now use the water we have a water tile and i can do a couple more tiles and use the watering can again there we go this is working really well the last thing we need is that once i restart the game i want to destroy all of the water tiles and also get rid of the w for every single tile that is going to be a separate method let's call it remove water no need for any arguments in here and there are two things that we have to do number one is we have to destroy all water sprites and the second one is clean up the grid the first one is really simple all we need is for sprite in self.water sprites dot sprites and i want to just destroy all of the sprites that is going to be the first part the second part is going to be for row in self dot grid and then for cell in row what i want to check in here is if there is a capital w inside of this cell if that is the case i want cell dot remove and the capital w all i have to figure out now is when to call this method this is going to happen inside of level.pi in here once again let me minimize everything and i want to work inside of the reset method there is going to be another section let's call it soil and all i have to do is self dot soil layer and remove underscore water if i run main.pi again i can create a couple of soil patches water them and now if i restart the day this is still working fine and there we go this is looking really good so with that we have the watering logic we are not quite done yet with the watering logic because we need the rain this is going to consist of two different parts number one we need the actual rain animation so that the player can tell if it's raining or not besides that if it is raining i want to automatically water all of the soil sprites so that is what we're going to work on let's jump right in back in the code i want to create a new file that i want to save as sky dot python in here i want to import pi game and i also want from settings import everything and i want to create a class called rain there is no need for inheritance but i do want a dunder init method although in here all we want is all sprites once again so that we can draw in here without having to leave the class itself this we have to save inside of an attribute so self.all sprites is going to be all sprites once we have that i want to have a few more graphic files we need self dot rain underscore drops and i want self dot rain underscore floor both are going to use the import folder function except with a different path as a consequence i have to import from support import let's say import folder for this one just to have a look at them inside of the project i have graphics and in there i have rain in here we have drops and floor drops are very simple raindrops basically just straight lines for the floor we have a whole animation or it's not really an animation we can just play them separately but this is what we are going to import let me just copy the file path it is going to be this one and it is going to be this one there's one more thing that we do need and that is we need to know the size of the entire map basically what is going to happen if this here is the entire map i want to randomly create little rain animations all throughout it and for that to work i need to know how wide the entire map is and how tall the entire map is that is information i can get from the ground image which we have to load with pygame.image.load and for this one let me copy the file path as well it is this one and this is literally just the ground nothing else all i want to know is get size and this i want to store in self dot let's do it via two variables we have floor w and self dot floor h once we have that we are going to need two separate methods one for create the floor and besides that we need create drops and after that i want to have an update method that is creating both of those so self.create floor and self.create drops in here now we have to figure out what to do in my case all i'm really going to do is create a drop class which doesn't exist yet so we have to create it and this i want to create inside of this file as well plus drop now this is going to be applygame.sprite.sprite although i do want this to inherit from generic to save me a bit of writing as a consequence i need from sprites import generic i am getting much worse at spelling essentially what i want to do is to import this generic class here we are using this all throughout and you could even put the drop in here it would be perfectly fine but i think in here it does make a bit more sense all i want is to create another indent method in here we need self we need a surface we need a position we need to know if this one is moving or not then we need the groups and then we need a z position and how the drop is going to work it is going to be kind of similar compared to if i minimize all of this it is going to be kind of comparable to the particle we're going to create the object for a short period of time and then destroy it which means we are going to have a timer for each object and then destroy it after a couple of milliseconds now for that i want to have a random live time which i'm getting with randint which we don't have in here yet meaning from random import rand int the duration here i want to go with 400 to 500. besides that for the timer i want to have self.start time and this we get with pygame.time.get underscore ticks also let me comment here that this should be the general setup because in here i guess this should be at the top i also want to have a super dunder init method the arguments we need for this one are the same that we have for generic we need these four all four of them are going to come from the attributes that we are passing in when we are creating the drop so there isn't anything we have to do right now although what we do have to do is to work on the moving part basically how that is going to work if we have a raindrop so the things that are going down those are supposed to be moving whereas the raindrops on the bottom so the round things those are going to be staying in place which means i want to have another attribute that i called moving and this is going to capture the moving parameter if self.moving is true then we need a position and this is going to be pygame.math.vector2 and self.direct.top left besides that we also need a direction and the direction here is going to be pygame.math.vector2 and for the value here i went with negative 2 and 4. those directions mean we are going 2 units in the negative direction and we're going 4 units down as a consequence our actual movement is something like this finally we need self self.speed which is going to be a random value as well between 200 and 250. now these three attributes is the same thing you have seen a couple of hours earlier inside of the player so if i show the init method somewhere here we have direction position and speed these are the attributes you basically always need to move anything inside of pygame finally i want to have an update method in here don't forget we do need delta time and i want to check if self.moving if that is the case self.pos should be plus equal self.direction multiplied by self.speed multiplied by deltatime and once we have that self.rect.top left should be rounded self.post.x and rounded self.y we are basically assigning the top left of the rectangle to position.x and we're using round to avoid the truncating that pygin does by default this is going to be the movement and besides that we are going to need a timer that i want to destroy this timer if it has lived longer than the lifetime and this is going to be your exercise create the timer that you are destroying this sprite after the lifetime has run out pause the video now and try to figure this one out all we need here is pygame.time.get underscore ticks this is getting our current time from that i want to subtract self.starttime if that difference is greater or equal than self dot lifetime we know the lifetime has been exceeded as a consequence we want to kill this sprite and that is all we need for the drop now we just have to create it inside of here and inside of here so let me copy all of the parameters we need and paste them in here and in here or create floor the surface is going to be self dot rain drops and from this we want to randomly select one of them for that we need choice which we don't have yet but we can import it very easily for the position i need to have an x and a y position for x this should be a number between 0 and the width of the map that is what we created up here which means i need rand int that goes from 0 all the way to self.floor width and this i also want to do for the y position and this should go from zero to the floor height next up we have moving for the floor tiles this is going to be false then we have the groups and the groups are going to be quite simple because in here all we have is self dot all sprites finally we need the set position and for this one if you look at settings we have rain floor this i want to copy and paste it inside of layers and there we go this is all we need for the floor and now i can basically copy all of this and do the same thing for the raindrops it's going to be fairly similar for the surface we want to have rain this should actually be raindrops and here this should be rain floor sorry about that the position can remain the same moving should be true ropes can remain the same although for the set position we have raindrops that's the layer all the way on top this i want to paste in here and there we go this is covering the entire rain class so let me minimize the raindrop and basically everything in here as well all we have to figure out now is when to call this rain method here and that is going to happen inside of the level first of all i want from sky import rain this i have to turn into an actual object let me add another comment here actually to organize this a bit better let's call it the sky because there's going to be a bit more in here we have self.rain and this is going to be the rain which needs self dot all sprites besides that i want to have another attribute here that i called self.raining and this by default let's say for now it is going to be true so it's easier to test but later on this is going to be random and now inside of the run method before we are doing the overlay let me add a few comments here actually transition overlay i want to have my rain all i have to do for that is check if self.raining is true and if that is the case i want to have self.rain.update that way we are calling this update method here which is going to generate raindrops and those drops we are going to see hopefully in the game so let's try and there we go we have the rain and honestly this is actually a fairly simple effect all we are doing is we are creating random sprites that are either moving for the rain or that are staying static on the bottom and well this is the entire rain graphic if we go over this it really isn't that complicated or at least i hope it isn't with that i can close the sky.pi file although we are going to see it later but for now we don't need it what we need now which is much more important we have to update all of the soil tiles if it is raining and for that inside of soil.pie let me minimize everything once again because this is getting quite extensive i want to create another method that i want to call right below water water underscore all no need for any arguments in here and once again i want to go through all of my grid cells for that let me copy the nested for loop again one more time and paste it in here i want to check if there's a capital x in the cell and w is not in the cell already which basically means we're going through all of the cells and we are checking if there's an x meaning there's a soil tile but this soil tile hasn't been watered yet but we do want to make sure that does get watered which means first of all i want to append a w to the cell and after that i want to create all of the water tiles again and in here let me copy it from the water we basically want to copy this entire thing although we do have to make some changes because for this one we have a position inside of a cell and this we have to convert to an actual pixel position the main thing you have to understand about the soil layer is we are working with two different systems one is we have all of the positions inside of the grid and that is basically a table besides that we have all of the pixel positions in the actual game switching between them is really simple in this case we need an x and a y position and those we get for x it's going to be the index column multiplied by the tile size and for y it's going to be the index row multiplied by the tile size this x and y we now want to paste into the position for x and y and we are good to go the surface is going to be the same surface we had up here i just want to pick a random water tile i can just paste it straight in here and the groups can remain identical those work just fine with that we have a function that can water all of our soil tiles we now have to figure out when to call it and this has to happen in two separate places number one is when we get hit or rather when the soil gets hit we are attaching an x inside of the cell here if that is the case i want to pass in if self.raining which is not something we have yet but we are going to in just a second if that is the case i want to call self.water all the problem we have right now is that the soil layer doesn't know if it is raining or not this we only know inside of the level although that is a problem that is very easily fixed all we have to do inside of the init method after we have set the rain i want to get myself dot soil layer and set raining ooh self dot raining also when we are resetting the day i have to do the same thing which means in here in a bit i want to randomize the rain every time we are resetting the day once we have updated that i want to get myself dot soil layer again and set raining back to self dot raining and now we always know if it is raining inside of this class here which means if i run main.pi and i use the whole we automatically get water sprites this is looking really good and if i switch off the rain all the way at the top here so raining should be false let's try this now we don't have rain and we don't have water at least not by default so all right with that we have some basic rain logic although what i also want when we are resetting the day and it is raining i want to automatically water all of the existing soil tiles because right now in the logic here we are only watering new tiles we don't water existing tiles which means when i'm resetting the day i want if self.raining is true then self dot soil layer dot water underscore all let's try this one oh and i do have to switch on the rain and to test this one let's randomize the rain meaning when i'm creating the rain i want to have a random chance to create a rain which i'm getting with rent int which i don't think i have available yet i do not i need from random import rand int and in here i'm just creating a number between 0 and 10 and if this number is let's say greater than 7 this is going to be true although for now for testing purposes i'm going to set this number to a free which means we're going to have a ton of rain this i also want to do down here actually i can copy the entire line like so and now for every day we have a pretty high chance to generate rain if i run this it's raining right now but we can still get started and let's go to bed and let's hope there we go now there's no rain so there's no water on them and i guess let me water one of them just for testing purposes if i now go to sleep again it's not raining now it's raining again and all of the soil tiles have been watered so this is working really well very nice and with that we have the basic watering logic so another major step forward next up we can start working on the plans let's get started with the plans since we already have a ton of logic in the soil this shouldn't be so bad actually but once again let's go for this step by step the very first thing we need is inside of the player we need to know if the player is planting some seeds for that we already have a method that is called use seed right now there's nothing in there but that is going to change i want to get this soil layer once again and now call a method that i called plant seed for this one we need two arguments the first one is going to be self dot the target position the second one is self dot selected not tool but seat and i hope this makes sense we have to know what target we are hitting and we want to know what kind of seat we are using this is all we need inside of the player and now in the soil in the soil layer i want to minimize all of the methods and let me put it let me put it all the way below the water in here i want to have planned underscore seat we need self we need a target position and we need a and once again we have to check if we actually hit a soil sprite which we get before soil sprite in self.soil sprites dot sprites i want to check if soilsprite.rect.collide.point and the point i want to check is the target position if that is the case once again i have a pixel position and this i want to convert to a position inside of the grid which means i need my soil sprite or direct.x and floor divided by the tile size i can duplicate this line and change the x to a y and that way i'm getting my y position inside of the grid if that is the case i want to get myself dot grid with my y and x this is going to give me the cell and i want to append a capital p short for a plant that way we know we have a plant inside of this cell now this should only be possible once which means i can already check if a capital p is not in self dot grid with y and x and only if that is the case i want to create a plant now that we have that i want to create a plant object this i am creating also inside of this python file with class land and this one is also going to be pygame.sprite.sprite i want to have a dunder init method with self we need a plant pipe so do we want corn or tomato then we want groups next up i need the soil for the positioning and let's say that's it for now as always i need the dander init method with the roots i have to convert the plant type parameter into an attribute so self.plant type is plant type and then i have a couple of frames depending on what kind of plant we have meaning here's the project i have graphics inside of there we have fruit and there's corn and tomato not the best naming but it really doesn't matter inside of corn we have these different files and inside of tomato we have those this is what we are going to import this we get with import folder and the file path here is let me just copy it right away we have to go into graphics and fruit and in there we have two subfolders and those subfolders i want to get with an f string because what we can use in here is the planned type besides that we need self dot h by default this is going to be zero after that we also need self.max h so that we know when the plant is reaching the full h this we can get with self. frames and get the length of it and subtract 1 from that finally i want to have self.grow underscore speed which is telling me how fast this kind of plant is growing and for that inside of settings i have a dictionary this is what i want to use meaning i can use grow speed in here and then get the plant type i guess i should really comment all of this a bit better to make it a bit easier to understand let's call this section here the plant growing and this stuff at the top is going to be the setup also there's one thing i forgot we have to turn the soil into an attribute so self.soil is going to be soil once we have all of that we can work on the sprite set up first of all here we need self.image this is very easy because we have a bunch of frames i want to use self.h for the indexing besides that i have to create self.rect this i'm getting with self.image.getunderscorerect i want to place the mid bottom and the position i'm getting from soil.rect.mit although here we have a problem this is going to be the size of a soil tile but each plant is going to be about this tall and since we're placing the bottom of the plant at the bottom of this soil tile we're going to be somewhere here and i want there to be some kind of offset this i created separately and i called it self dot y underscore offset this is going to be negative 16 if the plant type is equal to corn and if that is not the case it's supposed to be negative 8. the reason here is that the various plans are very different in size we do have to account for that and to use that i have to turn it into a vector which means pygame.math.vector2 this needs to be capitalized for x it's supposed to be zero and for y it is going to be self dot y offset we are nearly done the last thing we need is self dot z in here we need layers as always and for the plants we actually have two different layers the one we are going to start with is the round plant this i want to paste in here and this means if you look at the settings the plans are always going to be below the player by default i want the plans to be noncollidable so the player can just walk on top of them but once they have grown i want them to be on the main layer and the player should be able to collide with them but that's going to come in a bit i guess for now we have added a ton of stuff so let's actually create one of the plans and see how far we get so when i create a plant i need a plant type the groups and the soil this one should be fairly simple because the plant type is going to be the same as the seed the soil is also going to be very simple because all we need in here is the soil sprite for the groups i do want to have one group specifically for the plants this is going to happen in the init method of the soil layer in here i want to have self.plan underscore sprites once again this is just going to be pygame.sprite.group and now for the groups each plant should be inside of self dot all sprites it should be inside self dot blend not types but sprites and let me fix this typo here and let's actually try this so in the game i can use a hole and now if i press left ctrl we get some seeds that we can walk over and this i can do multiple times also with e i can change the seed and now we get a tomato this is working surprisingly well cool so i'm very happy with that what we now have to figure out is how to make the plants grow inside of the we need an update or some kind of an update method this one i called grow there is no need for an argument in here and now we have a problem because the plant needs to know if the soil it is in was watered but this information we don't have available right now what i want to happen is that each plant can access the soil layer and check out self.grid know if the tile it is in was watered or not and for that i am going to create another method that is going to be fairly simple though i called this one check watered in here we need some kind of position this position will be entered by the plant itself i want to get the actual cell and right now once again we have a pixel position this we have to convert into an actual grid position so we can access the grid the same thing we have done here actually let me copy the entire thing actually and fix the indentation there we go to get the cell all i want is self.grid and y and then x once i have that i can check is watered and is watered we are getting with capital w in cell meaning this could ever be true or false and that is the information i want to return so return is watered now this method i am going to pass into a plant whenever we create it which happens down here each plant is going to have access to self.js watered for this we have to create another attribute after soil i want to have check watered this we have to turn into an attribute so self.jackwatered is check watered and now we can create this grow method all i have to do is check if self dot check watered with self dot wrecked dot center remember here check water it needs a position and i'm just going to go with the center remember here check water did need a position if that is the case i want to add self dot h plus equal self.grow speed and after i have that i can run self.image is going to be self.frames and i can use self.h again although now we do have to be careful because this age could be a floating point value which we couldn't use for indexing but if we turn it into an integer this is going to work again and after that i can turn this into a rectangle which i am getting with self.image actually let me copy this one here because it isn't going to change besides that now the main reason why i am updating the rectangle is because the image is going to change and we might have different dimensions which means we have to get a new rectangle but other than that this is the basics of the grow method what we now have to figure out is when to call it for that inside of the soil layer i created another method update plans all i need in here is for planned in self.plannedsprites.sprites i want plant.grow and this method i now want to call inside of the level when we are resetting the day so in here let's do it all the way at the top we have the plans self. soil layer dot update underscore plants and that should basically be it i guess the one thing you want to be careful about here is that this should be called before all of this because for example if we called it after is raining with this method here we might water all of them and then update all of the plants which would be a tiny bit weird let's try so i want to grow some corn make sure i am watering it and now let's update the entire day and we are getting an error that name soil sprite is not defined this probably happened inside of here ah right jack watered has the problem right now that this should be position zero and position one because what we actually pass in here inside of the plant is self.record center which is giving us a tuple with an x and a y position now let's try this again next attempt i want to plan some coin again and start a new day and we are getting another error this one happens down here inside of plant.grow so let's have a look at this one and the problem is happening somewhere in here the problem is we don't have the soil as an attribute this we can fix with self dot soil ready next attempt let's try it again let's see if i made another mistake now it's working and there we go this definitely grew let me water it by hand and start another day and there we go this keeps on growing and now if i start another day it should be fully grown there we go now if i start another day this is going to crash because we are running out of frames but this was expected other than that this is working just fine we do have a very good start now we just have to make some more updates to the plant and then we are nearly done with the plants and with most of the game actually first of all once the plant is reaching the max age i want the plan to stop growing which happens inside of grow all i want to do in here is if self.h is greater or equal than self dot max h and if that is the case self.h is going to be self.max h although if that is the case i want to indicate that the plant is ready for harvesting which i am doing via another attribute that i called harvester bill and harvestable is going to be true once this condition here is true so we can set this to true with that the game is not going to crash anymore although what i also want to do is if the plan starts to grow it should be on the main layer and the player should be able to collide with it this could be a good exercise if the plant h is greater than zero so if we have one and above then the plant should be on the main layer and pause the video now and see if we can figure this one out for this one we need an if statement and i want to check if self.h is greater than zero if that is the case i want to update self dot z which now should be inside of layers and the main layer although there is one thing you really want to be careful about because self.h could be a floating point value and we only want to do this line here if the plant is greater than one which we can get quite easily with integer if you didn't do this self.h might be something like 0.7 which would be greater than 0 but the plant itself would still be a tiny seed which the player should walk on top so integer ensures that we have a certain kind of plan size if i run the game now let's hope it doesn't crash i can land something and if i now update the entire thing it doesn't crash and now we should be behind and in front of all of this stuff so this is working just fine what we now have to figure out is the collision mechanic and for that if i look at the player again at collision in here the plans don't have collisions yet because they don't have a hitbox which we are checking here but that we can fix quite easily once a plant has a certain age it should have self.hit box and this is just going to be self.direct.com p and this i want to inflate and now i need an x and a y dimension again for x is going to be negative 26 and for y it is going to be self self.rect.height multiplied by 0.4 and this should be negative that is all we needed if i now run main.pi and let's create a tomato for now if i plant this one although i think this takes two days to grow but that's a good way to double check so now i can still walk over the tomato plant but if i sleep again now we have a grown plant and there is no collision yet and i also know why the reason is the plants are not inside of the collision sprites method so when i am creating a plant it needs to be inside of self.collision sprites the problem is the soil layer doesn't have that one although that we can change i want another attribute with the collision sprites and let me put this right below all sprites self.collision sprites is going to be collision sprites now inside of level when i create the soil layer which happens here i also want to pass in self.collision sprites now let's try this again i want to plan some corn because that one is faster and now if i restart the day we have something and now we have collisions this is looking really good cool so with that we have the basics of the plant although we cannot harvest them but that is going to be the next section with the plants being done the last thing we have to do is the harvesting part or at least the last thing we have to do for the plans there is going to be quite a bit more let's jump right in and once again let's go through it step by step back in the code what i basically now have to figure out is if a plant is harvestable so this line here is true and i have a collision with the player so this player here then i want to destroy the plant and update the player inventory all of this is going to happen inside of level.pi i want to create let's call it planned collisions or collision there's no need for any parameters in here first of all i want to check if there are any plans in the first place which i get with self dot soil layer dot plant underscore sprites if there are no plans this is not going to trigger and then there's no point doing any of all of this if there are no plans this would not trigger in here i want to check for plant in self.soil layer dot plant sprites dot sprites that way i can access every individual plant and what i want to check is if plant dot harvest bill and the plant.rect.colliderect with self.player.hitbox we are checking if the plan can be harvested and if the plant is colliding with the player if that is the case i want to destroy this plant make sure to call this plant collision right after update which happens here i want to run self.planned collision and now let's try all of this we're getting an error that inside of level this should be planned sprites so should this one here now let's try this again there we go i can plant some corn and water this and now i have to do a bit of restarting the day but the game is definitely coming together now it's raining so i can go straight back to sleep and now if i collide with this it disappears cool this is a very good start although we do have to a few more things in here first of all i want to run self dot player underscore add and in here i want to get the planned and then dot planned underscore type that way we are updating the player inventory so there's an actual reason to harvest something and this we should probably test so once again all the way at the end of the run method i want to print self dot player dot item inventory if i run this now we get the entire inventory and i want to plant some corn now i have to restart it's still raining it's also raining and we need one more day and now if i collide with this we get corn one this is working very well so let me delete this print statement here again and now we can keep on working in here i also want to create a particle when the plant disappears which we don't have available yet we do not but i can import it quite easily i want a particle which we're getting from the sprites this one here and now i need all of the arguments to create it so let me copy these ones here paste them in here and now we have to figure out all of them again for the position i want to have land.rect.top left for the surface i want to have planned dot image and for the groups this should be self dot all sprites for the z layer i want to have the layers and in here this should be main this should be all we need once again let's try this and i do hope it starts to rain this is looking good raining again one more time and now we should have a particle effect and there we go this is looking good the last thing we need is whenever we destroy the plant we still have inside of the grid let me minimize the plans the last thing we need inside of this soil grid we have to remove the capital p that way we can create another plant for this one i need self.sawyer layer once again and now we need the grid the problem is right now we only have an x in the y position and for the grid we need rows and columns which means we need a row and we need a volume and once we have that i want to remove any kind of capital p and this column is going to be your exercise see if you can figure this one out for the row we are going to need the y position of the plant which we get with plant.rect.com y and this i want to flow divide by the tile size for the column this is going to work in the same way except now we need center x and with that we should be good to go so now if i run main.pi again now if i plant some corn and restart the day it's raining again we do have to wait until the thing grows completely now it should be working and now we are getting an error because i made a typo this should be tile size okay once again let's try this again and testing a game can be very annoying it's not raining but i guess all of this is good way to test all of this let's try it one more time now it is raining it keeps on growing and now it is completely grown if i touch it it disappears and now i should be able to create a new plant so let me plant a tomato and there we go we have a tomato i guess if i restart the date just to be sure all of this is working one more time and it is growing cool so this is working as well with that we have the harvesting logic this honestly wasn't so bad or at least i hope it wasn't there isn't actually that much more to do but there's one thing i did forget to do and that is the night transition or the daytime transition let's do this one next for the day transition we kind of have to do the same thing we have done for the transition between different days we are basically creating an image on top of the entire game and then we use blending modes to merge the two i probably should have done this a couple of hours ago when we worked on the transition but well here we are back in the code i want to do all of this inside of my sky because it kind of fits in there let me reopen it we need the sky in here besides the drop and the rain all the way at the top i want to have let's call it sky we need a dunder init method in here with self and now first of all we need the display surface which as always we get with pygame.display.get underscore surface besides that we are going to need an image that covers the entire window which i called self.full surface just surf is fine and this we get with pygame dot surface and in here i can once again from my settings get the screen width and the screen height let me copy in the screen width and this green height and now we have a full surface once i have that i want to let me call it display in here we need self and we also need delta time and essentially all i want to do here is self dot display surface dot blit i want to have myself dot full surface at the position 0 and 0 that will be covering the entire window and finally we need a special blacks which in this case is going to be pygame dot blend underscore rgba underscore mult right now this is going to be entirely black so there isn't too much point but let's use it right away also i want to close the soil at least for now to keep things a bit more organized i can also close the sprites because i don't think we need it at all anymore inside of the level i want besides rain also import sky and the sky has to be an attribute let's put it right here self.sky is going to be sky once we have that inside of the run method after the rain i want to have the day time like that and this we get with self.sky dot display in here we do need to at a time although not right now but we do need it to call the method if i run this now everything is going to be black the reason is we are putting a black surface on top of the entire window which well isn't particularly helpful although what i want to do now is self dot start color and this start color is going to be a list with the values 255 255 and 255 before i am displaying this surface i want to fill it with that color so self.color serve.fill with self.startcolor once we have that we shouldn't be seeing anything we can see the game itself this is looking as always but now what we can do with this setup i could for example change this to a0 and if i now run this again we get a bunch of weird colors and this way we can control how the game is going to look like in my case i want to transition from a pure white color to myself dot and color which is going to be the tuple 38 101 and 189 just to illustrate what this one is going to look like let me run it in the game it's going to look like this this is very much night time all we have to figure out now is how to transition from this value to this value here how this is going to look like is i'm going to look at every individual value and subtract it by a certain amount let's say negative 2. and this i'm going to do until we're reaching this particular point this point here so you can see it this is also going to happen for the second one this is going to go until this point here and for this one as well up to this point here this i am getting with for value in self dot and color although in here i do need the enumerate method because i need to know what index i am on so i have my index and i have the value i want to check if self dot start not time but color is greater than the value and if that is the case self dot start color with the index should be minus equal 2 multiplied by delta time also when i am filling all of this this should be the start color we are looking at every single color inside of n color against this we are checking on this line here if the corresponding value inside of start color let's say the first one 255 is greater than the end color 38 in this case and if that is the case we want to reduce the start color value by a certain amount and this we want to do until we reach the end point and with that we should be having a transition let's try now and we are getting an error this one here should be start color and index and now all i have to do is wait i guess while i'm doing that i can run around a bit to check out the entire level i've been very focused on specific tasks but well the entire game is coming together pretty nice also here you can see the trader and now since we have a collision block here we cannot move over him anymore we're going to work on the trader in just a second and everything else is working really well okay probably i'm just going to speed up this entire game because i am running out of things to talk about so let's speed it up a bit alright i think at this point you can definitely tell things are getting darker this is definitely working all we have to figure out now is once we have all of this color here we have to set it back to the starting position so 255 255 and 255 whenever we are resetting the entire day this is also going to be fairly simple all we have to do let me add another comment here sky i want to get self.sky dot start color is going to be 255 255 and 255. that if i now wait a tiny bit let me speed all of this up all right now we can definitely tell things are getting darker so let me restart the day and there we go this is much brighter with that we have the daytime cycle really wasn't that bad and this is literally all we need for the sky meaning i can minimize it and close the entire python file and we are almost done the last major bit of the game is going to be the merchant so let's work on that one there are quite a few different elements we have to cover here back in the code first of all the player is going to need let me minimize everything the player is going to need a full inventory we already have a couple of things in here we have this kind of inventory but we are going to need a tiny bit more we also need self.seed underscore inventory and this one is going to have two key value pairs we have corn and by default let's say we have five and besides that we have tomato five in here would also work well finally besides that we are going to need self dot money and for starting value here let's go with 200 it's entirely arbitrary this is going to be the inventory for the player and this is also what we're going to access when we are doing the merchant although before we are coming to that there's one more thing that i want to do and that is that the player shouldn't be able to use a seat once we are running out of seat for example the player can only use corn if this number here is at least one let me minimize the init method and all of this happens inside of use seed all i want to do in here is if self dot seed inventory and then i want to pick myself dot selected seed and only if this is greater than zero then i want to plant a seed besides that inside of here as well i want to get myself dot seed inventory get the selected self dot selected seed again and subtract it by one with that we can start working on the merchant itself let me explain how it's going to work here we are back in tiled and the trader is all the way in the top left what you can see around the trader is inside of player we have a trader area this is going to work kind of like the bad if the player is inside of this area presses enter then we are going to start the merchant menu back in the code when we are creating the level more specifically when we are running the setup method in here a bit further down we are checking for the start position of the player if there is a bad and besides that i want to check if object is equal to trader if that is the case i want to create another interaction object meaning i can duplicate this line here and paste it in here with that we are actually done all of these arguments here can stay identical since we're getting information from tiled all of this is going to be done automatically the only major change here is going to obj name because this one now is going to be trader instead of bad but with that we have the interaction object we have to do a tiny bit more inside of the player inside of the input method all the way at the bottom we have created this line a couple of hours ago and that is if the player is inside of the interaction area and we have trader then we want to do a certain thing basically what i want to do is to run a method called self dot toggle underscore shop this one doesn't exist right now but basically what i want to do is inside of the level i want to create another method let me minimize everything in here so it's a bit easier to see inside of the level class i want to let me do it below player ad this one i want to call toggle underscore shop in here we need self and nothing else and this is a fairly simple method all i really want to do in here is self dot shop active is going to be not self self.shop active meaning whenever we are running this method we are switching shopactive either on or off this attribute doesn't exist right now so we do have to create it this happens inside of the init method in here let's put it under another section shop and by default this one needs to be false if this one is true though we are going to show the shop menu but that is going to come later first of all we have to pass this method here into the player which happens inside of setup and in here we have the player and the player is going to get another parameter toggle shop which is going to be self dot toggle shop for that to work inside of the player all the way at the top let me minimize the input method and inside of the indent method we need toggle shop and for this one inside of interaction i want to create another attribute self dot or girl shop is going to be toggle shop and with that we should be having a pretty good start i suppose we can test this inside of the run method all the way to bottom i want to print self dot shop active and this we should be able to influence with the player so let's run the game and we are getting thoughts right now that is a very good sign and if i walk to the merchant and if i press enter right next to him we're getting true if i press it again we're getting false so this is a very good sign and with that we can start working on the actual merchant for that i want to create a new file and save it as menu dot pi in here as always we are going to need import pygame and we also need from settings import everything after that i want to create a new class that i call menu in here we need a dunder init method this one itself it needs the player and it also needs toggle menu so we can switch off the menu from inside of the menu inside of this i want to have a general setup for this i want to turn the player into an attribute so self.player is player the same i want to do for the toggle menu so self.toggle menu is going to be toggle menu and besides that i am going to need two more things first of all i need the display surface this as always i'm getting with pygame dot display dot get underscore surface and besides that i need self dot font the font we get with pygame dot bond dot font be careful here about the capitalization the first font is lowercase the second font is uppercase this we want to call and in here we need a font style and we need a size the size is easy because we just want an integer in my case 30. for the font we need an actual file in my case here's the project folder and we have font and in there we have a file called lychee soda this is what i want to import the file path for that is going to be a string and i want to go one folder up to font and then to lichi so da dot ttf and with that i have a font with all of that covered basically what i want to do i want to create an update method that one itself and nothing else and this is actually going to show the menu although we do have to do quite a bit of work to get this one done for now just to see if this is working i want to show some blank surface which means i want self.display surface dot blit in here i want to create a surface from scratch and this one is going to have a dimension of let's say one thousand and one thousand the position here is going to be zero and zero the way we are going to call it inside of level.pi i want to get rid of print shop active and instead first of all at the top i want from menu import menu inside of the init method i want to create an object from the class so self.menu is going to be menu the two arguments we need here from menu we need player and toggle menu layer is really easy because we have self dot player toggle menu is also very easy because in here we have self dot this one is called toggle shop though but same thing i can just paste it in here and we are good to go inside of the run method i have to do some reorganizing the first two lines can stay identical and let me add a few more comments here to make all of this a bit clearer the first two lines are let's call it drawing logic after that we have the updates in here i want to check if shop active if that is the case i want self dodge menu dot update i think i called it yeah update i want to call this method here and only if that is not the case so else i want to do these two lines here if the menu is active the player cannot move anyway so there's no point updating all of the sprites or any of the planned collisions it's simply not necessary as a matter of fact i want to stop the entire game while the menu is open this is going to include the rain as well which means it's only supposed to rain if raining is true and not self dot shop active only then do i want to update the rain the overlay however can stay here let's put all of this under the weather section actually and let me remove these comments i think this makes the most sense with that we have the entire run logic let's try it so in it still works and now i want to run to the shop and in here i want to press enter and the game is crashing because inside of menu this one should be pi game dot surface and while i'm here i also realized this should be inside of another tuple now let's try this again and next to the merchant i press enter and now we have a big black rectangle and the rest of the game also doesn't update which is a very good sign which means this one is working we just have to add more logic to it the most important one for now is that we need an input method so that we can switch off the menu as well this is actually going to be your exercise i want you guys to get the input and then if the player presses escape close the menu pause the video now and try to figure this one out it should be fairly doable first of all we have to get all of the keys this we get with pygame dot key dot get underscore pressed once we have that i want to check if keys and pygame dot a underscore escape if that is the case i want to run self dot toggle menu don't forget we also have to call self dot input but other than that this should be it back at main.pie let's run this again and right next to the merchant i press enter and now if i press escape the game continues and this i can do multiple times this is working really well so with that we can toggle the menu with that we can actually start creating the proper one and for that i first of all want to have a couple of options the most important one for now is self dot width and this one i set to 400 this is going to be the entire window and inside of it roughly here i want to have the menu inside of the menu we're going to have individual entries like so what with is determining right now is the width of this entire menu besides that i also want self dot space that is the space between the elements this i set to 10 and then self dot padding and this i set to 8. once we have that information i want to create the actual menu entries and for that first of all we are going to need all of the i call this one the options what this is going to be inside of the player in the init method we have the inventory this is going to be what i want for the options for the menu and i am going to combine all of those into one list self dot player dot item underscore inventory and i only really care about the keys here don't forget to call this and this i want to turn into a list this list i want to combine with the seeds let me copy it and to combine it to lists i need plus and copy this list and i want to have the seed inventory this one here to make sure this one is working let me print what we get self dot options and now if i run this and close the game here you can see we have all of the different options apple corn and tomato are the inventory of the player so the items corn and tomato are the seeds although now we do have a problem let me run it again actually inside of this list i need to know which of these items can be sold and which ones can be bought the items should be only sellable so these four items i want to be able to sell and these two items here i can only buy as a consequence i need to figure out where i'm drawing this line here where we end the selling menu and start the buying menu for that i created another attribute that i called cell border this is basically self dot player dot item inventory i am getting the length of it and from this i'm subtracting negative one later on i'm going to cycle through this list and for every item i am going to check the index and check if it is smaller or greater than this border if it is smaller we are selling if it is greater we are buying and with that i can create is self.setup method let's do it right below this one doesn't need any arguments the most important thing i have to do in here is to create the text surfaces all of those are going to be stored in the list and the list i called text surfaces for now it's just going to be an empty list all of these items are going to be created with four item in self dot options that is the list we have created up here all i have to do is to create a text surface and this i am getting with self.font.render in here we need a string we need antialias and we need a color the color is the easiest bit i just want to have black in here antialias should be false and the string should just be the item once i have that text surface i want to get myself dot text surfaces and append the individual text surface i also just realized this one should be set up not input now with that we have a list of surfaces this we can now use inside of the update method in here i can get rid of this big black rectangle and instead i want to do for text surfaces in self.text serves although remember what i explained earlier for this logic here to work to separate between the by and the cell menu i need to know the index of every item inside of this for loop as a consequence i am going to use the enumerate method here and let's call this one text index i suppose for now all we have to do is self dot display surface dot blit we have a text surface and for the position let's say we can go with a hundred for x and for y i want to have the text index multiplied by 50. let's try all of this now and once again i have to walk to the trader here we are at the trader if i run this we can see the different entries so this is looking really good we can also end the menu and this is working very well very good we are making progress although now we do have a problem right now the height is basically random so we have to figure this out more deliberately this is also going to happen inside of the setup method besides the text surfaces i want to have self.total height by default this is going to be zero inside of the for loop i want to get this total height and plus equal self dodge text surface and then get underscore height although don't forget i also want to add plus self dot heading multiplied by two and this i want to put in brackets that looks a bit cleaner each of those text entries let's say we have three for now inside of those the text is only one part in the middle and there should be some space or some padding between the top and the bottom of the text this is what we're getting with self.padding the entire height though is what we're getting from self.total height this is what we're going to use in just a second to center the entire menu although there's one more thing that we do need because if i open the drawing again between each of the entries so this space here there should be some more space that is the space we have set up earlier in here to get that number let's do it here i want to get self dot total height and i want to add a number number i want to get the text surfaces and i want to know how many items i have so i want to have the length right now that number would be free because we have one two and three elements from that i want to subtract one for the simple reason that we only have one space for any two elements as a consequence if we have three elements in total we want to have two spaces between them all of this i want to put inside of another bracket and this i want to multiply with self dot space and now i have the total height this i can use to calculate self dot let's call it menu top this is going to be the top part of the menu for this number i need in my settings the screen height and this i want to divide by two from this number i want to get myself dot total height and divide this by two as well this here is going to be the entire screen and screen height divided by 2 would be roughly this point here from that i want to subtract self.total height divided by 2. that would be roughly let's say here with this being the first half and the other half would be below so one half here that way the menu is always going to be in the middle there's one more attribute i want and this i called self dot main rect this is going to be the bounding box for the entire menu and this is going to be a rectangle so pygame.rect in here we need the left the top the width and the height figuring those numbers out could actually be a really good exercise so try to figure them out yourself and see how far you get there are three numbers in here that should be fairly simple the top is what we have just done it's just self.menu top so i can place this one in here the width is also very easy that is the number we have created up here which means i want to have self dot width height is also easy this is just going to be self dot total height the only minor complication is the left side to get this one we kind of need the same logic we have used here i first of all want to get my screen width and this i want to divide by two from that i want to subtract self dot width and subtract this by two as well with that we should be having a rectangle that is in the center of the window and also is as tall as all of the text elements i guess let me minimize the setup method and try this one i guess for now we can comment out this for loop here and instead i want to pygame.draw.rect i want to draw on self.display underscore surface the color let's go with red and the rectangle is going to be self dot main rectangle and just for testing purposes it's going to be kind of annoying to always walk towards the merchant so inside of the player let me go to the input method and then here if the player is pressing enter i want to toggle the shop already like this now if i run the game i am getting an error this happens inside of menu inside of setup and this self.text surface shouldn't be yourself it's just a text surface so we're getting this one here now let's try this again we're not crashing and now if i press enter we're getting a menu in the middle of the window i can also press escape and the game continues as always so this is working quite well i suppose next up we can start working on another important ui element and that is display underscore money there's no need for any arguments in here and all we are going to do in here is first of all we need a money surface or rather since we have local variables this can be a text surface all i want in here is self.font.render in here again we need a string we need antialias and we need a color the color once again is going to be black and antialias is going to be false it is false here because i have pixel fonts which don't look good when you enter and use them finally for the string what i want to access is inside of the player in the init method i want to access this money attribute here this i get with self dot player dot money although this i want to put inside of an f string like this because that way i can add a dollar sign before once i have that i can create a text rectangle this is just going to be the text surface dot get underscore rect and in here i want to place the mid bottom for the position here i want to have this green width divided by two so we are right in the middle and then i want to have this green height and subtract 20 from here that way we are slightly off centered from the bottom of the window once we have those two bits i can get myself dot display surface and split the text surface and the text rectangle and now all i have to do is to run self dot display money and this should be working so inside of main or pi i press enter and we can see the money in the bottom center of the window this is working very well although there's one more element i want to add and that is a background for this text this i get with pygame dot draw.rect and in here i want to draw on self.display surface the color for this one should be white the rectangle i want to use in here is the text rectangle although i do want to inflate this one by a tiny bit let's say 10 and 10 pixels if i run this now this is already looking much better although i do want to have some rounded borders this i can also get very easily i need to add two more arguments the first one is the border width which in my case is going to be zero and then we have to border radius which in my case is going to be 6 and this 6 here determines the border radius or how much rounding we get if i run this now we have some rounded borders which makes the entire thing look much nicer i guess you can play around with different numbers here let's try four yeah i guess this one looks a bit better but again this is pretty subjective so choose whatever you think is best with that we have finished the money this is all we need in this one i guess next up we can work on all of the actual entries and we already have some good starting points here we have access to all of the text surfaces and we know their index this i can use inside of another method let me call it show entry in here we do need a couple of arguments i want to have a text surface so the text i want to show that i want to have the amount like so then i need the actual position and this is going to be top with all of that i can start working on this and first of all in here i need a background after that we are going to create the text and later on we are also going to show an amount but let's get started with the background in here i want to create a bg rectangle this is just going to be a pie game rect and once again we need a left a top a width and a height left we can get fairly easily because we have self dot main rectangle dot left since this main rectangle is in the center of the window this makes it very easy for us to get positions top is going to be what we're getting from the parameters this top here the width is going to be self dot with the one we have created all the way up here and finally the height is going to be text surface dot get underscore height don't forget to call it and to this i want to add self.heading multiplied by two once i have that all i want to do is pygame.draw.org and in here self.display surface the color should be white i want to draw the background rectangle and i want to go with 0 and 4 for the border radius with that we already have a pretty good start all we have to do now is inside of this for loop we have to figure out how to actually call this show entry let me add a bit of white space and first of all in here we need to get the top and the top is going to be self dot main rectangle dot top plus the text index and this i want to multiply with a couple of things most importantly the text surface and i want to get the height of that although to that i have to add self dot heading multiplied by 2 and i have to add self dot space think of this one here is the main rectangle this one here and by default we are getting the top this line here and for every item we want to get the distance downwards that we get by multiplying the text index by the height of the text the padding and the space for example if the text index is zero all of this is going to be zero so the first item is going to be all the way at the top here for item number one we would be somewhere here let's say this one could be 100 because the text height would be something like 70. the padding could be 2 times 10 and let's say for the space we also have 10 and all of this we want to multiply by one as a consequence the result here is going to be 100 and this 100 is going to be the top of this text entry and this is what we can use in self dot show entry let me copy all of the parameters here so top is what we have just calculated text surface is also what we are getting from here for the amount for now let's just say 0 we're going to work on this in just a second but for now if i run main.pi again and press enter now we can see all of the background fields and those are perfectly centered which is looking very nice definitely progress although let me get rid of this line here so we're not drawing the text anymore and also this drawing here so we don't have the red background now if i run this again this is looking much cleaner cool so with that we can start working on the text for this one i want to create a text rectangle once again this is going to be pygame dot rect and again we need a left at top a width and a height for this one i want to get the text surface and get underscore rect in here once again i want to place the mid left i need an x and a y position or rather i need a left and a top position to be a bit more specific for the left side i want to have self.mainrect dot left and now i want to have an offset let's say 20. for the top i want to have the bg rectangle and in here i want to have the center y position once i have that i can run self.displaysurface.blit and pass in the text surface and the text rectangle let's try this one now and there we go this is looking really good finally we need the amount for this one first of all i want to create an amount surface this once again i get with self.font.rna in here we need some text we need antialias and once again the color the color is always going to be black and the alias is always going to be false and the text itself is going to be the amount although here this we have to convert to a string because by default amount is a number and pygame doesn't like that it always wants a string for the render method now that we have that we can create an amount rectangle this we get with amount surface dot get underscore rec and for this one i want to place the mid right again we need a left and a top and for the left side what i want in here if this is one text box or rather one of the bg rectangle inside of there we have the text rectangle and the text is somewhere here ish with a offset from the left for the amount surface i want the exact opposite i want to come from the right side and have something like this which means for the left side here we want to have the right side of the main rectangle and then go to the left a bit which means i want to have self dot main rect dot right and subtract let's start with 20 pixels although for the top all i want is the bg rectangle and then center y again and let me clean this up a tiny bit there we go all we have to do now is get self dot display surface dot blit and pass in the amount surface and the amount rectangle if i run this now this is looking pretty good although we do have to figure out the actual numbers for the amount that however isn't that difficult or at the very least it's certainly possible first of all inside of the for loop i want to get let's call it an amount list and this amount list is going to be very similar compared to this options here as a consequence i can just copy it and paste it in here except now we don't look at the keys instead we are looking at the values this way if i open the player we are getting all of these values here inside of one list and this list has the same order as this list here as a consequence we can get the amount simply by looking at the amount list and using the text index and that is what i want to pass in here if i now run this again press enter we are getting lots of zeros but then we are getting five and five those are the two seats and with that we have the basics of the menu although we cannot select anything and let's do this right now i guess we can keep the entire merchant in one big section for the selection we need a few more things most importantly let me add this section here and let's call it movement the one thing we need in here is self dot index by default zero here is totally fine and how i'm going to use this when i'm creating show entry let me minimize everything else there's going to be one more parameter and that is going to be selected and if selected is true so if selected then i want to for now just draw a border around this particular box which i'm getting with self.display surface for the drawing the color here should be black and i want to get the background rectangle although now i want to have a border width of four and 4 for the border radius if you specify a border width the content or the filling disappears for this rectangle but let me show what actually happens if i press enter now we are getting an error because i forget to add the argument in here i want to have either true or false and what i am checking is if self.index is equal to the text index now if i run this and press enter now by default the first item is going to be selected however if i go to my menu and set this index to let's say a 3 and run this again now we have tomatoes selected and all i really have to do inside of the menu is to change this index to select a different item and this i'm doing inside of input all i want to do in here is if keys and pie game dot k underscore up if that is the case i want to set self dot index minus equal one then i can copy all of this and change the up to down and this one should be a plus one now i can set index back to zero and now let's try this actually if i press enter now and press down something weird is happening the thing disappears oh well it kind of works but it moves way too fast and this is a problem we have encountered earlier basically inside of the init method pygame for this one for example checks if the down key is being pressed but pygame checks this about 100 times per second as a consequence if we are pressing it down pygame registers this line let's say 20 times even though for us it seems like we are only pressing the key once and as a consequence we need a timer this one we already have i want from timer import timer and the timer i want to create in here so self.timer is going to be timer for this one we only need a duration and for the duration for this one i went with 200 milliseconds now inside of the input method when i'm pressing either up or down i want to activate this timer so self.timer.activate but all of this should only be possible if the timer is not active meaning if not self.timer.active finally there's one more thing that we need and that is we have to update the timer which i'm doing all the way to the top of the input method self.timer.update i hope you remember the time i actually recreated this one a couple of hours ago let me open it actually so inside of the timer this one here we have all of this and this is what i'm using inside of the menu right now but with that this should already be working if i run this now i can open the menu and i can move up and down this is working really well the problem right now is if i move too far up the thing disappears and also if i move too far down it disappears this we want to control for meaning i want to clamp the values all this really means in practice is i want to have myself.index and if this one is below zero i want to set self dot index to length of self dot options minus one this means if we are going below zero we we're going to the end of the list this is also going to work the other way around that if self.index is greater than the length of the list minus one then i want to set self.index to zero and now let's run this again and if i move down this still works if i move up we are getting to the bottom of the list and if i move downwards we are going back to the top so this is working perfectly fine okay next up when we are showing the entry let me minimize everything once more the next thing i want to do is that let me run the game again and we have what apple corn automator selected i want to have a cell text roughly here for all of these and if we have corn or tomato selected there should be a by text here and this is what i'm going to create now first of all for that inside of the setup we have to import or well create two more things those two things are going to be the by or cell text surface in here i want to have self dot by text and i want to have self dot cell text both of those are going to be pygame.font.render and again we need three arguments the first one is the text let's leave this one empty for now after that we want folds for the antialias and for the color we want black for the byte text this should just be by and for the cell text it should be cell with that we have two surfaces we just have to figure out when to actually show them that is going to happen inside of show entry specifically i only want to show this when the specific entry is selected how this is going to work i am first going to check if self dot index is greater than self.cell border this is the border we created in the init method right here this one is checking the length of the inventory so if we are inside of the length of this border we want to sell if we are beyond it we want to buy let me add comments here this one is going to be buy and if this one is not true so else then we want to sell actually i think this one is a bit confusing let me do this the other way around so if we are below this we want to sell and if we are beyond it we want to buy and all we have to do now is self dot display surface dot blit and in the cell one i want to display self dot i called this one cell text for the position let's say for now we are going to go with zero and zero and for the buy text this is going to be by text and let's try this one although it's going to look a bit funny and we have an issue inside of the setup method this shouldn't be pi game it should be self.font.render if i now run this again this is working and now in the top left you can see sell sell sell and now we have buy buy buy although for the tomato something did go wrong so we have to make some minor adjustments here but other than that this is working pretty good i guess the problem here is inside of entry this should be smaller or equal if i now run this again we get sell sell sell and buy and buy there we go this is working just fine although the position of the buy and sell text we do have to work on although the position is looking a bit weird let's work on that one and for this i want to create another rectangle let's call it the position rectangle in here i want to have self dot for cell i want to have the cell text and get underscore rect for this one i have to place the mid left and once again i need the left and i need a top the top is the really easy part because i get my background rectangle dot center y for the left i want to have my self dot main rectangle dot left and to this one i want to add 150 pixels i can place the position rectangle in here and this should be working let's try and we are getting an error that this should be yet wrecked with lowercase letters and now we get cell in the perfect positions although buy is still looking a bit weird but that we can work on all i have to do is duplicate this one here paste it in there and now we want to get the bitext surface but the rest is going to remain the same meaning if i run this now we get sell cell and bye bye because i didn't paste the position rectangle in here for the position now this should be working sell sell and buy and buy this is working perfectly fine cool i am really happy with this so let me minimize show entry and the setup all we have to do now inside of input is to actually make the menu do something for that inside of this if statement here i want to add another if statement and now i want to check if keys and pygame dot k underscore space if that is the case first of all i want to activate the timer so self.timer.activate after that i want to get the item so i want to create another variable called current item and for this one i want to have myself dot options and use self dot index i suppose let me print what we actually get with current item and if i run main.pi if i now press space we get wood apple corn tomato corn and tomato this is working just fine now i have to figure out do i want to sell or do i want to buy that is information we can access quite easily because i once again want to check if self.index is smaller or equal than self dot sell order if that is the case i do want to sell if it is not the case so else i want to buy if i am selling it should be self.player.item.inventory and i want to check the current item if that is greater than 0 i want to do something so this should all be an if statement let me copy the entire line here because what i want to do if this is the case this should be reduced by 1. and on top of that i want to get myself dot layer dot money and i want to increase that amount by a certain number this number i'm getting from settings and here i can minimize a ton of different things in here we have sale price and purchase prices for now i only care about the sale price this i want to access and i want to use the current item as the index this should be all we need for now for the else i want to add a pass and just to test this inside of the player let's give the player a couple of items like this and now if i run this again i press enter i have lots of different items i could be selling and if i press space the amount gets reduced and our money increases and let me try to sell all of my wood if i now get to zero i cannot sell anymore but i can still sell other things so this is working perfectly fine so with that all we have to do is to check the buy part and we are basically done in here first of all i need to get the seed price this i'm getting again from settings and there we have purchase prices this i want to get and in here i want to get my current item as the index now i want to check if the player has enough money for it which means if self.player.money is greater or equal than the seed rise then i want to get self.player.seed underscore inventory and i want to get the current item again i want to plus equal one and then self.player.money is going to be minus equal the purchase price of the current item there we go and this should be it let's try so i can still sell things but now if i try to buy things my money goes down and let me hold space pressed and at some point we should be reaching zero there we go now we are zero and i cannot buy any more seats i can still sell things though and now that i have money again i can buy some tomato seeds until i am running out of money and there we go this is working fine so with that we have created the entire menu and that finishes basically the main part of the game all we have to do now is to add some sounds and then we are done for the final bit we have to add the sound let's jump right in this really shouldn't take too long here we are back in the code and what i want to work with let me open the folder here's the entire project and i want to look at audio in here we have a couple of different files that i want to use the main problem is we have to figure out when and where to use them but that really shouldn't be too difficult let's start with the axe for this one i want to look at my sprites so let's open this one again in the sprites i want to minimize everything because i only want to focus on the tree basically inside of the tree whenever we damage a tree i want to play the x sound let me add another comment here play sound basically all i want to do is self dot x sound dot play and that is basically it for that i have to import it this happens in the init method let's call this one sounds all i need in here is self dot x sound and this is what i get from pygame dot mixer dot sound spelled like that the file path we need here is one fold up then audio and in there we have a file called x dot mp3 and with that we should be ready if i now run main.pi and walk towards a tree and hit that one with an x that is sounding pretty good so next up we need to sound effect if the player gets a thing this is going to happen inside of level because in here i have the player add method i basically want to play something like self.success.lay this success we have to import and this happens let's do it all the way at the bottom music this i call self.success and this once again we get with pygame.mixer.sound the file once again is one folder up audio and the file is called success.wav although for this one by default i think it's a bit loud as a consequence self.success dot set underscore volume and in here 0.3 i think sounded good and now anytime the player gets any kind of item we are playing that sound so let's run minded pi and let's say i want to get an apple that sounds not too bad and if a tree disappears this also plays cool so this is working it's also going to play when we are picking up a plant but that takes a while to test so i think we're good for the next tool i want to work on the hoe and for that i want to reopen my soil layer or soil.pie and i want to minimize everything in the soil layer i want to add sounds and in here i want to create self.hoe sound and this one i get with pygame.mixer.sound the file path here is one folder up audio and in there i have whole dot wav this i want to make a little bit less loud though so i want to set the volume to 0.4 and this now if i minimize all of the methods i want to play whenever the soil gets hit so in here let's do it all the way to the top self.hold and with that we should be having another sound so if i now use this one possibly a bit loud i want to change the set volume to 0.1 and now let's try this definitely an improvement it's going to get better once we have background music but i'm kind of happy with this next up i want to work on the watering sound this one is going to happen inside of the player in here all the way at the bottom here i want to add his sound section and this i called self.water ring this once again we get pygame.mixer.sound the file path here is one fold up audio and the file name is called water. this one is an mp3 and whenever we are using a tool and the selected tool is water i want to play self dot water ring although for this one i also want to change the volume so self.watering.set underscore volume is going to be 0.2 if i now run main.pi again select the watering can that's working just fine cool there's one more that i forgot and that is inside of soil besides the whole we also have self dot plant and this one let's call it plant sound actually plant sound once again pygame dot mixer dot sound and in here one folder up audio and this one is called planned and the file ending is a dot wav let me just duplicate it self dot plan sound dot set underscore volume let's go of 0.2 this one i want to play whenever we are planting a seed in here so all the way at the top i want self dot plant sound dot play that way this one will only be played if we are actually hitting the soil if i run this i first have to create a soil patch and now if i plant some seed not the greatest sound effect but it certainly works and all right with that we have all of the minor sound effects the one last thing we have to do is to play the background music and this could be a really good exercise for you figure out where you could play the background music and import it and play it all of this is going to happen inside of level i guess theoretically you could also play it in main.pi but level.pi is a bit more flexible in here i want to import music so self.music and this we get with pygame.mixer.sound the file name here is called well we have to go to audio first and i want to import music which in this case is an mp3 file what we also have to do to play it is self dodge music dot play and in here loops needs to be 1 so that we play this continuously now for the background music i have been a bit lazy because you probably want to change the volume depending on the day time or play different kinds of music depending on what kind of weather you have but well i just have one kind of background music but this video is getting long enough you can work on this yourself but now if i run this now before i finish the entire thing there are some very minor things i do want to change first of all inside of the player if i minimize everything again so we can see what's going on inside of the input in here i have to clean up this self.toggle shop that's the one i forgot earlier here we go and now this one is done so let me close the entire player besides that in the level i want to set the rain to something greater than seven because the rain really shouldn't happen that often this i also have to update let me minimize all of the methods once more in the reset method this one should be like this finally inside of the sprites in here once again i want to minimize everything and in the tree i created an involved timer and this one simply isn't necessary i just mixed up my notes but now we are done with the entire thing this was literally all we needed and let's make sure this is all still running all right this is looking really good so well done if you have gotten this part this was a really long tutorial so i hope you enjoyed it and i'll see you around