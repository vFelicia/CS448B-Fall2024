hello my name is mario um and i'm going to be doing a maybe a nonconventional crash course for you in elm uh i work at travelport locomote um travelport is one of the three major gds's in the world hands up if you've ever taken a flight before anywhere one in three chance we sold you that flight uh locomote what we do is we do corporate travel so those of you that work at a big corporate awesome come and talk to me later we have a great product for you but yeah we do corporate travel management and um we've been acquired by travelport so as you can probably tell by the accent i'm not english british um i come from australia and our company was started in melbourne but with the acquisition i now live and work in london you can find me on github my handle is super mario that is my actual real handle so the goals for what i'm going to do tonight i was originally thinking of doing um the same format that we do at the elm london meetups um which is to actually do a code night you pull out your laptops you actually work on stuff people get in different groups either you're going from scratch and i'm doing a from scratch tutorial or you're working on projects or you might be advanced and helping with open source stuff but i thought given that i've got a room of presumably javascript and react experience developers the more that i thought about it the more i thought about my own journey into discovering kind of element functional programming and the things that prevented me from understanding the value of those things to myself and what they would give me in my kind of daytoday work and i thought it might be more valuable if i gave you a swathe of those kind of things because i found those really hard to find online i mean you control through lots of blog posts and things and try and scrape things together but until you've really kind of tasted um element functional programming for yourself it's really hard to understand some of those concepts so i wanted to maybe instead give you a little bit of a teaser of those things that you might not find so easily and then give you the resources of which there are plenty of for you to just learn like elm syntax and stuff so i'm going to try and cover things that might not be obvious i'm still going to go through a little bit of alum so you've got a bit of grounding but i'm going to talk about some awesome things that um that exist in the elm community that may not be obvious straight away i'll talk about some pitfalls and then i'll give you some references for more stuff um cool so this is an lmap that you're currently looking at some of you're still joining so let's just start really easy how are you feeling everyone's feeling good hopefully awesome uh no one's feeling bad that's great javascript experience zero starting confident or pro pro meaning you work in javascript professionally okay so we've got some people that are zero some people that are starting this is going to be awesome for you for the rest of you you've got prior knowledge that's going to hold you back i'm just kidding elm experience um has how has your elm experience been in terms of exposure or reading or anything awesome we have some elm developers here most of you zero okay great so um hopefully for those of you that are zero this will be informative and useful and help you understand one is elm something that you're interested investing your time in and secondly what it might give you generally okay cool so normally what happens sorry normally what happens with this is um i go through a set of live slides and you've got on your devices a set of reactions so you can give me like you're okay or you're confused thumbs up thumbs down thinking face falling asleep or bookmarks and then at the end of the talk you can put your email address in and get all that stuff back sounds really awesome except i'm not going to give it to you um because i didn't get to prepare these slides in the software so we're not going to use this i'm going to step out of it but this is more just to give you an idea that this is an app that i've used in in past talks um if you look at the elm europe conference you can see me doing it live on stage engaging the whole audience and it's something that i've tried for a number of years to build in lots of other things and i always kind of got to the point where i just couldn't keep pushing further the complexity in whatever language i worked in really really held me back and i think this is probably my best testament for myself personally of what elm can give you as a developer because it's the first time i've actually been able to succeed with a project of this kind of scale so anyway let's uh let's run through uh the president you can come talk to me afterwards if you want to know more about the elm app software so i'm going to avoid these things today because i think that there's better resources than me speaking to you for finding that stuff um so learning detailed syntax um fp concepts as a whole um and looking at comprehensive code examples it's probably better off in your own time and at your own pace so i'm going to avoid that kind of stuff but i will give you um things that you can look at afterwards for diving into more detail on those things so what i am going to go through is i'm going to give you a high level of what is elm i'm going to try and disambiguate some stuff that in my opinion i feel you might run into if you try and learn it yourself we'll run through some code but at a very basic level and i'm going to run through the elm architecture which i think is probably one of the big tripping points that people run into you know this question of is ellen the library is it a language and and trying to figure out what it actually does and how you do things i'm going to try to talk through some some awesome things at least as far as i find them roughly talk about how do i use element work which may be an interest point to some of you and then i'll give you some caveats that i found for myself personally awesome okay what is ellen so by its own admission this is on the top of the elm site elm is a delightful language for reliable web apps you can generate javascript with great performance and no runtime exceptions that's almost guaranteed so in more detail it's a functional language it's statically typed but it has type inference so if you don't want to write types you cannot and elm will still figure out the types view up until a point all data is immutable so there is no such thing as immutable value or reference or object in elm everything's immutable by default that's part of the language you can't opt out of that all functions are pure which means that every piece of code that you ever look at in elm the answer to the question of what does this code do the answer is nothing it takes inputs and it returns a value but it won't make any effects it won't change anything in the outside world it won't ask the outside world of anything it will literally do nothing so every line of code in any lm code base you ever look at has these two guarantees um null undefined and exceptions don't exist they're not part of the platform they're not part of the language you can't type null and have it compile and nothing within your elm code can throw an exception or give you back a null so those kind of things are removed from the language um so the these are all rather intentional choices and they have some really really interesting implications when you when you don't have these kind of things in your or rather when you have these kind of guarantees in your language um it actually comes out to be a very very interesting subset of um of the kind of programming that you may be experienced in already so to answer the question of exactly elm library this kind of gets confusing when you start looking at um stuff online if you're familiar with i mean how many of you using this kind of stack or something loosely related to this yeah cool so you know you get really excited you want to start with javascript like right how do you install packages oh you can't you gotta get npm right okay now i have npm like how do i bundle stuff together like you can't you gotta get webpack cool and then you know react at the moment you're all here because this is reactivate but this is you know a more recent paradigm before there used to be many other choices and spine and backbone and um you know more modernly i guess angular as a competitor but there's a lot of different options there so you have to pick one maybe you pick react then eventually you get to a point where you've got too much local state and your components are trying to send stuff everywhere and you're like ah how to solve this problem and you go oh redux so you learn redux you bring that in now you've got this problem where you know you add a new action in redux and now you don't know all the parts in your code that need to be updated so maybe you get something like typescript to flow to bring some level of kind of checking to figure out i've added stuff here and now my code breaks over here so you kind of bring that into the language then you get to the point where you're like oh you know mutable references are really killing us we're passing objects and accidentally setting methods on them and losing control of our state so you go well maybe we need to bring immutable js into a stack so what's the experience like when you start elm well you go well how do i get packages well that's built into elm yeah cool so how do i get all my files compiled into a single version that's built into elm you go okay so how do i actually architect my code how do i do the view layer and all that kind of stuff well that's actually built into elm so you go cool so how do i manage my state when it gets really big that's built into elm uh what about type checking and flow that's built into elm and immutability as i mentioned is also built into our so the analogy i've been trying to use recently for this is when people say oh well it can't be a language that has too many features it would probably be i'm assuming um similar to originally when memory management was all manual and you're a c developer and something like javascript came along now like we have automatic memory management now you're like so that's a library you're like no no it's a language feature and like i can't be a language feature like that's too featureful um so this is kind of the same in that same sense so when we say that elm has these things built in it's not built in as a library that you use it is actually the language so there's only one architecture in elm it's called the elm architecture there's only one way to structure on that initial set of code and that's all baked in all the libraries that you build in are for various other bits and bobs around is that making sense getting some nonsense lovely um now it's not all in isolation there is kind of like a lot of cross flow and lots of lots of the stuff that's in that react stack if you're already familiar with it lots of stuff in elm will just seem really really natural um so this is just a quote from the um dan abramov the author of redux who has quoted as pulling certain ideas back from elm so if you use redux you're actually using a subset of the same kind of function that that operates in elm so that kind of stuff will come natural to you um the the difference i feel though is that here you've got a lot of disparate components with lots of different authors different styles and different integration points whereas in elm the whole ecosystem is built around the premise that the call language has these functions so there's a huge amount of effort put into them working together really really really really nicely so a lot of the pain points that you may see on the left hand side when you kind of come over to the elm side um my experience has been those pain points are either way reduced or just nonexistent um in that kind of environment so let me let me uh dive a little bit deeper into that side note let's just take a slight detour and then i'll come back um there's a personal bug bear of mine and it uh maybe it won't be the same for all of you but it really impacted my ability to learn functional because when i came up against these two things i was really defensive of my existing experience and a bit insulted that there could possibly be something that i didn't already know in programming so for me it was really humbling having to probably battle through a year worth of selflearning before i got kind of past these concepts and i think that they're needlessly complicated especially has anyone here tried to learn haskell or idris or any other kind of functional languages well i'm hoping your experience is better than mine but you know like space burritos and homomorphisms over funk to monads and it's kind of like the mathematics and the language and the kind of tone of that community is really really are really difficult to approach so i just wanted to kind of debunk two things that hopefully will help you separate hype from understanding a little bit more so two things unbreakable and functional um so what do we what do we mean when we say breakable yes i know it was a bit of a clickbaity title saying building unbreakable software um let me give you two statements first statement being is the sky is green most of you probably think that's wrong but like what if we're riding a computer game you know and maybe the sky is green or what if we're in the northern hemisphere and it's night time so this guy's green for those reasons uh might be wrong might be not like this is this is about semantics right this is what our job as program is is to take models of the real world and understand their semantics and then emulate them in code and we can get that wrong and probably unlikely for quite some time that anything's going to automatically replace that right because that's the thinking and the logic that really matters say for you know our ai overlords in the future uh here's the second statement this guy is uncaught type error cannot read property color of null anonymous this is broken i don't think you would ever want to have this feature i mean unless maybe you were writing like ironic javascript poetry or something but like this distinction wasn't really clear for me until i worked with functional programming because for me this was kind of normal life right like you can't avoid this this is what programming is this happens all the time it's called a bug and you fix it and you kind of move on and the premise of functional was yeah you can like you can just not have these in your life at all um and that kind of i really really struggled with so the reason i struggled with that is because of this definition functional will not save you from semantic incorrectness but it can save you from things that are actually broken we don't necessarily need to have these in a language the second thing um that i wanted to side note on was this whole notion of functional you know people say oh javascript's functional um that's not not true but the premise is that javascript has both functional features and imperative features and in between those two kind of paradigms there are actually some compromises yes you can draw good ideas from both things but ultimately one of the kind of premises of functional is functions and the mathematical sense where functions don't do things if a function does something we then define that as a procedure so straight away the fact that you can take imperative features and sprinkle them anywhere you put yourself in a situation where there's compromises and fp practices really require discipline so this is why you know especially redux is a good example of that people who maybe are new to the react stack and haven't used redux before and drag it in because they think that that's what they need as a baseline and it turns out maybe they don't yet need that now they're doing all these crazy things all over the place and trying to manage all this i'm kind of kind of a boilerplate um for this alleged benefit of fp while simultaneously having the ability to escape hatch and do their imperative stuff and i think you know path of least resistance the temptation is really really hard to do imperative features so i think my experience has been that functional features are really amazing learning them helps you think differently but ultimately wherein you're where you're in a code base especially under commercial pressure or time pressure you're going to compromise and do the imperative things um in a functional language as i define it uh you have functional features and that's it so there is no back door fp practices is the default you can't accidentally mutate stuff you can't accidentally do effects because it's kind of constrained so the premise is not to infantize a developer and say oh you can't manage this stuff but actually to say hey maybe when we don't have certain things here it actually helps us write better code right faster with more confidence and that's true of what i've found in l okay enough talking should i show you some code yeah okay so like i said i'm not going to go into super detailed examples but i'm going to give you a basic counter so that you see a full complete could deploy to production piece of elm code and then i'm going to use that to talk about the elm architecture that's powering things underneath does that make sense cool so i'm going to step through it and i'm really sorry i hope that you can all see um is that okay for everyone or is it struggling half nods okay um so uh at the top of a elm file um simply open a new elm file call it app.elm or whatever you want um we're gonna put module main exposing the syntax for dot dot means that we're exposing everything in this file we could choose to expose only certain functions if we were writing like a little library module but in this case we said wildcard just include everything we're going to import some stuff from the core library i'm going to import two things from the html library i'm going to expose uh four functions remember like i said before they're all functions they don't do anything they return values so beginner program um takes a bunch of parameters and returns a program value that l will run um button div and text are all functions that take a set of arguments for attributes a set of arguments for children and they return a virtual representation of what that markup might be that's all i kind of need and the onclick function will take a message type that i want to trigger and it'll give me a tribute that i can put in an element so in every elm app you'll experience at the basic level we write four things they are the only four things we ever write so once you learn these four things you can approach any lmap and immediately know where to start and what to look for so the four things are our initial model which is our initial state a type we're going to call it message you could call it whatever you want but we're going to call it message this is going to be um so if you know redux this is an action so all the actions that our app supports um we're going to write so they're the two they're the two models or the two two values that we're gonna write and then we're gonna write two functions one is an update function this update function will receive at a given any given point in time a message and the current model and what we need to return back is the new model based on our business logic so all of the business logic for an elm app sits in this function just one place then we've got the view and the view is very similar to what you might ex might have seen in react except here it's explicit it explicitly takes in a model and we will return to markup so let's go and implement that so for the counter we're going to start our counter with a value of zero our whole model is just going to be a single integer our model could be anything it could be a hash type with lots of things in it which is normally what you'd get to in a bigger app but let's just start with um just plain old value um for the message type uh or we want to be able to sorry i didn't actually show you the the button that we're sorry you're going blind uh so this is the this is the app that we're going to build so you can plus plus on the counter minus and we have no guards in our business logic so you can go negative cool okay so if you think about that up in terms of the actions we have we really just have two actions we want the counter to go up we want the counter to go down so we're going to just create two two types here in the message type so message is either going to be increment or it's going to be decrement i'm not going to stress this too much because it takes a little while to kind of learn this concept but you can kind of think of this a bit as an enumeration for now if that makes it a little bit easier or you can note that uh boolean has exactly the same type signature so type boolean is true or false where true and false are the actual values that get passed around you don't really pass around boolean does that make sense so increment and decrement are two actual values they're kind of like labels they're labels that we can pass around and they'll be type checked so we can't put a label that doesn't exist someone that doesn't exist um okay so our update function usually 99 times out of 100 we will start with a case and a case is as you would expect the messages of the message type so we're going to case on increment well if we're incrementing that's the message that we received um we're going to return model plus one if we're decrementing we're going to return model minus one and our view is going to use our functions so let's focus on this middle function first so you can see that the divider has no attributes so putting nothing in the tribute it's just the plain div and as its contents we're putting a text node so that's just a root text node with no wrapping and we're putting a two string of our model so model is an integer two stringed into the text version that's gonna be text node so that's gonna sit in the middle before and after we're creating two buttons the buttons do have attributes one has an attribute of onclick decrement the other one has an attribute of onclick increment and then they have the individual text nodes that they're showing and then those all those values are wrapped in a div that has no attributes and that's what we return back is everyone comfortable that they understand on a high level what this code does syntax aside for a second this is the last line that stitches everything together so elm always looks for an entry point called main and in main we have to give elm a program value so it's a value that describes how our program functions so what we're what we're doing here is we are taking the beginner program which is the the function that we've got from the elmcore library and it takes a hash that has three parameters or three attributes in it a model a view and an update so literally the stuff that we've just written the four things that we've written save for the the message type and we say to um okay well this is what our state looks like here's the initial model take that away lovely um here's the view function that i want you to run for me and whenever there's a new model and here's the update function that i want you to run for me whenever you get a message so the net outcome of that is um this little app and as you can see heading plus is triggering that message minus is pulling it back down um yeah okay any questions at this point more comfortable all right i'm just going to bang on the point a little bit um so that view function that we wrote takes a model and it returns something a value called html in elm it is an actual html similar to the way that react does it because ellen has a virtual dom implementation so it's efficiently checking for changes and things like that and managing the dom for us we don't go anywhere near the dom we just tell elem well here's what a markup should look like for that state you gave me so that's that's always a new set of html the update model works similarly it gets a message in the current model we do whatever logic we want make whatever changes we want to a new model and we give a new model back we can't mutate that old model so i'm going to try and visualize it again in another way and hopefully just just really syncs it in so here's our home runtime which we don't control the l runtime happens outside of our control we simply gave it our initial model we gave it our update function we gave it our view um so now we've compiled that we've booted up our javascript in the browser and our app is running so we've clicked a button which has fired one of our messages and remember that markup can only have the messages that we defined in our app if we typed any other kind of message there that was unhandled that would fail at compile time so the browser is going to give us a message type and it's guaranteed that that's going to be a message type we know about so the runtime is immediately going to do two things first it's going to send that uh to the update function call update function and get back the new model and it's going to go cool i'm going to retain that model that's the new model now then it's going to go right view function here's the model get me back that html great i've now got that html and it's going to do the virtual dom differing calculate the dom differences and actually communicate that back into the layout they're unhappy so far with that nods but like more furrowed brows now hopefully furrowed um because you're thinking well this is really nice mario but how do you actually do anything with the outside world um so like i said before the guarantee that we have when we're looking at any elm function in code is that it's not going to be doing effects so say we wanted to um write a little app where you pressed the button and it fetched a new gif of a hilarious cat animation right so when that button is pressed we would like to send an ajax request or a request to a server to get a new url and we'd like to get that request back and change it well actually it functions in exactly and exactly the same way as the browser so what we write in terms of our app doesn't change we still only have four things we have the model we have the types of messages that we can expect we have our update function which has our business logic and we have the view except what happens now is when um that message type comes through um this kind of upgraded so this is html.program we're on beginner program we've gone to program now so the type signature changes slightly um update function now returns two values instead of one so instead of just returning the model it now also returns an array of um what in l are called commands they're values that represent a command that elm may execute for you later so you can kind of think of it like promises that you cannot resolve there's no mechanism in elm to actually resolve commands yourself the only way to resolve it is to hand them back to the elm runtime so let's say we we'd done this and our request has uh we've asked for elm to do a request for our cat gif well in the meantime elm goes yeah that's nice but i'm gonna i've got a new model i'm gonna run the view and we're gonna put that stuff back in the dom so that whole process happens instantaneously then at a separate asynchronous juncture elm may choose to take that command into what is called an effect manager so elm has an implementation of a certain set of effects that the language supports um http requests to one of them and it will execute that command now when we issued that command what we had to issue along with the command is an instruction to elm of what message type we wanted to get back and so then elm deals with the busy work and the possible failures and the nils and all that kind of stuff and it'll only give us back welldefined conformed guaranteed actually okay messages if they happen to exist yeah so what the effect manager will be doing is it'll be sending back a message note that this message and this one here are the same exactly the same mechanism let's take it in isolation so imagine that that whole loop has happened and we've got our new dom and now asynchronously the effect manager has has triggered a command for us so there's been an event let's say we've successfully gotten back our http request so the message that we've defined which is a message in our update function that accepts back the specific value that we're looking for will get called for us the same thing will happen again just exactly the same route like as if it come from the browser we actually don't know where it's come from i mean it could have come from the browser it could have come from an effect manager we only know by the semantics of the messages the action types that we've implemented um model html view gets run again and the dom gets output so that same mechanism kind of works through for both versions that is the most complicated thing that i ever had to try and figure out with elm so i'm really hoping that that that um unlocks a lot a lot of the runtimes perhaps my favorite thing about elm is that it has the best pair programming buddy i've ever worked with mainly because they have no attitude and they're never wrong and it's just really really pleasant you don't have to talk to anybody like the the compiler just kind of yells stuff at you so i'm going to give you some nice canned scenarios first um just so you see the kind of quality of elmera messages um okay so the first one i'll show you is this name okay so here we've got um soon um here we've got an error from elm and uh this is how it would come up in your console so you could have a live reloader going and it's you save your file and it and it's i'm spitting stuff out or i have it directly in my editor and ellen said hey i've detected an error it's a naming error i can't find the variable list.nap you've lose this as an app a list does not expose nap maybe you want one of the following list.map any map to map three so it's not a heuristic search on on the name which is really nice so it not only does it tell you what's wrong exactly where it's wrong give it a little indicators to highlight specifically on which area of the line it's wrong it also gives you suggestions for other things so this is a live code example that i've just reloaded getting a little bit more advanced than that uh here we've got um an if statement we've said um if n is less than zero then let's return the string negative uh if n is greater than zero let's just turn the string positive otherwise let's return 42. um so elm here is telling us well you've got a type mismatch here the second and third branches of this if produce different types of values the second branch of this type is a string but the third is a number and then it gives you these hints these these are the best thing by far so that's the uh that's the nice can scenario which is what normally gets talked about in talks um so i figured it's probably better to show you where elm really shines in the worst possible scenario luckily i have the worst elm codebase known to me which is my own codebase and i'm just going to go and arbitrarily change something in the in the application that you're all using on your phones um to try and just give you a little bit of a sense of what it's actually like to do mass refactorings in elm so here we've got a foreign code base um that we've we've never been in before and it's got like tons and tons of code it has no tests like nothing like just you know like absolute horror someone at work has like gone full crazy on elm they've just built all this stuff and they've quit right now it's your job to deal with it and you're like you're ready to like quit your job and you know you're like on stack overflow looking for other stuff and you're like all right uh i remember mario said some stuff like i should recognize the cell map um you got app.um i'm gonna start okay so we've got a program with flags um thing here and we kind of see like okay um init update and subscriptions and some stuff is here um and we've kind of got this types thing here so it seems like uh types is let's say we need to extend this app right we want to we all want to add a new page to the presentation software so we go okay cool well we know that in elm to add a new page we probably need to find a type for that page or we probably need to find the actual core message type that represents all the actions that can happen and add something there so say we go into types we look through we've got type page type aliases we've got things oh here we go type message we go cool so this is all the stuff actually all of the things that this app does there's nothing this app does that isn't here like let that sink in for a second it's a code base that you've never touched before and immediately you already know everything that it does so let's say we go okay my new awesome feature is the new label like when you click a button it's going to trigger my new awesome feature which is going to be amazing and we save this and what we get from what we get from elm basically now is a pair programming buddy that intimately knows the whole code base and has in a split second gone through and checked every single file every single include anywhere that this type might be used and immediately started coming back with errors so the very first error that it's given us is saying well your update function which is in another part of the code remember the update function is the main function with all our business logic saying that update function doesn't cover this new feature that you have you need to go and add that in there so we'll say okay cool where's that update function it's quite a long update function so we're going to scroll to the top like i said is you know like the worst the worst possible code okay so it says state.m and here we go we've found our update function so let's kind of scroll to the bottom of it all the various things remember like worst worst worst possible code um my awesome feature and uh let's just say we're going to return the model as is and we're going to turn command. we're just not going to do anything right it's going to be a noop now it's saying well can't find pattern my awesome feature why not because it's called my new awesome feature yes thank you pair programming buddy i've made that change now and only saying okay that's pretty good that's good that is all you needed to change nothing else in the code will break you didn't make any other side effects nothing else depends on that new feature you've added you are 100 a okay to deploy this to production so that for me is like chalk and cheese difference to the kind of development that i have day to day so much so that i'm finding it increasingly more difficult to program in other languages without these guarantees just because the level of uncertainty that you gain by working in a language like this kind of really decreases your confidence in other languages so i find myself now when i interrupt with javascript and elm and i'm working with javascript stuff you know with elm you you you write stuff and you compile it and it's wrong and you change it and it's wrong you change it again elm's like no you're wrong and you fix it and it's green you're like well it looks like it's pretty good and in javascript you change something and you're like where's the thing that tells me ah maybe it's okay i don't know like you gotta potentially now go write tests do your tests cover every single case potentially not so the wrong and broken difference that kind of broken bit just kind of disappears but the wrong bit is still your responsibility everyone's somewhat satisfied with the real life example okay cool very quickly i'm ending off with some highlevel stuff so um lm packages have auto semva um so again when i talked about uh the nice side effects of having enforced purity and um side effect free code elm can look at your library and all the type signatures that you have exposed if you have changed no public interfaces l will minor version increase if you have added a public interface it will the middle version increase and if you have removed a public interface it will major version bump your code you can't change your own version numbers in elm packages it just does it entirely for you the flip side of that is when you're pulling down new package updates elm can automatically or you can safely pull in minor and intermediate versions because you know that they haven't fundamentally they shouldn't have changed they wouldn't have changed any of the interfaces they may have changed some behaviors but generally it's a lot safer and if you're dealing with a major change you know that something's going to be removed even still bringing that package in with a major change you're pretty happy because the elm compiler will then immediately tell you every single place in your code base where your usage of that package is now broken so you still have the protection and optional choice on whether you want to engage in that work or not but when you do upgrade it gives you like a bucket list of exactly how to upgrade which is pretty awesome the elm packages site if you want to kind of look at the kind of packages that exist in the om community they're on packages.online.org yeah check it out there's so much more to say there compiling elm so i haven't talked about how elm actually works in terms of compilation so like i said even though it has all this library stuff it is fundamentally a separate language that has its own runtime um so it's got its own compiler so you take you write a bunch of elm files and they run through the compiler and you get compiled javascript that includes both your code and the runtime and all the libraries and everything to do with it all kind of packaged up if you're in a project that has javascript files already you're probably going to want to pull in elm incrementally um into certain bits to try it out or to have kind of some interrupt so the very very simple way to do that is through webpack webpack has a elm webpack loader which will simply allow you to require elm files directly and then mount that elm app to whatever node you actually want that to attach to and then run the rest of its stuff through uh how do i use element work uh the answer is gradually there's actually a blog post by um the author of elm himself his name is evan um and he he talks about the incremental approach and also um what he's seen in his experience of the the number of years that he's been um improving elm for on projects that have succeeded and yeah generally the premise is that you take a small area of an existing app um or or if you're starting from scratch if you have that luxury and you can just try elm out in a very small section and experiment and see if it meets your needs and if it works well enough for the domain that that you write in and then if it does you simply just take more and more chunks of that tree or put elm in multiple places around your app so for those of you that are using react there's a kind of like a canonical example um by evan himself of uh react components um so very simply you're importing uh the elm uh elm wrapper for reactant components you're importing your lmap from wherever it might be like the compiled code and then you can just put that straight into a react render function there's a very simple example there's more complicated examples where if you want to pass some values of mlm initially or if you want to actually talk to and from that application um but all of this is like a 20 line wrapper it's really really simple so just with plain javascript you literally if you're using the l modpack loader you're requiring that javascript that um you've written and you can just embed it to a node that's the only attached point to get started cool cavetts general purpose programming language gets kind of thrown around a lot so something that i again i got cut on so i kind of want to put out there elm doesn't run on the server side yet it's not a serverside language and it's not a general purpose language you could run it on the server if you really wanted to i'm in 0.19 the next version there may be some serverside rendering stuff because a lot of people have been asking about that um but there is a really really good document about general purpose language written again written by evan um that i would recommend reading if that kind of infuriates you for some reason because it's actually really clear and articulate on why this kind of premise doesn't really exist so you know we might say python is a general purpose programming language but you're not going to go right assembly in it we might say c is a general purpose programming language but you're not going to do web development in it so general purpose languages do still have specializations so elem is the same in that sense it's specialization really is to be really awesome at frontend apps uh fiddling with a dom you're gonna have a bad time uh if you really really convinced that you really really need a fiddle with a dom or you have some application that for some reason are doing something with external libraries and pulling in markup and all that kind of stuff um that is not something that elm allows or is any good at really um you can still achieve what you wanted if you talk the reports to um some javascript kind of interrupt but on that side as well java script interrupt is really really strict in order for elm to preserve those kind of guarantees of runtime safety and not exploding on you the way that it talks in and out of javascript is also through a really strict typed interface so it makes sure that the types that come back are actual types that your app can handle and keeps anything else out so kind of all the javascript errors stay on the outside and the arm stuff stays pure and yeah this one's a little bit cynical but you you legitimately may be more frustrated with other languages at least i have been uh cool thoughts after two years of functional programming uh it's not a silver bullet i'm not claiming that um this is the solution for all problems like i've said before i'm not suggesting we go to linus torvalds and say hey let's rewrite linux and elm but i think if you're doing web development um and you're writing web apps which is specifically what um almost engineered for i think it trades off for better problems um the constraints that it gives you it's kind of like lego um if you've played with lego as a kid um you probably didn't think man i really wish i could just put glue and and wood sticks and and cut the lego pieces in half right you just kind of go ah they snap together and suddenly can you build all these kind of things so for me fp is that same kind of thing i don't see the type safety i've never felt it to be a restriction it's just been kind of like an enabler um but if you really really need glue and sticks well then use glue and sticks um i'm yet to see a broken run time i haven't seen one yet there are various edge cases that can cause them you can look them up on the online tracker i think they've gotten them down to like four or three now elm reveals your mistakes so as part of a previous talk i talked about why l made me realize how terrible of a programmer i am it's actually a positive because it improves your code overall but it it kind of does show you like i said before it lowers that confidence that you have in other languages because it increases your visibility of just how much you're not seeing that you're not catching um and refactoring is really awesome i before the last presentation that i did this live talk with i decided to change something from a single field to like an array like i had a one of something and i wanted to have a multi of something and i changed it and it broke the whole code base because my whole thing had been built with a premise of a singular relationship and 15 minutes before the presentation i was like yeah why not ah let's dive in managed to get like all the stuff checked off and all changed and compiling and deployed it and went flawlessly um so my experience with that has been that at a baseline level in the worst possible scenario writing the most terrible code with no tests you still end up in my experience better off than other languages that don't have these guarantees and you do have those kind of tests okay further reading watching uh the elm guide is kind of like the canonical intro um it'll teach you all the stuff that i've violently skipped over like actual um syntax and the type of values that are available and some of the library functions a lot of this talk i've kind of ripped bits and pieces out from kevin yank who does a much better and more eloquent job with much nicer slides and so check out developer happiness on the front end with elm especially if you also work with rails you may find that interesting and then two uh talks recently that i think really address um two problems that that kind of people run into um when they come to um because it's such a different paradigm is you your app gets larger and larger and you wanna scale it um or you you start with a file and like me i kind of started with my first file and once i got to 100 lines i was like oh this is bad 10 files and like modular structure and all this kind of stuff and and so evan talks about why that's the the reasons that we do that in other languages aren't actually present in elm so it doesn't make sense to do that so he talks through a really beautiful example of those kind of assumptions and how they fall over in the life of a file and growing kind of modules out and then richard feldman talks about scaling lmaps until much larger extent richard works at a company called no raid inc and i think it's 200 000 lines of elm code in production they have and their claim is that they still haven't had a single runtime exception so i think that's that's pretty cool so if you want to see either of those kind of things take it from the horse's mouth there um that's all i've got thank you