hi this is nick karnick today we're going to talk about react component life cycle react lets us define components as classes or as functions a component class can be defined by extending react.component the only method that is required in a component subclass is render as you can see in this block of code components have several lifecycle methods that you can override to run your code at a particular time in the process these methods are categorized into four groups mounting updating error boundaries and unmounting in this example we will build a counter component and utilize all the lifecycle methods let's get started with creating a constructor a constructor takes props as its object and we need to call the base class or the parent class method via super and pass in props what this does is it sets this dot props to props so it's available throughout our class constructor is also the only place where we can set state so let's go ahead and set a counter and let's use that in the render method all right i also want to have the console open here and while we're looking at the console i want to make sure i'm printing messages in the various functions as well so you can see the we can see the progression so when an object is created the constructor is called followed by render let's give this some functionality to increment and decrement the counters so i'm going to create a couple of methods here increment which will set state on the counter and increment it using the previous value and add one to it likewise decrement will decrement a value on that right here okay and let's create a couple of buttons to allow us to increment and decrement this we're going to assign these methods to one of the events for onclick and let's replicate that for decrement oops there you go now when we click this we're going to see the counter reflect the change and notice that all that's done right now is calling the render method so let's introduce a few life cycle methods the first one is component did mount this is called right after render now when i save this we'll see things we render and what i want to do is also add markers at the end of some of these render life cycles so we're just going to add a dashed line so we know that this is a single render call and if we were to do increment there is another render call but it does not call component in mount because that is only triggered when the component is constructed and essentially gets added into the dom however there's another method called component did update and this method actually takes a few parameters there's a reference to previous props the previous state and snapshot let's trigger component did update and we'll add a log statement here all right so notice that component.update is not called here once we click increment we'll see component did update i'm going to add a line marker there as well so we know that's another render so if i click this you see the different sort of life cycles that are triggered all right so let's go ahead and add the ability to mount and unmount this counter we need to do that in app.js so we're going to create a constructor here with props that are passed to the parent and then set state in the constructor to with an attribute called mount which we'll set to true and a couple of methods to mount and unmount the counter we'll set state here to set mount to true and likewise uh this will be on mount counter where mount will be false let's go ahead and create a couple of button elements mount counter and map it's on click to this dot mount counter and replicate that for unmount counter okay so another thing i want to do is set disabled to true or false depending on the value of mount all right so notice that the buttons just grayed out now if i click on mount and mount you'll see that some lifecycle methods were triggered all right but one of the things we forgot here is to take advantage of that state variable so i'm going to use that and conditionally render counter and if it's not set to mount we'll remove it from the dom all right so there you go so now this should actually remove the counter let's add another life cycle method encounter this time it's called component will unmount as the name suggests this method is called when the components being taken out of the dom let's add another marker there and there you go so now component mount if i click on mount counter you'll see component will mount was triggered and there you go uh on mount the constructor is triggered because the counters com the counter component is recreated these are the most commonly used lifecycle methods let's shift focus into some of the infrequently used methods we have another method called should component update which takes next props and next state as its parameter parameters sorry generally this returns true by default the purpose of this method is to let react know if render should be triggered or not normally react does a very good job at figuring that out but sometimes let's say your state or props gets updated and you don't really need render to be triggered because you're not changing anything on the ui and especially if your render method is a bit expensive to compute then you can definitely gain some performance here but you need to be careful here because you could fall into a trap where you end up losing performance if this method is used incorrectly let's add a prop in app.js that we're going to pass into counter which we would want to ignore okay so let's call it ignore prop and whatever the value here is let's say it's zero initially i'm going to create another method here to pass and ignore prop by generating a value and assigning it to state so ignore prop is uh just add the random we don't care what the value is what we want to do next is pass that prop in to the uh counter so we'll pass an ignore prop equals this dot state dot ignore prop okay and so that should pass this through but what we also need is a button to trigger that change so let's call this ignore prop and then on click we will call this dot ignore prop okay there you go so now when i click ignore prop it's going to call render and component update mainly because something changed on the parent and that was passed down to the component but in this case let's say we don't care about ignore prop because we're not doing anything with it we're not rendering it to the ui so we simply want to ignore it that's where this method comes into the picture so we'll create a condition here to check for when it's appropriate to tell react not to call render we're going to store this in the state and call it ignore prop if uh there is an ignore props value and if the one in our state is not equal to that value we want to return false basically any time ignore prop comes in and if the value doesn't match what's in our state we want to return false so it's it's still being called here that's mainly because we should check this dot props so we're looking at whatever is in our current props and if next props is different then we know ignore prop was changed and in that case we don't want it to render anything let's add a console log here as well all right and click ignore prop call should component update is called but let's look at this so it's going to render for some reason we're checking if the value exists and if that value is not equal to what's in our props if that's the case we do not render perhaps we are looking at something incorrect here let's see ignore prop has been passed in there oh this should be ignore prop that's the issue all right there you go the next thing to look into is a method called get derived state from props this is a static method and it's called before every other method and this passes in props and state and the purpose of this method is to give you a chance to copy any values from props that you may be interested in transferring over to state and in our case we could add a another uh method here that allows us to pass in a random seed value so let's say we start off with uh our seed being some arbitrary value here and what we can do is add a seed generator method which is simply going to set state to set the value in seed to an integer so we're going to parse end and do math random times 100 to scale it up and that creates a method for us and we also want to pass in seed here from this dot state dot seed and also create another button here then maps to c generator so we can call it generate seed all right and i think the error we were getting earlier here is that we don't have a return statement so anything you return from here gets assigned to the state so if you don't want to change state you simply return null all right so now when i click generate seed let me lower this nothing seems to happen i mean we see some life cycle methods getting triggered here but it's not really taking advantage of the seed being passed in so let's take care of that in this method here so we want to check if a seed exists on the props and if the seed that's in our state is not equal to that seed that's passed in if that's the case we will return a seed value that's props that's c and it set the counter to props.c as well and let's just uh default it to zero here in this state notice that counter starts at 40 because we had set the initial seed value to 40 here so i can click increment and decrement and this continues to work but i could also click generate seed and that should change the value of counter here all right but the point here was to demonstrate this lifecycle method that allows us to copy props into state notice that since this is a static method we don't have access to the instance of the object there's one more or a couple more methods we need to talk about so the next one is called get snapshot before update and that sort of goes right before render and it takes in previous props in previous state and then we return a value out of this this method is to allow us to capture some properties that are not stored in the state before we rerender that component so let's say you had a list view or or a text area where the cursor was in a certain row and column or if the list would scroll to a certain location then you would be able to capture details about that and then handle that later on so whatever is returned here gets passed into component.update as a third parameter called snapshot and that's where we could tell the dom to sort of set the cursor and the carrot in a certain place and things like that so that that's that method and finally there is a method called component did catch which is part of the error boundaries group and this takes two parameters called error and info essentially it gives us a chance to gracefully handle you know any errors that we run into all right so let's go ahead and call ignore prop and also when should component update do not render is called we want to add one of the line markers so we know that's the end of the update and let's call generate seed and then we can still increment and decrement unmount and remount it and now let's generate a component that's going to create a deliberate error so let's call this error component and we're just going to return a div with it accessing some nonexistent value and this is going to cause it to crash so let's say we add it into counter right now so i'm going to place that error component here when i save you'll see that there were errors that were triggered here now if i did not have component that catch when i save i lose everything that's rendered in the browser and so i could have a downstream component that generates an error and it's not handled properly and it causes the entire app to go into sort of this blank screen so that's where component did catch comes into the picture it allows us to gracefully handle some of these so what i'm going to do is once we know there's an error we're going to set state and set the error and info properties on it and let's handle those here as well and render we're going to check for an error being present in that case we're going to return a div that says we have encountered an error let's try to print this out as well the error has some additional attributes that we need to print so what we can do is just print that out here to see what error contains and then we can revisit this there you go it is rerendering but the error is is right here so let's go ahead and look for i believe it's a message there you go let's take this out and all right so we were able to handle our error gracefully without everything else crashing and that's sort of the purpose of this method here let's let's trigger this conditionally so what i'm going to do is add an attribute to state called show error component and we'll set it to false to begin with and we're going to pass that here show error component equals this dot state dot show error component and everything still loads but internally here i want to make sure that we're looking at props to see if show error component is true in that case we can generate this just actually made up entirely just so that we don't run into this and we can get the counter again as we uh toggle this so we'll have to add another method here let's call this toggle error and we're going to set the value there for show error component and we're gonna set it to negate it to whatever it's set to and that should actually uh be called via button here so let's add that in toggle error and we'll just call this toggle error and so i think yeah there you go now as we click this it's not reversing so let's take a look at that um i see what's happening so this this part works okay i think the issue is with state.error because we are not clearing that once we set it here the component ends up rendering the error over and over again so all we have to do is look at if props dot show error component is true and if we have an error in that case there you go now we should be able to toggle this let me do a quick recap we have the constructor which is called when a component is created followed by get derived state from props which allows us to copy props into state this is not used frequently but there are cases such as this one here where we want to pass in a seed for the counter and have that be controlled internally through the state that's when this method is useful we have component dead mount which is also an interesting place to do things like network requests or handle like the initial loading of the component for instance if we had a value that said initializing to true by default and based off of this value if we were setting a specific if we were showing a specific message we could sort of simulate um oops let's say we were simply returning initializing right so in this case we're going to see that method there i think find the div it's going to show it on the next line there and essentially you know let's say this is when the component loads initially it's in the initializing state we need to fetch some data and that kind of stuff would happen right here let's just simulate this dot set timeout and call a method there in about let's say uh 500 milliseconds so you'll see it flash briefly and we're going to set the state on uh initializing to false sorry i meant to do just set timeout there initially i was thinking about set state so there you go if i were to refresh this notice you see the initializing followed by the counter showing up so that's sort of the purpose of this method where you could make a network request and when you have your data again you can change the state on your component and tell it to you know maybe perhaps show a spinner while it's loading content anyway while we were doing the recap so after component did mount should component update gets called this is where we could hint to react uh do not uh call render all over again i believe in the future that's how the method is going to work it's simply going to be a hint and react will decide if it wants to actually honor that or not and this gets snapshot before update which allows us to store things like positions of your list views or or you know text areas or whatever uh dom components that you can then pass on to component data update and reassign those after the render render of course takes care of rendering content component data update gets triggered right after render now this is also similar to componented mount if you wanted to make specific network requests based on certain attributes or props or state values you could do the same here you can actually call set state in component did mount and it triggers a rerender but it doesn't actually call the render method twice it only does it once because of the location where it's called under and finally this component will unmount that gets triggered when the components removed from the dom and component did catch which helps us sort of gracefully handle errors and downstream components lifecycle methods or or render method and that brings us to the end of this video hope it was useful and if you'd like to stay up to date with future videos consider subscribing below thank you