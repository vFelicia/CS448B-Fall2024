dynamic programming is a method for solving complex Problems by breaking them down into simpler overlapping sub problems and storing solutions to these sub problems to avoid redundant computations it can help you solve complex programming problems such as those often seen in programming interview questions about data structures and algorithms Alvin zablin teaches this course about dynamic programming in Java he has multiple super popular algorithm courses and he is a great teacher hey programmers Alvin from structure here Welcome to our course on dynamic programming in Java this is one of the most highly requested topics from free code Camp students so I'm super excited to explore this material with you in Java so if you're looking for a really thorough exploration of dynamic programming exclusively in Java you're in the right place of course that means all of our code specific walkthroughs are going to be in the Java programming language as for the format of this course we're going to build our dynamic programming knowledge by exploring a sequence of problems the problems are going to start simple but it's really going to give us the foundation we need to eventually solve some very tough dynamic programming problems in this very course for every problem we work through we're going to solve it using two steps the first thing we're going to do is head to my whiteboard where we'll come up with a strategy and really try to visualize the dynamic programming nature Behind these problems so after we draw things out on the Whiteboard and get a really confident understanding of the structure behind a particular problem then we're going to head into my editor where we're actually going to code up a Java specific solution alright so that's enough introduction for now what I want to do is hop into our very for section on our exploration of dynamic programming we're going to work through and frame our Fibonacci problem through our dynamic programming lens hey programmers Alvin here right now I want to work through this FIB problem of course we're referring to the classic Fibonacci Sequence this is a really really important you know computer science problem and to me it serves as the foundation to really unlocking a few harder Concepts down the line so even if you've done this FIB problem before it helps to review it together right now we're gonna see this core pattern uh show up a lot during the course together and so let's start by understanding what we should do in this problem well we know that the Fibonacci sequence has a few certain seed values we say that the first number of the sequence is zero and the second number of the sequence is one and then to generate further numbers of the sequence we just take the sum of the previous two in other words I can take zero plus one and that gives me the next number one right so the sequence starts zero one one then from there I continue this pattern right I can take the one plus one that gives me two I can take the one plus two and of course that gives me three and so on so forth and of course I can generate uh the sequence of infinite length in this way and so overall in this rendition of Fibonacci what we want to do is actually return the number at the specified index of the sequence right and so a really key insight about the Fibonacci sequence is to generate any particular number of the sequence we must know some other numbers of the sequence right I can get eight by just doing the previous three plus five if I wanted to actually formalize this problem a little bit better what we'll have to do is understand that these numbers I have listed are really the elements of the sequence and of course I can assign some indices to those elements so up top I'll just label these increasing by one of course but starting at zero so I can say something like hey the zeroth number of the sequence is zero and the first number of the sequence is one and also the second number of the sequence is one and so on and so forth so kind of jumping ahead a little bit if I look at this particular position what I see is all right it seems to be that the seventh number of the Fibonacci sequence is exactly 13. that's going to be overall the shape of this problem all right so how can we go about solving this one and so for this particular approach what I want us to do is actually work through this one recursively I think the iterative solution is pretty straightforward but I'm going to force us to solve this one recursively because it's going to help us I'll learn some new topics along the way so we'll kind of stick to a recursive mindset and if you hate recursion you know too bad he'll learn to love it right now and so looking at a particular example let's say I wanted to figure out how I can come up with the solution for FIB of six in other words the sixth Fibonacci number is exactly eight and so what I can start to do is figure out how to break down this problem I know in general to generate the sixth number of the sequence I can take the fifth number and add that to the fourth number right it's exactly the rule of the Fibonacci sequence let me try to visualize this one a little bit better so I'll represent uh the problem FIB of six using somewhat of a tree and I'll represent an instance of the problem as a note of this tree so I have my top level problem of six that'll be the root of this tree and this is a really important way to actually visualize recursion because it really shows us how we're going to utilize our return values and reconstruct our final answer so if this is a new pattern for you don't worry we'll walk through it pretty slowly together and so now that I have this root of six I have to figure out how do I break down this problem well like we just said to solve above six what I need to do is break that down into fibbo five so that'll appear as a child of that sixth node in the same way for before also needs to be solved to solve our main problem over here and notice how I have these you know children nodes of course below the FIB of six right as I go downward in this tree I should be getting smaller and smaller numbers in blue right that would represent a smaller problem because I know once I have a small enough input in blue then I would have somewhat of a base case kind of inherent the Fibonacci sequence so let's take a closer look at this five note over here right this node represents the problem of FIB of five right what is the fifth number of the sequence and I know in general my pattern is all right if I want to calculate FIB of n then I take the sum of N minus 1 and N minus two so I'm just going to apply that pattern to this five node in other words on fives left it's going to have a node of four and a five is right it's going to have a note of three right doing a minus one and minus two respectively and it's a similar trend for the four node on the right hand side over here right it's going to have two children of course doing 1 on the left and minus two on the right giving three and two respectively so let's keep applying this pattern we're going to do is fill out the next level of the tree until we can't fill it out anymore we have to notice here is when it comes to actually building on the full tree we have to stop at certain nodes in other words once I have an instance like zero as my input to this little sub problem I can actually shrink that problem size any further let's all highlight all of these nodes whose input is zero right that represents the zeroth number of the Fibonacci sequence and something inherent in the problem is I can't really break that problem down any further I know that for those particular nodes they ought to return zero right because a zero number of the Fibonacci sequence is exactly zero so in green I'm going to represent the result or the answer to those sub problems right I'm going to put their answers above the problem itself right so I'm trying to be very very particular in my drawing I'm always going to write a return value above a node here and I have a similar case for all of my nodes who have an input of one those are also a base case right because the first number of the Fibonacci sequence is exactly one so we'll also fill in those ones above cool now that I have some floating return values I can start to reconstruct my larger problems at hand so let's stay focused on the left hand side of my tree let's look at this particular node so I'm looking at this node of two and I have a left hand value and a right hand value are ready to compute I know that if I look at this this node of 2 it's trying to figure out what's the second number of the Fibonacci sequence and so at this node of 2 in blue what I can do is just take the sum of its children right of those green values so 1 plus 0 gives me one and if I do a quick Sandy check that must mean that the second number of the Fibonacci sequence is exactly one and this pattern continues up the tree right at this node of three I take the sum of the one plus one and I get two if I do a quick Sandy check that must mean the third number of the Fibonacci sequence is two what we're doing right now is really stepping through how a recursive code would actually return right return means return to your caller right so return to your parent node and so I'll fill in the rest of the values over here and bear in mind you know as you kind of uh draw out these diagrams maybe for yourself hopefully on pen and paper or even on a whiteboard it's really important at least for me that you check for correctness as you build the tree so if you're in an interview it really helps to not just check for your top level answer being correct but at any points of your Trace you should have logical information in other words by just looking at this node right I have a blue note of three over here whose return value is two that logically implies that the third Fibonacci number is two and that's totally correct so I'm good to go for now right it would really be a drag if I kind of sketch through this entire drawing only to realize I had a little like typo or miscalculation somewhere Below in the tree so I highly recommend that you stay very aware of your sub results as you kind of Trace through a diagram like this so let's continue to build up these sub Solutions so I know that this node of 2 is going to take the sum of one plus zero that gives me one and finally at the parent of four it's also going to take the sum so two plus one is three and that must mean that the fourth of a notch a number is of course three so let's speed this up a little bit for every other uh node in the tree so we're gonna add all these up so on and so forth now at the tippy top we see that this note of six at the root is going to take the sum of five and three and of course that gives me eight which is exactly the punch line right the sixth Fibonacci number is indeed eight and so looking at this pretty large tree you might realize that hey you know our top level problem was asking for the sixth Fibonacci number not a very large number in the sequence however we have to use a lot of nodes to actually represent that problem how we broke it down that's something really important about this Fibonacci Sequence right it has a pretty interesting complexity a pretty large one at that so let's try to analyze the complexity of this we know that every node of this like visual tree represents a recursive call right and so the number of recursive calls I make over here or the number of nodes of the tree should roughly represent the time complexity of this solution you're probably already recognizing that it's going to be a very very large one let's go step by step over here and so to analyze the complexity of recursion like this I think it's really important to notice any patterns in the tree to me it's all about looking in the tree right I can kind of figure out at least the ballpark of the type complexity without even writing the code right just using this visual and so at first glance you might notice that this one is pretty hard to analyze because the tree is asymmetric in other words notice that it's a little taller or deeper on the left hand side then toward the right hand side of the tree it's actually much more shallow and that kind of asymmetry makes us feel a little uncomfortable when it comes to figuring out any patterns so here's what we'll do let's actually try to analyze this one by drawing an analogy so let's ignore this exact Fibonacci tree right now and go for a more symmetric example so let's say I had a similar recursive code that had a more symmetric recursion so let's say I had some top level call with a value of four and let's say that this top level call to four I actually made two more recursive calls but both on a minus one in other words the left child is the same as the right child which is different from our classic Fibonacci right Fibonacci our left was minus one and our right was minus two but now I'm just doing minus one on both sides if I continue that pattern that should give me a nice symmetric tree let's say I had some base case roughly when my value is one so I can stop building the tree from here and so this has a nice symmetry to it let's try to notice any patterns now if I look at the different levels of this tree let me look at how many nodes there are across a level so for example my very very top level and there's one note on that level on the next level there's two nodes and then four nodes and then eight nodes you can probably see how this pattern scales right if I drew more of this tree let's say I had a farther a base case it would be 16 nodes and then 32 nodes and so on and so you probably realize the obvious pattern here right the very top at the root of my you know recursive tree I have one note or one call and then from one level to the next I doubled I multiply by two right and I do this process basically for every level of this tree so that begs the question you know how many levels are there in this tree well just looking at this kind of particular concrete example there's definitely about four levels right and I can kind of understand uh how to designate each level by just looking along this lefthand path right so colored in yellow notice that I have four three two one that's just a decreasing pattern so when it comes to the number of levels it's pretty obvious to me that it's exactly n levels right if my top level problem at the root is where n equals four then I have you know four levels or in general n levels so it's pretty clear to me that when it comes to figuring out the total number of nodes in this tree which implies the total number of recursive calls we make for this kind of toy problem it looks like I would multiply two by itself n times over which is a definition of an exponential 2 to the nth power cool so maybe you're a little bit skeptical and here's where we can either you know really buy into kind of the Big O complexity or we can get bogged down by the finer details something that you might fall into sometimes but you have to kind of be very aware of it is Big O is really just an estimate so if you actually plug in some values here you might notice all right if I did 2 to the fourth power right because 4 is my n in this particular example that would be 16. and so if we actually counted the quantity of nodes in this visual tree it would not be exactly 16. I'll label them over here starting at one there's actually going to be 15 nodes so it's off a little bit but if we you know understand Big O complexity we know that if we have something that's of the shape of like 2 to the N minus 1 we can ignore the minus one what's more is even if it was off by like five right if it's a minus five that's still a constant that we're subtracting that still is dropped from the Big O notation so overall I would consider this particular example as having o of the 2 to the N Run time which would be exponential pretty pretty slow right so while we're here looking at this symmetric example before we hop back into FIB let's try to recognize what the space complexity is we know how the space complexity for recursive code is going to be more or less the number of Stack frames that we use right for our recursion because whenever we make a recursive call that information has to be stored on the call stack right so we kind of make different function calls and also return from function calls and so this is actually something I notice students have quite a difficult time uh analyzing and so what I'm going to do is really Trace through how we would make these recursive calls as well as how to visualize the call stack right so this top level call of four that would be added to the stack all right so stack will be just a little a little rectangular block right and then as I make recursive calls let's say now I call upon three that's my input that's also added to the stack notice that it's added on top of the four right and really we have to recognize here is every time we make a call we're adding a new stack frame and we only get to remove something from the call stack when it returns so so far none of my calls have returned right until I have one at the top of my stack right at this point I've kind of bottomed out at like a base case so I can return from that call which also means I remove it from the stack at this point I need to evaluate two's right child so I make another call to one and this process continues right now I'm done with both of twos call so it can return now I'm back at three but three has to call upon it's right and the same thing happens well you'll notice that at this point is although there are many you know different stack frames we would have to eventually push onto the call stack at any point in time there's only about a four different stack frames on the call stack right it's not as if that we store like all of these different stack frames simultaneously right it doesn't really make any sense to add certain stack frames you must have returned from other ones so it's actually the case that the space complexity due to the call stack would just be o of n overall we're looking at an exponential runtime and a linear space complexity alright so for this particular symmetric example it has an exponential runtime and a linear space complexity but how about for our actual Fibonacci tree we know our Fibonacci tree is more lopsided it's roughly going to be like half the size of that and you can take my word for it it would actually be the same Big O complexity right still 2 to the n and then just an O of n space complexity and so kind of taking a lay the land over here the space complexity seems reasonable right however whenever we have an exponential usually that's not good enough and there is actually a better or faster way to solve this one recursively which is what I want to expose this to uh right now so let's go back to the recursion tree for our FIB problem right and so what we can do is try to recognize any patterns within this tree do you notice any duplicate work right this is all about understanding you know what this diagram represents right every node I have drawn in here with its corresponding number represents a problem as you can see I have many duplicate problems so for example if I look at this subtree that sub tree represents a sub problem right rooted in four so I'm asking for the fourth Fibonacci number not only do I need to calculate that on the left hand side of the tree but at some other point down the line on the right hand side I need to calculate that same exact sub problem right these two subtrees are identical and they both represent the same problem the fourth Fibonacci number and this pattern actually applies recursively because the strategy is recursive right so you can notice probably some other different duplicate sub problems right if I root myself at three I have to calculate this sub tree three different times right and notice that that three subtree is also internal uh to the fit before so it's a really a really duplicate and there are a few other duplicate sub trees you can recognize over here so we have a lot of duplicate work in this kind of Brute Force recursion and if we actually store some sub results then we can forego having to recalculate any of these subtrees down the line and so really what we're looking to do is kind of prune out some branches of this tree to avoid some duplication so what I'm going to do is kind of ignore this right hand tree of four so I'm going to take that out because I would have calculated it on the left hand side somewhere I'll do the same thing for this kind of middle tree of three so I can ignore that as well cool likewise for this too and so at this point we don't really have any full duplicate sub trees right I kind of took them out of my drawing so if we actually store some results as we calculate these sub problems this really represents all of the recursive calls that we'll have to make right and so you're wondering how can I actually Implement you know that kind of pattern in my code well it's all about just storing some additional information so let's step through still FIB of six so I want the six Fibonacci number in the long run we should get eight and the strategy I'm introducing right now is called memoization and so when it comes to implementing memoization in your language of choice it's all about storing some additional data in a memo and your memo is typically going to be your like hashed data structure so it could be like a hash map or a dictionary or object depending on your weapon of choice here right it's really important that I choose some data structure that gives me an O of one lookup time right so usually that would be your hashed data structures whatever that is in your particular language and so let's step through this one again but now we're going to store some data inside of our memo so we have the same base cases as before right we know that the first Fibonacci number is one and the zero Fibonacci number is zero and when these values return to the parent of two we're still going to calculate the sum over here so 1 plus 0 is just one but now that I have this result I can store it in the memo so I'm going to make the key represent the input to that node or that recursive call and then its value is going to be that return value and so if I look inside of my memo it's a reminder that the second Fibonacci number is one so we'll continue this process I know that I have a basically server here still the case that the first Fibonacci number is one and I return to the parent I calculate that hey the third Fibonacci number is two and I'm going to store that in my memo as well and here's where things get a little more interesting if I look at this node of 2 over here I've actually calculated uh this sub problem before right I can check that by just looking inside of my memo my memo says Hey the second Fibonacci number is one so without having to recurse and build the full subtree once again I'll just go ahead and fetch on the stored value in my memo so I'm just going to jot down a one above this node of two I'm not going to return to my parent and I figure out that hey the fourth Fibonacci number is three and of course I want to be sure to return that but also store it in my memo for the future and same thing happens at this three note right this three note is again in my memo so without you know recursing through my tree I'm going to just fetch that value from my memo I already know that hey the third Fibonacci number is two and so I can calculate the value at my parent right fifth for Notch number is five be sure to store that in your memo and so on and so forth by the time we get to the very top of our tree of course we have the fact that the six Fibonacci number is indeed eight and I avoided a lot of the duplicate recursive calls so it's clear to me that we avoid a lot of duplicate work what exactly is the run time now right and so we'll try to notice uh some patterns so this visual tree represents our Fibonacci recursion after we implement this memoization strategy right I'll try to generalize it over here so I'll kind of tidy up these edges over here and let's say I increased the size of this problem so instead of FIB of six what if I asked you for FIB of seven that recursion tree would look something like this right notice that the root is now seven of course and it's still the case that the left child is 1 so a six and the right child of the seven is a minus two or a five right still being the rules of Fibonacci and I only added two more nodes if I increase the problem size to FIB of eight I would still add two more nodes so every time I increase my input by one I only add two nodes it's always adding a constant number of nodes at this point our problem scales linearly right in general we're going to notice that we have basically two times n nodes and notice that that's not 2 to the N where I'm saying 2 times n and so we can simplify that to a runtime of O of N and the space complexity is still the same right notice that the space complexity for this algorithm is really just going to be the height of the visual tree it still looks like a linear chain right if I go along the lefthand path it just goes eight seven six five four and so on so definitely an O of n space complexity and this is actually a pretty efficient solution for our Fibonacci and so I think from this point let's go ahead and implement this in some code now we can have this core pattern under our belts so I highly recommend that you try to implement this one in some code on your own but don't forget we also have the video walkthrough available if you get stuck or just want to code along now that we're done sketching out a strategy for this problem on the Whiteboard what you want to do is follow the link in the description for this FIB problem so you can follow along and code up our solution in Java with me hey programmers Alvin here what I want to do right now is go over the Java walkthrough for this FIB problem this is going to be our very first problem in the dynamic programming section now I am going to teach you to solve dynamic programming problems is using recursion plus memoization so we're going to start just by warming up here and solving this Fibonacci problem uh using recursion and then we're going to apply our memoization strategy on top of it and this is going to be a really great strategy that can scale to a lot of different dynamic programming problems obviously you might be thinking that you could solve a Fibonacci using some you know pretty classic iterative code and you definitely can however I'm going to show you how to solve this recursively with memorization because it's really going to set you up for harder problems later on so let's Jump Right In when it comes to setting up the recursive code here I want to start with my base cases and they tell us that the zeroth number the Fibonacci sequence is zero and the first number of the Fibonacci sequence is one so I'll turn those into base cases so I can just go ahead and check hey if n equals zero then I know I need to return zero like wise if n is equal to 1 I know I want to return one so to kind of combine those into a single base case here I can check if n equals zero or n equals one well there's return n itself right because the zeroth number of the sequence is zero and the first number of sequence is one and that'll give me my two base cases to start then from there I only need one more line of code the recursive definition of Fibonacci is to get some further a number of the sequence you just take the sum of the previous two right so I know that the previous number of the sequence would be Fibonacci of n minus one right because n represents the number I'm asking for so the number in the sequence that comes before would be n minus 1. I want to add that to Fibonacci of n minus two right so that would be the number two steps ago right take the sum of them and that would give me my current number so let's give that a test run this will be correct but it won't scale in terms of the time complexity like we said in the approach video the time complexity of this Fibonacci function although it's very short code is exponential right it's 2 to the n and so the growth of this function as we increase the input number n is very very large so you're actually going to get a timeout for this one and so to make this faster we're going to layer on a memoization strategy right and so what's really important in the way I teach monetization is we always start by solving the brute force and here I have the Brute Force right I can identify that I've correctly implemented The Brute Force when I get correct results for my method except it's slow right so it times out for some very large input for example if I take a look at the test case I'm feeling right now it would be calling Fibonacci with an N of 46 right it would give me some large value and because this has an exponential time complexity that's far too large for me to wait around for and so when it comes to creating a memoization around this Brute Force solution in Java what I usually do is create two separate methods I'll have my main method I also have my recursive helper method that also takes in a memo and so let me create another version of this method above that would be the main method and it's just gonna really call and pass control into my recursive method I'm going to overload it with an additional argument here right so FIB the recursive method is going to take in not only the integer n but my memo and for you in Java it'd be nice if you implement your memo using a fast lookup data structure right because you want to improve the runtime of this code so you want to store your sub results in a fast lookup data structure so for you that could be as simple as a hash map so I'm going to import up top Java util hashmap so I know that a hashmap has o of one insertion and ov1 lookup and I'll take in a hash mark over here and when it comes to how I design the structure of the hash map I know that the keys of my hashmap need to be input arguments to My Method here right so I know the input argument is a number or integer n so I'm going to make the key integer I make the corresponding value in the hash map the return value for my method it's going to have integer values as well I'll just call this argument memo so that means when I in my main function call my recursive method here I'll pass in the original n but I'll give it a new hash map nice I could just return whatever the recursive method returns so do bear in mind that this circus of method now line 9 is taking in my original argument n as well as this memo hashmap right and this memo hashmap is going to be shared for the entire recursion right so what I need to be sure to do is I'm taking in the memo that's an argument here when I call recursively on FIB I want to pass along the same memo right you're passing it by reference so you can have all of your recursive calls share the same memo object right think of it as if when you visualize like the recursion tree like we did in our approach video you want all of your nodes in the tree to refer to the same memo awesome so that's just me adding an additional argument into FIB but now I actually want to use that memo object and so what you should do is check if your argument is already a key in your memo right so I'm going to check it over here it kind of acts like another base case here so I put it at the top so I'm going to check if my memo already contains key of my argument n right what I can do is then just return the stored value of that key so I can do memo dot get n obviously this only works if I you know over time store values into my memo which I'll do in a moment right so I know my memo is going to map right arguments of my method to their return values so if I find an argument in the memo that matches my current argument I'm just going to return its stored value in the memo but that means I need to be storing things over time into the memo and so now you should locate wherever you return recursively for your method so that'd be the line 19 return right those are my recursive return values right I know that line 11 is not a recursive return value because it's literally my base case right so I know that this value here I know it's really composed of you know two separate or cursive calls but I know that this will ultimately evaluate to a number right and we're turning a number here that number is like the answer so what I'll do is I'll save it in a variable I'll just call it result and you know that this result is going to be the answer for Fibonacci of n so what I want to do is in my memo before I leave I want to store using the key of n I want to make the corresponding value this result again what I'm doing here is I'm making sure my memo Maps arguments of my method to their return values I know the answer for like FIB of n is this result and what you want to be sure to do is just complete the return value like before so I just want to return result so I'm still returning the same data as before I'm just additionally storing into a memo for later on and what's great is later on you know somewhere in your recursion when you encounter an N that you've seen before I mean you know that's going to happen in this problem because we you know demoed it in the approach video when you see an input and you want to evaluate an input and that you've seen before then you'll actually hit this base case on line 14. you're going to find that that argument is already in the memo and you're just going to return the stored value inside and that happens in constant time right because I know getting you know from a hash map is constant time so with that change let's go ahead and give this a test run really important thing to remember to do is be sure to pass your memo you know to your recursive calls over here that way you get that shared information across all of your recursive calls awesome and there we have it so by implementing this memoization strategy on top of our Brute Force we really improve the time complexity of this solution right like we said in the approach video now we're looking at an O of n runtime right space complexity is also going to be o of n because we have to store all of these calls on the call stack and even if we consider the size of our memo we know that our memo is just going to have a number of entries that could be at most equal to our input n right because I'm using my input n as the keys of my hash map and I know that keys are unique all right programmers so what I want you to do is take a moment really be sure to redo this problem and understand how we solved it in two steps right first I solve just the Brute Force recursion and then I apply my memoization on top of it this is going to be a really really important pattern moving forward we're going to scale it to solve some pretty interesting and difficult uh dynamic programming problems but I always follows this core pattern of solving a Brute Force recursion then additionally adding a memo hash map to it I'll do a variation of this in the next video I'll see you there hey programmers Alvin here right now I want to show you the approach for this Fibonacci problem and so I know you're thinking you know why is he having us do basically a ripoff of Fibonacci well I think it's really important that if you want to get good at these algorithm things then you have to have a certain level of repetition as the saying goes one is none right so even though you know we've just done another Fibonacci problem doesn't mean that it's completely something that we've mastered so if anything this should be a quick little review right of course I want you to solve this tribonacci problem uh recursively and so let's take a look at the sequence so here is a few numbers of the Fibonacci sequence all you'll notice is in this particular problem like before I want you to give me back a particular number of the sequence so imagine that we had corresponding indices for each of these numbers when it comes to the tribonacci sequence we're going to have three separate base cases right the zeroth number of the sequence is zero and also the first number of the sequence is zero and the second number of the sequence is one so with those three seed values we can come up with our general rule right just like before to calculate a number of the sequence or the next number of the sequence you just take the sum of the previous three numbers right or in general to calculate trip of n you do the sum of N minus one n minus two and N minus three and there you'll have your final answer right it's kind of jumping at a particular spot within the sequence if I took the sum of 4 plus 7 plus 13 that would give me exactly 24. so you should feel red at home in this particular problem so let's start to draw this one now I don't want to skip any steps and so before we start building this one let's have some foresight and figure out how to visualize a problem like this right and what's great about visualizing it is at least if we spend some time you know sketching out you know a structure of the problem like visually it can also help us figure out the complexity of this particular problem so right now I want to step through calculating the fifth number of the sequence which should be four in the long run so like before I'm going to represent an instance of this problem just with a tree and so my top level problem will be the root of this tree I want to find a trip of five and I know that I have to break this problem down into three sub problems right in other words I can generate three children by doing a minus one minus two and minus three respectively I'm just going to carry over that pattern for as many nodes as I can and of course whenever I hit like a base case I can't break that node down any further we know that when it comes to our tribonacci problem we have three separate base cases right representing these particular return values so I'm just going to plug in these sub results so I should have all of these calculated values right zeroth number is zero first number is zero and also the second number is one now I can start reconstructing my sub Solutions right so if I take a look at the particular uh to the left the three node I take the sum of its three children one plus zero plus zero gives me one right so the third Fibonacci number is one and I'll just continue this pattern right every parent node just takes the sum of its three children return values so I get values that look like this and finally at the root I just take the sum of two plus one plus one which gives me a final answer of 4 right very similar to our classic a fib problem so this would be a working solution basically just doing the same a recursive code except we're going to have three recursive calls which makes sense because every call we make corresponds to a branch that we have in this visual tree however what's the complexity of this one it's pretty pretty slow for the same reasons our Fibonacci code was slow before right so take a look at this particular tree I can derive the time complexity of it because I know that for my recursive code the time complexity is at least going to be the number of recursive calls that I make And if every recursive call corresponds to a note of this tree I have to figure out what the long term pattern for the number of nodes is in this recursion tree so I know that the height of this tree is pretty obvious looks like it's going to be along the order of N and how do I know that well if you look along the lefthand path it just goes five four three two and in general that's roughly N Things right now just think about how many nodes are across on every level at the top level there's one node and to get to the next level I multiply it by three I continue this pattern right as a tree gets bigger and bigger from one level to the next I would continue by tripling the number of nodes right very similar to our Fibonacci problem and so you guessed it the complexity of this is 3 to the N so an exponential but with a base of three right and it is a case that our space complexity is a pretty reasonable o of n right of course we're referring to the space complexity due to the call stack right and in general we can figure out the space complexity from the call stack if we draw out the tree and we can just look at the height of the tree the height of the tree being basically the number of levels and there's roughly you know four levels here so I guess it's off by one even though our input was five right so to make this one a little faster of course we can just notice any duplicate sub problems right so same story like we're used to look at this sub tree rooted in three I have this sub tree appearing here as well and so I want to avoid resolving that sub problem we're going to use the same scratch as before but this I want to use a different word to describe it really what we're utilizing here is dynamic programming so dynamic programming is really a type of problem solving where we utilize any overlapping sub problems right in other words I have this sub problem of calculating the third tribonacci number and if I can store that information the first time I solve that problem I can utilize it later on because I'm probably going to encounter that same sub problem all right so this is in the family of a dynamic programming strategies and so far we've been working with memoization so really memoization is just one way we can Implement dynamic programming and so if we use dynamic programming wisely we should be able to forego that duplicate subtree right and overall we'd be looking at an O of n runtime and O of n space complexity if we implemented that correctly right and so to implement that of course we're going to use some hash data structure to build that memo so for my python people you're going to use like a dictionary for my JavaScript people you're going to use an object for my Java people I'm going to use a hash map right any fast lookup data structure and at this point we have a pretty optimal solution for this tribonacci sequence right it should be able to run in a pretty decent time and so with that what I want you to do is I give this code a shot on your own but don't forget if you get stuck we do have a Code walkthrough available as well so give it a go now that we're done sketching out this tribonacci problem on our whiteboard what you want to do is head down to the links in description and click on the tribonacci link that way you can follow along and code up the Java solution with me hey programmers welcome back right now I want to go over the Java walkthrough for this Fibonacci problem so it's going to be another dynamic programming problem just to kind of ease us into the core pattern that I'm trying to teach you guys in this course and that'll help you solve almost any dynamic programming problem and so this is going to be a variation Alpha Fibonacci just called Fibonacci it's really the same pattern except to generate a further number of the sequence you need to use the sum of the previous three numbers and here I'll start with my base cases right I know the Fibonacci sequence has some different seed values we see that the zeroth and first numbers are both zero right so I'm going to actually just go ahead and jump right in here I'll start with that as my base case I'm going to solve this one for now with a Brute Force recursion so I'm going to check hey if my n is zero or my n is one well the 0 and 1 elements of the sequence how about zero so I return 0 in either case then additionally I need another base case if n is two I return the number one really just arbitrary values for this sequence here so if n equals two and return the value of one those would be my two base cases when it comes to creating the recursive case here you just take the sum of the last three numbers of the sequence so for me that's as simple as I take the tribonacci of n minus one and I add that to tribonacci of n minus 2. and also add a 2 triple Notch of n minus three cool so let's give that a test run this is a really important step never ever skip it right whenever you're solving a dynamic programming problem using memorization you ought to solve it Brute Force first and verify that your code is correct for me correct means that I always get a correct result for my method right a timeout is okay right eventually if we had more time all right to use up here you would be able to pass test k07 you will get the correct answer but this code is just far too slow as it is right so now that I've verified that okay this code is just a matter of speed right it's just slow I can add memoization on top of it so just like before for you and job I think the best way to solve this one the structure of code is to overload this method and your recursive method your brute force is now going to take in a new argument it's going to be a hash map and when it comes to how I set up the keys and values keys are going to be the arguments here method here I just have a single argument n so I'll make that an integer key the corresponding return value is going to also be an integer so it's going to have integer value I like to call it memo awesome from there in my main method you just want to delegate to your recursive Helper and you should pass in you know a new hash map instance here so at the top I should import the right thing here so I'll import Java util hash map and you can pass it in inline be sure instantiated here so new hash map awesome and now when it comes to my recipe for memorization I have the Brute Force I'll start by adding a base case that checks if my key or my input argument is already in the memo so I'll add over here along my base cases I'll say if my memo contains the key of n right and if it's there that means I would have also stored the value that is the answer for that input n I'm just going to return whatever that stored answer that stored value is I'll do memo dot get and in that case awesome so I have the logic that looks into my memory like my memo fetching logic now I need my memo insertion logic right so now I need to locate my recursive return value right this is where I return the final answer for n right this would be a number technically I'm going to store it to a variable call it result and before I leave and return the result I actually want to store that result into my memo so I actually do memo dot put and you should always use the key that's your current input argument right so this result is the answer for Fibonacci of n right because I'm returning it for a call to n and so n is going to be my key here right so I'll do n I'll make the value the result a very important design choice that we make when we solve our memoization this way is we're only going to memoize our current call right so in other words all of my memo keying happens with the argument n right I check if it contains n and if it doesn't then I put a new key of N I don't write any like awkward heavyhanded logic like doing memo dot put I try to Cache like n minus 1 with some subresult right that gets very very messy right because we're solving this recursively if we handle all of the memoization for our argument n then everything else will actually be memorized as well right because you know that for this particular call when we jump in and evaluate that call recursively this n minus one Whatever actual number that is that is an n in some other frame of reference right so you're only going to want to memorize to keep your code very clean adjust your current argument n right don't try to do any of like the the sub problems with the children here awesome and one final thing to do if I actually test this it's a very common mistake it won't actually be any faster that's because these calls are Fibonacci in my recursive case they need to actually refer to my overloaded method here which takes in my memo I obviously I want to share this memo hash map for the entire recursion tree here so I'm going to add that into the mix just pass along the memo and that should do the trick awesome and there we have it hey programmers Alvin here right now let's go over the approach for this some possible problem so this probably want to take in two arguments we're going to be given a amount as well as a array filled with numbers and we want to do is return true or false indicating whether or not we can use some numbers of the array to generate the amount by adding them together in this particular example I should return true because I can totally make 5 by adding up some numbers in the array there are a few different ways to do that I could have done two plus three or three plus one plus one we're also two plus one plus two and there are actually a whole bunch of other different ways you can sum up to five but since I have at least one way to generate five I'm going to return true so overall we're just looking for a Boolean return type for a function here it could be the case that based on the inputs we're given it might not be possible so if I gave you a Target amount of 15 and I gave you numbers to choose from like 6 4 and 10 that would actually be impossible so you should return false all right so how do we start attacking this one we'll step through an example where you want to generate a Target amount of four and we have numbers one two and three this should be a sufficiently large example to step through here my intuition tells me that smaller amounts are easier to calculate late than larger amounts so what I can do is try to shrink my amount as much as possible until I get to a trivially small amount for which I know the answer for so let's say I start with my amount of four what options do I have here well if I think about my first choice what I could do is take a one so this one is going to represent the first number I can choose right and what I can do from there is actually subtract that one from the four that would give me a new amount of three but still at the four note over there what I can do is also maybe consider taking a two if I do 4 minus 2 then my next minus 2. and the final option would be taking a 3. if I do 4 minus 3 that'd give me one and at this point I'm starting to shrink my problem size so inside of the nodes in blue we're going to have listed the amount that we're trying to break down and then the numbers in yellow on the edges represent the choice of numbers that we choose we're starting to shrink our problem size so let's say we took a look at the three note on the left we can break it down further right using my options of one two and three and that would yield two one and zero respectively if I take a look at this two note over here in the middle I have to watch out because I can only use some of my numbers for valid moves right in other words I can do two minus one or two minus two and that'll give me a one and zero respectively but what I should not do is 2 minus three right although I have a third option of doing a three that would be too large right now and that would actually bring me to a negative quantity so we're gonna need to watch out for that in our drawing as well as when we implement the code similarly for this right hand note of one I can only subtract one for it because using any of the other numbers would bring me to a negative quantity so I'll continue this pattern for all of our nodes until we can't break them down any further and this would be the complete tree really what we're describing is the decision tree for all of the options that we can possibly make right so although I'm saying tree here I'm really referring to the fact that we're breaking this problem down recursively we go ahead and implement this we're not going to have to build any like tree data structure but we're going to solve it using recursion right I use this tree as a way to actually understand all the options I can take so since we know that this tree visualizes the recursion or where can we locate the base case well that would really be just the leaves of this tree what we can do is recognize that we have a bunch of zero nodes over here and to me that would be a trivially small amount that I can always know the answer for so that's going to be my base case right in other words if someone gave me an amount of zero I'm just going to return true why does that make sense well I can always generate Zero by just taking no elements of the numbers array I can always return true regardless of what numbers you give me you can even give me no numbers and that'd be totally fine I can still generate Zero by taking none of those numbers and so what I'll do is jot down this return value above all of my zero nodes those are going to be my base cases right my base case calls and I know that if I see a single true anywhere in the tree then it should be possible to generate the amount obviously here we can't really go wrong and we have a lot of different ways to generate the amounts if you look within this tree not only do you know that there are a bunch of different ways to make our amounts of four but you can actually see what numbers you added to generate that amount for example if I look at this path this represents doing a one plus two plus one to generate four right I'm just adding the numbers that I have along the edges here so this tree tells you a lot of information and you can use it to solve a bunch of different variations of this problem so now let's start to look at how the values return here so given a parent note if it receives a true from any of its children then it's also going to return true so that would evaluate something like this until we get a true at the top as our final answer so far we've described The Brute Force way to calculate the answer here I think it's worth going through the complexity so here I have two arguments to my function if we say that a is the amount and N is the length of numbers you can see that the time complexity is going to be n to the a power so this is going to be exponential so we're doing here is putting n in the base of the exponent because we know given a node it's going to give at most n children because I have to Branch for every option of number in the numbers array and I'm putting a in the exponent because I know that the height of the tree is at worse going to be a you can easily see that in this particular example if you start at the root and just keep going to the left it goes four three two one zero which would mean that the height of the tree in the worst case is exactly a if I had to keep subtracting 1 from my node so overall I'm looking at an N to the a complexity which is an exponential and typically going to be too large to actually run for reasonably large inputs we talk about the space complexity it's just going to be o of a right now based on the heights of our tree right we know the height of the visual tree would give us the maximal stack depth so how can we do better well you should probably catch the drift by now take a look at this tree and notice if you see any duplicate work what I can notice here is I have some duplicate subtrees right I can see these sub trees rooted in two that are identical and even have smaller sub trees that are the same like the ones rooted in one and I know that if I have duplicate sub trees in this visual that means I'm trying to solve duplicate problems right if someone asks me is it possible to generate two for the first time then later on if someone asks me again I should have just memorized that answer right and so here we're going to use that memoization strategy just store some solutions and some cash that way I can fetch them later on if you implemented memoization like we've seen previously then you would be able to trim out some branches of this tree ending up with this smaller structure what would this memoized complexity be well we'll still say that a is the amount and N is the length of numbers what we did was actually remove the exponential nature of this problem now we'll say that the time complexity is O of a times n so it's no longer an exponent I'm simply multiplying them right so a still represents the number of levels within my tree right the height of the tree and then n represents the width of my tree right for every level I will have at most n nodes and it would still be the case that our space complexity is O of a we would still use a a stack frames on our call stack due to the recursion and in terms of storing our memo we know that's also going to be linear in a and when it comes to the hash map we use to store our memo the space complexity for that is still going to be o of a because we're just going to use every amount every possible amount as a key of that memo before I let you go let's step through an amount that would not be possible given some numbers so we'll step through a scenario that should return false so my amount is 15 and I have numbers of 4 6 and 10. if we attack this one the same way we'll start with 15 in the root and we'll subtract each option of number giving us 11 9 and 5 and I'm going to carry this over as much as I can until I can't reduce my amount anymore so the full tree will look like this the nodes highlighted in red are the nodes that I can't break down any further because it would bring me to a negative quantity so if I have any remaining quantities in those red nodes then I know that that would mean those quantities are not possible to be generated so those should be a base case that return false now I can evaluate my returns in the same way as usual right I just bubble these up to their parents a parent is going to return true only if one of its children calls also returned true but everyone here is false so I'll get false all the way back up the tree all right programmers I think that's all I got for this approach video what you want to do is possibly give this one a shot on your own see if you can translate our visual diagrams into some code and then if you got stuck you can find me in the walkthrough videos I'll see you there now that we're done drawing up are some possible solution what you want to do is head down to the links in description below where you can find the link to the some possible problem because we're going to code up the Java solution right now together hey programmers Alvin from structure here what I want to do is go over the Java walkthrough for the some possible problem so you definitely want to make sure you watch the approach video for this one this is going to be what I consider like our first like actually difficult uh dynamic programming problem and so those previous toy problems of like fib and Fibonacci those have all been building up to a problem like this right what I really want to emphasize is we kind of write the code for this is try to compare the process for solving it similar to how we solved Fibonacci and Fibonacci right meaning that we're going to start by solving just some Brute Force recursion check that it works check that it's correct it's probably going to be too slow and then we add our memoization on top of it right we're going to scale out the solution here and so let's Jump Right In and so to solve this one I know I need a Brute Force recursion and with any recursion I like to think about my base cases right so when it comes to my base cases I have to think about all right what are some like trivially small inputs for which I automatically know the answer like we said in the approach video The Great base case here is going to be if your amount is really small so if my amount is zero if your amount to zero then what you want to do is kind of give back a Boolean representing all right is it possible to add up numbers such that their sum is zero and that's always possible right you're going to always get a sum of Zero by adding no numbers together right that's trivially true and so I'm going to return true here so if you hit an amount of zero just return true awesome but from there I know I have some positive amount and I need to break it down smaller and smaller toward this base case and I know that to shrink the amount I must subtract some value from the numbers list so I'm going to start iterating through the possibilities here so I'm going to iterate through every int I'll say none within the numbers list and I know that I'm going to take my current amount and subtract it by this number so just for some clarity I'm going to label this variable as my sub amount right because it's my original amount just with some number reduced out of it awesome and now what I want to do is keep solving this problem recursively so now I want to figure out is it possible to have a sum that adds up to this sum amount and I have a method to do that it's the current method I'm writing right so I'm going to call some possible and check if the sub amount is possible Right the second argument to this recursive method should be the same argument right numbers you can reuse the numbers as much as you want so I can pass in the same numbers awesome but now recursively have to think about all right what does this give back well I know that it definitely gives back a Boolean and that Boolean represents whether or not it's possible to create these sub amount right if it is possible so if this comes back as true then I know that it must be possible to sum up to the entire full amount so I'm going to return true here and why does that logically make sense well if it's possible to make my sub amount right it must also be possible to make my full amounts because to make my full amount I can just add one additional number to it right because to get the sub amount in the first place I took out one valid choice of number but on the flip side if it's not possible so if this a recursive call returns false then you want to keep looking and consider if another choice of number would be possible right so something to watch out for is you don't want to write like a else return false right because you would exit too early right you only want to return true if you find a valid amount right the place you should return false is only after you're done checking every possible amount and you don't find one right so you want to write a late return false here all right if I don't find any uh sub amount that's possible and I checked all of them so after my for Loop then you can return false hey it must not be possible to create my amount awesome so this looks like my Brute Force solution but we are missing a one kind of glaring case we'll want to pay special attention to our subtraction on line 10. right based on what our amounts and number is we could get like a negative value for sub amount imagine my amount is two and maybe my number is five well if I do two minus five I get negative three and things will get kind of nasty from there because at that point I've already overshot my base case of zero and so you'd get increasingly more negative numbers right as your amount and so we never really want to let our amount become negative so I like to turn that into a base case so if my amount becomes negative and I can return false right it's not going to be possible to create a negative amount using a sum because they tell us in the problem that our numbers are all going to be positive right you can never generate a negative quantity by summing up positive numbers awesome so now I'll make sure we don't overshoot right we'll get just return false here that'll help us complete The Brute Force recursive here so let's give that a shot always want to make sure that it gets a correct answer and it just times out right so now I know that this is a great candidate for applying memoization right we know that like we said in the approach video this currently has an exponential run time so it's far too slow so to structure the optimize solution here I like to split up into my main method and my recursive method that also takes in a new argument which like we're used to from our last two problems right it should be a hash map cool the keys of the hashmap are just going to be the argument of My Method but it's only going to be the argument that changes right so if I look at the recursion here I know that amount is really the argument that changes over time right the numbers argument or the list of numbers doesn't change right so I know that that list of numbers in my recursion doesn't really dictate the result right because another changes I always return based on what the amount is and so I'm just going to make the integer amount my key right the corresponding value is going to be just the return type of your method so Boolean here I know that corresponds with you know the return values online like 20 and 24 and even in the base case awesome I'm going to call this my memo once again so let me go ahead and do some of the housekeeping here so I want to get the hashmap and when I I'm in my main method I'm just going to invoke my overloaded helper method give it the same amount give it the same numbers but you should give it a new hash map that's going to populate over time so it's nice and fast awesome at this point what I want to do now is add my base case to check hey maybe an input amount I've seen before right so I'm going to add as a base case here so if my memo contains a key that corresponds to the current amount I'm looking for I just want to return its stored value because I would have stored the answer there so return memo dot get amount all right very reminiscent of your Fibonacci and Fibonacci awesome other things I need to do is need to be sure to pass this memo by reference to all of my recursive calls and I know that there are actually multiple recursive calls here because on line 25 I have a recursive call and it's in a loop right so you make a recursive call for every num of the list I'm going to over here pass in the memo and now the only thing I'm missing is I need to find a way or find a location where I should add information into the memo right when do I put some keys and values into the memo like I said in the previous videos I always locate my recursive return values right so that would be line 26 and line 30 right to be safe you can memorize both of those return values right there's no points of memorizing your base case return values because those already occur in constant time right so there's no need to do it there so over here before I return true you want to store in your memo for the key of amount the same value would have returned right so if you return true then your stored value is true or if you return false then in that case your stored value is going to be false right and like we always say the key that you kind of refer to through your entire memo logic is going to be the argument amount right so I'm not writing any keys that have to do with the sub amounts to keep your code nice and clean you write about your current amount you're passed in right you know when you make your recursive call on the sub amount that will become its own like full amount and then it will get cached anyway in the memo so this should be good to go let's give this a test run see how we optimize our solution great and there we have it hey programmers Alvin here right now let's go over the approach for this Min change problem so in this problem we want to do is take in two things as input we're going to be given a Target amount as well as an array containing some coin values what we want to do is return the minimum number of coins required to create the amount so for example since my target amount is 5 one way I can give back five cents would be to do one plus one plus one plus one or I can do one plus two plus two or I could even do one plus one plus three and also two plus three in this problem what we want to do is choose the way that requires the least number of coins so that would be the two plus three that would use only two total coins and my function should just return that number of coins which would be two as my final answer all right so let's start attacking this one by visualizing it let's sketch out what we would do for an amount of four that way we can actually finish it because we're going to see that as we moderately increase the amount the size of our problem actually grows pretty large and so if you're doing all these problems in order and I always recommend that you do you should recognize this one as a dynamic programming problem so I'm going to try to do is shrink my problem size then also notice any overlapping sub problems in the long run and so I'm going to sketch things out as a tree what I'll do in the nodes of my tree is write down my current amount that I need to generate and I can break my current amount down into smaller sub amounts so let's say I start with 4 at my root to generate amount to 4 what I could do is use a one cent coin if I did that my remaining quantity would be three as my amount I could have also taken a 2 which case I need to generate two where I could have taken the three cent coin in which case my remaining amount would have been one so let's continue this pattern let's say I was at this three node this node would have three more children just branching for one cent two cents and three cent respectively if I take a look at this two note over here I can't actually use every option here I certainly Branch twice because if I took the three cent coin that would give me a remaining amount of negative one which I should probably avoid similarly for this note of one I can only Branch using the one cent coin so let's say we continue this pattern for the entire tree you would end up with this structure and what we see visually is the decision tree that represents every choice of a coin we can make until we hit zero and so this is a tree structure that we've seen a few times in the course what I'm going to argue is within the visual of this tree you should actually be able to recognize what the answer is for this amount of four so take a moment see if you can recognize any properties within this tree where can I find the answer to this problem what we should do is interpret each path of this tree so let's say I looked at this path that would represent the sum of one plus two plus one in other words I took a one cent coin and a two cent coin and then another one cent coin what I can say is that would represent the answer of three like a possible answer of three because I used three coins to generate my target amount of four that's only one possibility we know in this problem we really want the minimal a number of coins used so that should translate into one of these shortest paths like this one this would represent my sum of three plus one and that would have a length of two you could probably notice that there are a few other paths with a length of two that's okay we just want to return the smallest length possible which would be two and so what we're really recognizing here is the minimum number of coins required to generate our amount would really be the shortest path from the root to any Leaf within this tree assuming a leaf terminates at a zero so how can I do this more programmatically maybe we'll sketch this out as some recursion tree right so what I'll do is think of a return value for all of these zero nodes we can say is our base case if our amount is zero then I should return zero and so zero is a great choice because it's a small number and I can't break it down any further and I should also return 0 for that instance because the minimum number of coins required to make zero sense would be to use zero coins right just use no coins so above all of these base case nodes I'm going to jot down my result of zero and what I can do is start to evaluate these as return values so let's say I was at this node of 1 over here what I'll do is just receive Zero from my child call what I should also do is add 1 to it if I add one that would actually count the edge between myself and my child node because remember when it comes to counting the number of coins we're really counting the number of edges in a path through this visual tree so let's say I was at this two node now I was ready to evaluate it what I do is receive both of these values of 1 and 0 for my children and because I want the shortest path or the minimum number of coins my nodeans to choose a smaller between the two so I do one versus zero I pick the smaller one of zero but then what I need to do is actually increment that by one to count the edge between us and what that would represent this one designates the shortest way I can make two cents which would represent this path highlighted in pink let's continue this pattern so let's say I was at this one node the zero would just bubble up then I add one to it because there's no decision to make but now it can be at this three node this three node is going to receive three options it's going to choose the smallest among them so just zero but then it needs to add one to it and at this point I should be able to check for correctness I have a green number of one above my three node which means the minimum number of coins I need to make three cents would be just using one coin which makes perfect logical sense because I have a three available in my coins array so I could just take a single three cent coin let's continue this pattern elsewhere in the tree at the root note of four in this tree it's going to receive a bunch of ones technically it would choose the smallest among them which would be a tie given one and what I should do is always increment it by one to count the edge between myself and the children nodes and this too represents the fact that I have a few different paths that could only take two coins or two edges it could represent this path or this path or even this path so as we evaluated this tree something really important we did was whenever we received multiple values from our children so when we received multiple sub Solutions what I do is choose the smallest among them right I know I need some Min value logic present in this implementation because I want to choose the minimum number of coins possible so I'll just keep that in mind when we implement the code we talk about the complexity of this we've seen the structure before right now we're going to describe the Brute Force complexity if we say that c is the length of the coins array and a is the target amount then the time complexity is going to be exponential right we know that the branching factor of this tree is going to be based on the number of coins so C right branching Factor refers to given a node at most how many times will it yield children and I know what my ratchet Factor here is three and in the worst case I have three branches coming out of a single node my exponent here is going to be a because that would be the height of the tree we'll say that the space complexity is going to be o of a due to the call stack because if you look at the height of this tree it would be in the worst case a we say the worst case would be the scenario where I keep taking a bunch of one cent coins giving me the deepest recursion possible so if you start the root node here and you just keep going left you're going to see a sequence like four three two one zero and that definitely is a linear pattern in a so overall we're looking at an exponential runtime and a linear space complexity for this solution the time complexity definitely needs some work there right we want to bring it down from an exponential so like we usually do we just want to memorize this one we'll try to notice any duplicate sub problems so looking at this tree there are some duplicate sub trees I can notice I can see these sub trees rooted in two so instead of recalculating that subsolution I can save it and just reuse it so I can trim out that piece of the tree I also have other sub trees rooted in one and I can also ignore those right the way I'll implement this is by using some constant time data structure like a hash map I can store sub results as I compute them in that hash map and then reuse them later on if that high level strategy seems confusing don't worry you'll want to wait until the walkthrough video will actually show you the details on how to implement this in some code so let's do a reanalysis of this now we're going to analyze this dynamic programming solution that uses memoization the time complexity is just going to be a times C so it's no longer exponential it's really a sort of multilinear right just multiplying my two terms together we know that time complexity is going to be based on the number of recursive calls we make and in this visual diagram every node represents a recursive call we still have a tree of height a so that's where the a comes from what we're saying is across every level of this tree we have at most C nodes so I think of a as the height and C is the width that would give me a times C nodes overall it's actually pretty easy to spot in this particular example in the worst case scenario at a particular level we have only three nodes at most that's because our coin array only has three options inside of it the space complexity for a solution is just going to be o of a due to the call stack and we'd be storing at most a different keys inside of our memo hash map all right I think I'm ready to code this one up you want to join me in the walkthrough video now at this point we're done with the planning phase for our Min change solution what you want to do is head down to the links in description below where you can find the link to the Min change problem where you can code up the solution in Java with me hey programmers Alvin Constructor here what I want to do is go over the Java walk new for this Min change problem so you definitely want to make sure you watch the approach video first this is going to be another dynamic programming problem similar to our previous some possible problem like we said in the approach video what we want to do here is optimize for the number of coins that we take into our sum and so I'll Implement that strategy exactly what I want to do is start by laying out a base case we know that in this problem our base case should be about an input amount that is trivially small and for me the amount is going to be zero so I'm going to check if the current amount that I'm looking for is equal to zero then I want to return the answer for that amount of zero I want to return an integer representing the number of coins I need to create that amount so if someone asked you to generate zero cents what's the least number of coins you need to generate zero cents the answer there is zero coins so I'm just going to return zero then from there I want to start writing my recursive scenarios so I know that I need to take one of my choice of coins to reduce the amount so I'm going to iterate over all the possibilities so for me that means I'll iterate for every int coin within the coins list and what I'm going to do is I'm going to take the input amount and subtract this coin from it that smaller quantity that'll give me my sub amount we'll call it and from there I want to recursively find the minimum number of coins needed to make that sub amount so I can call my recursive method pass in that sub amount could pass in these same old coins in the problem they tell us that we can reuse a coin as many times as we need awesome but now from here I need to do some thinking I know that this method call should give me back a number representing the minimum number of coins needed to make the sub amount I'm going to save that number into a variable here just readability I'll call it sub coins because that's the number of coins needed to make the sub amount and I know I need to find the minimum subcoins for every choice of coin that I can take so I need to perform some Min value logic here you know generally A Min value logic means as we iterate over the possibilities we maintain some outer variable here I'll call it the mincoins I have to think about a good default value for it here well I know that in the context of the problem they tell us that all right if it's not possible to make the amount with the coins then you want to return negative one so I actually use that as an initial value here so I'm going to set this up as negative one and I know that after the foil at the end of my function if I never find a mount that works I'm going to return mint coins which should still be the negative one right but besides that what if it is possible to make the sub amount well if it's possible to make the sub amount that means that subcoins would be a nonnegative number right so I'm going to check if subcoins is not equal to negative one that means it was possible to make the sub amount since subcoins is the number of coins needed to make the sub amount if I do subcoins plus one that should be the number of coins needed to make the full amount and why do I know that this additional plus one here is counting the single coin I took to get the sub amount I'll save it to a variable called int num coins so this is the number of coins needed to make the full amount over here and now I could compare this against the mincoins variable right so I'm going to check hey if this number of coins is less than the mint coins well then I can replace the mint coins with this new number of coins right but it's pretty obvious here that when we initialize the mint coins to negative one this negative one may persist over any valid number of coins here right because negative one is already a negative quantity right so this negative one just acts like a placeholder right to represent an invalid quantity or the fact that we haven't found any valid number of coins yet and so if the number of coins is less than Min coins or the Mint coin still contains that default value then I can replace that default value with this number of coins right so I'm performing A Min value logic over my minimum coins so this code is looking pretty good one thing we need to be aware of is when we calculate this difference here we do a mount minus coin that could give us a negative amount right sub amount could be negative so if we call Min change with a negative number we already overshot the Space Case here so what I can do is just cache that with the base case so if ever my input amount is less than zero then what I want to do is return some value I'll return negative one here because again negative 1 in this problem represents the the fact that the amount cannot be generated with the coins we're given right you cannot generate a negative amount when all of the coins that you're given are positive so that's going to be a good extra base case there so let's give this a test one this should be our Brute Force solution for Min change if all is well we'll add some memo into it and make it a little faster so I'm getting an area it looks like I have a random typo current subcoins that should just be subcoins plus one right let's give that a test once again nice and this looks like our Brute Force solution we know that an algorithm like this so far has an exponential run time just like we said in the approach video so to speed this up I'm going to use our memoization strategy so like I always love to do I'm going to separate it into a main function and then a recursive helper right so my main over here will just call my recursive helper it's going to take in the amount as well as the coins but also my memo which will be a new hash map I'll be sure to take that hash map as an argument here so it's going to be a hash map and I have to think about what the keys of this hash map are going to be they should just be the argument that changes during the recursion which is the amount notice that the amount is the only ARG that changes coins stays the same so I don't need to add it as a key into my map here so I'll say my keys are going to be integer and then the corresponding values are going to be just the return type of this method which is also integer I'll call that memo got to be sure to import hashmap above looking pretty good and be sure to pass along that memo through the entire recursion now I need to add an additional base case right I need to check hey if the memo already contains the amount well then I've solved this sub problem before just return the stored value in the memo so I'll return memo dot get the amount awesome but if it's not then I'll go ahead and actually perform the true logic and calculate recursively of the answer right and I know that now I need to actually add data into the memo where I return the result so I look for the literal return line in my recursive case and it's only one return statement here in the recursive case that's line 35. so literally what I should do is I ought to save this into my memo so I can do memo dot put I'm going to use the input amount as my key always use the original argument make the corresponding value mincoins and you still need to complete the return value so like before still logically return mint coins you're just making sure you store it in the memo before you leave this recursive call nice so with that logic built around my Brute Force by adding the memo we should get a better run time here awesome there we have it here we start to really see the power of this strategy of first solving a Brute Force recursion and then applying our memoization trick right around it really the hardest part of a situation like this is to solve The Brute Force recursion in the first place right but that lets you focus on just the correct logic and then afterwards you speed up that logic using this additional data structure all right programmers that's all I got for this one why don't you do is practice this and I'll see you in the next one hey programmers I just want to take a little break from our dynamic programming material to tell you about structi Shruti is a complete data structures and algorithm course that you can use to prepare for all of your technical interviews it's actually the course you've been seeing me use throughout the video tutorials I'm going to be your teacher through the entire instructed curriculum and in the structure course we cover all of those essential interview topics like graphs trees dynamic programming and more and like you expect for every single problem like you've seen in this dynamic programming course we're going to support it with animations as well as code walkthroughs and you'll be able to code up all of these Solutions on the platform tester code in Java C plus plus JavaScript and python so if you're enjoying this dynamic programming material I recommend you head over to structure where you can practice things further whether it's dynamic programming or those other essential topics and of course you're going to be joining me for all of those video walkthroughs so I'll see you there without any further Ado let's hop back into our course hey programmers Alvin here right now let's go over the approach for this count paths problem so in this problem we're going to be given a grid what we want to do is travel from the top left corner down to the bottom right corner and here we want to return the number of ways that's possible to Traverse through this grid the caveat is we can only move to the right or downward that means we can go up and we can't go to the left and so for this particular grid let's talk about the different ways we can travel through it one way would be to go right right down another way would be to go right down right and finally the last way would be to go down right right and since there are three possible ways to travel through this grid we should just return the number of three so this should be a counting problem for us however this problem is a little more nuanced they say that some positions are going to be occupied by walls and we can't travel through them so if I had a wall like this in the top right corner then one way to travel to the grid would be right down right and the only other way would be downright right so let's Trace through the strategy for this one by looking at a larger example if I was given this 3x3 grid I'll also put a wall in the top right corner let's start by labeling the indices for our rows and columns we know that we start in the top left corner so that would mean row 0 column zero and what I want to start to do is try to give myself a way where I can denote every option I have right how can I Mark the decisions I can make by traveling through this grid so I'm going to visualize this one as a tree so if I start at position 0 0 I can make that the root of my tree if I'm at this position I'll think about my options that I have I can either move downward if I move downward that would increase my row by one but keep my column the same giving me one comma 0 or if I went to the right I keep my Row the same at 0 and I increase my column by one and that would be the only two options I have from this root position and I can just apply this logic recursively so let's say I was situated at the zero one node right now so I'm over here I know that my options are more limited now I can't move to the right because I have a wall in my way so I'm going to need to make sure I code that one up and I can only move downward here and that would mean increasing my row by one and keeping a column the same and so let's carry over this pattern to draw out the rest of this tree we know that given a node at most it's going to have two children representing my downward or rightward movement and that would mean either incrementing the row by exactly one or incrementing the column by one however we should not do that move if we go out of bounds or run into a wall so the full tree would look something like this what's great about this tree is if I start at the roots and travel to a leaf node that would represent one of the paths I can take through my grid in other words if I look at this path in my grid I can represent that using this path in my tree which is a really nice way to interpret this problem and so let's start to realize how we can encode the base case in this problem what you should be realizing is we're visualizing this as a tree which usually gives us a nice way to implement this as recursion right so if I've got all the leaf nodes here I always terminate at 2 comma two because that would represent the bottom right corner of my grid which is the goal and so if I'm at the bottom right position of 2 2 what should I do here well I have to think about the return value for my function here right they say they want a count and so what I should do is treat this to comma 2 position as if it's its own input so if someone asks me in how many ways can you get from the bottom right position to the bottom right position the answer would be one right there's only one way to do that that would be to just stay there right because you're already at your goal point and so I'm going to make all of these Leaf nodes or all these base cases return one now having these calls return one seems useful because I know I need to tally up a count in this problem so how do we start reconstructing our larger Solutions here well I would just really Bubble Up these ones right so let's slow down at this one comma one node over here we know that this node has a little more work to do because it's going to receive two values and so what I should do is bubble up both of these values right and then this note should just add them together so one plus one gives me two and so what are we saying here if I pause I should have some logical information in the subtree what it should be saying is that there are two ways to get from the position one comma one to the bottom right corner I have this path or I have this path there are two different ways to get from one one down to your bottom right corner so I'll just carry over this pattern keep reconstructing all of my Solutions and as we get toward the top of our tree we are going to get the final count of all of the ways to travel from the top left to the bottom right giving us our final answer of five what's great about visualizing this one as a tree is it really describes the decisions we can make as we travel through the grid right we know that this gives us a binary tree because for the most part when we're on the inside of the grid we only have two options right you can either move downward or to the right that'll help us decide the complexity of this Brute Force algorithm so if we implement this algorithm as it is just with some baseline recursion we say that R is the number of rows and sees a number of columns this will give us an exponential runtime meaning they're an exponential number of nodes in this tree really it's 2 to the r plus C power so the base of 2 comes from the fact that this is a binary tree and in the context of a problem that means I can only move downward to the right so you only have two options I'm saying that the height of this tree is R plus C right because you know you want to start in the top left corner 0 0 and travel to the bottom right corner what you have to do is actually Traverse a path that is exactly R plus C moves along right because you need to move through all of your rows and all of your columns for the same reason I can say that the space complexity is going to be R plus C just due to the stack depth right stack depth is equal to the height of this tree which we just said is roughly R plus C and so overall we shouldn't be too satisfied with the time complexity of this one right typically something exponential would be too slow for our liking and so what we should do is recognize that we actually have this visualized as a nice dynamic programming problem what you should do is take a moment look at our visual tree and notice if you can spot any duplicate sub problems right are there any overlapping sub problems here that I can memorize so we actually have a duplicate sub tree over here rooted in one comma one what I could do is just save the first time I calculated that way I don't have to fully recurse down my tree the second time around effectively memorizing my duplicate function calls which in the context is my tree visual just means that I prune out some branches there are some other subtrees here I can look at this two comma one subtree I can also memorize that away and we know as we grow the problem size in other words if someone gave me a larger and larger grid I would have more and more overlapping sub problems so I'd benefit more and more from memoization like usual for us the way we'll implement this is by using some hash map data structure I'll save that detail for the Code walkthrough though so what do we know about the new and improved complexity of this one right we're going to implement our dynamic programming using our classic memoization strategy so like usual R is the number of rows and C is a number of columns now would be the case that our time complexity is R times C right it's still the case that our time complexity is driven by the number of recursive calls we make and now we would be making roughly R times C different recursive calls right and how do I know that well in the context of what I'm going to memorize into my hatch map I'm going to put positions right notice that each node in this visual is a position of row and column and I know that there are exactly R times C different rows and columns so once I store a row and column into my memo I would never have to fully recompute it which gives me my time complexity of R times C likewise now is the case that my space complexities R times C taken mostly from the size of that memo right every position is going to be a key and so I have R times C different keys in my memo object all right programmers I'm sure itching to see how we actually implement this one in some code so right now you'll want to join me in the walkthrough videos I'll see you there now that we're done sketching out the solution behind this count pass problem what you want to do is head down to the links in description below where you can actually access the prompt and the test cases for this count pass problem and we'll code up the solution in Java together hey programmers Alvin from structure here what I want to do is go over the account pass problem in Java so like we said in the approach video we're going to frame this problem like a dynamic programming one this is going to be a little different compared to our very classic like graph like grid problems because in this problem you can only move rightward or downward that means that we can't get caught in any Cycles right so I don't have to do any visited logic or anything like that however what I will do is solve this one with a Brute Force recursion and then apply our memoization strategy on top of it to get a really fast dynamic programming optimized solution so to get the ball rolling on this one I know I need to start tracking like a current position as I Traverse uh through the grid so I'm going to split this one up into my main method as well as my helper and my helper is going to take in my current row and current column information and then in my main method I'll just pass control to my helper and I'll give it the starting point which is a top left corner which means row 0 column zero pass along the entire grid to reference then from here I'm going to structure this one as like a depth first recursive solution more or less so I'm going to start with the base case so what's my goal here well my goal is to find the bottom right corner of my grid so I can stop traversing if my row and column is the bottom right so be careful of the math here right to be in the bottom of most row that would mean that the row is equal to grid dot size minus one that means the bottom row similarly you want to check if the column is equal to the rightmost column so that would mean grid dot get 0 dot size minus one right so this is checking if I'm in the bottom right position then what do I want to do what I want to return overall the number of ways to reach the bottom right corner from this current position well if you're already in the Target position then you don't need to do anything so that's one way that you can get to the bottom right corner you just do nothing right because you're already there so I'll return one in this instance we have to think about some other scenarios right it could be the case that maybe my row and column is out of bounds so I want to avoid that and so I'll check very a very similar condition here I'm going to check if I'm out of bounds that would mean that my row is equal to grid size or my column is equal to grid.get0 dot size right notice that I'm turning this into an or right because if your row is too large or your column is too large well in the theater those are true or both of those are true then it's an invalid position so you're out of bounds right and if that's the case I still need to give a logical return value right I always want to have consistent return types so even in the space case if I'm out of bounds I want to return an integer and an integer needs to represent how many ways from this position I can travel to the bottom right corner well if you're out of bounds there's no possible way to ever get to the bottom right corner at that point so you want to return zero right there are zero ways to travel from an out of bounds position to the bottom right corner so I have my base cases looking pretty good but there's one more to capture here they also tell us that all right some positions of your grid are not open o stands for an open position if a grid position contains an X that's a wall that I cannot travel through so I'm going to actually add that into the mix here right it might be the case that if my grid dot get r dot get C so if my current position is equal to an X well then I can't Traverse through it right that's also a dead end kind of I like out of bounds so I'm similarly going to return zero awesome do note the important order of these two cases over here right I'm making sure that I only try to access like the innermost element of my a 2d grid after I check that the row and column are valid right I know that I'm using some valid RNC to get a position of my grid it's just that that position contains an X so these are all of my base cases here now I can start structuring my recursive case and I know that from any position that I'm at I have you know two options to take and those two options will turn into my two recursive calls right so I'm going to call account paths you could move downwards so you could move down a row keep the column the same but you can also move to the right so you can do count Paths of the same row but increase the column nice I have to think about what these two recursive calls return they return a number right this one on the left returns to me the number of ways I can get to the bottom right corner or get to the goal if I move downward this tells me the number of ways I can get to the goal if right now I move to the right if I take the sum of them that gives me the total ways I can get to the goal from this position because from this position you can only either move down or move to the right so this is looking like some core logic this looks like the shape of my brute force not much logic to it overall just some tricky edge cases here for my base case and so let me give this a test run I'm looking for some correct output so I'm passing some test cases but probably timing out for large inputs and there we see it so like I always love to do now I need to apply my memoization to it so I'm going to set that up you always want to use some fast lookup data structure to store your memo right and so for us use something like a hashmap and I'll pass along that hash map inline over here so new hash map and I'll take it as an argument and here where I design the hash map have to be a little more particular right so generally for the keys of my hashmap I always use the changing arguments into my recursive method here right so if I look at the arguments that change during my recursion it's the row and the column right the grid itself is always the same throughout the full recursion so I don't need to encode it into the keys of my hash map and so I really need to represent a row and column pair or like position as keys of my hash map because depending on their own column you get a different answer and so to actually store that key I'm going to use just a list of only two things of a row and column so it'll be a list of integer and I'll just guarantee that I'd make sure that those sub lists are always going to be of length two right just pairs of row and column and corresponding value is going to be the return type for my method which is just integer as well nice call this memo and now let's add our memo checking logic so pass these base cases what I like to do is form the key I'm going to use into my memo so create that key here it's going to be a list of integer let me just a pair I'll call it my position it's going to be just a list of the row and column nice and I can check hey if this position is in the memo so if memo dot contains key position and I can return the associated value with it because that means I've seen this not recursive call before so I can just instantly find the old result so return memo dot get position again the key trick here is I'm using this position because it contains the row and column arguments right so I'm using that entire entity as a key into my memo nice then from there like we're used to I should be sure to pass the memo to my calls here and whenever you see your recursive return value which is line 30 for me you want to store that result in your memo before you leave right so I'm just going to store this into an INT result be sure to put that in your memo so memo dot put this is uh put a key of position with the result and then just return the result nice so with those changes pretty classic changes to the previous problems that we've been doing except we're having a little more complex of a memo key here let's give that a shot awesome there's our solution for count paths hey programmers Alvin here right now let's go over the approach for this maxpath sum problem so in this problem we're going to be given a grid and we start in the top left corner and we want to make our way to the bottom right corner this grid is going to be populated with some numbers though we want to do here is return the path containing the maximal path sum in other words there are a few ways we can travel through this grid one way would be to use this path in which case there's sum would be 14. another way would be to use this path in which case your sum would be 12 and finally you can use this path in which case your sum would be 18. and between these three options I should choose the 18 right and so that would be the max path sum for this grid so let's cut to the Chase and describe the strategy for this one and we'll step through exactly this example so we'll label the row and columns and we also know that we start of course in the top left corner the SE are really just a spinoff of our last problem so hopefully you visualize this one as a tree right a binary tree because we only have two options at any point in time right you can either move downward or to the right and sometimes in just one of those directions depending on whether or not you're at the border of our grid right so we'll start at zero zero from this position I have two options if I went downward I would increase my row by one notice that each pair within a node here is a row and column or I could have moved to the right in which case I would be at zero comma one now to present my two moves let's say I was situated at this one comma zero node here I only have one move possible to make I must move to one comma one right that represents a move to the right if you look at my row and column indices that's because I can't go downward anymore because I'm already in the last row if I take a look at this position over here I do have two options right I can go downward or to the right giving me one comma one and zero comma two respectively we can build out the full tree from this point we know that we must terminate at position one comma two because that would be the bottom right corner so I know that that is our ending point right so that's going to be my base case I know in this problem I want to choose the maximal path sum so I want to Max some but how can I start accumulating a sum in the first place and so what you have to do is ask yourself if I'm already at the end position what is its Max path sum to the end position that would just be the value of 2 right that's exactly the number in that ending position so for my base cases I'm just going to return whatever number is in that final position then from here I know that these values are going to return so let's say we were situated at this one comma one node it's going to receive a value from its child call because we know we're visualizing this in a recursive way and what I should do here is note what position I'm at so 1 comma 1 would be this position containing a six I want to accumulate a sum here so I should do 2 plus 6 giving me eight so this node is going to return 8 to its parent so it's 8 it's going to Bubble up a little bit more if I think about this one comma zero node that represents my current value of 5 over in yellow and I would do my 8 plus 5 giving me 13. so that would be a partial path so far so we'll continue this process on our right hand side we know that these would just Bubble Up and we would add the respective values at those positions things came more interesting when we're at this zero comma one node though so for this note it's going to receive both 8 and 14 right it's just going to return back up like we always do and I have to make a decision here since I want the max path sum this node should choose the larger of those two values so 14 is bigger than 8. so I prefer the 14 here but I should also still add the value stored at my current position so if I look at position 0 1 within my grid that would be this value of 3. so I add 3 to the 14 giving me 17. finally this takes place again at the root so if I'm at 0 0 I'm going to receive the 13 and the 17 for my children I choose the bigger value of 17 and then I add my position itself which has a value of 1 inside that gives me a final answer of 18. so the way we reconstructed our sub Solutions into higher level Solutions was to choose the larger of our two children and then add ourselves to it that way I get some max value logic while also summing our path we talk about the Brute Force complexity of this algorithm we say that R is the number of rows and sees the number of columns then our time complex is going to be exponential just like we saw in the last problem the base of 2 comes from the fact that given any position we have two options right we can either go down or to the right and I make R plus C the exponent because that would be the height of this tree right that would be the length of any particular path I know any path that travels from the top left to the bottom right must cover all of the rows R and all of the columns C and so the entire path length would be R plus C in a similar way I'll say the space complexities R plus C due to the stack space required by this recursion right if the height of this tree is R plus C that means the stack space used by my recursion is also going to be R plus C but a keen Observer would know that I can do better because this is a dynamic programming problem so what I'll do is take a moment look at this tree see if you can find any overlapping sub problems and although this example was small I can already see some overlap if I look at this node rooted in one comma one I see it here and you also see it here I know the punch line is I should only have to calculate these nodes exactly once so I should be able to trim out a little bit of the tree by using some memoization and as we actually increase the size of our input as I get a larger and larger grid I would have more and more overlap that I'm able to kind of forego using some memoization like usual we're going to implement this using a hash map but I'll say those finer implementation details in the walkthrough video if we Implement memoization properly for this one we're going to bring our complexity down to linear right so we're going to have a Time complexity of R times C that's because there are R times C different nodes to actually cover now right I know I'm going to put the positions as the keys of my memo and there are R times C unique positions in a similar way it's now the case that my space complexity is taken over by the size of my memo which is also R times C because of the number of keys right I have R times C keys because I have R times C positions all right I think I'm ready to code this one up you'll want to join me in the walkthrough videos now hey programmers welcome back what I want to do right now is go over the Java walkthrough for this Max path sum problem so it's going to be a small variation of the previous you know grid dynamic programming problem except this time you want to find the maximum as we travel from the top left of our grid to the bottom right so I'm going to start by setting up the same initial structure so you'll want to track a position as you kind of Traverse through your grid and so I'm going to add additional arguments to this method so I'm going to track my current row as well as my current column nice and then from there what I want to do is start laying down my base cases right so for my base cases like you expect there are a few I need to check if I'm out of bounds so if my row is equal to grid dot size that means I'm just outside of the grid or maybe my column is equal to grid dot size or rather grid dot get zero dot size or I'm out of the column range right either case you want to return a sum integer right how can you represent an invalid integer meaning it's not possible to travel to the bottom right corner using this particular position well because I want to perform overall like a Max path logic or max value logic I know my logic is going to be preferring any larger integers and so whenever I encounter like an out of balance or invalid position I need to return some very small number right and so for me I think the best way to solve this one is going to be to use like a negative Infinity concept so in Java really your only choice for like a true negative Infinity is going to be in the double type so I'm going to say double dot negative Infinity which means I have to adjust some of my types here right so I guess I'm going to make this return a double that's totally fine I'll just be sure to cast it back in my main method here right so what am I saying well just so I can have access to like negative Infinity in my recursive over here in my main method it's going to call maxpath sum with the initial row initial column as well as the grid and I know that this is now defined to return a double you're going to get an error in Java if you try to return a double from an integer return method so I'm just going to cast into integer I'm just doing that really straightforward so I'm only going to convert at the very end which is fine all right so beyond that I need to just handle the case where I actually hit my Target in a base case so that'll be a similar condition right you want to check in English if you're in the bottom right position so if your row is the last row and your column is the last column and so you want to return some number here and overall you want to be adding up the values in your grid as you travel along them so in your base case you want to return an actual value you want to return the value of your current position so you want to return grid.get r dot get C so what am I really saying here so let's say that we're performing our recursion and we hit this base case meaning we're at the bottom right corner so that means I'm at this position what I'm going to do here is return the value at this position so I'm returning the value of one I'm going to return it because I need to eventually add up all the values along my winning path and the end goal is still part of my winning path here nice and so now that I have these base cases in line what I want to do is start forming my recursive case so I know I'm going to have two recursive calls right because at any position I have two options I can either go down or go to the right so I'm going to call maxpath sum going downward would be R plus 1 C grid and going to the right would be maxpath sum of the same row increase the column same old grid nice and here what I want to do is prefer the larger sub answer right because when I take a path through my grid you either go right or you go down right and I know that these recursive calls can be back a number they represent the sum of the a path if I travel through the right or if I travel downward and I want to choose whichever sub result is bigger right because right might give you a bigger sum or going down might be a bigger Sum It could only take one of them and so to choose just the maximal between these two numbers that I get back I'm just going to use the builtin math.max you can also write some conditional logic this is probably the easiest way to write this though so just choose the bigger value between these two methods but I should also be sure to add my current position into uh that answer right so I'm going to do grid dot get our dot get C add it into the bigger between my going down choice or my going rightward choice right this gives me the logic of summing up all the values along a particular path awesome so let's give this code a run this should be our Brute Force solution it looks like nice and if all is well we should start timing out and there we have it so let's improve the runtime of this one by adding in our memo so that's going to be a hashmap this is going to have us use a hash map where the keys are going to be positions right because the row and column is what determines the answer here because those are the arguments that change so I should have passed along a new hash map here and over here I'll Define the type so hash map keys are going to be positions so just kind of list pairs to integers corresponding value is going to be looks like double I'll call that memo so like we always do we want to add our memo checking logic as an additional base case so I'll start by forming the key first which is really just a position pair list of the row and column and then start by checking if it's in the memo so if memo contains the key of position then return its corresponding stored value so I'll return memo dot get position nice and then beyond that I need to be sure to pass along this memo so it's shared through the entire recursion so just pass it by reference here not a big deal and like I always say right the key is to now just find your recursive return value which is this thing over here you want to store it in your memo before you return right so this long expression just is a double it's like just a sum right so I'll save that as a result and this is going to be double how do I know it's double well it's obviously double because of this over here what I want to do is store it in my memo so memo dot put use your original arguments the original key here make the corresponding value the result and then like before still return the same old result the only additional step you took was to store it for a rainy day because I know later on if I ever encounter this position again I would hit this conditional and I can return that sub result in constant time which gives me a much better performance here give that a test run added our dynamic programming strategy there we have our very Snappy code hey programmers Alvin here right now let's go over the approach for this nonadjacent sum problem from this problem you're going to do is take in an array containing some numbers what you want to do is return the maximal sum of nonadjacent elements in this array so that means we can never take two numbers that are next to each other within the array for this particular input the answer should be 16 because the max nonadjacent sum would contain the 4 plus 12. here we should notice that we can't take a sum like 12 plus 7 because those two elements are adjacent within the array let's take a look at another example let's say I was given 7 5 5 and 12. in this particular scenario the output should be 19 representing the sum of 7 and 12 which is totally fine because they are nonadjacent in the array so let's come up with the strategy for this one we'll step through the example of 2 4 5 12 and 7. what I want to do is figure out a way I can come up with all the possibilities for numbers I take into my sum and numbers I exclude from my sum because we know that based on the numbers we take that would actually limit our options later on so let's say we started to encode this as a recursion tree right so I'm going to describe all the decisions that we could take as we come up with a sum for this problem so I'm going to start with my original array at the root what I have to do is come up with a decision right now let's say I was making a decision for the first element of this array so if I took 2 into my sum then I know my resulting elements I can choose from is really just 5 12 and 7. so notice how I did this left Branch over here right I'm writing 2 along the edge to represent that I'm taking 2 into the sum and notice how I make my array smaller in that left child I just have 5 12 and 7 because I cannot include 4 in that next call right because including four would actually mean that we're giving ourselves the opportunity to take an adjacent sum right if you take two right now then you can never ever take four so that's why I exclude it however at the root we could have also just not taken two altogether in which case when you look at your next subarray that would just be 4 5 12 and 7 right if I don't take the two that means I'm excluding it along the edge on the right hand side then I can totally give myself the opportunity to take four in the future so I'm going to include it in the next array so let's carry this pattern further let's say we looked at this left note over here what I have to do is always make a decision about the first element of this array so for the five note if I decide to take it what I can do is then look at the remaining elements of just seven right I don't pass 12 until the remaining subarray because if I take 5 I cannot take 12. however I could have also just not taken 5 altogether which case my remaining elements are just 12 and 7. so by now it should be clear how we generalize the steps here right given any particular array what I can do is either take the first element or not take the first element and that would decide what remaining elements I can choose from either slicing off one or two elements from the front of my array let's say we evaluated this node over here if I take 4 then I would give me a remainder of 12 and 7. if I don't take 4 then my remainder is 5 12 and 7. something interesting happens at the seven node right so in one scenario I can take the seven in which case I really just have an empty array left over right there's nothing else to choose for because that's my last element and the scenario that I don't take seven you would still have an empty array left over so notice how the seven node terminates and really two empty arrays finally we'll evaluate this 12 comma 7 node if I took the 12 then I would have an empty array because if I take the 12 you cannot take the 7 anymore and if I don't take the 12 well then I can totally take the 7 for my next decision at this point we would actually have a larger tree right there are still some nodes I need to evaluate here fully but what's great about this is I can actually notice that those are all duplicate nodes in other words I've noticed that this is a dynamic programming problem right if something has dynamic programming present in it then I should be able to recognize any overlapping sub problems in the context of this tree I just have to notice any duplicate nodes any duplicate subtrees I can notice a duplicate sub tree rooted in seven right so I don't need to reexplore the seven node again likewise I can notice a duplicate subtributed in 12 comma 7. there's even more than that I even have a very large subtree rooted in 5 12 and 7. and so I'm going to save a lot of complexity by saving some of these sub Solutions as I compute them so let's talk about how you can recompute our final answer from the problem now that we broke it down what we should notice is toward the bottom of our tree we're going to have leaves that represent empty arrays which does feel good because we know as our problem size gets smaller and smaller that would mean a smaller and smaller array right less and less numbers to choose from let's make our base case about the empty array in other words if someone gave me an empty array then the max nonadjacent sum would be zero right just take no elements of the array because you don't really have an option here so for all of these empty nodes or the empty arrays I'm going to have them return zero I know I'm going to make that a base case let's say we wanted to evaluate now at the seven node how will it use those sub Solutions well if I take a look at the left return value that's going to Bubble up but what I should also do is add the 7 along the edge right the yellow seven that represents the fact that I was taking and including 7 into that sum so I have a 7 on my left and for the right hand child that just bubbles up as it is right because I did not include seven for that particular sub problem and at this point I have this node choosing between seven and zero since I want the max nonadjacent sum I choose the larger between the two so I should return 7 in this instance so now let's evaluate this 12 comma 7 node since I just evaluated the seven node into its result I'm just going to jot down that answer here and I know I would Implement that probably using some memorization but as I carry on my return values here the lefthand0 is going to Bubble Up but I add the value along the edge because I was including 12 to that sum so I have 12 on my left and 7 on my right I choose a large between the two and I should return 12. which makes sense because if you think about it given just the small sub array of 12 comma 7 the Max on adjacent sum would be 12 right just choose 12. definitely don't choose 7 because that'd be smaller now that I've evaluated this 12 comma 7 node I know I can save this result for later on so I'm going to jot it down on that duplicate node over here now let's evaluate a little higher up we'll carry over the same logic as before so I return these values and I add the 5 along the left hand Edge giving me 12. at this point I choose the larger between 12 and 12. it's really a tie here so I'll just return 12. so I've just computed the subsolution for the array 5127 and I actually have a duplicate node on the right hand side so I'm going to jot that down if I evaluate this node now things Bubble Up along the left hand Edge I add a 4 giving me 16. so I do 16 versus 12. I choose a larger one which of course be 16. finally at the ultimate root I return these two values but the left hand Edge gets a plus two I choose a larger between 14 and 16 giving me my final answer of 16 which would be the correct answer let's talk about the complexity for this one so if you say that n is the length of the numbers what we could do is analyze the Brute Force complexity of this right so if you did not optimize this by trimming out some duplicate nodes in your sub tree you would have an exponential runtime in other words your time complexity is 2 to the n and your space complexity is just o of n we can say that the time complexity is 2 to the N here because for every node of this tree it's going to give at most two children right so in the worst case from one level of the tree to the next I double the number of nodes and I also know that the height of this tree is going to be n right the height of the tree is going to be n because in some scenario I could just keep removing the first elements of my array again and again and that means that the deepest recursion would require n stack frames on the call stack like we said we can optimize this with some dynamic programming with some memoization if you did things correctly here you would get a runtime of just o event so linear and a space complexity of also o of n one thing to note for this one is if you really want to get the linear runtime out of this problem you're going to have to figure out a clever way to actually represent a logical shrinkage of your array in other words if you look at the nodes of my tree I'm representing the array and I'm chopping off some elements of the array at any point in time what you don't want to do is create many copies of the array because I know creating a copy of an array would itself run in a linear time if you're creating a copy within every recursive call it's going to be pretty inefficient I will actually save that detail for the implementation video and so if you're wondering how to exactly Implement that pattern you'll want to join me in the walkthrough video I think let's hop to it hey programmers Alvin here what I want to do right now is go over the Java solution for this nonadjacent sum problem so like we said in the approach video to solve this one we're going to solve it using some recursive Brute Force algorithm then apply some amylization on top of it and so to get the ball rolling here I'm gonna need a way to give myself the ability to look at different pieces of my input list here I know at any point in time I want to shrink my input list smaller and smaller toward my base case and so to set up that structure I think it's good to have access to like a starting index so I'm going to overload the method name here I'm going to give it another argument I'll say int I and this will represent the starting index of the sub list that I'm considering for example if I is the number two that means I should be analyzing the list starting at index two so index two all the way through the end that means top level over here when I call my helper method I'll call nine adjacent sum given the same nums list and then initialize I to be zero because you want to start considering the full list starting index 0 going through the end this will help us avoid any slicing or creating copies of the list as we go giving us a faster solution and so to get the ball rolling on our Brute Force let's consider some base cases here and so I know I want to check a base case if my list that I'm considering is empty right so I'm gonna check for me a logical like empty linked list would mean that my index I is at the end or past the end of the list here so I'll check if I is greater than or equal to num's dot size notice that here I'm technically checking if I is out of bounds of the nums list because I know the last valid index of a list would be size minus one so if that's the case what I want to do is return 0. for what I'm trying to be consistent with the return type of this method which would be of type integer and zero is definitely an integer and I'm returning 0 because it represents an empty sum because I know overall in the context of this problem I want to maximize the sum that I take and so with that let me also start forming my recursive calls and these recursive calls should really mimic the logic that we express when we drew the approach video tree right so we have really two options here I'll kind of lay them out well what you could do is take the number at the front of your list so for me the front of my logical list would be the item at index I so if you took that number you could say nums.get I and you want to recursively add it to the sum of the remaining part of the list that you can take from if you take the element at position I and when you call nonjacent sum they'll give him the same nums list but you want to manipulate I obviously I want to increase I giving myself like a smaller a logical list what you want to do is pass in I plus 2 here and so it's pretty clear why we're not just passing in the same old I well for one we already took the element that index I into our sum and we're adding it to our recursive sum here we shouldn't pass in I plus 1 because that would be a number adjacent to I right and if we take I right now we know we can't take I plus 1 later on because the whole point of this problem is you can't take two elements that are adjacent in the list and so the earliest number we could take from there would be I Plus 2. and this is a very indicative of the logic we expressed when we drew the tree so that's only half of the pattern here could also be a scenario where I don't take my current element at index I and instead I just do nonadjacent sum of nums and then I pass in I plus 1 here right so now I do have the option of taking the element that's right after I nice and I know that these two variables over here are these two expressions they give me back a number right they represent a sum what I want to do is now work in my max value logic I want to choose the maximum answer between these two choices right the choices you make are either you take your element index I or you don't take your element in x i so I'm going to choose the maximum between them for me I could just use the builtin math.max just takes into arguments and Returns the bigger value between them and now that I'm choosing the maximum between these two quantities you just want to return whatever that maximum is so this code's looking pretty good let's give this a test run so far really short logic but we do want to optimize this in a moment so we're passing our initial test cases and we're timing out test case zero four so we're in good shape here we know that you know the problem like this does have an exponential runtime so it's too slow to run but I can add some memosization logic into the mix here to improve that so like we're always used to should know this formula by now I'm going to bring in the hash map I'm going to pass it into my recursive method here when it comes to the structure of this hashmap its keys are always going to be like the changing arguments to my recursor method so I'll pass in a hash map here for me the keys need to represent my integer's I right so I'll make the key type integer corresponding value is going to be the return type of the method which is also integer so this hashmap Maps integers to integers and let me add my base case to check if a key already exists in the memo and for me the key is really the argument I right so if the memo contains the key of I then just return the stored value because I would have stored the subsolution previously so return memo dot get I now on the flip side I have to locate my recursive return value which is this expression over here and I want to store it in the memo before I leave right so I'll just save this thing to a variable I'll call it result I'm still going to complete the return value that way we don't change any of the actual arithmetic in this evaluation but I do want to save this result so before I leave I'm going to do memo dot put use your argument I the plain old I as their key make the corresponding value the result and always be sure to pass along that memo by reference into your recursive method here does that mean right here pass along the memo so I have that shared data structure and so just by adding this layer on top of our Brute Force let's give that a test run we should get a much better run time here cool and there we have it hey programmers Allen here right now let's go over the approach for the summing squares problem so the first thing we'll want to do is review what a perfect square is you can create a perfect square by just taking some positive number and multiplying it by itself in other words I can do one times one to give me one two times two to give me four three by three to give me 9 and 4x4 to give me 16 and so on so in this problem we're going to take in a number as input and we want to do is figure out the minimum perfect squares that sum up to our Target number so for this input of 12 the least number of perfect squares I can use would be doing four plus four plus four notice that this is a valid perfect square sum because 4 is of course a perfect square another way that uses perfect squares to add up to 12 would be nine plus one plus one plus one however that would be a longer way right I want to use the minimum number of perfect squares and so here I should return the answer of three and the reason behind it is because I do 4 plus 4 plus 4 which is three perfect squares all right so how can we break down this problem let's step through the example as if our input was 10. we're going to start at 10 at my root and what I know I have to do is get this number to be smaller and smaller because decreasing the size of our input would mean an easier and easier problem to solve so what I have to do is subtract different perfect squares from this 10. so what I can do is subtract one that'll give me 9 or I could subtract 4 giving me six and finally I could subtract 9 giving me one notice that there are no other perfect squares to try the next perfect square would be 16 but that would be too large for my 10. so I don't need to go over it over here let's say I now wanted to expand this nine node I would get children like this again branching for every perfect square that I can take out of that quantity and so on and so forth if we look at the right hand side of my tree I actually just discovered a way to create my input of 10. in other words I can look at this path since this path terminates in a zero that must mean that we have just found a way to sum up perfect squares such that we get 10. if I look at the numbers along this path I'm really saying nine plus one so let's expand this five node as well as this two node and we'll build the full tree for the subtree rooted in six that would look something like this so you can probably foresee that this tree grows very quickly and so we're going to avoid drawing the left hand side of the tree although now we know the core pattern that we can use to generate it so if I look at this sub tray I have a few different paths that terminate at zero right I can look at this path which represents another way I can create my input of 10 but I should obviously prefer a shorter path right if I count the number of edges within a path that would tell me the number of perfect scores I use to accumulate that sum and obviously the shortest path we should return here is two because we're using a nine and a one let's go through how we can actually code this one up so as always if I have this visualized as a tree I should be able to frame it as some recursion so in my base case if my number my input is zero then what I should do is return zero zero is a great return value because what we're saying is to create zero you need to sum up zero different perfect squares so I'm going to plug in that return value for all these Leaf nodes and as I return these values to their parents what I have to do is add one to them always that way I can start counting the number of edges so if I look at the very bottom right now the zero returns then I add one to it then it returns upward add one to it and one more time to get over here notice that I have a three over the three now which means that I need three perfect squares to create three which makes sense because you have to do one plus one plus one let's say we return at this four node since this node is receiving two different values what it should do is choose these smaller between the two right because this problem is asking us for the least number of perfect squares so I need to minimize here so I should prefer the zero what I should also do is add one to it to count the edge and so what I'm saying right now is there must be only one perfect square that I need to get a quantity of four which makes sense because 4 itself is a perfect square so I should be able to notice any correctness even as I evaluate these sub trees so we'll take some time to evaluate this further until finally at the sixth node we get a result of three and this three represents a few different paths we can take that are of minimal length so I think by now you understand the logic we need to evaluate this tree this tree is going to be a little large so I won't step through the full example we can already foresee the complexity of this though right whenever I have a tree structure like this I'm describing all the different recursive calls that I make so if I'm able to figure out the number of nodes in this tree that would tell me the time complexity that stems from the recursion what I know is the height of this tree is definitely going to be n right because the longest path from the root to a zero would be just by taking a minus one again and again right so the height of this tree is going to be n when it comes to the branching factor it's actually Dynamic so given a node we know that we Branch for every perfect square that we can fit inside of it we know that given a node n there would be square root of n different perfect squares so that'll tell us our total complexity we'll say that the time complexity is going to be the square root of n raised to the nth power like usual the branching factor of our tree is going to be the base of that exponent in this problem the base is no longer two right we were dealing with a lot of problems we just have a base of 2. now we have a branching Factor that's based on the square root of that number so that's why we say we have square root of n raised to the nth power the exponent of n of course represents the number of levels in this tree or the height of the tree in a similar way the spacing Plex is just linear o of n because of the height of our tree we know that we're going to need at most n stack frames in our deepest call stack and like you could probably guess this is actually going to be framed as a dynamic programming problem right what we can do is notice some overlapping sub problems looking at our tree you can capture a few I'll just point out this duplicate 5 node and of course as we grew our input larger and larger you would have more and more overlap so if you do things properly here and you implement memoization to capture the dynamic programming nature of this problem which you should be able to do is bring it to some sort of a multilinear function overall your time complexity would be n times the square root of n interspacing Plexi would still be o of n I'm sure wondering exactly how we implement this one so maybe what you want to do is try to code it up on your own if you get stuck you can find me in the Code walkthrough I'll see you there hey programmers after construct be here what I want to do is go over the Java walkthrough for the summing squares problem so you definitely want to make sure you watch the approach video first and we'll Jump Right In Here we want to solve this one using a Brute Force recursion and apply some memoization on top of it so let's start with a base case here like we said in the approach video we know we want to deal with an input that's very small right for us we have integer inputs so we'll just check if our number n is equal to zero if our number n is equal to zero then we want to return zero because we know that generally our method should give us back the number representing the minimum the number of squares used to build up our n right if your n is zero that means you can use the empty sum right you can add up no perfect squares and you still get the correct answer of zero so that's the logic behind our base case here but now the recursive case is much trickier we know we want to have the logic of subtracting out some perfect squares from n that gives us a smaller and smaller argument so I'm going to give myself a loop that just iterates over some possible squares so what I can do here is I can iterate for it's I equals one and I'm starting at 1 because I know that one is the smallest perfect square right so I might as well start there I'm going to iterate up to I less than or equal to the square root of n and then hit every I in between I plus equals one cool that's because as I evaluate this Loop what I'm going to do is take my integer I am going to create a square number out of it a square is just the number multiplied by itself notice that on the last iteration of this for loop I know that I is going to be exactly the square root of n so when I do I times I I'm definitely going to get the full value of N and this could be the biggest number we ever subtract out of our argument n here nice and so with that out of the way we want to do is now build our recursive call so I'm going to call summing squares and I'm going to do n minus this choice of square that I have over here we know that this recursive call is going to give us back the minimum number of squares required to sum up to this quantity right I'll call that my int num squares however if I wanted to figure out the number of squares to build up for our argument n we need to add 1 to that sub quantity right that's because this one over here corresponds to the single Square I have on line 9. nice and then I know I need to find the minimal sum and so what I want to do is some Min value logic here so I'm going to do int I'll say Min squares and here it would be nice if I can use some like Infinity value because I want to do Min value logic overall and so unfortunately like integer type doesn't have a builtin infinity and so what I'll do is I'll actually create this as my recursive helper and so the main method will have the original signature but my recursive method I'll think I'll make it actually return double because then I can start defaulting these values over here right so for line 13 I can make this default to double dot positive Infinity and I get some safe comparison over here right so I can say things like hey if this number of squares is less than the Min squares and on the first iteration this is guaranteed to be true because Min square roots is positive Infinity then you can go ahead and replace them in squares with that value then after that full loop is done running like you expect we return whatever Min squares is and since we're storing positive Infinity in this variable over here this should be of course type double which means that now we're summing squares recursive method is returning a double which is totally fine however when we actually call this helper method in our main method here we know that this call to summing squares that's actually going to give us a double I want to just cast it into an INT like so I'll pass along the same end here do bear in mind that right now because these methods of summing squares although I want to overload them they will probably get a conflict here because they both take in the same types of arguments and the return type is kind of ambiguous here so just for now I'm going to rename the helper method I'll call it underscore or something Square so that represents my recursive helper method nice and so with that let's give this a run here I'm just getting a little reference here for the typing this should be positive in fin it t and while I'm here I also noticed that when I add one to the results of the recursive method here that of course gives me back a double and that's because the method returns a double I'm adding one to it which should still give a double let's give that a test run nice and this looks like our Brute Force recursion is starting to time out though on test case zero six so you know the drill at this point we have our Brute Force let's add our memosization into it so I'm going to start by importing the hashmap and I'll pass it along to my cursor method here so it'll be a new hash map I'll take in this argument here so hashmap keys are going to be just the numbers n so integer corresponding value right now is going to be double I'll call that my memo and we'll add a base case like we always do if our argument n is in the memo so if memo dot contains a key of n then return ammo.get and right return the stored value for it then I need to locate where I call My Method recursively which is over here be sure to share the memo and then whenever you do your return value in the recursion you want to store that result before you leave right so here I return Min squares I'll want to save that in a variable I'll say result equals mint squares I'm going to still return that same old result but before I leave I store it in memo so memo dot put use the original argument as the key right so I just use n here make resolve the value nice and so now that the overloaded version of this method has a different argument of hashmap it should be unambiguous now so I'm going to actually change the name here it's just a summing squares right it's easily to identify now because there's two arguments for the recursive version right only one argument for the main version here so let's give that a test run always solving these dynamic programming problems and layers great there we have it hey programmers Alvin here right now let's go over the approach for this counting change problem so this problem we're going to be given two arguments we're going to be given a Target amount as well as an array filled with some coin values what we want to do in this problem is return the number of ways that's possible to make the amount given the coins in the array and we can reuse the coin value as many times as we want and so for this particular example let's go through the ways we can make an amount of four one way would be to use just a bunch of one cent coins or you could do a three plus a one you can also do a two plus a two and finally you can use one two cent coin and then two one cent coins and so that means there are four distinct ways to generate our amount so let's Trace through an algorithm you can use to solve this one we'll start by structuring the different decisions we can make when it comes to building our amounts of four so I'm going to use four at the root and like we're used to let's go ahead and Branch for every coin value that we have available in other words what I could do is take a one cent coin in which case I reduce my target amount from four to three or I could take a two cent coin in which case I have two cents remaining or I could take a three cent coin in which case I have one cent remaining you've seen this pattern a few times in the course already if we built out the full tree we'd end up with a structure like this notice that we terminate wherever we have zero because that must mean we actually successfully built our Target amounts we know that a zero Leaf would represent one of the ways to create our mount looks like we have too many zeros here you're going to see that we have seven zeros but we said that there are only four ways to create our Target amount let's start by interpreting one of these paths so let's say I looked at this path this path will represent me taking coins one plus two plus one and if I look at another path like this one in pink this is represent the way of taking two plus one plus one if we look at those two paths they actually represent the same coins right I'm using a single two cent coin and then two one cent coins I just took them in a different order and that's why we have a high count right now we're actually counting duplicate ways and so I don't want to return seven although my tree says that I should really return four so actually structuring our tree like this is not going to be the way to solve this problem so what would be a better way well we can still use our tree structure so we're going to break this one down recursively but we want to build it in a way where we don't have any duplicate paths right and so what we'll do is starting at the root of our tree we're going to make a decision for just a single type of coin so at this top level of my tree I'm only writing a decision for my one cent coins and so for this coin with a value of one what I'm deciding on is how much of this coin to take so I could take zero one cent coins in which case my quantity that I'm targeting my target amount still stays at four or I could take a single one cent coin in which case my amount is now three if I take two one cent coins then now my amount is two and this would just carry further until I've exhausted all the possibilities for my differing quantities of one cent coins so notice here along the edges of my tree now I'm denoting the quantity of the coin I'm taking and at this first level I'm taking coin one what I can notice immediately is I already have a node that terminates at zero so this must mean that represents one way I can generate my amounts of four and what this path represents is really me taking four one cent coins and on the next level of the tree I'll wanna do is make the same decisions but for our two cent coins so let's say I wanted to expand this note of four what I do is Branch for different quantities for my coin value too so I can take zero two cent coins one two cent coins or two two cent coins and that would give me four two and zero as my reigning amount respectively so we're gonna need some more room here our tree's getting a little wide what I can do is notice this amount of one since I'm trying to decide how many two cent coins to take I actually can't take any two cent coins out of that amount so this darkened node basically is going to be a dead end so we can effectively ignore it that's going to be true throughout this tree whenever we have an amount that we can no longer shrink we actually don't need to expand that node anymore and so let's reorganize things over here now let's expand this node of three and again I'm branching for different quantities of two cent coins right so I can take a zero two cent coin or I can take just one two cent coin which case I result in amount of three and are amounts of one I'll carry this further for the other nodes at this level notice at this point we've just encountered more zero amounts which means they represent other ways to create our Target so so far we've counted three distinct ways to create our initial Target amounts of four finally at the bottom level we choose different quantities for our coin value of three notice that some of the leaves here don't terminate in a zero which means that they don't represent valid ways to make my initial amount what I can notice at the bottom level though is I have an additional zero this would actually give me all of the four different ways I can create my target amount so the key pattern here is we want to make sure that up front we choose different quantities for a single coin value before moving to the next coin value altogether what I don't want to do is flip back and forth between different coin values because then I would end up looking at duplicate ways if you think about how we have the tree structured now we have a very short tree right this tree's height is just going to be the length of the coins array because at every level of this tree I'm choosing for a different coin value so although my tree is very short I actually have now a very wide tree because now I'm iterating through differing quantities it's like you can probably foresee we can totally structure this problem like a dynamic programming problem meaning you could spot duplicate subtrees here let's take into account the shape of our tree to come up with the complexity of this so if we implement this wisely with some dynamic programming via some memoization we should end up with a time complexity that's a multilinear so just a times c and a space complexity that's also a times C we say that the time complexity is a times C because is a is the width of the tree and c is now the height of the tree and in general the number of nodes would be the height times the width the space complexity is also going to be a times C because of the different keys we're going to need to put inside of our memo hash map you're probably wondering exactly how we implement this and why the complexity is the way it is and to do that we're going to actually have to implement the code together so at this point you'll want to join me in the walkthrough videos I'll see you there hey programmers welcome back what I want to do right now is go over the Java walkthrough for this counting change problem so in this problem like we said it's going to be a variation of our you know coin changing problems and what we want to do is this time return a number of ways that we could generate our Target amounts like we said in the approach video the thing to watch out for here is to make sure that you don't count any duplicate ways and so the structure of this recurs is going to be a little bit different I'm going to need an additional argument into my recursive method here and so I'm going to Define it down below it's going to have mostly the same signature I'm still going to take in the amount as well as all the option of coins I'm also going to take in an index I'll call it coin index this is going to represent the index of the current coin I'm going to consider which means top level over here when I call my recursive method I'm going to give in the same old Target amount I'm going to give it an initial coin index of zero and of course pass along the original choice of coins here and so what I get to do now with this coin index is now vary the quantity that I'm going to take the coin of the given index like we said the approach video we want to count the number of ways to generate the amount so recursively I want to be reducing this amount over time toward my base case in other words once my target amount is zero I have to think about how many different ways can I give back zero cents and the answer there is one right there's exactly one way you can give back zero cents and that way is to do nothing right so this one represents me counting a valid way right there's one way to make zero sense good and then from there what I want to do is now iterate over the possibilities so I know that given this coin index if I use it to access some value out of the coins list I can do coins.get coin index and I'm going to create a variable to store it I'll call it int value so this is the value of the current coin I'm considering so if I take a look at the first example in the event that coin index is zero that means my value is one it's like a one cent coin in the case that my coin index is one that means the value I get is two what I want to do is take varying amounts of this coin value so I'm going to start iterating here and this Loop is going to be different from our previous coin prompts in that we want to iterate over a different quantity right so I'm going to say int quantity if I think about what the lowest quantity of a coin I can take is well the answer there is zero you could take no instances of a coin and I know I'm going to increase that quantity over time to go through the possibilities but I have to think about how far I need to go what I want to do is iterate this Loop while the quantity times value is less than or equal to the Target amount so here I'm checking that my quantity times value is less than or equal to the amount because I don't want to overshoot my amount so for example let's say that right now my coin index is 1 right so that means I'm looking at the element of 2 over here right if I do my quantity times the value I have to think about what's the most number of two cent coins I can take right now if my target amount is four right well in the first iteration this is going to be valid because I'm going to check if 0 times 2 is less than or equal to 4 right and that's true so I keep running the iterations I'm going to check if 1 times 2 is less than or equal to 4. that's still true then I check if 2 times 2 is less than or equal to 4 and that's still true but on the next iteration when my quantity is 3 I'm going to do my 3 times 2 which is 6 and that's no longer less than or equal to my target amount of four because I don't want to take out six cents for my target of 4 cents that'll give me a negative quantity right so this condition ensures that I only iterate up to a valid point here so what I want to do now is generate my sub amount so I can do my int sub amount and I'll make that equal to the original amount but just minus the quantity times the value right I'm reducing the amount by the number of coins that I'm taking then from there I have this reduced quantity I want to call recursively on Counting chain now given that sub amounts and because I just made a choice for how many instances of this coin index I'm going to take what I want to do is now move to the next coin so here's where I increment my coin index so coin in X plus one right notice that this for Loop is going to iterate through all the possibilities for my given coin index and once I make a choice of that coin index I can never go back to it and so that's why I increment my coin index in the next recursive call along with that I can pass along these same coins right that doesn't change awesome now I have to think about the logic of my my problem here I know that in the approach video I wanted to have the effect of taking a total right I wanted to add up the sum of all of the branches through my tree so I know that counting change is going to return an integer that integer represents all of the ways that I can generate these sub amount so what I want to do is take the grand total of that so I'll say int total ways equals zero and I'm going to add the results over here nice so I'm getting the grand total number of ways and after my for loop I just want to turn the total ways just a little type over here I should be saying total ways so this looks mostly good except I should consider also adding a base case regarding my coin index in other words what if it's the case that you actually exhaust all of your different options for your coin index but your amount is still not zero so let's say after this if statement if I get past this if statement I know my amount is not zero right I also want to check hey if my coin index has no other options in it in other words if my coin index is greater than or equal to coins dot size then I have no more options right I know the last valid index of coins is coins.size minus one so if coin index is equal to coins that size I know I don't have any more coins I can possibly take so if you hit this case you want to return zero right there's no possible ways to generate your amount from this point because you already chose all of your quantities for your different coin indices nice the order of these conditions is really important right because I have this if statement of line 13 after line 9 this is technically checking all right if my amount is not zero and my coin index is out of bounds right and I'm able to accomplish that logically by the order of these two conditionals so what the let's give this a test run this could be our initial Brute Force solution looks like we're going to timeout nice because we get that not so great exponential runtime here so like where you see we'll go ahead and memorize this right so I'm going to bring in my hashmap and I'll be sure to pass it in over here it's our new hashmap when it comes to designing the hash map over here I have to think about what the keys need to be as always the keys need to be the changing arguments through my recursive method and here it's actually interesting that two arguments change right my amount changes because I have some reduced sub amount that I'm passing along and also my coin index changes because from one call to the next it would be increasing the coin index and because those arguments change during the recursion those are the ones I want to encode into my hash keys right so my keys here will actually be a list of integer I'll just make sure that that sub list or those sub lists just contain a pair of a Mountain Coin Index right corresponding return value is going to be integer so integer will be the values of my map I'll call that my memo nice so what I'm saying is I'll enter the base case and I'll form my key I'll just say list of integer it's going to just be a list of the amounts followed by the coin index I'm going to use this entire pair as the keys in my memo so I'm going to check if my memo contains a key a key then I want to return its stored value so return memo dot get key because that means I've seen this is a problem before so I can return the previously saved subresult and now what I want to do is make sure I pass along this memo by reference through the entire recursion and also be sure to store your recursive return value into the memo before you leave so that would be line 31 here what I do is I can say memo dot put you always want to make the key for your stored value the original key that encodes the arguments right so a Mountain Coin index are part of my key here so I use that in my memo and I store the total ways then just be sure to return the old value so return total ways all the same right that shouldn't change so with this let's go and give this a test run we should now be using our memo to solve this dynamic programming problem quite quickly see what we get awesome and there we have it hey programmers so you've reached the end of a dynamic programming crash course but the learning doesn't stop here if you head over to structney.net you'll be able to practice some dynamic programming problems further we have a full module on dynamic programming a lot of the problems that you've covered not in this video series for free code cam but I have a lot more in store as well so whether you're looking to really hone in on your skills of dynamic programming or you want to cover and go through all the other topics we have featured on structi I recommend you head to structie.net you're going to have access to video tutorials as well as animations with me for every single problem I'll see you there