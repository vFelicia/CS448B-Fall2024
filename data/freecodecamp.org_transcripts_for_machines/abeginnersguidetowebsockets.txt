uh today as you were saying i'm gonna be talking about websockets and we're gonna be talking about it from sort of a beginner's standpoint so someone who's never actually really used it more has sort of like heard of what websockets is but has never actually gone to the effort of actually using it in one of their projects so a bit about me i'm don misik that's my name i'm a fulltime associate developer at weistec currently i study at uts doing the bit coop scholarship so that's the bachelor of information technology i spoke at pycon last year some of you might have been at my talk and i did a bit of data science work at the anu last year as well and so i'm 18 years old and i'm obviously from canberra and have recently moved up here to study um and to give you guys a bit of structure about what we're going to be going through today we're going to sort of start off with a basic lowlevel understanding of some of the protocols which we're going to be talking about today sort of to get an idea of where everything sits in the whole it world we're going to go over some of the use cases and the applications which you might find using websockets and i'm going to go over some of the previous technologies which might be used in place of websockets since it's still quite relatively new and we'll go a bit about the browser support and the characteristics of websockets as a protocol and how fast it is in comparison to other implementations and of course what you're here for is the python aspect of it so we're going to go over how python has a role to play with it and how easy it is to do things with websockets with python and just a quick note at the end we're going to go quickly over how deploying websockets works over the web so to get into it we're going to start off with a pretty contrived example and so anyone who's done any sort of networking or taking any networking courses would have seen something similar to this you probably would have seen something called the osi networking layers um so this is the internet protocol suite and this is sort of just to get an idea of where everything sits relative to each other so i'm going to start off from the bottom you'll see the transport layer so these are things which define the way that data packets are transferred over the web right so these are things such as tcp and udp and so tcp guarantees that any packet that you send over the web will reach its destination in the same order which they were sent right and it does this by acknowledging um the packet once it's reached its destination so say i want to send a packet to a web server tcp guarantees that all of my packets will get there and i want to mention that udp the less important one to tcp is a bit more careless and it doesn't really care about this guarantee of order and it's generally used for things like streaming video data where we don't care if we lose some of the packets on the way and so tcp is sort of the underlying transport layer behind a lot of the things i'm gonna be talking about today and so then you move up to the next stage which is the internet layer uh so this is things uh like ipv4 and ipv6 which define the addresses which packets are sent right so everyone has an ip address you've probably heard of this in any um regards it's it's pretty much where data is sent on the web and so we then get to the application layer which is sort of the top level layer and this is where http websockets and the rest of them all sit um this is the sort of stuff that you guys might interface with when uh actually developing things now again i want to uh admit that this is a very contrived example so take this um layers in with like a grain of salt i would suggest if you want to do a further reading into where everything sits to either google the osi layer model or just looking into any networking courses that you can now i'm going to start off basic um just to get everyone sort of up to speed and you probably all know what http is but for those that don't um it's pretty much this request model where a client sends a request to a server the server then processes that request and then responds with like anything so right we it could be a html page it could be anything and so generally you type in a url the client is that browser that sends that request and the server does the processing so that could be anything and in our cases this is generally a web application like flask or django and then it returns a response okay so i'm going to be talking a bit about what http is and a bit of the characteristics behind it so you can sort of understand where http and websockets sit relative to each other so http stands for hypertext transfer protocol and it's a stateless protocol which means uh after the initial request is done that's it the the channel between the client the server is completely lost after this initial request right and so i like to think of it as flipping a coin you flip a coin once and you get your result heads or tails and if you flip it again that result doesn't have anything to do with the previous result right so the connection is completely lost after that initial request in the http model clients who are requesting data have to specify an action so that's either a get post put or delete this just tells the server what they want to do so a get request is retrieving some data a post request is making something new on the server a put request is replacing something uh if it does exist like a resource on the server or creating a new one and the delete one is deleting a resource on the server and these things these methods and characteristics are all put into a thing called a header which is sent over the web to tell the server what it wants it to do right and the server also responds with this header so i'm just going to quickly give you a quick example of a basic http request and i'm just going to show you how you can find these headers and look at what these things look like so if you open up any web page like my awesome web page here um if you open up the inspect tools and go into the networks tab and then you can have a look down here at all the requests you've made to the server and if you can click on that you can look in greater detail at what the request is actually doing so in a general sense you have all of the um chrome that does this nicely and it sort of gets the data that you will probably want to look at at the top and then it gives you more detail beneath right and so you can view the url which you might want to request so i've requested that url and i specified that i wanted to get that web page and then the server responded with a 200 ok response which means that my response was valid and it returned this data so you can also look in greater detail into the request and the response headers down here by just clicking view source and you can look at exactly what headers were sent up in the web now a lot of you who have done web work probably have interface with this but i thought i might start off and show you exactly where you should be looking for this sort of data now there's a couple other tabs which might be useful when inspecting this sort of stuff like the response tab so you can see that the server responded with a html page and all my browser's done has loaded that page and then you have a timing page which also shows you how long it took to download all the data for this page cool so in 2005 uh we realized that that model wasn't really what we wanted we wanted the web to be able to do more than just respond with some data okay and so we invented this technology known as ajax which stands for asynchronous javascript and xml okay and so what this allowed us to do is asynchronously send data to the server after the initial request so as you can see with the model the client sends the initial request for the html page it gets responded with that and then it can continue to make requests um after that and that did a lot of cool things for us so we could do a whole range of new things with that and i'm going to show you another quick example just to sort of stick with that um explain an example type thing so you guys can get used to looking at headers in the inspect tab so this is just a basic page which where you click the button and it makes an ajax request to an api and the api responds with some data so if i click this you'll see i'll make a request i'll just sort of make the headers tab a little bit smaller um and so what i've done here is just printed out what the request is so i did a get method to this url and i went to that api okay and then that responded with a greeting just this arbitrary grading which i created and this is great right so we could do these things now where we do the initial request and then we can get more data from the server so if we want to grab information we can just ask the server for it and it's a really cool thing we don't have to refresh the page and we can do a whole lot of things but what happens when you want to do something which is a bit more real time okay what if i've got something like a feed or a facebook feed or a chat application right where i want users to be able to instantly in real time be able to talk to each other okay imagine if say a facebook wall or a chat requires you to press get all posts to see the posts of your friends you you wouldn't want to be able to sit there the whole time pressing get all posts the whole day looking for new things i'm sorry um but you get the point right you don't want to sit there the whole day pressing get all posts but if you if you did it's i guess it would work and this this model could work for certain applications but for stuff that we want to be realtime it's not the ideal thing and so ideally what we want is a model where you can make a request and get a response for the initial page and then if the server happens to have some new data in its events it can send that data back down to me as you can see sort of by the model it shows when there's any new data it can send it down right so in the case of a chat application if i'm sending a message to a group chat with all my friends the server will get that message and then about okay i've got this message let me send it to all the people that want to know about that message and if they're connected to this the server can then send that message to everyone that's connected so that's what websockets does right um websockets is built to solve that inherent problem with http and to develop that dual channel right so what websockets does is it defines this fully duplex bidirectional communication channel between the client and the server i know that's a whole lot of jargon but pretty much it means that the client and the server can talk in real time without having to continuously make requests so what it does is it if you want to do web sockets over the web you send a header to the server saying okay i want to upgrade from http to web sockets and it uses that same tcp connection that it originally established loading the page and the server's like okay let's upgrade once this upgrade is done those two the client and server can continuously send data back and forth with each other without the overhead which http might bring with it and we're going to talk a bit a bit about the performance benefits you can have by removing uh headers from requests so essentially one of the great things about it is it's really easy to implement and we'll get into some of the details with that soon and it's standardized and it's been standardized for quite a while so i don't understand why people aren't really implementing it more than they are and as the last point says there the headers are only sent once so in that initial handshake where the server and the client agree to upgrade to websockets that's the only headers that are sent the rest is just sending data back and forth and so you don't have that overhead when sending data so i'm going to sort of go over a brief example again with that same feed idea um feel free to go on this if you want we can try crash my server and so i'm going to sort of show you how you can inspect them um and sort of see what a websocket looks like so if you want you can again feel free to go on there and post a message so i could be like okay my name's dion and i could be like hey i can make that post okay and so what's happening here is i've made the initial request to the server we've upgraded our connection i've sent my message and the server saved that message to some database on the side and then it sent that message out to anyone that's connected okay and if we look at the websockets headers which you can find by going in this little tab you can see this initial header so i'll just quickly drag that open it's not okay um so you see the initial headers um which happened with that upgrade connection so you can see the status code from the server was okay we're going to switch protocols to web sockets and so if you want to look further into please be reasonable did i just see your drop tables okay so if you want to look more into what's actually going on behind the scenes you can go into this little tab called the frames tab um and you can see everything which is happening um behind the scenes so you can see in my case all that's happening for me is i've been i've upgraded my connection to websockets and now all i'm doing is receiving that data from the server so when you guys are making those posts it's going up into the server saving them to the database and then sending them back to me and you can see that by looking at these here right so um you could you can see exactly what the event was so i made an event on my client saying add to wall which um does what it says and it just adds that text to the wall and you can see the the data that came with it right so you have um the username of the person that sent it um and the message that came with it as well and this probably isn't the best implementation of it but it sort of just um defines jesus it defines that um that connection okay so we'll go away from that i also do apologize in advance um for including all the um the curly braces in my slides i didn't realize until afterwards i just did it sort of as an aesthetic thing and then i was like wow i'm actually presenting this to a bunch of python people they probably don't know what those are anyway so a lot of people criticize web sockets for its browser support and we can now go ahead and say that that is sort of a myth because websockets is widely supported now in all of the latest versions of the browsers including ie which is good i guess if you still support that and if you want to do further reading and find these sorts of things for other things i'd urge you to go to this website can i use dot com most web developers who've done any frontend stuff would probably interface with that but it's just a nice little way of seeing if you can use it okay so i mentioned earlier that we're going to be talking about other technologies used to achieve quite similar realtime goals to what websockets does and you may have heard of these technologies before and i'm not trying to decredit them because they still are used today but i'm saying websockets can do all this but it's a more standard way okay so there are these two things called polling and long polling okay so polling is sending an ajax request any x number of seconds so i could tell my my client every five seconds make a request to the server for some new data now my work actually does something like this right and it's not probably the best way to do things but it does work so you will get some sense of real time i guess because you will be getting data every x amount of seconds and it's sort of a workaround to not having to use that websocket and it should be used um sometimes when you only want to be receiving data on intervals we also came up with another way of doing this called long polling now this is still i think widely used today from what i can see and if you look at a lot of applications where you'd expect websockets to be used like for example a chat um you'll often see that you won't be able to inspect any web soccer headers and that's because people still do use this long polling technique you might have also heard this referred to as comment programming but essentially what it does is it makes a request to the server and it tells the server not to close that request until it has any new data so it keeps that connection open until the server finds something to give it and then after it gives it back the client is just like okay i'm going to send you another request to do the same thing and by doing that you sort of achieve that goal of having dual connection between a client and a server and there are upsides to it and downsides to it and we'll get onto that quite soon another way of doing it is called server events um or service events sorry um and it uses this thing called the event source api to send events from the server and it's not truly bidirectional because it's really based from the server sending it to the client not an interaction between the two of them and that's sort of the distinction between them and websockets where websockets expect both the client and server to continuously communicate this expects the client to sometimes communicate with a server but mainly for it to be server data being sent back and so this generally requires an event loop or asynchronous server and one of the downsides is you don't have that binary message capability which you will receive with websockets which supports uh binary data and one of the main upsides of this method and i guess is the arguable thing you might want to consider when choosing to use web sockets or not is using this method allows you to coexist with existing technologies and when i say that i'm saying it works well with rest apis and with things like oauth right so existing technologies which use that that model now websockets can't really interface with them properly and there's a bit of an issue trying to request from an api using websockets so you've got to kind of consider if you want to be using those sorts of technologies and if it's worth the tradeoff now the browser support for service and events isn't as good as web sockets which is funny it's pretty much everything except for internet explorer but that can also be polyfilled so i guess it's arguable that you can pretty much use web circuits or these in replace of each other the intended use case of websockets this is sort of a topic which is i guess controversial so i don't want to make my opinion um change this but one of the things i want to get clear to you guys is web sockets is not a complete replacement for http right websockets is an upgrade we saw earlier with the headers it's it's not a replacement for the http model but it's more an upgrade for that channel so you can't just replace http to use this because http provides you a number of benefits which you won't receive with just native uh websockets like for example as i mentioned on the slide automatic caching um and you can communicate with those other technologies like rest and oauth and one of the things that's often another critical point about websockets is load balancing the servers is often quite hard with the websocket protocol and it makes the whole implementation of deployment a little bit more complicated than just doing a http server and so the intended use case for websockets is generally things where you need that full duplex client server interaction so it's things where you're doing things in real time like creating maybe a game on the web chatting applications where you've constantly got that interaction anything which needs that low latency realtime connection over the web okay so we're going to get into some of the clients which are used to interface with websockets so these are the things which you use to talk to a server and the server either upgrades or doesn't upgrade with you and i'll get into what that means in a second so these clients are built in a lot of different languages including python which is an upside and even microplay and arduino have them which is kind of cool so if you're into iot sort of things you can use web sockets which is awesome so if you want to control any iot devices you can create that websocket connection with a web browser so for example if i wanted to interface with uh one of my iot devices let's say some kind of robot or something i could control it using my web browser with a websocket connection and so clients which interface with websockets aren't necessarily web browsers like we'd expect but the most popular implementation of these clients are built in javascript and are used as web clients and obviously they require the server to be able to interface with web sockets um if a client tries to request an upgrade with a server that doesn't support it it'll obviously respond with an error and you won't get that upgrade and if you want to read more into sort of clients and looking for the right one that you might want to use for in your projects i'd consider looking at socket i o which i'm going to go into a lot more depth in a second and looking into just some of the websocket libraries just by doing a simple google search for a websocket client and if obviously you guys are python people so i'd assume you'd be looking for things in python and those do exist so for this example i'm going to be showing you um the native websocket support which is in javascript um and i'm going to show you a bit of code sort of work through how quite easy it is to create a client which can interface with a websocket server so in this example um we start off with the initial socket connection which is just a new websocket uh object and again i'm sorry for pushing javascript on you guys i know you're not here for this um but you give this this new websocket connection and you define a ws route so for this example i'm connecting to my local host and then you have to define a couple of uh functions so the this socket object has an on open event which means once the protocol has been swapped and upgraded to web sockets this function gets called right and so in the example that i've got up on the screen it's just a lambda way of dealing with that so for example in my example i open that connection and then i send using socket.send i send the string pyconau up to the server and then when the server sends something back to me the socket on message is called i just realized i don't have too much time so socket io is another thing i want to also mention and it's sort of the main thing i want to push at you guys to use this is a nicer way of interfacing with websocket servers because it's sort of like a jquery to javascript right so it's sort of like this this library that takes the native websockets and makes a lot nicer and easier to use right and so it includes things like auto reconnection and fallbacks so say a server and a client don't agree on the handshake what it does is it uses a fallback mechanism to use long polling instead which is quite good if you want to support older browsers um and it gives you that ability to do that uh it also uh as native websockets does handles disconnection and connection and it gives this ability to create these things called namespaces which is sort of like a group of clients which the server can talk to and so a socket i o clientside code is quite similar to what you saw before you create that initial connection and you give it the namespace as one of the parameters to the url you have a connect event and you can also send events to custommade events right so the native websockets can only send events to a message event on the server whereas this i can define custom events to do that and i'm going to skip over this slide because i'm slowly running out of time but there's a lot of support for python servers which do do this and i'm going to be using flask for a lot of my examples which we should hopefully fly through but there's a lot of different implementations for using socket io and it's really really quite easy so you create a flask application most of you might have used flask if you'd ever done any web stuff with python but it's as easy as wrapping the app with the provided socket object and then creating a route which takes in a custom event name like for example my sockets um sorry this is actually an example for native websockets so this is where you're using that native connection um and then socket io is where you can do custom events and so this name space allows me to address a group of people let's say the name space pycon so i get all the people that connect to this namespace python and then i can send messages back and forth to anyone that's connected to that python namespace which is really quite cool for managing groups of people so let's say you've got chat groups you can use this namespace to achieve that and also like i said before the performance comparison between websockets and just http is quite big so http requests they always send that header whereas websockets don't so after that initial connection is done every other request is only framed by a two byte uh header frame i think it's called a frame and it it's not as heavy as the multiple kilobytes which a http request might have but then there's also that socket io idea from before also does contribute to adding latency to their websockets but it's not as much as http might i'm going to quickly go to a speed test if i can this is just on my local host and what it does is i enter a number of requests i want it to perform and it just does that so i just send in a basic um string to either my websocket endpoint or my api endpoint and you'll see how much quicker websockets is in comparison to ajax this isn't actually hosted on the on the web because i wanted to take latency out of it out of the equation but you can see it looks a bit small here cause it's in milliseconds but you can imagine having a thousand hundreds of thousands of users connected to a connection all doing these requests you can see how that can quickly get quite expensive now i was going to do a live demo but i'm quickly out of time i'm just going to quickly touch on deploying these websockets and so synchronous servers don't generally have support for this so we have to use libraries such as eventlet and g event to monkey patch some of the standard libraries in python so synchronous just means that it it uses blocking functions and using these libraries unblocks it um i'll go into more detail if anyone wants to know about deploying it afterwards because i think i've literally got a minute but deploying websockets does add that little extra layer of complexity and doing them with asynchronous servers makes your life a lot easier and that's sort of the point i wanted to get across so unfortunately i'm going to have to wrap up early but if you do want to talk more about this feel free to find me outside i'll probably be loitering around for a little bit and thank you for coming thank you dion as you can see he's very enthusiastic about it so i'm sure he'll answer your questions later on thank you