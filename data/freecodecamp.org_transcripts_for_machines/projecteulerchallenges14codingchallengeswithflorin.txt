hello well welcome everyone to this nice very nice introduction and thank you Quincy it's oh boy I think one day if I need someone to if I need someone to sell myself I will definitely hire Quincy so let me know if everything is right if you can hear me my name is Lauren pop I'm a developer from Romania I've been coding for seven years and in November I started a YouTube channel you can subscribe there if you want to follow me we have almost daily live streams and different tutorials and also if you want feel free to follow me on Twitter we're posting almost daily and yeah let's start working on this new crazy challenge Quincy has been has been asking me to start this because well yeah it's an interesting challenge and we're going to do it on the free code camp website and we're going to do it with JavaScript which is pretty nice yeah hello Eduardo feel free feel free to join the chat this will be this won't be that kind of animal tutorial where I'm teaching you and I know it's all formal it's just us hanging out sort of and solving coding challenges with JavaScript this is whoops this is what I'm doing on my channel also so I haven't prepared for these challenges because I wanted you to to see the progress so I wanted you to see that it's it's okay to fail it's okay to Google sometimes things it's okay to not have the perfect solution and yeah it's all part of developer journey keep in mind that I've been programming for seven years I've been working as a freelancer I had a job than freelancer again and another job and then I turned into content creator this is what I really like to do so yeah thank you freakin camp for giving me this huge opportunity I usually stream for 4050 people there are thousands and so people now watching which is crazy I was pretty nervous but now I find ya so say hi in the chat if you're watching if you can also it's don't tell anyone but my opinion you should support a freaking cab Channel it's they're doing an amazing thing so feel free to become a member and then you will be able to join the chat if you have questions at any time feel free to ask them also I might need your help sometimes so feel free to help me and yeah hello TM sunny Eric hi all of you okay so yeah let's see what's the take a jar how are you today so this is the project Euler set of problems coding challenges I will be this will be the first series and then I will be doing I think weekly live streams in which we're going over these problems there are hundreds of problems but this challenge is the first 100 now I'm not sure if we can go over all of them like that fast because they're getting harder and harder but well we're going to try all right so yeah project Euler is the cities of challenging mathematical and computer programming problems meant to delve delve into and familiarize oh by the way if my English is I think she's off that's because of nothing in native English speakers so yeah any time you don't understand what I'm rambling around feel free to stop me and yeah wait what as I said I usually am on my channel we're all here as a family we're learning together we're having fun I don't have my orange lemonade now you really have an origin mone don't we yeah we had worth having fun okay so I was thinking that in this stream we should do the first four or five problems to see how it goes as I said I haven't really look into it just that just the titles but we should be fine hopefully hello Travis how it's going also so yeah the first problem multiplies of three and five if we list all the natural numbers below 10 that are multiplies of three or five we get three five six and nine all right the sum of this multiplies is 23 okay so we need to add up the sum of the multiplies of three or five all right find the sum of all the multiples of three or five below the provided parental value number okay so apparently we have a function which gets in a number and we need to return the sum of the multiplies all right so let's see first we should probably loop over all the numbers from 1 up to well the number provided and we should check if that number so all the numbers in the loop if there are multiplies of 3 or 5 so if they their modulus I guess the division by 3 doesn't have any reminders hopefully I said that right right okay so hey Adam yeah thank you good so let's see we want to create our loop let me know if the font size is big enough if you can see the code I don't know if my face is in the way or I should probably remove these social buttons or whatever they are and yeah if anything is not okay just let me know and we can fix it all right so we're going to do a for loop starting with one well I guess yeah we should start with one because we could have a number less than three right so we should start with one and then we want to go up to the number right so I less equals than the number I plus plus okay and so first I'm going to do like a brute force thing so not very optimized and then we can try to improve it if if we find find a better way to do it hello Marco so yeah thank you by the way thank you to all the poppers the poppers are those who been following me yeah the poppers family thank you all of you for being part of this you've been very supportive I was very nervous at the beginning and yet highly appreciate you being here also Marco seems that he became a member to be in the chat so yeah very nice of you all right so we're looping over all these numbers now we need to see if they are multiplies of multiplies of three or five I guess I don't need this anymore all right so let's check here if I right so if I modulus three is zero or what and that's yeah you'll hear a lot of oops you're here a lot of goodygoodies your Hill a lot of things I just hope you enjoy it and the most important thing I really hope that you're learning something and yeah what we should be looking for is to become every day to become just you know if we can become one percent better than we were yesterday that's already a huge so yeah good so one one zero is five equals zero I always mix up it is the modulus operator or yeah someone correct me if I'm wrong I might be wrong multiple times oh that's right okay so if that's the case then we want to add this I to a sub right so let's create the sum with let not beat Const let's um first will be equal to zero and here we can say some classical's i right and so they will add up let's make some space here to have a pretty code and at the end we should return some right hmm if my logic is correct hopefully it is this should be good so let's see all right something is off what did I do wrong so if it's three or five then we should add AI K up mm that should be hmm does anyone notice and think where it could be the issue all right let's let's console that clock and see what we get so for a thousand we should get to top two hundred thirty two thousand one hundred sixtyeight and we get oh okay I think I know where the problem is so you can see the difference between this and the value we should get it's like 1000 and 1000 is the number we're looking so yeah it says here below the provided very parametric value so that's the issue we went up to including the number so we just need to remove here the equals and now you can see that we are getting the correct answer and let's run this and look at that pretty nice we solve the first one awesome all right let's think yeah I less the number Thank You Kaja I also keep in mind that there might be a delay from the time you're saying this well do the time you're commenting in the chat and I'm saying that so yeah keep that in mind all right could we improve this or should we think about improving something like this I always try to think maybe we could have some kind of ray method or something fancy but yeah it doesn't seem like you know we should even think about something it's pretty clear we have a sum which is zero then we'll loop over all the numbers and if they are multiplies of three or five then we are the sum so I guess this should be a pretty good solution if you have an idea of how can we prove this maybe I don't see it or who knows let me know but for now let's submit this angle to the next challenge all right good the second one even Fibonacci numbers now let's see what this requires each new term in a Fibonacci sequence is generated by adding the previous two terms by starting with one and two so yeah we have one and two the next one will be one plus two for those who don't know about the Fibonacci sequence then we have two plus three equals five then we have three plus five equals 8 and then we have so so on and so forth all right by considering the terms in the Fibonacci sequence whose values do not exceed an so again we don't need to go over and find the sum of the even value terms alright so let's take some notes we need to not exceed and what I'm writing here okay so up to n then we need even numbers all right and we need the numbers will be in a Fibonacci sequence right okay look at this motivating message you can do it alright we can do so I guess we should start by having the Fibonacci numbers the first two Fibonacci numbers right okay so the Fibonacci values should not exceed all right so let's do the following let a be the first one or I guess we could call it a be the first B one and let be me too okay so these are the first two Fibonacci numbers and now we want to go to keep adding these and changing the these variables this is why I used to add until we are up to the app so again now because we don't know exactly last time we use the for loop because we knew exactly how many steps we have but this time we don't know exactly the number of steps so we're going to use a while loop so then we're going to use while and we need a condition here which will be the condition so in the next loop B will equal well a will equal B so a will be two and B will equal a plus B right so it will be the next number so we need to check while B less than and right so this is our not exceeding it okay and also need to keep in mind that we need the even numbers all right and we need a sound so let's create that variable sum will be let's think we want the sum to be zero or we want the sum to be a plus B by default I guess will be a plus B oh but no because a will be an odd number so we only want the even number so that's be right we should we have be less than and Escada no because we want to go up to and knotek's oh yeah see yeah you're right so it not exceeding means that it doesn't go over so it could be up to and including very good thanks yeah so nothing's not exceeded but included okay good good catch see ya we might sometimes just mess it up but it's fine and this is why I like the live streams well on one hand I just just I know get the fool of myself but on the other hand I have helped my helpers here which will make sure that whenever I fail it will still around okay yeah and we'd also figure out when the code fails so probably this is a bit overthinking on my side just to buy the know lay out the building structures I guess the oh okay so here we want to get the new values so the new Fibonacci number which has said that a will be B and B will be a plus B but here is an issue because now we modified a here so we need a temporary value in which we're going to store a then we're going to change a to be B so it will be the next element in the Fibonacci sequence and then here instead of storing into a we're going to do temporary plus B all right and now if B is even so meaning that the division back to the reminder should be zero right so if it's even we want to add it to the Sun so sound plus equals B now if my logic is correct and I didn't screw it up at the end we should some and let's run to see look at that so this time we did it correctly yeah let me know if you understood this let me know if you have any questions I'm going to wait after I finish one one challenge just to make sure that everything is you understood everything yeah so apparently all the tests here running correctly for ten it should be a number sixty one thousand one hundred thousands of these numbers go like so big which is pretty pretty interesting okay I don't see any questions in the chat so I guess we can go to the next one now mmm well actually let me think could we improve this anyway I don't have an adn now I'm thinking about using recursion to find out the Fibonacci numbers but yeah that's probably not for this challenge so yeah let's move on to the next one all right largest prefect or prime factor okay so the prime factor of 13,000 195 are five seven thirteen and twenty nine what is the largest prime factor of the given number okay so let's see that's right again what we need to do so mmhmm we need the prime factor so not only the factor is the prime on so we need to check and we need to have a function is prime okay so well let's see this will check if a number is prime okay all right then we would probably loop again over the entire numbers as we did in the first challenge so from 1 up to the number but I knew that there is a trick so we don't actually have to go up to the number because I think there was either going up up to the half of the number or the square root of the number so I never really really got this exactly so we're going to test it because you can see here we have a huge huge huge number and well doing the loop over let's see thousand millions billions that's well that's huge also being the prime weekend we need to check all the number so we need to check if is divisible by only one and itself so it doesn't have any divisors I guess yeah so for loop up to to half let's go up to half of the number because so if you're thinking about twenty right so then which is half of it it is a divisor right but eleven it's not anymore and also twelve and thirteen all the numbers from half up but also ten it's not a prime because yeah it has it divisible by 2 and 5 hmm okay let's loop so we need often just the largest so we're going to keep track of the largest so that largest first will be and should start with one and now we're going to let me remove this so for left I equals I think we can start with two or should one is definitely not the biggest but oh well let's start with 1 I less than or equal to half of the number number divided by 1/2 divided by 2 and I plus plus okay now we need to check if is prime so the i if is prime and well actually we can do i number modulus equals zero and it's a prime right so prime factors okiedokie and I did this we're going to create another function just to make it more readable so is Prime and we're going to give it a number and here let's see we want to start from two so let I equals 2 because 1 is divisible so being a prime means it's only divisible by 1 and itself so we want to loop over all the other numbers or so from 2 up to the number and if we find the divisor then it's another prime okay I guess this also could go up to 1/2 hmm let's do the brute force and then if it fails we can optimize it so let I equal to I less than the number I plus plus okay and now if number divisible by zero then we can already return false right so we get up the function and we turn false otherwise we can return true and this is a prime number so let me put this here nice little bit okay so [Laughter] Quincy again speaking highly of me but I don't deserve it okay so we're looking over the numbers and now if this is the case so if it's divisible and if it's a prime then we want to store it in the largest so largest should be I right because that's the little loop okay and here we can return the largest all right this is my logic let's see if it's a good one okay so something's wrong let's do some yeah look at that test timed out so this might be a problem for us okay because it's a huge number I said that we'll do four or five but maybe we'll get stuck at three alright first let's let's cancel that lot to see what we get and whites and not working okay so for this we get 29 that's good for two we get two one okay that's because we go up to half and apparently doesn't good so let's see what happens for three I guess it's the same thing and we get only one four five yes apparently that's not okay let's go up to the number prime factors yeah feel free to correct me if you see the mistake there might be a couple all right so this should work for few but Danakil Thank You Quincy yeah also feel free to support the freaking camp channel by donating if you want super chat it will help the organization alright now yeah this is what I was afraid of we're passing these these tests but the big one is pretty big I'm happy to see that you enjoyed it Adam yeah this is what I did with the free code camp curriculum and also I'm going to do it again with the Piton series after everything's working and all always good so Andrews saying that in is prime only need to check if number is divisible by two three five and seven all other numbers are divisible by one of these ends if not a prime value yeah but it could be a for example 13 is a prime so I'm not sure if that will work yes sir now it's failing because of its test timeout so we need to reduce the number of loops we have which will be pretty interesting and yeah so cassia is saying so if I mispronounce your name sorry it's saying that instead of for lo pruning running from one equal from I equals to one can we run i cost a number divided by two till i is bigger than one so you're saying which should look backwards yeah that would be an idea and then we save half of the half of the loops yeah and I'm glad I did okay but then well we're going to have the same issue where we won't have to entry if we do equals the half of the number right and we can also not change the largest so let let's comment this out we need to do something slowly figure it out they're probably must be some kind of fancy thing to delete but let's try this so let by equals number divided by two I bigger than I guess one we can go there I I so we go the other way around and I guess we can check the same thing now the issue here will be for example for we won't have to write and also I let's make it let's floor this number so we have a fixed number so fluorine if the number is not a prime it is bound to have a factor factor less then its square root according to the common mathematical theorem yeah so this is Matt Matt Matt ish yes I knew something about the square root so you say that here we should go up to the square root of number Matt square root right so this should save some loops also if you check divisibility by two before the loop you can start with I equals three and increment by 2 instead of incremented by 1 that's another good good suggestion because we know that 4 is not a prime right so what you're saying here is that we can start with 3 we can increment by 2 so it will be 3 5 7 9 and here if the number is divisible by 2 then we can return false right so this is 4 for the two case alright for two kids [Laughter] and yeah for case we're divisible by two yeah I wanted to the comment nevermind alright so this will save a lot of loops to check the prime let's see how this works for a number now yes so it still should return to still timed out why did you have to do so big of a number alright so let's think well this is divisible by two but if it's two we want to return true right it might be two the number itself might be two so then it we should allow it so we need to check if is divisible by 2 and the number is different than two then we should return false right and now it should work for for this test case but we still have a lot of loops IFS let's see what we could improve I could try this now but yeah my only issue with this is that the largest yeah you can see that it's not working I guess we could do a seal but still we don't yet we don't get to mmhm all right so this doesn't work now we need to work on this one okay now for the prime factors here also we shouldn't go up the number think go to the square root right and we can also do what we did here skipping to at the time so one three like that two two two two well let's try [Laughter] okay now we get to a one so we have this case in there's where the largest prime factor it's the number itself whoa but look at this so we kind of passed the test the big one which is pretty great that means that we're not timed out anymore which is pretty pretty great now the only thing we need to figure out is what are we doing when the large prime factor is the number itself two two two two two let's think so but wise oh well I guess I think I know so if the number itself is a prime then that's the largest right so here we can just check if is prime so if the number is prime then we can just return the number right because it's itself and otherwise we need to do all this mumbojumbo fingerprint [Laughter] all right look at that we have one percent done of and this project Euler pretty nice so yeah see how we started with a bruteforce and we slowly slowly adjusted the code to be faster and better and yeah okay yeah also marco is having good point someone also suggested this if we start from the back and yeah that will speed it up even even faster because yet the reason I didn't do from the back it's that we had this case scenario when we needed to return the number so I guess this is in the case where the number itself is a prime so then in order to simplify this well to speed this up even more we could do that we could start by setting I to be square root of the number we could we could go down to 1 and we could do I minus 2 so this way whenever well I guess we could even not store the largest and just return now so if we find something like this return i right because we're fighting so the first one that's divisible by the number the is divisible by the number and if it's prime then it's the bigger bigger biggest prime right okay I think this speeds it up even more let's see okay so something's not good so square root we go up to one oh I see where we might so we might go we might skip the square root here might be something like an even number right so it might be something like 30 and then we're going to 2826 24 so we're dropping like with two and they're all even number so they're not primes right then we need to see if this is even so I guess I could just tour so this is we'll already solve the problem and it works but sometimes it's good to stretch it a little bit more to make it better if you Canon well if you have the time I yeah I have the time so let's stretches stretch this even more so we want to store the square root right and we want to see if it's an even number and we'll start with that hello Edmundo and Lawrence thank you on behalf of free code camp not sure Quincy if I can do that to it thank you on behalf of a code camp for supporting their neuron that organ is organization all right so we start with this and if the square root is an even number then I guess let's add one to it so square root plus equals one right and now we can start with the the square root here and hopefully this will fix the bug we had and also speed this up even even faster okay so no hmm wasn't this the problem let's see what we get so if we do undefined okay so probably getting here it's not a number are we skipping it hmm let's cancel the flog all the ice to see okay so yeah look at that that's not good we have decimals so let's floor this all right and now do we get look at that we get 29 so yeah should this work now us perfect I don't have time now but if you do have time use this solution and try to see what's the difference in the speed with the solution we had earlier but they say this is much much faster yeah although the curve is not the prettiest but oh okay let me know if you have any questions for this one don't be shy in the chat if you're in the chat say hi say say why say whatever you want it's a open communication it's not don't let me feel yeah all right so I guess we can submit this and go to the fourth one right ask me later please okay let's see palindrome this is nice so the largest palindrome product a palindromic number reads the same boat both ways so for example 1 1 2 2 1 1 is the palindrome because you can redo the same backwards and forwards or 1 0 0 1 or we have here 9 0 0 9 so it's the same it's the same thing select the chat okay not sure conceived Markham meant about project Euler to the back or just just the the challenge itself all right the largest palindrome made from the product of two digit number is nine thousand and nine so 91 times 99 find the largest palindrome made from the product of two and digit numbers okay you hmm this is now quite interesting so yet there aren't a lot of taste test cases first we need to construct this number so these three digit numbers two digit numbers and we can start the same way we did the previous challenge so with the biggest number and then slowly decrease but the there's a catch here so what's the largest palindrome made from the product because well I'm thinking about having two loops right starting with 99 and 99 and then we do 99 times 99 or 99 times 9 8 and so on and so forth but then if we only drop in one loop we might get to a palindrome but then might not be the largest let's see so $4.99 we could 99 times 99 then drop to see in this case the correct answer is 99 times 91 so we could continue to drop one number right but something like this 97 and then we eventually get to 99 times 91 which in this case works but we might get down to 99 times I don't know for the three digits we might get down to 99 999 times I don't know 101 for the three digits let me put three digits here and this could be a palindrome but it could not be the biggest the largest okay also we need a function to determine is palindrome this is another thing we have to do and yeah I was thinking also to drop them by one but then the toast also not it's not the best or we could just do the brute force Cal see all the palindromes and then return the largest yeah I think that should we start okay so let's have an array palindromes like this and now we're going to have two loops so starting with I equals so the N we're getting is the digit and in order to have so if we get to the big we want to start from 99 so let's see two two two two two it could do something like so the the number could be array array of n this will create an array of length n fill it up with nines and then join it so yeah let me show you what this black magic is so we're creating an array of length N and this array will be empty and then we're filling it up with the number nut so let me console like all the steps here so you can see so array of n then console dot log array of n fill with nine see we have an empty array and we have an array of 999 and then well we can cancel out this number which is array field join you can see here we have 999 but what this doesn't show is that this is a string so well we could say type off so you can see it's a string but we need a number so in order to convert to number we could use percent like this or what I usually do it's a at the plaza front where's the buff yeah all right okay now we have a number and this is the biggest number so I guess I could say biggest oh no just leave it number all right now let's go back to our loop well not sure I did if there we need the forloop so let I will be number I greater than equals to 1 and I then for let J equals number so we want two loops because we want to do the multiplication there J greater than equals to 1 J minus ok and now if I times J is a palindrome so is palindrome then we want to push it to the palindromes array and we're pushing to the array and then at the end we're going to get the biggest number palindromes that push well let's store this Const multiplication I times J and here we can do multiplication or and here if it's a palindrome we can do that alright let's return the palindromes here just to have something returned and let's create the is palindrome function so function is palindrome and we get here a number how do we check if this number is a palindrome okay so I can see here there's an infinite loop nickels ki I don't see why hmm that's interesting okay yeah that's what I want to do Mike did it already so we have a number and we need to check well we need to reverse it and check with itself right and if they are equal then that's vulnera so I want to return here the value of number two string and show you why we needed two string equals two number two string again so we're converting it to string because we can do now split so we can get all the characters of the string and convert them into an array we can reverse this array reverse oops can type and then we can join it back to a string so now this is the reverse string of the number and this is the number all right let's see so two string is played in an array we reverse the array and then we join back to a string but it still says that might be an infinite loop why you you can anyone see ever function yeah it's fact we want to use a arrow functions now but well guess we can't we could so why is this well now we have all the palindromes right but well I guess I need to forget to console that vlog this so here we should get a bunch of palindromes look at that so these are all the palindromes which are quite a lot and we need to get the maximum from this we can do that easily by saying Mad Max and with the structure the array so it will go inside the method max function and it should work now yeah I still don't know why it said that we have an infinite loop okay what will happen if we say four here yeah so it might run for a while this is why probably here the time test test stand out you and it's interesting so maybe if number is negative then there is an infinite loop because it will never be positive again well the number can be negative here we have 2 & 3 so from the test cases we can't really have a negative number and also if it's negative then this condition will be false right and it will not loop yeah so it shouldn't if the number is less than one then this condition will be false so it will run well it will get up to the loop all right yeah so this works although yeah I kind of don't understand why they say it's anything look oh wow I guess it works let's see if we could improve this so one way now we're looping over all the numbers so if we have 99 we're having 99 times 99 loops which is a lot and well in this case we only should look like eight times nine times to get to this value how can we how can we get to number to the to the big largest number faster so we don't have to loop over because it is not the best way now we're just getting all the Palin terms let's see last night and don't quite have an idea now there is something should be something so we can stop sooner you maybe saved a number yeah yeah that will be actually good we save but it's it improves it bad because instead of having an array of I don't know thousand numbers or and which is not that big we just have one number but yeah that's that makes sense so console are just I guess this needs to be minus infinity so the lowest number possible if it's palindrome and and and the multiplication is bigger than the largest then here we can set the largest to be the multiplication right so now we don't do this we just say largest and we need to convert this to let because we can't reassign constant okay this should still work and we saved a bit of time here that's right I'm just looking here so I don't want this kind of mmhmm you okay yeah I guess we should move on and if you yeah by the way I didn't say this in the beginning I should have these challenges you should try to do them on your own and then well these life stone will be uploaded and probably this section of project Euler will be uploaded separately so you can watch it then right the loop doesn't need to continue if much smaller than largest perhaps yeah it might student but so for example in this case we get 291 times 99 right so we only have like 10 loops but we could get so we might have a case where we have like 98 times something being the biggest so then because of this number going lower than jumping back up 99 multiplied by this number being wants being a smaller number then the product of them will be bigger so yeah that's also not that's also not the perfect solution all right yeah I guess huh let's leave it like this for now I kind of have something in my mind somewhere I think I saw this but they for some reason can't remember now so if you find this dissolution please let me know well the faster solution and I'll be glad to take a look and I'm curious I make search for it after this dream all right and let's see okay let's wrap it up now we did four let's go back so we did four challenges and we're going to I'm not sure yet on which days I'm going to be live on free code camp we still not to still have to figure that out but I'm going to be live every week and we're going to continue this now for those of you who are watching and I highly recommend you taking part of this challenge it's pretty fun I recommend that you'll take a look at these problems and try to solve them on your own and when I'm doing live during the live and well don't spoil the answer to me but then you can see how I'm solving it and well it it will be much much useful for you than just seeing me solve this right so yeah I guess I guess that's it I hope you liked it let me know in the chat if you did and if you won meat is still to continue to do this thank you for Africa camp for letting me do this on their channel it's a no it's more than I ever expected I'm doing very grateful for that and yeah let's help developers get better programming find it well my job is to make programming fun and yeah thank you all for watching Thank You Lawrence for for your encouragement thank you all for joining and I'll see you in the next live stream have a great great day forward bye