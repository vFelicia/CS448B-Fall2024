Welcome to this learn Python through game development course. In this course, we've compiled the five great game programming tutorials, all in Python. To help you learn Python. through creating games, you will learn how to create Pong snake Connect for Tetris. And finally, a simple multiplayer game. This course is all about learning through doing. If you want to learn Python syntax directly, check out our other big Python course though there's a link up here or down in the description. The some people learn best by just jumping around to projects, especially people who may already have a little bit of experience with another programming language. But whatever your experiences, you may learn best by just jumping into these game development projects, a few of the tutorials use PI game, you don't have to know about pi game already. But you can always check out our pygame course, the links right up there down in the description again, you should be able to follow along, even if you don't really know that much about pygame. So check the description if you want links to the code. Or if you just want to learn more information about the people who created these great tutorials. So let's jump right into it. Let's take a look at what we're going to be building today. Classic Pong game. So we got a paddle on the right, we got a paddle on the left. And we've got a ball in the center. Okay, the ball goes off the screen. And the opposite player gets a point and the ball continues. Okay, so that is what we're gonna be working on. So let's get started. Today, we're gonna be doing this by using Python. Of course, this is written in Python three. But it should work in Python two as well, I don't think there's any Python three specific code in this particular tutorial. So we're going to be building this on top of the turtle module. On turtle module, it was a nice little module, it lets you do some basic graphics, it's great for getting started with games, a lot, a lot of tutorials use pygame, which is amazing. It's got a lot of great features. But for beginners, this is a lot simpler. And it's built in, you don't have to install it like you do with pygame. So now that I've got my turtle imported the module, I need to create a window. So I'm going to call it w n, you got wind w i n or wherever you want to call it. And but I use w n and it's turtle dot screen, notice the S is capitalized, it's very important. And I'm going to give it a title. And I'm going to call that poem by at Tokyo edtech. That's my Twitter handle. And do feel free to leave comments I do take keep close eye on things. And if you having trouble, let me know. And I want to change the background color of the window to black classic Pong. And I want to change the size of the window. And I want the width to be 800. And I want the height to be 600 pixels. I'm gonna do something called wind tracer. And this one's a little bit hard to explain. But basically what that does is it actually stops the window from updating. And so we have to manually update it, what this lets us do is basically speed up our games quite a bit. If we didn't do that, things would run much, much slower. So every game meet needs something called a main game loop. And this is where basically all the meat and potatoes of your your game goes to. So we're gonna make a loop wild true. Not gonna put four spaces there. Um, you can use tabs, but spaces are recommended. But whatever you use, make sure that you are consistent. You can't make spaces and tabs, and then we'll do Windows Update. And what that does is every time the loop runs, it updates the screen. Okay, just a quick note this this program is written for beginners, so I'm not really using object oriented programming, I'm not really using classes, except as it relates to the turtle module. This is basically a really straightforward, old school style of programming methodology. So let's run that and see how it goes. And what we should have is we have our title, black background. It is 800 wide by 600 tall. 00 is at the center. So plus 300 minus 300 plus 400 minus 400. Remember those numbers because they'll come in handy in our next few tutorials. So that's all for this particular lesson. I just want to get you started. We move on to lesson two, we'll add our paddle on the left, paddle on the right and our ball in the center. In this part of the tutorial, we're going to add our paddles to the screen and we're going to add the ball to the screen as well. So let's get started with that. So basically what we have in Pong is we have Pat, I'm gonna call it paddle a, we have paddle B. And we have a ball. So those are the three items that we need to add to the screen. Now, as I mentioned earlier, in the previous video, we are using the turtle module to, you know, add our graphics and to open our windows and things like that. It's very, very convenient, it works great for basic games, a lot of people use PI game, which is great. But for simple games, this is probably an easier way to get started. So everything in our game needs a name, so I'm going to call it paddle ng very original. And it is actually going to be a turtle, what's known as a turtle object. So to do that, it's turtle dot capital turtle. Notice the capitalization small t, because that is our module name, capital T, because that is the class name. Now, as this tutorial is aimed at beginners, I'm not going to talk about classes, I'm not writing in object oriented style, I'm just writing it in, you know, functional style. Although there are some objects kind of patterns here, you'll you'll see. But for beginners, don't worry about that stuff for now. So then what I want to do is paddle a, I need to set the speed. Now this is not the speed that the paddle moves on the screen. This is the speed of animation, this is just something we need to do for the turtle module. And what this does is it sets the speed to the maximum possible speed, otherwise, things would be really slow. We want to give our paddle a shape. And there are a few built in shapes. And we're going to use square in this case. Okay, there's Circle Square, circle, Square Triangle, a few others, we're gonna give our paddle a color. And we're gonna call it white, because that's what Pong looks like. And we're going to basically do something called pin up. Turtles, by definition, what they do is they draw a line as they're moving, we don't need to draw lines, because that's not what this program does. So we do the pet up, and I want my paddle a to start at minus 350. That's an X coordinate, and zero and vertically centered in the screen. So in our game, 00 is in the middle, minus 350 plus 350. So I'm gonna go ahead and run that and see what it looks like so far. Okay, so this is our left pattern. Now, you know, you've played Pong, you've seen the demo from the first video. Clearly, it's not the right size. So what we can do in our program is this. Now just just for your information, by default, that shape is 20 pixels by 20 pixels, so it's 20 pixels wide by 20 pixels high. So what we're going to do is we're going to stretch the shape. So we use the shape size method, you can see I'm using Visual Studio codes, very good program, you don't want a Mac, and it tells you you know, what you can do stretch with stretch length, etc, etc. So what I want to do is I want to stretch the width by five sets to be five times 20. So that'll make it 100 tall. And then by 20, wide, and stretch limb is going to be one we're gonna keep it at the default. So let's save that and run it. Okay, so you see now we've got a paddle over here, 20 pixels wide by 20 pixels high. Okay, now. So that's paddle a. Now I'm kind of lazy guy. So I'm just going to copy this. So what I always recommend if something's similar, similar styles are similar, you know, functions, you know, get it working right once and copy it, paste and just make the necessary changes. So now that we've done that, we just need to change that to be. So if you keep consistent names, it will really help your programming. And in this case, we want it to go on the right side of the screen. So that's gonna be plus 350. So I'm gonna run that and test it. And testing your program is very, very important. At each stage, a lot of beginners I don't know why they insist on typing the whole program in and then trying to test it and you'll never be able to figure out where the problems are, especially as a beginner unless you do it step by step like this. So we got our left paddle, we got our right paddle, so I just call it a said paddle a paddle B. And then the last thing we need is going to be our ball. So I'm gonna just go ahead and copy this because it's basically the same thing. I don't need it stretched. I want to keep it the original size and I Want to start in the middle of the screen, and I'm going to call it ball instead of paddle. So you see once, if you do it like this method, if you get everything working correctly, there's no errors and you tested it, you just copy and paste, it really speeds up your programming. So I'm going to run that one more time. Okay, you can see we've got our left paddle, paddle a, our right paddle, paddle B, and we've got our ball, which is starting in the center, so we're off to a good start. Okay, so we've got our pond window, we've got our paddle a on the left, paddle B, on the right, we've got our ball in the middle. So in this lesson, we're gonna learn how to move the paddles using the keyboard. Okay, so what we need to do is to basically, we're going to create some functions, okay. And if you haven't ever used functions before, a function is basically kind of a piece of a program that does a, something that's been defined for it. So. So in this case, we want to move paddle a up, we want to move paddle a down, we move paddle B up when we paddle B down. So to use functions, you first need to define your function. And I'm going to call this first function paddle a up. If you recall, in the last video, we talked about doing one function at a time or one piece at a time, getting that working perfectly, and then you can copy and just make the necessary changes. So that's what we're gonna do here. Okay, so paddle a up. So to move the paddle, what I need to do is I need to know the current y coordinate. So what I'm gonna do is I'm gonna say y equals paddle, a dot y core. Okay? Now this part here, paddle A is the name of the object we created here, we call it paddle a. And the dot y core method is from the turtle module. Okay, what that does is it returns the y coordinate. And so we're just assigning that value to a variable called y, which makes sense. Okay, so we've defined the function using the def keyword, you notice we have a, I guess, the tab, in this case, whammies space, we'll see might get an error there. And I'll explain that a second if we do. And it's supposed to be set to automatically change the spaces, but I think it's not set that way. So I'll leave it the way it is. So then what I'm gonna do is I'm going to go up on the screen, it's this way, so up. So why increases as we go up, it decreases as we go down. So we're going to do is I'm going to add 20 to why this is the way you do that. You say y plus equals 20. So that will add 20 pixels to the y coordinates. Okay, so now notice, we've just calculated the y's, then what we actually have to do is paddle a set y to the new y. So now having a function doesn't actually do anything until we call the function. So the function has just been defined, but we're not using it. So what would you do is you do something called a keyboard binding. Okay, so in the turtle module, we need to do w n. So that was our window. And listen, this tells it to listen for keyboard input. And we're going to use the on key press method. Okay, and watch what I do here, paddle a up. W. Okay, so let me explain what that does. So, this line here, it tells the program to listen for keyboard input. This line here says, when the user presses W, notice that's a lowercase W. So if you have caps lock on, it won't work. Call the function, paddle a up, here's our function, paddle a up, paddle a up, says get the y coordinate, add 20 to the y coordinate, and then actually set the y of the paddle to the new y coordinate. Okay, so let's test that and see what happens. Okay, so I'm going to hit the W key. Okay, so you can see how it is moving up. Okay, we actually moved off the screen. So now that we've gotten that working, okay, what I can do is I can copy that and I'm gonna change this to paddle a down. So instead of adding 20, I'm going to subtract 20. And then I need to do a key binding for that as well. So I'm going to copy and paste that. So it's gonna be paddle a down and in this case, I'm gonna use the AES key. You can use whatever key you want, but I just chosen those as usually swa SD on the left, and the arrow keys on the right. So again, I've done one thing, I've changed it, now I'm going to test it. Okay, so w s, okay, so everything's working exactly as expected. So then what I'm gonna do is, now I've got both of those working, I'm gonna copy it, and I'm gonna do paddle B. That'll be, that'll be. So if you keep your naming consistent, it makes it very, very easy to do what I'm doing, which is to be lazy. And just use copy and paste. And then here. Now for paddle B, I'm going to use the arrow keys. And then for the up arrow, it's it's a little bit different use up this capitalize and down is the down arrow. So again, I made a couple changes, I'm going to test my code. Okay, so w s on the left, up and down on the right. And voila, there you have it, moving the ball. This is really kind of the meat and the central kind of part of the program. This is where we actually get the ball to move. So we need to get to move, we need to get to bounce off the top and the bottom. And we need to get it to bounce off of the paddles. And so I'm going to show you how that's going to work. Because we have our paddles can move. And but the ball does not yet. So let's get started with that. And so what I want to do is with the ball is I want to separate the balls movement into two parts, an X movement and a y movement. So we're going to call that I'm going to say ball dot d x d means delta or change. You can even call it XP or whatever you want to, but dx works very, very well. Now on my computer, I found that two number two works very, very well, my computer at home, actually, it was like 0.1, it's much, much faster, I don't know quite know why. So you might have to play with the numbers here to get it to where you feel the game should be. So So dx and dy y equals two. So what that means is every time our ball moves, it moves by two pixels. So since x is positive, it's going to move to the right to and since y is positive, it's going to move up to so it'd be kind of moving up and diagonally. Okay, so to get that to actually happen, we have to go inside the main game loop. Okay, and in here, I'm gonna say move the ball. So what we need to do is ball dot set x. And what we want is the current x coordinate. So I'm just basically kind of combining what I did up here into one line, plus ball.dx. Okay, so the ball starts at 00. So 0x. So the first time through this loop, it's going to go to an x times the loop is gonna go to two, so depending on your computer speed, it could just fly off the screen, or it could, it can go a little bit slower. So again, you have to play around with that a little bit. So that when I say ball dot set y and basically the same thing I could have copied and pasted, but I should have done and ball dot d y. So I'm gonna say that and I'm gonna test and see what happens. You see some red lines here. I think there's gonna be maybe we problem. Yeah. So I'm gonna run that and explain why it's not gonna work. Okay, so you see here, I've got an error. And this is something again, beginners, I don't know why do not want to read error messages. The error messages basically tell you what's wrong. CCR says tab error, inconsistent use of tabs and spaces. Okay, so I mentioned this in an earlier video. So here, I use four spaces. But here, it's a tab. Okay, you got to use the same thing each time. So I'm gonna go with four spaces, that's actually the preferred method. Now I can set my editor up. So when I hit a tab, it changes the four spaces automatically, but I'll do that another time. Hey, so I'm going to run that. And hopefully we'll see the ball move. Okay, so plus, plus and right off the screen. All right, which is what we expected. Okay, so that's, that's good. So now what we need to do is we need to do some border checking. So what do we want to happen when the ball hits the border? Okay, so since it's moving up into the right, we'll do the top border first. Once you get the top border working, then it's easy to get the bottom we're working. So all we have to do is we have to compare the balls y coordinate Okay, so once it gets to a certain point, we want it to bounce. So if you recall earlier in the program, we set the height of the window to be 600. So so that means that the, the top y coordinate is plus 300, and the bottom is minus 300. Okay, but the ball itself is 2020, high by 20 wide. Okay, so what we'll do, then is what kind of split the difference, so we're gonna say if the ball dot y core, so if the current y coordinate is greater than 290. colon, and I gotta use spaces, it's telling me if it's greater than 290, what we do is we we set it back to 90. This avoids certain types of problems. And then what we need to do is we say ball dot d y times equals negative one. And what that does is it reverses the direction. Okay? So if d Y is two, so d y minus negative one is negative two. Okay, and that should reverse the direction of the ball. Let's run that. Let's watch it and we're good. That's exactly what we wanted to happen. Okay, now, since this is working, correct, exactly as we want it, I'm going to copy and paste that and just make some changes. So on the other end, it's less than negative 290. We set it to negative 290. And that is that so let's test that. To test that we'll need to start the ball off with a negative DUI for now. And again, notice how I'm making a change testing making a change testing. Okay, it's working. That's about what we wanted it a little bit off screen, bear. But we'll we'll let that go. So that's the borders. That's the top and bottom borders. Now, the next thing we need to do is the left and right border. So this is where it gets not more tricky or anything, but you got to think about what we want to happen. So in this case, because we're looking at left and right. Okay, we're not looking at the y coordinate, we're looking at the export. And now what we want to do is if the x coordinate, basically, if it goes off the right side, so if you remember, we said the width was 800. So that means it's plus 400 on the left minus 400. On the right. So let's say if it's greater than, we'll say 290. Or sorry, 390. That tells us basically, it's gone past the paddle and it is off the screen. Okay. Okay, so, if that's the case, basically, we're gonna put the ball back to the center, zero. And then what I can do is I can, maybe ball.dx may have it reversed direction. Okay, so let's take a look at that. Again, I'm testing to make sure it works. And if it does that, I can copy and paste and do the other side. Okay, so we got an error. Okay, so it says we got a lot of weird stuff here. That was a really long one. And say here, if you see it says line 87. So here's the line where it thinks the error is. And there's a lot of different weird stuff. But basically, what I forgot to do was zero comma zero. So let's test that again. So it shouldn't go off the screen and went back to the center and reverse direction. Okay, so we know it works. So let's copy that and paste it. And again, we're just gonna reverse it. So if it's less than negative 390, and that's all we got to do. So, again, let's test it. Hopefully it will come back. Okay, so that's basically, that's exactly what we wanted to happen. Okay. So in this lesson, we're gonna learn how to get the ball to collide with the paddles. So let's see what we have so far. So we've got our ball, it's bouncing off the top of the screen, and it's at the edge of the screen, it goes back to the center, which is what we want. So what we got to do is we got to make it so that when it touches the paddles, it will reverse. And how we're going to do that is basically, what we're going to do is we're compare the x and y coordinates of the paddle and the ball. So if we look at our code, we put paddle B at 350. So the x coordinate of the center is 350. If you recall, the center, it's Sorry, it's 20 pixels wide, by 100 pixels tall. So we need to basically look at, we need to make sure that the ball is basically between here and here. And that it's basically between here and here. If it is, then we'll call that a bounce. Okay, so let me kind of play the math a little bit on that and give that a shot. So let's, let's again, as I mentioned before, we're just gonna try and get the right paddle working. If we get the right paddle working, then it's easy to get the left paddle working. Okay, so I'm going to say so paddle and ball collisions. Okay, so if the ball dot x core, so if the balls x coordinate is greater than. So we said 350, it's 10 wide. So it's greater than c 340. And the ball? Well, should I leave it at that? I'll leave that No, we'll come back and fix it in a bit. So that's one condition. And the balls, y coordinate is less than paddle b dot y core, plus 50. There's a lot of stuff in here. And there's a lot of different things here. Ball dot y core is greater than paddle. b dot y Cor. Minus 50. Isn't glad that scrolling over from explain that real quick. So if that's the case, either. If that is the case, basically, we just want the DX, same thing we did at the top times equals one of those is x naught y, sorry, negative one. So if it's going this way, the dx is positive. It's gonna balance and go back this way. So what we want to see is the ball x coordinate greater than 340. That means the edges are basically touching. And is it between the top of the paddle and the bottom of the paddle actually used to be 50 is probably 40. Because of the size of the ball. Let's Let's play with that. Let's test out see what happens. So I'm gonna run that. Okay, so do you see what happened there? Which is not only one. Okay, see it bounce there. Watch what happens. If I miss it. See, there's like a little bit of a glitch there. It's because even though it's behind the x coordinate is greater than 340. And it's between here. Okay, so you see how that's kind of acting weird. So we need to do is I want to add this condition. And ball that x score is less than we'll say 350. So that gives it basically to the middle of the paddle. So we'll say ball dot set x to 340. So that moves it back to the left a little bit. And then it reverses the direction, which is what we wanted. Okay, so let me test that one more time. Make sure it's working. So bounces Which is good. Hopefully to get past and see. Okay, so you see how it did not get stuck that time. So that's basically what we wanted to happen. Let's just test it one more time. Yep. So that's, that's where we wanted it. Hey, so I'm just gonna basically take this, I'm going to copy it, paste it. And we're gonna do the same thing on the other side. So minus 340. greater than minus 350. And the top and bottom doesn't matter. But in this case, it's gonna be paddle a, not paddle B. That will give you some definitely some weird glitches. And then same thing, we're gonna reverse the ball. So let's test it again. Okay, so over here, he's the up and down arrows, he bounced. Over here, we're going to use the W and s keys. That's it. Okay, so something went wrong there. So I know what I did wrong. So I had set x here to 340, it should be negative 340. So again, notice, because I'm testing it, you know, after every little bit of code, I knew that the problem had to be in here somewhere, because that's the only thing I changed. I just I can't emphasize that enough. Because my students, like I said, they always want to type the whole thing in and then debug, which is never a good idea. Okay, so let's test it one more time. So you see this process, we're iterating, we're testing and just making sure everything is working as expected before we move on, okay, so that is that for that section. So now we've got collided with the paddles, it's going off the screen, the next thing we need to do is to add some sort of scoring mechanism. So here's what we have. So far, we've actually got a functioning Pong game. The paddle on the right is moving using the up and down arrows. paddle on the left is moving using W and s, the balls bouncing is doing everything and he's due. Next we want to add a scoring system. So let's go and take a look at that. So basically, what we do is we want to draw the score on the screen. And here's how we're going to do that. In Python using the turtle module, so we're gonna do is we're actually going to create a pen, okay, it's called a pen, but it's actually just a turtle, just like the ball like the paddle. But the turtle module gives these turtles objects a lot of different abilities. So I'm gonna make a pen. And it like the other is a turtle dot turtle. And I always spell that wrong. And keep an eye on the capitalization. So small t for the module name, capital T for the class name, which we it's happening in the background. Same thing as before, so pin dot speed. And again, this is the animation speed, not the movement speed that we're going to move, but we're going to give it a color pen color, the shape doesn't matter because we're not going to see it. If we want to print in white on a screen, like classic Pong style, and pen dot pan up. This is because we don't want to draw a line. When the pen moves, every turtle actually starts out at the dead center of the screen, then we move it somewhere. And if we don't do pen up, you'll see a line moving between those two points. And then here we want to hide the turtle because we don't need to see it. Now with the ball and the paddle paddles, we didn't hide it because we want to see those on the screen. But the pen we don't want to see, we just want to see the text that's going to write. So pen.go two, and zero comma, I think 260 I think and I played around with the numbers, that's why no 260 is number one. If you remember, again, the screen height is 600. So that means zero to 300 here, so we want the score to be right around this part of the screen. And then it gets pretty easy at this point is we use the right method. So we want to write and when the right player a. And now when the game starts the score, of course is 02 spaces, Player B, zero, comma, anywhere align equals center that will center the text force around that point. And then we want to choose a font. You know, watch here, I've got an extra set of parentheses here. Okay, don't forget that. And I want the font courier that's kind of old school techie. choose a font size of 24. And normal I think normal I think you choose bold and italics I'm 100% sure on that one. So be very careful. Again, we've got a set of parentheses here. I've got an extra set of parentheses here for the font. So because there's three arguments we got to send there, okay, so now, test your code. Make sure This is working. So I run that. Okay, so that's what we wanted to see if red little space after Player B. Hey, but yeah, that's that's basically what we wanted. Okay, so that's how we get the default score on the screen. So what we got to do is we need to keep track of the score. And so what I'm going to do, and I'm going to put this up here, and score, so I need to create a couple variables, I'm going to call it score a, and we start the game with a zero and score. B is going to be zero. Now, down, down here, okay, so we get a score when the ball goes off the screen. So here's the right sides of the ball goes off the right side, think to yourself who gets a score, of course, that is going to be Player A. So what I can do is score a plus equals one that adds one to player A's score. And by the same token, on this on the other side, if the ball goes off the left side of the screen, Player B, gets Okay, so let's run that. Oops. Okay, so nothing, we don't see any change. Can you guess why? Okay. Now, if you said, Well, we didn't update the score on the screen, you'd be 100%. Correct. Okay, so what I'm just going to do is I'm going to copy this line here. And I'm going to put that into here. And you'll see, what I got to do is instead of the zeros, this is just print, you know, basic printing, you know, one on one, if you're not sure how to do that, I do have a video on that somewhere. I'll try to remember to link that below. But how printing works. So we use the format method on our string, and we want score a and score B is what that does is put score a here and score B there. So I'm going to make sure I'm using spaces. I'm gonna copy that. And I'm pretty sure this is correct. So basically, every time I update the score, I need to update the actual printed score on the screen or the show's displayed spruce score, I should say. So run that. Now, watch what happens here. Okay, so you can see it did update. Okay. But clearly something is wrong. Because basically what it's doing is it's just printing on top of itself. Okay. So what we have to do is, before we do that call the right method, we say pen clear. Now actually clear what's on the screen. You know, it happens so fast that you don't see it. But it actually it does. So take my word for that one. Again, if you're using pygame, or some other, you know, framework or method, you might not have to do this type of steps. But for the turtle module, this is what you need to do. Okay, so I'm going to run that. And let's watch what happens. Okay, so Player A just got to a point where we just got to a point, and so on, and so forth. So, yeah, so basically, we've got a pretty well working game here. Again, the game never ends, you just go until, you know until you give up and get bored, which is pretty easy with Pong. So I've got Yeah, I got another tutorial coming up on this series, I'm gonna show you how to add a little bit of sound, which is interesting, especially depending on the operating system that you are using, I'm going to show you how to add a little bit of sound to your game. So just basically, you know, what you need to do to get started with that is you need to have a sound, you need to have a sound file. And what I've done is I have downloaded this file from I forget the site now, but it is balanced dot WAV and it's like kind of a classic old school. Bouncing sound. You'll hear it in a minute. Now, Python is generally pretty cross platform. Basically everything that we've done so far, it doesn't matter which operating system you're using Linux, Mac or Windows, everything works, the same. Sound is one of those things where it doesn't work the same. So right now I'm on a Mac, and I'm going to show you how to do it on a Mac and then I'll talk about how you would do it then on Linux or Windows? Okay, so it's a bit different. Okay. So the first thing I had to point out is that the sound that I found bounce dot WAV, and WAV files generally are more compatible cross platform compatibility isn't the exact same folder as my Python file. So right now, I'm on Pong, seven, and Pong sevens in there. So they are in the same folder. That's a really important point. Now that you can you work around that if you know what you're doing. But for beginners, this is probably the easiest way to do things. And so basically, it's really simple. When do I want to play a sound. And so I'm going to play a sound when I having to put when I when the ball either touches one of the borders, or bounces off of the paddle. Okay, so in Mac, okay, so I'm going to use something called the O S. Module. And what that lets us do is basically interact with the operating system through text commands. And so I've imported o s, so I can use that module. And then down here, so what I can do is I can say, oh s that system, that will do a system function call for us. Now on Mac, it's a play bounce.mp bounce dot w Av. So this is it. This will play the sound when it hits the border. Now there's, there's a problem here and I'm gonna show you that in a second. But again, let's test it. See what happens. Oops, one throw away. The wait till it's the top. I'll turn my volume up. Oops, sorry, my bad. A play is for Linux, a f play is for Mac. Let's try that again. Got that backwards. I had a 5050 chance and I blew it. Okay, let's listen. Now, did you notice that everything stopped while that sound played? So watch it again. Okay, that is not what we want to happen. Okay. So to get around that, at the end of this command, we need to add an ampersand. That's the end symbol. Okay, so let's test it. And watch it will not delay. It says a little bit, it's a little bit off. But that's you know, neither here nor there, I suppose what to do with that. Okay, I think actually, what I would probably have to do is edit this, this WAV sound is probably a little bit of a blank space at the beginning of it. So that's that's it on Mac. Okay, so let me copy that. And let's say we want to play it when it bounces the top, bottom and when it touches the paddles. So we need to put, do that. Okay, so let's test it. So again, I got it working once now I just copy and paste. So it should bounce here. I'm terrible at Pong, apparently. Okay, now you can choose different sounds, you have one sound for when it bounces off the walls, one sound for when it bounces off the paddle, et cetera, et cetera. Okay? Now, if you are a Linux user, the the system is very, very similar. Instead of AF play, it's a play. That's all you have to change. Okay, and for Windows is a little bit different. Now, I can't test it for you, but I can explain how it works. And I do have a video that explains this. And I'll try to remember to link that down below. And basically, in Windows, instead of importing o s, you import wind sound, which is a little module that only exists on Windows. And then when you want to play your sound, instead of this oh s dot system stuff, you would type win sound. dot play sound. Again, pay attention to the capitalization, okay? Small W, capital P, capital S, then in parentheses. So don't need the ampersand here. But you do need a comma, and then when sound not SMD async. So what that does is that same thing as adding the ampersand. that'll stop you if it's asynchronous, it will play the sound in the background. If it's not a synchronous program, we'll stop. Again, I can't show it to you because this is Mac but that should should do it. So I'm gonna undo that and get back to my system. Oops, somebody wanted to Oh yeah. Keep going, Yeah, a play and it's AF play, let's leave that. I'm gonna test it one more time. And that is our Pong program. Not the most exciting thing in the world. But you know, you learn a lot of different concepts, you know how to put objects on the screen, how to move them with a keyboard, how to detect collisions, update the score on the screen, gaming loops, sounds. So basically all the basic elements that you need to make a game are included in Pong. That's why it's one of the classics. And I remember playing this as a child, it brings back some memories. So let's just go ahead and get a look at what this final product is going to look like. So on like an x by x grid, so whatever you want it to be, you have little snake moving around, there's a snack is what I want to call it that shows up and as you collect it, it increases the length of the tail. And then obviously, if you run into yourself, and I just did that by clicking the back us going forward, it gives you a little error message here says, You ran into your tail, your length was nine dot, whatever. And then you can continue and play as long as you want. Anyways, what I'm gonna be doing in here is I'm going to be coding everything object oriented, I know that there's a much faster and easier way to do this doesn't really teach you that much. This way, you're gonna learn a bit about objects, but classes, how we can kind of work with them. And you'll see like how the flow of my program goes, and you should learn quite a bit, especially if you're someone a beginner programmer, what we're going to be using to make this is module called pi game, if you don't know about pi game, and you want to learn about it, before you do this, I would recommend that. Alright, so let's start coding. So pretty much what I've done is I've just set up the flow of the program, all the classes and the function just to remind myself what I need to write. And while I'm talking here, it's probably good ideas, if you guys copy this down, so we're gonna have, you're gonna have two main objects, we're gonna have a cube object and a snake object, and our snake object is going to contain cube objects, if that makes sense. So each one of those little red squares it was moving around is a cube object, and the whole thing is our snake object. We're gonna have a few functions here, draw grid, redraw window, random snack, messagebox, and main. So let's get started with our main function here. And this is what's going to be our main loop. So essentially, what I need for the main loop to start is we need to make a surface so in pygame, to do this, we do when equals pi game, dot display, dot set underscore mode, and then I'm going to set it. Let's see here, what do I want the height to be? I say, width, and height like this. Oops, that's fine. And I'm just gonna make a variable here called width equals, height equals, and we'll just set this to 500 by 500, like so. Now we need another variable, I'm going to set this as rows can delete this down here, it's gonna do something, we'll do that later. And this is how many rows you're gonna have what rows or columns, whatever, you can set this to whatever you want, just make sure it divides 500 evenly, otherwise, you're gonna have like weird looking rows, if you know what I mean. So I'm just gonna set mine to 20. That's what I'm using the other one. But if you want to make it harder, set it to something like 10, and there won't be as much room for the snake to move around, and the games will go faster, pretty well. Okay, next, what we need to do is we need to set up a snake object. So I know that we haven't even created like anything in the snake class yet, but I'm gonna do s equals snake. And I'm just gonna give it a position. So in this case, we want to use a color Sorry, just gonna be red, because red, green, blue, 255 for red, and then I'm gonna give the position we're gonna start in the middle. So I'm going to start at 1010. Now let's move into our main loop. So I'm just gonna say, well, flag, create my variable here, flag equals true. And then we're just gonna start by doing a pygame tic, so pi game dot time dot delay. 50, like so. And that's just gonna delay us, I want to say, like point five or 50 milliseconds, every time so that our program doesn't run too fast. I'm also going to create this clock, tick on to put that at 10. And what I'm gonna do is I'm gonna create a clock object up here. And this is a built in thing in PI game. And what this is going to do is I'll explain in just one second once I finish typing it pi game, clock, I believe it is, oops, time clock, like so. So what this clock tick is actually going to do is it's going to make sure that our game doesn't run more than 10 frames per second. So that would mean essentially that our snake would be able to move like 10 blocks in one second. And again, we don't want it to be that fast. So that's why we're also delaying by like a few milliseconds here. If you put this too low. Then again, it's going to move to Oh, you can play Round with the speed, this is kind of what I found was the best speed. And it may vary depending on what machine you're on, it shouldn't, it might. So you might want to just change these numbers. Again, the lower this goes is, the faster it's going to be. And the lower this one goes is, the slower it's going to be. So they're kind of inversely proportional like that. Alright, next, what are we going to do here, I'm just going to call redraw window. And I butchered that so bad, oops, redraw window like so I'm just going to give it a surface, which is in this case going to be when that we've created up here. And for now, that's all I'm going to put in my main loop here. And we'll move more into that once I start coding some other stuff. Okay, so now that we have our redraw window being called here, I'm going to go and I'm going to start coding our redraw window. So what this is essentially going to do is we first need to update the display. So pygame display dot update, like so. And we also need to draw the grid. So we're going to do draw grid, we're going to pass it out same surface that we were given, and move on from that, we're also going to fill the screen. So when Phil, in this case, I'm just gonna use block 6000. And there we are, that's all we need to do right now. But essentially, we're also going to need to draw the snake, we're gonna need to draw a few other things on the screen. That will we'll get to later. Okay, so draw grid, let's move into this one. Now, what we need to do here is draw a grid, which is pretty easy to do. So what we do is we were given rows and surface. So it's probably a good idea, if I actually passed in the rows and the surface. So I'm just going to global them here so that I can reference them, I think this is going to work well the global rows and width, like that. And here, we also need to make these global just because I don't want to pass them. And every time I draw a grid, we're just gonna say width. And rows, and this height variable is actually not necessary, because we are just gonna draw a square, like a square surface every time. So we can just make this the same, we don't need two variables for width and height width are going to contain the same number anyway, so global width and rows, I go here, draw a grid, given with rows and surface. So now we're gonna put in, well, first we're gonna put our rows are oops, width, row, and surface like that. Okay, so that should be working. Now, in here, what we first need to do when we're drawing a grid, is we want to figure out how big each square in the grid is going to be. Because what we're going to do is we're going to just draw lines going down and across, but we need to figure out where to draw those lines. So we have to figure out kind of like the gap between each of the lines. So the way we do that, I'm just gonna create a variable here size between is equal to our width, integer divided by our rows. This is just so that we don't get like large decimal numbers, because that we cannot pass into our draw line method in, in Python. Okay, so now I'm just gonna create X variable, and Y variable. And I'm going to set these to zero, let's say for L, in range. And this just standing for line pretty well, in rows, like that. Now, what I'm gonna do is I'm gonna increment my x by the size between, I'm going to increment my y by the same, so y equals y plus size between can get rid of one of the spaces here. Okay, there we go. And now we're simply just going to draw two lines. So to draw a line in pygame, all we have to do is pygame dot draw dot line. And the argument that takes is a surface, we need a color in this case is going to be white. So you 250 by 255 255 foot white, we're going to draw x zero comma x w, and I'll go through this in just one second. What this does, and I'm just gonna copy this and draw one more and then explain how this is going to work pretty well. Okay, so now we need zero, y, and w, y. Okay? So what this is going to do is this is going to draw two lines for us every loop of this for loop. And these arguments here is the start position of the line and the end position of the line. So the first line that we want to draw is going horizontal, which means we don't want to change the y value at all. So what we need to do is we need to find the x and then we're going to put y at zero, because we're going to be at the top. I think that's right at least Oh sorry, this this line is being drawn down not being drawn to the right, I was getting confused. Okay, so we're going to change the x, but we're going to keep the Y at zero. And then we're going to stay at that same x and we're going to keep the Y at the width of the screen so that we're going far enough down then same thing here, this one is going horizontal, excuse me, I messed that up before. So our x is always going to stay at zero. And our y is going to be what's changing as we draw a horizontal line across the screen. I hope that makes sense to everyone how that works. Anyways, I'm going to move on from that. And that's all we need for the drug grid function. So just go ahead, I probably made a mistake here, but we'll run the program to see if everything's working. Good now named when is not the find window fill. So I've called this when one really needs to be surface like that. So let's try now. And there we go, we get a nice little grid on our screen like so 20 by 20. grid. There we are. So now, let's move into another function, or actually, let's start coding on the classes here. So like I was talking about before, we're gonna have a snake object, which is going to contain a bunch of cube objects. So essentially, what we're gonna do is we're gonna have a list of cubes. And that's going to be known as the snake body. So let's go ahead and write that in. Now, what I want to do for that is just create a list. So we're just gonna say body is equal to and then a blank list. I'm also just while we're already up here, in creating a class variable, I'm going to create turns, is equal to, and it's just gonna be the set of squiggly brackets here that we'll we'll get into in a bit. Okay, so now that we're already in the snake function, what we need to do is we just need to define our parameters here that were passed. So we're just gonna say self dot color, equals color, self dot equals cube, which I'll get into in a second, given the position, say self dot, body, dot, append our head, self dot head, like this. So what we're doing here now is we're saying Okay, so the head of our snake, which is going to be important, because we need to know where that is at all time. So we can move accordingly, is equal to a cube at the given position. And the given position is what we pass in here, as like the starting position of our snake. Or we create a new snake, like we'd have multiple snakes moving around. And anyways, that's the position. Now we're saying we're going to append to the body, this head. So now this is in our list here. And then we can go through that list. And we can draw things, we can move it, we can check things, we want all of our cubes to be ordered within this list. So that's why I'm putting that in first. Now, I'm just going to give this one which is called turn x is equal to zero, and turn y, which is equal to one. So what this is going to do is we have a direction for x and a direction for y for moving our snakes, obviously, these are going to be a value like negative one, one, or zero, and that's going to be the same for y and x. If y or x is equal to one, negative one, then the other one is going to be equal to zero because you can only be moving in one direction at the same time. And this is just going to keep track of what direction we're moving in. And we'll use this in the next function that we're going to code, which is our move function. So moving is pretty straightforward, at least in terms of just if you have one object moving around the screen, getting it to go left straight, right, but when you have the snake object, it has to turn at certain points. So when I click left, the rest of the snake is still moving forward, once it reaches the point where the head turned left, then it has to turn left. So that's where things can get a bit complicated. Anyways, to start, what I'm going to do is say for event in PI game, by the end of my typing here, pi game, dot event dot gets like so. And that we're just gonna say if events dot type equals equals pi game, dot quit this, and this is the first one we always want to code in. Because we want to make sure that if they click that little red arrow, it actually works. And we can quit going to pi game dot quit like that. And I'm just gonna say if, actually, we don't even need another F, because the way I'm going to do this is this other way you might have seen in PI game before to move things around use, like if event dot type equals key down, and then you just check which key was pressed and move to the left. This is a similar thing, but it works smoother. I've used both of them a lot. And this is what I prefer. So I'm just going to use this. So pygame dot key dot get underscore press. So this is going to do is it's going to get a list. Actually, I think it's like a dictionary or something like that, that has all the key values. And then if they were pressed or not. So that way, if you press more than one key at once, when you're looping through, it'll adjust to that. Whereas the other one, you can only click one at a time and you couldn't move like per se diagonally if you're moving like a character at the screen. Doesn't matter too much for this, but this is the way I like to do it. So now I'm gonna say four key in keys. Because remember, this is going to give us all of the keys and then like one or zero value if they were clicked or not. So we need to loop through all of them and check if keys and then pygame dot key or uhq stuff dot k underscore left. Thought it was key there. And then we say keys by game dot k underscore rights Like that, and we can continue down here with up and down. And then we'll get into exactly what is going to happen when we click these keys. So last one here. Alright, and there we go. Okay. So now what we're going to do is we're going to change the direction according to what key we click. So for going left, that means that our x has to be negative because the way again coordinates work in pygame is in the top left hand corner of your screen is 00. So if we want to be moving left, we should be making our x negative to move more towards zero, right? If we want to move right, though, you make our x positive, which would be one in this case, because we're just gonna move one cube at a time to go further to the right. Same thing with the Y, it's kind of weird in pygame, how the Y works, because the more y you add, the further down you go. So what do we say for x, we're gonna say self love journey, x equals negative one, again, because we left and we're gonna set our journ y equal to zero. And this is because again, we don't want to be moving in two directions at once and be going diagonal. Now, this is what I was talking about, it's we need to remember where we actually turned. Because if you just have one cube in the ground, that's fine. But when you have multiple cubes, we need to be to turn left, right, we need to remember where we turned, so at the tail of our cube can turn at that point. So that's why we have that self dot turns list up, you're just as turns, I want to say, dictionary or set, whatever. So we're gonna add to that, itself that turns, and we're gonna give it a new key. I'll go through how this works in a second self dot pause here, is equal to, and then we're gonna give just a list of self dot exe, and self dot dir and why. Okay, so you might be kind of confused on what's going on here. So I've created a new dictionary up here, that's what I'm going to call it officially, you could think of it as a set as well. And pretty much, we're going to add a key, which is the current position of the head of our snake. And then it's going to be set equal to what direction we turned. So we're saying we have a new turn at this position, and our character where our snake moved left, so it's gonna say we have self doctrine y, which is right here is negative one self.or surf, don't turn x or then turn y is equal to zero, so we know what way we actually turned. And I hope that makes sense. That's, that's how we're gonna do that. Now, I'm just gonna copy and paste these and then change these values. So when we're going right, this is going to be one. Oops, same thing here. So put that in, this is going to be zero, and turn y we're going off is going to be negative one. Now when we're going down, we need to change this to one and this to zero, and I'm just gonna get rid of that. And there we go. Okay, so that is pretty much how we go about doing this. And I can also just put LS here as well, because we don't want to be able to move in more than one direction. So we're going to prioritize the left arrow key. If they're not clicking the left arrow key, then we'll check they're doing the right otherwise up otherwise down, because we don't want them to be able to click More than one key at once. Okay, so next, we need to actually move our cube. And this is where it gets a little bit more tricky in terms of looking where our cube is. And if it's at that turn, then we're going to turn it. So I'm just gonna start coding and I'm kind of going to go through exactly what I do. So before I see in a numerate, oops. And I spelt that wrong. Like that, and the version, say self dot body, because we're going to look through the list of positions that we have in on stake and then say, P equals seat up position. And I'm just going to copy this. By the way, that's what this little arrow does here, it just makes a copy so that we're not changing the position of our snake. When we do things, it's just just follow along with it's not super important. Okay, so we're gonna say if p is in self dot turns, like this, because remember, what we did is we added the position of our head, two turns. So now we're going to say, Well, if this position is in the turns, then we're going to move or we're going to turn right, so let's say here, when say, turn, oops, equals self dot turns. Like that. So now we've seen that it's in there. So now it's in there, we can find the index of it and we can grab the direction value so we know what way we're gonna be moving. And average can say C dot move, like this, and turn zero, turn, one, like so. Okay, now Next, I'm going to say if i equals equals the length of self dot body, minus one Oops, then I'm gonna do self run away, that's capital stuff, but turned dot pop. Okay, so I know I just did a lot of coding here. And this probably doesn't make a lot of sense to you guys. So I'm going to kind of run through exactly what I just did. It's, it's pretty, it's a little bit difficult to explain. So anyways, what we start off by doing is we're gonna say, we're gonna get the index, and we're going to get the cube object in our self dot body, because remember, our self dot body is made up of cube objects right here, that have these properties, right, they're gonna have a direction y direction, x, a start color, so on, and we're gonna get, we're gonna get to coding cube in just a second. So there are cube objects. Now all of these cube objects have a position. So I'm saying for each object here, I'm going to grab their position. And I'm going to see if that position is in our turn list. And we create the term list and add to the turn list. When we turn right, when we click left, center, right, so on, and then we're gonna say, Okay, so the actual turn, so where we're actually going to be moving is equal to that all the turns list at that index, right, so we grab the turn direction, x and direction y, which we stored there. And now we're gonna just gonna say, our cube dot move, which is another method that we're going to code, and we're giving it that direction, x and that direction y, so it knows what weight it needs to move pretty well. And then I say, if i is equal to the length of self dot body minus one, so that means if we are on the last cube, we're going to remove that turn. So once that last cube hits that turn, we're going to remove it, because if we were just to leave that turn in the list, that would mean any time you hit that position on the screen, regardless of if the snake was turning there or not, you'd automatically change directions, if you don't remove it from the list. hope that makes sense. Okay. Now, also after this, if you were gonna say if the, what do you call it if it's not in the list. So if our position is not in the list, we still need to move the snake, because it's constantly moving. So what do we do to this? Well, we write an else. And I'm just gonna copy this in, because it's going to take a second to type because I have another file open. And I'll go through what happened, how this works, okay? No, it looks like a lot. But pretty much. What this is doing for us is we're checking whether or not we've reached the edge of the screen for saying, if we're moving left, and the position, so the exposition of our cube is less than or equal to zero, then we're going to change that position so that it goes to the right side of the screen. So the way that we can do that is by saying c dot rows minus one, because again, if you start counting at zero, and computers, so if our rows is like 20, then the last cube would be 19 in a list, right? They see that rows minus one, and we're gonna be at the same y value. So we'll leave that there. Okay, and then we say, otherwise, we're gonna check if we're going right for moving right. And same thing, if we're at the edge of the screen, move back to the left side by putting zero here. And the next one, if we're going down, what we're going to be doing is, again, checking, are we less than rows minus one or greater than rows minus one? No, we're not. Or if we are, then let's move us back up to the top of the screen by changing our y value. And then same thing here, if you're moving upwards. Now, if none of that's true, so we're not at the edge of the screen, we're not moving up left down to whatever I just said, then we're just simply going to move our cube at the direction x and the direction y of that cube already. So if that cube is moving upwards, and it's not turning, and it's not going to the edge of the screen, it doesn't need to be changed. Just keep moving it in whatever direction it's going. And that's why I'm simply referencing the cubes already existing direction, x and direction, why we're not changing anything, we're simply just saying, Okay, let's move you forward one, like that. I hope that makes sense. That was a lot and that's probably one of the hardest things in this program is figuring out the movement of the steak. So if you guys understand that, then that is the hard part kind of over with and we're gonna get into this cube objects, you're gonna understand what all this means and how our rows and columns kind of work and stuff. Okay, so I'm just gonna forget about resetting od q for now because we'll worry about those later. But let's get into the draw method because want to see if there's actually working and put this on the screen. So simply for I see a numerate plug in outselling numerate today, like that. Same thing, self dot body, like that. We're gonna say if i equals equals zero, c dot draw, and you'll see why it is in a second. True. Else c dot draw surface. So the reason I'm doing this little check here, rather than just drawing every object is because when we draw the first snake object onto if you remember my other program, it had eyes. So what I would simply want to do is make sure That when we draw that first object, we add eyes onto it just so we know where the head of the snake is. We don't get confused, like what directions are having. And although you shouldn't we, I want to add a little is maybe just for aesthetic as well. So what this true does optional parameter simply says draw eyes if it's the first one in our list like that, if it's the head, and then in this draw method, you can see I have is equals to false. But when you make it equal to true, we're going to do a special thing in here that's going to draw eyes for us. Okay, so now that we've coded this, this whole mess of stuff in the snake class, let's just run the program quickly and see if anything's happening. So currently, we just have the grid, we don't have any errors or anything. That's because we haven't drawn the snake object onto the screen yet. So what we need to do is we just need to do simply do s dot draw it within our redraw window here. So I'm just going to type I'm going to global s here on global it down there as well. Because say s dot draw, like that. And we need to give a surface. So let's give it a surface, and I'm going to global s so that we can reference it there. And is there a reason why we aren't being drawn to the screen? Let's just have a look quickly. Start draw. Start draw Oh, it's because yes, we are indeed trying Yes, but we haven't drawn any of the cube objects yet. And it is calling the draw method on all of our cube objects, which we haven't yet created. Hopefully, that makes sense. But we'll go ahead and do that now. So we have to code a little bit more before we can see everything. So let's just go ahead and get into the cube object. And let's just say self dot start, people start, except I'm actually just gonna change this to position because I believe this is what it's supposed to be. And we're gonna say self, during x equals one, self dot y is equal to zero, and self color, is equal to color. And the reason we have this is because we're going to be drawing later what I want to call it a snack for the, for the cube to collect for the snake to collect on. So we want to change the color with that. And I've spelled it wrong, like three times during extender and why the reason I have done x your set to one initially, is because I want to make sure that we start moving in a direction. If I had this at zero, you'd have to click a key before the snake starts moving, but I want right when we run the program for the snake to just start moving, so I'm setting it already with a direction x. And the reason these are optional, again, is so that when we create a new cue object, we don't have to implicitly say direction x is one direction y zero, because it's assumed that it's always going to be like that, unless otherwise stated. Okay, let's have a look. What else do we need to do here, we need to now code this new function, which actually really easy I'm gonna do is we're gonna say, since we're changing the direction x in the direction y in our snake class, we need to do that in here so that it stays with the object, let's say during x equals x. And then same thing, so thought, during y equals getting y, like that. And then we'll go down here, and all we're going to do is going to change our position. So self dot position, is equal to self dot pose zero, which is our already existing position plus self dot, drag x. And they're saying self dot, part one, which is our already existing y value, plus equals self dot journey one like that. And just in case, I haven't mentioned it here, right, we're working with a grid system of 20 rows in this instance. So when I say something like, if our self deposition is like one, three, or 1010, I'm saying we're in the 10th row and the 10th call, I'm not saying the x value is equal to 10. And the y value is equal to 10. Because it's not in the case of drawing on the screen, because our screen is actually a width of 500 pixels. But just where we are in the grid, which is most important to us right now, is equal to like that values like 1435. So on that just just to make that clear for anyone who might have been confused. Okay, so now for drawing. So a little bit harder, just because of what I mentioned as well, is the fact that we need to figure out the distance between each x value and each y value. So when we're drawing something in pygame, it draws in the top left hand corner of the object. So if we draw a cube, we're drawing that in the top left. So we need to figure out what that x and y value is going to be for each cube when we're drawing to the screen. So I'm just gonna call this gap here that is gonna be our distance. And then we have same thing self dot w, y self dot rows. And we're gonna change W and rows down in our program later, but we can actually just type it in now. Like this 502 100 just so we have that set. Okay, so self dot w, answer divided by self dot rows. Again, that's the same thing we did when we were drawing the grid to figure out the distance between our x and y values. Okay, we're gonna say i is equal to self dot pause. Yeah, I was gonna say is a bit of typing in our function here, or in our method, just say j dot self dot paws one. So we're just saying I, which stands for row j stands for column, like a classically convention for it, so that we don't have to keep typing pause zero plus one when we move. Okay, so the next one, next thing we need to do is no draw rectangle, you're gonna say pygame dot draw dot rect, like this. And then we need a surface, we need to cover so self color, and then we need a rect. And here is a little bit of math. I'm just gonna type it and I'll go through exactly what what it goes j multiplied by this plus one, dispose to this question. Okay, so the reason I have these little plus ones, and these minus twos here is just so you can still see the grid when we draw the rectangle. Because if we were to draw with exactly the dimensions of this distance, then what would end up happening is we'd cover the white lines of the grid, and it just looks kind of weird if you can't see the white lines. So that's why I have plus one, added here and minus two just so we're drawn inside of the circle, or inside of the square a little bit. And you'll see that in a second. So what I'm simply doing is I'm multiplying my I value, which is going to be my current like row column by the distance that we need to get to the next one. And then same thing for J. And then this will add ones minus twos, it's just to make sure that we stay inside. So a quick quick example, if you don't understand is say we're in a position 00. so r is zero and r j zero. We're going to say, I multiplied by distance, let's say distances, like 40. Okay, so zero multiplied by 40 00, multiplied by 40, zero, so our position is 00. And that's correct. Because if we're drawing in the top left hand corner here, and we're in position 00, then that's where we should draw again, if you go something like zero 10, and you are you move down, I guess so 10, you moving wide down, you're gonna say zero miles distance zero, and you're gonna say 10, multiplied by distance, let's say it's 40, then we move to that correct position down the screen. So this is rectangle x, y, width, height. Okay, make sense. Now, the next thing we need to do is when to draw the eyes. Now you can skip this part, if you want, I'm just going to copy it in because it's a little bit of math to make it them like perfectly aligned on the square. But yeah, so we say, if eyes are saying our center is equal to distance modulates two, because that's going to be the center, obviously, or much. So we're saying divided by two is gonna be the middle of our cube. And we're saying the radius, that's how big the eye radius is going to be. And then we go through a little bit of math here. So circle middle is going to be high multiplied by distance plus center minus radius. And then we're finding out the x. And this is just like a random x that I'm setting by just putting it eight pixels up, like every time because I don't want to calculate the X. I don't feel like doing that. And then I'm drawing two circles, based on circle, middle one, circle, middle two, and then the radius and a color of black, or color of white, actually, sir, or no, that's black. I'm confused. Alright. Anyways, with all that being said and done, and you guys probably pretty confused, right? Now, let's just run and see if anything's actually happening. And you can see we have a cube in the middle of the screen. Yeah, so that's all we've done with all this coding. so far is drawn a cube. So actually, not quite, because we still, all we have to do now simply to start having that queue move and seeing our key presses work is just do a little bit in the main loop. So let's move down to the main loop now, and have a look here what we need to do. Okay, so what I'm going to do is I'm simply just going to call a stop move, which is our snake object every time this main loop runs. And what this will allow us to do is I want to call this before I read your window is it's going to go up to that method and snake, it's going to check every time that we run the loop, if a key has been pressed, if it has, we're going to move accordingly. And remember that in this move loop here, it moves all of the objects for us. So it moves all those cube objects. And then we're just drawing the grid redrawing everything in this redraw function, so it'll just display that and update that to the screen. So let's see here. And we get an error tuple object is not callable. self dot pose. 0% that there next. Alright, one second guys. Oh, it's because I used curl. Okay, so apparently, I'm an idiot. And I forgot to add an equal sign here. So the issue was simply that this looked something like this, that I changed it to square brackets, when all I needed to do was put an equal sign like this. And now we should be up and running. So to reiterate, the line here is that the issue is, you guys probably saw this when I coded it, to be honest, is in move in cube, it's near the top of the program, all you have to do is change this add an equal sign between this like the bracket and the pause. So now that we run it, we can see that we have a moving object, and that we can move up, down, left, right, etc. so on and so forth, like that. Okay. So play around with that for a second. And now we'll get into adding cubes. And we're actually almost done, we just need to add that add cube function messagebox little bit in the main loop, and that will be finished. Okay, so what we need to do now is, that's all great, we're moving around, but we need to add stuff to our cube, right? Like we need to progress the game. So to do this, we are going to generate what I want to call a random snack that we're going to place on the screen that our snake can eat. So the way that we do this, I'm just gonna say, positions equals item, dot body. And this item, oops, shouldn't be items should be item is just going to be a snake object. I don't know why I'm calling an item, but that's what I'm calling it. And we're simply just going to set like a new list equal to that list. So okay, so now we're gonna say, well, tree, capital T, we're gonna do x equals random dot random range. If you haven't imported random yet, make sure you do that. And y equals random dot Rand range. rows. And rows, again, should be global. So let's make sure that this works global rows. And after this, we're gonna say if I don't know how I just typed that, but the length of and I'm doing something fancy here, and I'll explain what this does in a second. Okay, so I know I just typed this stuff that probably makes absolutely no sense, you guys, if you haven't been using Python for a little bit, but pretty much what this is going to do is we're going to get a list of a filtered list. And we're going to see if any of the positions are the same as like the current position of the snake pretty well. So what we're doing is we're saying that, we want to make sure that we're not going to put a snack on top of the snake. Because if we have a really long snake, the chance of that happens is actually somewhat high. And I didn't do this when I first coded the game. So what happened is, when you have your snake moving around the screen, all of a sudden the snake could pop up, but it's like on the tail of the snake, which you don't want. So what this is doing, and just type it out, you don't really have to understand it is we're saying this, this means a function, Zed, and we're just checking if this Zed dot position is equal to x, y. So if it's equal to x, y, which is the position we just generated, here, by getting two random numbers, x and y, then we're gonna have to do this again. So we say, continue. And else we break like that, and then I'm just gonna simply gonna return in the tupple, or to go where you want to call it x, y. Okay, so this is confusing. But um, you can do this in like a much longer way with a for loop, where you pretty much loop through every position in this list, you check it against x and y, you see if it's the same, if it's the same, then do this loop again. Otherwise, you break and you return x, y, that's all we're doing in there to generate a random set. And it messagebox you gonna leave that and in here, now, what we're good. Okay, so now that I've created this, this random snack function, what I need to do is I need to use it. So I'm just going to create a new object, and we're going to call this snack. And it's going to be equal to another cube, right, because we want to have the same functionality want to build, draw it, possibly move it around, right, so we're just going to create a new cube object, we're going to give it a position of a random stock, which is going to select this random stack. And the random stack, I believe, oh, it takes a row in an item. So what we're gonna do is we're gonna give it row rows, and we'll just give it our item, which is gonna be s. And then after that, what else do we need for cube, I don't think we actually need anything else, I think that's all we need, oh, I'm gonna change the color. That's what I want to do. But I changed the color equal to green. So red, green, blue, 255 for green. So that shows up and is visible on the screen. And now what I'm going to do down here in this while loop is I'm going to say, snack, I'm going to check if our the head of our snake has hit the stack. And if it has, we're going to add another part to the body of the snake. Otherwise, we're not going to do that right, and then we're going to generate a new snack and so on, we're going to just gonna say if s dot body zero dot pause, and this is going to be the head, right, because we haven't ordered I don't need those brackets is equal to snack dot pause. And remember, these are both cube objects, that's works fine because we're going to be tuples. Then what we're going to do is we're simply going to say s dot add cube, which is a method that we have there that we haven't actually written yet. And we're gonna say snack is now equal to well, a new cube. So I'm just gonna copy this and paste it here. So All we're doing is now generating a new cube for snack, I'm sure I could put something in that, like change it, but this is just the way that works. Okay, so now that we've done that, we should be able to move around the screen and get the snack. But we need to code in the Add snack method here, which I believe I have here or add cube. So the odd cube is pretty straightforward, we just have to figure out where we're adding that snack, or wherever adding that cube, I don't know why I keep calling it snack to the list. So what we're gonna do is we're gonna figure out where the tail is. And we want to add it after that tail. So tail is equal to self dot body, negative one, the last element in that list, we're gonna say dx d y, which again, is going to be a direction extraction, I'm just shorting it, shortening it here, it's gonna be tailed during x, and tail dot during y, like this. Now, again, you could do this in two lines, I'm just doing it like this because it's faster. And now I'm going to copy something in and we're just go through exactly what this does. Okay, so pretty much this looks complicated. But all it's going to be doing is checking what direction that we're currently moving in, like the head of the keyboard or the tail actually, of the cube is moving in. So that we can then make sure that when we add that cube, we know where to add it. So for adding it like to the right of the cube to the left of the cube above it below it, and we can give it the correct direction to be moving. So pretty much what we do here is we just say we're going to append a new cube to our body. And its position if we're moving to the right, which and here we are, because the x equals one is one less than the x position of that tail. So whatever the last cube is one less than that. And that's so that we don't add a cube per se to the right when we're moving to the right. And then we're just going to have overlapping cubes and you're not getting to see them right. Same thing down here, for moving down. That means are not down sorry, for moving left, that means we need to add the cube to the right side. So one plus the tail of the expedition of the tail of the cube or of the snake sorry, so that we can have it in the proper position, right and same thing here with x and y, or with y so that we're moving up or moving down when we add it above. Otherwise, we move we put it below. So I just stumbled through that, because there was a lot of different words are very similar. Anyways, what we need to do now is simply set the direction for that cube so that we added it in, if we just left it like that, you wouldn't be moving any words, we just need to change that to the current direction of that tail. So whatever the tail is moving, that's where this new cube is going to be moving in that direction. So we're going to say self dot body, negative one dot x equals dx. And then same thing down here, except we're just gonna change this to y, then y equals d y, and not again, it's just the where our tail is moving at the current moment. Okay, so now that we've got all that done, it's time to see what syntax error we get. Next name, Rose is parameter and global. One second. So I've actually never even ran into that error, oh, global rows as, okay, so let's just make this our, and let's change this to be one second, we can just get rid of this. And this should work. There we go. So now move around like this, the only issue is our snack is not being generated on the screen. And I don't know why that is exactly happening. Oh, it's because we're not drawing the snack. That's what so now, global snack up here believe that's what I called it. And I'm simply just gonna say snack dot drop, like that. And I gotta give it a surface. So let's give a surface Let's run. And air named snack is not fine, because I didn't global down here. So let's go with that. Okay, so now we have the slack on the screen. And you can see that when we collect it, we have that cube added to the end of our snake. And that pretty much is almost the game done. So all we need to do now is right, that reset method. And then we need to just simply check like when we lose a great another snake can go through each other through itself. And you can see we have a huge error when the snake can cook through itself. So we need to make sure that when we hit ourselves, we like end the game and we need to write that message with this method as well. So to do this, again, I'm just gonna copy in this for loop, and then we'll kind of go through go from there. So let's move in here. Okay, so for x and range, the length of s dot body, we're gonna say s dot body x, which is going to be we're looping through every cube in our snake body. We're checking if the position is in a list of all the positions. After that works. That's how we're checking the collision. If you want to do it. Your Own Way, go ahead. But this is the way that I like to do. Okay, so now what I'm going to do is I just want to print to the console, like their score, just so that I would just say score. Oops. And that will say plus is the length of s dot body. But this is going to have to be converted to a string unless I put a comma like that. So let's just do it like that. And then I'm going to simply display a message box will say, message box, like this message underscore box, we have a subject and we have content. And we'll, we'll do that in just a second because I haven't yet actually coded that. And then we're going to reset our snake by just doing str reset, and this is going to take a position, which is going to be our starting position again, 1010. And then we're going to break out of this for loop. Because if we collided once, we don't really care if we collide it again, and go back, and we continue the game with a snake that has length one. Okay, so our reset on this is pretty straightforward. All I'm doing in this reset, is I'm just gonna get rid of our terms, I'm gonna get rid of our body. And I'm just gonna change like the direction x and the direction y. So maybe it's faster by just copy down, and you guys can just copy this out. So pretty much all I'm doing is I'm setting a new head, which is going to be equal to, again, like whatever position we given because we can move it at a different position if we wanted to. I'm clearing self dot body, which is again, a class variable here. And then I'm adding head, I'm setting turns equal to blank direction x zero direction, y is set to one against that we start moving. And you can see, it's pretty much exactly what I have typed out here, except I'm just resetting the turns list. Okay, so now that we've done that, all we need to do code is messagebox. So this one's pretty easy. Um, you can see up here, just in case you haven't looked yet, I import t kinter, st K, and then from G kintra. Import message box. Now this is how you create a message box in pygame. And this is how you create one that actually shows up on top of the screen. And that doesn't like float kind of below it or doesn't show up right away if you want to see that. So just watch this is extremely useful to use in other programs too, if you if you copy up this function, and then you just drag it into other attributes. topmost column true, what this simply does is we're creating a root oops, which is not root dot t gates route equal to tk.tk, which is going to be a new TK enter window, we're making sure that this window is going to be on top of anything. So if we have like a bunch of different windows open, it just comes up on top, which is what we want. I'm just going to simply make this window now invisible. And I'll explain how this works in a second. And then from this message box, what do you call it method, class, whatever. It's gonna say message box dot show info. And then we're gonna do subject and content. And this just takes it takes a few more parameters as well if you want, but pretty much this just shows info, given whatever subject we type in and whatever content we have. And now I'm going to say try group dot destroy like that. Except groups. And don't ask me what this does, because honestly, I don't know. But it just works. So pretty much it shows his message books. And I'm actually pretty sure the way that this works is it constantly keeps trying to destroy the message box until eventually you click the X button and then it actually can, I think it's like something like that. So anyways, that's how you create a message box. And with that we all we need to do is add a subject and contents on inside you lost. And our message will be play again. Let's run the program for the last time and make sure everything's working. So there we go. I just need to get my snake to a length that is large enough to the point where I can actually hit myself. Okay, and there we go. So pretty much we ran into an error. What is the error I spelt attributes wrong? That is lovely error to run into. Let's run back up here. Attributes attributes attributes. Where'd I even make this function? I must have scrolled path it there we go. And I believe that's correct. Let's try this go so I'm actually just gonna go see if I can There we go. Okay, so we get a message says you lost plugin and the reason I died there by the way is because while I was moving right, I moved left So technically, the head of my snake actually ran into another part of it so it says you last play again. And you can make that say exactly what you want and then we can see that our guy just continues to move so on. So anyways, if you guys want to see more content like this, go check out my channel it is named tech with Tim and I'd have a bunch of videos teaching stuff like pygame and doing a bunch of Python tutorials you guys will definitely learn a lot falling through some my videos and I would be very grateful if you guys went over there and like some My videos and subscribe. What's up guys, in this set of videos I'm going to show you how to program Connect for in Python. By the end of these videos, we'll build something that looks like this. It's a simple two player Connect for game with graphics, I think this is a really good exercise for your beginner to intermediate level Python programmers who want to build their skills. I'll just finish up a game real quick, just so you can see how this fully works. As you can see out of the diagonal, and it says player one wind school. Alright, so more specifically, In this first video, we're going to do something a little bit simpler, and then build up to that graphic based Connect for game. So by the end of this specific video, you'll have something that looks like this. It's a command line Connect for game where you actually manually type in numbers to drop your pieces, you see the one there, two, etc. Alright, so let's start building that. Just quickly, I want to mention that I'll be programming in Python three. And then using Sublime Text two as my editor, I posted a link to a video on how to set up these things in the description. So one of the first questions I asked myself when I was writing this game is what is the best way to represent the board. So if I drag in a Connect for board real quick, you can see that it is six rows by seven columns. And to me, this looks like the perfect structure to represent as a matrix in Python. So that's what we'll do. So we'll define a function called create board. And that's going to accept any inputs. And then we're going to make a, a matrix of all zeros with the dimension six by seven. And to help us do this, we're going to import a package called NumPy. And if you haven't already installed this, you can open up a terminal window and just type in pip install NumPy. And as you can see, I already have it. So we're going to use this as follows we're gonna say board equals NumPy dot zeros. And that's gonna make a matrix of all zeros, which is good for initial state and then the dimension six rows by seven columns. Cool. And then we just need to return that board. And we can test to make sure that worked by doing the following create board, and then print board. And as you can see, if I run Oh, no what happened. As you can see, if I run that, we, we do in fact have this six by seven matrix of all zeros. So that looks good, we're going to begin writing the main game loop now. So we're going to write a loop that says while not game over. And so our loop is going to be running as long as this game over variable is false. And the only way it becomes true is if someone has a foreign row. So we need to initialize the game over to be false to begin with, equals false. And the only way that's going to switch to true is if someone got a four in a row. So now we're going to need to we're also going to want to real quick make our board initialize before we start the game, just so we have something to put pieces into. So we have our board, we have our game over variable. And now we're going to want to be able to ask for player one input. And then we're also going to want to eventually be able to ask ask for player two input. So this kind of leads us to the problem of Oh, how do we differentiate between whether it's player one or player two's turn, so we're always going to define another variable here called turn, that's just going to initialize to zero. So what we're going to say is, if turn equals equals zero, then we're going to want to ask for player one input. Alright, so in Python, there's a function a built in function called input. As you can see, it highlights blue for me. So we're gonna say, selection equals input. And then we're gonna say, player one, make your selection. So this is what the player was going to say. And then the way we're going to initialize this game is we're going to just say they can type in between zero and six. So this is what the player one should see. So if I build this, you see we run into this error. So this is because Sublime Text doesn't accept this input function. So my workaround for this was I installed a package in sublime called sublime RPL. I'll put a link in the description of how to install this. And I can run the input function through that. So now you can see player one, make your selection three, and doesn't do anything with that input right now, but you can see that it's asking me that and I can type in enter. Alright, cool. So we also just want to make sure that it saves our selection properly. So we're going to print selection. And I also just want to see, you know, if I type in a number, does it actually give me the number? Or does it give me a string that represents the number. So I'm going to also printing type of selection, I just want to see what we're getting. So I'm going to run that again. And as you can see ever again, but we're going to go to splice mrpl. And the link is in the description, as I just said, run current file. So to and as you can see, it gets to, but it says it's a string, so we're gonna want to make sure that it's actually a integer. So we can just surround this with an input. And this should work. So let's see, run that again. And you can also run this through the command line. So if you run this in your terminal, go to the directory that the file is in and type in Python, and then file name, it will also run it just as I'm running it in this sublime RPL. Player One, make your selection three, cool analysis says three, and it says the class of that is an int. So that looks good to me. So now you can save some sort of selection from the user. And you can also edit this so that it requires you to make a specific number type in a specific number, but we'll just leave it as like, we'll imagine our players are following the directions right now. Alright, cool, we have that. And then we're always going to want to be able to ask for player two's input. So that's going to happen else otherwise have The turn is not equal to zero. Then we want to ask our player to input so selection equals, and we'll just copy this from above. And we'll just have to change this to say player to make your selection. All right. Cool. And now at the end of the turn, no matter whose turn it is, we're gonna want to increase our turn by one, so turn plus or plus equals one. So I'll make it incremented by one. And then we'll also what we're going to also want to do is we're gonna just make this odd even. So we're going to use mod division, so it's going to be turn mod to turn equals turn mod two. And this is just basically making it go take the remainder of whatever our turn is divided by two. So this is just gonna alternate between zero and one. So it will alternate between player ones turn and player two's turn. So let's just see if this works properly. So we're gonna run this build Python current file, player will make your selection to player to make your selection for player one, make your selection to Oh, that looks good. It's alternating between our player one or player two. Cool. Okay, and now we're going to want to start building our actual functionality, we're going to want to be able to make this selection right here, actually drop a piece into our board. So I'm going to define another function up here called definition drop piece. And we might define a couple functions. So maybe have dropped piece and I will just do pass for now, maybe we'll also have like, is valid location. So that will check whatever number that the player typed in, we'll check to see if that's a valid location. We'll also define a function called get next open row, and how all these functions are going to work together as as follows. So it all begins with the player making a selection. The zero to six here represents the column that they want to drop their piece in. So maybe a more appropriate title for this would be co l representing column C. Well, next, we're going to take this column and the current board we have and pass it into this is now location functions aboard comm individualize how we can check to see if the column they selected is a valid location, we will print out the board real quick. So as you can see, imagine this is the zero throws the first row, second row all the way up to the fifth row here. And then this is the zeroeth column, first column, second column, etc. We're starting at zero as our first index. So if we wanted to check if the column that the user selected, let's just assume that the user always typed in a valid number zero to six, we wanted to check to see if it's valid, all we need to do is make sure that this top row for that specific column is not been filled. So let's imagine that we're putting ones in for player one going in twos and for player two guys. So if this top row is still zero for the specific column we selected, then we know that it's okay for us to drop a piece in that row, or in that column, it hasn't been filled all the way to the top. So do that. So this is the fifth row. So all I'm going to do is just check to see whether or not the position at the fifth row. And let's say, you know, whatever column we select, is zero. And if it is, that means a column is still free, if it's not, then that's not an allocation, we'll have to have the user try something else. So to do that, let's just do board. So we're going to return board. And then the, the row is five. And the column is whatever the user selected. So here, so and we're going to make sure that's equal equals zero. So if that's true, then we're good to work good to let them drop the piece there. If that's not true, that means a column has been filled up all the way. And one thing I'll note that will probably change in a future video is that it's kind of getting messy my code a little bit with just throwing these random numbers here all the way all over the place in programming, this is a called magic numbers, you kind of don't know where they come from. So I'll clean those up in some of the future videos in the series. So return board five, column equals equals zero. And that is just checking to make sure that that column has an empty slot. Okay, so now that we've gotten the valid location, let's get the next open row in that column. So if we think back to our board, that's just checking to see when we drop it in that say, the zero column here on the left, checking to see which row of these, the piece will fall on. So to do this, we're going to write a quick little loop. So we're going to do four. And we're going to set the past in the board and the column into this one. So the loop we're going to write here is for our end range. And I'm actually going to start getting rid of some of these magic numbers. So I'm going to initialize a global variable called row count. And often Global's are capitalized just to show that are static variables that don't change or capitalized just to show that they're non changing variable. So the number of rows we have is six, and the number of columns we have is seven. So I'm going to do for our so for row in range, so the number of rows we have, so row count. And we're going to check the board position, we're going to see, if board our position, or so the column equals zero, then we want to return that row. So basically, if the row is equal to zero, so imagine we're filling this whole board up with ones and twos. If the slot is still zero, that means it's empty still. So we're going to return the first instance that it's empty. So this R is going to count from zero to row count minus one. And we're going to return that first case where it equals zero. Okay, so now we got the next open row. And then finally, what we're going to want to do is drop the piece. So this is going to take in the board, the row and the column. And then we'll also add something, we'll just call it the piece. So whether it's player one or two going, so all this is going to do is go board, row, column equals equals piece. So we're going to make it fill in the board with whatever piece that the player just dropped. So let's put this all together in our loop. So first, we got the column. And now we're going to check if is valid location of the board in the column. And then we can start getting the next empty row. So row equals get next open row. And that takes in the board and column as well. So get next input in row board column. And then we're gonna finally drop piece. And we're going to take in the board, the row, the column, and then for player one, the pieces just a one. And we're going to copy this in to player two as well because player one and player two, the functionality of what they're doing is the same, but we'll just have to change the piece here to two. So now and then finally, after the player goes, we'll probably want to To print out the board, so we'll print the board here. And let's see what happens now. So, tools build sheet, sorry, supply more IPL Python run card file. So player one selection, we're gonna drop our piece right in the middle. So at 0123 is the third column. So three. What happened? Why did it not fill in? Let's figure out what exactly went wrong there. So should have updated the board, but for some reason it did not. So let's see. Okay, I see what I did wrong here. So I accidentally put in two equal sign here. And what we're really trying to do is an assignment, we're not trying to set C of the board row column position is equal to that. So I didn't assign it. So now it should work. So we'll rerun this. So tools, primary PL, Python, on current file, player one, make your selection will say go to the middle three, player to make your selection, we'll do three as well. Play one, make your selection. And as you can see, one issue we're having right now is that the pieces are starting at the top and going downwards. And so the reason for this is, our convention was to say that this was the 00 index, but in the actual lumpy, they represent this right here as the 00 index. So I'm just going to add an additional function real quick called print board. And all that's going to do is change the orientation. So that what we're seeing is actually the day flipped over the way we're expecting to see a Connect Four board kind of be building from bottom up. So print board, and we just need to pass in the board. And all we're going to do is there's a command in dumpee. So the command is I mean, just remember it, it is NP dot flip. And when to do board, and then you have to flip it over, you have to specify the axis of the zero the axis, we're going to flip the board over the x axis. So that should get it upside the right side up again. So instead of doing print board here, we're going to now call our new print function. So print board, and board. And we can also do that down here if we want to print doesn't matter, I guess to start with print, or whatever. Okay, now let's run it again. Tools, primary PL Python, on current file, player will make your selection 333. And as you can see, now it's building up from with ones and twos. Just how we expect. Okay, that's all I'm going to do for this video. In the next video, I'm going to kind of build in the functionality of actually checking for wins with these ones and twos. And then in the next video, probably after that, we're gonna actually add the graphics, so make sure you stick tuned for those videos. Thanks for watching this one guy's seen a bit. What's up guys, and welcome to the second video in the programming Connect foreign Python series. At the end of last video, we had something that looked like this. It's just a simple command line based Connect for game. And the one problem with this is that if I actually won this game, so as you can see, I just won with player one down the bottom. The game doesn't let me know at all that I won. So we need to implement that functionality. So we're going to define a function called winning move. And we're going to have that taken the board and then the last piece that was dropped. So winning move, there's a bunch of different ways to implement this. And the way we're going to do is not the most efficient method, but it's probably the easiest describe in a video. So that's kind of why I'm selecting it. But we're going to manually check all the different possible places you could win and connect for. So all the horizontals all the verticals and all the diagonals, and check to see if there is a winning combination on the board. And because we're doing this after every turn, we're going to pick up the first instance of that winning combination, so we'll know who won. Probably the more practical way would be to just check around the spaces where the last piece was dropped. But that code got a little bit messier when I was doing it before so I'm going to just do it this way. So we're going to first check all the horizontal locations and To do that, we'll have a loop that iterates over the columns. So for see in color range, column count. And so we defined a column count up here. And that's seven. And one thing, I think would be a cool challenge for you guys to try that I don't think my game is going to be able to do at this point in time is a very well designed like Kinect for game, you'd be able to change these numbers. So like I could change it to say, like 12 or something. And this to like eight in the game would still be able to work, you still have like a Kinect for game, but just a bigger board. So that's a kind of a cool way to make sure like you've designed things in a smart way, where you don't have just these random like magic numbers popping up all over the place, I'm actually going to change this real quick to row count, and column count, just because I'm going to try to eliminate the magic numbers where I can and will clean this up to row count, minus one. So this is the last row, the left index of the last row. Okay, getting back to winning move. So we want to check horizontal locations for the win. So we're going to first loop over all of the columns. And then we're also going to have a loop over all of the rows. And what this loop is going to be over is not every single position but over all the possible starting positions for a horizontal when. So if we think about our board a horizontal when can start this spot, this spot, this button this spot, it can't start here, because you can't go for over from this location. So this is our last column, the third column in terms of indices, and then upwards, we can go all the way to the top vertically, because it can so this half sorry, you can't really see, but we're making a box around that half is where our starting locations can be for this first. This first check, so we're iterating over the columns. So it can only be the number of columns, and then we have to subtract three, because three of those columns couldn't actually work. So we're subtracting three off of that one, and then all the rows could work. So that's totally fine. So now we're going to check all the foreign row locations. So this is gonna look like something like that. So if board row, column, so this is just indexing the matrix equals equals piece and board, row, c plus one. So this is taking the next one to the right, so we're checking horizontally, so we're only changing the columns equals equals piece and board, our C plus two equals equals piece. And then finally, and board, this is the fourth piece in row board, c plus three equals equals piece, then we're going to return true. So we want to return true the first time this happens, we're not going to return this expression, because that would return that would break out of this loop before we wanted it to. Okay, and so what read it right again, this is not the best way probably to write it, you know, we have these magic numbers popping up. But it's just a very simple way to check for all those horizontal locations. Right. So let's do the same thing with vertical locations. locations for when. And actually before I do that, let's just check to see if we can get some functionality on this. So if falsification and we're gonna also write a if statement that says if winning move. And so we're gonna say, Ford and then the pieces one. So if it's winning move, we're gonna just print out. player one wins. Congrats, yay. Okay, let's just see if that works with the horizontal real quick. And then we're also going to want to set this game over variable to true, because the game is in fact over if the move is winning, so let's just run that real quick. Python on current file. Okay, everyone make your selection three. Yay. It says player one wins. And we I guess I accidentally printed the board at one extra time. But you know, we did get that functionality, it did check that horizontal line. So I think that looks good. Obviously, you'd want to test these like very thoroughly. But for the sake of the time of this video, I'm going to just start going to the horizontal, the vertical location. So think about where vertical locations can start. can start, you we need four up so it can start, it's pretty much the opposite of the horizontal. So vertical could start all this bottom section, because we need four up, but it can be in any column, so it's gonna be pretty similar to the last loop, but we're gonna have to change the row. So we'll see in a sec, Shift Tab, we're gonna have to change instead of the column count doing for C and column count minus three, we're gonna have to do row count, minus three, because we can't start at the top row. And then we're gonna have that add these pluses to the rows actually, row plus one, row plus two. And the last one is rho plus three, and then write it once again, like, see if you could figure out how to manipulate this, these equations to work for any length of a board. And also, let's say maybe we want to make a game that was like Connect six, like, it'd be a cool challenge for you guys to try to build these functions so that they could be any number of columns, any number of rows and any number of pieces for the winning length. Okay, so let's check to see if the vertical locations now we're gonna run this again, real quick. So tools, Python, and current file, three. Cool, it works again. So we see have the foreign row with a one right here, and it says player one wins, congrats. So that looks good. Now we have to get to the little bit of the trickier things run out the check for the first we'll check for the positively, slopes, diagonals. And we're also going to make a separate method to check for the negatively sloped. And you'll see why we need to do this in a sec diagonals. Alright, so let's think about it. We're gonna think about it the same way, where are our possible starting locations that we could have a positively sloped diagonal? Well, we can start here and go up, we start here and go up here and go up. So I think the last piece, we can start here and go up. So this is going to be the top row. And we can't go any farther than this piece right here. So that looks like we're doing row count minus three and column count minus three. So right, so we're going to, we'll just copy this code, see, oh, no, what happened? See, and I'll paste that in right here. Alright, so we're going to have to subtract three from column count and from row count, and then how this is going to increment as you start with that initial starting location. And then we need to plus one to both things because it's a slope. It's not just a horizontal or vertical now, so with do the addition step for both of these. Okay, cool. And as we've been doing, let's just check to see if we can get a diagonal when here. So player one, make your selection. I'll just start in the right, we're almost there. So close. Don't screw this up. Now, Keith. Okay, and we'll check here. Cool, the diagonal there worked. So that looks like it's working too. And then finally, we need to do the negatively sloped diagonals. And so if we think about negatively sloped diagonals, they can start at the top and go downwards. But they couldn't start any lower than this right here. This is the last one they could start at, because they have to go down four. So that looks like it would be the top rows and then also the columns minus three. So we're going to Start the rows at three. And we're going to have to start the columns in the normal, normal location. So this is going to start from three to the row count. And so it's three, because if you think about it, z, this is the zeroeth row is the first row, second row, third row. So even though it's actually the fourth up, it's third index. So that's why we're starting at three. And that's going to go all the way to the top, and the column counts actually good as it is. And so this is going to have to now go, it's going to go positively over in the column direction, but it's going to go down a row, so negative one here, native to here, and this is just a negative slope, you you know, you have one direction, positive one direction negative, and this will be negative three. So let's test to see if this works. Come on. or have your Python file. Okay, just build up the left side first. Okay, to okay. Okay, okay. Okay, we're almost into the negative diagonal there. So player one, you can go three, and then player two, to then do cool the native diagnose work now to Okay, so that looks like we have all the possible winning directions, you should more thoroughly test to make sure the all the edge cases work. But to me, that looks pretty good. So we're also going to implement the functionality for player two in this main game loop. Okay, so this is player two, Player Two Wins from grads Game Over true. Okay. And if you wanted to, you could just break out of the loop, if you didn't want to see this board, and the turns changing at the end. Okay, so that's, we've now finished the command line version of the game. So we'll start building out, probably in the next video, we might clean up the code a little bit, and then we'll build out the graphics. Okay, see you in a bit. What's up guys, and welcome to the third video in my programming Connect Four in Python series. In this video, we're actually going to implement the graphics for our game. So at the end of the last video, we had something that looked like this, it was a fully functional command line base Connect for game. So we're going to take this game, and we're going to expand on it to actually make it look nice. So the first thing we're going to do to do that is import a library called pi game. And just like the NumPy library, if you don't have pi game installed, just open up a new terminal window and type in pip install pi game. As you can see, I already have it. Cool. Alright, and now what we're going to do is we're not to start out by initializing pot pi game. So there's you have to do in any pi game project. So before our game loop starts, we're gonna do pi game.net. Okay, and then what we're going to have to do is define our screen size, how big do we want our game to be. So if I real quick, just build the finished version I have, you can see that, you know, it's pretty, you know, you can kind of break this game down into squares, I would say you have squares that represent each column in each row. And then I had this one extra row at the top. So we're gonna define each one of those squares as 100 pixels. So the sizes we're going to talk about right now are all in pixels. So the square size is going to be 100 pixels. And then our width for our screen is going to be the number of columns, so the column count times the square size. Cool. And the height is going to be the row count times the square size. And actually, if you saw my, the game I just dragged in, I'll drag it in over time. I actually added one additional row because I wanted this spot where I could display this circle that I'm dropping. So we'll actually make this row count plus one times square size for the height. And that will be packaged together nicely in a variable called size which will be a tuple of width, comma height. And then to get pygame to actually read that, we need to type in the following screen equals pi game dot display, dot set mode and then We'll have it read in the size. And if you're wondering where I'm kind of just magically getting these functions from, I'm looking at the documentation on the PI game site. So if you go to pi game.org, slash docs, you can find all the kinds of functions that I'm using, I'll post a link to that in the description. I'm going to real quick test to see our screen is actually working. So you can just run Ctrl B. And as you can see, the window popped up, and then it disappeared. We'll handle why it's disappearing in a second. So it looks like though is reading in that screen. Cool. So let's now create a function called Where do a couple things. So I think first we'll define a function called draw board. And this will just be like print board that we defined up here. But now we're actually going to draw it with the PI game graphics. So draw board is going to have to take in the board, and that's about it. And I'll actually pass this for now, because we're going to make some changes to our loop before we do this job board. So the first major change we're going to do to our loop is pygame is an event based game library. So pi game kind of works and allows you to function in the game. By just reading all of your movements of your you know, the keys, you press the mouse buttons, you click the mouse, like how you move your mouse, it reads those all in as individual events. So that looks like something like that. So for event in PI game, dot event dot get. And as I just said, events are like mouse motion, mouse button down, key down, etc. So we're going to read in, we're going to drop a piece by clicking down. So that's one of the important events we'll have to get. So we're going to first do just kind of follow me on this one, event type, event type equals equals pi game dot quit. So this is just something you want to handle in all of your games that you make, just allowing your game to properly exit out, if you click the button here in the top right that x out, x is out of it. So if that happens, we have to do a system exit just so it properly shuts down. And to get this sits right here, we're gonna have to import that into our project goes well that means system. And that comes to fall in any Python installation. Okay, system makes it now to get to the more interesting stuff. The event that we really are going to care about to start is mouse button down. So if event dot type equals equals pi game, dot mouse button down and all the different events, you can also find on the PI game website under the docs. The game is going to run by us clicking down on a specific spot in the screen where we want to drop the piece. So instead of reading in the column, we want to drop it in as we did previously. Now this column is going to be populated by where we click. So I'm going to real quick, put all of this all of this behavior into this mouse button down event type because now the events of us dropping the piece always happen when we click the mouse button down. So we don't want to tap in otherwise we don't want it to be asking for this input. Alright, so column equals, and this is going to be where we click on the screen. So just for now, I'm going to just kind of comment out this stuff, just so it doesn't run on us while we're testing. And let's just real quick, see if this fixed our error of the screen disappearing right when it pops up. What happened? Prince as you can see, now we have this screen and it's not, you know, it's staying here. So that's because we actually added in this event loop here. And knows kind of continue while these events are happening. And the exit out will be handled properly by this this system exit cool. Alright, so we have our screen looking pretty good but doesn't have any graphics obviously. So we're going to implement the draw board function now. So we think about it. I'll drag in the finished one I have again, we're gonna draw some sort of rectangle for each of these slots, and then a black circle inside those rectangles. And then we'll have to draw this afterwards. This piece So we drop and then whenever we do drop a piece, the the one or two that's in our command line based game on to become like a red circle or a yellow circle based on what we're doing. So let's implement this. So first, we're going to iterate through kind of every spot in our board. So for our refer, we'll say see in range, column count. And then we'll do the same thing for our in range row count, just as we did above here, and when we're iterating through all the spots, well, we need to initially just draw it as like an open, you know, a blue blue rectangle, and then in that blue rectangle, we want a black circle. So we're going to do a pygame dot draw function. So first, we're going to draw a blue rectangle. So that looks like kind of our game board, and then the black circle inside of that will be the open slot. So we're going to draw that on the screen. And I'm going to drag in again, the light the library, so I can see exactly what I'm doing. So as you can see here, pygame dot draw rect, we need to take in the surface, the color, the rectangle we want to draw, and then the width. So the screen is the surface, we're gonna draw it on the color is we want a blue color. So I'm going to define blue as a global variable, global static variable up above, this is going to be an RGB value. So we're gonna say it's 00, comma 200. And that means are 255 or so. So that's gonna be a very blue RGB value, because this means red, this means green. And this means blue. And the only color that's actually has some value is the blue here. So the color we're going to say, is blue, we just defined that that's the RGB value. Now we need to find our rectangle. So our rectangle is going to be there, you need to have four different things to define your rectangle, you need to have the size of the width and height, and then also the position. So the position is going to be this might be take a little playing around with to get this, but it's going to be school see time. So these are numbers zero to, you know, the column count and zero to the row count, there's gonna be see Times Square size, because we want the actual is the top left corner of it. And that's going to the and then our position on the y axis is going to be our times the square size. And our height and width, are going to be the other two parameters of this, what they make up a rectangle object, and that's just going to be it's gonna be a square, so it's square size, square size, height and width are the same. And the width argument that I showed was in the documentation, as you can see it defined as zero. So that's optional. And think that's just the outline like the line that surrounds the square, so we don't need to implement that. Alright, let's test to see if just these rectangles draw properly. So down here, we'll just do a draw board, taking the board as we did here, and then what we have to do whenever we want to update our display is do pygame dot display dot update. And I'll make sure that we actually see what we're supposed to see. So we'll build that real quick. Oh, and as you can see, we have this giant mound of blue. And the one problem I see right now is it's not actually opening up the I wanted the top to be open, so we could have a piece that swings around it. So it shows us where we're dropping it. So I think the problem with that is because our axis starts at 00, we actually need to shift down by one square size to kind of account for that offset that we left for that space. So we're gonna have to add a square size here. Now I build this again, as you can see, it looks proper. Now we'll need to fill in some circles to represent the, the slots. So we'll do that by drawing a circle in PI game and that's also in the documentation. So pi game dot draw dot circle, and that's going to take in the surface of a screen, and now we need a color. So I think a good color would be just black. So we'll define black up above two, and black in RGB is just Zero everything 000. Okay, so this is black. And then let's drag in the documentation real quick to see how we're gonna finish off this circle. So Circle Circle Circle, okay position and then radius. So this is going to be the position of the center of the circle, as you see in the documentation, and the radius will probably want to be a little bit smaller than our square size, just so there's, the circles aren't touching. So let's define a radius too. So our radius is going to be fun to find that under the width and height and whatnot. So our radius is going to be a little bit less than the square size. So we'll do I'm going to make this also they have to be integer values, I believe. So once we start getting into division, it might get a little bit messy. So to me n square size divided by two, because it needs to be the radiuses half the diameter and the diameter would be the full square size, and then we'll just minus an arbitrary like, integer value off of that. So now we can draw our circle with that radius, we'll have to do the position first. So the position where is it, I forget, oh, it's in job board, the position is going to be so if this the top left of the rectangle, our position for the center of the circle is going to have to be that then with some offset, so square size, then are Times Square size, plus square size. And the offset is going to have to be like half of it because we're talking about the radius. So half of the rectangle is going to be adding an additional square size divided by two. Adding a square size divided by two. All right, let's see what happens now. Oh, and then I'm actually going to do the actually specify the radius. So the radius is what we defined just a second ago. Build What happened? Yeah, integer argument expected. Okay, so it looks like this division causes us to have some floats in our code. So we're gonna have to actually make this and pygame it seems like only accepts integers. So make sure that everything you every position and radius value, you make a integer. Come on, baby, let's go. Cool. Yay, we got a board. All right, I think that's where we're gonna end this video will actually animate the dropping of the pieces and then the kind of the pieces hovering over here and the text saying you won in the next video. Alright, see in a bit. What's up guys, and welcome to the fourth video in my programming Connect for in Python series. In the last video, we implemented the background graphics for our game. But if I click around on this screen, nothing actually happens. So in this video, we'll finish implementing this graphics will implement the piece dropping and then a nice little piece follow up here. Just a few quick notes. Before I begin, if there's a feature you wanted to know how to implement, but that I didn't actually cover myself in these videos, feel free to leave a comment down below, and I'll try my best to get back to you as quickly as possible. Also, if you enjoyed this series, please please, please leave me some suggestions for future programs that I can write make tutorials on, we're always looking for new content. Alright, let's get started. So to start this video, navigate down to the main game loop. before when we are selecting which column we wanted to drop a piece in, we manually typed in a number between zero and six to specify this. Now that we have a graphic, we want the column that we dropped the piece in to be dependent on where we click. So if I click on the left side of the screen, we want it to drop a piece in the left column if I click the middle, the middle column, etc. So where we dropped the piece depends on the x position of our mouse pointer. So luckily for us pygame makes using the getting the exposition of your mouse, super easy. So if you go to the PI game documentations under the events, it lists all of these events, and then it lists the properties you can get on these events. So for us, we care about mouse button down and we care about the position so position gives us an x comma y tuple of where we clicked. And I can use that as follows. So I can do print event dot position. And then I can rerun our game. And so as I click on the screen You'll be able to see in the bottom left, he positions where I'm clicking. So I click in the top left of the screen, it's about zero comma zero, that's where our axes starts. If I click in the bottom right of the screen, that's the, the full dimension of our game. And we specified that to be 700 700. So these are the pixel values of where we're clicking. To develop a kind of way to select the column based on where we click, we need to try to find a pattern on clicking in these different columns. So I'm going to do that real quick. And if we will look at all these clicks I just made, we can see the first click is between zero and 100. Second click is between 102 100 200 300 cetera. So the last column is between 607 100. So we can somehow round these numbers down to just give us zero to six, or back at where we were when we mainly typed in those numbers. So we're going to do that real quick. So let's, we can go ahead and uncomment all of this code. And actually, this is supposed to be a comment. So we can uncomment this code right here, and we can just comment this out for now. So column, so we want that to be we'll say that the exposition, so this is a tuple on the x values first, so the position of x is equal to event dot position, and then it's the zeroeth element of that the column now is going to be so this is between zero and 700. So the column we can get using, we're gonna also just to make this our lives easier, we're going to import a library called math, this comes default in any Python installation. So we are going to get what we want to drop it by doing position x, then we're going to divide everything by 100. Because this would give us a range between zero and seven instead of zero in 700. So the first thing we're going to do is divide it by 100. And 100, remember, is what we define our square sizes. So to make our code a little bit more robust to changes, we're going to do position x divided by square size. And then we want this to be a whole number, an integer value, so we're gonna have to take the floor of this division so that we'll round it down to the nearest integer. So we're going to do math dot floor. And then the final change we're gonna have to make is we just need to make sure that the column is an integer. Because we don't, we can't take the index of float value of decimal value. So we'll just ensure that it's an injury by just surrounding it with an int. And now we should be able to see when we click on the screen, we should see our board building up and we can copy the same thing for player two. And we'll uncomment this. Comment that uncomment all of this. And then we'll make player to be able to select the piece in the same way. So we'll say position x equals a bench that vendor position zero, and then the column now, my god messy. Okay, we'll delete this line. Cool. So let's see what happens when we build game. So now we have this, where's the actual game window, what happened? Oh, like didn't pop up for some reason. clicked down the middle. If you can see over here in the bottom right, our game did pick up that click. So I click on the middle again, keep clicking on the middle. And it keeps reading that I'm dropping the pieces. And so that looks really good. Now we actually have to just represent that on the screen. So to do this, we'll just make a small change to our draw board function that draws the graphics. So navigate to draw board. And we'll just do a if statement here. Just say so the rectangles always drawn the blue rectangles that make up the board. The black circle represents the empty square. So if board right now, board row, column equals equals zero, then we want it to be a black, we want it to be empty. If elsif board our row column, so this is just indexing our matrix equals equals one. So that's what we see here. Player One dropped it in the middle. Then we want to draw a circle. So we Just copy this line because we know that this is in the right position, where we're just gonna have to change the color up. So we don't want it to be black, we'll just use red and yellow, player one will be red. So this is going to be red. And this is not a built in thing, we're gonna have to define red. So we'll define red right below black. These are RGB values, so our needs to be have a value and the other two can be zeros. So this will give us a nice bright red. And then while I'm up here doing this, I'm also going to define yellow. Yellow is both red and green is combination of both red and green in RGB. So 255 255, zero. So now we have red and yellow for player one and player two. Ch, Where was that? Okay, yeah, it's red. And then one last line, which will be the else condition lbf. Board our common our C is two. So that's going to be pi game, or actually, I'll just paste this in, again, pi game, and then instead of black, we'll make this one yellow. And then one thing that might not be intuitive is that whenever we make changes to our game board, after this is all done, this loop has been iterated through, we're going to want to call pi game dot display dot update that will rerender the screen with the new changes. So let us let us and also we're going to have to add the drop board resort, we are printing board on every turn, but we're going to draw a board here as well. Okay, moment of truth, clicking right here, know what happened. So it looks like it's populating, it's just populating it in the wrong spot. And the reason for this is because of how our axes is set up. So as you recall, when I clicked down on the top left, this is the 00. And this is the 700 700 space. So in our game, though, this is the 00 piece, but it just kind of flipped. So when we printed the board, we call that NP dot flip function. So we're just gonna have to figure out a way to offset this to actually be in the bottom of the screen as opposed to the top. So to do that, we can just use our height smartly. So what we really need to do is, we're starting at the bottom, so we need to subtract whatever we're actually trying to build up from the bottom from our height. So height minus this height minus this, let's try running this. What is happening, alright, so we still are having an issue. And the reason we're now having an issue is because this piece right here is still filling in the old fashioned way. So they're kind of like filling in black and red and yellow tiles, all on different axes. So what we're going to do to make our lives easier, is we're going to take out these two lines into a another loop. So I'm going to delete those real quick. And we're just going to do a whole nother loop of, so just try to bear with me here, I'm going to copy this stuff, we're going to iterate through everything. Again, this might not be the smartest way, but it's just going to be very clean for us to deal with. Because we're always going to build our we're always going to build our background and then fill in the piece afterwards, as opposed to like try to fill in our pieces as we're building the pack round. So I'm thinking this will work well. This spacing is just messing me up. And these lines are so long. Here we go. Okay, so if board RC is one, we're gonna fill it with that, and then we can just delete this line. bring us back. Okay, so now we have two loops running but this will kind of fix our problem of them, building our board out on different accesses. So let's try running it again. What the heck. If board RC equals one, we're gonna have to have make this an elsif. Otherwise, it's gonna fill out the board for all the empty spaces at the start of the game equals two. Right? Cool. Let's see what happens now. It looks like it's working properly, but it's just offset by one square. sighs and that's because of this, right here we are initially account when we're building downwards, we're initially accounting for this. But now that we're building upwards, we can delete that from it from the height. So we're gonna delete this square size here. We're gonna delete this square size here. And we should now fully have it working. Build. Yay, looks pretty good, huh? All right, cool. So now that we've pretty much fully implemented a game with graphics, we're going to add a couple additional features. So the first feature we're going to add is add this little scroll wheel so that before we drop a piece, we can see what color the pieces in where we're going to drop it. So to do that, we're going to add a new event, we're going to track a new event. And that's going to be the event type equal to pi game dot mouse motion. And once again, all the different events you can use are listed in the the pygame documentation. And just like mouse button down, the mouse motion also has a position property. So I can do position x equals event dot position zero. So this is gonna get me a lot more events, though, because it's always tracking whenever making any motion. So this is going to be constantly updating. So now we're going to use this position and draw some circles based on where that position is. So if the turn equals equals zero, that's a player one's going, then we're going to do pygame dot draw dot circle screen, the surface color is red, because it's player one. The next thing we need to put in the circle is the position. So the exposition This is the center of the circle, it's going to be at position x wherever our mouse is, then we just want it to be offset enough so that the full circle can draw, so we'll just make this square size divided by two. And then finally, we need to specify the height of or the radius of the circle. And that's just the radius we've been using for all the tiles. Else is means it's turned equals equals one, it's player two's turn. And we'll just copy this and draw it. And now it's going to be actually yellow. So let's look what that looks like if we build that. Alright, build. Okay, I forgot to get the display update, just like we did in the draw function. So pygame dot display dot update, build. It looks good. It's just not ever deleting the circles. So what we're going to do to fix this is right, before we actually draw the circle, we'll just draw a rectangle that's black, that will black out any previous circles that we have drawn. So pygame dot draw dot rectangle, surfaces, the screen, color is black. position is going to start at the top left. So that's 00. It's going to have with the hole with the screen, and then the height will be a square size, because that's how big that buffer bar kind of at the top is. And that should be good. I think I might have one extra. No. Yeah, I have one extra parentheses there. Yeah, it looks good. So now we have this game over, Drop. Drop, drop, drop, drop. That looks good. Cool. And so one thing that you also might want to change is that if I win the game, so I'll win the game real quick with red, it automatically closes right away. So one thing we can do is we can add a weight pygame has a built in weight function. So what we can do is if the game over condition is true, so if Game Over, we'll call pi game dot time dot weight. And this is the milliseconds you want to wait. So 3000 would equal three seconds. So if I run this again 123 and I'll shut down automatically. Cool. And then right before it shuts down, we want some notification that the player actually won. So initially, we were printing it, but now we'll actually render the print function on our screen. So that will look something like as follows. So we're going to delete the line this is player one wins. And we're initialize a font up top so that will look like we'll do it right below the the first update. So we'll do my font equals pi game dot font dot system. font. This is all in the documentation, just copying some previous code I wrote. And the last time I wrote this, I use a font called monospace. But there's other options, you can look at the documentation for all the details. And we'll do font size 75. That's just an arbitrary number that I found worked. And then if we go down below, to actually render that on the screen horizontally, I can type the following. I can say, label equals my font dot render, player one wins, explanation. And then I believe this one right here that I just put in, specifies the axes that it's on, I'm not actually sure I might play around with that to check. And then we want the color to be red, because it's rendering that text red, because player one one, and then what we have to do to get that on the screen, do it quickly, we can also use the PI game display dot update function, but I'm going to do something a little different here. I'm going to do a screen dot blit. And that just updates that specific part of the screen. And I toyed around with these values before I found that the XY pay or where this will start at the top left hand corner of this text starting at 40, comma 10. worked pretty well. So let's see what happens when I run that we're going to have read when player one wins. And one thing is that tile gets in the way. Well, we could potentially do, we could potentially draw another black rectangle if we wanted to. I don't know I'm not too bothered by it, we'll fix it in one sec. We're gonna copy this for player two. And also Player Two Wins in the colors gonna be yellow now. Build. So what happens if yellow wins. Making this so hard on myself. 32 wins, yay. All right. And maybe what we'll do is at the start of the mouse button down, we will draw that black rectangle as well. So we don't have that annoying. Annoying tile getting in our way. So right wondering when we click the mouse button down, that will make the thing disappear on it one more time. Ah, player one wins, it looks good. And you can mess around with that as you see fit. Okay, I mean, that's like a pretty good game. I'm pretty happy with it. So this is going to be Tetris in Python with PI game. Now this is a pretty advanced tutorial. A lot of the stuff I do in here assumes that you already have a basic knowledge of Python, you kind of know some of the syntax, and you're not a complete beginner. That being said, if you are a complete beginner, feel free to watch through, see what you might understand, you're probably going to learn something along the way. It just might be a little bit confusing, because I'm kind of going to speed through a few things that are I would consider like trivial right now. Okay. So first step for this tutorial series is you guys have to download and install pi game because that's the module we're going to be using. Okay, so let's give a quick preview of what our game is going to look like. So this is Tetris, I didn't go too fancy with the graphics, I pretty much just want to make sure that we get everything functional here. And then you guys can play around and change stuff later on, if you want to. But yeah, this is a fully functioning game. You can see it just like standard Tetris, we have different colors, shapes are falling down the screen shows us our neck shape. And there we go, the road just cleared. So that's all I'm going to show you right now. Because I want to get into actually coding, okay. So, pretty much what we're going to be doing in this first tutorial, is we're going to be working a bit in the main function, we're going to be creating the grid, we're gonna be talking about formatting shapes, all the basics of just setting up for the rest of the tutorials. So the first step, and what I need you guys to do is you're going to download kind of like a starter file, okay. And that's just because if you see here, I scroll through my file, I got a lot of lists, I got a few things set up here. And you know what I could go through and type them all out. But that's just a waste of video, because it takes a long time. So to save yourself time, and to save me some time, what I'm going to do is just put a link in the description as a paste bin link, click that link and download this code. It's just going to be all this it just has all the functions that we're going to need for this. And then it has these shape formats, which I'm going to talk about in just a minute. So go do that if for some reason Paceman is not working, let me know in the comments. And I'll find another way to give it to you but I'm also going to put it in the pinned comment, so that you can just copy and paste it from there as well. I do recommend you check the indentation on it though because sometimes it messes up on paste bin and in the comments. Okay. So now that you've got that downloaded, we're working on that I'm gonna be working in PI charm. If you don't know about pi charm, don't worry about it, you can just use it ideally, but it's just going to save me a bit of time because it autocompletes variables, and it does some cool stuff. So that's what I'm going to be working in, feel free to work in PI charm, feel free to work in whatever text editor you want, just know that that's what I'm using doesn't make a difference. But some of the stuff I do in here you might not be able to do And ideally, or Sublime Text or whatever you guys are going to use. So we've got that all the way. We've got everything set up. And now we're ready to actually start coding and understanding what's going to be going on. So Tetris is a fairly complex game, you have shapes moving down the screen, they're rotating around, they're moving left and right. When they hit the bottom, they freeze in whatever position they're in. And then if you have a full row complete, like cubes, that not row clears, and you keep going. And obviously you lose the game, if you stack up too many blocks, and it goes up or above the top of the screen. Okay. So this first variables we need to set up is our screen width and our screen height. So we got 800 700 here, the next ones are play with and play heights. Now this is the actual red box that you guys saw. That's what these are representing. So since in Tetris, we have a 10 by 20 grid, we need to make sure that our play with is exactly half of our play height, so that we have perfect squares, right. So doing the math here that makes it 30 width and 30 height per block. So that's our block size of 30. Okay, so now this top left and top left x and top left y, this represents the top left position of our actual play area. That's so when we start drawing blocks, and we start checking for like collusion and stuff like that, we just have these already set up, and we don't have to deal with that. So the math is pretty straightforward. You guys could probably figure that out. You don't need me to explain that. Okay, shape format. So these, and this is the longest part is why I got you guys to copy everything is this is what's going to represent our shapes in Tetris. Now you see that I have multiple lists inside of lists, in most cases, this is because each shape has possibly more than one rotation, right. So this is the standard rotation of the S shape. And that's actually what they're called in Tetris, like s said, I, oh, whatever. And this is the second rotation. And these are the only two rotations or whatever that s can have. So that's why we have them in here we have a five by five grid of periods, and then whatever, there's a zero that represents where the block actually exists, okay. So that you can scroll through, you can kind of look at them. And you can see for some of them, for example, the square, well, it doesn't have any rotation, if you flip it, it's gonna look the same. So we only have one list here, for J. However, though, we have four, right, because we can rotate in different ways L, we also afford T, we have four as well, okay? After this, I create a list. And it just holds all of my shapes. So as I said, I just saw that That way, I can really easily select shapes, just by indexing them in the list like zero through six. And shape colors here is the same thing. It just corresponds to like for example, if I did shape zero, and I did shape color zero, then that's going to be the color of shape zero, okay? Same thing with like, six. So shape six, well, color list, or shape, color six is the color of that shape. So just makes it really easy. We don't have to deal with dictionaries or anything like that. Okay. All right. So now, we've kind of gone through the like starter file, I'd say. And you can scroll down here, you can look at the function names, I'm not going to explain them, because most of them are pretty straightforward. And I'll talk about them when we start coding them anyways. But we do have a class here. Now this class is going to be the main kind of data structure, if you want to call it for our game, and this is going to represent or this class is going to represent different pieces. So the reason we have the class is because we're going to call this a bunch of times, and it's pretty much just going to hold the information like x y width height for our piece. So let's actually start coding this now. So I'm just going to create my initialization function or method. And this is actually the only method that I'm going to have. So I need another underscore, just butchered that. And pretty much, what this is gonna have is gonna have an x, a y, and then it's going to have a shake. Okay. And that's the only information we need for this. And I'll show you why. So we'll say self dot x equals x, self dot y is equal to y, self dot shape is equal to shape. And then what we're gonna do here now is want the color, and we want the rotation. So self dot color. Well, I was already talking about this self dot color is just equal to whatever the index of this shape is, in this color list. So what we can do is we can do shape under short colors, square brackets, and then shapes dot index, and whatever shape we were given. So if we're given the shape s, well, let's just find it in the shapeless, whatever index that is, well, that's the color of our shape, pretty straightforward. And then we're going to do a rotation. So rotation, this is going to set default to zero. And this is so that whenever we click the up arrow key, we can just add one to this rotation, and that will represent what shape we're actually going to be showing because again, remember the shape list is a multi dimensional list it has, you can see here, in this case four lists within it. Okay. Alright, create grid. I don't know if we want to do this one yet, you know what, actually, let's go. Let's go ahead and do this one. It's not too complicated. So the way that I'm going to represent the grid in Tetris, so that 10 by 20 grid, is just by creating a list full of colors. Okay, so we're going to have a two dimensional list. And within that second dimension, it's going to represent a bunch of colors. Okay, so I'll show you just by coding and kind of talking about after, say, grid is equal to, and then another square bracket here, for x, and range 20. And don't worry, I'll explain this in one second. And it will say for x in range 10. Okay. Except here, we're just gonna use 000. Okay, so what I've just done here, this is pretty this is like, the Python way to create lists k list comprehension, we're going to create one list for every row in our grid. So since we have 20 rows, we want to create 20 sub lists, and each of these like sub lists, or whatever two dimensional list is going to have a bunch of colors in it, how many colors is gonna have? Well, it's going to have 10 colors, because we have 10 squares in each row, we have 20 rows. So that's the way it works. These X's you could replace with underscores, because we don't really care about the actual variable, we just need to do this that many times. Now. 0000, or 000. Like that's right. Anyways, that's just block stands for block. And the way we're going to draw the grid is simply by looping through this grid, which we're going to return and just draw on each color. So it makes it pretty straightforward. Okay. Now, the only thing that we have to do here, though, is we have this locked position. argument now, locked position will right now we've created a blank grid. What if there's already blocks that have been placed in our grid, so like they've already fallen, they're static, now they're not moving? Well, we need to also draw those. So to draw those, we're going to check if any of the positions in locked position are not like or whatever positions are in locked position, we're going to get that color and we're going to change the corresponding value in the grid. I'll show that just by kind of coding here. So for I, in range, I'm going to do the length of grid. And again, this is going to give us 20. Because the length of grid will that it's 20 of these, right? Okay, so for i in range, one of grid for j in range, and then we'll say the Len of grid I, because now we're in this list. So now we're going to do whatever the length of that list is, okay? Alright, say if this if j comma i, because j is our x value, I is our y value, because rows are represented by I and the columns represented by J in a locked position, and just you know, locked pause stands for locked position, it's also a dictionary. So you can see that it's a blank dictionary here and each position. So like, for example, if we had like one one, is going to be set equal to a color, and the color could be something like 255 00. Okay, and we're going to talk about that and create that later. But that's just something he needs to know for now. Okay, so j is in locked position. So if that key exists, let's figure out what that key is. So that key is going to be equal to well lock position, or what the value is sorry, associated with that key J. Now we're going to change whatever the current grid position is here. So for grid, i, j, is equal to C. Okay? I know this might seem kind of complicated, but pretty much we're just looking through this grid, and we're gonna find the corresponding position to the locked position, and just change the color in the grid so that later when we draw it, we get an accurate grid. Okay. And you guys will see how this all is kind of plays out later if it seems a bit confusing, okay. And we're going to return that grid to wherever we're calling. Okay, so that's one part done. Now we can move down and we can go into draw window, which is the actually let's do get shaped. This one's really easy. Okay. So this is literally a one liner, return random dot x, actually, what is it called here, I got to have a look, I think it's random dot choose random dot choice. That's what is random dot choice. And then we're going to be given a shape list. So say, shape. Actually, let's just, we'll call it up here. Sorry guys shape. random choice shapes. All this is going to do is it's going to pick one of these shapes, and it's just going to give it to us. So that when we need to create like a new shape falling down the screen or whatever, that's all we have to do. Okay, so good shape. random choice down really easy. Okay. Next one drug raid. Alright, so what we're gonna do is we're gonna be past a surface, and the surface is obviously what we're going to be drawing on. So we're gonna start by just changing the surface surface that when surface dot fill with color this case the code is going to be blocked. Okay, surface dot fill 002. Alright, next thing we're going to do is we're just going to draw like a title on things. So the way we have to do this, we first have to start by initializing font objects when we do pygame.font.net. Okay, this just means we're setting up font, and we're getting ready to draw to the screen. We're going to create a font, a font is equal to pi game, dot font dot, s, y s capital, as well as font. And then we need the font name on the Comic Sans guy. So I'm gonna use Comic Sans size of the font, I believe. Yeah, so the fight Randy's 60. Okay. So the way you want to set up your fight, you want to change this, just change this to any font, you can look up fonts on the pygame website, and then just give it a size, if you know the name of the font, type it in here, it probably exists in, in PI game. All right. So now we're gonna need to set up a label. So I say label is equal to font dot render. And then in here, we need the text that we're going to render, in this case, I'm gonna call Tetris, need our anti aliasing of one, and I believe we need a color. In this case, I'm going to make it white. Okay. So text, anti aliasing, just set this one, I don't know why you need to set this one. But just so that one, and then whatever color you want your label to be, okay, now that we've got the label, we need to draw this label on the screen. So let's pull it it's not when I'm used to typing when surface dot Blitz. And then in this case, we're going to put the label, where do we want to put it? Well, now we want to figure out where the middle of the screen is. So we could just hard code this in. But if we ever want to change the dimensions of our screen, we want this just automatically kind of adapt to that. So we're gonna do top left, x plus play width, over two, okay, and that's going to give us the middle of the screen. If you don't understand that, let me know and I can explain it to you in the comments down below. Okay, now we're going to subtract this sorry, this isn't actually done yet, by the width of the label, because this is gonna matter. Depending on how long the label is, we're gonna determine where we place it on the screen. So we're gonna get the width of the label, and we're going to divide that by two. Okay, so now we need to do the Y. While the Y is pretty easy, we can just statically type this in because it's from the top of the screen. So I'm just going to give it unclick 50 is what I typed in 30. Okay, and that should put it in the middle of the screen. And I can explain that to any of you guys that might not understand it, you just leave a comment, because I don't want to waste too much time because I think a lot of people might understand that. So for i in range, now, the length of grid, because now we're gonna start drawing all the grid objects onto the screen. So we created a grid, we know how that kind of format works, we're gonna say, for J. and range, the lun of grid is same as before. And we're going to pygame dot draw dot rectangle, and then this guy is gonna draw on the surface. And then we're gonna go grid, i, j, okay, and then top underscore left, I need to put this in. What do you call it, brackets, your top underscore left search need to scroll over top left, underscore x plus j multiplied by 30. And I'll talk about this one in just a second how this works. And then top left, why Plus, I multiplied by 30, another bracket, and there we go. Now we just got to deal with this grid thing. So that means that we just now need to pass grid as well into our drop grid. Okay, way this works, we're a loop through every color within our grid. So this is the color grid ij. Alright, this is the surface we're drawing it onto. And this is the position in which it's being drawn. Now, we also just need to add two things here that I realized I forgot, because we need the x, y, we need a width, and we need height. And so for width and height, well, that's go to the block size, and block size once again. And you know, we can even multiply this instead of by 30. By block size in case we ever decide to change that. So let's do that just to keep this nice and dynamic. And then if we keep going over here, the last thing we need is a fill. So we're just gonna put comma zero to make sure that we fill in the shape, we don't just draw like a border for it. Okay, we this works, we get our top left x, and we're gonna figure out wherever we are. So which column we're in, multiply that by block size, and that's our exposition. Same thing works for the Y with the starting y position plus, whatever row we're in, multiplied by the block size will give us the correct position to draw our cube in. Okay. After we've done all that, we just need to update the screen. So pi game dot display to update. And there we go. So there's actually one last thing we want to draw. And it's a red rectangle that you guys saw in that kind of represented like the play area. So to draw it out, we do pygame dot draw, dot rect and then surface. And then in this case, we're just gonna actually, let's see here, do we want do I want to dynamically type this in? Or do I want to just statically draw it. So let's give it a color first of all, of red series 00. Okay, and we're actually going to type it in dynamic, just in case we decide to change anything later. So top left, x, and topless, why. And then the width, we actually already have all these variables. So we have the play underscore width, and the play underscore height. And in this case, we're going to give it a border size of four. Okay. And that's all for drawing the grid, we might come back to this later, but for now, that's it. Okay, so this just draws the actual grid, draw grid, and I've added this, okay, we're just gonna copy this part of you guys that says draw grid. So surface, I'll put this label and I'm just gonna move this in, because I realized I have another function called draw window. So in draw window, what I'm going to do is surface stop, fill, whatever. Okay, so, um, take surface and a grid. So I've just copied some of it from there. And then instead of updating the screen here, we're gonna update the screen over here. And we're just going to call our draw grid. What do you call it? function like this. Okay, so now what if we want to draw the grid and we want to use this in another program, we could just copy and paste this function, we wouldn't have to kind of take it out of here. We wouldn't have to like dissect it. Alright. Okay, so draw grid. Again, this takes surface and this takes grid. And there we go. I believe that's working well. Okay. Now that we've done that, we're going to start coding in the main and in main menu, and this is what we're going to finish off with this tutorial, because I know we're almost at the 20 minute mark. Right. So what we're gonna do in main now is we're going to set up a few variables. So the first variable we need is this locked position. locked position, okay. And again, this is what we're passing up here into create grid, it's equal to a blank dictionary just to set in case we don't pass it then we don't need it. Okay. So lock positions equals blank, we're going to say grid is now equal to well create grid because we already created that function with lock positions passed to it and create a variable called change underscored piece, it's gonna be equal to false, we're gonna make run equal to true, this is just for our while loop that we're gonna use, we're gonna say current piece is equal to get underscore shape. Okay, we're gonna say, next piece is equal to get shaped as well, we're gonna set up a clock object and clock is equal to pi game, dot time dot clock. And we're gonna set a variable called full time equal to zero. And those are all the variables that we need in our main function already coded for us. Okay, so now we're gonna set up our while loop is our main game loop here, say well run. First thing we need to do in our loop, sorry, for event in PI game, dot event dot get, let me say if event dot type equals equals pi game dot quit. Well, that means we need to quit the program. So the way that we can do that is just simply hitting run equals false. It's going to break us out of our while loop, and then we can deal with that afterwards. We're also going to add another event. This is a key down event. So if event dot type equals equals pi game dot key down like that, then we're going to check what specific key is actually hit. So let's go ahead and do this now. Kind of get it over with so I'm just going to type all the different keys. And then we'll go in and code that after. So we'll say if what do you call it pi game dot key equals equals, I believe, that's what it is, or event key not plugging key my bad guys, event dot key equals equals pi game dot k underscore, capital K. K underscore left. We say if event dot key equals equals pi game, dot k underscore, right, like that. And then same thing up and down. So event dot key equals equals game dot k underscore down. And last one, up. Okay, I don't know why that keeps happening. Okay, okay, underscore up like that. Okay, so painfully after typing that left, right down, up. Now we can go in here and we can kind of code what each of these is going to do. So for hitting left, we want to move our block left. If we're coding, right, if we're hitting rate one, move our block, right, and we're going down, we're gonna move down if we're going up, we want to rotate our shape. That's what the main things are going to do in here. So if we want to move our piece left, well, we should change the Y the x value left wise, okay. So the way that we can do that it is a current piece, dot x minus equals one. Now I know you guys are looking at this right now you're saying okay, well what the heck man, so current piece is equal to get shape. And that's all equal Get shape, well, what is good shape, and it's just returning random choice shapes. Now, this actually just made me realize the fact that our get shaped thing needs to change. But that's because we need to actually create a piece in here. So we set up this lovely class up here and we weren't even using it. So Pease random choice shapes as the last argument takes, it also takes an x and a y value, right? So for the x and the y, well, the Y is pretty straightforward. It's just gonna be zero, the x has to be the middle of the screen, so we're gonna give me five for y, we're gonna give it to you. Okay? And actually, for why we'll leave it zero for now. But we might want to make it negative so that it kind of starts above the screen and then starts falling down. Okay, so we have, let's make sure this works. looks right, x, y shape. Yep. Okay, great. Okay, so that makes sense. Now on how we can change this x value, same thing for rights. We'll do current piece, dot y, or dot x plus equals one. That's a for down, we're actually just going to type this in for now. But this is not exactly what's going to work. Y plus equals one to move downwards. And for up, well, we need to rotate the shape. So to rotate the shape, this actually pretty easy over into Steve, his current piece dot rotation, plus equals one, okay? Because when we change that rotation, well, that changes the actual image of the shape. Okay? Now, this is all great. But the thing is, what if we're moving off the screen? Or what if this is not a valid position? Well, that's why we have a function called valid space. Now, valid space, we haven't yet coded but I do have it in here somewhere valid space, and well valid space is going to do is it's simply going to return if the current position that we're in is a valid space. So the way that I do so this is gonna just make life a lot easier. If we're moving left, let's simply just change the pieces x, move it left one, and then check if that's a valid position. And if it's not, well, then we can just add one, and move it back to where it was. So we're gonna say if not, and then valid space and valid space. Again, take two arguments, gonna take the current piece and it's going to take the grid, okay? Then let's just simply subtract or add one to our piece. So all this is saying is we're gonna move left, but if for some reason moving left, results in not a valid space, well, let's just add one and pretend like we didn't even move there. So we're not drawing it, we're not changing anything. So this is perfectly fine. And it's actually a really easy way to check things that haven't been checking if if it's below this or above this or whatever. Okay, so now next, next one here, we're gonna say if not valid space. And same thing current piece. With grid. Well, now in here, instead of adding one, we're just gonna subtract one because we were trying to move right. And there we go. Same thing with moving down. Okay, so we're literally just gonna take the exact same thing, if not, valid space, current piece and grid. Well, now let, instead of adding one, we're just gonna subtract one and this is from the y value this time she said current piece. dot y minus equals one. Okay, so now for up. So when we change the rotation, we are changing the shape. Okay? So it doesn't show this yet right now, like how we change the shape, but we're going to do that later. So we can actually just call the exact same thing on rotation. Because think about it. If we're fully on the right side with like the straight piece, and we try to rotate, well, that could result in our piece being moved to the left or to the right. Or like, there could be positions where it's on the left, or it's on the right, and it's not in the grid. So we do have to check for rotation. If it is about spacemouse. We'll say current piece. And then what else are we doing? Great here. Okay, and then this case, we get it, we'll just we'll just subtract one from rotation. So minus equals one. And that should all work pretty well. Okay, so after we do that, we're gonna make sure that we remember to draw the grid. So in this wallet, put such say, actually draw window. I'm gonna give it surface. And we're going to give it grid. Now, this reminds me that I haven't yet created a pie game surface. That's great. So let's do that. So here, I'm going to say when equals pi game, dot display dot set underscore mode. In this case, I'm going to give it what is their screen width and screen height. So s, width, and s underscore height. And that's it for display. We want to give this a caption though. So we'll say a pygame dot display dot set underscore caption. Yep. So let's call this Tetris. Like that. And now we're going to just pass when into our main menu. We'll put one in here. And then in main menu, we're going to call me, okay, and we'll deal with Main Menu later. I don't feel like coding it right now. And it's not really important to like the main functionality of the game so we can simply just do this. Okay. Main win. Like this, and If I put win here, then everything should work out the surface. change this to say, when? In locusts Okay, so now we've effectively done draw grid or draw window, draw grid, get shape, create grid, we've created a piece, we've gone through what all this stuff in the starter file does. And we are now at 27 minutes. Hey guys, and welcome back to part two of coding Tetris in Python with PI game. So let's get right into it. In this video, we're gonna be finishing a few other functions, we're going to be doing valid space, convert shape format, we're gonna be coding but in the main, and we're also gonna be fixing a small mistake I made in the last video. So this code right here in drug grid, yes, this does draw our grid, but this is not what I intended this function to do. And I kind of just realized this, when I was looking over the video and looking over the codes, we're just gonna copy this code from draw grid, okay, deleted out of there. And we're just going to paste it down here at the bottom of draw wind. Okay, so now we just have this after we're putting the label, we have whatever code we had within draw grid, okay, because draw grid would this actually was supposed to do is draw the lines for the grid. So I kind of got this mixed up while I was going through the tutorial. So we're going to finish draw grid now. And what this is going to do, and it's going to draw those gray lines over top of all of our different colors that can kind of see where each block is, and we can see the actual grid structure. So let's get started with this. Say sx, which stands for start x is equal to what do you call it? Top left x. Okay, and then as far as equal to top left y, like that, all right. And this is just so I don't have to keep typing top left x, top left, y just makes it a little bit shorter for us. Okay. Now, I'm just gonna say I'm going to set up a for loop and I say, for i in range, and this is going to be the length of the grid. So how many rows we have, let's say for j, in range, and this one is going to be the length of grid i. So how many columns in each row. And then here, we're going to be drawing lines, okay. So for every row, we're going to draw a line. So pygame dot draw dot line, we need a surface, give it a surface, we need to cover this case gonna be gray. So gray color code standard is 128 128 128. And then we need two positions, okay. So the start position is going to be equal to sx. Alright. And then S y plus, what do you call it, I believe multiplied by block size. And I think that is actually correct. Okay. Now, for the end position, well, it's gonna be the same x value because we're destroying, or actually, it's gonna be, let me just check you, yeah, it's gonna be a x value that is just equal to the width. So s x plus whatever the play with this, and then the y value is going to be the same here. Because if you think about it, we're gonna be at the same y value each time we're doing like, we're drawing a horizontal line, every horizontal line is gonna have the same two y values and the x values just gonna be changed. Okay? So I'm just gonna copy this and paste it in here now. Okay. All right. I don't know why that did that. But we'll just go back like that. Okay. So now what we're gonna do is we're just gonna do this case with x s x plus j multiplied by block size, okay? s, y can actually just stay like this, okay. And then for sx, same thing, as x plus j, multiplied by block size. And j is, again, is our current column. And then this one s, y plus play, underscore, oops, we need a plus sign here, plus play underscore height like that. Okay. And that should be drawing us. What do you call it 20 vertical lines, and then 10 horizontal lines down the screen, giving us a grid, and kind of the way that works is every time we loop through a new row, we're simply changing the y value of what line we're drawing, and then these x values are gonna stay static, just at the left side and the right side of the screen. And then the way that we do it here is we have the x values that constantly are changing every column and the y values are staying static, being the top of the screen and the bottom of the screen to draw the vertical lines. And that's what I wanted to do within this draw grid function. So now, that's all kind of sorted out. And we fixed like a small mistake, don't get me wrong, can still have that other code up here. Like it still works fine. But just in terms of what I actually wanted to do with these functions. That's the way we need to fix it. Okay. So now that we've done that, what I want to start doing is getting into this convert shape format, okay? Now, this is probably the most complicated function I want to say within our program. And what this is going to take as an argument or a parameter is just the shape. Now this is what I was talking about before. So when we have a shape, it looks something like this, right? So we have zeros and we have periods. Now this looks nice to us. Like we can tell what kind of shape this is, but the computer has no idea. So how can we get this into a form that the computer can read. And ideally you want to give it, we want it to give us positions within the grid of where blocks exist. And then we're not going to give position if the block doesn't exist. So if there's a period like this, okay, and you'll see what I mean, as we start coding this function, and that's what the goal of this function is to do to take that information and put it into something that's actually useful to us. So we want a bunch of positions, that's the goal. From these, like lists, we want to generate a list of positions. And then based on those positions, we can do things we can check them, we can draw them, and so on, I'm just gonna create a list called format. Don't worry if it's a keyword, it'll just override it. We're gonna say when we're given a shape, we're actually given a piece object. So I don't know why I'm calling the shape, but whatever. So shape dot shape, and then we can just do is equal to, and I'll talk about this in a second shape, dot rotation, modulus, youth length of shape, dot shape. Okay, so what this does is actually gives us the sub list that we need. So this needs to be spelt correctly. I don't know how I butchered that. So bad. Okay, shape dot shape. So if we look again, here, whenever we're past a shape, we're actually past something like this, right, so we're past the shape object and its shape property. So right here, is looks something like this looks like the variable t, which would have a list full of lists. So we want to get the actual sub list. So which one this list right, that's what we want. So the way we do that, is by getting the shape rotation modulates the length of the shape. So for example, if our current rotation is zero, like we haven't rotated yet, then what's gonna happen is we're gonna have zero modulates the length of shape, in this case, the length would be four, so we get zero. So we're given this first shape. Now if we have one, we're given this if we have two, we're given this, if we have three, we're given this. And if we have four, then we go back, and we get this one, okay? And it just keeps going and keeps going. Because modules simply just gives us the remainder. So that's how we can tell what the actual current shape is within that main list. Okay, hope that makes sense. So now we've done that, well, we want to do is want to set up a loop. And because we want to look through every row and every column, and then based on if there's a zero or a period, we're going to do something. So we're going to say for i comma, and because we want the line as well in a numerate, right, and then format, okay, because format is the list that contains, like the actual zeros and ones, okay, we're just gonna say row is equal to list of line. This just gives us a nice list format that we can deal with making it easier for us, I'm going to say for j in or j, comma column, sorry, in a numerate and now row. So now every row we're getting the current line, and then we're gonna loop through the line and look for either zero or a period. We're gonna say if column, which is going to be, for example, if we have some, like this gonna look like 00. Okay, so this is what our row is gonna look like. So when we start looping, J will be zero and column will be a period. Okay? Just Just in case you can't confuse that. Okay, so for if column equals equals, and it's gonna be string zero, then we know that we've hit like a position like this cube exists here. So what we want to do is we want to add the position to our positions list. Now, it's not so simple as just add current IMG value, we actually have to add something else what I'll show you right now, I'm just gonna type it out and kind of talk about Okay, so shape dot x plus j, and then shape dot y, plus i, okay, so this is our x value, it's the current value of the shape, because if the shape is already moving down the screen, it's moving left and right, well, we need to add that to whatever the J value is, whatever column we're in within this list, okay? And then same thing with the y value. So whatever the current y value is of our shape, we're going to add whatever column or whatever row sorry, we're now in as for the y value, okay? And that is the positions that we need in these positions list. Okay, so now that we've done that, we just have to modify these positions slightly, we've got to give them an offset. Okay. And I'll talk about why this why we have to do this. So for I pause in a numerate positions, okay, then we're gonna say, positions, i is equal to, and then this is going to be the current position, okay? So we just need to put this into Tableau because that's where we're gonna give it. Pause zero minus two, and pause one, minus four. Okay, so now let's break this down and kind of talk about exactly what's going on. So we started off blank list positions. We're just getting the actual shape within this list. So for example, we get something like this, okay. And then we're looping through it. And where am I sorry, and we're pretty much just checking if zero exists in each Position have that shape, okay? If that exists, then we're gonna add that position into our list. And the way we do that is simply by getting the x plus whatever the current column is that we're looping through, and whatever the current row is plus y, okay? Now we've got that, the issue is that if we look here, we're going to get something like for a position list here, we'll get something like three, one, and then we'll get three, two, we'll get three, three, and we'll get three, four. Okay. Now the issue with that is we're adding the current x value, plus these two periods, and the Oh, so we need to remove these kind of trailing periods, right? Because that's going to result in our positions being offset to the right by too much. Same thing with these y values, okay? Because when we're counting this row, we're saying, well, this is one lower than this row, so our current y value, say zero, and we're adding to it, now instead of just adding one, we're gonna be adding two, so it's gonna, everything's gonna be offset down. So the way that we can kind of fix this is just by offsetting by constant and by offsetting, I'm just gonna take every x value that we've added and subtract two from it. And every y value that we've added in subtract four from it. Now this is going to do is simply just move everything to the left and up so that when we are displaying it, it's just more accurate to the screen. Okay, you guys can see what's going to happen if you don't offset this. And you'll notice that you kind of run into a few errors. So just run with me on the screen and just kind of you should see how this works later on. Okay. Okay, so now that we've converted the shape format, I want to go and code valid space now. Okay, so valid space is going to take two parameters, shape and grid. Alright. And we're going to check the grid to see if we're moving into a valid space. So what I'm going to do here is I'm going to create two lists, I'm gonna say accepted. How do you spell accepted, accepted underscore pause. So these are just gonna be the positions that are actually valid, okay, is equal to and just flow with me on this, we'll talk about in a second for j, i, in then within this list for j in range, 10. So similar to what we did to did in the last tutorial, and then for i in range 20. Okay, so this is really similar to the way that we created the grid, we're just getting every single possible position for a 10 by 20. grid, okay, and we're just adding in a tupple and accepted positions gate. That's great. But the thing is, I want to convert this into a one dimensional list. So this is the way that we can do this and make all the positions. But now how do we flatten this list. So this is actually how you do this. Okay, so excepted pause, is going to be equal to and this is one way, there's many j for sub in accepted positions. And then one more for j in sub, okay. So what this is actually doing now is it's pretty much taking all the positions in our list and just adding it into a one dimensional list. And then we're just overriding this list with that. So see if you guys can understand that. If not, don't worry about it, just know that all this does is simply flatten this list. So we go from looking something like this. wouldn't call it like 01. And then having another list. bedded stretched out example here, two, three. So we go from that to something that kind of looks like this. And we just held the positions in it now. So we don't have those sub lists. And this just makes it a lot easier to loop through. Okay, so now we just have 0123, rather than having these embedded lists full of other temples, okay, that's all we're doing with this line. Okay. So after we do that, what we want to do is we want to get all these positions, and we're going to get the shape, and we're going to convert it into our positions, right, because remember, whenever we get a shape that looks something like this, it means nothing to us, we need to first convert it into positions before we can compare it against other positions in our grid. So we're going to use this convert shape format grid, our convert shape format, we're gonna pass it the shape, and we're just gonna store this in a variable, and I guess we're gonna call it, what should we call it? format, okay, because I guess that makes sense. We formatted our shapes. So now we can use this and kind of compare it against accepted positions. So here, we're gonna have a list that looks like something with a bunch of positions in it. And then this one, we're gonna have a list that has a bunch of positions in it. So you might see where we're going here in terms of how to compare these things. Okay. Okay, so now that we've done that, we've kind of got all the data ready to check. This is the really easy part is we're just gonna say for position, informatics, and all we're gonna do now is just check if this position exists within accepted positions, because accepted position is every position that we're allowed to have, right? So we're gonna say, if paws not in accepted position. And this is an important part, pause. One is greater than negative one, return false, and then otherwise, so if we make it through that loop, that means we had all our positions accepted, we can return true Okay, so let's talk about this really quickly. The reason I have this if paws once the y value is greater than negative one is because when we give this offset of four, what ends up happening is we get some, when we spawn in our shapes, they're going to spawn above the screen. Now we actually want this, because we don't want our shape to show up on the screen wants to start falling before it's actually seen. So typically, this means y position is going to start at like negative one or negative two. So the thing is, while it's falling, we're checking if it's in a valid position, right? But the thing is, it's not going to be in a valid position if it's negative. So we just want to make sure that we're only asking if it's an invalid position if the y value is greater than negative one, so greater than or equal to zero, okay? And this is a really easy way to tell us well, are we on the grid or not? So let's give an example. Say we're trying to move left, and we're already at the edge of the screen. So that means we're gonna have an x value of negative one. Well, that position of negative one, whatever y value is not going to be in this accepted position. What do you list? So when we try this, we're going to return false, and it's not going to allow us to move left? And that is the whole point of that. And now, okay. What am I doing here? Okay, so I also just want to modify this part up here. So I have true j, i in range for j in range. If i in range 20. I want to just change something here. Okay, so what I'm going to do actually the mistake if grid, i j equals equals, and then the colored users Yeah, okay. So this is an important part, I was kind of waiting, I was kind of thinking about this. So pretty much, we're only going to add this position into our accepted position if it's empty, which actually makes a lot of sense. Because think about it, if we already have a color in that position, then that's not a valid position, we can't move into where piece already exists. So this conduct condition does it says, Okay, we're only adding this position. Now, if this is true, so if i j is true, then we're good, we can add the position. If it's not 000, that means something exists in there. So that's why we're not going to add it into our accepted positions. Okay, so I know this looks kind of confusing. So I'm doing like a bunch of embedded for loops. This just saves us a few lines. It's kind of a cool way to create a list in one liner. It's like the Python anyway, so I figured I'd do that for most of the stuff in here. Okay. So now that we've done that, what else can we code? Well, you know what, while we're here, we can code check last. All right, this one's a really easy function, this is just simply going to check if any of the positions are, what do you call it above the screen. So if we hit y value zero, then we know that we're above the screen that we've actually lost. So the way to do is we're gonna say four paws in positions, because what this is going to do is we're going to pass a list of positions. So we're going to get every pause now in the position, we're going to say x, y is equal to pause, which simply you're splitting up the tupple, because we know we're gonna get something that looks in the form of like, three, four, okay, and we're gonna say, if y is less than one, so equal to zero or greater than return true. Else, or we don't even need an else return false down here. So if every position is less than or greater than y, or whatever, one, then we will return false because we haven't lost yet. Otherwise, we're returning true. Okay, so we're almost getting there. Now I want to go down to the main, and I want to finish coding up some stuff in here. So last time, we kind of just left it at this, like moving pieces around, whatever. But we have these variables. Okay, so change piece, next piece clock full time that we're not using. So what I'm going to do now is I'm going to show you guys how we can actually move our shape down our screen at like a regular time interval. So I'm going to create a variable here actually called false speed. And this is how long it's going to take before each shape starts falling. Okay, so we'll talk about how to do this, I shouldn't gonna start coding it now. So pretty much we're gonna say, up here. And I didn't do this before, but follow along. Grid equals create grid based on locked positions. The reason we're doing this, I know we already created grid up here is because every time that we move, we have a chance to be adding something to locked positions. We're going to do that later. Because for example, if we hit the bottom of the screen will now locked position is going to be equal to something else because it's going to have a new shape and it shouldn't we need to constantly update the grid, so that when we're drawing it to the screen, we get like an updated version. So that's why I'm doing that up here. Okay. I also need to actually, I don't think I need to do that here. We need to add to full time, okay, so the way we're gonna add to full time because this is going to track what do you call it? How long since like the last loop ran is by using this clock object that I set up here. Okay, so before I add to that, after here, I'm going to do clock dot tick and then I'm going to add this and I'll talk about After I do at some clock dot get underscore raw time like that. Okay. So the way that this works is this raw time actually gets the amount of time since this last clock dot tick. So when I first add, it's going to be zero because we haven't yet ticked the clock and the next iteration, it's going to see how long it took this while loop to run. And then it's going to simply add that amount, okay, so it's actually going to give us real time. This means that this should technically run at the exact same speed on everyone's computer at every one machine. Because I know when I use FPS, FPS is dependent on kind of the speed of what you call it. Your actual computer, sometimes like the way I did it in other games, so this is a better way to do it. So now what I'm going to do is, since I've now incremented, the full time, and this is going to be given to us in milliseconds. So like one second would be 1000. That number and our full speed is in well 0.27. So what I need to do is I have to say if fall time, divided by 1000 is greater than full speed, then what we're gonna do is we're gonna reset full time equal to zero, and we're going to add one to the current y value, which means we're scrapped we're moving down the piece one, so this is going to automatically Now move our piece down. Another thing is what if our piece will hit the bottom of the screen, and what if it's moving into position we can't move into. So this is the same thing we've kind of done in here, what we're gonna do is we're gonna say again, if not valid position or valid space, whatever, given the current piece, and our grid, I believe at least grid, okay, then, and actually, we're gonna check one other condition. And our current PCE dot y is greater than zero. So this means that we're not at like the top of the screen, because the same thing with negative values, alright, is greater than zero, then what we're gonna do is we're going to subtract one from the current piece. So why once equal one, because that means we moved into an invalid position. So let's move back up one and pretend like that never happened. And we're just going to say, change piece is equal to true. Now, the reason I'm setting change piece equal to true, because think about it, right, if we're moving down, and we move into position, that's not valid, well, we know we didn't move left right off the screen, because we were moving down, that means we must have either hit the bottom of the screen, or hit another piece. So in that instance, we need to stop moving this piece, and we need to change it. And what changing pieces going to do, we're going to do that later, is simply going to lock all the positions what they're currently in, and then it's going to make this next piece generate down the screen. And I'll show you that in a second. But this is kind of the way to check it. It's easier way then you don't have to check like the y values and, and all that stuff. Okay. Alright, so now that we've done that, let's move down here to the bottom of main. And let's start adding a few things. Okay, so what I want to do down here, I want to say shape positions. So shape underscore pause, is equal to convert shape format, current piece, because what we're going to do now is we're going to check all the positions of the piece moving down to see if we've hit the ground or see if we need to lock it, okay. So, and we're going to add all that color to the grid so that when we're drawing it, we actually see the piece because right now we have the piece, but we don't add its color into the grid, so we're not actually going to see it show up. So we first need to add it to the grid so that we can draw it and we can see it moving. So to do that, we're gonna say for i in range, the Len of shape positions, okay. We're going to here to say x, y equals shape positions of i x, that's the current iteration, the current one we're looking through, we're gonna say if y is greater than negative one. So this means that we're not above the screen, let me say grid, y, x equals current piece dot cutting, okay? Because remember, the grid stores a bunch of different colors. So all we're doing the greatest giving different colors, and based on that position in the grid, so y x, which is going to be this shape, the all the shape positions, we're going to draw that color. Now the reason we're going to have this negative one is because imagine that we're at the top of the screen, and we try to draw it or we're above the screen, we have a position with a negative y value. So if we throw negative, we're not actually going to get an error in grade here. But it's going to end up looking like it's at the bottom of the screen and then moving to the top and it's just gonna look weird. If you guys want to see what it looks like without this, just remove this condition. You'll see that why have it added in. Okay, so now what we're gonna do is we're going to check this change piece variable. So I put it up here, change piece, this means that we've hit the bottom or we've hit something. What we're going to do now is we're gonna update lock positions and this one, I'm gonna start talking about lock positions. Okay, so for pause actually in shape positions. Alright, we're gonna say p is equal to pause, zero. Pause one. All right. I don't know why. Do this, but I think there's a reason for it. So let's just run with it. And we're gonna say locked positions p is equal to current piece, dot code. Okay, so what is this? Well locked positions is going to be a dictionary, in a form like this, right? It's gonna have a tough one here, that's gonna have a position like one, two, colon, and then we're gonna have a color and the color is going to be another tupple. But RGB values, okay, so for example, 255 00. The reason we have this is so that when we passed locked positions into our grid like this, right, we can get each of those positions in the grid, and then update the color of grid. So every time that we have like a locked position in a locked position, as simply means our piece is no longer moving, it hit the bottom of the screen, and we're on to a new piece, we can get the position and we can get the color, and then we can update the grid based on that, and we can keep that in there. Okay. And that's the way that locked position works. So it's a dictionary with the key of a position and the value of a color. Alright, that's kind of like the data structure for now what we're gonna do after this, after we update our locked positions, and we add positions to it, we're gonna say current piece equals next piece. Okay, so we're just gonna change that. And now since we've said, current piece now equal next piece, will we need to update next piece. So let's get a new shape, because we're just moving forward with the game. And now, of course, we got to say change piece equals false, because we're on to a new piece that's going to spawn at the top of the screen. Okay. And I think that is about it. What we also want to do actually, is we're going to check if we lost the game, and I think I do this after draw window. I don't think it really matters. But we're gonna say if check last, based on what do you call it locked positions? Okay, so these are all the positions of the shapes, then we're going to say run is equal to false. And that's going to break us out of this wall up. And you know what, while we're here, let's indent out and uninstall pygame. dot. What is it, I think it's display dot quit or something. Yeah, display dot quit. So we're actually just exiting out of our game. Now, up until this point, I actually have not tested my code. Now I know some of you probably think I'm insane. Because we've already written like 300 lines of code, we haven't tested any of it. The reason I haven't done this is because I wanted to test this in between videos, figure out what the errors were so that I didn't waste too much time fixing all of them. So I'm going to go through a few errors that we have now and show you what happens when I run the code. So I'm just going to delete that because that was the fix that I made. And pretty much you can see a big crash right away. And we actually get a four Iron Range, none type has no length. Now the reason we get this, and this happens down in the main is because in convert shape format, somehow I managed to forget to return positions. So this is really important because the whole goal of this function well was to generate this list of positions. And we did that fine, but we forgot to return them. So pretty easy error to fix or return positions. Now, again, we run this like okay, everything looks good. Now, there's another issue, right? So just watch. If I try to go off the screen, you can see that we get a unsupported operand for current piece, because I forgot to put a y or an x here. So let's go down to main, let's fix this. What line are we on? 262 262 current piece dot x. Yeah, that would be important. Okay. Now I know there's a few other errors. So this one current piece minus equals, let's change this to an X. Current piece minus equals, wow, I really messed up on this a lot. Okay. dot rotation, minus equal one. Okay, so this is rotation. And let's see anything else? Let's run the program. See, okay, we're getting another issue here. So if we have valid space, okay, so I just messed up and a bracket here. So let's go line 265. Here, so we're gonna take this quotation mark, or one of the same condition Mark bracket, and just put it there. And all should be good. Now, let's see, we go down to the bottom of the screen. Okay, we get another. And let's just play this for one sec, see if we can run into any errors. Okay, so we're rotating fine. We can't move off the screen. And all looks to be doing okay. Alright, so that's a good sign for now. Let's leave that. So it doesn't look like there's any issues. If you find any, I probably end up fixing them in future videos. So don't stress about it. Okay. So now that we've done all this, what we need to do next is a few things. Alright. So we need to deal with this draw next shape, clear rows, draw text, middle, what are their functions, so I think that's about it. And we're also going to deal with Main Menu, kind of starting the game, finishing the game, and all that stuff. So what I first want to do actually, is I want to deal with draw neck shape. And then I'm going to do clear rows just because clear rows is kind of complicated. So draw next shape. What this is going to do is it's just going to draw the next shape kind of off the screen and show us what it is because in Tetris It shows you like the next shape the next few shapes. So yeah, now this seems pretty straightforward, like just draw the shape. It's actually kind of long because we have to, once again, get this list, turn it into positions that we can use. And yeah, it just it gets a bit complicated. So what we're gonna do is we're also gonna set up a font in here, we're gonna say font equals pi game dot fonts dot s, why is font. Here, we're gonna do Comic Sans again, because you guys know I love Comic Sans. Comic Sans sighs stick 30. And let's render this font. Okay, so label equals font dot render, text for this is going to be next shape. Okay, feel free to add a colon or something if you guys want anti aliasing, one, text color white to fit fatty food factory gate, basically already been through that. Okay. Now we need to figure out where we're going to draw this, this label. Okay, so let's do the same thing we've done before we say s x is equal to top left x plus the play width. And then we're gonna say s y is equal to top left y plus the play underscore heights actually won't play 100 we're gonna say play height, divided by two. Okay, now what we're gonna do is this is going to give us like, to the right, maybe I can just run this and show you guys, it's gonna give us where my mouse is right here, like a position kind of similar to here. So we are actually here. So what we want to do is we want to add a constant to this, so we move to the right of it. So this constant, we're just gonna hard code in. And we can change this and play with it, if we want it to be like move more to the right or more to the left. So to move more to the right, we're gonna add 50. And then to kind of make this look a little bit better, which can actually subtract the 100 from the site. So we can move a bit higher up on the screen playing with these constants if you guys want it to look a bit different. Okay, so now we've got that, what we're going to do is, we're going to once again, we're going to format written say format is equal to shape, dot shape. And same thing, we need the actual shape. So not just like that main list, its shape dot rotation, modulus, the length of shape, dot shape like that. Okay, so this is the exact same thing that we did in format, whatever it goes out, yes. Know what function I'm talking about. And I've lost myself here, okay, just to get the actual like, sublist that we need. Okay, so now, you might say, Well, what are you? What are you doing here, we already have like a function that does this for us. Don't worry about it, just follow along. Because this is a bit different. The way that I'm going to do in case I'm gonna say four, I call them a line in a numerate. All right, and then row four, actually, format, sorry, I'm gonna do the same thing here, we're gonna convert row ID into list is really similar to the other function, except we're gonna do one major change. And you'll see that for row equals list line, we're gonna say for j, comma, what do you want to call it calm in a numerate row this time, and exact same condition, if column equals equals zero, what we're going to do here, instead of adding some position to list, we're gonna draw something. And this is why I didn't want to use the other function that gives us list of positions because I don't care about the position within the grid, I just care when we should draw something or not, because this doesn't matter, it's not going to be moving, we just want to draw like a constant image on the right side of this static image on the right side of the screen that we can just look at. Okay. So what we do here is we're going to say pygame dot draw dot rect. So dot draw dot rect. And each surface we pass the surface in, in each color, that's going to be the shape color. Okay, and then we need our position to draw sx. And then in this case, we're gonna have to do since we're drawing each cube, great, we're not just drawing the whole shape, plus j multiplied by 30. And then we're gonna do same thing with y. So s y, plus i multiplied by 30. And we actually just change this to let's change the block size to be a bit more dynamic. Okay, so it's a 30 block size, just in case we decide to change the dimensions of our screen later on. And then we new width and height, and that is going to be block size and block size and we want this filled in so comma, zero. Okay, so what we've done here is really similar to what we've already done. We're just going to be drawing these blocks according to where they show up like in this list, based on initial exposition plus, like a changed kind of position or whatever. Okay. Anyways, I think that's about it for this. Oh, we need to actually complete the label now. So we created this labeled we have actually drawn on the screen. Yep. So let's do this. As we say surface dot, Blitz. Label changes to period. Okay. Then we need to position what's their position going to be? Well, we're actually just gonna do sx plus 10 and s y minus 30. Okay? Again, play around with these constants, guys, if you want your thing to look a bit different, be more centered, whatever. I again, I don't go like too crazy on cosmetics here. I just want everything to work and look decent. I assume you guys can mess around with it. All right. Okay, so now we've done that we've drawn the next shape, well, we actually need to call this function. So within draw window, we're going to call draw next shape, as well. So where should we call this? Let's see what's called before we draw a grid, draw next shape, or actually can't call them here, where we need to call this as in the main because we only have next shape within the main symbol. Right? When we're drawing draw window, we're actually just going to call draw next shape. Because we need to give it the next shape. So it's going to be next piece. And then the grid does, it takes it takes a surface surface. Okay, so let me just go check this to make sure our surface is not cold surface. It's called wind. Okay, so in draw neck shape, you have a shape and surface case. So that that should work fine. You know what, let's actually test this now and see this working. And we're not showing up, we're not drawing this surface. I believe it is because Joe, when adrenix. Okay, so we need to do actually, this draw next shape, we're gonna draw after Joe and no, and we're just gonna update the display in here. So pygame dot display dot update. And then if we go to draw window, just remove this display update, and this should work. There we go. So now we're getting neck shape. On the side, the reason I wasn't working is because we're pretty much drawn overtop of the next shape, every time that we drew the window. So now that's working fine. We have our next shape showing up. And what else do we need to do? I'm really delaying trying to go to this clear rows function, because it's really complicated, but I think we're gonna have to do this next. Okay. So clear rows in Tetris. Obviously, if we create a full row, we need to clear that row. And then so that's the only way the user can win, obviously, yeah. So way to do this is probably a lot easier than the way I'm going to do it, but try to follow along, because this is the only way I could kind of get to work. And this is probably the hardest part of the actual game. Okay, so we're going to take grid, and we're going to take locked positions. And what we're gonna do is we're gonna set up a few things here, just follow along with me, I'll try to explain as I go, so when I say Inc, which is an increment zero, for I, in range, the length of grid, negative one, negative one, okay, and we're actually just going to subtract one from this to, what this is going to do is go loop through our grid backwards, so it's gonna start at the 20th row, and it's gonna move up to the 19 through, Okay, I'm gonna say the current row is equal to grid I. Alright, and we're gonna say, if the color 000 is not in our row, let's clear. Okay, so we're gonna add one to Inc. Don't worry, I'm gonna explain this after I just fall on, say ID equals I am going to say, for j in range, the length of row, what we're gonna do is we're gonna try to delete, locked, square brackets, current position, which can be JDI. And then if this doesn't work, then accept. And continue. Okay. Okay, so let's just talk about what I just did here, because I kind of went fast. And there's another part of this function door. So the way this is gonna work, is we're gonna say, we're gonna loop through the grid backwards, we're gonna set row equal to every walbro in our grid. So we're looping through. And the way that we know if the row should be cleared is if 000 doesn't exist, because if 000 doesn't exist, that means there's no plaque squares in our row, which means it's completely filled with shapes are completely filled with cube objects or whatever. Okay, so we know we can clear it. So the way to clear it now. And don't worry about these variables, we'll talk about that in a second is to get every position in that room. To do that mean to loop through j in the row. And we're already at the current row. So we know that I just gonna stay static change j and try to delete this from locked positions, because now what we're doing is the lock positions need to be removed. So when we dealt with these, since locked position is a dictionary, it's mutable, we can actually just change it within here. And that's how we delete those keys and those colors from the grid. Okay, so after we've delete that, all we need to do is we need to shift every row. So what's happening now and I think I'm actually just going to pull out a little, I have a drawing tablet and just start using this to kind of explain some things because it's pretty complex. So just give me one second Alright, so what we need to do is we need to shift every row. So if we delete, like, the bottom row in every row above that row needs to move down by one. So if I go to, let's see this, and delete this, okay, so you can see if I have a grid. Alright, and it looks something like this, we're just gonna do like a very basic like three by three grid. Okay, just to save us some time. Let's say that we want to clear this row down here. So these are full of colors, right? So if we clear this row, and then what happens is we get rid of all these and that any positions that were above it, so let's draw something like this. Now, this is here. Well, currently, this is floating, right? Because if we've cleared all these positions down here, so we got rid of those, this is floating. So this needs to move down one. So how can we go about doing that. And the thing is, every other row needs to shift down by one as well. But now let's talk about like a potential issue we might run into. So if I delete all that, and let's say we have a grid that looks like this, okay. And there's a color here. If we delete this row, the grid actually now in our memory, only looks like this. Alright, it's only this top portion. Because we've deleted an entire row out of the grid. So yeah, we can shift everything down by one. But now we're left with the grid, that's one less than the other one. So what we want to do is we need to add another row at the top here, so that our grid stays the same size. Because if you delete an entire row, well, you're deleting row, right? So you need to add back the other positions at the top, because everything's shifting down by one. So really, the way it works is you delete this, and then this whole thing moves down, and then you add a row up top like this. Okay, so that you're back to your continual grid. I hope that makes sense. That's kind of the only way I can really explain it to you guys, in terms of how we shift things, and I'm going to do it in code, right? Okay. So leave a comment if you guys are confused about that, because I'll try to explain it in a better way. But it's just kind of like a confusing topic in general. Okay, so now what we're gonna do when I say if IMC is greater than zero, okay, we're going to say, so this means that we've shifted, and we've removed at least one row, and I'll talk about the case in which we move to Rosa one second, okay, let's say for key in and just follow it this is, this is gonna be kind of confusing. List of locked positions. So locked, because we just, we just pass in locked there, okay. And then you say key equals lambda lamda. I'll explain what this does in a second. x, x one. And I think that's about it. And we're actually just gonna reverse this negative one. Okay. So, for every key in our sorted list of locked positions, based on the y value, is what this does. So given a list that looks like this, if you have like 0100. Okay, given this a very basic list, this could be an example of locked positions list, okay? What we're gonna do is we're gonna sort this list, and the way we sorted is based on this number here, this y value, and this is what this key equals lambda x x one does. Don't have to understand that this is just really kind of complex way to sort of list. What we're gonna do is we're gonna now make it looked like this 0001. And the way we do that is that we get all the positions that have the same y value in like the correct order. Okay? And you'll see why we need that when we start coding, okay, so I'm gonna say x, y equals key because again, remember, key is a tupple. And we're gonna say, if y is less than ind, we're gonna say, new key is equal to x comma y plus IMC and then locked. New key equals locked dot pop key. Okay, let's, let's dissect this now, right? Because this is, I told you guys, this was kind of confusing. So what we're doing now, if we want to shift every single position in the grid down, because when we delete a row, everything above that needs to move down. So the first part is pretty straightforward. Okay, so x, y equals keys, we're simply getting the x&y position of each key in locked positions. And remember, lock positions has a key and then corresponding with that is, okay, straightforward. Now, what we're gonna do is we're gonna say, if y is less than IMT, what that means is if y is if the y value of our key is above the current index of the row that we removed. So if we remove for example, row 17, then only things that are above that are gonna move down. We don't need to move anything below row 17 down because we didn't remove anything after row 17. Right. I mean, shows us an intro in just a second. Okay, so with that happen, In this, what we're gonna do is we're gonna change a key, we're going to get a new key, let's say it equals current x value, but we're going to increment this by a certain value, so we're going to add a head to the y value to shift it down. And then we're going to do is we're going to rewrite, we're going to create a new key in locked position, which can have the same color value as the last key, B, and this will, this gives us the last current color value, but it's equal to this position, right? So I'll explain why this works now kind of withdrawing, and why I needed to look at this backwards, okay? Because when we're looking at from bottom to top, there's, there's a reason for that. Alright, and I might butcher the explanation, but just kind of bear with me here for a second because this is important understand why this works. And this is the most complex thing. And this is actually very useful, you might want to use this a lot like shifting positions in a dictionary or in a list. Okay, so if I go back to my little drawing thing here, I go like this. Okay, so let's create a grid over here. Let's make it a few more rows this time just for a better explanation. So 1234, okay, make it a four by four. And you guys can see my fancy drawing skills. Let's make this a row. So let's say we have a row like this guy, so it's green, make orange. Orange didn't work. So green can say they're orange, like this, like this. And like this, and then we'll add some more colors. Let's do like blue. Up here, and up here. Okay. So obviously, this is the row that needs to be cleared that my mouse is going over right now. Okay, so this is the row that needs to be cleared. What happens when we clear this row? Okay, so we've looked from the bottom of the list up, and we found if we're looking at row like four, now looking at row three, we say row three needs to be clear. Okay, so it's cleared. So we delete everything out of row three, right? This row is now gone. So our grid in memory just looks like this. And this. So what we need to do now seem to shift these positions down. But we don't want to shift these positions. So that's why we're getting that ind. So we know which position positions in our grid to shift. So we delete that row. And then what we're doing is we're adding one and shifting all these positions down. Okay, that's a straightforward example. Let's get rid of this. And let's do this. Okay, so let's say when we add our, I don't know shape, whatever to our grid, we end up getting something that looks like this. Okay, two rows that need to be shifted down. Now what we have to do is we have to delete this row and this row. Now here's the thing, we delete this row, we delete this row, how many rows is this now needs to move down? Well, this needs to move down to rows. So how do we know how many rows to move this down? How many rows and everything else above it down? Well, that is based on our What do you call it increment here. And that's why whenever we delete a row, we add one to increment, because we know that we have to now shifted down another row. Okay. And that's kind of the way that this works, if that makes sense. Now, the reason that we go through and we look at things backwards is we don't overwrite existing rows. Now, this is another complex thing, okay. You probably don't have to really understand this that much. But anyway, okay, so let's just say it's not going to let me undo. Okay, that's fine. So we have this right. Now, here's the thing, we started looking at it from the top down to the bottom, what would happen is, we would so let's actually have to add another row for this example. That makes sense. So if I add another row, and I say, Well, okay, let's add a color. Let's pick yellow, right? Let's say we have a position here. And we have a position here, right? So that means this position, this position, and this position only to move down. So here's the thing, if I move this one down by two, alright, or if I move it down by one, or whatever, it could possibly overwrite this existing position. And we don't want that to happen. So what why we have to start looking at it from the bottom is that when we start moving everything down, we move the lowest most things down first, so that way, when we then change this, there's no possible way we're gonna overwrite this right here. Okay? Because remember, if you in a dictionary, if you change a key and the key already exists, will you're just gonna overwrite that key. So that's what we start looking at it from the bottom. If that doesn't make sense, don't worry, just, that's for any of you. That's why okay, because I want to make sure I explain everything and you guys understand, at least on some level, why I'm doing what I'm doing. Okay. So that's it for the explanation of clear rows. Now, let's call it function. So when are we going to call clear rows. Now this is actually an interesting call. We could call this function, every loop. But we're only going to call this when our change piece hits the ground. Now the reason for this is because you could possibly be moving On the screen, and at some point, the grid would have a full row before your shape actually hit the ground. Now we obviously know the way in Tetris, when you're moving down the grid until you like land or you stay static, we're not clearing anything. So that's why we're only going to call this if we are about to change the piece. So clear rows, what is clear rows take again, I would say it probably takes grid in locked positions, maybe, yeah, grid and locked positions. Okay, so passive, the grid will pass it block positions. Okay. So then we're checking whenever we're changing the piece, if we should clear a row, and this can clear multiple rows at once. Okay, I'm going to be showing you guys a few different things. So in the last video, I mentioned, I was going to be doing more cosmetic stuff. So that is true. In this video, I'm going to be showing you how to do the main menu screen how to draw text in the middle the screen, how to make things look a little bit better. And I'm also gonna be adding a little bit of functionality to the game, in terms of making the piece fall faster as it moves, or as time moves forward. So obviously, you want the game to get more difficult as time goes on. So what we're going to do to do that is increase the speed at which the piece falls on the screen, it's pretty easy, I'll show you how to do that, I'm going to be adding score, and we're going to be displaying that score. And that's probably about it for this game. So the first thing I want to show you is how to add the piece falling faster. So to do this, we need to create a variable in our main here. And I'm just gonna make this equal to what do you want to say, fall or let's say level, underscore time, okay. And this is gonna just represent how much time has passed. And it's gonna be similar to full time and levels, just because as we increase speed, like the level is going up, kind of whatever, okay, so say level time plus equals clock dot get underscore raw time, and we're gonna do exactly what we did with making the piece move down the screen, except we're just gonna change the speed at which it moves down the screen. So what I'm going to do here is when I'm making the if statement, I'm simply gonna say if level underscore time divided by 1000 is greater than, and then you can put in whatever time you want here. Now I'm going to do five seconds. So every five seconds, we increase the speed, okay. And then we can decide what we want to increase the speed by. So I'm going to say level underscore time, we need to first reset this back to zero so that we continue to do this. And then what I'm going to actually do here is going to say, if level, underscore time is greater than, and we want to put like a terminal velocity here. So at what speed do we stop increasing the time because we obviously we can't get to a negative false speed, otherwise, you're just going to instantly fall. And we don't want it to get too fast that the game is unplayable. So we need to pick a speed. Now a good speed that I kind of found was 0.12. Because anything faster than that is like pretty fast. But I mean, you guys can play with that and change that around, it's really easy number just fix right. And then if we're greater than that, we're just simply going to subtract a value from level underscore time. Now this value, the magnitude to the size of this value that you're subtracting is going to determine like how quickly you increase the speed as well as obviously the time. So I put originally 0.01. And I mean, depending on how long it takes you to play a Tetris game, this is pretty fast, because that means after 50 seconds, you're already going to be down to 0.17, which is very quick and almost a terminal velocity. So I recommend you do 0.005. That means it'll take about a minute and 40 seconds before, you're going to be close to reaching this terminal velocity, which might be good if you're playing Tetris for a decent time. Okay, so you guys can play with those numbers. But that is he is going to move it down faster, I would show you but it's going to take like a decent amount of time for it to continue moving faster to just play with that. Okay, just trust me. All right, the next thing we want to do is add score. So we need to first create a score variable and as a score is equal to zero like that. an incorrect score is pretty simple, I'm going to say and you guys can make this whatever you want. Whenever we clear a row, I'm going to add 10 to our score, because you had 10 pieces or 10 cubes or whatever that you cleared. Okay, so actually, the way that we need to do this is we're gonna return a value from clear rows, which is going to be equal to score. Now I'm going to go to clear rows, and in here, I'm simply just going to return I NC, okay. And I NC is the increments, so how many rows that we actually ended up clearing. So if we clear the one row, we're going to get a value of two, we can multiply that by whatever our score increments going to be. And then yeah, we can just add that to the score. So this is pretty straightforward. If we go to clear rows, we're gonna say score is equal to clear rows, multiplied by 10. All right, we're actually not equal to we're gonna have to say plus equal to clearos plus 10. Now what we need to do is we need to display this score on the screen, somehow. The user can see that we're actually going to save the score as well when we lose the game. Okay, so the way that we can display this is we're gonna have to do the intro window, but we're gonna have to pass the score to draw into. So after our grid object, we're going to pass score like that. And we're going to go to draw window. And we're simply going to add another parameter here score like that. Now I'm just gonna set it equal to zero as a default parameter. So in case we call it somewhere else, and we forget to add that score, that's fine, we don't need that. So what I'm going to do now is I'm actually going to go to draw next shape and draw next shape. You can see if I run the program quickly here, it shows us a little text object, okay? Now I want to get this similar text object. So I'm just going to copy this font, the label sx s, y. And I'm just going to bring it down here into draw window. Now it doesn't really matter where you draw it, I'm going to plop it in the middle here. And obviously, I'm going to change this from next shape to be score. Now we need to obviously display what the actual score is. So we can just say plus STr score, like that, and that should be displaying for us. Okay, so now we have s x and s y, which is giving us the play area, I believe we're no this is actually the position in which we want it to draw it. Okay, so what I'm going to do is I'm going to say now when dot Blitz, or is it surface surface, Blitz, our text object, which is the label, and then where do we want to draw it to draw sx s y. Now, I'm just going to have a look up here to see where I did it here. So that's x plus 10, s y minus 30. So what I might want to do is, we can add plus time to this, so it's aligned, but then we're gonna subtract, or actually add to the y, so it's lower. So I'm going to add, let's say like 80. Like that. So let's test this out and see if it's working. Score, so it's not low enough. So we'll add this and do 120. And see where we're getting enough score. Again, not low enough. Let's go 160. And again, you guys can play with these, our score equals zero, perfect. And then maybe we'll just add 10 more pixels here. So it's more in the center. And you know, whatever, that's good enough for me. Okay. Good. So that is working well. So we've got the score, and we're moving down faster. Now, what else do we need to do? What we need to do now is work in main menu and figure out what happens when we actually lose the game. So we have this check last, and all this simply does is just quit the game for us when that happens. But we want to do something else when we lose, and we want to display something to the screen. So actually, before I go on Main Menu, I'm going to go up here to a function that I told you guys, I need to get rid of that, that I was going to finish, which is draw text in middle. Now this is going to take a surface text. And what else do we want, say size and color. Okay, so surface text size color, this way, you can use this in another function or sorry, in another program, and you can use them multiple times with whatever text size and color you want. So we're going to set up a font and say font equals pi game, dot font dot s, y s followed by now you probably know this, I'm just gonna pick Comic Sans, we're gonna make it equal to size and bold is going to be equal to true. Now, you can make this false if you want, or just omit it completely, and then it won't make it bold, pretty straightforward. Make a label label is equal to again, font dot render. And then we're gonna say text, one for anti aliasing and color, like this. Okay, now we'll just simply draw this in the middle of the screen. So to do this, we'll say surface uplit. label, comma, and now we're just gonna do a little bit of math here. So top underscore, left, underscore x plus play underscore width divided by two, not three minus, and we're gonna get the label width. And the way we do this, I don't believe I've actually done this yet, is get underscore width, I think I'm just gonna check Yeah, get width. And then the reason I have this in brackets, because I'm going to divide this by two as well. And this will essentially give us the middle position where we should be drawing in terms of x squared, okay, so now I'm going to give top underscore left y plus play underscore height divided by two. Okay, and now same thing minus label dot get underscore height in brackets and divided by two. I don't know why kids tab over here, okay. divided by two. And that should hopefully be working for us. Okay, so we can test that in just a second. So we've got this, it's bleeding now, whatever text we want to the screen. So this makes it really easy for us to draw anything to the middle of the screen. So the first thing I want to draw to the middle of the screen is like a you lost message. So when it says you've lost, what I want to do is draw obviously, you lost and tell them so let's say draw, text, the middle. And then what do we want to draw? Well, let's simply draw what surface first actually that we need. So we'll say when And then we're going to pass it text. And in this case, we're gonna say you lost exclamation point, size. Let's go for AV, and color. Let's go white. And obviously, you guys can play around with that. Now after I draw that, and I display the screen, or update the screen, pi game dot display dot update, just because we haven't called the window yet, draw window when we do this, then what we're going to do is we're just going to delay, so we're gonna say pi game dot time dot delay. And I'm just gonna delay one and a half seconds, just so once this comes up, the user has a second to look at it, because then we're gonna move back into our main menu screen, which you'll see. Okay, so I'm just gonna fast forward this until I lose, and then you guys can see that it's working. And there we go. So we got you lost, and then it delayed, and then just quit because I have this pygame dot display dot quit here. Okay. So now what we're going to move to his main menu, everything else is working. I told you guys snot, like super difficult. While this stuff in main menu, what we're going to do now is we're just going to make it pop up whenever you start the game. And whenever you lose, it's just going to say hit any key to, like, move forward to continue. Okay, so once you set another game loop in here, so we're gonna say run equals true. Well run, and this is gonna be really similar to the loop we've done above, it's just step just a lot shorter, we're, and we're going to just draw in here, without using a different function, just because we're not drawing very much. So it's not important that we would call it like, update the screen with a defined function. So I'm just gonna fill it with blocks, we cover getting rid of everything, we're gonna draw text middle. And what I'm going to do here is I'm gonna say press any key to play, okay. And then we'll give this a size of 60, and a color of white once again. Okay, so that's being drawn in the middle, we'll update the display, so pygame dot display dot update, like that. And then we're gonna say, for event in PI game, dot event tickets are similar to what we've already typed up top, we're going to say, if event dot type equals equals pi, game dot quit, we always want one of these, not quit Q, then we're simply going to say run. Oops, run is equal to false. And then we can tab out here, and we can just make sure that we are actually quitting the display. So dot quit. And we'll get rid of this pygame dot display dot quit. And then we're gonna add one more event, and this event is going to be a key down. So whenever they press any key on the keyboard, then that is going to move this forward. And we're simply going to call this main function where we'll play and I'll explain how this kind of flows in just a second because it's really nice. Okay, so if event dot type equals equals pi, game dot, all capitals, key down, so if they hit any key, then what we're gonna do is we're gonna say main, like that. Okay? And I believe that is about it. Okay, yeah. So let's see here. pygame dot display quit, looks correct. Okay. So the way this is gonna work pretty much is when we run the game, we start by running main menu. So we run main menu, and then we go into this main loop, where all its gonna do is just say press any key to play, and that's going to be drawn in the middle of the screen. Once that happens, we're going to check if they're hitting any key, if they hit any key, we're going to call mate, in which case, or let me close this, so it's easier to see. If we hit main, then we go into the main game loop, and we go in, we do this loop until eventually we lose. Once we lose, it displays you lost on the screen, makes this loop equal to false, which means it brings us back into this main menu loop. And we can play again by hitting any key. Pretty straightforward. Okay, so let's test this out to make sure this is working. Draw text missing one potential argument color. Because I didn't give a surface My bad. So let's just do win. And there we go. Okay, so press any key to play. Press space missing one, mate. Sorry, guys. So this is why we tested Perfect. Okay, when. And now let's try. There we go. And now we're playing shows the score, and you guys can mess around, I haven't actually tested the score. So I'll just do this really quickly and see if I can clear row without having to fast forward. Which we may be able to do not using that one. Okay, let's see. There we go. And score is equal to 10. So the score system is working as well. And that's relief, because I hadn't even tested that before I put this in the video. Okay, perfect. Oh, when you press the X brings you to press any key to play. If you press it again, you can do that. So if we wanted to change it, so when you hit the X key in the main thing, and you want to close the game, then in the main loop here, sorry, what are you going to do instead of saying runnicles false just to high game. Display dot quit. So you can do both the and say run equals false and then you can quit the display as well. Okay, so what's next? So I said we were going to save the score and potentially display that So if we want to save the score, we're gonna have to do something when we lose, so we're gonna have to update, like the current score. And we're gonna use a text file to do this so that you can play multiple times. So what I'm gonna do, I'm gonna say new file, to create a new text file, I'm just gonna call this scores dot txt. Okay, and here, I'm just gonna put zero as a default value, it's really important you put a default value to start, otherwise, you might run into some issues. So just create a new text file, make sure it's in your directory with the mean, with the script, okay? Now, what I'm gonna do is I'm going to create another function doesn't really matter where it goes from, say, define, update underscore score, and we're going to give it score. Okay? Now and here, what I'm going to do is I'm going to say, with open, and this is how we're going to open our text file and like update and display with open scores dot txt, in our so in read mode, and this action needs to be in quotation marks as well, we're going to say, F, F, do this as f sorry, say F dot read lines like this, okay. And that'll be equal to lines, is equal to F dot read lines. So that means our score is going to be, well, the first line, so score is equal to lines, zero. And we're gonna add this dot strip, so that we remove any like backslash ends, because if you don't know, in a text file, when you hit the next line, the way that it actually tracks that you have another line is it puts a character that looks like this, on the line, it's invisible to you in the text file when you're viewing it. But when you read it in with code, you're actually reading this character. So we just want to make sure we strip that off, in case it is there. We're gonna say score equals this, and then we'll just set Okay, so we've done that. And since we're tabbing out now, it'll, it's going to automatically close our file, what we're going to do now is we're going to open the file again, except in this time, we're gonna open it right mode, which means we're going to overwrite whatever is in the file. And we're simply gonna say, if score is, I guess I'm gonna change this to and score standing for new score, if score is greater than n score, then we'll say F dot, and we'll say write lines, actually, right, I think, and we'll simply put in str of score, which is this update score, otherwise, so if that's not true, we just have to write back the other score, because we're clearing it when we open this with w mode. Okay, so we're gonna say F dot write, and then we're sorry, this is gonna be limiting, and n square. Yeah, sorry. So I kind of messed up in this way, it should be the other way around. But whatever. We're just checking if the original score is greater than the new score, if it is, we'll write the original score, otherwise, we'll write the new score. So this works still, it just not the way that I was thinking about it when I was kind of talking about that. Okay, so update score should work. And then you can actually return, let's just return actually, now we don't need to return anything. So I haven't pre written this yet. So I'm kind of still just going through how I want it to work. Okay. All we'll do here, after we start running equal to false, we'll say update score, and we'll give it whatever the current score is. And then it should be working in the scores dot txt file. So let's run this. I'll fast forward through and make sure everything's working. Okay, so we go they're not supported between insists of string and int, okay, so if score greater than sports, which means we have to convert the student. So if we go back up to score, and where did I make this, okay? Score is going to be int score, like that. Okay. And that should hopefully work because n score comes in as an int. And we'll run a one time one more fast forward. Sorry about that, guys. Okay, and another issue lines, zero, Linda, list index out of range. Okay, I'm gonna have a look at this and come back. Okay, so this code is actually working just fine. The issue was that since last time, when it crashed, we didn't end up writing anything into the file. So we had a blank file, and then we were going lines zero, where is it here, and obviously, there was no line zero, so that crashed. But if you just add any numbers like that, add zero back in here, two squares dot txt and save it, then this works fine. Okay, so that's it for saving scores. Now we need to display those same scores. So I'm coming in to leave this up to you guys where you want to display it, I don't really know where I want to put my same score, like high score, maybe on the left side of the screen. Doesn't really matter. So if I want to draw it on the left side of the screen, then I can do something like, we're gonna have to first get this max score, right? So I'm gonna have to make a new function called define, Max score, or last score, whatever you want to call it. And if you call max score, what we're gonna do is we're just gonna do the exact same thing we did here. So we can say with open source text, source zero slot zero dot strip, except in this time, we're going to return a score like that. Okay? Now, we actually do here too is we can just simply replace this whole line with Max score and just say, score equals max score. really efficient way to do it. And I mean, feel free to do that if you want or leave it the other way. Okay, so now we have something that's getting us back score. So how are we going to use this? Well, when we call mean, I guess when we call me or we can call Main Menu does it like you guys, if you want to draw it on the main menu, you can do that otherwise, straw didn't mean to draw it in the main, all you're gonna do is gonna say like last score is equal to max score, which is going to be whatever it is stored in that text file. And then to draw this old, we're gonna have to pass this again, into when we're redrawn window. So in draw window, I'm just gonna say, last score, we can go up to draw window again, say, last underscore score equals zero. And you're pretty much gonna copy exactly what we have here, with this font, and the split. So let me just call it out this and say, This is correct score. So I remember, you had a comment, say, last score, high score, whatever you want to say here. And then we can just say score. And we can actually get rid of this font, because we already defined it will say, high score equals, and in this case, last underscore score, okay? Draw that to the screen, this is probably not where you want to draw it, you probably want to draw it, top left x, minus, like some value minus 30, top left y, maybe Plus, I don't know, like 300, or something. So now we can see where this is actually going to draw if we check this out. So let's run this, press any key. So it's not obviously showing up where we want to, we're gonna have to subtract more from this. So let's subtract like, I don't know 100. And then this was plus too much c plus 200. And high score. So again, like you got to move it over more. So we'll move over 200 this time, and hopefully this works. Okay, so high score zero score zero. And that's obviously because at the current moment, we have no, or our score is just zero in that text file. Okay, so I think that is pretty much it for this video. So essentially, this is online game development with Python, which means we're going to be using sockets and networking to connect what's known as a client and a server or multiple clients to a server, where they can send and share information. And therefore we can create an online game. So we're going to start off with just the absolute basics and just get shapes. For example, like if I move a shape on my computer, it moves a shape on your computer, like if you're the other client, and then we'll start getting into some more advanced stuff where we create a legitimate game and start sending massive amounts of information to the server, and back to the client. So we'll start really simply by just getting everything working on our local network. And then once it's working on our local network, we'll deploy that to an external server, which will allow us to play from anywhere in the world, not just against people on our local network. Okay, so what I'm showing you right now is actually an online game that I created with Python pi game and networking. And this is similar, something we're gonna make obviously not as advanced, but it works on the same principles. So essentially, I have what is known as two clients. Now if you don't know, the way that any online game works is we have multiple clients connecting to one main location, which is known as a server. Now right here on my screen, we have two clients. So this client on the left that my mouse is kind of going over that has this red highlight the way the rook is, or where I just didn't vote to move this night is client one, and then this block one over here. So like your block, where I just moved this pawn is client two. Now you can see in the background, I have this command line thing going and it's sending and receiving information. And this is essentially how a online game works. And you might see, whatever you guys playing online game, it says waiting for server we're connecting to server. And that's because it's doing exactly that. It's waiting to get a connection to the server and then grab information from that. So that's the way that we're going to be doing things is using the client and server. Now I'm not going to be using any frameworks that are pre created, like, I know there's like twisted and some other frameworks for Python, the only module we're going to be using the external is pi game and that's just to create some very basic graphics. Okay, so let's close this, I just want to give you guys an example of what an online game looks like. And you could see when I was moving something on one client, it would move it on the other. So let's close that up. And let's actually get started with the tutorial did not mean to open up. So I'm going to be working with PI charm for this tutorial. Now if you don't know what pi charm is, it's an ID. To download it. All you have to do is just go to the internet. Type pi charm. And you can go here and click Download whenever it loads up. Now, if you guys don't want to use PI charm, that's absolutely fine. You can do everything using the standard editor like ideally you can use atom, Muse, whatever you want. But if you want to follow exactly what the tutorial I'm going to be using pi charm. Now the next thing we're going to need other than it, I guess you don't need pi charm is we're going to have to install pi game. Now for 90% of you, the way that you're going to be able to install pi game is just by going to command prompt, loading it up like this and just typing pip install pi game, and then hitting Enter. Now, if this doesn't work for you, I'll put a card in the top right hand corner of the screen right now, which tells you where you can go to install pi game. And I have a video explaining you exactly how to do this. And if this command doesn't work for you can follow that video, and I'll explain to you how to do that. So once we have pygame, then we're ready to actually start writing a bit of code. So while I launch up pi charm right here and create a new project, let me just tell you about, I don't know some of the things we'll be going through in this tutorial series. So obviously, we're going to be working on coding both a client and a server. And I'm going to explain obviously, exactly how those things work, and how we can create them. And then what we're going to be doing is we're going to be dealing with a bit of server like administration, if you want to say that. So actually deploying things to an external server, stalling in pen, installing dependencies, working with like a Linux server to deploy our game to and that will be at the end of the series that we do that right now we're just gonna be working with what's known as local host, which means that we're just gonna be doing it on our own network. So right now, the games that we create are only going to work on our, what do you call it against people that are on our Wi Fi or on the same network as us, and then later, it'll work against anyone in the world that has that client downloaded? Okay, so let's just create a new project here, my new project, I'm just gonna say is tutorial, let's say network tutorial waters. And just as a, what do you call it here, just letting you guys know, I did actually mess up my thumb a little bit. It's kind of swan. So if my typing is not the best, that is actually my excuse for that. So now that I've got a new project opened, I'm just gonna create a new Python file. Let's call this tutorial. One, actually, let's call this client, okay. And just save that as okay, because that's all we're going to be coding in this video is just a very basic client. Okay, so now we've got client. So what I'm going to start off by doing is creating a configuration for my client. And keep in mind, if you guys are using something else, you don't have to worry about what I'm doing with this pie chart specifics. This just the way you have to set up a project in PI charm. So I'm just gonna set a client, I'm going to go to script path network game client. Okay, apply. Okay. Now, quick side note, all the code that I'm about to write is available on my website tech with Tim dotnet. Usually I have as well as that a text based tutorial version. I'm not sure if I'm gonna be able to write the text based tutorial. Well, this first tutorial is out. But you will see it on there at some point input tutorial import pi game. But yeah, all the code will be available on there in case you guys missed something or something's not working. So we're going to start by importing pi game and make sure that that's working. Once that's working, we're going to create a window. So to do that, we'll just say, when equals pi game, dot display dot update, or what am I saying pi game dot display dot set underscore cap set underscore mode. Wow, bit tired today guys. And then in here, which can type width, and height, and then we're going to create these variables. So say width equals 500. Height equals 500. Okay, so there we go with height when and now we're just gonna set up a few global variables we're gonna have to use after we create a caption, so let's just say login, dot display, dot set underscore caption. And then in here, we'll just go to caption, let's just say, client. Okay? Alright, so now let's set up a global variable that we're gonna use. And what we're gonna do for this global variables, it's gonna hold the current like clients, we're gonna say, like client number. I want to start by making that zero, but we're going to increment that based on like, once we connect to the server, which we'll do later. Okay, so now that we've done that, there's a few basic things. This is what we always do for like a PI game project or whatnot. I'm just gonna define redraw window. Okay, and in here, all we're going to do is just pi game dot display dot update, like that. And we'll also fill the display before we do that, oops, didn't mean to do that. With when dot fill, and it will just pick a color. In this case, I want to do whites which is 2552505255. Okay, now Yeah, I just realized this is actually gonna be a lot harder to type than I thought because my thumb so just excuse me guys, if I'm making a few mistakes here. Okay, so we got our redraw window now and what we can do next is We can code our main loop. So I'm going to say define main. And then here I'm just going to create a game loop. And this is going to run continuously while I program is going and it's just gonna be what's checking for collision checking for events can constantly asking the server for information, and you guys will see how this works in later videos more. So we're gonna say run equals true. And then here, we'll say well run. And we'll just set up some very basic things that we always do for pygame. So for event in PI game dot, event, dot get, okay. And then we're gonna do say, if event dot type equals equals pi game dot quit with all capitals, then we'll simply do pi game dot quit like that. Don't need a semicolon, I guess we can say run equals false as well. Okay, for events, that looks good. And then what else we'll do in here is we'll just call that redraw window function. So redraw window like that. Now, what I'm thinking we should do next is probably set up a class for our character, okay, now our character is going to be just the only object we're working with right now. And it's just going to represent like a rectangle that moves like left out up right around our screen. And I guess we'll do that all in this video moving that character around, and that will connect it to the server, the next one. So let's create a class. And we'll do that up here. And we'll say, class player like that. Okay, so we'll give it a knit function. If you guys don't know much about object oriented programming, and programming, and you want to learn, I do have a tutorial series on my channel that I would recommend you go through if you don't understand a lot of the stuff that I'm doing right now. Okay. So x, y width heights will be what we get in here, this is just going to represent, actually, let's give it a color as well, because it'll be good to have X, Y, width, height, color. And yeah, this will just represent kind of our player and what variables they're gonna have. So we'll pass these values in when we create an Eclair. So self dot y equals y. This is very straightforward. self dot width equals width, and self dot height, equals height. And finally, self dot color, equals color. So these are just our initialization here, this is what we're going to use when we're drawing the character when we're checking for collision or stuff like that. And what I'm also going to do to save us a bit of time in the future, I'm gonna say self dot rect equals and then in here, let's do this, okay, so x, y, width, height like that, okay. And this will just make it a bit faster when we're trying to draw our character. So the next thing we're gonna need is define draw. Now, in the draw method, here, we're going to take a window, so we'll call that when, and all we're going to do is just draw a rectangle that represents our character onto the screen, and obviously be the appropriate color. So to do that, all we have to do is just say, when.oh. No, we don't see that we have to pygame dot draw dot rect. standing for rectangle, we have to first give the window so we'll give when we need the color. So we'll do self dot color. And then we need a rect, which will be self dot rect. Okay, and that's actually all we need to do to draw the rectangle to the screen. Now we need one more method we're going to use and it's going to be called move. And move Actually, I believe, yeah, we don't need to do anything else in there. Right now as the argument sorry. So for move, what this is going to do, is it essentially just gonna check. What do you call it? If they press like left key, right key whatnot? How can we move them around the screen? So the way that we can do this really, basically, essentially is just do pygame. Dot, what do you call it dot keys, dot get underscore, pressed, I believe that's it might be key might be keys, we'll see. We'll see which one works. So this is essentially going to give us a list of all of the keys, actually a dictionary of all the keys. And essentially, each key is going to have a value of either zero or one. Now, if one is true, that means we're currently pressing the key, if zero is there, that means we're not pressing the key. So the way that this is useful, as opposed to doing what we could sometimes do, which is just check for events. And here is if you're pressing more than one key at once, it'll allow you to move like diagonally or whatnot. Okay, so what we can do in here now is we can just check if certain keys are pressed, and then change the x and y values accordingly. So we'll say if, what do you call it? Oh, I guess we should probably put this in a variable. Let's say keys equals pi game dot. Maybe I feel like it's key, we're gonna go key for pi game dot key, don't get on a script. So say if keys and then pi game, dot k underscore left standing for our left arrow key. And that's all we need to do for that one. And then we'll say if keys and then pi game dot k, underscore is this should this be all capitals, I think it should be k underscore, right. And then the next one, if keys, pi game dot k underscore up, and then our last one obviously is down. And then we'll change our values accordingly inside of these if statements, so pygame dot k underscore. Okay, so left right up, down. So if we press the left arrow key, obviously, we have to do a subtract from our x value. So to do that, we'll just say self dot x minus equals self dot Val. Now, Val is something we need to define. So let's do that up here, self dot Val equals, and let's do a value of like three for right now. Okay, so if we're going to write we need to add to our x, so we'll do this very similar. So self dot x plus plus equals self dot Val. Okay, if I could type that correctly, and then to go up, we're going to subtract from our y value, so self dot y minus equals self dot Val. And to go down, we'll do self dot y plus equals self dot Val. And that's the way the coordinate system works in pygame, our coordinates actually at the top left hand of our player or a screen, so if we want to go down, we have to add to it and then left and right is the same in terms of subtracting and adding, okay, so that should successfully move our player, we could add like a jump and stuff in here at another time. But for right now, that's all we need. I'm trying to think of anything else that we could do right? Now, we should probably create a player object and draw that to the screen just to make sure everything's working. So to do that, let's create a player. Should we do it up here, let's do it right above our main loop here. Okay. So we're just gonna say, actually, we'll do it inside the main that this will work better. We'll say p saying for player just equals player, and then we'll give it some values in x, y with high color. So for x, y, we'll just start them out like 5050. And then for width, let's just do 100 by 100. So he's nice and big, and we can see him and then we'll do a color of green. So that would be red, green, blue, like that. So 255, for green. And then what we're going to do actually, is we're gonna type in here, insert in redraw window, we're just going to pass p to our redraw window so that we can draw him. And before we do that, we'll call p dot move. And what this will do is move our character based on what keys we're pressing. So inside redraw window, let's add a player. What do you call it? argument attribute, whatever you want to call that. Sorry, parameter. That's the correct name. And then we'll just say player dot draw, like that. And we'll pass winning here, which probably should be passed in here as well, because we do use wind quite a bit. So let's do P. Let's do when and then. Okay, so let's run this now and see if I made any mistakes I likely did. Process finished, oh, we never calling the main function. So let's call this main function from down here. So we're actually executing that code that we wrote. And there we go. So now we have a little green square. And you can see, Hmm, interesting, it's not working for me to move this around. So let's check this one more time. P dot move, what is move doing get pressed. Let's just add, I want to add something here and make sure this is working. So let's, we're gonna say clock equals pi game. dot time, dot clock. Okay. And then in here, we're just gonna do clock, dot tick. And we'll do 60 FPS, I just want to see if this is working. If not, I do know how to fix this. Okay, so we're not able to actually move this. Oh, I know why. So very interesting. We are not updating this rect. But we are updating. What do you call it like, up, down, left, right. So at the bottom here, all we're gonna do is just redefine our rect by doing self dot x, self dot y, self dot width, and self dot height. Now I'll really quickly explain why this error was happening. Essentially, we're defining rect up here based on the input parameters when we're creating our player. So that means we're always just constantly drawing our rectangle in the same position, because we're never updating this rect variable, we're only updating like x, y, width, height, right. So we just have to redefine our rect variable every single time that we're moving, which is fine. And we can do that. So now let's see. And we can move our green square around the screen, I actually quite like the speed this movement. So yeah, so essentially, in the next video, we'll we're going to be doing it so I'm wrapping it up here is we'll add a little bit more to this client. And then we'll start working with sockets. So we can connect this up to a server. And we'll start talking about all the networking aspects. And then so in this tutorial, we're going to be working on coding the server. And then in the next video, we're going to be connecting this client that we made in the last one to that server and then sending information to and from the server. So let's get started. And let's create a new file that is going to be our server file. So I'll just call this one server.pi. And then in here, we're just gonna have to import a few things. I'll talk about exactly what they're gonna do for us once we start using them. So let's start by importing sockets, our socket, then we can import underscore thread and We'll also import OS. Okay, so actually not sorry. That's why Yes, that's all we need for that. So what we're going to be doing, like I've talked about is we're going to be using sockets and threading, to handle connections to our server. And essentially, what that means is we're going to set up a socket, and it's going to allow for connections to come into our server on a certain port. So we're gonna start by just defining server, which is going to be a string, and port, which is going to be a number. Now for port, you guys probably know what ports are, you might have heard of them before, for example, like a common port you would use on or common port that is used on your on your router would be Port 80. And that is for HTTP connections. There's also a port like 443, there's there's tons of other ports that have distinct uses. But there's also a ton of ports that don't have any uses and that are just left open for programs like this, or for different things to be used for. So what port I'm going to use, which is typically open, it depends on like what router you're using and your internet connection. But typically a port that's open is 5555. So we're going to use this port to connect to and from and it's just a safe port to use, as opposed to trying to use another number that we might not know if it's being used for something else or not. Okay, so once we've done that we've created a server and create a port we're going to do is we're going to set up what's known as a socket, okay, and we'll talk about exactly how this works in a second. But we're just gonna say s equals socket, dot socket. And then here, we're going to type something that's probably gonna mean nothing to you, but I'll talk about what it means. So we'll say, socket equals AF, underscore, eye net, okay. And then socket dot sock stream like that. All right. Now, these are just the types of connection. So since we're going to be connecting to a ipv4 address, which, again, we're gonna keep talking about all this stuff, as we go through in case you guys are unfamiliar with networks, this is the type we're gonna have to use and sock stream just I believe, represents, like how the server string comes in. I could be wrong on that. But this is the type we're gonna use. And for any kind of applications like this, this will be what you use for your socket. Okay, so we're just initializing that. And now the next thing to do is to bind our server and our port to the socket. So to do this, we need to do a try and accept. And the reason we do this is because like I talked about, we don't know if this is actually going to work on initially doing it, there could be in some instance, this port is already being used for something. And if that's happening, that means that this is going to fail. So we need to try and accept this. So it will accept, what do you call it? error as he said, when we say socket dot error, as he will just print that out to the screen, just so we know why we're not working there. Otherwise, what we'll do is we'll say s dot bind, and then in here, we're going to put server comma ports. Okay, so we'll bind to whatever IP address we'll put in here, to this given port. Okay, so I hope everything's making sense so far. Essentially, what we're doing when we do sockets, is we're setting up a connection or we're using a port on our server on our network, it's going to look for certain connections. And then we'll be doing this on the client side as well will be binding or not enough will be binding, we'll just be connecting to a certain server at a port. And then since we're connecting to that this server script that we're gonna have running will see that connection and handle it in some way. Okay, so now that we've done that, I'm trying to think what else we have to do. Okay, so what we're gonna start by doing is we're gonna start listening for connections. So we're gonna do s dot Listen, now. So listen, essentially just opened up the port. So now we can start connecting to it and having multiple clients connecting and whatnot. So in here, this actually takes one argument. Now it's optional. And if you leave it blank, it means it'll allow for unlimited connections to happen. Now, depending on what kind of program you're writing, is, what you're going to do for this now for me, I only want two people to be able to connect to my, what do you call it? Yeah, to my server. So we're just going to do s dot listen to Now this might actually be one because it might be like 01, but I think to maybe the correct thing, so do s dot listen for now. And then what we're gonna do is we're going to print after we've listened, we'll just say waiting for connection. And we'll say, server started or something like that. Because once we get to this point, we are running the server and everything actually is working like we're listening for connection, we're ready to go. Okay, so the next thing we're going to do is, we're going to define something known as a threaded function. Okay. And we'll, I'll talk about again what this means. But let's just do threaded threaded underscore client for now. And I'm just putting, you don't actually have to name it this you can name it whatever you want. I'm just putting threaded here just so we know. This is threaded, and then it's going to take one argument which is going to be co nn, which stands for action and let's just pass in there for right now. So the way that threading works, actually, let's, let's do the threading. And then we'll talk about how it works. So they'll probably make a bit more sense. So let's do a while true down here. Okay, so once we set up our server, our port we bind it doing here, we're starting to listen waiting for connections starting the server, then we're going to do is we'll be get put into this while loop. And what this while loop will do is will continuously look for connections, okay? Because right here, we're just listening, like once right to see if anything's on that server port. But down here, we want to continually try to grab connection to see if somebody's connected. And if it does, then we want to print something to the screen are we gonna send information are we gonna start a new thread, which we'll talk about in a second. So in here, what we're gonna do is gonna say connection, which co nn and then ADR equals and then s dot, and then we'll say accept. And what s dot accept is going to do is it's going to well accept any incoming connections. And then it's going to store the connection and the address. And the connection is, by the way, an object representing like, what's connected, the address is going to be an IP address in these variables. So if we get a connection, what we'll do is we'll say, print connected to Okay, and then ATR. And this is going to show us what IP address is actually connecting. So we can have a look at that. And then what we're gonna do is we're gonna do start underscore new underscore thread. And then in here, we're going to do, what was that name of the function that we had was threading clients. Okay, and I believe we do, comma, and that in brackets here, we do see, like that. Okay, so start new thread. Is there a reason that's not working? Give me a second, I want to see why oh, that's why. So up here, instead of saying import thread, we're gonna say from underscore thread, import star. Okay, and that's just gonna make it so we can just do start new thread thing. And you know, what, I don't know if we're gonna need this S y s, but let's just leave it there for now. Okay, so let's talk about what reading is gonna do. So essentially, the way that you guys are used to programs working, I'm assuming, unless you have some familiarity with threading is that say, we're in this while loop, right, and we were to call the function thread client. Well, before we continue going with this while loop, we would have to wait until this function was done running. In other words, we return back from this function, some value, or, for example, like he does, like x equals five, we would have to wait for this x equals five to execute, and then it would come back in this while loop and keep going. Now, we don't want that to happen, because we're going to be having multiple connections going at once. So what we want to do is we want to start what's called a thread and the thread is just another process that's running in the background. So that just means when we do start new thread, and we do threaded client, it's going to run this function, but it's not going to need this function to finish executing before it continues the while loop. So this is going to be running in the background as like process two, while process one is still running and still going. So that means say we connect to 100 different things, we're going to have 100 different functions running. So 100 different threaded clients on the stock or like keep going. And then what we're going to have is this while loop still continuing to go, what did I just do, still continuing to run to look for another possible connection, you guys will see more how this works, but essentially just means this will run in the background. And we don't have to wait for it to finish executing before we can accept another connection. That's the basic kind of a way to that works. So now let's start working with threaded client. And then we will test the server out and see if it's working. And then obviously in next video, we're going to connect to it and do all the connection stuff. Okay. So in here, threaded client. So what should happen when we connect to a client? Well, we're going to have to do a while up in here. So we're gonna say well, true. Because we want this to continually run well, our client is still connected, okay? Now, what we're also going to do is, we're just going to say reply equals blank like that. I'm just copying from my other screen, because this one is a bit finicky. I don't want to mess it up. We're going to put a try in here. And then we're going to say is we're going to try to receive some kind of data from our connection. Okay, from whoever's connected, we want to receive some kind of data. So what we'll do is we'll say, I believe it's s con dot receive. That might be right. Yeah, I think that's right. And then here, we're gonna put the amount of bits, okay. Now, if you guys know anything about computing, you know, like how what bits represents, but essentially, this is the amount of information we're trying to receive. Now, if you're getting an error, when say you'd like do this and you connect up and you get some error that says, What do you call it? Like object was true answer like you're getting any errors just increase this size, okay? And you can just do that by like putting this like time Ate or something, just note that the larger the size is, the longer it's going to take to receive information. And that's obviously because the more information you're getting, the longer it takes to send that over the server. So 2048 bits is not a lot, it doesn't take very long, it happens almost instantly. But if you bump this number up to a ton, then it will take longer to do that. Okay, so data, then we're gonna say reply equals, and then we say data dot, I think it's actually string dot d coach. Let's see this data dot decode, because it will be in that kind of objects for that data decode. And then here, we're going to do UTF, eight, comma, eight. Now, the reason we have to do this is because whenever we're sending information over a like client server system, we have to encode the information. And you'll see that in the next step that we're going to encode information before we send it back to the client. But that means that we're receiving encoded information. So to actually be able to read it like a human readable string, we need to decode it first. So it's really easy to do that we just do dot decode, and we're just giving the format which is UTF, eight, okay? So reply equals that. And then we're going to say address, if not data, we're going to print disconnected, okay, and then we're going to break. And this just means if we try to get some information from the, what do you call it, the client, but we're not getting anything, we're gonna disconnect and we're gonna break. And that likely means that we've will disconnected from the client or the clients left or something like that. So instead of continuing to run this, while we've been trying to get information from a client that's disconnected, we're going to break this just kind of a failsafe to make sure we don't get into any infinite loops. And it's also going to show us if we're running into any issues with like receiving the data and decoding it, which we'll talk about later. Okay, so otherwise, so if we are getting information, all we're going to do is we're going to print received, is that how you spell received, maybe? And then we're going to put? What do you call it? reply, okay. I didn't mean to that. Let me see if I'm spelling this, right, I have not received reply. So this just means we received from the client, this reply, let's print to the screen, see what it looks like. And then we're gonna print sending a colon? And we'll just print reply. Okay. And then we'll talk about this again, in a second. Why does this keep happening? Okay, reply. Next. Now, after this, if not data breakout, what we'll do down here is we're gonna say con dot send all and we're going to send str dot encode, reply. Now, again, remember that since we're sending information over the server, we have to encode our information. So all this is going to do is just encode our string reply into a bytes object. So that means when we read it in from the client side, again, we'll have to decode that information. It's kind of annoying, but I mean, it's a security thing, right? So now we're just going to accept, I guess, what, what kind of error would even be, I don't even know if there's gonna be any errors. If we run into anything, let's just break just to make sure that we're not you know, getting in that infinite loop, or we're not gonna ruin the program by doing that. Okay, so this is actually about it for our server. Let's see how much time We're at 30 minutes. Okay, so now what we need to do is figure out what the server number is, and then we can actually test it and see if this is working. So what we're gonna do now, is we're gonna find the server number. Now, to do this, we're gonna be doing this over localhost. Okay, that means that our, we're only gonna be able to connect over our local network, meaning that like anything on our Wi Fi network, that can see each other, that'll work fine. But as soon as you're outside that network, it won't work. So we're going to be using what's known as local IP addresses. So to find the local IP address of the machine you're currently on, you're going to go to command prompt in the bottom left. And then we're just going to type IP config. Okay. Now, some of you guys are probably freaking out, because you can see my IP address right now, this is a local IP address. And that means that it is locally assigned to my network, no one outside of my network can see this IP address or can ping it or can DDoS it or anything like that. Okay. So it's perfectly fine if you guys see this address, if other people know what this local addresses, okay, just as a note, so we're going to do is we're going to take this ipv4 address, so just copy that. And we're going to paste that inside of the string here. Okay. So 10 to 11.2 52. Seven is mine. Now, yours likely is like 192 dot 168 dot something, okay. But since I'm on like a massive network, usually they use 10 dot 10, like as the default gateway, which is what they're using. So my IP address starts with the 10. Yours likely starts with 192 dot 168 dot one, or dot like five or something like that, and then the rest of it, okay, so that's the address we're going to use. And this is going to be our server address. So whatever machine that you're going to be running the server script on, that's the address you want. So say you want to run this server on your laptop and you want to run clients on Like your PC, and your Mac or something like that, then you want to make sure you get the IP address from your laptop, and you're putting it in that script. Okay, and we'll talk about more of this in the next video when we actually connect to it. Okay, so now that we've done this, I probably made a mistake. But let's actually just create a configuration quickly for server and run this and just see if we're getting any errors as of now. But now, it is worth noting that we're not gonna build to connect anything yet. So there's not really going to be much we can see or really do. But for now, let's just test this out. So let's have server let's run this. And you can see waiting for connection server started. So that's actually good. If you're getting this string of text, everything is currently working. In the next video, we'll probably have to debug a little bit once we start connecting to this. But for now, that is the main server script. Now briefly, just talk about before I end this video, how it's going to work in terms of running the server script and running the client script. The server script always has to be running, okay, so whatever you're trying to connect, you have to have first run the server script. And then you can run multiple client scripts from wherever on the network you want. Now, the server script has to be running on the machine that the IP addresses like this little string here, okay has to be running on that machine. And you can run a client script on the same machine that the server scripts running, and you can run multiple client scripts on the same machine. So like, for example, what I'm going to do To test this in the next video is I'm going to run the server and then I'm going to run two clients on this machine. And we'll see that it like is moving back and forth for them. So what we're gonna be doing in this video is we're gonna be coding the kind of client side of this. So connecting to the server, I know, we already coded a client, but we're gonna code like the network aspect of the client so that it can connect to the server, it's not as much code it's a bit more straightforward. And then we're just going to test out sending very basic information to the server, and hopefully getting some back, see if that's working. Okay, and then in the next video, we're going to be connecting this. So like the little user interface we created with moving that block around in the first video, we're gonna be connecting that. So that we can have multiple clients running and we can see like different blocks moving on each screen. Okay, so that will involve a bit more work. Hopefully, by video five, we'll have like a fully working kind of game that's working over the network. Okay, that's the goal. So with this video, I just want to start by saying on the server class here, or sorry, server file, I did actually forget two lines of code in the last video. So after this, except break in threaded client, just need to add this print last connection. And then connection close. All this is doing is once we break out of this threaded client, we're just letting the we're just going to print this to the console so we can see what it looks like. And then we're going to close that connection, so that we can possibly reopen it in the future. Okay. really straightforward. That's all you got to add. So just make sure you add that before moving on. Okay, so next, what we're gonna do is we're gonna create a new file, and I'm going to call this network, okay, now you don't have to put what I'm going to in the new file, it's just a lot easier. So that's why I'm going to do that. So let's do network. And in here, we're going to import socket. Now what I'm going to do is I'm just going to code a class that is going to be responsible for connecting to our server. And this just makes it like so I can reuse this class in the future. And you guys could reuse this class in the future. It's just a bit cleaner and nicer. In this way. I like to do things. So when I say class network, again, call us whatever you want. And in here, we're just going to send an initialization function will take actually as network, do we need anything in network? No, I think we'll just leave like that. So we're gonna say self dot clients equals socket, dot socket. It's gonna be the exact same arguments as last time. So say socket dot i f. NET Anka, is that what it is if underscore net, AF underscore eye net? Okay, and then we'll do socket dot sock stream like that. Okay, now we're going to define the server and the port again. So self dot server equals self dot port equals 5555. Now for the server, this again, this number has to be the same as the one you used in the server. What do you call it? The server file here. So no matter what, like no matter where you actually are, like, what client you're using, this number is gonna stay the same, because this is the server you're connecting to. It's not the clients address. We don't actually have to define the client address anywhere. It'll automatically get that for us. Okay, so what we're gonna do now, we have client server port, we need to do this self dot addr equals and we're gonna say, server so self dot server, and then self dot port here. Okay? And then self dot. What do you call it? self.id is going to be equal to self dot Connect. Okay? Now, you guys, actually let's just do self connects right now and we'll talk about why I was going to add this ID later. Once we add that functionality, the server, okay. Essentially, I wanted to have an ID There was returned here, or like it was stored in this network object, just because we are going to have to like be sending an ID to each of our clients. So they know if they're like player one or player two, but we'll do that later. Because we don't really, we can't really do that yet. Okay, so we've called this Connect method. So we need to write that now. So let's say define Connect. OK, and in here, I believe we should probably be given Actually, it's probably fine. Just yourself, right? Now, what we can do is use your self dot clients dot Connect, okay, and then here, we do self dot addr. Now we're going to throw this in a try and accept just in case you know, this isn't working. So say try, say, accept, and renew socket, air, um, let's say accept. And we'll just pass right there. Okay, just in case this doesn't work. So we'll try this, we'll try to connect, accept pass. Now, once we actually connect, what we're gonna do is we're going to return, I'm just looking at the screen right now self dot client dot receive. And then we'll do 2048 dot decode. Guess what this is going to do? I'll talk about this because it might be a little bit confusing is when we connect, we want to actually send some kind of information immediately back to the object that connected to us. So like, for example, it's going to give me to close that. Let's go into server here. And you can see, when we initially Connect, we're not sending any information until we receive something, now, that's fine. But when we connect, we should really send some kind of like validation token, or like, Id back to our network object or back to our client. So what I'm going to do in here, let's say con, dot send, okay? And then in here, what we're going to type is, let's see, what should we really type here, um, str dot encode, then he was connected like that. Okay? Just so we know that we did indeed, connect. So that means if we set this equal to a value, so self dot, I don't know, let's say ID equals self dot Connect, what'll happen is, when we connect, we'll return that string connected. So this will get connected. And since it's in Kota, we need to decode it, obviously. So if we want to print actually in here, self.id, it should say like, connected, okay, let's see if that works. Okay, so now that we actually have that, um, let's see if we can connect to the server, and then we'll deal with sending information from the client to the server, as opposed to just getting it from the server. Okay. And that's a bit confusing, right now, I'm just trying to figure out the best way to do this. So let's try this case. So we're gonna say n equals network, I will just type this in the bottom of the script. We won't do this after we'll delete this just for testing purposes. And then we're just going to say, actually, that's probably all we need to do, because it'll just print our ID. Okay, so let's create a configuration for network. So new configuration, type network and here and then select that path. And then let's test if this is working. So remember what I said, when we're going to connect right to our server, what we have to do is first run that server script. So let's run the server script here. Waiting for connection server started. Okay, let's run this network script now. invalid argument with supplied s dot listen to. Okay, so I had a quick look here, I realized the mistake was I was actually running this server two times. So obviously, that's not going to work for us. So we can put two back in this. Listen, I'm not sure if you guys will see if I left that in the video or not. But let's go to network. And we also need to change this to AF instead of if I don't know why I typed if I literally said AF when I was typing it, but that's fine. And we have server, I'm actually running it right now. So make sure you guys run that. And then those run now we can see if this works. Okay, sweet. So I know it doesn't seem like much. But you can check here if we go to server says connected to and then it gives us that address. And it's also printing out some other thing that I honestly don't know what that means. And then saying disconnected and lost connection. Sweet, that's actually really good. And that means that we're everything's working. And you can also see that we have connected being printed here. slot means when we connect to the server, we're actually getting the value that descending so we're getting this connected, and we're printing it out, decoding and all fine. So that's really awesome. So now the only next step is to actually send information to the server and keep like a loop going like sending receiving, sending, receiving, sending, receiving. Now let's actually just test. If I run this again, you can see again, obviously it's working again. So this is the server just continually is running, I don't actually have to stop this unless you want to make modifications to it. So let's just keep that running for now. And let's add something to our network class. So in our network class, we're going to define a method that is going to be sent. Now this method is gonna be very useful later on, because it's gonna save us a lot of time. So in sandbridge, can take a string, which is going to be data, okay. And all we're gonna do here is we're gonna try to self dot client dot send. And we'll say data, str actually dot ENCODE data. And then we're gonna get a reply from that service, we're going to say return. So exact same thing that we're doing here, self client receive 20 48.2 code, and we'll accept. And I believe this is a socket, err, yet, it's socket dot air as he and just print E. So if we get into some error where, you know, either we're sending or we're receiving, it's not working, let's just print that arrow to the screen. So we have a look at what that really means. So now let's do a test and try to send information to the server and then get something back. Okay, now the information that we're getting back should just be the same information because that's what we have in server, we're just going to send exactly what we got right back, right. So it doesn't really make sense right now to do that, but we'll talk about like, what we can, what valid information we can send, how to send receive information in the next video when we connect up the client to the thing, okay, so what we're gonna do is we're gonna say n dot send, and we'll print n dot send, okay. And we'll print and send again, and let's just send like a few bits of information and see if everything is indeed working. Okay, so n dot send. And then in here, let's just type Hello. And we'll type working Ok, and see if this works. So we have actually, we should have Yes, server is working, let's run our client. And you can see we get connected, hello, working. And if we come here, it says, received Hello, sending Hello received working, sending working. So that's awesome. That means our network class is working, sending information receiving information is working, servers working. And now the only thing that's left to do essentially, is to connect that up to this. So use this network class in some meaningful way here, and then to actually store information on the server, and then send that information to multiple clients, which we'll be doing in future videos, what we're going to be doing is we're going to be hooking up our graphical client to our server, so we can send information back and forth. And ideally, at the end of this video, what we're gonna have is we're gonna have two rectangles on each client. So I have like two clients running. And when you move the rectangle on one client, it moves on the other, and vice versa. Okay, so you guys will get the idea when we go through, but there's a little bit of work we have to do. And we're gonna be modifying a few things within a lot of the files you've already created. So just make sure you guys are paying attention. And again, if anything is going wrong, feel free to download all the code off of tech with Tim dotnet. It'll be available there. And it'll be exactly the same code that I'm writing right now. Okay. So first thing we're going to do is in this network class, we're just going to delete a few things. So this testing stuff, we don't need any more, this print statement for the self, that ID, we don't need that. And we're actually going to change this self.id to be self dot pause, okay, and you guys will see why we're doing that in a second. And we're gonna add one quick method in here. And then we're just gonna say define, get pause, okay. And what we're gonna do here is just return self dot pause. Alright, and again, we'll, you'll see why we're doing that. But I don't want to have to come back to this network class. So we'll do that right now. Okay, so from inside our client, now, what we're going to do is we're going to import this network class, because we're going to use it in here. So we're gonna say from network, import network. And then in our main function down here, what we're going to do is actually above player, we're going to say, and equals network, okay, like that. And then what we're gonna do is we're gonna say, start, pause, equals and dot get pause. So essentially, why I'm doing this is because when we first connect to our server, what I want to happen is I want it to return to each of our clients, the starting position of their character, right or of their cube, okay, because it's going to depend where they're starting based on if they're player one, or if they're player two. So then on the client side, what we're going to do is when we initially connect to the server, which is what we're doing, when we create this network object, we're connecting to the server, we're going to get that starting position. And then for creating our own player, we're going to use that starting position to determine like where we're starting. So the position is going to come in as a tupple. Alright, and we'll be coding all this on the server side in a second, but it's easier just to go through each file, rather than going back and forth. It's going to come through as a tupple. That looks something like this. So it'll be like 50 100. Okay. So what we're going to do is you're going to read this tupple. And because it's actually going to come in as a string, like, you'll see how it comes in. We're going to get the two aspects of it like the x value and the y value. And then we're going to use that inside of this player initialization to like set the initial position. So that reminds me what we're going to be doing when we're sending information to the server is we're Send it using string data, right. And that's what we're doing in the last video is we were sending everything with strings we were sending, like Hello, and then we were decoding and encoding it. Now, this is not the only way we can send information, we can actually send information with objects. And I'm going to show you the advantage of doing that in the next video. But for now, we're just going to send strings. So since we're going to be sending strings, the strings that I want to send our positions, okay, I want to for each client, send the current clients position to the server, the server is going to get that position updated on the server side, and then send the other clients position back to the client, you guys will see how it works in a second. Actually, let's see if I can do a quick drawing to illustrate this because I'll make things a bit easier. Okay, let's, I don't know why I had this. Let's delete that. Okay, so let's do a quick drawing. So we're gonna have, we're gonna have client one, and excusing some drawing this with the mouse and client two, okay, so it's gonna be one, and this is going to be too, alright, this will do it as a red box is going to be our server. And on the server, what we're going to do is we're going to store positions, so psych one has positioned like, one, two, okay, sorry, this is hard with the most guys. And then client two will have position like three, and one, OK. So it can store these positions. So what's going to happen is when we initially Connect, client one is going to go to the server, it's going to connect to it, and then it's going to be sent back the starting position for the client. Okay, so it's going to be set. Okay, so your client one, so that means you're going to start at position one to client two, it's going to connect, it's going to say, okay, we're client two, so I need to send client twos position. So let's send that back. All right. Now, let's say we've already connected client ones, their clients twos there, and we've set their starting positions, what we're going to do next is now we're going to continually call to the client and update the position. So what we're going to do is say, let's say we're working with client one, okay? What it's going to do is it's going to send its position to the server. So it's going to say, let's just say pause, okay, it's sending its current position, let's say that position is like four, five, so this is really hard with the mouse, get four or five, what's gonna happen here is we're gonna say, okay, so you're updating your position. So then it's going to go in here, it's going to say, okay, client, one will update your position to be four, five, like that, okay. And then what it's going to do is, instead of sending back the same position, because we already know what the position is, it's going to send back the position of client two. So it's going to send three one. And then on here, we can draw that client so that it looks like it's moving, right? So we're getting we're sending our information, and then in return receiving the other clients information. Now the same thing works here with client two. So client twos connects, right, and it's sending information, it's gonna send its position. Let's say it sends the position one, three, okay, that's its updated position. So this is going to change to be one and three. And then what's going to happen is, it's going to say, Okay, well, we don't need clients twos position, we need clients one. So what's client one position? Well, that is four, five, so let's send four or five, over to client two. And then on client two, we can draw four, or five. So you'll see those simultaneously be moving. I hope that makes sense. I just want to draw it out for you. So you guys know what I'm about to do in this video. Okay, perfect. Now, the only thing is we need to send these positions as strings. So we're actually going to have to implement two helper methods so that we can convert those positions which are going to be topos Industries. And then we can also read the string into a tupple. So what we're going to do is we're gonna say define, and I'd want to remember what I call this one, we'll say this one is read underscore position, which means we're going to take a string value, and we're just going to read the string and we'll say str equals str dot split. And we'll split it at a comma. Okay, and you guys will see how this works in a second. And then we're going to do is we're simply going to return the end of string zero. So str, zero, okay, comma, int, str. One. So what we're going to do is we're going to take a string that looks something like this would be 45, comma 67. Okay, in in string value, 4567, we're going to split it, which means we're going to get a list that has the string 45, and the string 67. And then we're just going to convert those two ends, and return them as a tupple. So now we get that converted something that looks like this, which is useful information that we can actually use. Okay, so that's what read pause is gonna do, but we need to make one more which is going to convert that position into a string. So we're gonna say, Make underscore position. And in here, what we're gonna have is we're going to take a tupple. So the shape top standard for tupple. And what we'll do here is we'll say, let's see here, return, tuck, actually str of top zero. And then we're going to add that comma in so sorry, I'm butchering my typing right now, comma, plus STr of top one. And I hope that makes sense how we do that. So that's returning the string value. So we're reading pause And making pawns. And that's all we need to do for those helper functions. Okay, so that means though, that when we get the position initially from our server, it's going to come in in that string value, right, it's going to look like 4567. So we need to convert that. So what we'll do is we'll say, read pause, we'll just put that around and get pods because get returned us that string position. So we'll read it in. And now what we're going to do is for our player, we're going to say start, pause, zero, and start pause, one, okay. And what this is going to do is just set it to the initial start position, we're going to code all the server stuff after it will start making a lot more sense. Okay. Now, what we also need to do is we need to create a second player, because we're gonna have to draw the first player and the second player on the screen, right, so we're gonna say p two equals, and we're literally just going to copy this, except for start position, we'll just gonna put it as 00 for right now. And we'll update that in a second. Okay. So we have P, P, two M. And for now, that's what we'll do, actually, let's we can continue working in here. So that we don't have to do anything else in here, after we'll just code the server side. So what we'll do now is we're going to send our current position to the server, right, that's like the algorithm we've developed, essentially, we are, when we connect, we're going to get the starting position, we're going to set that starting position. And then every time after that, so like every time the frame updates, we're going to send our position and then get the other person's position. So we're going to say is, we're going to say, P to pause is going to be equal to n dot send, okay? And we're going to send make position of, and then we're gonna have to do in here is, it's a little sketchy, but we're gonna do p dot x, p dot y. Now, right, because that's the position of our player, the x and y coordinate, we're putting it in tabular form, we're sending it to the function make position, which is going to turn it into a string, and then we're sending it to the server, right? Okay, awesome. So I think that makes sense. And then we're going to do simply is for p two, we're going to update is its position. So we'll say p two dot x is going to be equal to, actually, and to not sad, but we'll we're gonna have to put around to your story is make pause, read pause, because right, it's coming in as a string, so we need to convert this into our actual position. So P to pause is going to be P to position zero, and then P two dot y is going to be equal to P two, P to pause one. Okay, now the only thing that's left to do here is what he called draw p two and update p twos rectangle. So what we're going to do now is in the redraw window down here and put p two, we're going to go to redraw window, we're going to say player two here. And then we're going to do player two dot draw window, because again, it's going to be a player object, so that'll be fine. And then last thing to do is just update the rectangle. So what I'm going to do is I'm gonna say p two dot update, and we're going to go to player object now we're just going to add this one function, that is define, update. And then, so you see, I just made the x self dot rect equals x, y, width, height. And then in here, I'm just gonna say self dot updates, like this. Okay. So I know this might be getting a bit confusing, but we're almost finished. Let's go do the server side. And then we'll recap through everything, what we've done, explain things, I kind of have to get this content out. Okay, so define update. So what we're doing again, here is before, we just had this line of code here, so we're just replacing that with an update method. That's pretty straightforward. I hope that makes sense to you guys. And that's just again, so when we change the x, and we change the y value of p to directly, then we are updating the rectangles. So when we draw it to the screen, it's in the correct position. Okay, so I believe that's all I have to do for the client side. So now it's time to go to the server side and server sides pretty straightforward. Now what the server needs to keep track of the positions, right, it needs to hold player ones position and players to position consistently. So we can decide if we want to store that, let's say like on a hard drive, or if we want to store that in memory. Now in our case, it's not a lot of information. So we're just going to store it in the memory of the server, right. So what we'll do for that is we're going to create a list. And we're going to say pause equals and just a blank list. And this list is going to hold the positions of our players. Now actually, that reminds me, we're going to put two titles in here. And these are going to represent sort of the starting positions of our players. So we'll start with 00. And like 100 100, so player one will start at 00. Player Two will start at 100 100. Okay, and that's all we're going to do for that little list there. And then what we're going to do down here, while this while loop is we're going to keep track of how many players have connected. In our case, we only want to to connect right. And then we need to keep track of well those players, so we're going to say there is a current player equals zero. Now, this is because when we connect, we're going to add one to this so that when we go back into this function, it'll be you guys will see how it works. But essentially, every time we create a new connection, so every time this, we accept a new connection, we're going to add one to our current player. So we'll actually do it at the bottom of the while loop, we'll say current player plus equals one. This is just to keep track of which player we're using, so that we know what position to update what position to send to that player based on the connection, right? Okay, so keep track of current player. And now what we're going to do is when we start this new thread, so this threaded client, we're also going to pass another argument, which is going to be the current player. So instead of just passing connection, we're also going to pass player in here, okay? Current player like that, okay? Because that's gonna be important information to know. Alright, so we're actually almost finished, we just got to update a few things. So let's actually grab these two methods from our client class or client file, and throw them onto server here. So we're just going to put them right above position, because we're going to need to use them read pause and make pause. So now when we initially connect to our player, right, this is what happens when we initially Connect, the first thing that sent is this encoded message that is connected. Now in our case, what we want to send is we want to send the starting position. So how do we do that? Well, we know what player we are, we're either player zero, or either player one, right? Because we only have two players. When we start with player zero after player zero connects, then we do player one, right? So what we'll do is we're going to send pause, player. Now, that won't work, because it's just a tupple, right, we need to first convert that to a string, and then encode that string and send it. So let's actually go back here, I want to keep the string dot encode. So string dot encode, and we'll say make underscore, oh, a pause. And then we'll just put pause player in here. And what that'll do is it'll convert it into a string for us, and then it will send that to the player for us, right. And then they'll read that string in Kibera to position and update the position accordingly. Okay, making sense. I hope so. Okay, so that's how that works for player. Now, the only thing we need to change now is what information we are sending, every time this loop is running, right, every time we receive something from the player, we want to send back the other players position. So to do that, what we're going to do is we're going to say conduct receive D code. So we'll get rid of this for now. And then we're going to say is we're going to turn this data into, like readable a readable tupple, right. So to do that, we are going to use the read position method that we've already created or function. So say read pause, conduct receive. And we'll turn that into from that string like this right? or whatever it was, like 4567, we'll turn that into something that looks like this. So that we can actually use it. Okay, so now that we have that, it's turned into that, what we're gonna do is we're going to update our current players position. So we're gonna say pause, player equals data, right? Because this is the position they sent to us. So let's update it on the server. So yeah, so it's updated information. Okay, sweet. So we've done that. Now, all that's left to do is send the other players position back to our client. So to do that, what we can do is simply say, reply, equals, and we're just going to say, pause, or actually, let's not do it up here. Let's do it down here. Okay, we're gonna say, if player equals equals one, so if we're player one, we're gonna send player zero position, right? So as a reply, equals, and then pause, player or not, pause, not not player zero, sorry. And then else we're gonna send. So say reply equals pause one. Okay? So if we're player one, we send player zero position. If we're players here, we send players one position, right, like I was talking about with that little algorithm we're going to use, okay, and then instead of saying received, and sending, actually, yeah, we can say received reply sending reply, or real estate received data sending reply, that should work fine. Okay. Now, what we'll do is we're going to send all the reply, but the thing is our reply, we need to first convert into a string. So to do that, we're going to say make underscore, pause, write that function we've already created. And then that should actually be about it. Now, I'm probably made a mistake or two here, but let's just test this out and see if everything's working. So let's start by running the server. And then let's run to clients and see if we can connect if there's any errors. Okay, so we've connected with client one, let's run client two. And let's see what happens. So I'm on client one, right now, you can see that when I move my green square, it moves on the other client, kids go to the other one. And when you look at this, when I move it on here, it moves on the other client. So we have successfully set up and connected our two clients together. Now the only thing I want to change quickly, it's just the color of these so that we know who is who like which square am I. So to do this, we're just simply going to go will actually close the server class otherwise you're gonna run into an issue or sir instance, whatever it is, we would have clients. And instead of having the same color here, we're just gonna change this to be 255 for player two. And now I want to show you what happens, because some of you are probably gonna be confused with what's about to happen here. But it's kind of interesting. So let's run server. Let's run client one, let's run client two. Now notice that these colors are inverted. Now Can anyone think of why that might be? So green, right is going to be your current player. So right now I'm on here, I'm on this where my mouse is, and I'm moving the green square that's near the middle of the screen, okay. But notice on the other screen, it's moving the Red Square. That's because on your client, it's unique to you. So on your client, you are green, and red is the other person. Meanwhile, if I go to this client, and I start moving, see green is me. And red is the other guy, right, and he's not currently moving. Now, if I wanted to move these at the same time, I would just have to be running these on different computers, or I would have to change like the arrow keys to move them. And that's just because obviously, right, like, if I'm pressing the arrow keys on here, it's not going to work on this client. But if I were to load up my laptop and try doing it on there, this would work fine as well. There's a quite a few issues that we may run into when we're doing this. So I've set this up essentially, to be kind of like an example program or like an example problem. To give you guys an idea of the way we go about doing things in terms of server and network. But it's really not ideal, the way that we've coded things so far. Now, I did plan this for to do what we're about to do. But essentially, I'm going to redo what we've just done in a much more elegant and nicer way that's going to allow for better scalability of this program. Okay. So what we're going to do is I'm going to redo it here, I'm going to show you how we can actually send physical, not physical, but like send objects to the server and from the server back to the client rather than just string data. And then in the next videos, we're actually going to scrap all this code that we've written, and we're going to start fresh and code, like a networking game, there's going to be a lot more complex than just a few squares moving around the screen. So that's my plan for this series, let me know what you guys think of that. I know, it might be a little bit frustrating to get rid of this code. But now that we understand a lot of this works, it's gonna be really fast to rewrite it in a much more elegant way. So what I need to first start by doing is just taking this player class, okay, and I'm just gonna copy it into its own file. So really straightforward, I'm just gonna go to a new Python file, I'm going to call this player with lowercase. And then just copy that player class in there. And just import pi game up here. Okay, import pi game. Now I'm just going to go back into client, we can delete this player class. Now, what I'm going to do really basically is just from player import player like that, okay. And that's the first step. Now, remember, I said, we're going to send objects. So that actually means that we're not going to need this read, pause and make pause thing. And it's kind of annoying how we've had to, we'll take that Tableau object, decompose it, turn it into integers, and then change Object Properties. And then when we want to send something, we got to put it into a string, and we got to send it in just a pain. And we don't want to have to do that, especially when we're sending tons of different bits of information, not just that same positional data, right. So we're actually going to delete this, I'm going to delete this client number, I don't know why I have that there. And we're going to start just making some modifications in terms of sending data and receiving data. So we'll start on the client side, and then we'll go over the network, the server side and fix some of that. So wherever we see like read pause and make pause, we can just get rid of that for right now. We don't actually need any of that, we're not going to need this P two dot x stuff, we don't need p two dot update, we'll get rid of all this for right now. You know, actually, let's get rid of star position. Let's get rid of P and let's get rid of P two, and we're going to recode all this. Okay. So, actually, um, p2p, I can stay there, Peter move is fun. Okay, so we got rid of all that. And you can see we've just cleaned up this file, but and we'll start working with some more stuff in a second. Now, what I want to do actually is go to this network file that we have. And we're gonna start making some modifications in here as well. So what we're going to be doing is we're gonna be sending objects, so that means we're going to send like an instance of the player class. And that's actually what we're gonna be sending instance of a player class to our server, as opposed to sending like string data and then updating the object on or then updating the string data on the server and then sending it back and then updating the object, it's just a lot of work, it's a lot easier just to send the actual object. So we can do that using something called pickle, okay. Now, it's a weird module name, but it comes default with Python. And this allows us to do something that's called serialized objects. And that just means we turn it into byte information, which is like all the zeros and ones, send it over the, what do you call it, send it over the network, and then we can decompose that, turn it back into an object and use it and it's really easy to do that. So what we're gonna do here is we're going to modify a few things. In this in our network class, so first thing, instead of having self dot pause, we're gonna say self dot P, okay? Let's give equal to self dot Connect. And so saying get position will this do get P, and then we'll return self dot P, okay. And that's all we need to modify for that. But now in the connect in the Send, we're going to change a few things as well. So since we're going to be getting object data, what we have to do in the Connect is we have to decompose that object data. So to do that you do pickle dot loves, okay? Now what this stands for is it stands for load byte data. Okay. And we'll we'll talk more about this as we keep going through, but that's essentially what it means. And same thing here in send, instead of encoding this data, what we're going to do, and I guess decoding as well, is we're going to dump it into a pickle object and unsend it. So to do that, we're going to save pickle, pickle, yep, dot, dot dumps, like that. And we'll just put data in there. Okay. And then when we receive, we'll do the same thing as before, we'll say pickle dot loads, and that will load that in. So now essentially, what we're doing is we're going to be receiving an object, decomposing that object, getting the actual object, not the bytes form of it, and then we're sending it, we're going to first like, what do you call it, encrypt it, like send it into that byte information, and then on the server side will decompose that as well. Okay, so we'll, we'll go through that. But that's all we need for the network side. So now let's go to server and start making some modifications. So same thing here, we no longer need this read, pause and make pause functions, we're not going to be using those. And we don't need this pause list, either, we're going to change this actually to be players. And it's going to be equal to two new players. So notice that we're going to actually store the player object on the server, as opposed to on the client side. And this is not only like safer, because it means that the player technically can't really mess with the player objects, they can only like, do commands to update them. But it's also just like, it's gonna be a lot easier. And you guys will see how it works. We're gonna say player, and we'll do another instance of player. And in here, what we're gonna do is we're just going to create two new players. So you say 00 5050, and we'll give it a color. In this case, the first color will be red. So we'll say, red, green, blue, like that. And for the other player, we'll start them at 100 100, like before will be 5050. And then we'll make his color blue. Why not do that? Okay. So now you notice that we're getting an error for player here, just because we forgot to import it just say from player, import player like that. And that's why I made this new file, by the way, just so that we'd be able to see it from the server side and the client side as well. And then wherever we're doing this, like send encoding stuff, we're going to change this. So let's do that. Now, actually. So instead of conduct send, instead of encoding some string information, we're just going to send the player object. So what we'll do is we'll say, players, like this, and then player, right, so exact same kind of concept as before, in that we're going to send the initial like starting position of the player, or like the, but in this case, we're just setting the initial player object, which means any information that's stored in that player will be given to the client as opposed to just the position. Okay. So next, what we'll do is instead of saying data equals read, pause and decoding, we're going to get rid of this dot decode and we're going to put pickle dot loads, okay? And actually, when I'm sending this player object, my bad here, guys, we got to do pickle. dot dumps, okay? And then we're gonna have to import pickle up here. So import, pickle, alright, sweet. So pickle that loads pickle dot dumps, and then obviously, instead of pause, player equals data, we're gonna say, player, players, player equals data. And again, same concept as before, what's gonna happen is the, what he called the client is going to send us a player object, we're going to replace the existing player object with that new player object. And then we're going to send back the other player objects like the other clients. Okay. So now what we're going to do is just change these pause to be player or players like that. Okay? Same thing here, players. And then when we send it back, what we'll do is we'll just turn it into a object, right? So we'll just do that pickle dot dumps and send it back. So say, pickle dot dumps, reply, like that. And that should actually be about it. So let's go back or sorry, there's something we need to do in client. So now what we're going to do is essentially, we've set up our network class so that we're going to be able to send that object data. We've set up the server so we're gonna be able to receive that object data. We're gonna Modify the objects we're storing in the list here, and then we're going to send back the other ones to the other client. So in clients, all we have to do now is set up player one and player two and then send that data. So really straightforward, it's very similar to before, what we're going to do, first of all, just say p one, we're actually just p i guess is equal to n dot get P. Okay? Because in the network class, remember, what we're doing is when we initially Connect, so let's go back to server, we're just going to send the initial player object, which is going to be whatever player it is. So zero or one. So let's just say that this clients player object is going to be n duck MP. Okay? And then we'll say, actually, I think that's all we have to do for Yeah, that is all we have to do for that. Inside this while loop. Now, what we're going to do is every frame, we're going to send this player object, which will be updating with P dot move. And we'll just get the reply and say that that's p two. So we're going to do is I say p two equals. And then in this case, we'll just say p.or, not n dot send, P. And that's all we have to do. And notice here that we don't have to do with all this like make, what do you call it, make pause, read, pause all that stuff. And I believe this should be working. If I didn't make any mistakes, let's cross the fingers. And let's try this out, waiting for connection. Let's go to client one, run that, okay, and client two, running that. And now notice that these rectangles are the same color. And watch what happens if I move this red one, see how it's red on the other screen as well. Now that already shows us one of the advantages of doing it this way, is that we can store information like color as well not just position. And if we wanted to store maybe like there was a text attribute on each of these players, we could store that as well. But we wanted to store more information in the player like a health or something like that, it'd be a lot easier to do that by just sending the actual player object that has like an unlimited amount of attributes, rather than just sending a little tupple that has like five, six, right, which is the position. So the reason I went through the trouble of showing you the other way is to show you the massive advantage of doing it this way. And just to give you kind of perspective, if you're making something really simple, and you don't use any objects, that's you can do it with string data. But I think this way is a lot easier. And we've just cleaned up quite a bit of code, we've gotten rid of a bunch of functions. And moving forward, this is going to make things a lot easier for us. I'm pretty much going to be gutting everything we already did, we'll keep a little bit of it, but we're just going to really add to a bunch of that. And just yeah, we're going to be gutting most of it. And we're actually gonna be working to create online Rock paper scissors. Now I know this sounds like kind of a lame game, but let me show you because it's actually pretty complex. And if you can understand how to make this game, then you're going to be able to understand how to make any other kind of online game because the principles are the same in terms of sending information waiting for players to go. And there's a lot of different things that you might not think about that we actually have to do to code something like online Rock Paper, scissors. Okay, so let's This is client number one, I'm just running another pi game window, or pi charm window with the server running on it. And you can see obviously, it's been oversized, but it says waiting for player. Okay, so I'm going to launch another client. And then excuse me, you can see when I launched that it loads both of them up into the game, and it says your move opponents, your move opponents, and currently it's waiting. So I believe this one's player two, and this one's player one. So if I make a move here on, let's say rock, it'll lock in my move and says your move is rock. And then over here it says, obviously the opponent's move is locked in because it's like looking for this guy's move. And now if he makes a move, like let's say scissors, then it says you when you last, and then it just resets and you can keep playing games. Now I'm also going to be adding more to this, this is just like the beta version, I'm going to have wins, ties and losses, keeping track and top hand corner. And when you load in, you're going to be brought to a menu screen, which will allow you to like start a new game or to leave or we'll we'll add that later as we go. But this is the main functioning game. And you can see obviously, it's working well tie game. And it restarts. This also allows for unlimited amount of clients to play. So for example, if I launch another two windows, you can see these guys now have their own game going. It's kind of difficult, because I can't really get four on the screen. But anyways, if I go like Scissors, paper that works independently of these games, and these games can kind of play at their own time, which is really interesting and really cool. And if you disconnect one of them, it automatically disconnects the pair. And that's just because obviously you can't play against no one right? So yeah. Okay, sweet. So that's that. Let's start getting into the code. Okay, so first thing we're going to do is we're actually going to code a game class, okay? And this is just going to be responsible for holding all the information for our game that we need. So for example, did player one go yet to player to go yet? What move did player one make one move to player to make are both of them connected to the server information like that, and you guys will see how much information we actually need. It's also going to or things like keeping track of who won or who lost, how many times how many wins. So that's what we're going to do with this game class. So let's start making it. So class game, I'm doing this in its own file, by the way, just called game, you are going to need the end zone file, because it's going to have to be accessed by both the client and the server. Okay, we're going to define our initialization. In here, we're going to take ID, I'm going to say self dot p one went equals false. self dot p two went equals false. And obviously, you guys know what this is going to do, it's just going to stand for if player one has made a move or not, if player two has made a move, we're gonna do self dot ready, equals false. If I could type that correctly, we're also going to add self.id. So self, that ID equals ID, and this is just going to stand for the current games ID. So each game we create is going to have its own unique numeric ID so that we can determine who is like what clients are a part of what game and whatnot, we're gonna do self dot moves, equals, and then we'll just do none. And none in here, because currently, the moves are none. But we'll just store two positions, so we can change that will say self dot wins, equals and then 00. Obviously, this one is going to stand for player one, this one's gonna stand for player two will say self dot ties equals zero. That's all we need for the net. So the next one is going to say get underscore player underscore move. Now what this is going to do is exactly what it says is just going to get I don't know how I added that there, it just going to get the player move that we asked for. So we're going to take p, which is going to be either zero or one. And we're going to do simply return self dot moves, and P and just remind ourselves, we'll say that P is in the range of zero, and one. So we're only going to take value zero or one and then we're going to return a move, move here. And let's just remind ourselves that we have to pass your one, obviously, zero is going to represent player one, and one is going to represent player two. Okay, next one play. So this one's a bit more complicated, not crazy, we're gonna take play, we're going to take a player, and we're gonna take a move. And what this is going to do is it's simply going to update our moves list with that players move. Pretty straightforward. So what we're going to do here is we're just going to say, if player equals equals zero, then what we'll do is we'll say self dot moves, zero equals move. Oh, actually, you know, let's do this. Sorry, I'm just looking at my other screen right now we'll say self dot moves, player equals move. But now what we have to do is based on the player, we have to update if p one went or P two went, Okay, so what we'll do in here is, if it's player one, obviously, we'll do p one went equals true, get any to self before that, and then we'll call it, we'll just do a little LS here, because it's not player zero must be player one will say self.pg. Want, if I could spell once, equals true. So that'll just keep track of if we've gone or not. Sweet. Next method, this one's really easy, it's going to be called connected. And it's just going to tell us if the two players are currently connected to the game. If they are, it will allow us to load in. And that's how we can determine whether we should show waiting for player or not on the screen. Right. So we'll say return self dot ready. And that's just going to tell us obviously, if we're ready, and that'll be updated from the server side, which we'll do later. Next method define both went, this is just simply going to return if both of our players left. So to do that, we're just gonna say self dot p one once and Why can I not spell that word, and self dot p two went like that. Okay. Next one is winner. This one is a bit more complicated, but it's just gonna keep track of where it's actually going to tell us who's won the game. So if we call this method, we're assuming that both players have gone, we're going to check their moves, excuse me against one another, and see if they want. So we're actually going to have to check nine possible cases, because there's three moves, each player could do three times three, nine. So what we'll start by doing is we'll just say p one equals self dot moves, zero, dot upper. And then to the reason we're doing this is because we just want to get the first letter of the move, because the move is going to be stored as Rock paper or scissors, the string, and it's just gonna be easier for us to type out, for example, R or s, or what do you call it, or P to check the moves, as opposed to having to check the entire word. So we're just going to get that first letter by doing move zero, we're going to upper it and then we're going to take that first letter, we're gonna do the exact same thing for p two, except obviously, we're going to need Oh, I don't know what I did there. We're going to need moves one dot upper. And now we can start checking to see who's won. So we're going to stay to start winner is equal to negative one. Now that's because There could be no winner that could be a tie. So if it's tied, we're gonna say negative one. If player one is the winner it's gonna be zero. If player two is the winner, it's gonna be one. Okay? So we're gonna do is we're gonna say if p one equals equals R, and P two equals equals scissors, what we'll do is we'll say winner equals zero because player one one that will say lF p one equals equals s, and P two equals equals R, then we'll say winner equals one believe, do another lF, and I know this is tedious, but this is the way you have to check for rock paper scissors. I don't think there's an easier way to do it. If you know an easier way let me know. And p two equals equals R. And if you guys don't want to type this, you can always copy it from my website, tech with Tim net. Okay, so say winner equals paper beats rock solid B winner equals one or zero sorry, we'll say lF p one equals equals R, and P two equals equals p, then winner equals one. And we've just got two last ones to check here. So we'll say lF p one equals equals s, and P two equals equals R. And then P two is the winner. So winner equals one. believe that's Oh, sorry, I'm gonna mess this up. This should be P. Thanks. So P rock, rock, paper, scissors, paper. Yeah, when r equals zero. Okay, well, if p one equals equals paper, and P two equals equals scissors, then when r equals one, and I believe that should be correct, 123456. Okay, sweet. And then the other cases, or if it's a tie, so if none of this is the case, then they must have tied, and then all we're going to do is simply return winner like that. Okay, and one very last method, then we're actually done with this class, we can move to something else is the fine, reset, went. And all this is going to do is say self dot p one went equals false. And self dot P to one equals false. Pretty straightforward. And this is the game class. I know it kind of sped through this, but it's pretty trivial how this works. We just need to get this out of the way so we can start coding some other stuff. Okay, sweets, we've done this class. Next thing I think we want to work on is network. So network, actually, you guys are gonna have to modify yours to look like mine. Now get P. And what do you call it? So this first half, so a net and get p are gonna be the same as what we had previously, the only thing that's changed is connect and this send. So in Connect, instead of, what do you call it, like unpicking an object. So like pickle dot loads, what we're simply doing is we're going to just connect to the client like we did before, but instead of unpicking it, we're just going to decode it. So we're gonna say self dot client dot receive 2048 D code would return that value. And that's because when we initially connect to the server, what we're going to get from the server is our player number, which means we're either player zero, or we're player one. Now, that's important, because that's going to determine where on the screen we're drawing certain things, and how we're sending information back to the server and updating player one or player two, right? Because technically, each player thinks that they're player one, but each one needs to be assigned either zero or one by the computer. So we know where to store information, right? Okay, so that's how we modify that to decode instead of pickling. Sending, I believe is the same except what we're going to do is, instead of picking an object to send, we're simply going to send a string, and we're going to load an object. So that means we're going to send a string data to the server, and we're going to receive back object data. So when we receive something, we have to pick it out, loads it in, but when we're sending it, we just have to encode the string. Okay, so just make sure it looks like this, I don't think I need to go through this. We've already done this for the past two, three videos. And that's the network class. So game and network are done. The next thing is to do our server and client. Now server and client are a bit more complicated. So inside of server, I guess we could do this first because it doesn't really depend on the client to work or the client kind of depends on the server. We're gonna change a bunch of things. So this is what mine looks like. Now I've kind of gutted the entire threaded client, I got rid of most of the stuff like most of the other stuff, just left this beginning thing so that the server IP, the port, the socket, connecting, listening, waiting for connection. So by the way, some of you were saying you're having issues with F s dot Listen, you can just make this zero doesn't really matter. What's in here. And some of you are saying like you're having issues just you can just delete it and type it in again. And apparently that works. That's when someone said so. I don't know. Don't ask me about that. But if you're running into issues, do that. Okay, so what we're going to do now, is we want to make it so you can have unlimited connections at once. Now that means we're going to have to have unlimited games running at the same time. So before what we were doing, when we had those players moving around the screen, we were just storing, like player one, player two, and we just had a list that had two entries. That's what we were doing that, what we're gonna do now, is we're gonna have a list that contains a bunch of different games. And those games actually, you're sorry, it's gonna be a dictionary, those games will be accessed by their ID, and use, we'll see how this works. It's a bit complicated, but just follow along. And yeah, so I got to just open up my other file, so don't make any mistakes here. Guess what we're gonna do is we're gonna do connected equals set, we're going to define some variables, we'll talk about these do games equals a blank dictionary, and Id count equals zero. So the reason we're adding these is games, this dictionary is going to store our games. So it's gonna have an ID as a key, and the game as like a game object like this, okay, as the value, this connected is just going to store the IP addresses of the connected clients, we're struggling to set just so it's easier to access later. I don't actually know if we use this, we might. But we'll see. Id count, obviously, it's just gonna keep track of our current ID. So that means what game we should recreate. So we don't override games and say like two games have the same ID because obviously, we can't have that happening. Okay, so that's fine. for that. We're not going to deal with anything threaded client right, now, we're going to go down to our while loop. And this is where we're going to create new games based on new people joining or possibly delete games, actually will delete games from threaded client. So we're going to do right now is when someone connects this, this runs, right, and we run a new so like, once we accept a connection, everything after this runs, so what we're gonna do is we're gonna say ID count, plus equals one, if you noticed me looking away, I'm just looking at my other screen to make sure don't make any mistakes on this. Now, what Id count plus equals one is going to do obviously, it's going to keep track of how many people are connected to the, the server at once. Because obviously, right like, once this happened, we can accept, then we go down the while loop, we start a new thread, and then we wait for another connection. So we're just gonna keep track of that, what we're gonna do is we're gonna say P equals zero, just standing for the current player, we're gonna say game ID, equals, and this is gonna be weird, but just follow along with me. We call it ID count, minus one, integer division two. Now, what this is going to do is essentially, every two people that connect to the server, we're going to increment game ID by one, and what game ID is going to be, or we will say, it's, yeah, we'll add it by one, what game ID is going to do is keep track of what Id or game is going to be. So like, for example, if we have 10 people connected to the server, we're gonna have five games, right? So that's what this line of code is doing. For us, it's keeping track of how many games or if we need to add a new game, because obviously, if we have like six people connected, all of them are gonna be playing each other a seventh person connects, well, it doesn't have a game to join, we have to create a new game for it to join. Hopefully, that makes sense. Okay, so what we'll do next and say if Id count, modulus two, equals equals one. And what this is going to stand for, is if you're going to be player one, or player two, and if this happens is actually we need to create a new game, because this means that we don't have a pair for our new player. So for example, like, say this numbers three, that means two people already playing. So that's one person just connected. So we need to create a new game. That's what this module is to is getting. Okay, so to do that, we're going to say games. Game ID equals game. Game ID. Okay. And I believe it's actually speed capital. So obviously, start at the beginning of this, I forgot to mention I import a game. So from game import game, that is important. And yeah, essentially, what we're doing is we're just going to say that game ID, which is that key in our dictionary is now equal to a new game, so we can access that and add players to it and whatnot. Sweet. So that works, let's actually print out a message here and just say, creating a new game, dot dot dot, just so that in our server, we get some kind of output, and we can have a look at that if something's going wrong. So otherwise, if there, we don't need to create a new game, meaning we have, let's say, three people are connected. So that second game already exists, and another person connects, well, that person has to be a part of this new game. So what we're gonna do then is we're gonna say games, game ID dot ready, equals true. Now, what this means is that the second player connected, so there's two players now connected to our game. So now we can say that that game is ready to start playing because both the players are connected. So that means that they can will obviously play against each other, right? So that's what we'll do, we'll set that dot ready equal to true. And obviously, we're storing all the games on the server side, as opposed to on the client side. And then what we're going to say is we're gonna say P equals one and what this means is putting Error equals one. And you'll see why we need to do this in a second. Okay, so now we're going to do start new thread. Now notice insert new thread, I added two new parameters, P and game ID. So this means the current player, so it's either player zero or player one. And the game ID and game ID is going to stand for which game in this games dictionary, are we playing in this thread client, like, which one of our clients that's connected here is playing which game, that's why we need that. So let's pass that information. So we're gonna pass p, which is either going to be zero or one like we have there. And we're going to pass game ID. And then we'll have that up here. And just remember that threaded client, one of these functions is continuously running for every single one of our clients. So if we have 100 clients, we have 100 different functions of this running in the background at the same time. Okay. Awesome. So that's how that's working inside our threaded client now. Excuse me shut to take a break there. inside of our threaded client, we now need to add some things. So the first thing we're going to add is ID count we're going to global ID count, because if someone leaves our game or disconnects, we're gonna need to subtract from that. So we can keep track of accordingly, like, how many people are connected, how many games are running, and all that stuff. Okay? Now, the first thing we're going to do, when someone connects to our, what do you call it, our server is we're going to send them what player there. Remember what I was saying in the scheme class, or in this network class, sorry, then when we connect, we're initially just going to decode a string, that's either going to be zero or one to tell us what player we are. Okay, so what we're going to do is we're going to send con dot send str dot encode P. And I believe it should be actually string P. Like that, so that we know for player zero or for player one, that's the first step. Next, we're gonna say reply equals a blank string, want to say while true. And this is where we're going to start doing some more serious stuff in here. So the way that it's going to work in terms of sending string data from a client to our server, is we're going to send one of three different options we're going to send yet we're going to send reset, or we are going to send a move, and the move is going to be like rock paper or scissors. So if we send get what that means is we want to get the game from the server. So we're going to send that every frame, we're going to send get a string get, and then the server is going to look, it's going to say okay, what are you sending you're sending get, Alright, we'll send you back the game. That's how that's gonna work. Or another option is reset. Reset means reset the game, the game is finished, both players played, reset, and that's going to be sent from the client side, because the client knows when we want to reset, right. The last one is a move, same thing when the client makes a move. So like rock, paper, scissors, if they are allowed to make that move, which will check on the client side, we'll send that move to the server, the server will update the game accordingly. And then it will send back the game to the client. And that's how that's gonna work. Sweet. So what we'll do now is say, well, true, let's say data equals con, dot receive. And then we're gonna say 4096. And here instead of 2048, which you're using for D code, reason we're doing this is just in case, we're sending too much information that is more than 2048 bits, we want to just double this number so we can get more if you run into any issues that say like pickle data was true onst or like ran out a input, just increase this number, okay, you can literally just do multiply by two in here. And that should hopefully fix the error. If it doesn't work, you can like multiply by four, multiply by eight. And that should hopefully fix your air for you. Okay, so now what we're going to say is gonna say if game ID in games. Now I'll talk about why we're doing this in a second, we're gonna say they're gonna say game equals games. Game ID. So essentially, every time we run this while loop, we're gonna check if the game still exists. And that's what we're doing right? So in this games dictionary, we're seeing if this game ID, which is the key to access, the game is still there. Now, why would we check that? Well, if one of our clients disconnects from the game, we're actually going to delete that game from the we call it the games thing. Now, what that's doing for us, excuse me is not only like keeping track of our memory, which means that we're not going to just continually keep creating games. So like Sarah server ran for weeks, and we never deleted any games, then we probably run run out of memory on our computer, right? If we're playing a lot of games, but it's also going to tell the other client that was connected to that game that, hey, this game no longer exists. That means the other person must have disconnected from it. So we have to do something accordingly. Go back to the menu screen right. Do something like that. Okay, so let's we'll do there. And then we're going to say, in here, as I say, if not data, we're gonna break this similar to before. So I'll go through it a bit quicker. We're gonna say else. And now we're gonna check the three different things that could have been set. Right? So we've received the data. So we're going to check if we got reset and get or if we got a move, first thing we'll check, we'll save data equals equals reset. Okay, then we're gonna say if data does not equal, get, and then else. Sorry, this should be an lF Alec data does not equal get else we'll do something else. actually do anything else? No, we don't. Okay, so if data equals reset, what we're gonna do is we're gonna say game, dot reset, right, because we already have the game. And if we look in here, what resets doing is essentially it's resetting both players one so we can play another game. really straightforward for that. Next one, if data equals get, what we're going to do is say, gain. Or if data does not equal get sorry. So if it didn't equal read, reset, and it does not equal get, well, then it must be a move. So it means we're either getting Rock Paper, scissors, so we're going to send that move to the game to update it. So to do that, we're gonna say game dot play. And then we're gonna do with the current player number, which is P, and then the move, and the move is going to be whatever this data is, right? So it'll be data. Okay, and then otherwise, so I guess after that, what should we do here? We'll say, reply equals game. And that what we're going to do is we're gonna do con dot send all we're gonna say pickle dot dumps, and not reply. Okay. And what this is going to do, let me just make sure I didn't run into any errors here is simply going to package up our game into that nice sendible form, we're going to send it over to our clients, clients going to receive it on Piglet, and then use it to obviously make moves and do different things and draw to the screen and all that. Okay. Alright, so I think that makes sense. We can go through it really quickly. What time we got 25 minutes. All right. So we'll go through really quickly, essentially, what's happening. When you connect, we're going to check if we have an even amount of players or an automatic players, if it's an automatic players, when you connect, that means we need to create a new game. So we create a new game. If it's not, that means we need to assign you to a game. So what we're going to do is make the current game that only has one player in it ready, we're going to assign you to that and start a new thread. When we start the new thread, what's going to happen is we're going to send to the client what player they are either player zero or player one. And then what we're going to do is we're going to constantly receive string data from the client. If the game still exists, then what we'll do is we'll check if they're sending us reset, get or remove, they're sending us a move, we'll make that move the sending us reset, we'll apply that reset to the game. And then we're just going to constantly send back to them the game object. And now what we need to do is just really quickly add some statements in here. So that if some of this stuff doesn't happen, we have like a catch for it. Okay. So what we'll do here is we're just going to simply say else break. Okay, that should be lined up here. And we're just gonna add a try and accept up here. So we're gonna say try, and we're gonna indent all this by just highlighting and pressing tab, let's say accept, and then pass. I think that Yeah, no, not pass or accept and then break, just in case you know, something goes wrong with this data dot receive, we want to make sure the server keeps running. So we have that try and accept. And then underneath this accept, in line with the main function indentation, what we'll do is if we break out of this while loop, we need to close the game and delete it. So to do that, is actually we're going to print some on my ROM file here. We're going to print last connection. And then we're going to print What do you call it? closing game. Okay, actually, we can print that game ID to see what game ID we're closing. So say last connection, closing game game ID, okay. And then we're gonna try to delete games. Game ID. Otherwise, we will accept and pass. Okay, and then underneath here, last thing we're gonna do is gonna say ID count minus equals one. And we're going to say connection dot close. Now that actually think about it, we should probably put this closing game only in this try after we delete, just so that we don't we only close the game once we don't say we're closing the game twice. Okay, so what we're doing down here essentially, is if we break out of this while loop so for example, if the game no longer exists, we're going to break if something goes wrong with this getting data so like the player disconnected, we're gonna break we're gonna say lost connection. We're gonna try to delete that game. The reason we have this try here is because if both players just can At the same time, one player will delete the game before the other. So if we try to delete a key that doesn't exist, we're gonna run into an issue. So we try that. If that works, we will say print closing game, and then we'll say that game ID, otherwise we're gonna pass, we're gonna subtract from the ID count, and we're gonna close the connection. Sweet. So we're rolling, we're going pretty fast here. Now all we got to do is code the client. Now, this is probably the most amount of code, I think it's about 100. lines, it just is a lot of drawing stuff. Okay. So I'm into your break, we'll be back in one second, and then we're going to code the client. Alright, so I'm back out and we've got about 150 lines to write for this file. It's pretty tedious, because a lot of the stuff has to do with the drawing, like we need those buttons to be working. We need, like all that text to be showing up. So that's like 90%, or not 90%. But like 70% of the code are about to write is just going to be cosmetic stuff. But I mean, what do want me to tell you, that's what we need to do if we're going to make an online graphical game, right? So let's start by just coding a class. And this is going to be a button class, just that when we have those three buttons, you know, it just makes things easier. So we're gonna do our net. What do we need the niche, we're gonna go for text. Sorry, coding in the wrong file, text x, y, and color. And we're just gonna say that the width and the height will be uniform in here. And we'll just make it the same for all of our buttons. So we're gonna say self dot, text equals text. self dot x equals x. self dot y equals y. And self dot color equals color. Okay, sweet. We'll also add a width and a height here. So we'll say self dot width equals 150, self dot height equals 100. And feel free to play with these numbers. That's just what I decided. By the way, guys, I just really want to say this. I'm not focusing on how good this game looks. I know it looks like crap. But you guys I know can go through and tweak the colors and tweak the positions and all that. I still want to focus on that because I want to get the hard stuff out of the way in the tutorial. Okay, so let's do a draw method in here. Pretty straightforward. We're just gonna do pygame dot draw, dot rect. And then for the rectangle, we're gonna take window, which is a parameter for the draw, and then we're gonna do, what should we do color, so self dot, self dot color, and then we're gonna need that rectangle position, which is going to be self dot x, self dot y, self dot width, and self dot height like that. Okay, and then I guess, let's see if there's anything else we need to add to that, no, that's fine. We're going to find a font. So we actually need to make sure you just add this to the top pygame.font.net. Okay, make sure you get on that. And we're gonna do font equals pi game, dot font dot s, s y s fonts should help you spell font correctly. And then here, you're gonna pick your favorite fonts. I like Comic Sans. I'm gonna make this. How big should this be? Let's make it 40. And then what we're gonna do is we're gonna render some fonts, we're gonna say text equals plot dot render. And we're gonna put self dot text, we're gonna do one, and we're gonna do the color, which will be I guess, in this case, black or white. 2552505255. Okay, next, we're going to draw this on the screen. Now we want this to be centered on the button. So I'm going to do some like, decently complicated math. It's not really that crazy, but we're gonna say window, Blitz text, and then we're gonna say, self dot x minus is it minus notes plus self dot x plus in brackets, and we're gonna round in these brackets. I know this is confusing, or any self doubt with over two, minus round. And we're gonna say txt dot get underscore width, over two. Now what this is doing essentially, is we're starting at our exposition, but obviously, we want our text to be centered. So to center our text, we need to know not only the width of the container of the button, but the width of our text. So we're going to get the width of our text or our button, we're going to subtract that from the width of what do you call it our text. So that way, it should add like 20 or 30 pixels from the left side to our text center. Okay, for the why we'll do a similar thing. So inside makes you don't mess up these brackets inside here. We're just gonna actually copy this. And we're gonna paste it right after comma. And we're simply gonna say self dot y, plus round self dot height. Okay, plus text dot get underscore heights, or minus txa. gunners get height over two, and that should center our button. Yeah. Okay, next, we're gonna say define, click, we're going to add a position here. This is just going to tell us if we clicked on the button or not. So it's a really basic if statement here, so we're just gonna say x one equals pa zero and y one equals paused one. Now we're gonna say we're gonna say if self dot x is less than or equal to x one less than or equal to self dot x plus self dot width. And self dot y is less than or equal to y one less than or equal to self dot y plus self dot height. I believe that's correct. Let me just check this. Yep, that's correct, then what we'll simply do is we'll return true, indicating that we did press the button, otherwise, we will return false. Now, I know I'm speeding through this, but it just because it's really basic pygame stuff, and we're doing online games. So make sure I change that. So I don't want to focus too much on the cosmetics. But essentially, what this is doing is it's checking if the coordinate which we're going to pass in here, which is going to be a tupple of x, and why of our mouse position is actually in the button. And the way we're doing that is we're saying, well, we go on the x, right, we check if it's greater than the x, we check if it's less than the x plus the width. So like if it's in between the little box, and then for the y value, we do the same thing. But we're checking vertically to see if it's in that box. If you don't understand that I have pygame tutorials where I go through like collusion and how all that works. I'm not really going to talk about that right now. Okay, sweet. So we got that working. Now what we're going to do is actually, let's see what I want to code now. Let's code the main function, and then we'll get into Redrow window. So the first thing we're going to do is we're gonna define those three buttons that we're gonna have at the bottom of our screen. So Rock, paper, scissors, do that we're gonna say buttons equals, and we're just gonna make three buttons. First button will be rock, and say rock, we're gonna start it at 5500. And then we're just going to go and give it a color of 000. Okay, we're gonna create another button. Let's say button. And then we'll say, scissors. We'll give it a, me just check here. 250 as next 250 as an X 500 as a why, and for the color. For that, I gotta check what color I made this. I believe that I made that red. Okay, so the 255 00. And then one more button. Can anyone guess what this one is going to be? It's going to be paper, we're going to put this out of position of 457 go here for 5500. And we will simply make it blue, or green. Sorry, 02 55 zero, so red, green, blue. Okay, sweet. So that should be at for our buttons. And now we'll get into the main function and start coding some stuff, the first thing we're going to need to do is we're gonna need to say run is equal to false or equal to true, I'll just do that. We're gonna say clock equals pi game dot time, dot clock. Capital, see here, my bad. Okay, next, we're gonna say n equals network. Right, because we're importing network up here, we're gonna do a very similar thing to what we did before in the previous tutorials where we just connect initially by doing that initialization, and then we're going to say, P equals, actually player equals and dot get P, right? And you should already have that method. It's just returning that, like, connect what we connected to, right, so when we connect, we get the player number, which is either zero or one. So we need that. Now it reminds me, it's going to be number, so we got to put an inch around this so that we can compare it with other integers. Okay, and last, we're going to just print just so we have this you our Player, Player. Now this just indicates to us like when we initially run, if we know where zero or one just to make sure everything's working fine. Now we're gonna make a while loop running, say, sir main game loop, we're gonna say well run. And then in here, we're gonna do clock dot tick 60. Very similar to what we've done before, guys, I'm gonna start adding some new stuff in a second. Okay, so now that we've done this, it's time to start actually connecting and asking the server for information. So what we should be doing here is every frame, we should be asking the server to send us the game, especially at the beginning of this loop, because right now, we haven't actually created a game class, right? We need to get that from the server. So we're connected now, we know what player we are. So now what we can do is we can try to get that from the server. So to do that, we're gonna say game equals n dot send. Get and that's literally as easy as it is. We just need to do an accept. And then we'll just when you call it will say run equals false, and also print couldn't get game. Okay? And the reason we're doing this and we're gonna break as well, is because when we if we Send this and we don't get a response from the server, that means the game doesn't exist. And what what if that happens? Well, then what we should do is we should exit out of this game, we should print saying we couldn't get the game. And then we should try to reconnect or start a new game with someone else. So this main function is going to be like the actual game running. But once we exit of this main function, we're going to go to a main menu. And the main menu will allow us to choose like we want to play against, and a bunch of other stuff as well. Okay, you guys will see that later. Okay, so let's do that. Next, what we're gonna do is we're gonna say, if game dot both went. Now, what we're going to do here is if both players went, well, we're not waiting for anything. Now, we need to see which one one. So what we're going to do here is going to check which player one and we're going to display that message accordingly on the screen. So what we're going to do, initially, we're going to redraw the window. The reason we do this right away, is because we want to make sure that if both players went, we're updating the window and on the window, it'll check like if both players have gone like in this redraw window, and it'll draw the player moves for us. So you guys will see how that works in a second, we're going to do a delay when we pygame dot time dot delay 200. And now what we're gonna do is we're gonna try game, sorry, game equals n dot send, reset. Now, why we're doing this, obviously, is because, well, if both players went, we need to tell the server to reset those player moves. Right. So inside of game, if we call reset went, we're just gonna reset it so that we were able to play the next round after, okay, we're going to accept except, of course, I can't spell that. We're gonna say run equals false, we're gonna do the same thing as before, we're gonna print couldn't get game. Couldn't get game, and we're gonna break. Okay? Now under this, so after we send that reset, now what we want to do is want to display a message on the screen indicating whether player one one or player two one or like if you want, or if the other player one. So the way we're gonna do this, and it's actually a decent amount of lines is we have to like render font and then we get to determine where we're gonna draw the font and what's going to be on the font. So we're first just gonna start by defining thoughts. We'll say font equals pi game, dot font dot s, why is font Okay, in here, we'll say, Comic Sans, font size, let's go 90 for this one. Now we're going to say if game dot winner, and remember if we go to game winner is going to respond to us with either a zero, a one or negative one. So you have to check if winner is one and player. So whenever our current player is one, then we're gonna say you won. If winner is one, but the current player is zero, we're gonna say you lost, right? So that's how we can check this. So to do that, we're gonna say if game dot winner equals equals one, and Claire eagles, Eagles one, and remember, we got that player from the server. So we know if we're either player zero or player one on the client side. And is actually doing an end. Oh, sorry, or that's what we need to do. Or game dot winner equals equals zero, and player equals equals zero. So essentially, what we're going to do here is going to check if this player one, so we know what player we are. And we know what player one so if that coincide, like what player we are and the player that one, then we'll print out and we'll say, or we'll put on the screen you want, right telling that client they want. So we'll say text equals font dot render. And then here we simply say, you one exclamation point, and then we can just do one, and then a color and obviously color we just do like red like that. Okay, on the screen. Okay, so else, actually, l if, and now we're gonna check if they last washy, I think we can do this easier. We're gonna say l if game dot winner equals equals negative one. So if we type, what we'll do here, is we'll say text equals font dot render. And we'll just say tie game. exclamation point one. Again, we'll put that in red. Okay, and now else, so if we didn't win, and we didn't tie we must have lost so we can literally just copy this and it will just say you lost as the text. Okay, so you lost that. Sweet. And now what we're going to do is just render that font, put it on the screen, so or not render it just put on the screen so say wind up lit text. And now we're gonna do the exact same thing that we did before. To get it in the middle of the screen just be a little bit easier. So we're just gonna say, I believe to any another bracket, so I don't think so we'll say width over two and that's the width of the actual screen. Minus text dot get underscore width, we need those brackets over to do comma. And now we'll just do the same thing with height. So we'll say height over two minus text dot get underscore height over two. Okay, so that's going to put it in the middle of screen, we're going to update the display, game dot display, dot update, and we're going to delay, so pi game dot time dot delay, and I'm going to put 2000 for two seconds, you guys can put whatever you want in here. Okay, so let's break this down really quickly. If both players went, that means now we're going to check who won. So we're going to do is we're going to redraw the window, we're going to what do you call it, apply a small delay of 0.2 seconds, just so that we can see what both players did before it immediately pops up who won and who lost. So actually, let's make this delay half a second, we're going to send to the server reset, we're going to reset both players once the next time that we start playing we can both players are allowed to move, we're gonna say run equals false. If this doesn't happen, if this doesn't work, we're gonna print couldn't get a game we're gonna break. Now otherwise. So like, if this worked, we set the game, we're going to create a font, we're going to check who won. So either we won, we tied it, we lost, we then display that to the screen, ran delay for two seconds, and then we're going to play the game again after. Okay, awesome. So we're almost done. We're just gonna add this pretty actually complex for loop in here. So we're gonna do now we're going to say for event in PI games dot event, dot gets very standard for pagi probably seen this before, we're gonna say if event dot type equals equals pi game dot quit, then what we're gonna do is gonna say, run equals false. And we're gonna say pi game dot quit. So this just means that they hit the little X button on top of this corner. Now we're going to check if they actually pressed their mouse button down. So this is how we're going to check if they pressed a button. That's where we're gonna do now, let's say if event dot type equals pi game, dot mouse button. down, then what we'll do is we'll get the mouse position to do the hovering so if we're gonna say pi game dot pause, pi game dot mouse, dot get underscore pause. So what we're doing here is we're checking if they press right mineral or left mouse button, if they do, let's get the most position. Now, for every single button, we're going to check if we click that button. If we did, we're gonna do something accordingly. Okay, so we're gonna do now I'm gonna say for button in btn. Remember, we defined buttons up here, then what we're gonna say is, if btn dot click, pause. Now, if they did click the position, there's a few things we need to check. Oh, and also, we can check this sir. And game dot connected. Sorry. So what this game connections doing is just making sure that it's not going to let us press like Rock Paper, scissors, unless we both players are on. So just so that we don't run into an issue where we can make a move before the other player connects. Okay, so just add this end game connected. What we'll do now is we're gonna check what our current player is, because this is gonna determine how we send a move. So we're gonna do now is gonna say if Claire equals equals zero, if not, game dot, what do you call it P one went, then we'll do something otherwise, so we'll just put Alice here. And we'll check if not, p two game.pt one. Okay, so what we're doing now, and I haven't coded the rest of it yet, is we're just going to check if we press one of the buttons. So remember, we have that click method in our button that tells us if we clicked on it. So if we do click on it, and we're connected to the game, what we're going to do is we're going to check if our current player is your one. Now, what we're doing is if we're player zero, we're going to check if players here has gone yet, if they've gone, obviously, we're not going to let them make a move, right, because they've already made that move, they can't change their move once they made it. Same thing with player two. So if we're not player zero, we're player one clearly. So that means we're gonna check if player two has gone yet. And if they haven't gone, we'll allow them to move. Okay, so all we're doing here now is we're going to make a move. Now to make a move, remember, we just need to send to the network our move. So we're just gonna say n dot send origin server, sorry. And all we're gonna do is we're just gonna send the text of the button. Now the text of the button will be Rock paper or scissors, right? And that's precisely the move that we're gonna make, depending on what button we're clicking. So it's a really nice dynamic way to do that. Now, once we've done that, right, so if we go to server, what happens here is if we send that we're going to play that move, and we're going to update it on the game, so that the other client when it gets that game board again, we'll have the updated move. You guys will see how this works out. Okay, so that's working well, now all we need to do is just add in line with this, right here is a redraw window, we're gonna give it when we're gonna give it, what else do I need to give it a game, and p, which stands for current player. And that's actually it for and make sure you just call our calling main down here at the end of climb. That's actually it for this main function. So now all we need to do is do redraw window. And we're really close to done. So we got another like 20 lines. And then once we do that, we're actually finished this game. And then we can start testing it out and talking about some more things we can add to it. Okay. So what we're going to do now is, it's actually quite a bit of work is we're going to draw all the stuff on the screen now. So we've done all the logic aspect of it down here in this main function. Now we need to draw everything so it's more tedious and it is difficult. Or we're just going to first start by checking if not gamed connected. Now, this just means if we have not yet had the other player Connect, then all we're going to do is we're just gonna print on the screen waiting for player and we're not going to show anything else. So to do that, we're gonna say font equals pi game, dot font dot s y as Font Name, obviously, it's Comic Sans. And then the, how big should it be? Let's make it 80. Okay, and then we're gonna say text equals font, dot render in here, we're gonna say, waiting for player, dot dot dot, one color, let's do a nice red. And let's actually add true here for bold, okay? Okay, so we're going to put this on the screen. So to do this, we'll say wind dot lit. And we're going to do again, that same I know a tedious thing to get in the middle of the screen. So we're just gonna say with over two minus Tex dot get underscore width. And then we're gonna say height over two minus text dot get underscore height. And actually, we need to make sure we're dividing both the width and the height by two. So let's do that. Okay, that's it for that. Now else. So this means if we actually are connected, both players are in now it's time to start drawing the real stuff on the screen. So we need to draw that. What was it? So actually, let me pop up client for you guys. So you can see what it looks like. Let's run the server. Right and client client. Great. So if we want to see the client, what we should do is we need to draw this, this, this, this and then the three buttons. Okay, so we're gonna have to do these four texts. And the thing is, these text needs to change on like, they're gonna be different depending on what player is looking at it, right. So for example, here, it's showing us what our move is. But notice, it just says locked in for opponents. It doesn't tell us what our move is, or what the other players move is, right? So we need to do that as well. Okay, so to do that, let's start. We're gonna make another font, I'm gonna say font equals pi game, dot font dot s, why is font, Comic Sans size of this font, let's make it 60. And then what we're going to do is I say text equals font dot render. And we're going to do your move. So we're going to start by just doing your move and like opponent move, because those aren't going to change, they're going to stay the same no matter what. And for that, we're gonna do one and the color I had there was a nice cyan, I think, right? So we'll do this, to feel free to change the color. I know, it probably doesn't look the best. And let's just put this at a static position on the screen. So we'll say text. And let's go at 200. Okay. All right, next. So actually still in this else statement, we're going to copy this. Just sorry, what am I doing? Just this text and this wind part. And we're going to put it down here. And so your move, we're going to say, opponent opponents move. Is that a spell that? Let's change that to opponents. And actually, let's just get rid of moves and be too big opponents. And same color, except we're just going to change the x value, so that we draw it at Will you call it 380. Like that, okay. So that's it for your moving opponents. Next, what we need to do is a bit more complicated, because now we have to draw what the actual moves are. So remember, we're obviously we don't want to show the other player what one of the players moves is, unless both of them have gone like we want to know what our move is, but we can't know what the other players movers until we both made a move. So to do this, we're gonna do, we're gonna start by just getting ballplayer moves, we're gonna say game, dot get underscore player underscore move, we're gonna get move zero. And we'll actually we'll copy this and just do move to and change this to one. So let's start by getting the moves. And then now we're going to check if we should show those moves, if we should show waiting or if we should show locked in. Okay, so to do this, we're gonna say if Game dot both went, Okay, like that we're gonna say is gonna say text one equals font dot render. And we're just gonna use the same font as before. And what is going to be is move one, comma, one, comma, and we'll make this black. So 000. Okay, and we'll copy this. And we'll do the same thing except text two, is going to be equal to move two. So essentially, this is saying, If both of the players have gone, well, we can show their moves, because they both made them. So let's do that. And it's just rendering that font, and we'll display the font after, you'll see how that works. So now, otherwise, if both players have not gone, what we need to do is we need to actually, let me just check something for a second is we need to determine if we're going to show locked in meaning the other player actually has gone but we're not going to show their move, or if we're going to show waiting, which means the other player hasn't gone. So to do this, we're gonna say if game dot p one went, and P equals equals zero. So this is saying, if we have gone, and that's our current, like, we are the player, we're player one. So player one's gone, and we are player one, what we're going to do is we say text one equals font, dot render, move on, which is the move we've done, which is fine if we see that, and then we're gonna say one, and color 000. Okay, lF game dot p two went, and is this one, it is actually sorry, game dot p one went, you guys will see how this works in a second. We're gonna say this a text two equals the same thing. Now, this might be confusing, but essentially what this is doing is it's saying if player one is gone, and we are player one, we're gonna say, if I spell render correctly, render, like that. Render, sorry, I got interrupted there. Okay, so if player one is gone, and we are player one, then we want to show underneath like your move what our move is. Otherwise, what we want to show is we want to show that, like locked in, so we're gonna change this to locked in, underneath opponents move because it means player one went, but it's not us. So it's not our move. So that means we want to show it under opponent's moves, you'll see how this works. We're gonna say, locked in like that. Okay? All right, now we're just gonna do else. So this actually just stands for, if game dot p one hasn't, like if they haven't moved yet. We're gonna it's gonna say txt two equals waiting. So we'll say waiting. I believe that's correct. I'm actually sorry, these all need to be text one by one. Okay? All right, IOC is confusing, but we'll go through it after. All right, so we're gonna actually copy this, and we're just gonna change everything to two. So this is going to be P two, this is going to be one, this is going to be two, it's going to be two, and it's going to be two, and this is going to be two as well. And we just make sure that I did that correctly. I believe I did. Okay, sweet. And now we're going to actually show these, we're going to split these on the screen, and we're actually really close to French guys. So to do this, we're gonna say if P equals equals one, so if we're clear one, we'll do is say wind up lit. And we'll say text two, and then we're going to show it, we're gonna show it at 103 50. Okay, now we'll copy this, so Ctrl D, and we'll blit one, except instead of at 100, we're gonna change this to 400. Now we're just going to put an else so if we're not player one, clearly, we must be player zero. So we're just going to reverse these player one, player two. Now, the reason we're doing this is because this is going to be where like player one and player two's moves are shown on the screen. So we want it to make so that for each of our clients, rather than saying like player one, player two, and having one of the clients have their move on the right side, and one of them have it on the left side, we want it to be the same for each client. You guys will see how this works when we actually run the thing. So let's actually just, let's add in drawing the buttons. So to draw the buttons, we could we could draw them in this L statement. Actually, I might be better. Yeah, let's do it inside of this, this else, okay, we're gonna say for btn. In buttons, we're just gonna say btn dot draw, and give it a win. And I think that's actually all we need to do. And lastly, we're just going to update the display. So probably game dot display dot update. Now, assuming I didn't make any critical errors, this should actually be working. So I know this has been a lot of code and a lot of writing but I think I've kept it to just about an hour now actually. And that's actually pretty decent time for creating a game like this. So you guys will see how this works out. Okay, so let's try running our server and see if we got any errors First of all, okay, server waiting for connection server started. Good sign so far. Okay, clients, let's try running it. Client client. Oh name P is not defined when game P. Okay, so what we're gonna do for client, this is a really easy fix just change this to player. And I might have to change. Oh yeah, up here but I do redraw game window as well we got to do win. Game and player. Okay, so fix that. Alright client run waiting for player. all right good sign. Let's run another one. And what do you look at that okay they both launching now so you saw that waiting for player showed up but as soon as we are ready, now both of them are showing up. Okay, so this should be player one, this should be player zero or Player, Player One player two, right? Okay, so let's try this now. Rock ran out input self client received 2048. Okay, so let's have a quick look at why this might be. So I think I might have finally found the issue. I'm actually I don't know if this is the issue Exactly. But we do need to fix this, where I do game dot reset inside of server here it actually needs to be reset went cuz that's what I called it inside here. Reset went so we should make sure we do that. Okay guys, so really silly error here actually on the issue was on the server side here. I'm calling play, right, like game dot play. And so actually, to get rid of six, I was just printing out the exception so I can see what it was. But essentially, play doesn't actually exist because I misspelled something on game, I misspelled it, and misspelled player should be play. So that was the issue I was running into. It just was very difficult to see because it was just accepting it and not like not printing any Oh, just continuing to run the server. So I couldn't find it. But essentially, if we run the server and run the two clients now we should have everything working. I haven't actually tested it. So let's pray. I go paper. Sweet. So it goes paper here. We're not getting locked in over here. So that might be an issue. But let's see if we make something here. That is since you lost and you won. Because we have a slight issue, but it's pretty easy fix. Let's just go up to client, just look through, we're just probably messing something up in the drawing code here. So Oh, that would make sense. Well, we're not actually end up drawing. Yeah. So this, if P equals equals one, this just needs to top back one, one indentation level. And now we should everything actually working fine. So let's try this now client client. And let's go rock. Okay, so that works. But it's not doing the locked in for some reason. So let's check this this locked in portion, close that server and make sure that this is actually working. So that needs to be P two went. And oh, if this one should be working, that was what's confusing. Okay, so actually, so that would just need to be P two went game dot p two went. Let's try this server. And let's go client. And let's run it again. And we'll scissors locked in sweet. So that's actually working and the game is pretty well finished. All we got to do is out of menu screen and we're gonna be done. So let's go scissors. This is a scissors, scissors. That's not correct. We got to fix that as well. Okay. I thought I had everything working guys. I really thought so. Okay, so actually I do I do know the issue it was it's pretty straightforward. So in main here when we check the let's see here the winners where do we check winners? If it equals equals one, because it goes negative one? Ah, okay. So again, no winner needs brackets? Of course it does. So we add that so obviously just subsidiaries guys. So servers running right now, let's run these clients see if everything is indeed working as as it's supposed to be now. Okay, so let's try this paper blocked in scissors. You lost you won. Yeah. Okay, everything's working. Okay, paper, paper, die games. Sweet. Okay, so you guys can really mess around with the timing, you can see how this is working. So the only last thing to do now is watch this. If I disconnect, disconnect both of them. So what we're going to want to do now, if that happens is instead of just completely like exiting the game, we're going to want to bring them to a menu screen where they can just click to reconnect. And this is a really, it's actually really easy to do. So what we're going to do is we're just gonna define another function. I'm gonna call this menu underscore screen. Okay, and in here, all we're going to do is have a really basic while loop that just checks if you click something, and all it's going to do there is click the Run that mean functions we're gonna do is gonna say run equals true. Or say well run. Okay, and then in here, we're gonna say for event in PI game, dot event dot get, and then obviously, we're gonna check if they click Exit. So if event dot type equals equals pi game dot quit, then we will do is just do pi game dot quit, Ron equals false. Otherwise, if they click any key, so we'll say if event dot type e Calls equals pi game dot, I will just say, most button down, so I should just get it, click the mouse button, then what we'll do is we'll simply say, run equals false. And at the bottom of run equals false, what we're going to do is we're just going to call main. So all this is going to do and we'll call menu underscore screen here. Say while true. Comma, menu screen. Okay, I'll go through this in a second. We say while true menu screen, okay, so what we're going to do is in menu screen, if they click something, we're going to call the main function, which is simply going to what do you call it do all of this stuff in here. And then if they exit out of the main function, so if you say like run equals false, because they disconnected, it'll just rerun the menu screen, which means that there'll be prompted to reconnect to new game. Awesome. Well, we'll do it here. It's one o'clock as well. So say clock equals pygame dot time dot clock, give it a tick. So clock dot tick 60. We'll do we'll just draw something in here. We don't need to use the redraw window function will just do font equals pygame dot font. dot. That's why as font in here, we'll go Comic Sans will go 60. And then we're going to render some texts, we'll say text equals font dot render. In here, we'll simply say click to connect, our click to play, exclamation point, one, some nice red text. And we can just continually Actually, we can just window fill. So wind fill, and we'll just fill it with white 00. Or what I say gray, actually 128 128. And we should just Where's when do I define it up here somewhere? Yes, I do. So that's sweet winds up there. So what we could do is just fill the window, run into this while loop, put some text on the screen. We may actually have to fill this every frame. Let's get rid of one of those brackets I created. So let's fill this every frame actually. Okay, so we'll fill it. We will blit this font. So let's say when dot Blitz text, and you don't for right now, I don't want to do it. We'll just do it. statically let's do like 150. So tonight at the top of the screen, actually, let's go 100 200 Okay, pygame dot display dot update. Like that. Then if they click something, what should happen is that you break this loop, they should be brought to the main thing. And yeah, that should hopefully be working for us. So let's try this. Client. Click to play. Okay, little little sketchy on the click to play but let's see if we click the play. Okay, waiting for player. So this is what actually what I wanted. So it says waiting for player. We're gonna wait for someone else to connect. Okay, boom, connected. Sweet. So now we're ready. So let's just run a game. Let's go rock scissors. Now let's just see what happens if we click x. This one goes to the menu screen where it says click to play. And it can be what do you call it play against someone else, right and that's exactly what we want it. We may also want to have like a back button to go back. But I'll leave that to you guys. So guys, I'm gonna leave the tutorial here. If you guys have any questions or run into any bugs or anything, please let me know this is by no means like a full complete game. There's still obviously a lot of things that could be added to this. I hope that you guys learned how to make an online game. I find this stuff really freakin cool and really interesting how you can have like a ton of different clients connecting together. And that being said, I'll see you guys in another video.