Hi, welcome to amigos code. My name is Nelson. And in this crash course, I'm going to teach you everything you need to know about Spring Boot Spring Boot. It's an amazing framework for building Java applications very fast. Recently, Netflix just announced that they'll be switching their entire back end to Spring Boot. And this is because Spring Boot is so solid, that there's no need for you to reinvent the wheel. So they provide things such as connectivity to databases, jetty servers, metrics configuration, and pretty much instead of you having to configure the low level code to get up and running, you can simply use Spring Boot and get off the ground very quick. So first, I'm going to show you exactly how to use Spring Boot dependency injection, and how to implement to an interface where we will have an in memory database, and then I'm going to show you exactly how to connect to a real database running on Docker. So without further ado, let's get started. Alright, amigos, welcome to amigos code. In this video, I want to teach you exactly how to use Spring Boot 2.0. Spring Boot is by far one of the best frameworks for building applications in the Java world. So if you want to build an enterprise application, you can use Spring Boot, or if you want to prototype an idea and see whether you know, it works that you can use Spring Boot because it makes it very easy to build applications. And basically, Spring Boot provides you a platform for building back end applications. And not only that, you can also build web applications as well. So in this video, let's go ahead and build this awesome API, where any client can submit a request. So these requests could be a get request, post, delete, and put. And then we're going to take that request, and within the API layer or control layer, so this is where we receive the requests, we're going to send that to the service layer. And basically, the service layer is responsible to handle all the business logic that you may have within your application. After you perform some business logic, then you might decide to use a database to perform some various CRUD operations. And basically, so this layer right here, so this layer is responsible to connect to any database of your choice. So the cool thing about Spring Boot and dependency injection is that you can start with an implementation. And then if you want to switch to a different database, you simply have to change one line of code. And I'm going to show you exactly how to do that with the pendency injection. So after you submit the actual request from any clients, so the clients could be an iOS app, a react or even an Android app, the request will go through all these layers, and then go back with a response to the client. So the response could actually be, for example, a JSON payload, or an image, or a status code of 200 500, so on and so forth. So if you want to learn the best framework for building Java applications, stick to this video, because there is a lot to cover. And I'm pretty sure that after this video, you will be very comfortable building back end applications with Spring Boot. So let's go ahead and get started. So the very first thing that I want you to do is to navigate to this website start.spring.io. And basically, this website, you can see that it's it's titled spring initializer. And basically allows you to bootstrap your application by picking dependencies and configuring the actual project. So go ahead and generate a project with Maven, we can see that you can be Gradle. And then you have the option to code with Java kotlin or groovy. So I'm gonna stick with Java. And then for the actual version, make sure that it is above 2.0. So I've got a video on 1.5. And basically, I just want to make sure that you guys have the latest version, so that you can use it within your latest projects. So then go ahead and click on this link right here. So switch to the full version, basically, right here, you can, you know, configure your project metadata. So go ahead and change these according to your company or project name. But for this tutorial, I'm going to leave everything as is apart from the Java version. So I'm going to pick Java 11, because I do have it installed. But if you don't have Java 11 go ahead and pick Java eight because it will also work. Then, if you scroll down, you can see that right here you have a bunch of dependencies. And this is why springboard is pretty much one of the best Java frameworks for building applications. So they give you a lot of flexibility with these dependencies, which simply means that you can install one of these dependencies and start coding right away instead of you having to configuring and you know, setting up things. So basically, you just have to install these dependencies, and then start implementing whatever you want. So you can see that we have a bunch of sections right here. So web server web applications with spring MVC, and Tomcat at jersey WebSockets, template engines, security, so they make it very easy for you to configure security within your applications. So you know, it saves you the hassle of having to implement security the right way. So basically, they're doing the difficult job, which is implementing the security, and then giving you this nice package that you can just plug in play. And then you have SQL, so my sequel, h2 JDBC, Postgres flyway for database, migrations, Mongo, and then you can scroll down, you can see that they have a lot of great things. So for this video right here, let's go ahead and focus on picking this dependency right here. So web server web applications with spring receipt and Tomcat. So I'm going to take that and then generate a project. So right here, you see that I've got this demo zip, which I'm going to open in my desktop. There we go. So now I'm going to click on this zip folder. And if I delete the actual zip, you can see that now I have this folder right here. So for this video, I'm going to be using intelligence, which is by far the best ID. And if you want to learn about intelligence, go ahead and check my video on YouTube, which I show you how to download, install and configure IntelliJ properly. And if you are using NetBeans, or Eclipse, this will also work. So inside of IntelliJ. So I actually recommend you to download and install IntelliJ if you don't have it to follow along, and I'm pretty sure that you're going to learn great things with IntelliJ throughout this video. So what I'm going to do now is pretty much click on open. And then navigate to desktop, and then open up this demo folder, and then open up the actual POM dot XML. So I'm going to open that up, and then open as project. So I'm going to allow and just give you a second, Maven is resolving the dependencies for this project. There we go. So that's nice and done. So let's go ahead and explore this project. So open up demo. And inside demo, you can see they have couple of folders, but the ones that we really care about are the palm dot XML. So if I open that up, and see that this is what you saw when configuring the project with spring initializer. So you saw the group ID artifact, name, and then version. So this is the version right here. And then this is Java 11. Basically, the actual dependency that we picked was this one right here. So Spring Boot starter web. And by default Spring Boot ships with Spring Boot starter tests for writing unit and integration tests. So go ahead and close this because we don't need it. And open up the source folder. So open up source, and then main. And you can see that you have Java, and then inside you should have a class called demo application. And inside of this class, you have this public static void Main method. And this is how you pretty much just run your spring application. And if I play so make sure you play this. Just give me a second. You should see that I have spring up and running and you can see that it says that Tomcat started on port 8080. So right here, we could change this port but this is the default port for Tomcat. So I'm going to stop this and you can see that everything is up and running fine. I'm gonna stop this and then collapse this. And then inside of resources, you have static templates and application properties. So start is where all the web resources live for web applications. And then you have templates. And this is where you have all the templates for your web application. So usually, you would use something like mustache or ej s. And then you have this application that properties. So this is where all the properties for your application do live. And the cool thing about properties is that you can define properties for different environments. So you could have a demo environment, a test environment and a production environment with different values for the actual properties. So it's pretty cool. So I'm going to cancel out of that. And now that you know the actual structure and make sure that you can start the application, you've successfully managed to start a Tomcat server with Spring Boot. So now let's go ahead and implement our API with all of those resources, controllers, services, and defining a database as well. So if I go back to this diagram, so remember that I said we had the API layer controller, or controller layer, and then we have service layer for business logic, and then database for data access. So let's go ahead and start things right here. So we're going to start right here. And in fact, this I mean, put a dot right here, so you know what we're doing. So if I remove that, basically, let's put just a.so, we know where we are, with things. So right here. And then if I collapse that, so basically, we're going to implement this section first, and then move our way up. So basically, we're going to implement one step at a time, and then see everything working fine, and then implement some other functionality. So let's go ahead and go back to IntelliJ. And the first thing that I want you to do is to create a package. So let's go ahead and create a package. And right here, simply call it API. So this is where the API will live. Go ahead and create a second package, and simply say, model, go ahead and create a third package, call it service, go ahead and create a fifth package or actually a fourth package and call it so we need the actual da Oh, and I think this is it. So we have API d o model and service. And basically these packages are representing this diagram. So if I go back, and perhaps you haven't seen me, like right clicking, so new, and then a package. So basically, I tend to use a lot of keyboard shortcuts. And this is how I am productive with IntelliJ. So if I press Ctrl, and then enter, you can see the keyboard shortcut down below. And basically, then that gives me the ability to create a new package. So the same if I, for example, create a variable. So if I say var, and then ELO equals to two. And, and then if I press Command, and then why you can see the keyboard down below, right? So I've just deleted that line. So also, let me go ahead and say, Okay, so now what we need to do is actually define our model. So what is the actual model for this application? So if I go back to this diagram, so let's go ahead and define a model. So I'm going to copy this stereotype. And you can grab this diagram, you can find the link in the description below where you can download and see exactly, you know, everything that we're doing here. So basically, the actual model, so oops, so the model for this tutorial will be a person. And basically a person will have an ID. So when ID. And let's keep things simple and have like, let's say a full or actually name, just like that. So obviously, you could have more properties. But I want to keep it simple for you see exactly what's happening. And so things you know, become really obvious to you. So we have this model right here called person. Let's go ahead and define this in actual code. So go back to IntelliJ and in side of the model package, go ahead and create a new class and simply call this person. Right, so the kind it's a class, and then press enter. So now simply go ahead and say private final, and then the ID will be of type U ID. And simply call the Id go ahead and simply save private final, and then string. So this is the actual name. And then I'm going to add these two constructors. So you can see I'm using keyboard shortcuts again, and then the getters. So just like that, and there we go. So now we have a model that we can work with. So if I go back, so now we have to define the actual database section right here, right, so let's define the actual interface that will allow us to have any implementation for our database. So inside of the DA, Oh, go ahead and create a class, and then simply save person and then the A Oh, so instead of like class, change this to an interface. And this is the actual interface where we're going to define the operations allowed, or the actual contract for anyone that wishes to implement this interface. And the cool thing about it is that we can then use dependency injection to switch between implementations with just one line of code. So let's go ahead and define our very first method. So for our database, we want to insert a person into the actual database. So we will simply return an integer. And basically, we're going to mock a database using like a list. And basically, we will return zero or one depending whether the actual data is persisted to the actual database. So let's simply go ahead and say insert, and then person. And this will take a user ID, which is the actual ID, and then a person just like that, and that with semicolon. Now, let's also go ahead and create a default method. And basically, this will be the same thing, or actually sorry, this will be integer. So it will be the same thing. And let's simply call this ad and then person. And right here, we will simply take person, right. And what this allows us to do is to actually generate the you IDs, ourself, or the actual ID, so you would, and then let's call the ID equals two, and then UAT, dot and then run the mu ID, and then simply say, return. And then insert person passing the ID, and then the actual person. Yep. So basically, we have two methods, one that allows us to insert a person with a given ID, and the other one without an ID. And the ID is simply randomly generated. Now let's go ahead and create a class that will implement this interface. So open up the DA o package, and then simply create a class and call it person and call it fake. And then person data, access, and then service. And then this guy implements and then person, da, oh, just like that, and then implement the methods. And we need to implement insert person, right. So right here, let's go ahead and define our list. So private, and then static. And then and then list. And this will be a list of person, simply quality b equals to a new, and then array list just like that. Or, in fact, we could even initialize this inside of a static clock, if we wanted. So now to insert a person, all we have to do is simply add to this database right here. So for the sake of this, simply go ahead and say dB, dot and then add, and then new and then person and simply take the actual ID, and then simply say person, dot and then get name. Right. So And finally, let's simply go ahead and return one. So we know that it always works. So the insertion always works. So now let's go ahead and actually define the actual service. So inside of the service package, go ahead and create a new class. And then simply call it person and then service. And right here inside of this class, let's see if we have a method to insert a new person. So simply go ahead and say public, and then int, and then and and then person. And basically, this will take a person. And what we want to do is simply say return. And right here, we need to actually get a reference of the actual person, da Oh, so let's go ahead and simply say, private, and then final, and then person, da, oh, and make sure that you get the actual interface and not the concrete class. So don't get the actual fake person data access service, because I want to show exactly how to use dependency injection. So then what we need to do is added to the constructor. And now we can simply say person, da, O dot, and then insert, and then person. So remember, we had two methods. And if I go back to my interface, so person to you, oh, and in fact, I need to call this the same. So let's be consistent. So person, so insert person, actually. So now you can see that the error went away. So basically, we have the option of providing the ID or not. So in this case, let's go ahead and have it, you know, randomly generated, because we don't care. But if you need to generate the ID yourself, you know that you can do it. So now that we have the service done, let's go ahead and implement the actual API. So inside of the API package, go ahead and create class, and simply call it person. And then resource. Or actually, let's go ahead and save controller. So in Spring Boot world, we tend to name these as controllers. So and then simply say, OK, and then let's go ahead and also have a reference to the actual service. So private, final, and then person service. And then right here, we need to add this to the constructor. And then let's simply go ahead and have a method that adds a person, so public, and then simply say, void, so we don't want to return an integer in this case. So we want to, so we want to return a status code of 200. Or if anything fails, we can pretty much throw an exception. So or you could also have your custom exceptions, if you wish. So let's go ahead and simply say add, and then person. And this will take a person, so a person just like that. And then what we need to do is actually say person service, dot and then add person, just like that. So up to this point, we simply have normal Java classes. And to be honest, we're not even using spring framework at this point. So let's go ahead and configure everything to start using spring framework. So let's go ahead and open up the actual da Oh, so fake person data access service. And you'll see right here inside of the actual service, we have a reference to it. So person, da O. And basically, we are trying to use dependency injection. So if I was to run this, this would wouldn't work because this person deal is not instantiated. And you know, there's no way for this constructor to know about it, right. So this is where we use annotations to instantiate beans. So open up the fake person data access service. And the way that we tell spring that this class needs to be established, created as a beam so that we can inject it in all the classes is simply by saying act and then repository. Right. So you could also say add, and then component. So this is the exact same thing. But repository makes it obvious that this class is served as a repository. Right. So now that we have a repository, let's go ahead and configure the actual service. So for service, you might take a guess. So this will be add and then service. Right. And you could also use a lead component if you wish. But I usually prefer to be, you know, specific. So anyone looking up my code, know exactly that this is a service. So now that we pretty much annotated the actual data access service, and right here we are injecting right so we are injecting into the actual constructor. So the way that we inject is simply saying add and then auto wired. So basically, we are auto wiring into this interface, right. So now, because we can have multiple implementations of this interface right here, we must have a way to distinguish between them, right. And this is when use at and then qualifier, right? So add qualifier. And then right here, you can give it a name, so fake and then da O. And basically, I need to go back to my fake person that access service. And then right here, I'm going to name this as fake. And then da O. And what this allows me to do is to have multiple implementations. And basically, all I need to do is for example, if I have, for example, a Postgres or a MongoDB implementation, I simply say Mongo, just like that, and then I don't have to change anything. So let's go ahead and use the fake da Oh, and now this is why it's correctly. So finally, let's go ahead and open up the actual API package. And then personal controller. Let's also go ahead and simply say, at an auto wired, basically, springboard injects the actual service into this constructor. And if you want to learn more about dependency injection, go ahead and check my channel, I made a video specific on dependency injection, and why it's important for you to know about it. So now, remember that I said that this class right here, so the API, if I go back to our diagram, is this one right here. And right here, we can specify HTTP methods. So get post, delete, and put. So these clients right here, right, so they have to issue some requests to our back end. So right now, there is no code that tells that this method right here will be served as a post or put or get or delete. And also, this class is not available as a rest controller. So to do that, we need to use a special annotation and simply say, add, and then rest controller, right. So this is a rest controller class, that we can have some methods, and then expose some endpoints that clients can consume. So in our case, what we want to do is have this method right here to be served as a POST request. So basically gets is for retrieving data from your server posts is to adding a resource to your server, put modifying, and then delete for deleting a resource, a resource from your server. So to tell spring that this method will be used as a POST request, we'll simply use the annotation at and then post and then mapping. And this is all we have to do now. So obviously, we want to add a person from my client, right? So go ahead and download postman. So postman allows you to pretty much just serve as a client, because we don't have, for example, a react application or an Android app, or you know, you we don't have any, any any client, right. So we can use postman as our client, right. So go ahead and download postman, it's an amazing client. And what we need to do is actually send a person to our server. So before we do that, so let me actually clear everything here. And basically, go ahead and say post, and then this will be local host, column, and then AD AD. And then for slash, and then simply say API, forward slash, and then v1, and then person, right. So after you define the actual endpoint, go ahead to the actual body, and then simply say raw, and then instead of text, go ahead and send a JSON. So we want to send a JSON payload to the actual server. And remember, we have name, and let's say that this is James and then bond. So basically, we want to send James Bond to the server. So in order for us to do that, we have to do few things. One is we have to define these properties in our pojo so that when we send this JSON spring knows to take this property and then convert that into a jar. Have a class, right. So in order for us to do that, what we need to do is open up person. So inside of the model package, open a person. And then you'll see right here in the constructor, let's go ahead and define some properties. So JSON property, and this will be the ID. And then right here, so if I put this on your line art, and then Jason property, and this will be the actual name, right? So you could also define more properties. But as I said, Let's keep this simple so that you understand exactly what's going on. So if I open a postman again. So right here, you see that name. So this name right here matches the property that we have in our class person. And if we wanted to send the ID, so we would simply say ID and then pass, you know an ID, but we are generating the ID from the server, therefore, we don't need to send it. Now what I need to do is actually tell that we are receiving this JSON payload from the actual body. So inside of person controller, go ahead, and you see right here where you add a person. So right here, simply annotate this with ADD, and then request. And then body, right. So we are simply saying that we want to take the request body, and then shovel that inside of this person. And then because we have, so right here, so because we have these, this property right here, we will simply turn this JSON object into a person. That's what we're saying. And the final thing that we have to do is actually define this path right here, right? So right here before rest controller simply say at and then request. And then mapping. And the actual mapping will be API, v1, and then person. So this is all you need to do in order to create your very first endpoint with Spring Boot. Now, what we need to do is actually test it. So let's go ahead and simply play the application. So as you can see, Tomcat started on port 8080. Now, if I open up postman, and then simply send this request right here, you can see that we have a 200 status code. And this means that the request went through fine. Now, obviously, we don't have a way of testing this, right, because we don't have an endpoint to retrieve people from our database. So let's go ahead and define the functionality to get people from our database. So let me go ahead and open up the IntelliJ. And if I collapse that, so go ahead and open up the person da Oh, and let's go ahead and say that this will return a list of person and say, select all people. And then let's go ahead and open up the person data access service. So we need to implement that. And then right here, what we need to do is very simple within the actual database, and open up service. So right here, simply create a method public. And then list of person, get, and then all people and then this will return person, the Oh, don't and then select all people. So now we need to define the actual resource or the actual method that will serve as the get request. So simply say public, and then a list of and then person and then get all people and then what we're going to return is the actual person service dot and then get Oh people, right. So now we need to tell that this method will be served as a get request. And the way that you do it is simply by saying add and then get and then mapping. So you see that everything has the same pattern at the post mapping at getting mapping. Now, let me go ahead and pretty much just restart the server There we go. So the actual server started on port 8080. So open up postman. And then let's actually try and send the actual same request. So we're going to send James Bond can see that worked. And now let's go ahead and try and perform a get request to our server. So the exact same URL, send, and there we go. So you can see that we have an array with one person that comes from our database. So this is awesome. Now let's go ahead and perform a nother post. So so right here, so change this to Nelson, and then Mandela, you can change this to whatever name you want to be honest, I'm going to send that you can see that it's 200. And then simply change this to Anna, and then Jones, send. And now if I perform a get request to our server, you can see that we have three people. So James Bond, Nelson, and Anna Jones. So as you see, springboard is just incredible. It's super fun. And as you saw, like, it didn't take us long to implement this functionality, right, we're just using annotations to drive our implementation, which is awesome. And we can pretty much deliver results very fast, using Spring Boot. Now, let's go ahead and implement the other two HTTP methods, the ability to update a person, as well as deleting a person. So open up IntelliJ. If I collapse this, and then open up the actual da Oh, and let's define the actual interface, or actual method. So right here, simply say int, and delete, and then person by ID. And right here, we need to pass the actual ID, so you ID and then ID. And let's also define a couple of things. So let's also define that we want to update a person. So this will return an integer, and then simply say, update. And then person by ID. So right here, we're going to pass the actual ID and the actual new person that we want to update, right, so person. And also, let's define one more method. And this will be an optional of and then person. And then simply say, select person by and then ID, and then simply pass the actual ID inside. And there we go. So now let's go ahead and open up the fake person data access service. And we have to implement all of those methods. So I'm pressing Alt, and then enter, and then implement methods. And you can see that we have these two methods that we need to implement. Okay, and error is gone. So in fact, let's go ahead and implement, select the person by the first. So to implement this method, what we need to do is actually search within our database and see whether we have a person with the given ID so this one right here, so the way we do it is simply by streaming our database. So let's go ahead and use Java streams, dot and then stream. And if you want to learn more about streams, go ahead and check my video on Java streams where I cover this. So let's go ahead and simply say filter. And right here, we get a person. And then let's simply say that person dot and then get ID dot equals to ID, right. And then what we want is dot and then find, and then first. And there we go. So now let's go ahead and open up the actual service, and then simply implement the same method here, so public, and then this will be an optional, and then person, and then get person by ID, and then simply pass the actual ID. And you can see that it's almost the same thing that we're doing right here return and then person do dot and then get or actually select person by ID, and then pass the ID and then open up the controller. So person controller, and this will be a get so basically We went to public. So this will be person and then get in then person by ID. And then we're going to pass the ID, and I'm going to show you exactly how do we get that. So Id, and then what we want to do is simply say return. And then person service dot get person by ID, lowercase ID, and then.or. Else, and then no. So right here, you could actually have a custom message or a custom exception, or a custom code thrown to the actual client. So for example, a 404, with a message saying, user not found, but for this video, let's go ahead and keep it simple and simply return now. Right? So now what we want to do is, if I open up postman is you see this ID right here, right? So I want to be able to copy the ID, and then simply say, forward slash, and then pass the ID. And then when I send the request, I should get that person back. Right. So the way that we get the ID from the path is by simply using an annotation, and the annotation is called. So this one is at, and then path and then variable. And the PATH variable that we want, is an ID. So Id, just like that. And basically, this is a type right here. So now let's go ahead and define the actual mapping. So this will be add, and then get and then mapping. And now because we want to have the actual ID in the path, so inside simply save path. And then what you want is double quotes, and then curly brackets, and then pass ID. So basically, this will allow you to have forward slash and then some ID. And then right here, you're simply grabbing the ID, and then turning that into a unit. Right. So let's go ahead and test this. So if I pretty much just restart the actual server, there we go up and running. So if I open up postman, now we need to issue some requests. So you can see that, you know, every time that we restart the server, we lose everything from our list. That's a disadvantage of having an in memory database. But for this video, you can see exactly how everything works. So let's go ahead and send a POST request there. And then let's get everyone so remove the actual you with there. So send. So we have knelson, right there. And basically now we can grab Nelson's ID, and then do a forward slash, and then paste that. Right. So now if I send, you can see that we have only one object, right? It's not It's not an array, but it's an object. And if I was to change the ID for something that doesn't exist, send, you can see that actually, it's a bad request. Because the you with it's completely wrong. So it's not valid you with that I've just sent to the server, but you get the idea. So if I go ahead, and let's go ahead and add Anna Jones. So send, and then let's get everyone, and let's grab Anna Jones ID right there. And then Ford slash, send that. In, see that works. Right. And in fact, let me go ahead and say you wait generator, and let me generate the unit. So I want one unit here. And if I grab this, and then go back to postman, and then perform a get request with that up there. So if I delete everything, and then paste that yo ID and then send you see that it's a 200. But we have nothing in our database without your ID. Right? So as I said, so you shouldn't be throwing a 404 with a custom exception. But in this video, you can see exactly that we are returning nothing because there is no one without you it against our database. So let's go ahead and implement the remaining methods. So if I collapse this, so Let's go ahead and implement everything in one go now. So open up the actual fake person data access service. And to delete a person, what we need to do is simply get the person if the person is there, delete it, otherwise, return zero. So let's go ahead and simply say select. And then person by ID, we're going to grab the ID. And remember, this returns an optional, so person, and then maybe, and right here, I'll simply say, if, and then person may be dot, and then is empty. So if it is empty, we want to return zero. Otherwise, what we want to do is actually remove from the database, right, so if it's there, we want to remove so DB dot and then remove, and then person, maybe dot and then get just like that. And then return one, right, so we know that we did delete this person. Now let's go ahead and implement update person. So what we're going to do is simply say return and then get or actually select person by ID, we're going to pass the ID. And then what we want to do is say dot and then map. So right here, we get a person, let's call it P. So P. And as I said, if you want to learn about, you know Java streams, maps, operations filtering, go ahead and check my YouTube video where I teach all of this. So now let's go ahead and try and get the actual index of this person. So int, and then index of and then person to delete equals to and then DB dot, and then index of and then pass the actual person, right. So now we have an index. So I'm going to say if the actual index to the leat and I'm missing a knee right there. So if the index to delete is greater or equal to zero, what we want to do is actually set the actual person, so we means that we found someone, right, so let's go ahead and say DB dot and then set and then index of the person to delete, and then simply pass the actual person, right. And now what we can do is simply return one right here. So otherwise, so else, or we can simply say return and then zero. And then right here, so because we need to return an integer, simply say don't, and then Or else, and then zero. Right. So basically, if I format this, so basically, I'm saying select the person, and then map that person to something else, right. And if the actual index of that person is greater or equal to zero, we know that we found that person, and then set the contents of that person to the new person that we've just received from the client, and then return one, everything is fine. Otherwise, return zero. Or if select person by the is not present, we don't do anything and simply return zero. So this is what it means. So now let's go ahead and simply, you know, feed this through the service, as well as controller and then test it. So let's go ahead and simply open up pass and service. So let's go ahead and save public and then ain't delete, and then person. And then right here, we're going to take the actual ID, so Id, and then this will be very simple. All we need to do is simply say return, and then person do that. And then the lead by ID pass the actual ID, and we're done. To update a person, sorry. So if I close that, so to update a person, what we need to do is simply say, public, and then ENT, update, and then person. So we're going to take the actual ID, so you ID and then ID and then this person is the new person, so new and then person. Right? And then what we need to do, I simply say return personally, oh Don and an update, and then Id right. So you can see that I don't have much logic going on here. Here. And this is because, you know, I'm just teaching you exactly how to use, you know, Spring Boot to to create an API. But essentially, you know, inside of this service, you will have whatever logic your application requires, right. So I'm just making this simple for you to understand exactly. So you don't have a lot of code going on. Basically, you see the entire process of what we're doing. So now, let me go back to the actual person controller, and simply expose those to a REST API. So the first one is update, or actually delete. So let's go ahead and say delete, so public, and then void, and then delete, and then person by ID, we simply pass the ID, and pretty much the same thing at and then PATH variable. And then this will be the ID. And then we want that to be a u ID, ID. And then return, Oh, actually, there's no need to return here, because this is void. So simply say person service dot, and then the lead person passed the ID. Now this has to be guess what at, and then remember, we are deleting a resource from the server. So delete, and then mapping. So now inside, we have to have the path, and then the actual ID, right, so this ID is this one, right here, which we can pass down to the service. So let's also go ahead and implement the actual update. So the update will be act, and then put, and then mapping, and public. And then Floyd, and then update person. And then this will take a person from the request body. So art, and then request body will take a person to update. There we go. And now simply say person service dot and then update. And in fact, we also need the actual path. So the path will include the actual ID. So Id, and let's go ahead and say that, and then path and then variable. And that will contain the ID. And this will be a user ID, and then call it ID. And there we go. So now we can pass ID and then person to update. Right. And to be honest, this is all we have to do to implement our REST API. So let's go ahead and test it. So I'm going to pretty much just restart the server. So let me go ahead and open up postman. So let's start with one person. So let me send this request. And then let me get everyone. So send, you see that we have Nelson Mandela. So let's go ahead and change Nelson's name to something else. So go ahead and simply create a new request. So go ahead and change this to a put and the body. So instead of saying, Nelson Mandela, let's simply say that this is Alex. And inquiring, right. And now let's go ahead and simply pass Nelson Mandela right here. And basically, we're just changing his name. So if I go ahead and send, you can see that the request did work. And now if I get everyone from our database, so if I perform a get request, and then send, you can see that that didn't work. And let's go ahead and debug this in a second. But for now, let's go ahead and pretty much try and delete this person. So Nelson Mandela. So if I put forward slash and then the actual ID, and then delete, and then send, we got 200. If we get everyone, you see that Nelson is not there, and it's been deleted. So we had a bag. So if I post let's go ahead and Post, Anna Jones. And basically, we couldn't update the actual name. So if I get an A Jones, get the actual ID, and then perform a put. And this will be Anna Jones Id just like that. And then body. And then let's, let's simply say update and then update, send. Still a 200. But if we get everyone, you see that still Annie Jones, so we have a bank. So let's go ahead and try and find out why exactly this is happening. So, let me go back to IntelliJ and then close this and then open up the actual data access service. And now this is the actual method. So we are selecting the person mapping. And then so basically, so right here we have index of person to delete. So this would be actual update. So to update and DB index of person. So basically, yes, so this is the error. So so right here, so you see that we have, so this person right here. So this is what we want to update. So right, so let me rename this to update, right, so the index of person to update, you know, it's minus one. So this will always return zero. So what we want is actual p, so P is the actual person, in fact, just I mean, rename this to person. So we want this person that we found. So person, and then this should return the actual index. And then if it's bigger or equal to zero, what we want is Neal, so because this update doesn't contain the actual ID, so we need new person, and then pass the ID, and then simply update dot and then get name. So yeah, I think this makes more sense. So let's go ahead and restart the server. There we go. So now if I open up postman and then pretty much just get so let's start from scratch. So no one in the database. Let's go ahead and post Anna Jones. And now we have to get let's go ahead and get so we get the actual uod of Anna Jones. And then right here, let's go ahead and perform a put to this endpoint and simply pass Anna Jones you ID or ID. And then in the actual body. Let's also change this to Anna, and then Montana, just like that. And then if we send, so we got 200. And now this should work. So go ahead and send. And that. So you can see that this now works. So you see that we pretty much just managed to implement all of the methods defined in our API. So it is nice to have like tests for everything right here. And basically I wrote tests for this class. So go ahead and download the repo down below. And you can run all the tests and see that this works as expected. So I've got unit tests around all of this. So one last thing that I want to mention is that you see inside of this person controller right here. So this person controller, we can have, you know, some annotations that enforce null ability in our application. So we can pretty much just use one, attach some annotations, and enforce that this object right here is always present, and also valid. So go ahead and open up person model. And then right here, what we can do is actually say that this field right here, so the actual name, this cannot be blank, so act and then not and then blank, right? So the reason why I'm not saying that no, is because if you have an empty string, it's not No, but if you have an empty string, it's actually blank. So basically, we don't want that to be blank, right? So then go back to the actual controller. And now you can say that the request body. So this has to be. So add and then valid, right? And then we can also say that this must not be no. So we could also do the same here. So we can enforce that this is valid, and also add and then not know, right? So now if I pretty much restart the server, so you see exactly what we're doing. So basically, we want to fail as soon as possible instead of having to deal with nullability inside of our code. So now let's go ahead and open up postman. And then let's go ahead and pretty much try and post someone to our database. So right here, so you see that we have Anna Jones, but if we send for example, blank, so send, you'll see that we get an error. And basically, this is working as expected, as expected. So you see that it's a bad request. And it's pretty much saying that validation fail for object person right here. So this is awesome. And you can see the actual default message, which says that the field name must not be blank. So now if I go ahead and add the correct payload, so right here, so let's go ahead and say, john, and then Jones. And then send, you can see that we have a 200 status code. And if I go ahead and get everyone in, see that we have john Jones. So this is it to be honest. So now you should be familiar with Spring Boot and writing API's for your application. So now the cool thing about it is that you can have a client API, and then do all kinds of things depending on your application. So one more thing, actually, that I forgot to show you is dependency injection, right? So let's say that we want to have a Postgres implementation, right, another database or connecting to a different database. So how do we change that without changing pretty much anything apart from one line of code. So to do that, what we need to do is open up the actual do package, and then simply create a new class. And right here, simply call it for example. person listening was call it person. And then data, access, and then service, right, let's simply call it that. So this is a real thing now. So okay, implement and then person, da, oh. And then implement all the methods. And then right here, so when we select everyone, I simply return list, dot, and then all of and then new, and then person, your weird dot random mu ID. And then, let's simply say from Postgres dB, right? So now what we need to do is annotate this with ADD, and then repository, and then simply say that this is a Postgres implementation, right? And then to change our implementation, right, all we have to do is grab this name right here, and then go where you inject the actual interface, which is inside of the service, right? So person service. So now instead of fake do simply use Postgres, like that. Now, if I restart the actual server, and then open up postman now if I perform a get, you can see that we pretty much switched our database, we just one line of code. And you can see that this now is coming from a Postgres database. So I'm actually planning to do a video on you know, connecting to a real Postgres database. But go ahead and check my channel because I've got a video on how to spin up a Postgres container using Docker, and also an example with Spring Boot. So go ahead and check my video on that. But I'm gonna make a second part on this video connecting to a real database. So the last thing that I'm going to show you exactly how to spin up everything. So go ahead and stop your server. Now what I want to show you is actually how to spin up the actual jar. So this is the, the the jar that you can deploy to a server and have your application up and running. So I'm going to simply collapse that. And then inside of Maven, so go ahead and open up this tab right here. So Maven, and you should see a target folder. So if you don't see that, so if I delete that, simply go ahead and open up lifecycle, and then simply say, install. There we go. So this is actually running some tests. And there we go, you see that we have a target folder right here. So inside of the target folder, go ahead and simply right click, and then open in Terminal. So you should see that we have this demo 001 snapshot dot jar, the jar, and this is what we can pretty much just run on the actual server, right? So when you deploy this to any environment, so just to show you, so if I open a post, man, so if I send a request, you see that the server is not up and running. So to kick off this jar, all you have to do is simply say Java, and right here. So if I scroll up, you can see that so if I scroll up, you'll see that we can say Java, and then minus jar, and then pass the actual jar. So go ahead and simply say Java, minus, and then jar, and then the actual job. So the job name is demo. And then if I press tab, you'll see that we get auto completion. And then all I have to do is press Enter. And you can see that now we are starting our server. So right here, Tomcat started on port 8080. And what I'm going to do now is simply open up my web browser. And this is the actual API that you would use, so localhost, and then 8080, and an API, and then v one, and then person, and then enter. There we go. So you see that we have a JSON that we can consume. And basically, you can distribute this and have 1000s of clients consume your API. So I hope you had fun implementing this application or this API with Spring Boot. And basically, we achieved everything. So we have, you know, a client. So in our case was postman, we implemented get post, delete, and pull requests. Through the actual controller layer, we had a service layer data access layer for a database, you saw how to implement an in memory database. And then you saw how easy it was to switch from databases. And then we return the actual response to the actual client, which is what you see right here. So as I said, I'm going to do a second part on this video, I really want to add value by connecting to a real Postgres instance, which to be honest, is not going to be a lot of work, as you saw, it's just switching one line of code and then implementing the actual connectivity to Postgres. So now, let's actually go ahead and pretty much just use, we're actually connected to a real database. The database engine that we're going to be using for this second part of this crash course, is this amazing database engine called Postgres. So if you want to learn more about Postgres, you can go ahead and check my website, where I've got this PostgreSQL Crash Course, or actually, it's a course about four hours long, and it's absolutely free. So you can see the roadmap right here, and a cover the essentials that you need to know, in order to be familiar with Postgres. And by far, actually, by far, both price is the best database out there. So go ahead and check it out, go ahead and enroll. And it's absolutely free. So if I go back to the diagram, so you can see that right here, we have this data access layer, and instead of talking to a fake database, we're going to connect to a real database, which will be Postgres. So for this database, what I'm going to be using his Docker, so I'm going to use Docker and simply say Postgres and go ahead and click on this very first link and Basically, if you don't know about Postgres and Docker or Docker, go ahead and check my video. So I've got this video right here, where I cover about where I covered Docker and Postgres in about 10 minutes. So everything I'm going to teach you, you can find on this video. So if I close that, and basically is really straightforward. So you can see that they have some description on what is Postgres. And basically, this is how you start an instance, once you have Postgres installed. So let me go ahead and simply grab this command right here. So let me just grab this command, and then go ahead and open up your terminal iterm, or command line. So go ahead and simply open that up. And what I'm going to do is simply paste that in. So actually, I didn't copy that. So let me just grab this. And then paste that in, basically what we're doing here, so just let me explain so so let's start from the very first command. So Docker run, so this is the Docker command. And then I'm going to name this container as so let me simply rename this to, let's say, post grass, and then dash, sprink. And then right here, so dash E is the environment variable. So we need that to set the actual password. So let's simply keep things simple and simply have a very weak password. So password, and then minus d, Postgres. And this is the actual image and go ahead and simply change this to Postgres, and then Alpine. So this is the smallest version. And then what we need to do is also expose a port. So we're going to take the port that is running inside of that Docker container. So 5432, and then expose that to the outside world, as 5432. So basically, what we're doing, and so basically, this minus D is in detached mode. So as soon as I press enter, then we can carry on doing all the things. So go ahead and check my video if you don't quite understand this, because I teach you all of this. So go ahead and simply press Enter. And there we go. So now if I go ahead and simply say Docker, and then PS, you can see that we have this container right here. And the name is Postgres spring. So go ahead and simply say Docker, and then port, and then post, an Ingress dash spring. And you can see that we are exposing the container port to the outside world, on localhost, and then 5432. And by the way, 5432. This is a default port for Postgres. So now that we have a database, so we can log into it, and then perform various things. So I want to show you exactly how to SSH into this box in a second. But for now, you have a container running and exposing a port 15432. So now what we need to do is actually go and open up IntelliJ. And let's actually connect to this database. So what I want to do is first revert this because I want to connect to Postgres. And what we need to do is if I actually stopped that, and then close that, so open up the resources. And by the way, I didn't mention that we have some tests right here. So if I open up tests, so you can see that I even took some time to write some tests to make sure that everything works. So let me go ahead and close this. And then what we're going to do is open up this application dot properties. So application application dot properties, this is where you define the connection details to your database. So go ahead and pretty much just delete the application properties. So go ahead and delete application dot properties. And inside what I want really is a file and simply call it application dot and then yamo wash that could have simply renamed that to yamo. But it's fine. So okay, and not for now, I'm going to commit this in a second so you can have everything on a branch. So now inside of this application dot yamo. This is where we define all the connection details to our database. But before we do that, what we need to do is actually add some dependencies that will allow us to connect To databases have the drivers and then also give us the ability to write SQL commands against our database. So for that, what we need to do is open up palm dot XML. And just let me collapse this for a second. And you can see some information about this project, I'm using Java 11. The version of Spring Boot is 2.13 release. And then you can see that we have some dependencies right here. So this is the actual dependency for Spring Boot starter web. So this gives you the ability to have a Tomcat server up and running and write some API's using Spring Boot MVC, so on and so forth. And then we have this one right here. So Spring Boot starter test for writing tests. And then we have this set for j, which is pretty much an assertion library for writing unit tests. So the dependencies that we need are the following. So go ahead and simply add a new dependency. So I'm going to press Enter. And you can see that now we can add a new dependency. So the first one that I need is from all dot spring framework dot boot, so it's me grab that, and then paste that in. And then the artifact ID that we need will be spring, and then dash and then boot, dash, and then Stata and then dash JDBC. So let's actually duplicate this. And then what we need is org dot and then post and then dress keywell. And then the artifact ID is simply PostgreSQL. So just let me grab that. So that will be that. And then what we need is simply have a scope. And then this will be only at runtime. And finally, we need a net of dependency. And this time, this will be org, dot and then fly way. And I'm gonna explain this in a second. And then dB. And then what we need is simply fly. And then way, and then core, wash the dash, and then core, just like that. So all of these dependencies will allow us to connect to a database. And basically, this is what allows us to write, or actually it gives us an awesome API that we can execute some statements against our database. This is for the actual driver, so PostgreSQL. And in this flyway, db is for database migrations, and you will see this in a second. So now let me simply go ahead and open up the project tab. And then if I open up the demo application, and then press play, you should see that we have an error. And the error simply says that failed to configure data source URL attribute is not specified, and no embedded data source could be configured. So basically, what we need to do now is simply to create a data source, and inject the URL, username and password. And then pretty much allow us to add an image that will allow us to connect to our database. So let me go ahead and simply collapse this. And what we need to do first is simply go ahead and create a new package. So package, and then simply call it as data and then source. And then go ahead and press OK. And inside of this package, let's go ahead and simply create a new class, and then simply say, post, grass, and then data and then source. Press OK. And don't ask me again, I will add all of this later on. So this class will be served as a configuration. So add configuration. And what we're going to do inside of this class is simply return a data source, so public, and then it carry data source. And let's simply go ahead and name it as the current data source. And what we're going to do here is simply return a data source of builder. And inside let's simply go ahead and say dot and then create Then right here, simply go ahead and say, and then simply go ahead and say dot and then type. And the type for this will be e curry data source dot and then class, and then dot and then build. So you can see that now we have this data source. And what we need to do is simply say add and then being. And what we need to do also is say configuration and end our properties. And then what we're going to do is simply have app dot and then data, and then source. So, basically, we are instantiating, this Ikari data source as a bean. And then what we're going to do is create some configuration file that will contain the username, URL, password, so on and so forth. So let's go ahead and simply open up the application dot properties. And inside of application properties, what we need to do is simply do the following. So let's go ahead and have an app and property. And inside of this app property, we have data and then source. And then inside of data source, what we need is JDBC dash URL. And this will be JDBC. Colon post grass qL colon forward slash localhost. And then the port will be 5432. And then Ford slash, and then we need to connect to a database. So we're going to create a database in a second. But for now, let's simply name this as spring and then boo. And then dash and then post grass dashDB. long name, but you get the point. So now we need a username. So the default username that ships with Postgres, it's called post press, we need the password. So password. And remember, the password that we chose was password. And we can also define a pool size. So basically, this is the number of connections that we can have actively, instead of having to create a new connection to the database, every time that we want to execute a query, every time we want to execute a query against our database. So simply go ahead and add 30. And that should be it. So you can see that we have App Data Source. And inside of this data source package, we have this Postgres data source. And basically, it's just grabbing all the dependencies from this app, and then data source. So just let me go ahead and start this because I want you to see the errors, and you see exactly what is going on. So if I start the application. There we go. So now it says that cannot find migrations in location, class, path, db, and then migration. So what we need to do is to create a folder called dB, and then another one called migrations and then have our database migrations inside it. So what flow and this is basically flyweight, right? So flyway allows us to manage our database schema as we evolve. So go ahead and pretty much just learn about flyweight, right here. So flyway. And basically, you can read through the documentation, but it is straightforward. So just follow along and you will understand exactly what I'm doing. So if I close Oh, actually, I just have to keep that open. So if I go ahead and simply close this or actually clear that and then I've got this terminal right here. So I'm going to open this terminal. And if I do pwd, you can see that I'm inside of desktop Spring Boot YouTube Crash Course. So what I'm going to do is simply CD into SRC, and then main and then inside of core resources. So inside let me go ahead and make a folder. So make and then there. And what I need is dB, CD into dB, and then make another folder. So make dir and then migrations. There we go. Enter. And basically, you could simply come here and pretty much just right click, and a new, and then directory, and then DB dot migrations. But I prefer to use terminal. And you should also get used to it. So inside of dB migrations, let's go ahead and create a file. And this file will be as follows. So version one, underscore, underscore, and then person, table dot SQL. So make sure that this is as follows. Because otherwise he won't work. So version one, underscore, underscore person, table dot SQL, enter. Now, let me ignore this extension. So this is where we can write some SQL. So let's go ahead and simply create table person. And then inside of this person, we have an ID. So Id, and this is of type EU ID. And then this will be not and then no, primary, and then key. And then we also have, so if I open up the person class, we have the actual name. So if I go back, so this will be name. And then this is a VAR, char. So let's go ahead and simply add 100. Not Know. So this is enough. So now we have a table called person with the following columns ID and Name. So what I need to do now is actually go ahead and create our database. So if I open up the applications, or yamo, so remember, so right here, we have this database called Spring Boot, Postgres dash dB. So you can get a better name. But you know, I'm just giving this name so that you know exactly what we're doing. So what we need to do now is actually, so if I open up the terminal, and this is where I've got, you know, I've typed some Docker commands. And you saw that how we pretty much just launched this container, which is running and also exposing this port. So 5432. So this is the port that we are connecting, right, so localhost 5432. So let's actually go ahead and bash into this container and create a database. So simply go ahead and say Docker. And then exec, and then dash, and then it for interactive. And then what we want is actually, if I grab this container ID, and then simply say, bin, forward slash, and then bash, Enter. And you can see that now we are inside of that box, or actually. And you can see that now we are inside of this container right here, which we can simply now run some commands. So go ahead and simply say p SQL. And you can see that we have p SQL working. And now we can write some p SQL commands. Again, if you have missed my course on p SQL, or actually Postgres, so on my website, so this is where I teach everything that you see me typing. And to be honest, you should learn Postgres. It's amazing. And a lot of companies are using it. And you can also use it for your personal project. So let me go ahead and simply go back to my terminal, and simply go ahead and say p SQL, dash, and then capital U, for post grass. So remember, so this is the actual username, and then enter. And there we go. So you can see that now we are inside. So if I pretty much type backslash, and then l. So if I clear the screen, backslash L, you can see that I do have three databases. So you can see a list of databases, we have Postgres template zero and template one. So let's go ahead and create a new database with this main. So let me grab this. And then if I tried to create So, caps, so create table or actually database and then paste the name and that with semicolon, enter. Oh, okay. So we cannot have dash. So let me simply pretty much rename this to demo dB. Right? So demo And then dB, Enter. And you can see that worked backslash L. And we have demo DB right here. So let's go back to IntelliJ. And let's simply rename this to demo dB. And now all we need to do is actually connect to this database. So let me connect inside. So backslash, C, and then demo dB, Enter. And you can see that I'm connected to demo dB. So if I do backslash, and then D, so to describe what we have in here, so backslash, D, we haven't got anything backslash dt, you can see that there is no relations. So these are everything. And then dt is for tables only. So now what I'm going to do is go back to IntelliJ. And let's go ahead and simply start our application. So let's actually go ahead and click on this icon right here, edit configurations. And let's go ahead and simply say that we only want one single single instance running at a time. So if you press play multiple times, it means that you will only get the same process and not get two processes. And then you get like one error saying that the port is already in use, so we don't wander. So go ahead and simply now play. And we have an error, and it says cannot find migrations in classpath DB migration. And thus, because I've misspelled migration, I've typed migrations instead of migration. So just let me rename that. So migration, and then refactor, there we go, and install the application. And there we go. So you can see that everything started fine. And basically right here, you can see that we have a curry pool started and then completed. And then we have database demo database right here. And you can see that we have migrating schema. So person tables. So basically, that was executed. So our command was executed correctly. And you can see that the migration was applied. And now we have the server running on port 8080, which is awesome. So now, so if I pretty much go back to my terminal. So I just want to show you something first. So remember, previously, we type backslash, D, and backslash dt. And that wasn't working. Well actually, it was working, but we didn't have any relations. So if I type the same command, so backslash d t, you can see that now we have two tables. So this one is for flyway specific, which you shouldn't care at this point. But you can see that we have this table right here called person. And if I go ahead and describe a person, so backslash d ln person, you can see that we have this table called person inside of the public schema. And then the ID is of type you will not know. And then we also have name, and then it's a character varying. And then this is 100. So this is the length. And it's also not no, and this is awesome. So if I go ahead and simply say select, and then start from and then person and with semicolon. And you can see that we have zero rows. So let's go ahead and simply insert someone. So because I know I need to install an extension to be able to to generate the Jew IDs and also I cover this on my free course, I need to install an extension. So what I want to do basically is this, so select and then you ID and then generate and then v4 as a function. And you can see that no function matches. So what we need to do is create extension. And then this will be u ID. Dash o s SP. So w ID dash o s SP and now it's semicolon. And you can see that worked. Now if I pretty much select you with generate vision for and you can see that now we can generate you It's so If I go ahead and simply say insert, into, and then person. And then we have ID, and a name, and then values. And then we want to generate a u ID. So generate, and then v4, and then the actual name. So let's simply say that this is Maria, and then Jones. And then end with parentheses, and enter. You can see that Maria Jones does not exist. And last, because that has to be single quotes, and not double quotes. So Marie Jones, like that, enter, and you can see that worked. So let me go ahead and add Tom, and then Smith, enter. Now if I select star from person, you can see that we have two people inside of our database. And this is awesome. So we've managed to connect to our database using Spring Boot. And we have a database up and running with a table. And now what we need to do really is just write some code to retrieve data from our database using Spring Boot. Oh, actually, we're actually using Java and Spring Boot and their API basically. So let me go ahead and collapse this, and inside of the person data access service. So let's go ahead and write some code that will retrieve as everyone from our database. So what we need to do is to use this class right here, so private, final, and then JDBC template. So what we're going to do is add this to constructor, and then auto wire. So this is dependency injection, we don't have to do anything spring, no Spring Boot knows how to initialize correctly this class for us, so that we can write some code against our database. So now, instead of saying select all people, and then return a list, so basically this fake list, what we're going to do is use JDBC template API. So simply go ahead and say JDBC template dot, and you can see that they have various methods. So the one that we want is query. So we want to query and the query takes two things. So we can pass s, so we can pass an SQL statement. And then we have to pass a row mapper. So basically, the row mapper is how we take the values that we retrieve from our database, and then transform that into a Java object. So let me go ahead and simply simply define a string. So string, and let's go ahead and make this final, not needed, but why not. So SQL equals to select. So basically, the same thing that we had, so select name, or actually, this is ID, name. And then from and then person, not the same. So previously, we simply said select star. So right here, so select star, so select, and then Id, name from person. And this is the same thing. So I prefer to use the actual column names instead of the instead of star. So now let's go ahead and simply pass the SQL query. So SQL, and now we have to pass this row mapper. So this row mapper is a lambda that has access to the result set to the result set, as well as the index. So what we're going to do inside here, so let's simply go ahead and say return. And then we need to return a person object. So person, so this is our model, and inside of our person, we need to pass what we need to pass the uod. So they should be new person, just like that. So inside you can see that we have to pass a u ID and also a name. So inside of the result set, we can get the string so get string, and then you can see that we can pass the column label. So I know the column label is so basically ad. And also we can get the actual name. So resolve set dot, and then get string. And then this will be named. So if I put this this on a new line, and you can see exactly what we're doing. So right here, you can see that we have an error. And this is because this result set Daguerre string is a string basically. And what we need is a unit type. So let's simply go ahead you ID and then from string. And then we need that. So that will work. So you can see that now this works, let's end with semicolon. And what I like to do is actually to extract this way variable. So all of that actually. And then this will be ID. And then this will be name, so you see exactly what's happening. And we can remove that. And also that, and then that and then format everything. So now I don't need to return the list of pretty much just fake people. So this from Postgres DB is not named, and we are retrieving from a database. So you can see that I still have an error. And this returns a list of people, right. So you can see that it's a list of people. So I can either say return, and then people whoops, so people just like that. Or I can simply return that in line, so refactor. And there you go. So you can see that I'm returning that in line, which is awesome. So this is it. So if I now restart the application. So let me go ahead and simply say stop, and we run. There we go. It's up and running. And if I open up Chrome, and then remember, so right here, we previously add an empty list. And this is because he was coming from our fake database. So now, if I refresh this, there we go. So you can see that now, this is coming from our database. And this is awesome, guys. So you can see the power of Spring Boot. Basically, you can just write code, you know very fast, and they give you these tools so that you can focus on writing what matters instead of you having to configure things. So there we go. So let me go ahead and simply add someone else into this table. So let's go ahead and simply, say, Tomcat, we're actually not Tomcat. Let's simply say, Anna, and then Jamil and an editor. So if I refresh this, you can see that now we have Anna Jamil. So there we go. If I collapse this, you can see that this is only one implementation of our API, right? So we have a bunch of other methods. So select person by ID, you actually let's go ahead and implement this one quickly. So you see exactly how this is done. So what you want is to pass, or actually select ID name from person. And then here you can see where in an ID equals to question mark. And then what you want is to take the exact same thing here, and then simply return that back instead of query because query it returns you a list, what you want is query for and an object. And query for object takes the SQL. But we also need to pass the arguments. So new object, so this must be an array. So just like that, and you can see that So currently, this is empty, right? But I need to pass this ID that comes from the client. So Id and then this, let's rename this because it's already in scope. So person, and then ID. And let's rename that to person ID as well. Just like that, and let's actually change this. So this will be a person, right? But what we want really is to return so return optional.of nullable, because that can be no Then pass person, just like that. So basically, it's the same thing. But we have this question mark, and then query for object, we pass the ID right here. So if I put this on a new line, so you can see exactly what we're doing. So in that, that, so we passed the SQL, the ID. And basically, if you had more item arguments, you'd simply pass him right here. So we have the ID, and then this is the row mapper, as you saw before, so right here. And then we simply return the optional of nullable of person, because, you know, we might not find a student with a given ID. So if I restart this, and then open up Chrome. So if I refresh, you can see that this still works. But you find out take this ID, and then pretty much to Ford slash and then Id remove the quotes there, Enter. And you can see that now we only get one person. And this is awesome. So there we go. So you can see that we managed to connect to a database using Docker, Postgres, flyway, spring JDBC. And you can see that this was pretty much, you know, very straightforward. And we even managed to use a carry. So I didn't even explain what you carry was, but you carry is the actual recommended data. So if I you should be using for a Spring Boot, because it's very fast, reliable. And yeah, it's just one of the best ones out there. So there we go, guys, if you have any questions on this, and basically, I'm gonna let you implement the rest of the logic. So insert person, the same with delete, and then update. But basically, it is straightforward using some SQL. So go ahead and pretty much just subscribe to my channel to get more videos like this, if you want to learn more about all of this and more. So I've got a Spring Boot full stack, web development course where I teach all of this and a lot more. And also creating user interface for this using react, reacts and hooks. And pretty much, it's a lot of content packed into one course where I'm pretty sure that once you learn that you will be able to build applications on your own. And also apply for jobs because a lot of companies are looking for a Spring Boot developers or, you know, Java developers. But Spring Boot is used quite a lot in the industry. And once you know all of these skills, so dependency injection, connecting to databases, writing tests, writing integration tests, writing user interface for it, I'm pretty sure that you will be able to get a job. Okie dokie. As you saw throughout this crash course, springboard is amazing. So we really just scratched the surface. And the next step for you is to check out my full stack web development, Spring Boot and react. And in that course, I'm going to teach you everything you need to know about Spring Boot. So we're going to cover essential topics that you need to know as a software developer. And the cool thing about this course, is that whatever you learn, you will be deploying it into a real server using Amazon Elastic Beanstalk. And upon completion, the skills acquired in this course, it will help you apply for jobs because it will help you with a lot of great important concepts that a software engineer should know. Also, you can start your own projects, university projects, and pretty much if you are a developer, you should be aware of this awesome framework and how to use it inside out. This is all for now. Go ahead and check out my YouTube channel where I've got more content similar to this. It was a pleasure teaching you and I'll catch you in the next one. See ya