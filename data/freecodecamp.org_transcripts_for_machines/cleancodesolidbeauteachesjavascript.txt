this video is part of my clean code and JavaScript Series this video is all about solid solid is an acronym that stands for five basic principles of objectoriented programming and design the s in solid stands for single responsibility principle this principle states that everything should only have one reason to change this will help developers understand the context and responsibility of what they're building and when there is a need for change so here is the bad way to do it in the user settings we have a change settings function and we have a verify credentials function now this is really two different things there's the settings and there's the credentials so this is not just a single responsibility if you go go down here we have the good way to do it the good way to do it we're going to have two different classes we're going to have the user off class and the user settings class and so one of them is responsible for verifying credentials and the other one is responsible for change settings so that repes that shows the single responsibility principle the O in solid stands for the open closed principle now this up here is actually the bad way to do it first let me explain the principle software entities should be open for extension but closed for modification this basically means that if someone wants to extend our module's Behavior they won't need to modify existing code if they don't want to there's an easy rule of thumb if you have to open the Javascript file of your module and make a modification in order to extend it you have failed the open close principle so let's see in this example here we're making an ice cream maker we have the ice cream flavors chocolate and vanilla and then we're creating this ice cream maker with the make ice cream function where you pass in the flavor and it's going to either say a great success you know ice cream or epic fail no ice cream for you depending on if you if the flavor you pass in is in the ice ice cream flavors array so if you pass in chocolate to make ice cream it's going to say great success now you have ice cream uh then if it's not in the array you're going to have epic fail no ice cream for you now the problem with this is that there is no way to add an ice cream flavor without editing the ice cream flavor array so we can easily change that here's the good way to do it we've just added this extra function here which is to add a flavor and it's going to do ice cream flavors that push flavor so you can add maybe strawberry here or something like that and then you can now make ice cream in the strawberry flavor so um and the bad way to do it we would have had to go into the file and actually add the strawberry flavor to the array here uh we don't have to do that we can just use the the method of the function to to change that array so we don't have to modify the existing code to extend the behavior okay the L in solid stands for the Lov substitution principle this means that derived objects or types must be substitutable for their base again this will make more sense with an example this is the bad way to do it we have a class we have a rectangle class and it's going to have a Constructor with the the width and height um where you you're going to be able to besides setting the color and the rendering you're going to set the width to the width that you passed in you're going to set the height to the height that you passed in and you can also get area now we can create a square which is going to extend a rectangle um all squares are rectangles but not all rectangles are squares so here we're only going to add we're going only going to overwrite two functions um which is the set width and set height and see we're going to set width the width and height to the width that you passed in and if you do set height you're going to set the height to the height the width and height are going to be set to the height you passed in the Square Square inherits from the rectangle class according to the listov substitution principle you should be able to substitute the square class for anytime you would normally use the rectangle class and your code should function as expected but you will see in this bad example it doesn't work out that way so if you see this part here um we're going to create these re rectangles to be a new rectangle new rectangle new square and then we're going to render the large rectangles and pass in this rectangle array so it's going to call this function and for each rectangle in that array it's going to set the width of four then it's going to set the height of five and it's going to get the area of that rectangle it would actually return 25 for square because the height we passing was five and it basically just overwrote the width so this would work for rectangles when the width and height are different but it's not going to work for squares so you can't really substitute squares in for rectangles and it behave how you would want it to behave so here's the good way to do it we're going to create a shape class that has the set color and the render that are going to be the same for any any shape then we're going to have the rectangle class which has the Constructor the width and height and it's going to set the width and height and you can get the area by multiplying the width times the height and now if you look at the square class this is going to extend shape it's not even going to extend rectangle it's going to extend the shape class and with in the Constructor we are just going to pass in a length and then you're going to set the length and the area is length time length now up here we have the render large rectangles function but down here we have the render large shapes the rectangle and square both extend from shape and the square did not extend from rectangle so we're going to create the new rectangle by passing in the four and five because if You' see here the rectangle you pass in width and height and the square you're just going to pass in the length so you're going to create them differently pass in form and five for rectangle for new rectangle pass in four and five but for new Square you're just going to pass in five and then you're still going to be able to render large shapes and pass in the the shapes array and shapes at 4 each shape you're going to get the area since the rectangular class for get area is return this. width times this. height and the square has returned this.length time this. length it's going to behave how you expected so you are in able to substitute squares and rectangles and you're going to get what you would expect so this goes along with the listov substitution principle the ion solid stands for interface segregation principle a client should not be forced to depend on interfaces it doesn't use now JavaScript doesn't have interfaces so this principle doesn't apply as strictly as others but a good example to look at that demonstrates this principle in JavaScript is for classes that require large set settings objects not requiring clients to set up huge amounts of options is beneficial because most of the time they won't need all the settings so let's look at the bad way to do it which is right here we're creating a Dom traverser class and we're going to pass in some settings so we're going to um put all the settings into here now if you see here it's going to run the setup function and it's going to get the root node which we're always going to want but the point of this bad example is that you may not always want the animation module so in this bad example you always have to pass in a root node and you always have to pass in the animation module because in the setup it's going to access the animation module. setup but we may not need to animate so in the good way to do it we're going to make passing in the animation module optional so it's pretty similar but we are going to have the root node and when we're creating the Dom traverser we're also going to have options and anything in this options object is optional we're going to set the options to the settings that options that we passed in from here and here we're always going to set the root node to settings that root node and then we're we're going to call the setup options function down here and now here it's if this. options. animate module so if we passed in the animates module then we're going to run the setup for that but if we didn't pass it in we're not going to run the setup so it's optional whether you pass in these options or not and the last part of the solid the d stands for dependency inversion principle now this is another principle best explained by example but let me tell you the definition first this principle states two essential things one highlevel modules should not depend on lowlevel modules both should depend on abstractions and two abstractions should not depend upon details details should depend on abstractions this is all about handing over control from the function itself to the color of the function so let's look at the the bad way to do this so in the bad way we're going to create this inventory tracker class and it's always going to use the inventory requester class so you have no choice to use the inventory requester class and the good way to do it we are going to be able to choose which inventory request we used so here um when we create this um inventory tracker we're going to create the new inventory tracker which is this and we're going to pass in these uh inventory items here it's going to sign the items to the items and then we're going to set the requestor to a new inventory requestor up here and this inventory requestor is always going to use the HTTP method so when we do inventory tracker. request items it's going to to use the requestor we set up here which is the inventory requestor to request items and it's going to request the items using HTTP now we may not always want to use HTTP so instead of always depending on this inventory requester class we want to give uh give ourselves more options so here's the good way to do it we're still going to have the inventory tractor but instead of just passing in items to the inventory tracker cuz remember up here we only pass in items now we're going to pass in items and we're going to pass in the requestor so remember before the requestor was always the same but now we are going to be able to pass in a different requestor so there's two types of requesters we have um requestor version one and requester version two requestor version one is going to use HTTP requestor version two is going to use we websockets so we can now use the inventory tracker class for both HTTP and websockets we just pass in a different requestor and it's going to set this that requestor to whatever request we passed in and then when we request items um it's going to either use um the HTTP requestor or the websocket requestor to request the items so if you look down here I when we create the inventory tracker we're going to create a new inventory tracker we're going to pass in the items and then we we are going to pass in either the new inventory requester version two which is the websockets one or the version one this is going to allow us to easily substitute the request module and just make it easier to refactor and make it easier to use the inventory tracker class for different purposes well thanks again to Ryan McDermot who wrote the article that inspired this series many of the code examples come from his article check the description of this video for a link to his original article and thank you for watching my name is Bo KS don't forget to subscribe and remember use your code for good