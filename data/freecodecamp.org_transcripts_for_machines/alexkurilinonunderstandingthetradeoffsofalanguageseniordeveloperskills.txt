hey everyone this is utsab i'm a teacher for free code camp and the goal of this video tutorial series is to learn the skills of a senior software developer so in each video we'll be chatting with a senior developer and will walk through a specific challenge that he or she faced and he'll walk through all the steps that they went through how they reasoned through to the solution and finally there will be a call to action at the end of the video where i'll explain how to translate the skills you see in this video into a solid thing that you can build for your portfolio so today we're here with the senior developer at front row ed front row is an adaptive learning software that's used in over 30 percent of schools in the country their users include over 200 000 teachers and 4 million students so we'll be chatting with alexander kerlin who is the cto of front row you're about to see the part of the conversation where he dives deep into the topic of tradeoffs so tradeoffs alex explains is one of the key skills that distinguishes senior software developers and what that means is the ability to look at many different solutions to a problem understand the pros and cons of each one and then pick the one that's most appropriate for the specific situation that you're in so alex is going to walk us through a challenge that he faced at front row where their old technology stack and language which was closure wasn't it it wasn't serving them very well they were facing some challenges and so we had to decide whether to stay with that or move to a new language which was haskell and so he walks us through kind of like how he reasoned through the tradeoffs of each solution and why he picked one over the other and in case you're wondering this in the background uh this is their mascot jt the piggy that stands for justin timberlake and this is me so alex i want to zero in on one of the points you mentioned yeah tradeoffs yeah i'm wondering if there's a decision that you could walk us through where you had to weigh different tradeoffs like maybe something like the technology you chose stack why did you pick hassle for example sure now um that's a nuanced and uh large question which i get asked actually very frequently because that's i think very interesting to a lot of people whenever you do something outside of the norm and that's that's something you will be asked about and in our cases we started with a dynamically typed language which was closure back in the day and you can think of it as yes it's functional but the dynamically type portion is very similar to what you would experience in javascript in a ruby in python which is you're not specifying the types of the variables that you're using you're just you're specifying essentially the shapes of them and then those can be changed over time and there's nothing statically so at compilation time telling you whoa these two things do not match i want to go over some of the jargon that alex is talking about here dynamic typing static typing shapes variables runtime compilation time what do all these things mean so let's take a look at a dynamically typed language javascript alex was referring to closure as a dynamically typed language but the same concepts apply to javascript so notice we're passing these three things a date a number and an undefined value all into the same function print date and javascript allows this the key thing is this as long as each of these whatever you pass in as long as it has a two string property javascript will handle it just fine and this is what alex meant by the shapes of variables instead of the actual type now one of these types causes the program to crash because the undefined doesn't have a tostring property and uh we'll see how that plays out so when we run the program in the browser we see oh there's an error the undefined value doesn't have a property to string and notice that we don't find out about the error until we run the program in the browser that's called a runtime error all right now let's look at an example of static typing we're using a framework called flow which allows us to declare types for our variables and here we're giving today a type of date now again alex was referring to a different language haskell as a statically typed example but same concepts apply here to flow so now with a statically typed language we can compile our program before we run it and it'll check for certain errors and it fine and it tells us that hey you can't pass in a number or an undefined value into print date all right so next alex goes into some of the details of the situation in front row which um and we'll kind of compare which of these is was better for his situation the project was getting progressively larger and larger so it was it started with just me developing it and then it spilled into two or three different products so we had a we have a student product a teacher product a parent product a school product and um there was a lot of code reuse between the different products because you don't want to don't repeat yourself dry is one of the uh core tenants and principles of solid software engineering and so being able to reuse code is actually quite challenging so the project was getting larger at front row and they were developing multiple products so they had a teacher product student product a school product and a parent product and they were all trying to reuse code so in our simple example here we are gonna have one shared method that is going to be shared by two products the teacher and the student product so here we have our shared module it has the function is holiday which takes a month and a day and just returns whether that date corresponds to a holiday the student product has this function write reminder email which will construct a special message if the current day is a holiday the teacher product will prevent the teacher from declaring office hours on a date that happens to be a holiday so let's see this in action here i'm loading both of our products here in node and i'm going to call the right reminder email function and give it a holiday and we see it gives that special holiday message if i do the teacher product and try to declare office hours on a date with the holiday we again get that special failure message so notice that this example here is dynamically typed and next alex explains some of the challenges that he faced at front row with their dynamically typed setup so i want to rewind to the moment when you started noticing this problem what was the first time you got the sense that you know what these shared modules are getting out of hand we need to switch to a statically typed language sure what what was happening is that i would change one of these uh internal modules i would change the interfaces and uh and uh i had to put in a lot of extra work there was a lot of overhead work that was was not really a good use of my time to uh update all the unit tests that were there in place to make sure that let's say these four products were using this shared functionality all correctly at the same time so now instead of just being immediately told does make sense this doesn't make sense i have to go in there first of all make sure that those tests exist which is time consuming this is not time you're spending on working on your product this is your time you're validating that the product is same and as your product gets bigger and bigger and the permutations become more and more that's more testy you have to write and you're essentially doubling the work of the compiler but um i was doing more and more of this overhead and that was not adding any value to the product it was just me doing something very very tedious and menial got it so alex talked about the specific symptom he started noticing about the problem the the cue that let him know that there was a problem whenever he would change the interface for a shared module bad things would happen so things would break you'd have to update a lot of unit tests so let's walk through this what do we mean by that changing the interface so an interface is whatever you need to know about an object in order to interact with it so for example what do you need to know about a computer in order to interact with it really just how to use the keyboard so that's the interface when it comes to code what's the interface for our shared module well what the student and teacher need to know about is holiday in order to use it it needs to know the the name of the method and the parameters so that's the interface let's go ahead and change our interface instead of taking a month and day as parameters we'll just take a date object and then it'll extract the month and date like this and now notice what happens when we run the program when we run student product we get an error so this is called a runtime error because it the error happens as we're running the program can we do better than that can be some can we somehow find out sooner than this that there's going to be a problem and the answer is yes yes we can with the help of unit tests so unit test will simulate what might happen as we're running the program so notice here we're writing these method calls passing in some parameters and we're checking to see that the output makes sense we have unit tests for both the student product and the teacher product okay notice what happens when we run our unit tests everything breaks all four tests break and this happens before we run the program and therefore we can find out that hey something's broken we can well we can fix that by by updating our code so we'll update our um students method and our the way we pass in the shared module and then we also need to change our unit tests so this is going to take in a date object okay and we would we would change all these unit tests so this is the symptom that you would look for in your own code as you're updating shared modules if you notice whether you have to update a lot of unit tests so next i i explain why it's important for you to be aware of this symptom so the reason i'm asking this is i'm wondering as the audience what can they look for in their code base to let them know like this is the cue this is the same trigger that alex noticed and so what i'm hearing is if you're ever find yourself doing this very thing in order to write one feature you have to now inspect the unit tests across many other use cases that might have nothing to do with what you're writing at that point you might reason as alex did that maybe a statically typed solution or language yeah would would solve that headache yeah i would say there were two um two big red flags here is one you're having to reimplement almost the same test over and over again for different products and uh two things are maybe you don't have those tests and things are continuously breaking when you're editing these shared modules so you edited it maybe you fix one part of the project you deployed to production you discover a few hours later or maybe a day later that something else broke and you went oh i totally forgot that we have this thing there well that means you don't have enough test coverage but now we go back to is writing an infinite amount of tests really good use of your business time so alex mentioned that with the dynamically typed language they were using closure he had to maintain lots of unit tests for shared modules as the product got bigger and aesthetically typed solution haskell solved these challenges for him so let's take a look at how that might happen for our example we're using flow in javascript to allow for static type checking notice it types on the variables and notice we have a lack of unit tests that's because our flow compiler will detect for the same types of things that our unit tests we're checking for and we see we have no errors now that doesn't mean we'll never have to write unit tests we just won't have to write unit tests specifically for detecting when interfaces change on your shared module so let's go ahead and try to change an interface here and see that we get an error so we find out right away that things are broken and next alex explains why this was important to him the the principle is you want to anticipate problems you want to detect problems as early as possible in the process because fixing a problem once it's a production is very expensive fixing it once you said okay compile the code i just wrote very cheap it's it's literally like several orders of magnitude cheaper to do it sooner than later so we've talked about the skill of understanding tradeoffs and we've seen alex demonstrate this skill as he thinks through the tradeoffs of haskell versus closure which one is right for front row and their situation there i'd like to give a call to action for each of you to put this into practice i'd like for each of you to have a project that you've personally built that was challenging where you had to think through the tradeoffs of different solutions and then pick the one that's right for your situation now one of the best ways to con to practice is to contribute to an open source project free code camp is an exciting project they have lots of things that they would love your help with to build on their map and of course i'm biased because i'm also a contributor to free code camp but they're a very respected project they've served hundreds of thousands of people and they're the most starred project on github i will even offer a free session to help you get started and i'll help you find a specific feature on free codecamp's roadmap that's challenging that would require you to think through the tradeoffs of different solutions and here's how to get in touch with me you can set up an appointment directly on my calendar or reach out to me over email i love talking about coding happy to answer any questions you have all right hope you enjoyed and until next time