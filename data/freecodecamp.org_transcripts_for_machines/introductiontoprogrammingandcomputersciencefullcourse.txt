Welcome to Introduction to programming. My name is Steven in my name is Shawn. Over the next 90 minutes, we'll be taking you through this series consisting of 21 different segments that hope to cover the basics of computer programming, which can apply to any and all programming languages you might want to learn. We'll be starting with the simplest question of what is programming. And from there, we will be working our way up as we talk about common features of computer science such as loops and arrays, we'll discuss how to read and write code, debug code that you've written some strategies to help you plan out your code and much, much more. The complete list of topics that are going to be covered in this lecture style video are shown on the screen. Now, additionally, there will be timestamps in the description, so feel free to skip around. If you're already proficient in some areas of computer science, or just want to know about a specific topic we will be covering. Hopefully, by the end of the series, you'll have a basic understanding of what computer science is, along with an armory of useful skills that will help you unravel whichever programming language you decide to learn. First, we'll only be covering the major key points that apply to all programming languages. So we'll be shying away from topics such as object oriented coding, and command line navigation, as those are things which are language specific. Additionally, there will be no software required for you to download in order to follow along with this tutorial, as we won't be writing any code in an ID to keep things simple and concentrated. This video is meant for those who are interested in computer science and programming but have no idea where to start and have little to no background information on coding. And so if that sounds like you, then strap in, as Shawn and I work our way through the wacky world of computer science, starting with the biggest question probably on your mind, which is what even is programming? Well, the dictionary defines it as the process of preparing an instructional program for a device. But that's a really confusing definition. So in layman's terms, what exactly does that mean? Essentially, it is attempting to get a computer to complete a specific task without making mistakes. Imagine this for example, you want your less than intelligent friend to build a Lego set, except he has lost the instructions and can only build based on your commands. Remember, though, your friend is far from competent. And so if they are not given very specific instructions on how to build the set, there are many mistakes that they could make. If he thinks like a computer, then if there's even one piece that you have not told him specifically where to place and how to place it, the entire Lego set will be ruined, and you will be left to suffer a complete mental breakdown, causing the whole goal of the project to be corrupted. giving instructions to your friend is very similar to how programmers code. Instead of a less than intelligent friend, you have a less than intelligent computer. And instead of instructions on how to build a Lego set, we are feeding information on how to complete a program like a game or a web application. And an important thing to note is that computers are actually very dumb. We built them up to be this super sophisticated piece of technology, when in actuality, a computer's main functionality comes from how we manipulate it to serve our needs. Now, programming isn't as simple as giving your friend instructions. Since in a programmers case, the computer doesn't speak the same language as you. The computer only understands machine code, which is a numerical language known as binary that is designed so that the computer can quickly read it and carry out instructions. Every instruction fed to the computer is converted into a string of ones and zeros and then interpreted by the computer to carry out a task. Going back to the Lego example, this process wouldn't be like if he was not only less than intelligent. But to make matters worse, he could not understand English and only speaks in Mandarin Chinese. In order to speak with him, you have to convert the instructions that you understand in English into the language that your friend understand. This process is essentially what you must do for your computer in order to make it understand the instructions that you give. The big difference between the two examples, however, is that it is very difficult for people to understand machine code in binary. Directly translating what you want the computer to do into machine code is extremely difficult, in fact, almost impossible, and will take a very long time to do it if you could. Each program is composed of millions upon millions of those ones and zeros. So how exactly are we supposed to translate our instructions into machine code. This is where programming languages come into play. programming languages are fundamentally a middleman for translating a program into machine code. These languages are much easier for humans to learn than machine code, and thus are very useful for programmers. Going back to our Lego example, a programming language would sort of be like an interpreter that's able to take the instructions you give them in English and translate them into instructions your non English speaking friend can understand. This makes programming languages extremely useful and the backbone of any good program. Think of programming languages as not English and not machine code, but somewhere in the middle. There are many different programming languages out there that each have their own unique uses. languages such as Python and Java, are just general purpose languages that can perform a variety of computational tasks, or robots C or HTML or CSS, or languages designed for more specific purposes, such as moving a robot or constructing a website. languages can also vary and how powerful they are. For instance, JavaScript is a scripting language that is designed for smaller tasks, or Java or Python can carry out much more computationally taxing processes. We can measure a programming languages power, or level by how similar it is to machine code, the series of zeros and ones we talked about earlier. low level programming languages, such as assembly, or C, are closer to binary than a high level programming language, such as Java or Python. The basic idea is that the lower the level of your programming language, the more your code will resemble what the machine can interpret as instructions. Aside from the different purposes that each language fulfills, choosing a language typically comes down to a matter of preference, as are usually many languages that can accomplish similar tasks. Try different languages, and decide which ones rules interface and level of simplification you like best? So now that we know what programming is, how do we actually write code? It sounds like we can simply type words into a text document and automatically assume that the computer can translate it into machine code, read it and carry out a task like opening up a browser. And additionally, we can't just write down rubbish in certain programming languages mentioned in the previous segment, and expect the computer to understand. So how are we supposed to write code then? Well, the answer is with an ID. And ID, which stands for integrated development environment allows the facilitation of code by a computer. It is provide a graphic interface on your computer in which the programmer can easily write, run and debug code without having to worry about problems with complication or interpretation of the program. Think of an ID is any other program on your computer, such as a game browser, or even the file explorer, except we'll be using it to write code, IDs are able to turn your code into machine code and run it through the computer to produce results. In addition to providing a place for programmers to develop their code IDs provide some extremely useful tools for programmers to ease the job of writing code, such as built in error checking, because as we'll talk about later, code doesn't always run correctly. Auto filling for frequently used words or phrases, and a project hierarchy, which will help you organize and manipulate the files within your project. Back in the olden days before IDs code used to be written on punch cards and then fed into computers, which would take hours and cause a lot of pain. IDs nowadays act as sort of a fast track to writing code and make things a whole lot easier for programmers. An example of a specific ID can be seen on your screen now. In the center, you can see the program that is currently being written. And right below it is the console, which can print out useful information for the programmer. This specific ID is used to write Java code. IDs are extremely powerful and will be used in almost 100% of your programming projects. So through these IDs, we are finally able to write and compile code smoothly without worrying about the computer not being able to understand it. The next problem we run into then becomes how do we write this code in the ID. Because it's not like we can just type random words from a certain programming language and expect the computer to understand this is where a programming languages syntax comes into play. Now, just as if you were learning a real language, learning a computer language can be very similar. Some have different styles that may seem odd. Some may make you use weird or abstract concepts which may be confusing. And like all languages, programming languages have a set of rules that you must follow when writing code in that language. And at the forefront of those rules is grammar. Programming grammar is referred to as syntax and is very similar to real world grammar. Each programming language has its own syntax or rules that you have to follow to a tee if you want your program to run correctly, just as if you were speaking in real life. These can be things such as how you type out certain functions, what you put at the end of the line of code, and how you set up certain functions. Each language is unique in its syntax, and while some may share similar rules, all will have some quirk which makes it stand out from the rest. syntax is something that catches a lot of people off guard since many expect every programming language to follow the same set of rules. But as we spoke about in the last segment, because each language is specialized for a specific task, each needs its own set of rules to function. Breaking or disregarding these rules will result in an error. Just how breaking or disregarding rules in real life will result in an unintended message. As an example, if you wanted to do something simple, such as initialize a variable, which is something that we haven't covered yet, but the example is still relevant. In Java, you'll notice how we have to specify what type of variable we're defining, in this case an integer and also add a semi colon after the statement. In Python, we don't even need to define that we are trying to create a variable and just have to type what we want to create. And in JavaScript, we just specify that we are making a variable, but we don't include what type of variable we want to make like in Java. Even in this simple example, you can see how much a syntax matters when learning a new language. Since while the goal of our program remained the same, which was to define an integer with the value three, all the programming languages shown took different approaches. All these languages require that you follow this syntax because remember, computers are extremely dumb. If you forget one semi colon or misplace a character, the entire program will not run and send you back a syntax error, which is something we'll talk about later. Think of this as if you forget a comma in a sentence and the entire context of what you're trying to say gets misinterpreted. For example, in the sentence, let's eat grandma. If you were to forget that comma. While it may seem like a small mistake, it changes the entire context of the sentence, making it sound like you're going to eat your grandma. The same rules follow for programming. If you forget a semi colon, the entire context of your program can be corrupted and misinterpreted by the ID. Now another thing which makes it so useful is that they will let you know if and when there are syntax errors in your code. syntax errors, of course, being parts of your code, which do not follow the same rules where we talked about previously, the ID will tell you where in your code the errors, and also won't let you run your program until the error has been fixed. Because of how important syntax is to writing code and learning a new language. It's recommended that you learn the rules and syntax of a language before beginning to write complex programs in that language. Most of the rules are tedious to learn but easy to master. And as soon as you can do that, you'll be able to easily identify syntax errors and take care of them easily and be writing code in no time. That covers the basic gist of syntax and programming rules. So now that we know how to write code and where to write code, we next need to cover what happens after we have typed out our program and run our code. Because writing a piece of code for a game or for a database is cool and all. But after the computer interprets the program, how will we know what's happening and whether or not is working? Well, programmers do this by looking at the console. The console is a text interface within your computer that us programmers can use for a variety of different purposes. If you remember, a short while ago, we heard a picture of a basic ID. And one of the main parts of the picture was the console. The main use of the console is to output text from the program. This is usually done by using a print statement. A print statement is a command that does exactly what it sounds like. It prints text to the console. The print statement is the first piece of actual code we've talked about in this series. And it's about as simple as the print statement. Despite its simplicity is one of the most important functions in programming and exists in some form in just about every programming language. The most basic thing you can ask the print statement to do is to just simply make it Say something. This is done by instructing the console to print, and then include wherever you want to be printed inside the parentheses. For example, in Python, the segment of code print hello world will cause a message reading HelloWorld to appear onto the console. Pretty neat. The print statement is also vital for viewing interpreting the computer's output from program. For instance, if you could tell a computer to run a simple calculation. For example, to determine what four plus three is, they will run the program internally and compute an answer. However, what is the purpose of having the computer run this program if you will not be able to tell what the result is, instead of simply telling the computer to perform this calculation, instruct the computer to print the output of the program to the console, and upon the program's completion, seven will appear on the console. As you can see, the console allows us to easily print information out to the developer for a variety of uses. It is important to note that the print statement varies depending on the programming language being used. For example, in Java, there are multiple versions of the print statement depending upon whether you would like a line break after the printed text or not, as well as specialized print statements which make your code run more efficiently. Also, the general syntax of using a print statement and certain nuances of its function contains between languages. However, you can generally rely on it to carry out the same overall function as it is a foundational statement for programming in general. All of its functionality makes a print statement along with the console and very useful developer tool. However, it is important to remember that that is all it is the developer tool. The console is not really meant to be viewed by the end user of your program. It tends to be hidden away behind the scenes and other methods of displaying information, such as displaying text, graphics, or images are used to convey information to the user instead, think of it like this. When you're using your phone, you see the console and none of the programs you use. So while you can use the console to give yourself information about how your program is performing, don't try to implement it in the final product because it fundamentally just isn't meant for that. Overall, remember to use the console to its fullest extent when writing and fixing problems in your programs, as it is a great tool to use to tell how your program is performing behind the scenes. So now that we know a bunch of information about programming languages, and how and where to write them, along with the print statement under our belts, let's go over some intuitive things that the computer can do all by itself without you having to tell it how To. More specifically, we'll be covering some basic number mathematics as well as string math. Starting off with basic mathematics, the computer already knows how to do simple arithmetic. This includes addition, subtraction, multiplication, and division, all of which are represented by the symbol shown on the screen now, in any ID that you may install, you'll be able to print out the answer to simple math problems using the print statement. Which may seem counterintuitive, because why would you use the computer to do math when you have a perfectly good calculator on your phone. But you have to remember that computers are dumb. And anything we want a computer to do, we have to build up from scratch. basic arithmetic, while simple helps out in almost any program you may write. For example, if we wanted to build a basic calculator app, we need to utilize this functionality in order to correctly display the answer to an arithmetic problem when our user tries to add, subtract, multiply or divide two numbers. Now in addition to the four basic math equations, most programming languages include an additional operator known as modulus. If this is your first time hearing this word, don't worry, since it's not usually taught in math classes. modulus allows us to get the remainder of a divisional operation. For example, when we take 10 modulus three, we're essentially telling the computer to take 10 divided by three, ignore the actual answer and just give us the remainder of the operation. In this case, one, since when we divide 10 by one, the answer is three remainder one. The one in this case is what gets printed out to the console. If there is no remainder, say in the case that we take 50 modulus two, since the remainder is zero, the function would return zero if we were to print it out to the console. This can be extremely useful. In many cases, the most obvious being if we want to determine whether or not a certain integer is even or odd. If we take a certain number, modulus two, and it returns zero, then we know that is even because any number divided by two will always result in a full answer without a remainder. But if the system returns one, then we know that the integer is odd, you will find yourself using the basic math operators a lot more than you think. So it's good to keep them in mind when running your program. Now, not only can our computer work with numbers, but it can also work with strings. strings, by the way, are just another way to say text. For example, hello world is a string, the letter A is a string, and anything enclosed by quotation marks is denoted as a string in programming languages. We'll cover more about strings in a bit when we talk about variables. But for now, let's continue. We already talked about printing strings to the console. But let's say we're making a game and we wanted to print out the statement, game over for was your final score. Now while we could just make a string that says that exact phrase and print it out to the console, in some cases, it would be more useful to print out the actual integer value, especially in the case of a game where the score can change each time you play. Because score definitely isn't always going to be for. Well, we're also able to print out multiple strings of text and even integers by adding them together in the print statement. This is known as concatenation. Continuing with our score example, if we wanted to print out the statement gameover for was your final score, using four as an integer rather than a string. We could do this by breaking down the statement into two strings and an integer like so. Print game over plus four plus was your final score. We of course begin with a print statement, which again will be different across all languages. But in this case, we're using Python. Inside the print statement, we start off by printing the string game over. Now here comes the important part. From there, we use a plus sign and add four to the print statement. Just like if you were adding two numbers, then we can repeat this process with another plus sign for the final string was your final score. And we're able to print out the entirety of our statement easily. Doing this we can easily print out multiple different strings and integers together in one print statement. We could also combine the two lessons we've learned thus far and do something such as game over plus four plus four plus was your final score. In the case, let's say where you have a game which gives you a base score and then four points for a certain task that you complete it. This demonstration also displays Another important part of programming, which is that oftentimes to get your program to be the most efficient, you have to combine aspects of code. Now it's important to note that the computer will take whatever you put in the parentheses and print it out character for character. So oftentimes programmers will forget to add a space onto the end of their strings. This can result in a small mistake in which the string from the previous example would be printed out as if to say gameover four was your final score, which isn't that appealing when displayed on the screen to the user. So it's a good practice to always put a space after and before your strings to make sure this doesn't happen, and your string doesn't end up like that. Another important thing to note is the difference between four in quotation marks, and four without quotation marks. Now for in quotation marks is treated as a string, rather than a four without quotation marks, which is treated as a number. This may not seem like a big deal, but again, computers are dumb. And if you try to do math with a number in quotation marks, it will return an error. Because the computer doesn't understand that you're trying to perform the operation on a number and thinks you're trying to add an integer to a string, which is a big no no in programming when you're adding numbers. So when you're programming, make sure to make a mental note of whether or not you want to make something an integer or string, because that type of stuff makes a big difference. All right, that concludes our segment on the base power of computers. Now Next up, we're going to be covering one of the most important components of computer science. So make sure you pay attention because next up we're going to be discussing variables, what they are and how we use them. First of all, what exactly is a variable? A variable is simply something that can store information and can be referenced and manipulated. Think of variables like a cardboard box. cardboard boxes, servers means to store items in them, which can be changed that replaced and modified variables are like cardboard boxes to store information for the programmer to reference or manipulate. each variable simply has a type, a name, and a piece of information stored inside of it. The type and piece of information will be covered next, and the name is simply a name for the variable. Think of it as writing out a label on the cardboard box in Sharpie. Now there are many different types of variables that a programmer can use, or right now, we will just be covering what are called primitive variables, which include integers, Boolean, floats, and doubles, strings, and characters. We'll start off by talking about an integer. An integer or int for short, is as simple as it sounds, a variable that can store an integer value. This includes all whole numbers from negative 2,147,483,648 to 2,147,483,648. Notice how I said whole numbers, integer values can not and will not hold any decimal values. So keep that in mind when using variables. Secondly is a Boolean. A Boolean is very primitive variable which can store a value of either true or false. Boolean variables can only hold these two values, and are extremely useful for conditional statements, which we will cover soon. The next few types of variables are floats and doubles. Both of these variable types are floating point data types, which essentially means that these variables can store numbers with decimal places. Whereas integers values cannot hold decimal values, floats and doubles can. The main difference between the two is that a float variable can store numbers of our precision up to 32 bit. All doubles can store numbers with a precision up to 64 bit. Essentially, a double can store more decimal places than a float. So it all comes down to how precise you want the variable to be. Up. Next, we have string variables, which are like the strings we've talked about beforehand, except store somewhere in a value. String variables can store strings of letters, which are just words and sentences. Strings are useful for displaying text and storing input information. Strings can also be concatenated together to form combinations of string variables and pre written strings. This can be very useful for outputting information in a readable format for the user. For example, imagine we have a string called name. The code asked for input and storage that string of text and name. To output this information to the user. Rather than simply displaying their name, you can add the phrase Your name is and make it into a sentence by concatenating. Your name is plus a name plus a period. This makes it easier to read your code, while also adding variability to your code, which always makes things more interesting for the end user. Finally, we have char variables. char stands for character, and just as a name suggests, they can each hold one character. This is useful when a programmer wants to read one button press or one character in a string without using a string variable. a specific example is being a game that is controlled by the keyboard, the program needs to recognize the character that is pressed and translate that into carrying out some function. Now strings can also hold one character, but chars can hold more than one character. So keep that in mind when defining variables. Now, why are variables so useful? Well, being able to store information in a format that can be easily referenced later is essential for any good program. Oftentimes, in code, you're going to want to keep track of things such as a user's name, or score. And so by creating a variable called name or score, you store this information in the variable and then reference it, add to it or modify it. Also, many times to program will want to take input from the user, which cannot be pre programmed into the code, and thus the variables required to store the information. A program may also rely on factors that will change as the program progresses, in which case a variable is once again required. Also, taking these variables and manipulating them is quite necessary for carrying out many of the tasks you want to program to carry out. For instance, multiplying in variables or concatenating string variables. Overall variables are the backbone of any program, and you'll find yourself using them often if you want to clean and efficient code. So it's best that you learn what types of variables you need to use and when. So now that we know all about the different variable types, and we've talked about them a little bit, we're going to delve further into what happens when we actually define or create a variable, how we reference them, and how we can manipulate them for our programs. To start, let's go over what happens when we actually define a variable. Now when we write a line of code, which initializes a variable, and that code is executed, the computer essentially creates a little space in memory that stores your variable name and its contents so that it can be referenced later. Going back to our cardboard box example from the previous segment. Think of this as if you had your own storage facility, and you make a new cardboard box labeled name. And inside of it, you put a piece of paper with the word no pointer exception on it. Now, anytime you want to know the contents of your name box, you could simply look inside and see that it has the contents no pointer exception. This is what the computer does, except the storage facility is the memory in your computer. The box is a variable and the contents of the box or whatever the variable is set to be equal to. Anytime you want to know the contents of the name variable, you can simply call it and the computer will pull the information that is stored in that variable, and use it how the user see fits. Another thing to note really quickly is that you can actually make a variable without putting information inside of it. This would simply be like if you built up a new cardboard box, gave it a label with a sharpie, but just didn't put information inside of it. You're simply saving that space in your storage facility for later. This can be maybe because you want to store information in it later down the road. Or if you're going to use it to store information given to you by the user, in which case you can't give it information since you don't know what the user will input. Just to note that if you try to reference or point to a variable, which does not have any information in it, you'll get what's known as a null pointer exception, which despite being an amazing name for a YouTube channel is something you generally want to avoid when programming. Now programming languages allow us to do some pretty cool things with these boxes that we've created. For example, let's say we created a second variable called channel name. And instead of setting it equal to no pointer exception, we instead set it equal to our already created named variable. This doesn't create a space in memory for this new variable. However, it simply points to the same location of memory we have already created for the name variable. Going back to our storage facility example, this would be like instead of creating a whole new box label channel name and storing sheet of paper with the word no pointer exception on it, we instead simply added another label below the name box, and titled channel name. Now we have two variables which point to the same contents, that being the string no pointer exception, we usually do this to save space in our code for things that we know are going to have the same value. variables can also be updated throughout your code. For example, let's say you had an age variable, and inside of it was the integer 17. Then you celebrated a birthday and wanted to update your age, all you would have to do is reference the variable and set it equal to whatever new integer you want the variable to hold. In this case, 18. This would be the same as having a box labeled age with a sheet of paper eating 17 inside of it, and then taking that piece of paper out, erasing 17, replacing it with 18 and then placing it back in the box. Doing this we are able to easily update the contents of our variables throughout the code as things dynamically shift. As another example, if you were making an RPG, your character would likely have stats such as attack, defense manner, etc. As the game progressed, you could continuously update the variables so that the player could get more powerful, the further along they went through the game. And you wouldn't have to create new variables, you would simply need to just keep grabbing that box from your storage facility, erasing and replacing the numbers on the piece of paper and then continue along with your code. Just keep in mind that these variables are nothing more than places in memory in which a certain value is stored. So we can easily update the numbers and their place will remain constant. After the code has run its course the place in memory is deleted until you run the code again, and the program dedicated space for the variable again, each time you run the code, you're making new boxes in your storage facility. And at the end of the code, you destroy them all to make room for the new boxes next time. Another cool thing you can do with integer float and double variables is add them subtract them, divide them, multiply them and even modulus them. For example, if you're making a calculator app and you store the first number, the user entered as number one and the second as number two. You could then multiply num one and num two together and either print them or store them in a new variable entitled result. Then each time you run the program, the user could input new numbers into the number one and number two variables. And they would simply be set to those new integers that the user inputted and return the result that correspond Through those specific numbers, this allows you to keep easy track of which numbers are which, and what's going on in your program, which is extremely useful. Also, while you cannot subtract, multiply, divide or take the modulus of strings, you are able to add them. Like we said previously, let's say you had a string str one with the contents Hello, and a string str two with the contents there, you could add str one and str two to create a string that had the contents Hello there, either storing it in a third variable or printing it out to the console. The last topic we'll be covering on the topic of variables is the naming conventions of variables, which will be it may seem odd, but it's extremely important when trying to read your code. So we'll be covering it now. Now variables have to be one continuous string. And so if you wanted to make a variable that store the player score, you'd have to find some way to combine the words player and score. Since you can't have the phrase player score be the name of a variable. All programmers have their own personal preference when it comes to naming variables. But the one we'll be using in this lecture is called camelcase, which is the process of not capitalizing the first word, but capitalizing every word that follows it. Going back to the player score example, using the camel case method, the variable would be called player score. This allows us to easily see and identify each word and becomes really useful for long variable names, like the player score before the final boss. Whereas if we just type it out without camelcase, it would be really confusing and hard to read. This will help you out a ton when we start finding bugs in our code and need to quickly scan through our program to figure out what is wrong and adds to the overall readability of the program. Other programmers might use different naming conventions like using underscores to separate the words in a phrase. But for now, and this series, we'll be sticking with camel case. Next, we'll be moving on to conditional statements, which at their core, are statements that change the path of our code depending on certain conditions. For the sake of keeping things simple for this section, where Atlanta will connote that our code will not be following the specific path. In Greenland's I mean, our code is following the path. The main type of conditional statement that programmers use is the if statement, and this will show up countless amount of times in any program you write. It is as simple as it sounds, if some condition is true, and usually that condition will be enclosed by braces, then carry out the instructions located within the if statements brackets, else do another thing. Now, brackets are used in most programming languages to indicate a segment of code which will run it works like this. If the condition in parentheses is true, then all of the code contained within the brackets will run. And if the condition within the parentheses is not true, then it will skip over all the statements within the brackets. A quick note is that while this is the case, with most programming languages, some, like Python, use columns and whitespace to determine where a piece of code starts and ends. But for the sake of this series, we'll be using curly braces. Now, the condition within the parentheses can take on 1000s of different forms, such as if the value of the string variable name is equal to Steven, or if the player score stored in an int variable is greater than five. The list goes on and on. Each of these statements is evaluated as a Boolean, which you will remember from when we talked about variables is either true or false. If the Boolean is true, we run the code inside the curly braces. If it's not, we pretend everything inside the curly braces never existed, and move on with our code. The if statement comes with two more additional statements that go with it elsif and eltons. elsif is a conditional statement used directly after an if statement, and carries out mainly the same function as an if statement. However, the elsif statement will only be evaluated if the proceeding F or the preceding elsif statement is bypassed due to its condition being false. So we will run through it like so. If something is true, we will run the code inside of that statements curly braces out if that's something is not true. But another statement inside of the parentheses is true, we would then run that code segment. And if neither of them are true, we would skip both segments of code and move on in our program. This can be a hard concept to wrap your head around to so let's do an example. If we had a program that evaluated the if statement, if age is equal to 10, we then have a statement under that which stated outs if age is equal to 12. Now, if the age variable was 10, which we can see from the example that it is, then the code immediately following that conditional statement in the brackets would run. The Ultra statement we made will not even be tested. Since we know that it is going to be false. And thus the print statement inside of that conditional statements brackets will be ignored, and the code will move on to the rest of the program. Now for example, let's say we change the age variable to be 12 instead of 10. Now instead of the first conditional statement being true, it actually evaluates as false since age is no longer equal to 10. So what we do now is first skip over the print statement, which prints out that ages 10 and does not. And then we evaluate the elsif statement, we check if age is equal to 12, which again it is. And so now we run all the code inside of that conditional statement before finally moving on to the rest of our program. So as a review, we check the initial if statement. If it's good, then we run all the code within that if statements curly brackets and move on with our program. If the initial if statement is not true, we then move on to any elsif statements and evaluate if those conditional statements are true. We can have as many elsif statements as we want, although this could lead to clutter amongst your code. So we'll talk about some alternatives later to help us out. Now that takes care of the FL statement. So now we'll move on to the else statement. The out statement, once again, it comes after an IF or an elsif statement, and we'll carry out its instructions no matter what. As long as the proceeding statement slash statements are evaluated as false. If we went back to our previous program, we could add an elf statement, which would only have the code in his brackets run at the age variable wasn't 10, or 12. This will catch all cases of the program that didn't fit into our parameters. It's good practice to always have another statement at the end of your conditional statements to catch any weird cases that may come up in your program. Now remember back to the fact that we could have 1000s of Elif statements after a while that can get pretty cluttered. And so another very useful conditional statement helps circumnavigate this problem is a switch statement. A switch statement is functionally similar to many if and else statements together, you write a switch statement in the form of switch variable. And then below that you write out how many cases the variable can be. For instance, if we wrote switch var, and then under read write out five cases that the variable var could be and then the instructions listed under each case would be carried out if the var variable it would be equal to that case. Now switch statements are different sets. Instead of using brackets, they use a column to signify the start of a set of instructions and a break statement to end them. This is very useful, because you are able to essentially use many if and else if statements without having to write nearly as much. In switch statements, you just always have to remember to include default case at the bottom of the expression to denote any and all cases that don't meet the above requirements. There simply catches all the inputs that don't fit within the program's main cases. It's very similar to just case the end of an if else chain. Now, why are these statements so useful? Well, many times programmers want their programs to function differently depending on different conditions. For instance, a program could function differently depending on the information that the user inputs, such as allowing user to use a program or not user program if they are above or below 18 years old, respectively. Or in say, a video game. If the user experiences above a certain threshold, you might want to give them harder opponents to battle. Another example could be a program was changing the color scheme depending on the time of day. Or even more simply, if a user presses a button that is meant to move on to another screen in an app, the programmer would only want that app to change screens if the user clicks that button. A program without conditional statements would do the same thing every time, and would be very primitive compared to one that can change depending on its conditions. So now that we know how to make and use variables, how to compare them, and what we can do with those comparisons, let's move on to another foundational concept of computer science. And that is arrays. Now we've already talked about variables, and how great they are for storing singular bits of information for making our code more simplistic. But one of the biggest drawbacks that comes with variables is their inability to hold more than one piece of different information. For example, let's say you're making an app which allows a user to create a grocery list. Well, there's no real easy way to create lists using variables. Because it's not like you can have one variable store the names of six or seven different food items. Remember, we can only put one piece of paper in our cardboard box no more. And besides, even if you were able to add multiple items to one string variable, you would still have a lot of trouble doing simple tasks you might want from a list such as searching through it, splitting it or even deleting items from the list when you're done with them. This is the problem that using arrays solves for us. An array is as you may have guessed by now, a list, you can have an array of integers, an array of strings, and even an array of other arrays, which is something we'll cover in a minute. Programmers use arrays when they want to store a lot of variables containing information that is all related to each other, such as a grocery list or a high score list in the game. Think of arrays as a column in Excel or Google Sheets. Here the title at the top and then below it are a bunch of bits of information, which all relate back to the title. Arrays are super useful when programmers want to store a lot of information that can be easily searched through because programmers have developed methods of breaking down and using arrays to find specific information in arrays full of 1000s of different variables. As an example to show just how useful arrays are. Let's say you're a startup company that owns an app that has 100,000 users. Every time a user wants to create a new account, they input the username they want and then your program will have to check to make sure the account name hasn't already been taken. Doing this requires you to search through the information of all 100,000 of your users to see if that username has an account with your service and array would be able to get Pain all of this information and make it easy to search through and find out if the account name has already been taken with little to no delay. Now, the single most important thing to note about arrays is how you reference each element of the array within them. Let's create a basic array called numbers and inside of it, put the digits one through 10. Now, when we want to refer to each cell in his array, we would call upon its index. an index is just a fancy way of saying that numbers placed within the array. Now you would think that the first integer in this array would be the first index, the second would be the second index and so on. But that's simply not the case. In computer science, programming languages refer to the first cell as zero with element in the array. This means that if we were talking about our array of numbers we just made, the number four would actually be in the third index, five would be in the fourth, and so on. So instead of starting our count from one, we start from zero. It's extremely weird and confusing, but it's one of those programming quirks, you're going to have to memorize and commit to memory. If you were to not follow this nomenclature, and refer to the last element in this array as the 10th, you get what is referred to as an array out of bounds error, since you're trying to reference the 10th element, but there is no 10th element, where you're actually trying to do is reference the ninth element. Another extremely important thing to note about arrays has to do with their size. When you initialize an array, you can do it in either one of two ways. You can either populate it with the elements that you want contained in the array right then in there, creating and filling the array at the same time. Or you can define how many elements you want the array to hold, essentially the array size, and then populate it with elements later. This is because when we initialize an array, it creates a space in memory that has a size of exactly what you give it. no more and no less. This is great for when we want to access elements in the array, because we can do so instantaneously because the computer knows exactly where in memory the array is stored. But the one downside is that we can't increase the size of the array later on. All array sizes are final. Think of this like setting up a bookshelf with books by populating a bookshelf with a certain number of books. And then moving on and filling the next shelf with different books, we have no way to go back and add books to that first shelf without shifting everything over. Once we decide how much space to dedicate for an array, in this case, there's no way to add more space. Once again, because this is extremely important to remember. This means that once an array has been defined, there is no way to change the size of it. If you have an array titled names with a size of eight, and you try to add another name to the array, you will receive an error. So be careful when messing around with array sizes. Of course, you can always go back to the start of your code, when you initially make the array and allocate more space to it, increasing its size. If you find out that you need more space to hold items, but once it's defined, you cannot change its size through conventional methods. Another small thing I want to touch upon really quickly is that when you initialize an array, you must determine which type of array it is right then in there, for example, you have to specifically say it will be an array of strings or integers when defining it. And also you're not allowed to mix and match. Meaning that you can't have an array full of integers with a few strings and some doubles thrown into the mix, they all have to be the same type. Now the last thing we're going to cover on arrays is a little funky. And that is the practice of putting arrays inside of arrays. If you make an array of arrays is referred to as a 2d or two dimensional array. Think of these as matrices if you've taken an algebra class before. Now, if you haven't Think back to our Google Sheets example, but instead of using columns, we would add rows as well. So now each element in an array would simply just be a string variable or an integer variable. But an entirely new array with its own set of values and elements. The way we index these is mostly the same, except we would have two numbers to index instead of one. We start with the row and then the column. So a number in the positions 02 would be in the first row, three columns down, in this case, the name Clint a number in the position one one would be two rows down and to columns across, in this case, the name Chris, you get the idea. Now you can also make three dimensional arrays by putting an array inside of an array inside of an array, but that's a little above what we're going to be covering. So I'm going to cut it off there. Next up, we're going to be talking about loops. So what exactly are loops? Next up, we're going to be talking about loops. So what exactly are loops? Next up, we're going to be talking about loops. So what exactly are loops? Next up, we're going to be talking about loops. So what exactly are loops? Next up, we're going to be talking about loops. So what exactly are loops? Well, as you can probably tell by that statement right there. A programming loop is a statement that is used to run certain instructions repeatedly. Just like how the opening statement of this topic was repeated five times. loops are very useful for a variety of reasons. For instance, imagine you want to print something 15 Sure, you could just copy and paste the print statement 15 times, but this is really annoying to have to do, it becomes even more unrealistic when that number goes up to say 100 or so. Now what if instead of rewriting the same instructions over and over again, you would simply place the print statement inside of a loop, and it will occur as many times as you would like. Now that's the power of loops. With loops were able to repeat parts of code multiple times. Now, there are three different types of loops that we will be discussing today. And first is the for a for loop is very useful for situations like the one described above, where you would like to carry out a certain set of instructions numerous times. The syntax for a for loop varies depending on the language, however, it usually consists of three parts an integer value, a condition which the integer value must meet in order to exit the loop, and an operation to modify the integer value at the instructions inside the loop are completed. Each time the for loop runs, the operation you set will be performed on the integer as long as that integer still needs to condition your set, usually being greater than or less than a constant value, the for loop will continue to run. Eventually, when the integer has been modified by either increasing or decreasing it to the point where it no longer meets the condition, the for loop will terminate and the code will continue to run. For example, let's say our integer value was I and we set it equal to zero, then we set the conditional statement as I being less than three. So basically, we're saying that as long as I the variable we just created is less than three, continue running the instructions contained within the loop. Finally, we make the operation i plus plus, meaning each time the loop runs, we increase it by one, and inside of the loop, let's just put a simple print statement. Now let's run through the for loop, we start with i equals 00 is less than three, so we enter the loop and print out hello world. Now that the instructions are done, we add one two, I'm making it one moving on. One is again less than three. So we want to get into the loop and print out hello world. Again, we had one two, I'm making a two now to is still less than three, so enter the loop again and print out hello world. Finally, we add one to it once again, and it becomes three. Three is not less than three though, is equal to three, and so we don't enter the loop and it terminates. Moving on to the next segment of code. This is a simple example. But you can extrapolate it across programming to fit your needs. Now when using a for loop, we have to make sure to set up a condition that given the initial integer value and the operation will at some point not be met to avoid creating an infinite loop and crashing your program. an infinite loop occurs when you give a for loop a condition which will always be met given the parameters of the program. And so software crashes. For example, a for the beginning at 10. And checking if is over less than zero, and then adding one to either the end of the loop will never terminate since I will suggest increase infinitely. After the for loop is the very similar for each loop. A for each loop, or a for in a list loop in Python is used for iterating through arrays or lists. Essentially, the loop will go through each element in the array and carry out some server instructions for each value. If you would like to read all of the elements in an array and compare them to some value, or perform some operation on them, a for each loop is extremely useful. So for example, we could have a for each loop which iterated across an array and simply printed out the value of each array location. Next up we have the while loop. A while loop will continually carry out instructions while a conditional statement given to it is true. This can be as long as a certain variable is true. As long as the numbers that's another number, or while a value is still equal to another value. For example, while loops are different than for loops in that the loop is not contained within one statement but stretched out and will continue to run. As long as this condition is true. Like a for loop, you could make the condition such that it will eventually return false and exit the loop. However, while loops will not crash your computer should you create an infinite loop. In fact, it is very common for wild lips to run infinitely. As for certain programs, you would like the program to continually be iterated through instead of running once all the way through until you exit out of the program. When programming a game for instance, a while loop would be used to iterate through your code, continually refreshing the screen as the game runs. From there you can perform operations on the screen to make the game playable. Creating infinite while loop could be done by simply using the syntax, while true, as the condition true will always be evaluated as true. Finally, I'd quickly like to cover the extension of a while loop the do while loop. Do while loops are very similar to while loops, except they will carry out their instructions at least once even if the condition is false. And then we'll carry on like a basic while loop. Essentially, the conditions inside of the loop will run at least once. And then if the condition is still met, they will run again and function as a normal while loop would. As you can see loops in there many varieties has some extremely useful functions. using them, you're able to perform an operation many times in a row. You can iterate through arrays and lists and overall decrease the clutter of your code. Next up, we're going to be taking a break from learning about common programming statements and dive into what happens when the code we write doesn't work. More specifically, we'll be covering the different types of errors that can occur when you're programming and what causes them. Now when you're writing code, you have to understand that things aren't always going to go the way you expected them to. And sometimes the program doesn't always work as you had intended. too. We programmers call these errors. And while annoying, they're always going to come up in computer science, and so it's best to learn what they are and how to deal with them. Often referred to as bugs, errors and scripting languages can be narrowed down to one of three types, syntax errors, runtime errors, and logic errors, all three of which we'll be covering in today's video. To kick things off, let's talk about syntax errors. These are usually the easiest of the three to solve, since they are oftentimes something that can be fixed within seconds. If you remember back to earlier in the video, when we talked about syntax and programming rules, we said that if you were to break the programming rules or syntax that would result in an error. Well, that's what syntax errors are parts in your program where you fail to meet the programming rules, and so the computer doesn't know how to interpret your code. This can be anything from forgetting a semicolon at the end of a statement in Java, accidentally defining a variable with two words instead of one, or even just misspelling the word string when you're trying to define a string variable. Lucky for you guys, these errors are extremely easy to fix, since you just need to figure out where the error occurred, and what the syntax rule you broke was. Now thinking back to IDs, we mentioned that IDs are so useful because they do precisely that. They underline the syntax errors and usually provide helpful hints as to how to fix them. Think of syntax errors as small misspellings or grammatical errors in an essay you're writing annoying, yes, but not the most infuriating things. Another useful thing about it is when it comes to syntax errors is that the program will actually restrict you from running the code unless all syntax errors are cleared, making them even easier to identify and fix. The second type of error we will be covering is the runtime error. These errors don't show until you actually run the code, hence the name runtime error. runtime errors are usually caused by a statement in your code that seems logically sound, but the computer physically has no way of computing it in a reasonable amount of time. The most common of these errors is one which we've already talked about the infinite loop, as a refresher or an example. Think of an infinite loop like this. Say you set your friend down in front of the TV, put on the office, and told him he could leave as soon as Michael made it. That's what she said joke. Seems pretty simple, right? Wrong, because instead of putting in the office, you put in friends on blu ray. Now, Michael, no inappropriate joke, meaning your friend would be sitting there for the rest of his life. This is basically what happens with a computer, you give it some condition that it has to complete before the program can terminate. However, you give it no feasible way to finish that task. This puts the computer in error mode, and most likely it will crash your program. As the computer desperately tries to complete the condition you gave it. As a computer example, if we try to have a program terminate when integer i is no longer greater than 99. But eyes initially 100 and only ever increases, the loop will never terminate, and the program will crash. To avoid these, you generally want to think through the flow of your code before running it, especially with loops to make sure that all of your statements can be completed by the computer. Carefully planning out your code before you begin writing is an extremely useful practice, and something we'll be covering towards the later part of this video. The final type of error that we'll be covering is a logic error. This error is also pretty self explanatory. A logic error occurs when the code runs smoothly without any runtime or syntax errors. But the result that you get just isn't what you want it. For example, let's say you had a calculator app, and you want it to instruct a program to add two numbers, except it multiplied them because you use the multiplication symbol on accident. This leads to the sum being 36 instead of 13. nothing went wrong with the code syntax or runtime wise, the code runs just fine. It just doesn't work as you had intended it to. These are often the hardest types of errors to debug. Since most of the time, you'll have no idea why the code isn't working, and certainly not any idea of how to fix it. This is why it's a good idea to test your code incrementally. Don't wait until you've been programming for an hour before testing your application. We're all to run into a lot of logic errors. Logic errors can be extremely fury ating, and could cost you a lot of time making them a huge pain. But if you know how to effectively debug your code, you'll be just fine. Speaking of debugging your code that brings us straight into our next topic, which is how to debug your program. Now let's say you've written a program, you think it's ready and you're ready to test. You've been working hard on this and you're just wanting to see it in action. You run the program and wait for it to run smoothly and efficiently. Only it doesn't work. you've encountered one of the three errors we've just mentioned. You really want this code to work but how this is where debugging comes into play. If the code is giving you an error, the first thing you should do is read the error. Oftentimes for syntax and runtime errors, the ID will print an error message out to the console. See what line or lines it points to since those little lines with the occurred, and see if you can understand and fix what the problem is. If the error isn't clear, or you've never heard of it, then try googling it as there are many websites out there. So just Stack Overflow, which service forums to ask an answer problems with code. Chances are, if you've had a problem, someone else has had the same issue and there's likely a tested solution. Usually, when the syntax or runtime error pops up, you should be able to find a fix for it fairly easily. However, as I said before, the issue may arise from some loophole or oversight in the code you hadn't planned for beforehand. Maybe you did something as simple as multiply two variables instead of adding them. These are logic errors we talked about previously, these problems usually won't have red text show up to explain what went wrong, you'll have to figure it out yourself. Now, there are a few different strategies that you can use in order to track down and fix a logic error. First, you could use print statements and the console in order to determine where the code is going wrong. Imagine you have a conditional statement that will run one segment of code if an integer x is greater than five, and it will run another segment of code if not, if in your program. X is supposed to be greater than five when the program reached this conditional, but for some reason, the program is still printing out x is small, you can use a wrench they're meant to help. For this problem. Specifically, you could place the print statement before the branch or the conditional that would print the value of x. Now when you run the program, you know exactly what the computer is thinking, printing out the value of x just before the FL statement. While you know the variable has the value you wanted to have. And if it doesn't, you know that somewhere above that conditional is something went wrong, and x was set to a value you didn't want it to. In this case, x is equal to two, which is why x is small is being printed out. Now that we know what the problem is, we can track down where and when in the code, we modify x in order to solve it. Use print statements to determine where your program goes wrong, and then try to track down the cause of these issues and solve them. If you use this strategy, make sure you end up deleting the print statements afterwards to avoid clutter in the console. The situation described above could also be solved using a breakpoint. a breakpoint pauses your program when the line you placed a breakpoint at is reached. If say you would like to program to run through a certain conditional and set a variable based on that conditional. But you are unsure if this actually happens in your code, you can place a breakpoint inside the conditional path that you expect to run. Upon the breakpoint being reached, the program will pause and wait for you to continue it through a button press. This signals that this button occurred where the breakpoint was placed. In this case, the correct conditional path has been reached by your program. You can then continue the program knowing that this was or wasn't where the error in your code occurred. breakpoints can be used in conjunction with print statements. In order to do both pause the program and perhaps view the values of your variables at the moment in time to give yourself all of the information you could want. You can also have multiple breakpoints to help slowly work your way through your program and determine where an error has occurred. A combination of these two strategies will help you easily determine where in your code you have incurred a logic error. Next, let's go over what to do if you think you have tracked down the section of code that causes the problem. You may think you should delete it, but it's likely you put it there for a reason. And you don't want to lose all that work if you don't have to. Firstly, try commenting it out. Comments are used to markup code and explain their surrounding sections. They can also be used to the bug. Anything that is designated as a comment will not be read by the program as code and will be skipped over. Essentially, it becomes something that is only there for you, the programmer to read. The syntax varies from language to language, but it usually involves placing some symbols before or around the code you would like to be commented, examples of how to comment in different languages can be seen on the screen now. Also, when you comment something, the ID will grayscale that line of code, making it extremely easy to determine what's commented and what's not commenting code deletes it in the computer's eyes without actually deleting it. If a problem is present before you comment a section of code, but it's gone afterwards, then that section of code is the culprit. If you comment part of the code out and there are still issues and move on to another section until you find the culprit. Once you do, you can tweak it until it works as intended or deleted entirely. And you'll have a fully functioning program once again. Now that we've talked about what to do if you've encountered an error, and a strategy on how to find and fix it, I'd like to talk about some strategies you can use to avoid errors in the first place. Firstly, backup your code frequently. In the event of the code completely bugging out and you being unable to fix it, you will want the ability to revert to a previous version where the code was still working. If you save frequently enough, you will probably not lose too much work. Version managers like GitHub or subversion can help with this as they backup code to an online cloud service, which you can easily pull previous versions of the program from at any point. Also on top of saving, running your program frequently to ensure that the current version works as intended. This accomplishes two things. First of all, it prevents you from saving a backup that doesn't work second If you encounter a problem, it will be easier to find if you have only made a small number of changes since the last time you ran it, and it worked. And thus, you will only have to look through the new code for problems. If you've spent five hours coding and hadn't run it during that time period, it's going to be likely that at some point, during that five hour code session, you messed up, and it's going to be even harder to figure out where you went wrong. errors, while annoying and extremely frustrating, are a fundamental part of making you a better programmer. Alright, now that we've covered errors for a bit, let's hop back onto the programming statement train and talk about one of the most important concepts in computer science, they'll function. Now, you may not know it, but we've actually been talking about a few functions, this entire series, print statements for loops. And even the basic math operations we've talked about are all examples of functions, which of course, begs the question of what actually defines a function? Well, a function is a segment of code that can be easily run by calling the function name. And depending on the type of function will do something in return. functions can be called numerous times and in numerous places in your code. Essentially, they're like wrapping up a segment of code into a nice present, and giving it a name, which, when called, will unwrap the present and go through the code that you had wrapped up. For example, the print statements we've been using this series allow us to print something to the console anytime we want. Those are functions, you see, we just call the print function and enter in what we want to be printed to the console into the parentheses, and the computer does it for us. Behind the scenes, there's actually even more complex code that is in charge of taking your text and translating it to the console to be printed. The developers of almost all programming languages realize that you don't want to program something that manually has to print something to the console through the use of complex programming. And so they implemented the print statement to reduce the stress and complexity of code on the user, abstracting it to the single line of code that is print. All of that code that is used to print something to the console is wrapped up like a present and given to us in the form of one line. This is actually the main theme of all functions and the backbone of any good program. Oftentimes, in your program, there are going to be sections of code which are repeated and serve the same purpose, or equations, which you want to allow different inputs of. And so you can use functions in order to condense these down into singular lines of code to save both time and reduce clutter on your code. As you will see soon functions are extremely powerful, and will definitely be something you utilize all the time in your computer science journey. The print statement is just one example of functions in everyday code. There are 1000s of functions that are available to you through the IDs. However, because we won't always use all the functions that are available to you in a single program, you have to import these functions from packages found in the ID E, which is something that we'll be covering later on. Now, there are four main types of functions in most programming languages. And they are separated by two defining features, whether or not they take in arguments and whether or not they return values. Let's start by separating them by whether or not they take arguments. But first we have to cover what arguments actually are. arguments are essentially variables that we pass into the function in order to be manipulated, and then either returned back to us printed to the console or used in another operation. Think of functions with arguments like this. If you walked up to your local Five Guys, and told them that you wanted to get food without supplying a type of food, they would probably look at you confused. In order to get the food that you want, you need to tell them exactly what you want to order so that they can give it to you. In this case, getting food is the function and what you order in terms of food is being passed in as the argument based on what you tell them or the argument that you pass into the get food function, they will do something different. You should also note that the argument can be many different things. It could be fries, burgers, sodas, really anything on the menu, and such as the case with arguments in programming. Arguments can be strings, integers, arrays, pretty much anything. As an example of a function that takes in arguments, let's look at the max function, which takes in two integers as arguments and returns the maximum number between the two. Now for this function, if you don't input two numbers or variables for it to compare, it's going to throw you an error. Just like the five guys employee. He doesn't know what you want to eat Since you didn't provide him with any arguments. And the computer doesn't know which two numbers you want it to compare and return Since you didn't provide it with two integers. arguments are a way for programmers to have one function that can do many different things depending on whichever variables can be passed through arguments, add variability to programming and can help diversify your code. Think of it like this, a restaurant that only allows one type of food to be made regardless of what you order isn't going to be very useful or diversified but We're able to pass in arguments and tell them what food we want, our experience can be heightened and more options can become available to us, which is exactly what happens when you start using arguments in your function. Now that we've talked about functions that take in arguments, let's move on to functions which do not, because functions can also be created and used without taking arguments in and still be incredibly useful to the programmer. For example, let's say you're making a text based RPG game, and one of the options you give your player is the ability to view their stats at various points throughout the game. Now every time you come upon this option, and they choose the view stats button, you don't have to type out six different print statements for every statistic they may have, your code would get cluttered and messy very quickly. Instead, what you could do is you could package the six different print statements in a simple function called print stats, you don't need to pass in any arguments into the function, since the function will do the same thing no matter what the statistics on the player are. Now, every time the user wants to view their stats, you could simply call the print stats function, and voila, the user stats are printed for them to view. This allows you to save a lot of time writing code, but also a lot of space, which is extremely important when your programs begin getting into hundreds and 1000s of lines of code, and you want to easily search through it to maybe debug. Okay, now that we've separated functions into those that take arguments and those that do not, let's again, split these up into those that return values and those that do not. Another thing you have to understand is that when you're making your own functions, which is something that we'll be covering very soon, you have to choose what your function will return, if anything at all, functions are able to return values back to the user, whether they be in the form of string variables, integer variables, or even arrays. Now, the thing to note about returning variables is that calling the function alone won't do anything, you have to return the value into something or print it out. As an example, the max function we talked about previously would return an integer back to the user. But in order to do something with it, we would have to either set a new integer variable equal to the result of that max function. Or we can print out the result of the function, which in this case, which is print out the maximum value between the two integers. Using functions which returned values don't do much on their own, you have to pair it with something in order to gain the use from it. Let's do another example. Let's say you had created a function which took in two string variables as arguments and combine that using that fancy string that we talked about earlier, and then return them as a singular string. This combined string function could then be used to create new string variables. Since what it returns is basically a string, the variable would simply be set to whatever is returned from this combined string function. The last type of function is one that does not return anything. And these are known as void functions. Oftentimes, these are like the print stack functions that we created earlier. Simply use to condense large amounts of print statements that appear often in your code. These cannot be set to variables since they don't return anything, and just get the code that's within them run through. So there you have it, the four types of functions, ones that taking arguments and return something, ones that take in arguments and don't return something. ones that don't take in arguments, but still return values, and ones that take in arguments and don't return anything. Each of these four types of functions are useful and unique in their own way. And you will probably find yourself using each of them through your programming journey. So get used to the different types of functions and know how to make the most of them, as they are all extremely powerful. Finally, I'd like to talk about one of the major benefits of functions, which is that it makes it super useful to make large changes to your code without having to go through the entire program. Each function call is essentially just a copy of that functions original code. And so it's very easy to make changes to that initial function, and have it translate across your entire code. Let's go back to our print stats function and say that you wanted to go back and add in a new statistic that the player could level up and through experience in the game. Without functions, you'd have to go back into your code and find every instance that you'd printed out the user stats and create another print statement to display the new statistic. However, if you had created a print stats function like we did just a while ago, all you would need to do is find out where you define that function and add in a print statement, which displays the new statistic and you're done. Now every place which you had previously called the print stats function will now also print the new statistic as well. You can see just how powerful functions can be if used properly, and we haven't even scratched the surface yet. Now, up next, we're going to cover how we can import other people's functions that they've written and use them in our code. Before we get technical, close your eyes and imagine you're trying to build a house. Sure, you could grow your own trees, chop down your own wood, make your own tools and nails and build from scratch. But why do that when you can simply go to your local Home Depot and buy these materials that others have already made ready for you. That's the main idea behind importing functions into your code. Importing functions allows you to gain access to libraries of functions that other people have already made for you. This is just as useful as it sounds. There are so many functions that are super useful for any given program, that it will take you forever to write them all yourself. Luckily, other people have already done most of this for you. In each programming language, you were able to use an import statement to import libraries of functions into your program that you can use as you write it. A library is simply a collection of functions that all have the same theme, and maybe a math library, a data analysis library, a library that was translated text, or anything you can think of really, there's such a variety of libraries for any given language that most functions you require that are not hyper specific to your program can likely be found at some library. In fact, a good portion of any programmers job is looking online for packages, which can make his or her job easier, instead of hand writing functions. Now I can hear you saying, Wow, that's sick. How do I do it? Well, it's quite simple, an import statement. In most languages, an import statement consists of three parts. The library you would like to import from the package you would like to import from that library, and then which class from that package you would like to use. For example, we can load up the Java library. And from there import the util package, short for utilities. And then from that utilities package, import the scanner class, a class which allows us to read information from the user. A package is simply a smaller set of functions and methods to help differentiate between the 1000s of methods contained in a library, and a class is even more specialized than that. Now, if you don't know what specific classes you're going to want to pull methods from, you can use a start import all classes within the package you'd like. However, it can be beneficial to be more specific, and only import the classes you would like, as it helps with the efficiency of the program in the long run. For instance, in Python, the syntax to import a library is import followed by the library name. However, importing an entire library is more computationally taxing than importing specific functions from a library. Imagine you would only be using the factorial function from the Python math library, it would be a waste of computing power to import the entire library, and it would increase the load time for your program. For smaller programs, this isn't a big deal. But it really starts to add up when dealing with larger projects. Therefore, you would instead use from math import factorial, or the Java equivalent import java dot math dot factorial, and now have access to that one math command only. This limits the functions that you can use. However, it saves programming runtime, if you decide you want to use another function that you hadn't planned for, you can always go back and import that too. Many times. If you try to use a function from a common package, and you have not yet imported, the ID, he will prompt you to do so if you're trying to figure out which libraries you want to import, think of the functions you're going to need in your program, perform a simple Google search. And you will probably run into a package or library that already exists in your ID that you can use. And if you can't, there are ways to download and import additional projects to fit your needs. But what if, after all that you still can't find a library that contains the function you're looking for? Well, that's a perfect segue into what we're going to talk about next, which is the basic structure for writing your own functions. So at this point, we've talked about both what functions are and how we can get some very useful functions by importing them through packages. But there are definitely going to be moments in your programming career where you're going to want to make your own functions because you want one to be made specifically to your program in code. Luckily, making your own functions is extremely simple. There are just some basic rules that I want to cover. Now we've previously used making functions as an example. For other topics such as the Player Stats function from a little bit ago, they were extremely abstract and didn't go into depth into what is needed for an actual function to operate. So right now, we're going to be covering a skeletal system of everything that needs to be included in a function in order to get it to work. Now think back to the four different types of functions that we talked about previously, functions that do and don't return values and functions that both do and don't take in arguments. For creating your own functions. We're just going to have to go down the list and talk about how to approach creating each one of them. Starting with the most basic of the bunch, one which takes in no arguments and returns no values. Before we start that there are a few small things I want to note about function naming conventions, the variable naming conventions we talked about previously. also translate over to function names. So you can't have two word functions, and you can't use special characters like periods or commas. Generally, you're going to want to follow the same camel case style, which we talked about in the variables video, which is not capitalizing the first word, but capitalizing each word after that. Alright, so in general, for making functions, each language differentiates on how you tell the computer, that it's actually a function. In Java, you have to define the function scope, which is something you don't really need to know unless you're going to become more invested in Java. But basically, it tells the computer which parts of the code can use the function in which type can, for this series, all of our functions that we make are going to be public. From there, you then determine which type of function it is. So in this case, since it won't be returning any variables, we'll just put void to signify this type of function will not be returning anything. Finally, you put the function name after those two identifiers, along with a set of parentheses after it like so, the parentheses are where your arguments would go, if you were making a function that took in arguments. But since for our first type of function, we're not incorporating arguments into this function, let's just leave those blank. All of that is just for Java, Python, on the other hand, all you have to do is put the word def, short for define, and then the function name with a set of parentheses. So as you can see, each language is going to be a little bit different in how you make functions. But the main thing we want to remember is to always add parentheses. From there, we just have what we want our void function to do within the confines of the function and close it off, and we're done. In Java, the confines of the loop would be whatever is contained within the curly braces. And in Python, it would be until you are no longer indented. At its core, this is the most primitive type of function, we've made. Something which takes in no arguments and returns no values, quite similar to the print stats function from early on. Moving on to the next type of function, creating a void function that takes in arguments. Now this process is going to seem very similar to the previous except for one small adjustment. Remember the parentheses that I mentioned earlier? Well, we put any variables, we want the user to pass into the function into these parentheses. And then when we call that specific function, it will be required to have those variables passed into it. For example, in Java, let's make a function that takes in two numbers and prints out the product of those numbers. We start with the public void plus name of function setup again, since we won't be returning any values, and here comes a new part. Inside the parentheses, you define which type of variables you would like to pass in as arguments, in this case, an integer and then a name for that variable. This name is what you will use to refer to the integer that the user passes in. For example, let's just call it num one. Then if we want to add another argument, we simply add a comma in between the two and we can make another integer variable num two to hold the second number. We can do this for however many variables we want to pass into the function. But for now, let's close off the parentheses and just print out the product of num one and number two, as you can see, we refer to the two numbers that the user will input into the function has num one and m two, whatever numbers that the user passes into the function will be converted into num one and m two. Now, whenever we want to call the multiply numbers function, we just have to make sure that we are putting two numbers in as arguments. In this case, the number five becomes num one and the number eight becomes num two. From there, we simply run the code and the number 40 is printed to the console. It's pretty important to note that you can also mix and match variables when making arguments. So you can have some function which takes in a car, an integer, and two strings all within one function. The last thing I want to mention about arguments is that when you call a function, you have to follow the variables you defined when making the function. So for our multiply numbers function, you couldn't put in a string and then an int, it has to be two integers, because that's what the computer is expecting to be passed into the function. So now that we've gone over how to make functions that don't return variables, we have to cover those that do. And we'll start with ones that don't take in arguments. Now the main difference between defining functions that return variables and defining ones that do not is that in some cases, you have to specify that you want this function to return an integer variable. This is most common in Java, where you would replace void with int to tell the computer that you want this function to give you something back to you in the form of an integer. This works the same as if you wanted to return a string care or even in an array. You simply replace the word after public with whatever variable you want to be returned by that function. The most important thing to remember about making functions that return variables is that no matter what path your code takes, it must return a variable no matter What? What does this mean? Well, let's say you had some string function in a game. And inside of it, there was an if statement where if the player score was above 10, you returned a congratulatory message. This works fine if you printed the result of this function, and the player score is above 10. But if the player score was less than 10, then you don't enter the if statement, and then you don't have something prepared to be returned to the user. And so the function is going to throw you an error, you have to have all your paths covered, which may seem simple. But if you're making a function with a switch statement in it containing high amounts of cases, then this can get out of hand very quickly. Something I like to do to make sure this doesn't happen is put a return statement at the bottom of a function with a string or an integer so unique that I'm able to tell that the code is not running properly and can fix it. Also, usually, an ID will let you know if there's a path in your code or in a function that does not return a variable when it should. The main point I'm trying to get across however, is always cover your exits and make sure you have a return statement prepared for any case the user may throw at you. Another small thing to note is that you can't return one type of variable if you've already defined the function to return another type. For example, you can't return a string and an integer function or vice versa. The return statement must always match the type of function no matter what the final type of function is one that returns variables and also takes in arguments. And for these, all you need to do is combine what we've learned from the previous cases. First, you assign your arguments in between the parentheses making sure that you've also defined what type of variable you want to return, and then ensure that no matter what path the code takes, that you're always returning that variable type. That concludes our discussion on functions. As you can probably tell, functions are an extremely vast subject area, and require a little bit of practice to fully understand, which is why later on in this series will recommend some websites you can use to practice those more difficult topics. Now, I'd like to switch gears a little bit and continue our discussion from earlier on arrays. arrays, while useful aren't the only way to store and manipulate information. In fact, there are a multitude of different ways to store data in computer science, including linked lists, stacks, queues, maps, trees, and many others to right now though, I'd like to talk about two cool, wacky and zany ways to store data that we haven't previously covered, array lists and dictionaries. But before we get into those, let's get a little review and reinforcement of arrays. As you may remember, arrays are basically lists of values that are stored together. When you initialize an array, you give it a size and this size is fixed, you won't be able to increase the size of the array. So when you make an array of length is final. To access the values in an array, you reference them using an index for starts at zero. What this means is that the first item of an array is not at position one, it is that position zero. And its position is commonly referred to as its index location. So to find the nth item in an array, you would refer to it as index location n minus one. However, as the size of an array is fixed, you have to be careful to not reference a position that's beyond the total size of the array, or to append too many items to it. As this will return an error. We also have what are known as two dimensional arrays, which is an array containing an array and each of its indexes. Or you could have an array containing arrays containing arrays containing arrays containing arrays, depending on what you're trying to do. multi dimensional arrays can be useful in more advanced programs for organizing a wide volume of related values. If that's confusing at all, just get back to earlier for our full discussion on arrays, the timestamps will be in the description. Now that we've reviewed arrays, let's go over array lists. Array lists are just lists in Python can be thought of as a growing array. Earlier, we mentioned how you have to be careful to set an appropriate size of your array, and to make sure that you only referenced in the pin values such that you remain within the size. However, with array lists, this isn't a problem. After you initialize an array list instinctively has a size of 10. What if you append values, such that the size of the array list goes beyond 10 elements, an array list will grow itself, meaning that the computer will allocate more memory to the array to increase its total size so that the new values can be appended. This is quite useful when you don't know the exact number of values that the array will need to store. Or you want the ability to store more values to your heart's content. such as when you're making a database with an unknown amount of users that will sign up. There's a lot more to uncover when regarding array lists. But for this surface level series, that is all you pretty much need to know. So let's move on to dictionaries. Now when we're talking about dictionaries, we're not referencing that thick book you probably have lying around your house, which has 1000s of definitions. In computer science. dictionaries are like arrays in that they store multiple values. Use, however, their values are stored very differently. Rather than being referenced by their linear position within the dictionary, each value is tied to another value that is used to reference it, or its key. Because of this, we need to throw away all conceptions of dictionaries as a linear way of looking at data. Since in actuality, it is much more fluid and entertaining. Basically, we say that each position in a dictionary holds a key value pair. When referencing a value in a dictionary, you will use its unique key, and the dictionary will tell you the value that it is tied to think of it like this. Each time when item to your dictionary, your computer creates the handcrafted box to store the data. And also a custom makes a jewel key one of a kind, no other like in the world. This way, there's only one key that goes to the box that stores a certain bit of information. Because each key must be unique, we're using the key in a dictionary, it will result in an error being thrown. Because having two keys that are exactly the same will confuse the computer as to what box or piece of information that key leads to. However, you can store the same value in multiple key value pairs since the keys would all be different. Now, like I said, dictionaries are more fluid, making them easier to organize and then arrays as everything is set up in a more logical manner. That is to say, it is easier to find the value you are looking for when you're using keys, rather than simply referencing their positions. Let me explain what I mean. Imagine you have a dictionary of prices at a store where the key is the name of the product, and the value is the price of the item. Maybe apples cost $1 milk costs $2 and bread costs $3. You can see the in the dictionary, each key is the name of a product, and each value corresponds to the price of each product. So to find the price of bread, all you need to do is simply call the dictionary using the key bread. This makes it extremely easy to track values through your code. Since you're working with tangible values rather than numbers which don't mean anything to you. You can also manipulate dictionaries and money the same way as you can manipulate arrays and array lists. You can iterate through a dictionary and perform many operations and comparisons on the values. If you want to find the product with the highest price for example, you can iterate through the dictionary to find the value that is highest amongst the grocery store items. arrays, array lists and dictionaries are useful in their own right, as are the mass amounts of other ways to store data, and each boasts certain advantages over one another. We already covered the basics of these three. But since there are so many, we don't have time to go in depth into each and every one of them. And so in order to help you grasp the basics of storing information, we're now going to talk about one of the most important functions needed to understand arrays, which are searching algorithms. Now just as there are many ways to store information in computer science, there are even more ways of searching through lists. Searching algorithms at their core are ways in which we can look through a list of values stored in an array, say a patient name list or a high score list and find a particular piece of data. The goal of a searching algorithm is simply to give the algorithm a string or object you want it to find and have it return the index of the array that contains that string or object as fast as possible. Now while this may seem simple, lots of software runs on the backbone of being able to search through lists extremely quickly, making searching algorithms and in particular, efficient searching algorithms an important topic to cover. Additionally, this is the main functionality that arrays are used for. And it's the backbone of many of the methods used within ArrayList as well as many other storage methods. So knowing them will take you a very long way. Typically, searching algorithms are used to return the index of a particular data points so that it can be used, modified or updated or checked on. For example, if you're about to check into a hospital run on an array system for patients, the staff must search through your name in the database. And by returning the index of where your name is, they now have a quantifiable number that they can use to easily check you in, rent out prescriptions schedule you for checkups, update your personal information, etc. Without having to search through the list for your name every single time. You may think that there's little difference between searching algorithms since computers nowadays can perform millions of calculations per second. But when you're a huge multi billion dollar corporation trying to find a certain data point in a list containing 1000s, or even millions of data points, small differences in efficiency are going to make or break the user experience. Even a 1% improvement in efficiency can mean a big differences in the amount of time that a user is waiting for a simple task. Now before we jump into different types of searching algorithms, we must discern between the two states that a razor list can be in either sorted or unsorted. A sorted list of information is characterized by some sort of rankl value, whether that be a patient ID, credit card number, or even by alphabetical values like usernames or legal names. An unsorted list is just some random assortment of related information not sorted by any particular order or reason. Some searching algorithms only work for sorted lists, usually the more efficient ones, and some work for both sorted and unsorted lists. Although these are usually less efficient if you end up pursuing computer science further, you'll have to deal with both sorted and unsorted lists. So it's good to know a common searching practice for both. Another thing to note is that we determine the efficiency of searching algorithms, based on both the worst case scenario and the average number of items that must search in order to find the index. We call this big O notation in which each searching algorithm has an equation which takes in the size of the array as an integer and, and will output a worst case scenario efficiency value that we can use to compare with other searching algorithms. We can then also look at how long on average it takes to find an element in a list. Using these two methods allows us to easily compare how efficient two algorithms are. Alright, now that we've got some background on searching algorithms, let's hop right into it. The first type of search we'll be talking about is called a linear search. And Eve honestly probably uses multiple times throughout your life. Every time you have to search for your name on a list of people, you probably follow the same pattern, you start at the top check to see if the first name on the list is yours. If it is great. If not, you move on to the next name on the list until either you find your name or you don't in which case you leave. A linear search works in the same way, you start with the first element in the list compared to the value that you're trying to find. And if they're the same, you found your match and you return the index of that element. And if not, you move on to the next element in the list until you either find the thing you're searching for, or you run out of lists to check. Pretty simple, right? This is because linear searches are pretty bad when it comes to efficiency, especially in the worst case scenario. If the item you're searching for in the list is the last element, you're going to have to check the entire list of items before you find the one you're searching for. On average, however, you're going to get it about halfway through the list. This makes the linear search oven worst case scenario since in the worst possible case, it will take the entire length of the array or n to find the correct value. But linear search on average will return the correct index in O of n divided by two. We're halfway through the list. Now while the linear search is in great, it can work with both sorted and unsorted lists, because of the fact that it will eventually cover every element in the list. The other search we're going to cover requires the list to be sorted, which may seem like a drawback, but having a sorted list allows you to use algorithms that are far more efficient than the linear search. So overall, the linear search is a good basic searching algorithm for if you have an unsorted list. But if your list is sorted, there are way more efficient options out there for you, such as the binary search, which we'll be talking about now. The binary search uses a recursive process to break the data in your list down into more and more manageable bites. Taking advantage of the fact that it's sorted in order to find the item you're looking for faster. This one is much harder to wrap your head around. So let's start with an example. Let's say you have a list of 10 names sorted alphabetically, like shown on the screen now, and you want it to find your name within that list. in binary search, you would look for the middle most name, in this case, the one at the fourth index. Just a quick aside, since there is no true middle since the list is 10 names long, the computer automatically uses the next one down as the middle value. Now, once you find your middle value, you first check to see if the name you're searching for at the index you've chosen is the name that you're looking for. If it is you simply return that index. But 99% of the time it's not going to be including right now. So let's keep going. If the value at the middle name is not equal to the one you're searching for, you check to see if the value you're searching for comes before or after the middle index. For example, if you were looking for the name Brandon, and the value at the middle index was Carl, Brandon obviously comes before Carl alphabetically. And since we know that the list is sorted, what we can now do is ignore the entire bottom half of the list and just focus on the top. Since we know that if Brendon is even in the list, it's going to be in that top half. Now we simply treat the top half of the list as an entirely new entity and repeat the process over again. Again, we would find the middle most element of this new list of names and again compared to the name you're trying to find. If it's the name we're trying to find we return that index, but if not, we compare it to see if it comes before or after the middle index. Going back to our example. Let's say the middle index of this new list is AJ. Now we know that Brennan comes after AJ alphabetically. So what we can now do is ignore the top half of the list. Since we know that if Brennan is in the list, it's not going to be in the top half of our list. Now we again repeat this process again and again until we find the name we are looking for. So if For example, the middle index is time is Brenden. And that's what we're searching for. So finally, we would return the index to in binary search. Eventually, the index we were compared to our search term will be the same. And once it is we can return the index and move on. Now if we don't find it, which happens after we have eliminated the entirety of the list without finding our search term, the algorithm will simply return a null value to let you know that the item you're searching for cannot be found in the list. The binary search is way faster and more efficient than a linear search. Since we are drastically cutting down the amount of elements, we have to look at making the program run faster. In almost 99.9% of cases, in which your list is sorted, the binary search it's going to return a result faster than the linear search. So if you have a sorted list, your best option is to go for binary. As for efficiency, the binary search is O log n for the worst case scenario, which could be confusing if you don't fully understand logarithms. But all you need to know is that it is way more efficient than the linear search. Its average scenario is actually also o log n as well, which again, is infinitely times more efficient than linear cases. Now while there are other types of searching algorithms you can use, these two are the most common for both unsorted and sorted lists. So we will stop there for now. Up next, we're going to be covering one of the most confusing and important topics in computer science recursion. Let's start with the most important question, what exactly does recursion mean? in programming recursion refers to functions that repeatedly call themselves meaning that any instructions that occur within a function, one of the instructions will be a call to that same function you're already in. In the extremely primitive example, on your screen. Now, you can see we have some function which, in the confines of itself, calls itself, a recursive function will usually take into account some integer as an argument. And we'll use this to carry out some instructions, modifying the integer that was entered before calling itself again with a new integer as its argument. To better understand these functions, let's discuss the basics of how we go about programming one of them. A really good and easy example of a recursive function is one which sums up all numbers from one to n. So let's make a recursive function that does just that. The first thing we need is the actual function. And we're going to make it an integer function, which takes an integer and as its argument, the reason we do this will be explained later. But for now, let's move on to the base case. A base case is simply a definite value, which all recursive statements are the ones that are being repeatedly called as we go through the function tried to get towards at the beginning of the function, we test the value that was passed in by the argument against the base case to see if it is satisfied. Usually, these base cases are some requirements like of n as I described before, which has a certain value or is equal to a certain value, it is extremely important that the base case is set to some requirement that and will eventually meet for the same reason that it is important to avoid an infinite loop. We do not want a Stack Overflow error to occur. For example, if our base case, what's the stop calling the recursive function when n was greater than 100. And if it is not, we will call the same function again. But with n minus one. And we started with ns, say 99, we would never reach the base case and the recursive functional or purely call itself over and over again, subtracting one from n and hoping that somehow it will eventually be greater than 100 until your computer crashes. Not fun. So anyways, back to our recursive some example, let's make our base case when n is less than or equal to one. This way when you start at some positive integer and and subtract from it until it is less than or equal to one, in which case we can exit the recursive statement. Cool. Now, if n is not less than or equal to one, what we want to do is return the sum of both n and then the returning value of our recursive sum method minus one. Why do we add and the function call? Well, let's actually go through the function as if we were at the computer and see why we start with a call of recursive sum with n equals three, we know that three is not less than or equal to one. So now we tried to return a recursive sum of n, which is three and the returning value of recursive sum within n of two. We don't know what the returning value of recursive sum with an N of two is. So we have to go through the function again, only this time and is two again, and is not less than or equal to one. And so this function will go through the lF statement and return to plus another recursive statement, in this case, the returning value of recursive sum with an N of one. So once again, we have to go through the recursive sum function to get that value that will be added to two and then returned and added to three And then returned, hang in there, we're close now in this function, and is less than or equal to one, and so we return n, which is one. Now we take that n, which again is one, and that is what gets added to to the previous function call, and then return. So this would return three. Now, this three is what gets added to the first function call, which is three, and so it becomes three plus three, which is six. And finally, after all that time, we get six return from the function, which if you've been following along at home, three plus two plus one is indeed six. Now this may seem like a waste of time, since three plus two plus one is not a hard operation. But those of you saying that I asked you to please give me a sum of all the numbers from one to 3567. Godspeed. Now recursion is a very difficult concept to wrap your head around. So if you're not 100% comfortable with it at the moment, feel free to rewatch this section of the video in order to better familiarize yourself with it. Alright, cool. Now that we have a little background on recursion, let's talk about why it works so well. Now to understand why and how recursion works, we must first understand what a stack is. A stack is a data structure that contains all of the tasks you instruct your program to complete. Based on a certain method, your program will then carry out the tasks you give it is called a stack. Because if we start another process before the previous one completes, the process is stacked on top of the other one, such as the animation on your screen is showing now, programs we write will follow the LIFO structure. For those unfamiliar with accounting LIFO means lastin. First out, or the last item put on the stack will be the first one removed from it. Essentially, every time you ask your computer to complete a task, that task is added to the stack, and will be the first one to be resolved. Think of it like a stack of stones, you can keep adding stones on top of your pile. But in order to get to the one at the bottom, you must first remove all the rocks on top of it. Now when your functions continually cause itself without end, without a base case, like in our infinite loop example, then this stack will never be resolved, as items will be continually added to the stack without any of them ever been completed. In this case, the memory allocated to the stack exceeds the maximum allowed and a Stack Overflow error occurs resulting in your program crashing. Think of this as if you're doing chores. And before you complete one chore, you get called to do another chore. And then before you can complete that one, you get called to do another one. Since you keep stacking tasks, or shores on top of one another, the stack of tasks will never be completed. And you will probably die before ever finishing all of your chores. This is the same logic that makes infinite loops crash your program. recursion works on these same principles. The initial call makes a second call, which is added to the stack. And now that one must be taken care of first. But in that one, another function is called which gets added to the stack, and so on until you reach the base case and what you slowly start going back down the stack. In conclusion, recursion in general is extremely useful, because by calling the same functions repeatedly, it breaks down the problem into smaller sections, and results in the program being more efficient. small parts of problems are easier to solve and less taxing to compute than the entire problem at once. And the computer can combine these small solutions into the whole solution at the end. Now as we wind down our introduction to programming series, we want to take some time and go over some of the soft skills needed to be successful computer scientists. Since it's not all about writing code. In fact, many professional computer scientists will tell you that the majority of their job is spent thinking about code rather than actually writing it. This is because much of programming boils down to problem solving. How do we optimize the system? How can we make this feature for our app? What type of movement Do we want for our game? And how can we program it? The harsh truth is that no good program has ever been written simply from the programmer, getting the prompter idea, sitting down, hopping on an ID and starting to write code. There are many tasks we should go through beforehand in order to plan out our code. So we ensure that when the time comes to program, it's a clean and easy process and not riddled with mistakes and bugs. This is where pseudocode comes into play. Think of pseudocode like this, if you wanted to take a family trip to the Grand Canyon, would you simply hop in your car and drive off and figure out things later? No, because that would be ridiculous. Instead, you would spend some time planning out the trip. What sites or places do you want to visit? What hotel reservations are you going to have to make? What kinds of things are you going to do when you get there? What routes or highways are you going to take and why? All of these things must be determined before you can even think about hopping in your Ford Explorer. So how does this translate to pseudocode? Well think of our family trip to the Grand Canyon as a program, programmers use pseudocode pseudo meaning not real, and code, meaning code as a means to plan out their programs before they write them. Just like how we planned out our trip before going. They throw away syntax and naming conventions for variables and just focus on what they want the program to accomplish, and how they plan on doing that. pseudocode is very similar to constructing an outline for a paper that you're writing, you write down the main topics of the essay, and plan out your major talking points. But you don't worry about the nitty gritty details of it all, such as word choice, grammar, conventions, and proper formatting. By doing this, we allow ourselves to think freely and not worry about stressing the small stuff, at least not yet. Alright, now that we know what pseudocode is, let's talk about how we write pseudocode. You see, the best part about pseudocode is that it can take the form of many different things for many different people. Each computer scientist has their own methodology for planning out their code. And there are probably hundreds of different methods of writing pseudocode that are out there today. Today, however, I'd like to focus on three popular ones that I think you might find to be extremely useful. The first of these is known as flowcharts. And mainly they can be used to think through the process of a particular function. a flowchart is fundamentally a graphical representation of a function and how it might flow. Many programmers do this and lay out the conditional statements and loops that they want as different blocks in the flow chart connected by arrows and charting out every path of their function. From there, it's extremely easy to create test cases and follow them through the flow of the function through the different blocks and arrows. For example, we could have a flow chart that goes something like this, a user enters in a number, and if the number is eight, I want the program to return true. However, if the number is not eight, then I want it to return false. It's a great way to visualize what the functions overall purpose is, and also look for any errors that you may have missed when thinking about the function, such as a missing path. It also abstracts the programming statements up to simple blocks, making it easier to modify or change completely. The best part is that when you have finished testing cases, you can simply convert the blocks into programming statements, and you have a well written function without any debugging. Another popular pseudocode technique that is often used is to simply write out what you want your code to do chronologically. don't necessarily think about what programming statements and functions you want to use. just jot down from start to finish what it is the program you're writing is going to do step by step. For example, let's say you're making an app that takes in two numbers and divides them. The pseudocode for that would look a little something like this. First, I want to prompt the user to enter a number. And then I want to wait for the user to enter in that first number. After I get the first number, I want to again prompt the user to input a second number. Once they do, I complete the operation by defining the two numbers entered and returning the result back to the user. This all seems like it would be common sense. But remember that oftentimes, we're not going to be working with simple multiplication or division functions. We may be working with full scale games, algorithms or user interfaces with many different options. This method allows you the programmer to not get bogged down with the syntax and conventions that you have to follow, you're simply making a note of what the program's ultimate goal should be, as if you were explaining it to a friend of yours. This method really lets you plan out everything that needs to happen in your program in order for it to run smoothly. It also ensures you don't forget about a piece of an algorithm or a certain function that you need to write in afterwards. And the final pseudocode strategy that I'd like to talk about to you today is writing out the main features you want the user to have when using your program, and what functions or smaller programs, you're going to need to complete these features. Let's do another example. Say you're making a banking interface. And on startup, you want the user to initially have two options, they can set up a new account, or log into an existing account. From there, if they log into their account, then you want them to have the functionality to withdraw money, deposit money, take out a loan or pay back a loan. If they decide to set up a new account, you want them to be able to create an account, store their information in a database, and then access all of the features that are returning member would have. This may look very similar to the flow chart method. The only difference being that this is abstracted one level higher over an entire program, rather than just a single function. If you really wanted to, you could also create a flowchart that would go through the functionality of all the four methods described above. Setting up a hierarchy like seeing on your screen now makes it easy and clear to see every function interface you're going to have to make. This prevents you from having to try to shoehorn a function or feature into an already finished program at the last second, which is not a very fun experience in the slightest. So There you have it three pseudocode strategies you can use to plan out your code before you even start writing any the flowchart method, which is good for thinking through the flow of a certain function. The write up method, which is good for getting the general idea down for a program, or the functionality planning method, good for listing out the functions of a certain programs, you can use all of them, none of them are a mixture of them, or even disregard these and find and create your own pseudocode methods. The main goal here is to drastically minimize the amount of errors that occurred during your program and relieve a lot of stress on your head. The importance of pseudocode cannot be stressed enough. And if you don't believe me, I urge you to try to complete a large project without it. Okay, so if you've watched the series up until this point, you've gotten a pretty good understanding of many aspects of programming, and also how to plan out your programs. Now it's time to go out into the real world and write some actual code. But what kind of program I can hear you asking me? And the answer is truly whatever you want, really, as I'm sure you know, by now, you can program just about anything you have on your mind. Anything from simple games to complex software. This video has equipped you with the basics that are going to need to be used in pretty much any program you decide to write. But that doesn't mean that every programming language is perfect for every application. Each language has its own strengths and weaknesses. and choosing the right one is very important for making it easier, and sometimes just even possible for you to program what you want. So that's what we're going to be talking about now, choosing the best language for what you want to accomplish. Now, we talked earlier about low level versus high level programming languages. In case you forgot, let's do a quick refresher. higher level programming languages have a higher level of abstraction from machine language, that series of zeros and ones from way back when, while lower level programming languages have a low level of abstraction for machine language. For example, block program where you can drag and drop programming statements together like 2d Legos would be a high level language, as it does not take a high level of understanding of the inner workings of a computer to programming. The theoretical highest level of a programming language would be if I could just write down what I wanted the computer to do in Simple English, and it would just work. But sadly, that doesn't exist yet. On the other side of the spectrum, the lowest level programming language would be just feeding zeros and ones into the computer at supersonic speed, which would be almost impossible and extremely absurd. So how do you choose what type of language is best for your needs? Well, it depends on what you are trying to do, as sometimes you need very specialized languages to get done what you want. The world of computer science is vast and contains many fields. So trying to cover everything in one language would be impossible. This has led to the creation of hundreds of different programming languages, each designed for a specific task. Right now though, we'll cover some of the most popular languages and their uses. Now, if you are trying to design a website, using HTML and CSS is probably your best bet. HTML is a markup language that is designed for writing the content of a website. While CSS is great for designing the style of the website. you interact with HTML every day. And you can even see it right now. If you right click and hit Inspect Element. This will truly show you how complex HTML and CSS can be. Maybe it would be best for you to use a scripting language. A scripting language is a language that has many commands for you to use. And that can also be run without needing to be compiled. Scripts can be faster to write in most programs, and tend to be easier to port between operating systems allowing for cross platform support. Scripts can also be used with websites, oftentimes adding to the overall user experience of the site. If you want to go into web design, this might also be a path for you to go down. Examples of scripting languages are Perl, PHP, Ajax, and JavaScript. For most programs, you could probably use a general purpose language. General Purpose languages, as they sound have a wide range of applications. Usually, these should be your go to languages. Examples of general purpose languages are Java, c++, and Python. They each have their own different benefits over one another. Java is very useful for developing games and interactive web pages. Python can act as a scripting language for web programming, as well as writing applications and data analysis. And c++ tends to be used for writing applications and system programs. They all have a variety of packages that you can import and use to achieve the functionality you need from them. while selecting the right general purpose language for your big projects is very important. For most of your programs, any one of them will work. It really comes down to preference. Get to know each language and decide which ones syntax rules you like best and find most comfortable. If you get to know one general purpose language really well and enjoy programming with it, you can apply it to just about any of the programs you plan on writing. Personally, I tend to use Python for most of my projects. This is mostly not due to any functional difference between Python and any other general purpose language, though there are a few, but it is mainly because I find it syntax rules most convenient and easiest to write programs with. Overall, either you can consider the product you plan on doing and research and see which language boasts the most advantages for your purposes. Or you can simply become comfortable with a language and use it for most of the programs you decide to write. will now be looking at our final topic of this introduction to programming miniseries, you now have the basic knowledge of programming, which will take you far in any language that you decide to learn, you know, some good pre programming pseudocode strategies to help you design your code from the ground up. And you might already have a good idea as to the type of programming language you might want to start with. So what's the next step? How can I learn that language? And what applications can it be used for? Well, that's what we're going to be covering now. So let's just jump right into it. Starting with the biggest question, which is what is the next step? Well, now that you might know which type of language you might be interested in, research that language and find out whether or not you truly want to pursue that programming language. Most languages like Python or c++ will have either an official website where you can read up on the language, or Wikipedia page, which will provide you with useful information in deciding whether or not you want to pursue that path. From there, the next step is to actually learn the language, which can be done right here on YouTube. While we've taught you the basics of any programming language, each specific language is going to expand upon these concepts. And so watching tutorial videos on a certain language is going to be very beneficial. I would start with an introduction series, like the one you're currently watching both for the language you've chosen and work your way through that series, picking up on the syntax and rules of that language until you become comfortable with it. Once you do that, you come to a crossroads. You know how to program in a certain language, but you may be completely clueless as to what to make in that language. Programmers blog can leave you uninspired and not want to continue programming. So I'd like to give you a few websites to help out. First is coding bat, a completely free website which has hundreds of coding challenges in both Java and Python to help you refine your programming skills, and even learn some new programming shortcuts and tips. This is great if you want to get better at improving your efficiency and need something to hone your skills as a developer. The next is coder bite, which offers over 200 plus challenges that you can complete in over 10 different languages, something that is sure to help you improve. The final website I'd like to talk about is hacker rank, which not only provides programming challenges to keep you on your toes, but also provides support for you using your programming skills to find jobs or internships. These and many more websites exists solely to keep you interested in code and work on refining your skills to become better. Now if you're a teenager watching this series in high school, I also encourage you to take programming classes in your high school. AP Computer science principles and AP Computer Science a are both amazing courses which can help you greatly in the future, and are also incredibly informative and important to colleges. Your school might also offer other classes in the field of computer science, including ones on key data structures, game design, and data science. Any and all classes you can take to help expand your knowledge of programming and help you find your niche is going to be extremely helpful. As you can see, the world of code has now been opened up to you. These are just a few examples of where you can go from here. But there are many more we didn't talk about. You could get into GitHub and start contributing to projects. You could work on your own projects and collaborate with others. The possibilities are endless. The next step is up to you. This concludes our introduction to programming mini series. We hope you enjoyed watching it as much as we enjoyed making it. If you enjoyed the series as a whole consider subscribing to our channel, no pointer exception, which will be linked in the description for more content like this coming soon. Thank you so much for watching.