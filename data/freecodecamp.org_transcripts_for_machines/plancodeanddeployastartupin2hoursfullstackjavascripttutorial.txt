what's up guys back today with another longer video which is to build a job board app that could actually be a real startup that people use there's a lot of different places to find entry level or junior developer jobs on the internet for example github jobs stack overflow jobs you have angel list you have indeed but filtering through those especially because you kind of have to spam applications for your first job can take a long time so the good thing about all these job boards is they have public apis for the most part you always want to start with an mvp that is the minimum viable product today that means we're going to start with a single data feed that is a single job board api feeding into our app and then finally we're gonna have a super minimal simple front end we're gonna do this in react and material ui on the front end we're gonna use an express server redis for our data storage because we're not writing or persisting any data that is not part of the job feed and then finally a node cron job to fetch these jobs and refresh them at a certain interval which are going to be filtered through an algorithm so let's draw this all out to get a better idea of our plan here's our front end what we basically want here is a list of jobs this is going to be pulling data from our api and that will be express and then this will pull from our store which is actually going to be redis and redis will be populated by our cron called a worker which is pulling from one or more apis it's going to be eventually multiple this is going to be job uh board apis so like in let's say indeed we have github we have stack jobs and this is going to be filtered through our algorithm we're filtering down the jobs getting rid of the senior jobs getting rid of the manager jobs and eventually when we make it more complicated we could even look through the description for years of experience and create uh search indexes and different things like that but again the minimum is just going to be pulling the jobs in and filtering them down okay so this is our plan let's start with the front end i know a lot of you guys like react and it's gonna actually be super simple let's just do a create react app to get started uh i already have a folder our directory here called junior dev so let's uh do a create react app and then call it client you guys know that i love material ui so let's install that as well once we get into our client and let's do yarn add okay that's done and we will start our react at okay let's go through the stuff we can actually delete no tests you always want to write tests in real life but not today logo and also clear this out here now let's open the material ui docs let's get our component api and let's get a title for our page typography h1 let's just copy this and instead of putting it directly in app let's make a new component for jobs and then let's make a new component for a single job all job which we'll use in jobs and then let's import react exports default functions okay in this we will use typography okay so just to explain what i'm doing here i am making a separate component because i want our app just to hold our state and then jobs will actually hold our component tree our render styling and app will hold our application state our use state and call our hooks for kubota did mount and for state that was really confusing sorry we're using typography here and let's do variant typography variant okay i'm naming our page entry level software jobs i think it's a good name then save import jobs throw that in there like this okay that is some huge text but we're gonna leave it for now within jobs we already know we're gonna um import job make this a similar export we'll just copy this whole thing almost sneezed okay turn div and then this will just be a single job row which will put on a class name of a single job and then we'll just do this in advance because we know we're going to eventually have to write some css to style this stuff let's make a job list should probably actually be matching our component name just to change that back jobs and then job okay so let's just say that we're passing down some props for all our jobs from our uh app which is holding our state let's just do it like this and let's do some mock json that we might return from our api swe software engineer one and company google um there's gonna be a bunch of fields but let's just leave them like that for now and my mock job so we don't get it mixed up mock just being mock json data and it should work then we can do jobs map job this will return a job job job equals job hopefully that's not too confusing okay now you could just hear the structure job in the box but job.title let's see if this works there it is job.title and job.company and let's actually add some css for job and just make it a display flex next direction oh that's right it's always freaking hard switching from jsx to javascript okay there we go boom i'll leave it like that for now we can add more stuff to this this list if we want like this facebook apple it'll map it out for us let's give that a little bit of margin a little bit of padding let's do a 10 pixel top left right zero and then padding will be the same okay not too bad not too bad so our front end we could call this like kind of done let's call this done for now and let's return to it after doing some full stack stuff so i'm gonna collapse our client let's see what our actual data feed is gonna look like coming from uh our source which i'm just gonna use as github jobs because i know that has a really good clean api output that you don't need a key for or anything so api github jobs open it up you can see some examples here okay so it says that the api supports pagination it'll return 50 at a time and you could do it by adding a parameter to your queries before jumping ahead we just know we want these json representation of these jobs so we can manipulate it with our node worker so what i'm actually going to do is call a similar url like this in our node side which is going to give us output like this just by eyeballing this i could see that it is somewhat matching what we already wrote out here in app.js where there's a title somewhere yes like that senior full stack node.js developer and there is a company somewhere and we can also tell in advance that location's going to be an important field too but basing our analysis on this we could start to model kind of what our worker is going to do as well as how we want our api to act as well so looking back at our plan let's actually just make a folder for uh all our boxes here so this is the client right api is going to be simplexpress server and then the worker is going to have our algorithm and it's going to be calling our apis on a cron job which is at a set interval so maybe every hour in the day we want to refresh these apis refresh our redis and make sure that everything is up to date there's no expired jobs that the companies don't want people to see anymore and we're basically staying in sync with whatever is in uh our upstream data source so within worker i want to create an index.js which is going to manage all our worker tasks and i know already that we're going to need the cron node library it's just going to help us run simple cron jobs which is what i was saying before is the it's the way you run a task on an interval basically forever if you want to opening up a new terminal tab going out to our main directory and within our main directory i'm just going to create a package json which is going to be accessible from all our different folders so you can see that was created here and then we just want to install cron as a dependency okay now inside a worker i just this is the way i pretty much start with every uh with every app you just copy kind of the basic usage and you build your way out from there so all this does is it's running a node process where we're importing the library and then this is called a um cron shorthand cron syntax something like that uh cron.guru you can see it here okay so this site is really useful no not this site crown guru crontab guru okay so these asterisks are called a cron schedule expression and it's basically symbols for how often you want your job to run you can test it over here slash one that's actually every minute this is every second this is every second minute it's every third minute right so you just have to play around with the syntax that'll tell you here how to do it and then you could do kind of whatever interval you want so you could do like once uh a day i think one yeah so you got it you just got to mess with it to do what you want and then you could just google exactly what you want to do and you get pulled the chronic especially from that but this is kind of a playground to get the chronic expression you you definitely want to do all right so let's test this um this basic implementation of cron to just see if it works and in our real production app this is actually going to run every second not every second every um let's say hour to fetch our jobs so this will fire off some function which is now being passed in as this a anonymous function that is just console logging but what we're eventually going to put in there is our script to fetch the jobs and then filter them down so in this worker folder i'm going to make a github um or rather let's do it this way i'm gonna make a tasks folder and then we'll do one called fetchgithub.js and we just want to play around with that you know github api and get it to do what we want so the good part about the github api the the good thing about the github api and part of the reason why i picked it is because it is pretty much all developer jobs so we don't have to filter out for developer jobs we could just assume they're all tech jobs and then we will take the ones that are just junior software engineer or more specifically not senior or not manager so we know our url is roughly going to look like this to do a backend url fetch request i'm going to install the node fetch library which is the same as the clientside fetch library but you could use it in node.js okay so we're just required like that then let's do an anonymous async function just to actually now let's do it this way export default async function just did a hey siri for some reason nope okay so fetch github there and i'll just call it here just for testing purposes and within here let's do a jobs await etch and we'll do asurl equals this without the query string so let's break this down a little bit we have a question mark then a description equals and ruby and page equals one so this is called a query string here it's a way to pass parameters through a url so so we're passing parameters to the server through the query string syntax which is key equals value like this so in our case we're going to want to iterate through the pages that is we want to get all the results from all the pages and combine them together the way i think we want to do that is just by leaving this like this so this is just our truly base url and then let's actually see what happens let's see how many jobs we get back just by doing this and then logging out jobs length keep in mind that this function is going to run because we're calling it here when we just run a node on fetch github.js okay i forgot we still can't do that and let's just do this okay undefined let's console like this jobs oh i forgot we also have to do this this is just our raw response this is jobs press.json still not resolving because this is an async function too okay 50. i already kind of knew this going in but if you put no parameters here it just gives you the first page only so we have to add a query string for each page and iterate through to get all the results until we get back an empty page best way to solve this is to keep adding one to the page number so we start at zero then we try page one then we try page two until we get back a page with zero results so if this is the way we do it for one page we're just going to want to run this same subroutine for every um page that's not empty to make this a little more clear i don't like really how we've written this out so far uh let's just do it like this maybe it's just me being lazy so while the uh page result count is not empty we're going to do this and we have to keep track of the page we're on as well as the result count so let's make uh result counts and not zero value because if it's zero it'll break our loop so let's just start at an arbitrary value one and then after we fetch the first page it'll be 50 then it'll be whatever the second page is until it's zero at which point this while loop will break so we'll initialize it to one and then let's also initialize our what where are we going to call it on page equals zero we'll start on page zero okay so base url we'll do a template literal here and then slash or instead of slash we'll do our query string h equals on page okay so we loop we get our jobs we get our jobs length we're gonna want to also push the jobs we get back into an array called all jobs let's do all jobs push the jobs we get back from that page let's keep this in here just so we know what's happening and then finally increase our onpage value okay again just to review setting our result count to a nonzero value starting on page zero creating an empty array to hold the results we're getting back from the api we start a while loop that's gonna run as long as we're getting results back by increasing one page at a time so getting page zero getting page one getting page two here's where the url is constructed base url from up here and then page starting at zero pulling out the json from the response putting that json in our array logging out how many jobs we got back increasing the page count repeating until we run out of or rather we run into an empty page finally we have all our jobs so let's just log out how many jobs we got total which we're going to eventually be returning all right now these console logs give us an idea of what's happening in our function here otherwise we would have no idea since we refactored a little bit we have to call the function again let's see what happens hopefully this is not infinite loop please oh oh oh no okay okay what happened there i guess we didn't break oh because we're not setting result count okay so we got to do this result count equals length okay there that should work now but for the most part good okay okay so there's one thing we also overlooked i think let's look back at this this is a sample response we're getting back and if we look at this whole object let's just assume this is like page zero it's coming back with an array but then we're pushing that array directly into our all jobs so this is actually creating an array of arrays whereas really we want a flat array just a single array holding all these job objects so the simple way to do that is to spread that in with a spread operator we're just dumping the array into another array by spreading the values in if we run that we're totally gonna see this is gonna work super confident why i did not work that time that's weird interesting okay that's probably something we have to debug maybe it was a weird response from the server so our fetch github function is done we're returning all our jobs now uh i think we actually want a way to save these jobs into a local storage that we can retrieve through our api and actually before we do that i'm getting ahead of myself but we want to call this entire function on an interval so um let's go back to crontab let's just call it every uh no let's yeah let's let's let's call it uh every minute make sure i'm doing that right yeah every minute every minute here we'll import our fetch github function patch github boom just throw it in here and the beauty of this is we can repeat this for as many um functions as we want right we could we could fetch github we could fetch stack overflow jobs we could fetch indeed and we could create a crontab for each one that is not dependent on one another to succeed or fail so these could be all trying in parallel and they could also um give us kind of a rolling refresh of our jobs so maybe one could run every 10th minute of the hour one could run every 20th minute and it'll just continuously refresh without hitting any one of these apis too often let's test the uh the cron aspect of that i just turned it on and it's running for the first time now but then it should run again after a minute okay and that's not going to work because i actually ran directly to fetch get github one but if i do index okay it's gonna wait a minute oh okay i messed up i messed up okay so i copied exactly over from cron tab every minute okay well i guess if you put six stars it'll do seconds and if you put five it'll do minutes so lesson learned there so we'll see if that works after a minute and in the meantime let's uh let's talk about storage and like i mentioned earlier we're going to want to store these jobs actually in redis now i already have redis installed but you can install it through homebrew pretty easily just if you don't have homebrew installed you look up homebrew installation you just it's a simple easy download and then you can install anything with a brew install for example redis and then it'll basically install redis under the hood in your system in a directory called uh the brew services so then you hit start and stop restart it from from that position jumping back up to this you'll notice that it worked after a minute so that's awesome so let's see if it runs again after another minute i just cleared the terminal there with command k but like i was saying about redis i've already installed it with brew install redis and you can install it yourself if you don't already have it there are a couple different ways to install redis but it should always connect the same way uh since i'm starting a new project here i just want to make sure my redis is clear so um oops there's a command line command that allows you to connect to the redis client and then we want to clear all our our redis with a uh it's a similar um language to like a sql where you can uh basically this is like a drop table and then we just cleared everything out of our redis we got a fresh start and you'll see it ran again after a minute so let's just we could stop that we could leave it running whatever i'm just going to stop it but we know our crontab refresh is working every minute with our fetch github okay i have redis installed and um if you're not familiar with redis it's just a key value store so it's an inmemory database my sql is a little bit different because it's on disk but redis is just memory so it's not persistent and that means if your system shuts off you lose all your ram so it's not a fault tolerant database it's not a durable database and the upside is though that it's really fast it's kind of like an object in javascript you just if you have the key it's constant time access you just pull it out of your redis store and then you can serve it up in our case jumping back over to these um these job uh json that we got from github you can see every job has a uuid which is a guaranteed unique id because it has so many characters and it's random characters so it'll be guaranteed unique every time every job has one of these ids so that's a natural candidate to use as a redis key i'm thinking within redis our key is going to be this id and our value is just going to be the whole job object so it would be a string version of this that we can then pull out we know it's already json so we can just stringify it and then when we pull it out we'll just parse it into a javascript object now the slightly tricky part of this is okay how do we access redis through our node um worker right because we have all the jobs here right now we're just logging them and throwing them away but we want to put them in redis and the answer to that is there's a node client library to access and connect to and uh do all the redis actions so it's an interface that node uses called the client that's a library that will do everything you need to do in redis and you can do it through node with this library so i'm just going to search for node redis and then we will install it just like the same way as before and i'm gonna do exactly like i said before what the getting started docs say i know this is going to be better if we promisify this library because you can see right now that we have all the redis commands here like set is setting a key and then there's one called get which will retrieve that key just think of it like an object so if you put in key a and then the val is one then you do client.get you'll retrieve that one from the a key set and get functions are async so it's not going to be in line with your javascript code and that's just the name of the game because redis is not in javascript so there's no way to know when its response comes back programmatically in line it's it's going to wait redis could be over network so it's going to take an indeterminate amount of time to serve the request and then that's going to come back to the function call in this format so this is the standard callback format and node error and then data replies is going to be the response now you can just ignore all of that because we're going to promisify this library with the promisify util in node which will convert callback functions into promises that we could use await or then promise chaining with and so on let me just do this i'm just literally copy pasting it from the docs and get it async is the example which is converting that client.get function to a promise i'm going to put this below the client variable declaration so it works and i can tell you now that we're also going to need a set async we were thinking of setting each job as its own item in redis right which would be fine if we were ever querying for those keys but we're not we're in the mvp gonna just get all the jobs serving back to the client and then we'll let the client handle pagination or any kind of showing and hiding of these jobs so until we do that or rather until we decide we want to optimize this query on the server we could actually just set the response from github as the value of a single key it'll be a huge text blob and we just serve up to the front end and the only reason we're doing this is because of performance we don't want to have to wait for the api to respond every time we uh serve a client request so redis is only a buffer that's an intermediary holding this data that we're only fetching once every hour because the jobs aren't refreshing that often so that's a longwinded way of saying that once we create these this all jobs um array we actually are just gonna throw the whole thing under one key and we'll call that key github also let's let's hold on to this um let's hold on to this um get function in our head because we're gonna we're not gonna be pulling out of our redis until we're in the api layer which is serving the um the jobs request man i have kind of a stuffy nose okay let's do the set async and this takes a value github or a key rather github then a value will be our all jobs we might need to stringify that but we'll test it out okay let's run node worker tasks that's github and uh let's see if that works we can test it like this get github like that we still have our redis cli open there okay so far nothing happened that's not a good sign and here's why let's call our function just as a test i'm gonna take that out okay okay i hope this uh sniffly nose hasn't been annoying you guys too much it's actually annoying me and i hope it's not super loud on the microphone okay the get command contains the argument of type object okay i didn't like that at all um i'm not i'm not using get so i don't know what it's talking about here but um okay i know now set and then okay let's try that okay set contains argument of type object and as we expected this is like an array i think this is gonna work to be honest nice okay github there it is radis is working our fetch worker is is totally great we'll leave these logs in just so we have that telemetry that observability but everything is working oops okay just make sure that's still working with our crown tab here oops so we're supposed to remind me to take that out leave that running and we'll jump over to our next piece if we look at our plan api so let's just review this oh actually so we've got this api part done we still need this we still need this and then we'll improve our front end last so filter algorithm all right let's look at what's in our store here so we're getting jobs back and um like i said we we want to start with a really simple algorithm that is just filtering out by position so just taking like eyeballing this i can see that in the title we can gain a few insights into what kind of job it is right if we see a senior in the title we know it's not going to be a junior developer job if we see manager in the title we know it's not going to be a junior developer job another common thing we might see is like a senior abbreviated as sr i didn't see it in there but i know that's it's done so maybe if we see that word sr dot at all then we um we want to filter it out so this is our set in redis so we're gonna want our filter before that that's all pages filter you can always factor this out to a function later but for now let's um let's do it this way okay new array junior jobs it's going to be fill a subset of all jobs and we're going to filter based on a few different parameters looking at each job okay we're going to use one super important thing here and that is the string that includes function and we're going to use that on job title so if the job title includes or rather stop siri okay let's do it this way actually job title equals job title to lower case it's important i think the example we saw in the terminal was in all caps so we want to reduce that kind of variation by just lowercasing the whole title we also don't have to keep accessing the object if we just store it in a variable so this is this is for one job and um we're going through 392 so we're gonna have to go through each one of those jobs real fast that's part of the reason too why we're doing this cron method is because if we fetch the jobs on every front end request we'd have to do this whole filter thing every time and it's going to be the same logic so in general when you're doing the same logic for every client request that's definitely a good case for caching or even database denormalization so replicating data in your store that's a commonly a common read pattern rather all right we could be more curious about this but let's just make it super clear and have a default case let is junior equals true then there's going to be our logic then we're gonna just return the result is junior okay now this is gonna be our main algorithm logic here okay so if um job title includes senior we gotta remember we changed it to lower case or job title includes manager or job title includes sr dot senior or another one i'm gonna and i thought about this before i'm gonna put in is architect because that is generally a more senior role as well that you're not gonna be able to do as a junior developer that's something you have to gain a little skill from then you can design whole systems and you may or may not be the one implementing them as well but here's all the cases we want to filter out if any of these are true is junior equals false okay so this is the most clear we could way we could do it but i'm actually going to cut this part out and then we'll do return false otherwise we don't actually need else just if that didn't happen return true okay now we could test in our in our code how many get actually filtered out by this by um console logging filtered down to junior jobs okay and we do uh move this one up here actually i think yeah we'll leave that in make sure we're adding junior jobs in here only consolidate success okay just that's bothering me okay restart oops restart clean slate we'll get this extra log we'll see how much damage our filter does and then we will still set that in redis and then we can make sure it's still in there please work okay nice cool so if we're filtering out okay we went down from 392 all the way to 245 so we're filtering out almost uh one third of the jobs just with these words which i think is already making our app useful to some degree obviously the more complex we make this algorithm we could search through the job.description look for years of experience there's definitely more more titles we can include here but that would depend like what we see in the json um we can kind of pluck words out of there be like oh yeah this was obviously a senior term too and then add it to this list but for now i think it's a good start okay let's see back in our planning we just did our filter algorithm or very basic version node work is done so this whole section is done redis is done api and then we'll we'll finish up with our front end and then finally deploy okay so let's actually just close everything open up api index.js just want a super simple express app express again same thing i said before uh just do that npm install and then from there you take the most basic example make my port 3001 because i know my front end is running on 3000. get a little bit of extra space here and um okay and then this route we don't need a slash we just need a route called jobs okay i love this part okay our express install went through over here let's do um let's just run a node on api index.js sample app listening on port 3001 and then if i curl which is just sending a request to something on the port 3001 slash jobs get the hello world back sweet okay this is going to be the simplest api ever and we just want to use that redis library we already installed and we're going to use the get which we already commented out and we already know which key we're gonna get because we only set one so that really simplifies it uh so we need to copy actually all this code and delete this because we don't need it here get the redis client get another instance of that here and then do the get async and this is where the async part is really going to come in handy to convert this route to an async function let me do jobs here wait get async github just hardcode that in now let's remember we stringified it so json parse and i'm going to actually undo this because we are just going to have to restringify it when we send it to our client but um in the meantime just to see the length and or rather see that the length matches our our length that we put in let's parse it and then let's do dot lake okay so it's kind of a lot that we did without testing it let's restart our server do the same curl oh man okay 245. i don't remember if that's how many we put in we're definitely getting a list of 245 which is a good sign now let's just try sending this back and see if we get that full uh stringified object that's exactly what we want and it's that easy so that's already done so i don't know how long it's been guys but with this simple of an api we can literally we've literally been able to create all this like in such a short amount of time we have a data feed and you can replicate like before before i go further you can replicate this in any this is like 90 applications if you have a data feed you have storage you have a worker that's doing some async task on an interval uh it's called batch processing you have an api that's called by front end this is like 90 of crud applications let's create read upload delete in this case we're only really reading from the front end but the backend is doing some more complex stuff including an algorithm the pieces that we're using are used in some way in almost every large scale application so doing this as an mvp is like a really good exercise all right let's push on i might be getting a little bit tired but let's keep it going okay so we have our api uh running let's keep this running all right let's just restart this so we have the uh log that we know we're listening and um i'm gonna go back into our client folder okay so we're back in our app close that we're back in our app function which we we mentioned we're going to put the state in let's pull this back up so make sure it's still running all good to call our api programmatically the same way we're doing with curl here we just need to call this url with a function that we're going to make called fetch jobs all it's going to do is use the browser version of fetch which we don't need to import because it's built into browsers like chrome let's um instead of hard coding do a job api url constant it'll just be exactly what we have over here since this is async we can use in a weight a weight const jobs equals weight of course this will be in json so we have to uh convert it to json let's do that call this res call this json goes await as that json and before going further let's just log that out okay how do we call this in our client to find my number used i know i'm getting there okay if you've seen my past videos i talked about react hooks these are replacing all react class components now we just have functional components and we've seen hooks for use reducer use state and all that kind of stuff since this app is just a very simple state it's a list of jobs i don't feel like i need to use a reducer and i know exactly the shape of these jobs as well so i don't need to do any reducer like manipulation and it's also very hierarchical and shallow application meaning i just want to pass down these jobs one level to my job's view component from this app state i started talking about hooks and we've used the used state hook a lot in my past videos but we're gonna use one that we haven't used too much yet here which is called use effect and that's basically uh replacing the component did mount or component did update function from past versions of react so i'm going to use it here react i use effect and then this function actually takes a anonymous function in which i can do some function calls some async function calls as well as a second argument which is the basically hooks that i want to watch to update but if i pass in an empty array this react i use effect will act exactly like a component did mount all right in inside here just gonna fetch jobs and um i also want to think about how i'm gonna store those jobs so um let's also do a used state hook jobs this is never jobs a lot so let me just do job list was react dot use state and update jobs react i use state and then i'll initialize this to an empty list which i'm actually going to pass in here so when i do that that should actually clear out all my um chops okay good because i'm initializing it to an empty list okay in here i'm fetching jobs console.json see what happens here fail to fetch ah right this is one thing you're going to definitely run into if you're writing express apps and you're pretty new it's the access control allow origin so this is something you have to set in your server if you're accessing endpoints from a different base url it's called cross origin resource sharing and you basically have to set a server header in your api that allows requests from the url that is the origin so recall that our react app's running on localhost 3000 as we can see here so all i have to do is set a um header header uh i think it's like just literally that but let me just uh let me just copy something to so i make sure doing it right chorus res header express yeah here it is that's all i need press header access control origin but if i do the star that makes it not protected so i just want to make this http localhost 3000 okay now this will i think i'm 92 percent sure it's gonna work all right i type it wrong huh i didn't restart my server that's why i was the eight percent me not restarting it wow nice guys there we go that's all our jobs beautiful okay we're getting close okay fetch jobs is um it's working i think what we still need is a um callback to to update these jobs so let's just do this update callback as we know when we use a used state hook the second variable that we destructure from the use state hook is a function in which we can pass a argument that is the new value of our state for job list so if i pass it in here like this update callback and then i pass the json directly into this i'm actually just setting the value of job list to this json which is as we can see over here an array of uh size 245 containing our jobs okay so i got update callback job list i didn't even have to do anything else it's already rendering all the jobs that are from github that's pretty cool hey guys i'm back with a new shirt let's finish up this front end and then get this app deployed i've pulled up another plan board here just to make it a little bit more clear what we want to do with the front end like i said before we always want to have a plan before we just jump into coding and um the first thing i'm going to draw out is just the current way the app looks which is just the title and then uh the list of all our jobs here right now our jobs only have the title and the company name but we're definitely gonna want also to have the location so title company we're definitely going to want location as well as the time posted and i think the best format for time is how long ago so today one day ago two days ago etc now this is in the list view and we gotta think about too what is going to happen when we click on a job and in that case i want to build a detail view modal also known as a dialogue or a popup that will show more details about the job uh which will include the company logo description as well as the apply link and that could also be a button if we decide to make it like that okay so these are the main things we still need to excuse me these are the main things we want in our front end the good news is since we already have the json we just have to pull it out of the json of each job and create a little bit extra functionality to make this modal animate luckily this is pretty easy with material ui and in fact the main reason i wanted to use it for this project because you get the modal for free with all the um animations and stuff like that so let's just jump back over to our um front end here and i'm gonna pull open the jobs component here i have variant h1 but i think this title is definitely a little bit too big i don't think it i think that's pretty obvious and i'm going to switch this up to still using a h1 html under the hood but the variant will actually make it an h4 stylistically so that's a pretty cool trick if you want to maintain the uh benefits of having h1 for seo and so on diving into the job itself let's actually log out what a single job is going to look like just so we know what we're working with and instead of doing that here in the job component i'm going to do it in jobs and we could just look at what the first job looks like so i'm going to use jobs 0 for that then we'll open the console and see that we have the fields we can use here so i said we wanted to add location and time posted to our list view uh we could pretty easily just pull out location in our job component like the way we've been doing with the other ones and there it goes this is looking a little bit let's say disorganized but let's worry about that in just a moment um for now i'm just going to throw these all in a div which is going to be floating to the left of our box and instead of space uh around i want to change this css to space between it'll make sense more in a minute why i'm doing that finally in another div let's do the um created date which i believe is over here in our json as well created underscore at and i'm just kind of using these typography elements interchangeably as divs so later on we can change the size of these different things okay so created at let's just see if the spacing looks alright there now that i see this here i think the date doesn't actually look too bad as long as we make it a little bit shorter so let's just split it by space and then take the um the first three words so let's take o24 and then join that by a space so all i'm doing here is taking sunday june knife out of this longer string i meant to do 0 to 3. there we go so we get index 0 1 and 2. all right looking at our page it deserves a little bit of padding just it's pushed up against the side here so let's add that quickly and then keep going let's give body a margin top and bottom zero left and right 40. okay top and bottom 20. all right and then within job maybe we give a little padding uh top and bottom left and right ten okay pretty good now inside job we'll actually add some hierarchy style hierarchy to our job title let's do h5 h6 on this and so on we can just keep updating editing this um i think i'm actually going to flip these around h6h5 but you get the point you can just keep tweaking it okay let's add that pagination thing i mentioned it's gonna be kind of a fake pagination you're supposed to do it on the server to not load all your results at once but this is a good stop gap we start just with the client implementation and then later if we want to improve the performance we could do the server side too but long story short we have over 200 results we want these on more than one page so they're more navigable so to solve this i opened a material ui page for the stepper component and i really like this one down here called the mobile stepper progress so you could click through it like this it fills up kind of a progress bar and it says mobile but i like it so i'm just gonna pull it over um let's see let's just pull over everything here just in case we need it and then paste it right into our jobs component and um we could use the word step here interchangeably with page and i'm putting this state in jobs because it's more of a view state rather than an actual data based state so all our logic concerning our view is going to actually be in jobs and not in the app file okay so since these each have their own function handle next set uh oh sorry handle next handle back i'm just going to copy these directly over to paste those right in function inside a function and um all right finally i'm going to just put this whole thing below our uh jobs map and um let's see if by pasting it directly in we we need to do anything else just going to make sure that's formatted correctly saved it and um let's just take this out classes direction rtl okay let's see how theme is being used because this is kind of a um darn all right i don't know why that would change from left to right but um it might be a mobile implementation specific thing so let's just take this and hard code it as right and we'll hard code this one as left and see if we run in any problems okay save that and can't find module oh i forgot about this material ui icons is a separate library so we have to also install that in our client yarn add material ui icons now while that's installing let's think about how else we want to use our pages um if we want to artificially construct these pages from a larger list then we basically just want to break things into a slice depending on the number of results we want to show at a given time so let's think of it as a moving window of 50. so if step equals 1 or let's say step equals 0 then we want to show 0 through 49 step equals 1 show 50 through 100 and so on or maybe 5099 okay so since our icon's finished let's see if that worked we got to go all the way to the bottom and yes it is here next and back okay okay so let's make this more dynamic steps is hard coded as six if we want 50 per page um we're going to have to do our well since we're going to use this in a couple different places let's get our uh job length or num jobs equals jobs.like just for uh better abstraction steps will be num jobs uh divided by 50. and then we'll math floor that or let's actually math seal that because it'll be minimum um one page could have you know only one job on it so we want minimum okay so that seems about right it seems like we have about four pages just by the amount of times i click that and um let's add a little more detail to right above this mobile stepper that just says and i'm just making it a different now but we can change it um page uh active step of num jobs okay um not okay let's let's let's factor this out num pages num pages equals this and then we can also use this where we are oh computers lagging again numb pages like that yeah i'm feeling pretty confident about that um see if it worked if we go to the bottom my wrist is getting real tired of scrolling here all right and then one thing i actually meant to do earlier too is um okay going all the way down okay oh five oh back one two three four five okay so the display number we want to actually be uh active step plus one because we're zero index and we're going up to um for yeah so this will this will work on pages minus one because the index is actually one less than the true value one two three four five okay we'll just leave it as num pages all right one other thing that i meant to add earlier is uh the total number of jobs at the top right under the title so let's do a variant h6 and put in the total number of jobs here num jobs 245 cool getting very close to being done with the front end here um oh cancel that uh okay now let's implement the actual pagination um and we could do that by just creating a slice that we're gonna map over instead of the list of all jobs uh jobs on page which is just jobs slice okay let's think about how to do this first number is going to be okay um yeah so active step let's keep in mind is our page that we're on now so the lower bound is going to be active step times 50 and the upper bound is going to be active step times 50 plus 50. now all we're gonna map is uh jobs on page not the full list and um now we only have 50. so much more navigable in terms of what's being rendered and then if we go to the next page it updates next page updates sweet all right that is our pagination done uh now all we need left is this popout modal and then our front end will be all we need left is the pop out modal and our front end will be totally done uh so what i want to do is click on this and then it'll give me a more detailed view as well as a link where i can apply so the first thing i want to do is add a hover state to this job div with a hover sudo class and css and then i'll just make cursor pointer pointer and i could also make the colors a a gray color just so it's very clear that we are hovering over this page or over the the job that i'm indicating so that that doesn't look great but it's uh okay for now let's just make this a little bit of a darker gray than dark gray all sixes here all right so that looks fine um okay so there's our hover state now on on click we're gonna want to push that job into the modal state because we want to know which job specifically to display in the modal we also want to set a modal open flag to let the app know to show the modal itself i think this is going to make a lot more sense when i actually read it out so um i'm gonna add it to the let me think about this yeah i'm just gonna add it to the bottom of jobs below my mobile stepper and i'm going to pull another component from material ui to do that and you might have guessed it it's going to be a dialog component so if you go under feedback there's uh dialogues and i kind of already know the one i want because i there's a lot of them and it's going to be the slide in alert i just think this one looks pretty cool because you click it and then it oh wait that didn't slide in where's the slide okay so you can see there it kind of slid up and in my computer is going slow but uh it'll look cool okay so we have to import a bunch of these components for this one to work in a perfect world you would make this modal its own component and i think i will do that actually call it job model dot js let's bring it react export default function job modal and our prop is going to be called job returning jsx and importing everything i just copied also there's some forward ref business going on here but we'll just trust that works like the material ui docs say it does and uh let's bring all of this in to here i am going to delete these though or rather i'm going to move these into our parent component because that's where we want to manage the state from it's going to go in the jobs component um let's consolidate this down this is for pagination and then modal consolidate this down too uh okay now we want to import job model then uh put this at the top here actually job modal open is open job is okay now this is where we have to define our actual modal state um active modal active uh no selected job let's do selected job so let's do just one more state okay state starting out it'll be an empty object default state and um select job will occur when we click on a job on click let's set some more room there select select job job like that so there's a callback in the on click function that will run when we click and it's going to set uh the selected job to whatever job we click good start and then that selected job is being passed in to job model um let's just rename this to be extra clear destructure job and open and if there's no job title we know this hasn't been set yet so we just return nothing that's just protecting against a empty object and let's see oh yeah we also gotta pass in our uh oh well no we don't need this because this is happening one level up right and um that also reminds me we have to not only select the job but set the model to open as well and i'll click open and then handle close is going to happen here and like no and all close okay pull that out and um okay let's see what errors we're getting i'm sure this isn't going to work out of the gate but just got a typo there okay so if i click what happens all right okay we actually have to pass down this function like that and then we open job and we do that on click here because it wasn't running we need to we needed to put it on the on the child oh nice nice got it down all right so title now we can start putting in our our variables this job title um instead of just having that there maybe we also put the logo of the company so yeah let's make this fancy do a image source company job company logo and um detail logo in here we will do detail logo make it pretty small 30 pixels float right now back over here we of course want the company and um in the content we definitely want the description okay one tricky thing though you'll notice that the description is in html it's an html string so a trick with react is um if you want to actually render html from a string it's considered dangerous because you can put in script tags and execute script on someone else's browser so if you want to allow this as the developer you have to use the dangerously set html inner html attribute like that and then you pass in an object with uh the key html equals whatever you want your html string to be and that'll do the trick but it's again dangerous so use it sparingly as for the buttons at the bottom let's change this one to apply and this will just be a link to the original job posting for now so we'll wrap this in an anchor tag a href uh wrap it in anchor tag of job.url which is the link to the original job you see here closing anchor tag goes on the other side of the button maybe we don't actually want this button to close the modal and then i'm just going to save everything we just did now i'm opening it again we do have an error but it's looking pretty good and i'm wondering if the the reason for this is that i just have to use the dangerously set inner html directly on this let's see if that works changing this to a selfclosing uh tag and uh one thing i want to do also is put a break between the the title here and the company because they were both on the same line actually let's just do it like this put in a little hyphen to separate them when i open click okay awesome and uh if i click apply it'll take me to the company or the rather the original job posting which we may want to make a little more complicated down the road but for now it's good uh one more thing i want to do is make this link a target blank so it'll open in a new tab underscore blank so that'll open this link in a new tab all right as far as the modal goes i think we're pretty we're pretty much good so for now i mean that could be obviously we could add a little more pizzazz to this front end if we you know continue improving it over time but for now i mean it's very functional it does everything we wanted to do i can click on different jobs and get um get a different you know listing this opens and closes and these are all working with the logo and i can scroll it looks pretty good it looks pretty good so i want to say our front end is done all right guys we're so close to being done we literally just have to deploy our app and will be home free a lot of people are afraid of deployment but it's not that bad if you break it down into steps when i think about what we need it's going to be a domain pointing to a virtual private server which is hosting nginx now nginx is called a reverse proxy it connects your server to the public internet and provides like protection between those requests the other thing we're going to need is a process manager on our server after we install our dependencies that we have in our local environment so we're going to need the same things redis we're going to need node.js and then we're just going to need to send over all our files so they can actually run on our server in the same way they're running locally so let's do it i've pulled up a bunch of docs here we're going to need it's just going to be a lot of copy and pasting for server configurations and i'll put all these links in the description so like i mentioned first uh we need a domain i already bought one on google domains but you can buy a domain a ton of different places i just like google because the interface and it's because where my uh other domains are so i've opened my domain i already bought it a normal.com domain is going to be about 14 a year and the first thing we need to do is use the digital ocean name servers so that domain can be directed over to our server so you'll see that i have clicked on my domain i've opened the dns tab and then there's a name servers tab and i've clicked use custom name servers now i'm going to put that on pause and jump over to the digital ocean dashboard you can make a digitalocean account for free and it'll give you this dashboard where you can create projects which have resources inside of them a project is basically just a folder for a bunch of resources including domains and virtual servers and then all this stuff you see down here so i'm just going to create a new project and call it um entry level software jobs e lsj and it's a web application so i'm just going to create that and then like i said it's just a folder we're going to start with no resources so i'm going to skip that step for now but right away we're going to create a domain and the domain is going to be the one that we bought entry level software jobs.com so i'm just going to put that here and then add it and you'll see that i have the digital ocean name servers here so it's ns1 2 and 3. so i'm just going to copy this by clicking it and enter it here and we need all three of them so i'm just going to expand this out make this one two and then make this one three now when you change the name servers it could take a a little while to actually update it says up to 24 hours a lot of time for me it's instant but it's not always the case so you might have to wait and we'll see what happens here so next thing i'm going to do is actually create a droplet which is our vps virtual private server you can do this on any cloud provider other common ones are aws or google cloud but um on aws this is called an ec2 and then i'm not sure what it's called in google cloud maybe just a vps but on do it's called a droplet which is just a server so what you have to do is choose your operating system i'm choosing ubuntu linux 1804 and you can choose the size of your server you could always upgrade it later which requires a server restart so i'm just going to pick the 15 a month which has three gigabytes of ram and 60 gigabyte of storage and then um moving down you could choose your data center where is your server physically located and then moving down you could do private networking's useful if you have you know multiple servers talking to each other but the most important part is here at your ssh keys you're probably going to want to do a new ssh key but i already have mine saved here you definitely need this step because you need it to actually get into your server to connect to it otherwise there's no way to get into it so you definitely need a ssh key and then uh feel free to look up a tutorial to set that up i'm not going to do it here but it's pretty easy to do and then i'm just going to call a hostname master because we're only going to have one server with all our services and then finally create this so this server is now being created it doesn't take too long and i'm going to go back into my domain and add an a record for at which is just the root domain and i want it to direct to our master server so i'm just going to create that record and that is step one in linking our domain to our server now uh once this finishes which it looks like it just did we got the green light here i'm going to copy the ipv4 address that's the ip address and i'm just going to ssh directly into this server by doing root at ip address just like that ssh root at ip address and it looks like it wasn't completely finished loading so i'm just going to try it one more time and now we type in yes and there we go so you can see our operating system here and now we have a command line in our server so we're actually in our server through a secure shell that's ssh so i'm just going to clear this out with command k and it's important to look at the command prompt to know where we actually are we don't want to be installing things on our local machine that we think we're doing on our server so always keep an eye on this i'm rude at master master being the name of our server all right so as i mentioned we have to install nginx to actually talk to the public internet and uh if we have a domain we also want to install an ssl certificate which gives us the https secure connection and that sounds complicated but it's really easy if you use the tool like certbot i have the documentation open here all you do is um you choose your software on your system and as you'll recall we used 1804 and it'll give you a a series of commands to just enter into your server and it'll install pretty much everything you need so i'm just going to run these commands and a few of them require me to hit yes so i'm just going to do them one at a time make sure each one works while periodically clearing out my console with command k just to give us more space so there's one where i have to hit yes and let's just keep going through these so the nice thing about this certbot is usually you have to install nginx on its own but this will install our nginx and our certificate our certificate all at the same time and then we just have to update our nginx config and we'll be already serving our application to the uh to the public internet through our domain okay last command here yes all right okay i'm going to copy this sudo sir bot nginx command which is what actually runs the uh installation and then i'm going to enter that in and it'll take us through a series of prompts to actually install this so i'm going to put an email and then agree no now we need our actual domain we got to make sure we spell it right here entry level software jobs.com an important thing to take note of here is where it deployed our certificate so it deployed our certificate in sites enabled slash default which is a config file that we later have to edit if we want to make any changes to our domain configuration so um we're going to open that later to update the config but just keep in mind that location okay congratulations it was successful so let's test that and see if our name servers have propagated yet by going to the domain and that's exactly what we want to see welcome to nginx so this is a nonconfigured nginx but it is running and we're connected to our server from the public internet so that's great so we're done with sirbot and then like i mentioned we want to next edit our configuration file which is at that location etc nginx sites available uh default and i'm going to open this with the vim text editor by typing in vi and then the file location now vim is pretty cool if you haven't used it but it's basically installed on all unix operating systems that is linux and mac os and it gives us a text editor right in the console so what i'm doing here is i'm scrolling down to the second server block which is actually indicated by this server bracket notation and i'm going to look in here and i can see my url is defined here and being forwarded to uh basically port 80. so um within this location block i'm just going to completely delete what's in here that is inside the location block and then i'm going to put a new config in that is just pretty much something you have to copy and paste to do port forwarding to a local port on your machine so i'm going to copy this location here and i will put this link in the description where i'm getting this from but this is just a standard configuration for port forwarding so i'm just going to paste it right in we have that and then the other thing we need is to put this outside of our server block which is actually the port that we're forwarding to port 80. so sorry i messed that one up actually undo um go in to make a little space and then i'm gonna paste that in there so we're forwarding localhost 5000 to port 80. that's what this upstream is doing so i'm going to save this with colon escape colon wq and that saves the file and then i'm going to do sudum sudo system control restart nginx and that just restarts our nginx no errors um okay so that's pretty good um now let's keep moving and install our dependencies on our machine so i'm going over to this other tutorial how to set up node.js on ubuntu link in description and i have to install actually the node.js version that we need which is at least six to run uh create react app build so i'm changing directory into the home directory that's the squiggly line then i'm curling this file now i'm just running the script that i received from this file uh curl making a request to download some dot s h file which includes basically some setup configuration for installing node.js clearing the terminal and then actually installing node.js through aptget which is a linux equivalent of homebrew that's for installing just pretty much any software okay that worked and now i want to install this build essential file which is or rather module which is a helps us run certain npm packages so it just makes sure we have compatibility with every um npm package that we want to use okay next let's actually test out that our port forwarding is working by creating a test file called hello.js so i'm going to do that with them here hello.js and then insert this uh code and i just want to actually change that to 5000 which is what we set up our port forwarding to as you might recall and then i'm just going to save that with escape wq and then run it with node so node hello js and it's running so let's see if that is actually being forwarded correctly and it is so that's great okay just scrolling down this page and i'm going to stop that server the next thing we need to do is install pm2 our process manager which allows us to run all our services our api front end and worker at the same time without us being actively on the server so it'll run them restart them capture logs and do a lot of stuff that's pretty cool for actually managing our server processes so i'm just going to do oh no we don't have npm installed so of course um you know no tutorial is perfect so let's just install npm as well it normally does that when i install node but i guess i'm using a different uh set of commands this time to to do this so hopefully this just um doesn't give us any problems later and uh let's see if that worked okay sweet so let's do the and the same command as before npm install gpm2 oops okay and then to run our react app we all we need to npm install g another dependency called serve okay so we got those two done and let's just test pm2 with our hello js file so let's do pm2 start lljs and we'll see our pm2 daemon is spawned so now we can see our pm2 processes with pm2 ps and there's a status cpu and memory which is pretty cool that we get those stats in a dashboard and then if i refresh my page the app is still running in the background so that's great so if you remember the steps we outlined at the beginning the next thing we need to do is actually get our files onto this server and once we do that we should be pretty much done so i'm going to open up a second command window here and this is you'll see in the command prompt my local machine so what we want to do is send through the files that we made in local development before we do that i'm going to open up this uh set of files and make one critical change that will allow us to access our api on our local server and that is to basically change this to just a relative path so i'm changing this to just slash jobs and actually i want to change it to be a little more clear to be slash api jobs now that means we also have to change our api route which shouldn't be a problem slash api slash jobs and we have to make one change in our package json and that's adding a proxy config which allows this to still work on local development this doesn't affect anything on production so um proxying all api routes to a target of localhost sorry need the double quotes there http localhost uh 3001 was our api server i believe and i'll save that and again that just helps us you know still develop in the same way but we need to make one config change for the production server as well so that was our change in um in our files and as i mentioned i'm going to go actually back into that nginx config file etc engine x sites available default and i have to add one additional location block just for the api route because basically what this is doing is appending the relative path to the end of our url and nginx needs to know to direct this to actually port um 3001 on when it's being run by the browser so it's just basically a different port forwarding for a different path and the way we do that is by getting a proxy pass to http localhost 3001. semicolon is important i forget that a lot so escape wq to save and then system control restart nginx all right so we're about to send through our files to our production server i'm going to change into my client and then i'm going to do an npm run build to create a production build of my react app that we we just built this includes everything from our package.json and also our minified version of our javascript files and our bundle js now we can see that we have a build folder and we send this through the same way that we actually ssh in with a command called scp and then i'm going to put in an r flag for recursive so it'll send anything recursively within the build folder to our uh server url i'm just going to copy that again from here by going to master oops that's not good okay no it hasn't been destroyed false alarm uh copy the ipv4 and then do the same syntax root at our ipv address and then uh i need to put in a colon and then the home directory so where are we sending it to on our server and we just want to make sure it's going to the home directory okay so that's sent through all our files from the build folder and now when i ls inside of our server you'll see the build folder is there so that's great so um let's start this up we're not gonna have any data running yet because we don't have our workers started on our server but um let's start this up by pm2 stop hello this was our test server we know it works and then we'll do pm2 delete hello and now i'm going to do a special kind of syntax to actually serve our build folder publicly and that's going to combine the serve package we downloaded with the pm2 process manager so i'm going to do pm2 start serv dash dash s build this is just saying use the serve package and run this command dash s build under serve it's the same as pm2 starting uh just running this command serve as build and in fact let's try this first serve as build to see if our application is going to be served so it says serving local and network to the port we're forwarding to and there it is already uh we can see it's kind of working here's our domain and then here's our front end with no data but like i just typed we're going to run this in pm2 with pm2 start serve as build and you'll see it created under a name serve that's probably not the best but we can keep that in mind this is running under the process serve and it's online and then when i refresh it's still running so that's cool now we have our front end running so we have to send through our worker and our api files so i'm going to clear that out this is our local machine again change directory out to our home directory and then we want to send through a cpr let's see api and i'm just going to hit up a few times to get this command back i'll send through the api folder to our home directory then i'll send through the worker folder then i'll also send through package.json to get our dependencies namely express and the redis client so back over in our vps i'm you going to need to install redis so i'm just going to do sudo aptget install redis yes and we can test whether that installed by doing redis cli as we did on local and it seems to work so exit and now that we have all our files here let's just check that we do let's do npm install to get those dependencies and now let's start our worker or rather let's start our api bm2 uh start api index.js i'll do name api and then we'll also start our worker pm2 start index.js name worker okay everything seems to be running but how are we sure that our work is working well let's do pm2 logs worker just to see if those logs that we set with the console logs that actually give us the indication workers working are actually going to run so you'll remember that we did a cron for every minute so let's see if those logs are actually going to run after a minute so we just got to wait and see if that happens and then once that happens our redis will be loaded so in theory we should be able to refresh our page and then see all the jobs there but right now we just gotta wait the suspense is is kind of killing me here uh i feel like it's been longer than a minute i don't know if it's gonna work or not but i actually have faith okay there we go come on worker you can do it okay it says success okay and uh so now our reddish should be full if i refresh there's all our jobs amazing so we have a deployed application everything looks just as it did on local if i click into these jobs let's see uh it works there's our description logo and everything and then if i click apply it'll take us to that position so that's pretty cool guys we just deployed our whole app and it didn't even take that long i feel like that was around 30 minutes or so all right guys that's it we basically built a whole production application in less than 100 minutes and we got it deployed and now it's running on the public internet at entrylevelsoftwarejobs.com so go check it out but um i'm thinking next there's a few critical things we have to do before we're ready for like a full production launch so to speak this was just our base framework that we're building more features off of but at minimum i think we need a few more data feeds and we need to make our algorithm a lot more robust prevent it from breaking on errors as well as filtering down those jobs a lot more because if we get in five feeds we're just gonna have a huge amount of jobs and we really wanna make sure those are entry level jobs so i'm thinking that we parse through the description and look for like three to five years of experience and take those out i think anything less than three years would qualify as an entrylevel job so again we're gonna have to keep working on the algorithm and then otherwise we're gonna want to add a little bit of monitoring logging different things like that but that can all come later our mvp is done and our base of our application is done so that's pretty cool so anyway hope you learned something um let me know if you have any questions and i will talk to you guys soon