Hey freeCodeCamp! Welcome to another of The Daily Programmer web series video. The problem we're gonna talk about today is called spelling with chemistry, which is is number 302 on the daily programmer subreddit. And before we break it on the whiteboard, I just want to say there's a survey link in the description below if you want to take it. Should take you like a minute or two just so I can get feedback on the videos I'm making in try to improve them in the future. All right, so let's break it down. Alright, so for this problem we're given a single input. For instance, the string bacon, and our goal is to decompose that input using the periodic table of elements over here. So for every symbol in this table can we build up this string? So to kind of walk you through an example. The first example we can build it up with B for Boron, Ac for Actinium , O for Oxygen, and N for Nitrogen, right. And then we also just want to keep track of the weights here if we were to sum all these atomic weights together For this first example we get a 267. And the purpose of the weights is we need to return the maximum way to build up the string. Alright, so that kind of overviews the problem. Let's go ahead and look at two other examples. We can use Ba, which is Barium, plus carbon plus oxygen plus nitrogen and when the atomic weights are summed up we get 179 And then lastly, the last way to decompose this string using the elements is we can use barium, cobalt, and nitrogen which ends up summing to 209 using the sum of the atomic weights. And so again, the goal is given a string, break it down or decompose it using the element symbols and then return the best optioned with the maximal atomic weights when summed up. So in this case, this is our best answer and we need to return that. So that was a good overview of what we need to do to solve this problem. Let's go ahead and work out how exactly we generate these potential solutions, and then pick the best answer. So we take a step back and just think. All the symbols in the periodic table of elements is either one or two characters, right? There's nothing that three characters. At least the table that they provide us in the example. So what we can do is just try each possible one character or two character combination. So they kind of walk you through this. I'm going to building a chart or a graph which kind of represents the recursion of the algorithm. So starting off you have a word. For instance, bacon. And we have two options. We can go ahead and pick off the first letter, which leaves us with acon? Yeah, acon. And then of course keep track of whatever number that was. So I'll say that's the atomic weight of 10.8. And then the other option is we can take off Barium, which is Ba. And then the atomic weight of Barium is 137, And then leftover we just have con over here. So once you reach this depth of the recursion or the program, we can then remove Ac for Actinium but we can't remove 'a' because there's no element with just one symbol. So I'll just go ahead and say we remove Ac, Actinium is 227. And then again, I'll just go ahead and pop off those two so we're left with O and N. And then over here, we can take one character which is Carbon, so I'll go ahead and say, 'C' And we're left with on. Or we can take Co for Cobalt, which we're left with Co. Oh sorry, we're only going to be left with the N for the Nitrogen. And then again, Carbon's atomic weight is 12, and Cobalt's 158.9 And moving on to this level or this depth, we can again remove the O, which is Oxygen which gives us 15.9, and then we're left with N, and then we're left with the empty string here if we were to remove nitrogen, which atomic weight is 14. And there's no particular way to remove O & N because there's no element called 'on' So we have the same thing over here. We can remove the 'n' Sorry, we can remove the O. And then we can remove the N here. And then lastly we could just remove the N here, atomic weight of 14, and we're left with the empty string. So looking at this graph We can tell that there's three possible solutions Right, and the solution ends when we reach an empty string meaning that we are able to take off one or two characters all the way up until we reach the empty string meaning that we've built it up using valid elements. And if you notice here, we kind of check before we go down this path to make sure that the element actually exists. Like there is an element called 'a' And if there's not, we don't go down that path Otherwise, we go down the other path. Since there's an element called Ac we can go down this path. So then looking at this graph, it should be pretty obvious as how do you find the maximal way to build up. Um.. Or decompose this string using the elements' atomic weight. So we can go through here and just add them up down the path, and I'll kind of just do this off I'm not going to do this, uh, Exact so I'll say 10 + 227 + 16 + 14 This path we have 137 + 12 + 16 + 14, and in this final path we have 137 + 59 + 14 So this one, if summed up, we get roughly 267, around there. For this one where you take Barium, We take Oxygen, I'm sorry, we take Barium, Carbon, Oxygen, and Nitrogen We are left with, We're left with 179, roughly. And then lastly we have Barium, Cobalt, and Nitrogen, which leaves us with 209 roughly. So obviously this is the best path that we need to take. Right here because this is the maximum. 267 over 179, and 209. Alright, so that kind of is how you solve the algorithm by hand, right? You could just simply draw out this little graph And then go through and sum up your best path and then return that as your option. Pretty straightforward on paper. Right, so how would you kind of do this in code? And before we go to Javascript, let's kind of break it down. So basically again, just pop off The left or pop off one character, check the element exists, pop off two characters, check if the element exists. If they do exist, you can then go down that path recursively and try it again, and then of course keep track of the the element that you chose and then keep track of the atomic weight as you sum them up and Then keep doing that algorithm Remove one character, or two characters, check the element exists for two characters, if it does go down that path etc, etc, until you reach the empty string down here And then if you reach this ending statement where you have an empty string, you should have a running sum that's already up to 267 at that point And what we can do is just let's go ahead and add that to some type of collection or an array where we keep track of The symbols so let's say symbols, and then we keep track of the sum So say 267 and basically we just have this array that keeps building up So this array will end up becoming an array of 3, where it has objects where we have the symbols we used. In this case would be 'B' AcON And then in this case would be BaON, so I could say BaCON and in the final case we have BaCo in lower case And then the sums would be you know whatever. This is so This is, so, 179, 209, and I know you probably can't really read this but just know that you have an Array at the end that has all of these symbols concatenated and the sums added to it. And finally we could just sort this in descending order and pick element zero. So in this case, we'll just say pick the first element after sorting descending and that's going to be our answer. Alright, so hopefully that was a pretty good breakdown of what we need to solve. A breakdown of how we solve it, and let's go ahead and move the Javascript and try to solve it in our editor So starting off from showing you the problem as is posted on the dailyprogramer subreddit, And you can see here they provide you with a table of all the different elements and their weights, and their symbol name. So I did a little bit of preprocessing, which you're going to see in the code that I'm just going to start with a variable called elements, Which is going to have all of its already defined as objects. And then again if you wanted to look through this or see an example, um, Answers down below, you can do so, you just hover over these gray text. You can see them. So now that we have you know information as to where that's coming from let's go back to the code. And you see that. I started out with a const called elements I'll actually going to make this all caps so it's understood that it's a global. And then in each property of this object we have the symbol name, which maps to an object that has a name of element and the weight of that element. And then down at the bottom, I'm just going to go ahead and call spellWithChemistry, which will be our functioning we're trying to implement and I'm passing bacon to it so we can actually start testing out with the bacon. So to start off let's go ahead and write a function called spell with chemistry, which takes an original word And then what we need to do is again, I like to work backwards. I'm going to declare a constant called results and set it equal to an empty array And then like we said on the whiteboard I need to return the first element of results after or right after we sorted, right? So again, we're going to sort this somehow. And in this case, let's just say that we have 'a' and 'b' are the elements in the array And then 'a' should just be an object that has the weight values, So I can say b.weight a.weight so that should sort it in descending order, The zeroth index has the largest weight So now that we've had like this whole like boiler plate What do we do after we find the different solutions that we push in the results? How do we actually implement this whole, you know, traversing the tree recursively? So inside our spellWithChemistry function, I like to make a function called helper, which is going to take a couple of arguments So that we can keep track of the state as we traverse down the stack. So the first argument is going to be word, which is the current state of the word. So bacon, remove the b, should be acon or con. Or on or 'n' and that will change depending on where we go down the tree We have another parameter argument called symbols, which is just going to be the list of symbols concatenated together, which allows us to easily print it out down the road. And you can, I think that's optional. You could just change it as you want to. The third parameter is going we called elms, which is the elements. In fact I'll just call it elements, which is going to be the list in order of elements that we put into the results in order to build it up. And then finally we have a running sum weight. So as we pick elements we just keep track of the weights and push that into our recursive function And then of course since we have this helper function, we need to call it with an integer, or, the original word which is going to be bacon in our case An empty string for symbols. I'll just say an empty array for elements, and then zero for the weight. So again, just take a step back. What is helper supposed to do? It's a function that supposed to traverse that graph and then when it gets to an ending terminal node or an empty string We push the result into our results array. So again I'll repeat that. If we reach a terminal node, so how do we determine a terminal node? Well, the length of word will be equal to 0, right? If it is, that we know that we've reached a node which actually can be spelt out with the symbols list or the periodic table of elements. So again we start with, if word.length is equal to zero, we can just go ahead and return, um, results.push And we can push in the the list of elements we use. So in this case, I'll just say output, which is just going to be a string output we can use where we output the symbols. And then followed by a space, we're going to output the elements.join like so So basically this is going to print out a string, which has the actual string built up with symbols and then followed by is going to have all the elements we used in order written out with their actual element names. And then lastly we can just print out The running some weight or or put that inside the object so that we can later sort it down here on line 122 So now we have the base case of our recursive function typed out. We can now start working on the else statement. And I'm actually going to try to use more like ES6 functional paradigms. So what we can do is remember we have two options. we can try to get or pop off one character or we can try to pop off two characters and Then we need to check to see if those characters first of all put us out of bounds So I'm going to go ahead and do a .filter on this array And I want to filter out any of the choices which put us out of bounds. So I could say word.length numChars greater than equal to zero. So I only want the numbers which keep us in bounds. So for instance, if we write the very end and so bacon we get down to the character 'n' So if word was 'n' for this example, we don't want to filter on 2 or we don't want 2 to pass our filter. Because if we try to take two characters off of that word, it's going to crash, right? So that's why we have this filter on 119 So now that we know which num characters we can actually try, we need to go ahead and map those num characters to their actual symbols and map them back to this elements array right at the top So to do that I'm just gonna pretend like we have a function that's called getSymbol() Which we can pass in our current word and pass in the number of characters we want to remove from the front of that word. So I'll go ahead and call it getSymbol() here, but since that's undefined we're getting an error So I'll go ahead and define it up here and pass it word and num characters as parameters And what we want to do is, when passing a word We want to take the first two characters of that word or whatever characters numCharacters is So we could take the first character or we could take the first two characters Then we need to take the first character and make it toUppercase So we can actually find it in our symbols array And then we're going to concatenate that with another substring of numChars. So again take either the first or the two characters And then just concatenate that capital first character with the rest of the string here. So again if we were to call getSymbol() here, with let's say "bacon" and then pass it two characters Actually I don't think this is going to run right now because, oh it does run. So again look it prints out to 'Ba' If I were to change this to one, it just prints out B capital B All right, so that's what getSymbol() is doing. Its just returns the first two possible symbols that you can build with a string. So then again So again we have one and two. We filter out the ones that don't put us out of bounds. We map them to their respective symbols, and then we want to filter again to make sure that the symbol that we've trying to generate actually exists in our array. So we can say elements.symbol So only give us the symbols, which are real elements in our periodic table of elements. And then finally we can just loop over each good symbol and recolor for a recursive helper function, right. So in here I could say forEach symbol Call our helper function one more time and then in this case We're going to remove those first one or two characters, so I could say, word.substring of symbol.length, So that could return remove one character, or that might remove two characters from word? We want to concatenate that symbol string with the symbol we chose. We want to concatenate the elements that we have Previously chosen with the element that we just chose. So I'll say concatenate elements.concat with elements of the symbol.name. And then lastly we want keep track of that running sum of weight. So if you say weight + elements of symbol.weight So everything seems to be working fine. And now if I scroll down to the bottom, so we see here in the output below it printed out BAcON with Boron, Actinium, Oxygen, and Nitrogen and gave us a weight of 267. And then again just to show that we got multiple results, I can just go ahead and print out the results here. And we see that we get an array of three different elements, where the first option is this type of, this spelling of bacon. The second option is this spelling of bacon, which gave us a weight of 209. And third is this bacon with 279. So that wraps up our solution or implementation for the spelling with the chemistry problem. This problem was a little bit more challenging than any of the other problems I think I've done in the past mainly because we're dealing with recursion in this one. It's a little bit more complicated to build up and traverse that graph But if you did have issues understanding this, be sure to you know watch tutorials about recursion Try to solve easier recursion problems such as like fibonacci just so you understand our depth first search Breadth first search or whatnot and then hopefully after Learning those you can come back and get a better understanding of how you solve this yourself. Also as a reminder, there's a survey below which should take you about two minutes to fill out just so I can get feedback as to, you know, How difficult these problems are? Are these helping or these not really helping? Is there a way I can change these videos to make it so you can comprehend when I'm teaching better? Again feel free to leave me any type of feedback and Be sure to subscribe to freeCodeCamp below and like the video if you thought was good, Alright, again I'm Cody and thanks for watching.