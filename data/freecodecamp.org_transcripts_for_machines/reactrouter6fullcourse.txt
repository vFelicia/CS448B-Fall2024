this course will teach you to build real world apps with react router 6. you will Master essential react router features such as layout and index routes nested routes search parameters route protection and the new remix inspired data router apis Bob's role teaches this course he is one of the most popular react instructors ever and is also the head of education at scrimba hi there free code campers and welcome to this interactive scrimba course where you are going to learn how to use the react router library to build single page applications in react since this is a course dedicated to a specific thirdparty react package it's going to be pretty important that you already know react if you haven't yet learned to react or you just need a refresher I've got you covered I've got another free course here on free code camp and on scrimba that's a complete introduction to react you can check the video description below for a link to that course and then when you're ready you can come back to this course it'll still be here for you I promise now the special thing about this course is that it is fully challenge based which means you as a student are going to get your hands on the keyboard again and again to really practice the topics that we're learning and if you're feeling a little bit concerned at all about following the challenges of this course on your local development environment don't worry that's why we've created an interactive version of this course over on scribba.com there you can solve all of the challenges directly in your browser without having to worry about anything with your local environment If instead you do want to follow all of the challenges on your own local environment that's great too I've got a GitHub repository with all of the code that you'll need in order to follow any of the challenges that we have throughout the course again check the video description below in order to get links to that GitHub repository one final thing if you are enjoying this course I ask that you please give it a thumbs up here on YouTube and if you have any feedback for me you can always reach me on Twitter at bobserol so with all that said let's get started welcome to this course on react router 6. I am so excited to guide you through one of the most popular and impactful libraries that exists in the react ecosystem now react router is a library used for enabling something called clientside routing and understanding what clientside routing even means is just one of the many things that we're going to learn in this course from a really high level we're going to be learning about the basics of using routes and routing we're going to learn about how to navigate between our routes we'll learn about layout and index routes nested routes we'll dive pretty deep into learning about search params and how to filter results and we'll be creating protected routes so that you can allow only authenticated users to visit certain parts of your page along with those there's a ton more that we're going to be learning and of course in the typical scrimba fashion we'll be doing tons of HandsOn practice in order to drive the curriculum forward we're going to be building a really cool app called van life which is a way for people to rent out camp Vans for their next road trip adventure this app will have over 10 routes we'll be able to filter the Vans by their type we'll learn about active nav link styling so we can very easily tell in the user interface where we are in the current APP as I mentioned we'll be including protected routes so that certain pages will only be accessible if you're logged in and will be hitting hard the concept of nested routes because this app goes multiple levels deep into nested routes then towards the end of the course we're going to be shifting Focus briefly to learn about how we can migrate our fake data into a real database using Firebase and periodically throughout the course we're going to update a live version of our site by deploying it to netlify here on the scrim I do have the final version of the code for the app that we'll be building so you're welcome to poke around the app get a feel for it you of course are also welcome to look around the code don't let it be intimidating because jumping into a new code base is always a bit intimidating instead be excited that you're going to be learning everything you see here now this should be really relatively selfexplanatory but the things you should know before starting this course are of course react I would expect before you start this course that you have a pretty solid foundation in react if you are feeling Rusty or you have not yet had a chance to really learn react this course will not be a good starting point for that it will assume that you already have the basics in your tool belt so if you do need to spend some time learning react or just brushing up on certain topics I have a free course here on scrimba it's over 12 hours long it's got tons of practice tons of projects and is completely free you can click the screenshot here which will take you to that course on scrimba if you'd like my name is Bob zerol I'm going to be the course instructor for this entire course the most active place you can find me online these days is on Twitter you can click this little Twitter icon to go to my profile page on Twitter and without any further delay let's jump in and start learning about react router version 6. I mentioned that react router enables us to do something called clientside routing however that might not make a whole lot of sense on its face if you're not familiar with the history of multipage applications versus single page applications so let's spend a second talking about the difference between these two in a more traditional website you have multipage applications or mpas on the left side of this diagram we have a client it's showing a computer but more accurately the client is really the browser in our case and on the right side we have a server which really is just a computer that lives offsite usually somewhere else so when you go to your browser and you navigate to a website let's say mysite.com a simplified version of what happens is a request is made to the server that's associated with the domain of my site.com and it's requesting the HTML page that is needed to display the web page at that point the server will do some processing it will grab the HTML page but it also might be evaluating some CSS or some JavaScript it could potentially be reaching out to a database or making API calls to other servers in the end with the ultimate goal of putting together a completed home page to send back to the browser in the form of an HTML file that HTML file is then sent back as a response from the server to your browser and your browser then loads that page for you to view so then once you're looking at that home page you might go ahead and click on the about page the URL for this would be my site.com about which would then perform another request to the server the server again would go through similar processes where it would be searching for the about page to then deliver up to the browser your browser would then replace the old home page with the new about page from the browser's point of view it might look something more or less like this not including this actual animation when you're on the home page you can see all of the homepage content including a header let's say and a footer and when you click on the about page the entirety of that page is disk carded and replaced with the entirety of the new page of course it's usually not a sliding motion like this instead it will appear more like a Flicker and that Telltale flicker is a good way to know that you are currently looking at a multipage application so how does a single page application differ well don't be confused by the name single page application it doesn't actually mean you can only have one page on your website but instead it means that your browser is only loading a single web document one time and then your app will make incremental updates to that existing document through different methods like internal react State changes or fetch requests to an API it all starts in a very similar fashion in your browser you navigate to mysite.com that makes a request to the server the server will then process a few things but this time instead of its job being to process and build an HTML file it's going to send back an entire react application so that application is sent back to the browser it's loaded into the browser and when new requests like going to the about page are made oftentimes portions of that new page are able to load directly inside of the react app without any new requests being made out to the server that said the about page might still need some extra information or data from a server or an API and so a request could still be made out to a server at which point it would do its job and this time instead of sending a new page back because remember that view already exists inside of the react app itself it's likely only going to be handling sending back something like Json data that Json data gets sent back to your react app which then loads into the react app gets consumed by it and changes whatever view you're looking at to include the new Json data that you just loaded from the server all that said on the client side the real difference that you'll see is there won't be the same flicker of the entire page when you're going from one page to the next because remember we're not reloading the entire document it's just one document one page but the content on that page might change in essence what that does is it might swap out the home page content for the about page content because the react app was loaded on the initial render of your website it already knew what content the about page was going to contain and it may or may not have had to reach out to a server to get some additional data in fact in our van Life app we're going to see this where we can transition to the about page without any delay without any of that flicker that happens with the multipage application and the about page doesn't request any additional resources or Json data from the server instead it's already loaded on the initial render of our site however when we go to the Vans list page the beginnings of that page will load in sort of a skeleton UI you could say while in the background a request is being made to the server to ask for the specific data about the vans that we need to list then once that data comes in it will update the page to display the Vans this will make a bunch more sense once we actually start developing it so that's a very high level overview of what will be happening as we're building a single page application using react router now it's time for us to actually dive in and start learning the code hey free code campers this is a special message just for those of you that are taking this course on YouTube when you're following this course on YouTube you likely will want to complete the challenges and write the code alongside me in your own local environment and so I wanted to make a quick note about developing through this course locally at this point in your Learning Journey I assume you're already familiar with some kind of editor like vs code and at least know your way around the program in order to create new files and open a new project and so forth well the code for every lesson in this course exists inside of a GitHub repository that I really want to encourage you to go follow using this GitHub repository will give you the starting code for every single lesson in this course not only that but it will have a really important readme down here that will give you specific instructions for how to set this up on your local machine and any gotchas that you might run into while you're developing locally as well as any updates to this course that you might need to be aware of of inside of scrimba I have the power to record new lessons and insert them anywhere inside the course that I want but with the course being here on YouTube I don't have that same capability so this GitHub repository and the readme therein is going to be a really important tool for you as you work through this course to make sure that you're getting the most uptodate information so even if you don't plan to use the code from this GitHub repo and you just are going to start the project up completely from scratch on your own still make sure that you come to this GitHub repository start it watch it bookmark it whatever you need to do and make sure to check it regularly in case there are any updates that will be important to you as you learn react router in this course the link to this GitHub repository should be readily available in the description down below if for whatever reason you get stuck developing locally while it is a great experience to debug those local development issues I don't want that to become a demotivator for you and stop you from your progress in the course so if at any point you do feel like you're getting stuck you are of course is always welcome to head over to the scrimba platform and just pick up where you left off in the react router 6 course okay that's all I have to say about this for now let's keep moving forward in the course okay we're gonna start this app from the almost bare bones we have a very basic react project here you can see that all we really have is a simple hello world there's one thing I do want to point out and that's something that I haven't really talked much about before and you might have noticed it real quick over here in the index.html you'll see that our script tag is pointing to index.jsx when you're working in a react project you can specify any files that have react components in them specifically ones that are using the jsx syntax as having a DOT jsx extension now under the hood in scrimba we've made it so that it's using Veet in order to compile the language if you were to download this onto your local machine and run it and Veet expects any components you make in the jsx syntax are using the dot jsx file extension now here on scrimba it's going to work just fine if you decide to make these as dot JS files but I did want to introduce you to that in case you had never seen it before so throughout this section and this project we are going to be using jsx files when there's a react component involved okay let's move on to react router setup you can see I have react and react Dom included as dependencies I need to include another module called react router Dom and that's react Dash router Dash Dom so I'll add that here you can see the current version is 6.4.3 now for a little extra information react router Dom 6.4 introduced a whole new set of tools that you can use in react router I'm planning on touching on those new additions to 6.4 a bit later in the course however in this section I'm only going to be focusing on the basics that come with version 6. we will not be going into the data layer apis that come with 6.4 okay let's start out with the most basic thing in order to set our project up as a single page application with routing using react router we need to import a few things and in this screencast the only thing we're going to be worried about is importing something called browser router and that comes from react router Dom now we just learned about context recently in this course so I think this will be interesting to you what browser router is doing under the hood is it is a context provider and so in order to give our app the power to include routing in its functionality we need to wrap our entire app with this browser router so I'm going to put browser router around the app like this we'll hit save and nothing much should have changed we should still get our hello world text right there but by simply adding browser router we now have a whole Suite of tools that come with react router Dom that we can use to control our app now just in case you see this in the wild sometimes people will rename browser router since it's a bit of a mouthful and so they'll import browser router but then rename it to something like router now we're also going to be seeing that there is a routes component and a route component so I'm not going to rename it as router because those are all very similar so we'll just call it browser router for now awesome this is a great start like I mentioned there's a few other components we're going to be importing so that's what we'll be working on next as we mentioned browser router is a context provider and it provides context to all of its children components very similar to what we were doing in our reusability section so browser router is the provider we need to set up a way to define the routes that we want in our application we're going to start with a really simple Home Route and an about route and there's two components I need to pull in in order to start setting that up the first one is one called routes the routes component goes as the first child inside the browser router so I'll set up routes here and I think to avoid confusion I'm actually going to stop rendering our app component so we just have the browser router and this empty routes element notice here it has a separate closing tag and that's because inside of routes will need to go a series of new components that is just called route now just in case you don't know a route is just part of your url that specifies where on your website you are so let's say you have a website like example.com example.com would be your home page and oftentimes it has a trailing slash so that route might just be called the slash route but if you wanted to create an about page on example.com you would maybe have a route called slash about and then this part of your url is the route for your site maybe you have a contact page that would be slash contact or maybe you have a Blog Page slash blog now routes can be nested and we're going to cover nested routes later but if you had a Blog you might want to specify that you have another route as part of this URL that leads you to blog article one you hopefully have more interesting titles than that oftentimes blogs will use the title of the blog as this part of the URL although you might see sometimes it's just an ID number where it specifies for the database under the hood which blog ID number it should be looking for currently over here in the mini browser you can see that it says slash index.html and when we're just serving up a single HTML file that might be true but once we set up our routes we're going to just see the route portion of our mini browser it's not going to say something like example.com it's just going to say slash or in our case slash about it'll also say in the app we're building it'll be slash Vans it'll be a Vans route and then we're also going to have Vans slash and then some ID number for the van okay we're getting a little ahead of ourselves we don't have any routes to find so now we have a place to put our routes we need to start using this route component to actually Define our routes and actually we've covered enough material I want to get your hands on the keyboard so we're going to have a quick challenge before we move on before we get too far I want to make sure that you are practicing some of this so you're basically starting from scratch I've actually removed the app component because in this case we're not actually going to render anything to the page yet and I've already included the react router Dom dependency over here so all you need to do is to render our browser router with a routes component inside of it so pause here and work on this challenge okay first things first let's make sure we import the browser router and the routes components from react router Dom again the browser router is a context provider so we are going to wrap everything that we have Below in the browser router and for now we're just going to put one nested child component in there and that's going to be the routes component all of the rest of our work with react router is going to happen inside of this routes component okay hopefully everything has made sense so far we haven't gotten too deep yet so when you're comfortable with what we've done here we'll move on next to creating our route definitions the next component we'll talk about is the route component which we also need to import from react router Dom and this is really where the meat of what you'll be working on will happen it's within these route components the most basic way to use a route component is to render it as a selfclosing element here and the route component can take a few different props the most common of which are the two that we're going to learn now and that is path which is where we specify what the path to this route should be remember I mentioned that the Home Route is going to be called just slash well that's what we're talking about here we're talking about the route path if I wanted to create an about page I would make this slash about or a contact page slash contact for now let's create a home page and secondly we need to tell it which react element we want to render if the path in the URL bar matches the path that is defined here on this route component now you'll see that I put a set of curly braces that's because inside the curly braces I need to render some kind of jsx in this case we'll say when the home page is loaded or rather when the path is just a plain old slash we want to render our app component that we have up here now I haven't quite shown you this yet but I want you to see if you can figure out what we need to put here I mentioned that we need to render our app component see if you can read between the lines and figure out what it is that's going to happen inside my curly braces here this is the kind of thing that's fun just to play around if it doesn't work that's completely fine you're not breaking anything that can't be undone so notice that our mini browser is currently at slash see if you can make it so that when you fill in this element and then hit save that your hello react router H1 will show up here on the page pause now and see if you can get that to work one thing you may have tried was to pass a component as a function like this and actually in past versions of react router you actually could do something very similar to that however I did mention that we need to render the app so I'm going to surround it with the angle brackets like we see here okay let's hit save and there we go we are at the slash route and we're rendering the app component when we're at the slash route out of curiosity let's see what happens if I add a slash about here and hit enter okay it sends us to the slash about page but there is no slash about path and so nothing is showing up this seems like a great place for another challenge okay your task is to create an about component just right here underneath our app component and it can render whatever you want I mentioned an H1 that says about page but then I realize that's probably pretty boring so choose whatever you want to render there and then you need to create a new route so that it will render the about component when the path is slash about I've already put it here at slash about so you will know that this worked when you hit save or refresh over here and your H1 or whatever it is you render in your about component is rendered to the page pause now and work on this challenge I'm feeling a little bit boring so I'm not going to be super creative and I'm just going to copy my app component and we'll put this as an about component and we'll just say about page goes here okay maybe we can make it a little more interesting we'll put a little Tada symbol there okay now down here where my route definitions live I'm going to just copy my route this path will be slash about and the element will be the about component getting rendered I'm already at slash about let's hit save and there we go about page goes here and if I get rid of Slash about in the mini browser URL bar and hit enter it sends us back to the home page or maybe more specifically the slash route let's clean this up so we can see a little bit more awesome work now you might have noticed it's quite annoying to have to click up into the URL bar in the mini browser and type out slash about usually that's not how navigating around the website's going to work so in the next lesson we're going to briefly cover another component from react router Dom called link that will help us navigate through our routes in a much easier way okay before moving on I actually want to do a very quick reorganization I didn't just want to do it behind the scenes because I was worried that you might get a little Jarred by me having changed the code so quickly but right now it's I guess a little wonky maybe it's just me but I have this app function or app component that's being rendered as the home page but I have an about component that's being rendered as the about page I feel like I'd rather keep the names a little bit different and then instead of rendering the entire browser router inside of this render method I think what I'm going to do is treat the app like the top level so I'll just render app and that means I'm going to take this entire browser router put it inside of app and then I'll create a separate component just called home that represents the home page then instead of rendering the app as the home page will render the home component that we just made and down here we need to render our app and maybe let's move this onto its own line okay that feels a little better to me let's move on like I mentioned it's a bit annoying to have to go up to our menu bar just to change which route we're in so if I want to go back to the home page I have to hit slash and then if I want to go back to the about page I have to type in slash about we also can see that when I do that the page is actually blinking which means it's refreshing it's doing a complete full page refresh it's not that big of a deal when you only consider about the blink but if you have any kind of state living in your app that needs to be passed to the about page or well really any state at all doing that page refresh is going to completely wipe out any state that you were maintaining if you really think about it a react app is a little bit delicate when it comes to State because if that page refresh happens then all your state just completely disappears unless you're saving it in local storage or something like that it will just completely reset now the way to solve this problem in HTML is to have an anchor tag the problem with an anchor tag is when you click it it will do another page refresh so we need some way to navigate between our different routes within the ecosystem of react router Dom Unfortunately they give us a component to do that and it's called link so I'm going to import the link component capital L link and if you actually look at your Dev tools when you render a link it's just rendering an anchor tag but it's intercepting the path that the anchor is sending you to and making sure it doesn't do that page refresh so you can maintain your state now this isn't the real way that you would do this but to avoid having to put links in both the home and about Pages I'm just going to stick a link element right here and the way that link works is very similar to an anchor tag so it will have an opening and a closing portion to it whatever you put inside is what will be the text that shows up on the page but instead of an href property a link takes a two property and this is actually kind of nice because it reads like English this is a link to the following route and so I'll say equals slash to go to home we'll duplicate that and we'll say it goes to slash about to go to the about route again you aren't going to usually stick your links just inside your browser router like this we're going to see a more robust way to have this navigation element that will appear on every page later but let me hit save it's going to be poorly styled it's just kind of shoved together because they're inline elements but when I click the home button it takes me to the slash route and when I click about it takes me to the about route and if you look closely you'll see that there's no page refresh happening between the two if I were to create some state in my app and pass that as props to my home and about components whatever state I created even if I decided to change it maybe like a counter that I had a button that said incremented and it counted up to 10 when I go back and forth between the about page and the home page both of those will still have that state of 10 as opposed to using an anchor tag or typing into the URL bar because that would refresh the page and refresh my counter State back to zero because it would take quite a bit of code I'm not going to bother actually showing that example hopefully it makes sense if not that's okay the main thing to take away is that if you want to link from one place to another or navigate from one place to another inside your react app using react router you have to use the link element now if I want to style these links I could either give each one of them a class name and select that class name in my CSS or if I need to use the element selector then I can go into my CSS I can say select my nav or maybe if I had some kind of class on my nav then I would put it there but to select the element of the link remember it's rendering an anchor tag so I need to select the anchor so maybe I don't like the underline we would say text decoration none and there goes the underline we are going to be revisiting the links a little bit later in this section but for now this is good enough for us to more easily navigate around our app without having to type into the navigation bar or use these little back buttons and lose our state in the meantime as always feel free to play around with everything we've learned here and when you're ready we'll move forward before we move on we're going to apply what we've learned so far by creating the first two pages of our van life project so your challenge is to do exactly that I do have the react router Dom dependency already installed in this project so you don't have to worry about adding the dependency but you'll see that I have no Imports I'm not using anything with react router yet and so that's going to be your task as a part of that I want to make sure that you also include a navigation bar so that you can at least get to the home page by clicking this van life logo or the about Page by clicking the about route if you want you can add a Vans route but we're not going to be dealing with that quite yet as a part of that you'll notice that both the home page and the about page have the same navigation bar we haven't learned sort of the official way to handle this but I did show you one example in a recent scrim so I wouldn't worry too much about it if you want to copy and paste the code you use for the navbar on the two pages that's totally fine if you find a way to use the same code on both Pages that's fine too we're going to learn learn a more official way to handle that situation in an upcoming lesson now this isn't something I'll say super often but I do trust you to know where your strengths and your weaknesses lie if you do feel like you struggle with CSS then I would encourage you to actually do all of the CSS by yourself it's not an insignificant amount that you would be spending trying to get this designed this way so I just wanted to give you a heads up since I have already designed this on the side we're not going to be spending our time actually thinking through and writing all the CSS I'm just going to copy and paste what I already have but since this isn't school I'm not going to be giving you a grade so if you have a weakness in CSS then practice it exercise it actually do this yourself you can click on either of these screenshots which will take you to the figment design where you can grab all of the spacing and fonts and colors and everything you need however if you do feel pretty confident in CSS and you really are just here for the react then I totally understand if you just want to make a Bare Bones white background black text page that will link you between the home and about page to practice react router specifically and not necessarily to practice the CSS so I'll leave it up to you just do whichever will be best for your own education okay that's enough of an intro pause now and work on this challenge okay let's import some of the things that we already know we are going to need we know we need browser router that's going to be the context provider that will set up everything with router we'll need the routes component and some routes inside using the route component the naming is a little confusing and we're going to need the link component and all of this will come from react route or Dom there's a few different ways that we can set this up let me buy myself some space here we could either put all of our react router stuff here inside of app or we could put all of the react router stuff right here in the render I'm going to prefer that my app act almost like a table of contents for my react router stuff and so I'm going to render the browser router right here in my app we'll create our set of routes and inside there we will have a route we'll have two routes and these are both going to have a path and the second one is going to be about but we'll handle that in a second and then it will be rendering an element and let's have the first one do a home element the second one do an about element this will be slash about and then that is going to lead us to some errors where we don't have a home or about element so let's import those even though they don't exist yet and actually you know what I think I'm going to put all of my pages into a folder called pages so we'll say that I'm importing this from dot slash Pages slash home and about okay that means I'm going to have to create those so we'll create a Pages directory and I'll create a home dot j let's see jsx because I'm going to use jsx in this project and we'll also create an about.jsx okay import react from react hopefully by now this has become kind of second nature just being able to spin up a quick react opponent like this let's do our classic H1 that says home page and then I'm just going to copy this whole thing and put it in the about we'll change this to say about page okay this is good it's now displaying home page here so let's go back to index and I guess let's test to see if we have our different routes so for now because I don't have any links we'll have to type in slash about okay we got to our about page cool now like I mentioned in the challenge I didn't want you to spend too much time looking into how you would include the navigation bar only because there's a sort of this designated real way to do this in react router and we haven't learned about that yet obviously when we have a site with a lot of different pages it's not very maintainable to copy and paste the navigation bar into every one of our Pages if that's the way you solved this challenge of getting the navigation bar up there that's completely okay I specifically mentioned that that could be something that you do but one other thing we could do is before we start rendering our routes I could stick the navigate education bar right here under my browser router above my routes so that's what I'm going to do for now but we'll be learning the real way to do this very soon so let's maybe put this all inside of a header element and that's where we will have our navigation and let's see to be honest I'm not sure if the logo that is clickable and sent you to the home page should be a part of this nav element because it's also kind of serving as the site logo for now I think I'm going to just consider what's on the right here part of the navigation and I'll call this maybe its own link so in the nav I'm not going to use an a tag because that is not how we transition from one page to the next in react router I'm going to use a link element but I need to import this so oh I already did import it okay awesome this one will lead us to the about page I need a two prop that goes to slash about and then as part of the header but not part of this nav we'll say that we have another link this is the one that will say hashtag van life and this is going to send us to the home page or slash okay I'm sure this isn't going to be pretty but let's see if it works that takes us home that takes us to about okay now this is kind of what I was talking about the rest of our efforts would really just be into putting some content on the page and then dealing with CSS however because we're learning about react router I'm not going to spend our precious time making you watch me do CSS so I'm going to snap my fingers and just like that we have a project that is designed now don't be thrown off this is basically what we had before just with a few changes and I'll walk you through them so it's not so disorienting our home page and about page I've really just put in some CSS classes and some content same with the about page over here one thing you can see is that I also added these images I put them inside of a folder called assets and then images so we have the two Heroes on the two pages I have some styles that I plan to use throughout like this button right here I called a link button just because it is actually a link but I wanted it to look like a button and there's a few places where that exists I think over on our home page we also have this one I think right now this might be sending to the slash Vans route yeah but we don't have that yet we're going to get there soon so feel free to poke around the CSS if you'd like it's really just 145 lines on top of what we already had so it's really not too bad so the next thing we're going to start learning about is something called nested routes so once you feel good about what we have here let's move on you know it may not look like much but darn it it is worth sharing so let's talk about continuous deployment using netlify the terminology may sound complex but I promise it's easier than it sounds in this lesson we're going to walk through every step that you'll need to accomplish in order to get your project deployed up on netlify and have an Associated repository on GitHub but once you go through all of these steps as you'll see at the end of this lesson it is dead simple to update your app and have that change automatically deploy to netlify so the idea behind continuous deployment is that as you make changes to your code you will push those changes to GitHub which is an online place to hold your code and when you push something to GitHub it will automatically deploy to netlify and netlify being a web host makes it so that people around the world can access your website from their browser in the end the idea is we will be able to have an actual URL that you could send to a friend family member or post in a tweet and that person could go see the actual site that you have built in deploy again this will happen in three easy steps first we're going to push our project up to GitHub then we're going to tell netlify which GitHub repository we want it to deploy and it will automatically watch for changes to that repository and the truth is it's only two steps then you're done now there's a few things we need to take care of before we begin and actually I'm going to walk us through creating a netlify account so in reality you just need to make sure that you have a GitHub account and that you install GitHub desktop there's a bunch of different ways to use git and GitHub of course I've found that for somebody first learning git and GitHub it's easiest just to use GitHub desktop if you are already familiar with using git then you don't have to do that at all you can use command line git or whatever method you feel like using so before moving on ensure that you have a GitHub account make sure that you have GitHub desktop installed or you are already familiar with how you're going to push your code up to GitHub so for creating a netify account you can click netlify account here and that will take you to the account page or you can even click this logo here and you'll go through the steps of setting up an account just like you would anywhere else it'll ask for your email and password you can hit sign up that should send you a verification email you'll go and you'll click that link clicking that link will take you to a sort of getting started page for me I chose that this would be primarily used as a personal account and I identified myself as a hobby developer I don't think it matters much what you say your first project will be I just put a personal portfolio site and for naming your team because this is a completely personal account I just put my own first name as my team name then I hit setup and continue we get to this page for now I'm going to skip this step because we're going to come back to this later that said if you're already familiar with Git and GitHub and you've already pushed your code to GitHub then you can skip the next number of slides and at this point just say that you're going to import an existing project for the sake of completeness I'm going to go through those steps and just skip this part for now so that brings us over to GitHub desktop I'm going to open GitHub desktop and in the upper left I see a drop down for adding a new repository and I'm going to create a new repository clicking create new repository will bring up a modal I can give it a repository name everything else I'm just going to leave the same and for now I'm going to put it on my desktop but I would recommend organizing it somewhere that you actually want to keep it then click create repository that will bring you to the main page for your repository that you just created and next we need to actually put some files inside of this folder now depending on how you're following along this next step will look a little bit different for you I'm going to show you how you could do it directly from scrimba in the current scrimba interface there's a little gear icon in the lower right that you can click and choose download as zip and in fact you can do that right from the scrim here it basically has everything that we just saw where we left off in the last lesson do be aware that in the future as the scrimp interface changes the location for this option to download the project as a zip may change so just search around until you can find the option to download this project as a zip now that will create a zip file you'll have to unzip it which will have a folder with your project files in it and because we've already created a new folder that is a git repository I've found that the simplest thing is just to take all of the files from the project that we just downloaded from scrimba and drag them over to the new folder that we just created with GitHub desktop then you can take that van life folder and open it in vs code now this next step is going to be pretty important we haven't yet run an npm install on this project as you can see we don't have a folder called node modules but it's pretty imperative that we don't commit our node modules along with a few other things that are really good to never commit to your GitHub repository so I would highly recommend at this point immediately before doing anything else to create a DOT get ignore file in this file each line will contain a folder or a file or some kind of naming structure that you are telling Git You don't want to ever include in any commits that you make if that doesn't make a lot of sense that's okay just know that it's important to have a DOT git ignore file and to include at least a few basic items now if you were just following along and you downloaded this project I did create a DOT get ignore file already mostly so that anybody who isn't downloading this can actually come in here and copy the items that I have listed here and paste them into your dot get ignore file that you just created I also made this a little bit larger so it's a bit easier to see now that we've made a change to our project we can go over to GitHub desktop and we will see that it is already tracking the changes that we've made including dragging all those new files over and creating a new git ignore file manually so let's go ahead and commit these changes we can do that by adding a summary down here in the lower left I'm just saying adding files and git ignore and then I can say I want to commit these changes to the main branch so I can click that button and after a few seconds that will be done if you're relatively new to git and GitHub it might be important to note at this point that you have only committed to your local git repository but you have not yet pushed anything up to your online GitHub account so that's what this published repository button is for we'll go ahead and click this at this time we'll get a modal here it should already have a name filled out you don't necessarily need to change anything else unless you feel like adding a description or making this a private repository and you can click publish repository and once that is done it will send us back here to the GitHub desktop dashboard at this point you can click the button to view on GitHub which will show you that your code is now live online the stock readme that we get from scrimpa is a little bit ugly but that's okay for now okay now that our project is live up on GitHub we are primed to go back to netlify and sync up our repository with our netlify account so back on netlify we are greeted with this dashboard page and we can click this button down here that says we want to import an existing project from git when you click that button it will ask you to connect your git provider in our case we're using GitHub so I'll click the GitHub link which will send me to an oauth page where I can authorize netlify to access information on my GitHub page and when I do that I'll have the ability to search through my entire list of repositories I've here searched for Van Dash life that pulled up my new van life repository so I'll select that repository doing that netlify will try to figure out the best way that it can deploy this project and it usually does a pretty good job so for me I was able to keep all of the stock options here exactly the way that they were the most important thing is that we run npm run build as the build command and that the publish directory is dist unless you have gone out of your way to change the Veet config settings for the package.json so that this is different so this is what popped up for me I'm just going to keep it that way and hit deploy site doing that sends me back to a dashboard page for this specific site and we can see that it says it's building a new production build after a pretty short wait we'll see that board building change to published and at this point it's just chosen a random URL which is going to be good enough for us for now that we can click on and see our site live on the web super cool now oops it does look like we have a little bit of an issue here on scrimba of course we pretty much develop everything as a mobile style but even when I turn on the mobile view in my developer tools we can see that the styles are not really looking like a mobile styled site to be honest this is something I almost always forget to include when I'm spinning up a new project completely from scratch and that is to include this line of code which is a viewport meta tag so the reason I'm showing you this process is not because I actually forgot to do this but because because I want to show you how once you have deployed your site live you can make changes and update the live version really really easily this is where the benefits of having continuous deployment setup really shine now if you are actually following along and you want to add this line of code you can actually click this screenshot it will take you to a page on mdn which has a quick way to copy this line of code and you can paste it into your index.html page right below the start of the head tag like I did here now once I paste this in we can go back to GitHub desktop and see that it is tracking some changes here I think my formatter might have changed the way that things were lining up which is why it's showing a little bit more green than what we actually added and just like before I can add a little summary up here if I want I can also add a description and hit commit to main again this is only committing to my local repository and doesn't automatically make changes to my GitHub repository in order to do that I do need to remember to push these changes this commit up to my origin which is the Repository that lives on GitHub and from GitHub desktop I can do that by just clicking push origin then without doing anything else I can go over to netlify and see that it has noticed a new commit to my main branch on my GitHub repository and so it starts rebuilding my site and after a few seconds again it will have a new published site that includes my changes awesome so again the process for updating the deployed site in just three easy steps one we change our code to we commit and push those changes to GitHub again it's just two steps that's how simple it is now that you have a live site that you could share with family and friends I'd recommend jumping in both feet with the build in public mentality if you have a Twitter account you can click this screenshot which will prepopulate a tweet that you could send out to the world and really show off the work that you're doing on your projects of course make sure to add your actual Netflix link here at the bottom one last important thing to mention is that even though you've downloaded your code code to your local machine and push it up to GitHub it will still be pretty important for you to follow here on scrimba scrimba isn't intended to be the ultimate place that your code lives you're not going to open scrimba in order to write production level code for example but for the sake of learning scrimbab makes a lot of other things easier it lowers the barrier to get your hands on the keyboard and follow along so in the future when we talk about deployment again we'll cover the steps on how to update the code that you just downloaded to your local machine so that you can deploy the most updated stuff but for the best learning experience just remember to keep following the course here on scrimba okay that's everything we have to touch on right now for continuous deployment using netlifice so let's keep pushing forward and building our van Life app in these upcoming sections we are going to be working on a Vans list page and a van detail page and as you can see there's some data here that needs to be coming from somewhere in the past what I've done is created just a simple data.js file and kind of pushed all the data in there but that meant that we were just importing that file instead of actually doing a fetch request to a server and a database like you would in the real world however I also didn't want to create a real server and database just because of the maintenance problems that can happen Over time however I found a solution that I think will be a really good compromise and we're going to try it out in this project there's an npm package called mirage.js you can click on the screenshot here to go to their website if you want to learn more about it and it's a way to create a mock server that will intercept any API requests you make and it will return the data from your mock server instead of having to worry about reaching out to the real world this isn't something you have to worry about but if you want to look in this server.js file that I I created you can see there's the data for our vans and down here at the bottom there's a simple routes section which you can think of like the server code that will run whenever you make a request to slash fans or to slash Vans slash the ID number of the van again this doesn't have to make sense in fact you can think of it more like you are the frontend developer on this project and a backend developer one of your coworkers has already created the server and some endpoints for you to get data from what's nice about this is I don't have to pollute my code too much the only thing I need to do is say import server so import dot slash server and everything else will work out just fine we'll get to see this in action in a little bit but I just wanted to show you what I'm doing there with server.js so that didn't become confusing okay that sets us up perfectly to Now work on our vans page so that's what we'll do next okay the next thing we're going to do is create the Vans list page and this won't really require you to do anything that you haven't learned yet so I'm going to make this into a twopart challenge the first part is going to help you practice creating a new route modifying the header creating a new page and the second part is going to require you to use a fetch request to get some data and use a map method to map over the data all of this is kind of the introductory level react stuff that you should already know by now but let's not get too far ahead of ourselves let's start with part one again your challenge is to create the Vans list page that's going to be over in the Pages directory the route which is what will happen down here and a link in the header so that you can actually navigate to it now even though this is something that you have done recently I really want you to practice this before just skipping ahead and watching me do it however if you get stuck of course we will be going over this together so pause now and work on this challenge let's start by creating the page so I'll create a new file called vans.jsx and we'll just do some of the regular setup stuff nothing fancy quite yet we're going to get to that in the next challenge then over here we need to import the Vans page we'll create a new route so I'll just duplicate this line and change this to Vans and this will render the Vans element and then we will link to vans so this will lead to slash fans bands and I think that should be it let's hit save okay we have our vans here and if we click it man's page goes here awesome now comes the fun part in the next challenge we are going to actually pull in our data so that we can display the actual Vans and the van information however before plowing ahead if you did struggle with this challenge then just revert back to the beginning of this video and try it again if you're confused about these parts then it will be more important that you kind of drill them in before you just pow ahead okay getting off my soapbox let's work on part two of The Challenge okay this is the fun part of the challenge this Vans page goes here is nice and all but we want to get the actual van showing up on the page as per usual you can click the design screenshots here to send you to the figma design in case you feel like spending the time to actually put the CSS together yourself but like I did before I'm not going to necessarily make you do that I'm just going to do a magic snap of my fingers and we'll have the design already implemented for us so your challenge is written out here you're going to use the fetch API from the web and you're going to fetch API slash Vans let me put some quotes here just to make sure that that's clear that that's a string you're going to use the fetch API and you're going to fetch to slash API slash fans this might look a little strange if you're used to only doing your fetch requests to another server or another URL somewhere because usually you have something like https colon slash example.com API slash fans but when you're fetching something on the same domain as what your site is running on then usually you only have to provide the relative path now remember we have our kind of fake server running here with mirage.js and you can see it says this dot namespace is API that means that all the requests are going to start with Slash API and then this function here is going to handle a get request to the slash API slash Vans endpoint and all it does is return all the Vans again you don't need to understand this this is not an important part for this course but sometimes it's nice to poke around and see an inside look and hopefully that helps make sense of why this URL or what it doesn't really look like URL but why this URL looks a little unique so you'll kick off that request you'll need to parse that Json and turn it into Data you need to think about what react hook you would want to use to fetch the data as soon as the page loads and how you would make it so that it only fetches it the one time and actually you know what number three is no longer an issue so I'm just going to get rid of that now parts of this challenge are going to require you to have prior knowledge in things like how to use the fetch API and where in react you can kick off a request when the component mounts if you're feeling a little rusty on that that's completely okay I've tried to include a couple helpful resources here this is a link to the fetching data in react scrim that I taught in my introductory course and the second one is how to take an array and to map over it using the dot map method and then how to actually display each of those as elements on the page so feel free to check out those resources brush up on some of those topics before trying to start this challenge here okay I think I've given you everything you need again if you don't necessarily feel like doing the CSS to make it all beautiful I'm actually okay with that this time just try to get each of the pieces of data displayed and if CSS is something that you feel Rusty on or you want a little more practice with then I would encourage you to do it okay enough of me talking pause now and work on this challenge I think I'm actually going to do these in backwards order I'm going to start with number two and the answer to this question is to use the use effect hook in react now the truth is and this is something we're going to explore later on down the road or possibly in a different course there's a bit of a movement away from trying to do your fetch requests for the data of a component in a use effect hook but for now let's go ahead and use a react.use effect this takes two parameters the first one is a function and the second parameter is an array of dependencies in this case we have no dependencies but it's important that I put this array here otherwise our effect will run every single time any State updates on our page at all inside the body of our function we will kick off our fetch request so I'm going to say fetch slash API Vans and again what our server is going to do this fake server it's going to intercept this fetch request instead of trying to actually make a fetch request out to some endpoint probably here on scrima.com it's going to intercept it and give back fake data this fetch function it returns a promise and so I'm going to unpack that promise which will come with a response and we'll turn that into a JavaScript object or just regular JavaScript by taking the Json part out of it that returns a promise so we will resolve that promise as well and that is where we will finally have access to our data I usually just like to console log our data for one just to make sure things are working we haven't made any mistakes along the way but also to see the structure of the data so we know what it's going to look like how we're going to access all the pieces of it so let's hit save and okay well we got something console logging looks like it's an object with a Vans property now in this case because we're choosing to kick off our request inside of a use effect and we're only kicking that request off one time when the component first mounts we need a place to save the data that we're pulling in just so that if anything were to change and this component got rerendered the data wouldn't just disappear and you might remember that state is a place where data can survive the rerender cycle of a component so we're going to create some State let's call it maybe Vans and set Vans is react.use State I'll start this as an empty array and then instead of console logging our data we will use set Vans and we don't really care what it used to be so I don't need the Callback function I'm just going to set it to data and then remember there's a property called dot Vans that's the one that actually has the array that we want so if I console log Vans we'll hit save and first we get an empty array that happens when the state is set as an empty rate in the beginning and then it turns into our array of Van information from our fake server awesome actually you know what while we have this still console logging I'm going to grab one of the objects of our vans just so we know what properties it has let me get rid of our challenge text instead I'm going to put in the properties of our van okay so our van has an ID a name a price a description an image URL and a type so I'm going to turn our array of raw data into an array of elements that we can display on the Page by using the map methods so maybe I'll call this van elements is equal to vans.map and for each van we are going to render and you know what this is where normally we would just start creating one van element that we want to show on the page so one of these little sections here for the sake of time I'm going to paste in what I've already created since it won't provide a whole lot to this lesson or challenge to have you watch me go through each little piece like that okay so what you can see is just a div that has the elements that we see in the tile of one of these Vans and since we're doing a map it will end up being a tile for each one of the the vans in our database and there's a couple class names that are not here yet let's actually put van elements onto our page first and then we will fix the CSS so instead of our H1 that says Vans page goes here we'll have in fact let's use a fragment just because we don't need to necessarily add a bunch of more elements and we will just put our van elements here and let's see where we end up okay well that's a huge picture but we've got our picture and it's got the name of the van the price and this is the style or rather the type I think is what it was called yeah type is simple and okay we have our vans awesome let me go ahead and just use the magic of editing to make this look a little nicer and just like that our CSS is applied I had forgotten that we wanted a list container and then we have our list itself just for styling purposes so I got rid of our fragment and actually put in a div so that it could have a class name and actually we're missing something from the well we're missing a few things from the design but one that's really easy right now is this looks like maybe an H1 that says explore our van options so I'm gonna stuff that just right inside of our tile here we'll have our H1 that says explore our van options to hit save okay cool a little step closer we still have some other work to do like these buttons the footer and so forth but we'll get to that okay man that was a lot of work but hopefully this is mostly just review from previous lessons that you have learned about react but this does lead us to what we're going to learn next and that has to do with nested routes because what I want to have happen is I want each one of these tiles to be clickable basically anywhere on this tile and I want clicking each one of these tiles to take me to a nested route so it will be slash Vans slash and in our case we're going to keep it simple and just use the ID of the van so slash one will send us to a detail page of this modest Explorer man because that's the one with the idea of one slash two would take us to a detail page of the beach bum van and so forth there's a couple fun considerations to keep in mind when we're going to do that so that is what we're going to tackle next everything we've learned so far about react router you could say is like the meat of react router what with the browser router the routes these individual routes that we have and the link that allows you to navigate between one and the other everything else that we'll learn is sort of the I guess you could call it the vegetables of this plate they're really going to round out our experience and they're going to allow us to do some pretty cool things with react router we'll spend the next couple lessons learning about nested routes but to do that we're going to first see maybe the harder way to do this so in order for us to understand nested routes we're first going to learn about parameters or route params now we know that we have our van list page here and the list page is showing us all of our vans we want to be able to click on one of them and be navigated to a detail page for the specific van that we clicked on you can see in the design here we have the list page clicking on one of them sends us to the detail page and in our case we decided we want this detail page to have a route of Slash Vans slash Flash and then the ID number of the van but we don't want to go through and create a new route for every one of the vans in our data and have something like slash Vans slash and then slash one slash two slash three slash four we wouldn't want to manually create that because well it's just not maintainable if we were to add more Vans to our list then we wouldn't also want to have to come in here and create new routes create separate elements and so forth so this is where route params come in when we're defining our routes let me get rid of all these extra ones when we're defining our routes I'm going to copy this one just as a starting point and then instead of saying slash Vans slash and then a specific dedicated ID number or some other kind of text we're going to use a colon and then we're going to give it sort of a variable name in this case let's call it ID we get to choose whatever we want but let's call it ID because we will put the ID of the van in this spot because the colon sort of turns this into a variable it means that we can reuse this one route definition for every detail page that we want to create no matter what the ID is going to be now we need to change Vans because this right now is just leading us to the same Vans list page so instead we're going to create a van detail page so I'll Whip that together really fast we'll go to Pages create a new file call it van detail.jsx and I'll just set this up really quick okay like we did before just an H1 that says the van detail page goes here we will go back to our index page import it and instead of rendering the Vans here we will render band detail and we don't have a link yet to send us there so let me hit refresh and I'll just start by typing in in the URL slash one and hit enter and cool that sent us to the van detail page now we'll notice that this doesn't say anything about one it just says colon ID so I could change this to slash 42 even though we don't really have a van with an idea 42 I could change this to whatever I want and hit enter and it really doesn't care the colon is just saying there's going to be something here I don't know what it is but it's going to be something so there's two more things that we need to hook together in order for this to work the first is from my Vans page I want to have each of these Vans send the user when it gets clicked to slash Vans slash and then the ID of that specific van and then in the van detail page we want some way that we can access the ID that is in the URL after slash vans in that way from the van detail page we can grab whatever the ID is from the URL make a get request to our server to grab the detailed information for that one specific van and then go through the process of displaying the detailed information for that one specific van like you see here really I think the only information missing from the list page is this description down here but still for now what we'll do is whole extra get request to get the detailed information for this van so for the sake of breaking this up a little bit let's tackle those two different parts in separate scrims so that's what we'll start with next the first part of this involves a challenge that you should already be able to complete without learning anything new each one of our vans is listed in what we're calling a van tile here on this div and we want to make it so that if the user clicks anywhere at all within the contents of this div that they'll be sent to the Vans slash and then the ID of the van so your challenge is to wrap all of the contents of this div in a link from react router Dom and have it send the user to that page you'll know that you've completed it when it sends them to that then detail page goes here page so pause now and work on this challenge okay first we need to import link from react router Dom and then we will just wrap everything in a link we'll indent that and then the last thing is we need to send them to and I'm going to use string interpolation here so I can say slash bands slash and then because we're inside of the loop where we're mapping over the Vans we have access to each individual van and we'll say van dot ID okay let's hit save let's click on reliable red and of course it really doesn't matter but we can see in the URL in the mini browser that it sent us to slash Vans slash three because reliable red had an ID of three we can go back to Beach Bum which should be two and there it is now of course this van detail page is not very descriptive it's not really doing anything important next we need to make it so that the detail page can grab information about that specific van that they clicked on so we can display everything we need to display here to do that we need to learn about something called use params so that's what we'll learn next let's take a second to look back at what we've done just as a reminder before we move on in our app component where we have our route definitions we created a route that has a parameter as part of its path that's identified by the colon in front of this part of the path by putting a colon here it tells react router that this isn't going to be the literal text colon ID but instead there's going to be something here in its place I like to think of it as a variable inside of our path so whenever slash Vans slash anything is in the URL then it will load the van detail element here then we set it up so that in our vans page we link to the slash Vans slash and then whatever the ID of that specific van that we clicked on in the Vans Page by doing that it takes us over to slash Vans slash two in this case because we clicked the van with the ID of two and our next task is to make it so that in the van detail page it's able to grab the two out of the URL and then go and get the specific information about this one van that we're supposed to be looking at there's a bunch of different ways that we could do this and we're going to see some optimization that we can do for example right now if we go to the Vans page you'll see it delays for a second because it's doing another fetch request going to get all of the van information so really we should be caching that somewhere so that we can get that information much quicker and then there's probably a better way that we can handle getting the detail information rather than always doing another get request since we have all the information when we get all the vans in the first place the point is there's a lot of different ways to organize things to make it have better performance but for the sake of focusing on our learning with react router we're going to keep it simple react router provides us a tool called use params which allows us to grab any of the parameters that we have in our URL and that's a tool we will need to import so I'm going to import use params from react router Dom and inside the body of my component I'm going to grab the params so we'll call it const params equals and then we'll call use params and let's go ahead and just console log the params this function will run whenever the van detail component is mounted so I'll open up the console we'll hit save and cool we see that we get an object that has an ID property I want you to pause and think for a second where did ID come from remember over in our index.js after the colon we put this colon ID react router will look at any sections of the path that have a colon before it and it will add that as the key in the key value pair in the object that we get from use params so if I were to change ID to blah blah and hit save we'll see that now our object has a key of blah blah that's too silly let's go back to ID also it's important to note that the reason that react router chose an object instead of just giving you the value of what's there because you can have multiple params there's nothing stopping me from using slash Vans slash ID slash rent maybe like a rent page that's nested inside of the detail page now if I do this my URL currently isn't going to match anymore so I need to update it we'll say slash van one slash rent one really quick side note is there's nothing stopping us from having multiple params inside of our URL so I could after slash colon ID I could add another slash and say colon I don't know maybe type and when I hit save of course this path that we currently see isn't going to match anything on here so it's going to disappear but let's say we add to our URL slash rugged and hit enter and now we can see the van detail Pages back up because this path is now matching again and also the params that we're pulling in the van detail page and we're console logging over here is now including both vid and the type parameter for our needs we won't be needing multiple parameters but I just wanted to make that clear so let's go back we'll go to well let's hit save we'll go to Vans go back to our vans we'll do number two this time and cool our parameters are coming through as we saw before and now I think it's a good time to get your hands on the keyboard instead of building a whole separate app to have you get practice with this I'm actually just going to delete what we've done and have you do it from scratch so I will write up part one of this twopart challenge that we're going to video okay this will test if you were paying attention of course you can rewind to see exactly what it looks like but I want you to be the one who's writing this out so I want you to reroute what we did and I want you to console log the params object like we still see in the console from before in fact I'll hit save and that'll disappear and now it's your turn pause and work on this challenge so we need to First import the use params Hook from react router Dom and then we will grab the params object by calling use params and then simply console log params and that needs to be lowercase hit save and there we are back to where we were okay so now we're ready for part two and this lesson is getting a little bit long so we are going to do part two in the next scrim okay so in part two of The Challenge I want you to make a fetch request to get the data for the van that we're looking at on the van detail page based on the params.id that comes in we're using the mirage.js server fake server again to get the data and the endpoint you will make a fetch request to is slash API slash Vans slash and then the ID that comes from params in this case I'm just making this as a comment van ID has no significant meaning or anything I'm just saying that the ID of the van needs to go at this point in the URL for now you can just console log the data we won't be worrying about designing up the page I'm just going to give you all of the markup that I use for that okay pause now and work on this challenge okay let's get ourselves some room by closing the console and like we've done before we're going to use react.use effect to make a request when this component first loads so let's go ahead and do that maybe down here below this text we'll do react dot use effect the first parameter is the function the effect function that we want to run the second parameter is the array of dependencies now before what we did was we used an empty array of dependencies and that's because well the fetch request didn't rely on any other external piece of data to stay in sync with what we currently want to fetch however this time around we do want to rerun our effect if somehow this component were still loaded but the params ID were to change in our case this probably isn't going to happen the only way I can really think of this happening is if we had some link on this van detail page that linked to another van detail page in which case what would happen is the ID would change but but the component would not unmount and remount it would just rerun the function with a new params.id I suppose down the road maybe some feature that says here's some vans that are similar to the one that you're looking at could be implemented in which case this would make a difference if we left this as an empty array it would not refetch when we moved to another van like van 3 instead of Van slash two it wouldn't run the effect therefore it wouldn't run the Fetch and therefore the page wouldn't change that's not a feature we're worried about now but since we know it could happen we might as well put it in here so I'm going to say I want you to rerun this effect if params.id were to ever change okay so then we'll do our fetch request and we're fetching out to slash Vans no slash API slash Vans slash and then the van ID which we're getting from params.id so I'm going to use some string interpolation here and we'll say params.id then we will get the response and parse the Json out of it click this res dot Json that returns a promise that we will also resolve that will have the data and let's just console log our data and at this point I'll get rid of this console log and let's get rid of all the challenge text here just to clean things up a little bit we'll hit save and check our console okay it took a second because it's doing a fetch request going out to the quote unquote database but it pulled in the van with the ID of two in this case we can see that there's this object that has a Vans property and that's the only thing in here and the only thing we care about and awesome it has everything that we need at this point all of the next steps to get this page up and running actually looking good with the data that we need is really something that you should be very familiar with by now so once again I'm going to snap my fingers really all the changes that I made are instead of console logging the data I set that data into some localized State you can see we used data.vans because we had that Vans property in the data that was coming in up here we're initializing that state the rest of it is mostly just some markup you can see there's a little bit of conditional rendering happening here because we're initializing our van State as null if I try to access things like the image URL on null then that's going to be a problem so what I did was conditionally render if there's a van then I rendered all the markup and if there isn't a van then we just have this H2 that says loading when I refresh the page you can see it briefly it'll say loading and then it'll show the data everything else is really just some styling there's nothing too special here clicking the button at the bottom doesn't actually do anything but what's awesome about this is because we're using a dynamic parameter in the path we can go back to Vans we can click the modest Explorer and it's going to load the the data from the van with the ID of one we can go back to Vans and choose something like reliable red and we have net data as a separate piece of data so once again as a quick recap over in index we created a route parameter that was Dynamic by using the colon and part of the path that we have for our route definition by using that colon we're setting it up so that react router will save whatever value gets put in the URL when this page loads into a variable called ID in the Vans page we are linking to slash Vans slash and then the ID of that van it's important that that matches up because when we come to the van detail page which we're coming there because the element is set to go to the van detail page when we get to the van detail page the very first thing we do is grab the parameters from the URL so that we can make a fetch request to then get the van with that specific ID again we could definitely increase the performance of this app for example over here instead of doing a fetch request every time this component loads or or the Vans component loads we could probably save that maybe in local storage or do some kind of caching so that it can not have to make a request across the internet first but can just check our local cache and then because this data that's coming in has all of the information for each van we could theoretically just grab the piece of data that we need based on the URL instead of making a whole extra fetch request like we're doing in our van detail page but at this point with us learning react router that's not really our intent here is to make this a very performant app and just like that we have a majority of our app built at least the skeleton is all there there's a few little details that we still need to fill in so that's what we'll start working on next as always though if there's anything that was confusing about this Challenge Series that we just completed I don't want you to push forward I want you to go back I want you to practice practice practice what we've done that's going to be what helps you internalize what we've learned If This Were School you might be cramming for a test just so you could pass the test and move on but this isn't school I want you to actually learn the stuff of course it's always okay to use whatever resources you have using Google is something that even the most senior developers do every single day but getting the muscle memory by practicing this is what's going to help you truly deeply understand what's going on at least well enough to start building your own projects so spend as much time as you need reach out to the scrimba community and ask any questions that you might have and then once you feel confident with the things that we've been learning let's move on and we'll start learning some of the nuances about react router let's run through a quick quiz on Route parameters just to make sure that you are understanding everything we've been talking about again I'll remind you that this isn't school I'm not going to be giving you a grade on this it will have no effect on how you do in this course really this quiz is a tool for you to assess your own understanding of what you've done as such I recommend you don't just skip ahead if you were to struggle with any of the questions here but rather to maybe open a separate tab review the lesson that's associated with each of these questions and then come back and see if you can answer them for yourself skipping ahead and just watching me answer it will maybe help you understand it a little better but the understanding will be so much stronger if you're able to answer it by yourself okay that's enough of a guilt trip now with these quizzes on scrimba I do expect that you pause the screencast just like we do with any other Challenge and physically type your answer down I know when you hit play it's just going to erase your answers but that's not the point the point is to have that muscle memory that's included when you actually type on your keyboard it will really help you retain the amp answers that you're writing down okay pause now and work on answering the quiz questions okay number one what is a route or sometimes called a URL parameter in our route definitions we are able to tell it exactly what we want the URL to say when a certain component is loaded or more accurately when a certain element is loaded however it's pretty common for us to not know ahead of time as the creators or the developers of these route definitions what the actual URL will be this is most common when you have some kind of detail page that displays specific information for one specific item in a whole group of items that sounds super specific but if you think of basically any web app that you've been to there's probably something like this for example any blog will probably have something like a slash blog route but then after that you might want the detail for a specific blog entry in which case it would be slash blog slash and then probably some kind of slug of the title of the blog why I love react router for example the second portion would be a route param instead of copying and pasting our route pads a billion times every time we want to add a new blog entry instead we can create a parameter inside of our route path that makes it a sort of placeholder for any part of the path that might be put in there so let me try to summarize that in an answer here this sounds a bit wordy but I landed on a portion of our route path that is just a placeholder for what will eventually be the actual segment in the URL of the page so let me clean this up I'm already bleeding over into number two here and let's work on number two we need to add a route parameter called product ID I'm going to copy that to the path below we have a path that says slash products but we are going to add a slash representing a new segment of our URL and then instead of just putting product ID I'm going to put a colon in front of product ID if I just had product ID then it would be the literal Text slash product slash product ID with no deviation whatsoever in this however with the colon it says by the way this is just a placeholder for some other text that will actually be the segment in the URL of our page okay and then for number three we need to add some code below so that we can actually display whatever product ID gets put in the URL when it's displaying our product detail component in this case we would need to First import use params from react router Dom and then we can grab the specific parameter that we want in our case there's going to be the one called product ID and that will equal a call to use params and now with product ID in tow we could say something like product ID is and then stick in our product ID okay since this is just a markdown file we can't really save this and double check that it works but I feel pretty confident with my syntax here and more important than the specific syntax is an understanding of the concepts behind it once again if you feel like you need to review these things then now is the time to do that before we plow ahead and when you are ready we'll keep moving forward we are about to dive into what at least for me was one of the more complex topics about react router but that's okay we're going to walk through it very much step by step and hopefully we can get to the end and you'll just completely understand it perfectly and that topic is nested routes when we're talking about nested routes we're oftentimes talking about actually a couple different things first of all we're talking about nesting pieces of the URL so for example we've already seen something like this we have the slash van route and a nested route that we have is the slash van slash and then the ID or the name of the van or whatever it is you want to be in the URL but the URL is only a part of the story because when we're talking about nested routes we're also talking about some shared user interface or parts of your page that need to remain on the page when you transition from one route to a child route or a nested route and that might happen more than you think with the example with the slash van and the slash van ID over here we're are not doing much of that because if I come to Vans I mean we're sharing our navigation bar across the entire site but slash Vans doesn't really have any shared UI with its child route of Slash Vans slash and then the ID of the van slash van one even that little explore our van options wasn't part of this next page and so this page isn't really sharing any user interface but oftentimes you will want to do that a really great visualization of this is over on the remix website I included a link here if you wanted to see the live demo of this and the reason it's over on remix is because react router is actually now a part of the remix package remix is just a full stack framework for the web it uses react right now on the front end although I think in the future they'll be supporting whatever frontend framework you want to use but a major part of remix is the way that it handles routes so here we see an example app they call it fake books and we'll notice a few different things first of all we're inside of a nested route here we have exam sample.com sales slash invoices and then slash the number of one of the invoices and if we break this down you'll see that example.com is rendering everything that you see on the page that includes the navigation bar over here on the left the logo everything else as you might expect as you navigate with this navigation bar on the left it will probably go to example.com maybe dashboard slash accounts we happen to be here at slash sales and so that's the next part of our URL sales now we still have some shared UI here because we are maintaining the navigation bar on the left the slash sales part of this URL is going to render everything else that you see here in this teal color now here we have yet another navigation bar inside the sales portion of our website we have an overview of our sales subscriptions invoices customers and deposits again presumably if we click on overview well that might just be the slash sales endpoint by itself or maybe it's slash sales overview we click on subscriptions that's going to be slash sales subscriptions we're here at invoices so we have sales invoices this top portion is going to be a shared UI for those other routes so if we go to the next image we see that invoices is rendering this part down here but it's keeping everything from this kind of secondary navigation bar and then of course everything from the first navigation bar still exists too over here we have a list of invoices and presumably this is one of those invoices in fact it's the second one here so the last part of our URL which is the ID is going to be rendered in this little portion over here on the right so in this example we see not just a nesting of the portions of our URL but that Those portions of the URL are mapping to nested content on our site or another way to think of it is that there's quite a bit of shared user interface pieces on this site even if you navigate to another route so how do you actually create these nested routes well we know about the route component but up until now we've just been using it as a a selfclosing component if we look at the code that we've written so far let's go to our index page every one of our routes is closing itself nothing is being nested however we can use route as a nonselfclosing element or rather something that has an opening and a closing tag we're going to see exactly how that looks a little bit later but it's one of the most crucial capabilities of the route component that allows us to Nest our routes now we talked about there being a couple different reasons to do nested routing and I would like to propose that the primary reason that you would want to do it is whenever you want to keep some of the UI on your page but you also want to display more so you're linking to a new part of your website but maybe that new part of your website is really just changing one small part on the page or it could be a big part too the point is you have some things that you want to keep displaying kind of like we showed with the navigation bar or both of the navigation bars in that example but you also want to display some new stuff too another reason that you might want to do this is just so that you can avoid some repetition inside of your route definitions I put a little Caution sign here because sometimes that may end up being more work than it's really worth in the end for example over here we have a little bit of repetition where we're saying slash Vans and slash Vans slash colonid but as we mentioned we're really not sharing that much user interface actually we're not sharing any user interface between the Vans component and the van detail component and so in this case you could choose to Nest or you could choose not to Nest again we're going to see what that actually looks like in a different scrim but I wanted to lay the groundwork and say that the primary reason that I would suggest you actually consider nesting routes is when you have parts of your page that you want to keep but also that you want to display some more stuff to so this is really going to crack open our website because we have a lot of pages that we're going to build so that we can really practice with nested routing and hopefully really solidify our understanding of nested routing so let's take a quick look at what we will be adding to our site as of right now we are only can consumers of our van life site we can see the list of Vans we can see the details about one van we can click this button that does nothing to rent the van but on the other side of this equation are people who are renting out their vans so we are going to be adding an entire host section to our website hopefully it's not too small you'll see in the navigation bar we're adding a host link there and going to the host route is going to render a new navigation bar that we see here that navigation bar will have a dashboard which displays kind of a quick overview of the details the van host might want to know and also a list of the other information that the host would want to know like a detailed view of the income notice that it's also going to have this navigation bar that's going to be a shared user interface the reviews that their Vans are receiving again sharing the same user interface with that navigation bar and then we have this section for Vans now I'm keeping this separate because this is going to go even another level deep on the slash host slash Vans route we'll see a list of all the vans that this host is hosting on our van life website clicking on one of those vans will take you and again it's got the shared interface here by clicking on one of those is going to take you to a new page there's still some shared interface but this time we have yet another little navigation bar down here this allows the host of this van to see the details the pricing and the photos for this fan so the details will be kind of the default and when you go to the pricing it will have both of those shared user interfaces too and then some new information that displays same with the photos we'll have the photos of this van down here theoretically it would be where the host could then edit the photos so to get an overview of the routes that we'll be adding we will have the slash host route that's going to send us to the dashboard then we'll have slash host slash income slash hosts slash reviews and then we'll dive into the slash host slash Vans this is going to be the list page but then we have yet another level of nesting where we'll have slash host slash van slash the ID of the van that was clicked on in slash host slash vans and then yet again we'll go down to slash host slash fans slash ID and then slash pricing and slash photos so this one here where it just ends in slash ID that's going to sort of default to The Details page we also could choose to name this slash host slash fan slash ID slash details if we really wanted to but just making the executive decision to have that be the default view okay that is a lot we have a lot on our plates fortunately kind of like before because I really want to focus this course on react router and not necessarily on making a beautiful design I will do you the student a solid and I will Implement all of the styling and everything for you I know that's not usually my style but I do want to stay focused here on react router and of course that's not to say that you couldn't take the reins and actually design it yourself if that's what you want to practice so let's Center ourselves let's take some deep breaths if you need to and we will Jump Right In the first thing that I'd like to do to get our feet wet with this nested routing idea is to really fix what we have going on with our header right now we stuffed our header into our browser router just because it was outside of our routes which means that it will display on every page however this really doesn't feel clean to me in fact if we had a header that was more complex maybe it would take up 50 lines of code it feels like a weird place to just stuff it into our browser router like this I guess we could abstract it to a header component and then it would just say header but still it doesn't feel good to me to put something that's unrelated to our routes inside of our browser router like this so our introduction to nested routes is going to be through something called a layout route and I wanted to remind you that the primary reason we are nesting our routes is so that we can hit this second bullet point here when you want to keep displaying some information or some UI on the page but you also want to display more stuff that's exactly what we're doing with our navbar we're keeping our navbar on the page and I think our design has a footer too yeah we've got a footer that we haven't implemented yet but that would also be something that would just be on every page but we also want the changing of our URL to display other things as well so I added another slide to the end of this presentation let's bump forward a little bit this is an image taken from the documentation for react router it's specifically the spot that talks about layout routes you can click the image you see here to go to the documentation if you'd like you can read through this whole main concept section or at least parts of it or skim through it maybe it might be a little hard to grasp if you haven't done react router before but it honestly has great information there you might need to read it a couple times to make it stick so feel free to pause and go look at the documentation if you'd like but I'm going to be talking about these layout routes the idea of a layout route is that it doesn't have a path of its own per se but instead its purpose is to lay out your page we know that we want every one of our pages to have a header and a footer if you go to that documentation one of the things that they'll mention is how the concept of a route can be a little bit stretched I guess because in the case of a layout route you don't necessarily need to have a path if you look really closely it's a little bit small in this image but it says this is a bad example and it says danger basically don't do this what they talk about is how if I didn't want my header here inside my browser router but I did want to wrap all of my pages without using what we're about to talk about with layout routes I would have to do something like take my home component and maybe wrap it in a fragment or a div and then start stuffing in all my header code just right here and I would have to repeat that for every one of the elements that I want to have my header and I would have to do that with my footer as well this is obviously not a good example like it says in the documentation don't do this there's a much better way and that is by using a layout route so let me back this up to a reasonable spot now we do have a little bit of work before we throw the layout wrap together so I'm actually going to make a challenge I'm going to give you the chance to do this hard work for me and then we will actually implement the layout route in the next scrim so let me type up a challenge for you okay I'm sorry this is a bit administrative but I want you to create a new folder called components it's going to sit as a sibling to our assets and our Pages folders so not nested inside of them and in that components folder I want you to create two new component files layout.jsx and header.jsx and then you will simply move the header code here into the header.jsx file but I don't want you to necessarily go beyond that because we will actually not end up importing it here and using it at all inside of our index file so pause now and work on this challenge gosh you know I wish there were actually a way that I could just steal the code that you just wrote and use it in my recording here but alas that's not exactly how it works so I will be doing this work let's go ahead and create a new folder called components and inside I will create those two new files header and layout and then we will just steal our header from the index page we can actually just cut it we're going to lose our header for a little while so in the header we'll import react and we'll create our file or rather our function and we will return the header that we just copied all right let's hit refresh there and okay so yeah our header is gone which is a little bit inconvenient because we can't navigate our site anymore but that's okay we're going to fix that soon actually we're going to fix that now because we've done the administrative stuff we're ready to now just jump in and learn about how we can implement this layout component so that we don't have to repeat ourselves by putting the header on every one of the elements that we're rendering at every path okay so we mentioned how route is a selfclosing element but it also can be an element that wraps around other elements and in fact when the route component does take children it needs to be other route components as its children what I mean by that is if I want to create another route up here and I want it to wrap around other elements I can't just go ahead and start putting other things like an H1 in here it needs it to be other route components as its children so I'm going to move this closing tag down here I want it to envelop or wrap around every part of my website that I want to contain my navigation bar which is everything now assuming that you have dealt with react children before you might start recognizing this pattern this route component is going to essentially take whatever element we pass to it so I can say an element and this is where we're going to put our layout component and it's going to render the layout component and then it will also render whatever child route matches the URL that we're currently at let's fix some of the bugs we have here first of all we're not importing layout so let's go ahead and import layout from our components folder slash layout and then we need to actually create that so we will get that set up okay easy enough this is obviously just a placeholder now I'm going to hit save we're going to see what happens and then well yeah let's just do that I'm going to hit save okay it's done loading this is everything that our site is now displaying at slash fan2 or if I go to slash fans also the same thing now assuming you do have some experience using react children I want you to think why is it that this layout component has now completely taken over our app it's the only thing being rendered here if you'd like you can pause for a minute to think about that I wouldn't necessarily try to fix it quite yet because we haven't learned what we need to learn in order to fix it if we were doing something like this say creating a layout component or actually rendering the layout component ourselves and wrapping it around everything here like this then we would have access to our route components inside of our layout through the children prop however this isn't the right way to do it because react router is not going to be able to render correctly if we do that so when we have our layout as an element that we're passing to this route definition there's a special tool that react router has provided us so that we can render the layout but then also tell it exactly where to render whichever route we're currently matching on the URL for example we're at the slash Vans route right now so it should render the layout and then we want it to render the Vans component that we're rendering here the element that we're rendering here or the element that we're passing to this route here so let's go over to layout and the tool that we're going to use is a component from react router called Outlet foreign we have to spell it correctly so we'll import that from react router Dom and the outlet is basically our way to create a hole in whatever our component is where the matching route that is a child of the route that we're nesting here or the parent route like this the outlet creates a hole where the matching route can render this took me a long time to wrap my head around so don't feel bad if that doesn't make sense playing around with this is going to be the only way that it makes sense if it didn't already let's actually implement it and then we'll go over it once again so right now I'm just rendering this H1 let's um maybe put some fragments around this just so we can actually render two things and below my H1 I'm going to render the outlet as a component so now I want you to think when I hit save what is going to happen well when I hit save I should get my H1 just like it is but then I should also get the content that is supposed to display at slash fans and sure enough there we go so this is the layout route H1 up here is replacing our header so we're going to fix that in just a second but now we have the rest of the slash Vans page rendering below so let's look at that once again because we are nesting these routes inside of this parent route react router is going to notice that this route doesn't have a path so it's always going to match whatever URL we're currently at and it's going to render our layout component so when it renders our layout component if we don't have some way to tell it where to put the rest of the matching child routes like we have currently slash vans so this route path is going to match and we want to render this Vans element we need to tell react router inside the layout component where that Vans component should go just like the children prop Works in react children where we get to tell it where the children should be rendered so I want you to think what is going to happen if I were to switch these two I put the outlet on top and my H1 on bottom you can pause if you want to think through it or if you want to run it and actually see what it does well if I tell it that the content should be rendered first and then the H1 second I'll hit save we'll see that my content is first and way down at the bottom we get our this is the layout route H1 okay now it's your time to shine let's do a challenge I'll be a little bit vague I want you to get the header working again you'll know that it works when you can go to the top of the page you'll see our header and you can actually navigate between the pages again pause now and fix our header well everything should be set up for us I'm going to move this Outlet to the bottom and then instead of using an H1 I'm going to Simply import our header from and let's see it's inside the same folder so I can just say dot slash header and then I can render the header component and let's get rid of this challenge text we'll cross our fingers and hit save ah so close over in our header we're using the link component in a few places and I forgot to import that some of you were probably shouting at me about that and I apologize so react router Dom okay let's hit save again awesome I'm currently at the Vans page we see the list of Vans I can go into the van's detail page go back to Vans about the van lamp home page now I know we're not working on nested routes in the URL per se quite yet but we are definitely going to get there I think this is a great way to introduce the concept of nested routes and most importantly understanding how this Outlet works if it didn't totally make sense that's okay we're going to get a lot of practice with it but I've been blabbing on for a while we've done a lot of good work here we've got that ugly nav bar pulled out of our browser router the nephr wasn't ugly but it felt ugly to have it here in the browser router now if for some reason I didn't want let's say the about page to have access to the same navigation bar and I wanted it to be completely different I would need to move it outside of the children of this layout route so that would just have to move down here and then I hit save everything's working but when I go to about we lose our navigation bar hopefully that jives with your understanding of what we've been doing so far let's put it back in there so we can actually navigate back okay with that under our belts we're going to be bootstrapping out all of the host pages and remember there's a lot of different cool shared user interface things that we're going to have to deal with with nesting so we will get lots of practice with what we've talked about here so when you're ready that's what we'll start working on next okay before we can dive into actually doing the nesting that we want to do we're going to bootstrap out some of the pages that we need and so that's going to be one of your first tasks first of all I want you to add a host link to the navbar it should be before the about Advanced just over here to the left and when it gets clicked it should take you to the slash host path and of course that won't happen until we set up the rest of this but I want you to also create the following components that we see here dashboard income and reviews I've organized things a little bit I moved our van detail and vans pages into a dedicated fans folder and so I've also created this host folder currently it's empty and so you'll need to add these components there I've also included the routes here just in case you wanted a quick reference to them I also pulled up the slide here in case for some reason this is better for visualizing it and keep in mind I don't need you to build the pages right now I just want you to have maybe an H1 that says like host dashboard here and then once you have those components ready you'll need to import them and you'll set up the routes for each of the those now because we're just bootstrapping things I don't want you to worry yet about doing any kind of nesting you can just put everything as additional routes here right on the same level as these other ones all right now it's your turn to get your hands on the keyboard pause now and work on the challenge all right let's get this done so we'll first go to our header which is where our links are We'll add another one that will take us to slash host host awesome okay easy start if I go there nothing's going to show up because we don't have any route that matches that and oh no I broke it okay there we go we're back okay that's nice a quick easy win we'll get rid of that okay let's create some components dashboard income and reviews I won't Bore You by making you watch me do all of this so I just created a basic dashboard component and I'm going to do the exact same thing in fact I'm just going to copy this and paste it to some new components for the income and the reviews okay so now we have the income and reviews done let's go to our index here and we will import those we'll bring in the dashboard this is going to be in the host folder and it's the dashboard component and then we'll just do that for the other two okay so challenge part number two is done and next we need to set up our routes so I'm just going to take this Vans route and let's see we need one two three of them so we'll change Vans to oh this is well that's okay we'll change it to host and then I'm going to change this to the dashboard I guess I could call this host dashboard or something if I wanted to be extra clear and then this will be slash host slash income that will be the income component and slash host slash reviews and that will be the reviews component okay let's hit save we're not broken that's good news I'm gonna go to the host and we'll see dashboard goes here that's good now currently we don't have any kind of navigation that will be able to take us to the income and reviews routes so I'm just going to type it up here into the URL we'll hit enter okay income page goes here we'll do slash reviews reviews page goes here awesome okay that was all just some bootstrapping work nothing too groundbreaking but next we're going to see how we can actually on our host page have another navigation bar that will allow us to be a little more deeply nested so that we can navigate just through the different host Pages if anything that we did in this bootstrapping challenge here was difficult then that's probably a good sign that it's time to go back just review what you've learned maybe it's been a little while since you've done it but it really will be in your best interest to review what we've learned up until this point and try to catch yourself up so without further Ado let's start turning this into some more nested routes okay we are going to work on nesting these other routes inside of our slash host route and we're just going to take it one little step at a time so your first challenge is to take this route that is for slash host and turn it into a parent route that surrounds the host income and host reviews routes now because we don't have a navigation bar to get to these other paths here once you've done that you'll go to the URL and you'll type slash host slash income or reviews it doesn't matter hit enter and see what happens once you've done that I want you to pause and I want you to see if you can figure out why it did what it did okay so pause now and work on this challenge okay well let's simply take this closing slash away so that we can turn this into a parent route here we'll close it with a separate tag and move that down we'll indent these nested ones now okay let's hit save again we don't have any kind of navigation happening so I'm going to type in slash income and hit enter and okay well here we are it says we're at slash host slash income but we're seeing that the dashboard goes here and we're not seeing anything else so maybe you figured it out kudos to you if you did remember when we learned about layout routes we learned that this route as a parent to the other routes needs to have some kind of hole inside of that layout so that react router can know where to put the route that actually matches the URL in this case this dashboard element is acting like a layout route and if we go to our dashboard page we don't have the outlet component here anywhere so okay let's say we go ahead and we import the Outlet component from react router Dom and let's just do a really quick fragment so that we can add our Outlet we'll hit save and look at that we have our dashboard goes here that's from this dashboard page that's this H1 and then we have the outlet which is the sort of placeholder for the route that's actually matching best to go I guess the important thing to learn from this lesson is that the way react router is working is it's matching multiple routes and deciding that multiple things can go on the page at one time in this case this route with the path of Slash host is matching and so it's displaying the dashboard and because our dashboard has an outlet it's also matching this route here and by matching I just mean that it's comparing our path in this route to what's actually in the URL and because this route is matching it's also displaying this income and it's putting it inside the outlet from its parent route that should have been reviewed but maybe seeing it in this slightly different context is helping clarify that now there's one major problem here and that is that our dashboard is actually a different view altogether it's going to have a summary of our earnings our reviews a quick summary of the vans that we're renting so the dashboard isn't the shared user interface that we want to share between these three routes so think for a second what is the shared interface that we want to share between these three routes well it's this tiny little navigation bar at the top so in reality what we need to create is another layout route that is specific to the slash host route and this layout route is still going to be nested inside of our main layout route up here because we still want the top navigation and the footer we don't have a footer but eventually the footer to exist so in the next scrim we'll have another challenge where we create another layout route we'll call it the host layout and thankfully we'll create that little navigation so that we can actually navigate around this slash host nested routes without having to type anything in the URL so that's what's coming up next before we jump into this challenge we are going to backtrack on what we did on the dashboard file really quick as you might remember the dashboard itself is going to be the view that has sort of these summary stats and we also want it to include the navigation bar but the navigation bar isn't really the dashboard because if we navigate to another route like the income or the reviews route we want the navigation to stay but we don't want the summary to stay we want to switch to those other routes currently we set up our dashboard with this Outlet so we're just going to undo the changes that we made there so that we are all set to start now on the challenge for this script so let me type that out okay your challenge is to make the host layout component it's just going to have the navigation bar for the dashboard the income and the reviews like it mentions here and once you have created that host layout component you'll need to replace the dashboard being rendered here for our host route as a caveat to this it's going to make the dashboard disappear but don't worry too much about that we're going to fix that in the next lesson so your navigation will include something called dashboard but clicking it won't exactly show dashboard goes here the way that you might think I've left out a couple of the steps that you'll need to take so this is going to be a good challenge for you and it will really test your knowledge and make sure that you've been following along with the challenges and understanding what we've been doing so far especially regarding layout routes so now it's your turn pause now and work on the challenge okay let's go over to components I'm going to create my host layout in the components folder not the pages folder maybe there's an argument for doing it in the pages folder to me because first of all we have the layout component in the components folder it makes sense to put the host layout component there but secondly this isn't really a full page per se it's just this navigation bar that's going to be shared between the pages so let's go ahead and create a new component we'll call it host layout.jsx and we'll just kind of get it set up like normal for now we will just return an H1 just kind of do it one step at a time and we'll say host layout then we need to make sure that we import that so let's import it at the top of this file host layout that was kind of a cool shortcut I could do there and we'll replace the dashboard with host layout we're at the slash host route so going to that path should render the host layout and sure enough there we are okay let's go to the host layout we know we need our navigation here and to navigate around we're going to use the link component from react router Dom and let's use a nav element since this is a navigation on the site and we will create our links so this is going to go to slash host oh not slash host slash link there we go this will say dashboard again this one's not going to be working the way that we think but we'll fix that soon then we will create our other two we're going to have slash actually just here let's see Slash income slash reviews this will say income and this will say reviews as a quick aside for anybody who may be already familiar a little bit with react router you might be screaming at me that I don't need these absolute paths even over here in our index we have some repetition happening with Slash host slash host slash host so don't worry if you know that there's a better way I'd also know that there's a better way we're going to learn about that very soon if you have no idea what I'm talking about with relative paths or anything like that don't worry about it we will talk about it okay let's go back to host layout and well let's go ahead and hit save okay it's pretty ugly so I'm going to call on my magic snap and here we are perfect it's a little basic but the styling is there so let's see if the functionality is there now we already talked about this dashboard well we're at the dashboard I'm clicking it it's taking us to slash host but nothing else is showing up and well actually I'm getting ahead of myself these will take us to slash reviews and slash income but the part that I kind of left out was the fact that we would need the outlet if we want to show any of the other parts of the page so that's the next thing we need let's go ahead and import our outlet and I will need to turn this into something a little different so let's just wrap it in a fragment for now so that we can put more than one thing here and below our nav bar we will render our Outlet let's hit save okay awesome we were at the slash host slash income income page goes here that's of course where we would design the actual income page okay let's try reviews reviews page goes here awesome dashboard uh oh nothing's there let's go look at our index and I'm going to clean up this challenge here I want you to look at this nested route setup and see if you can figure out why it is that when we go to slash dashboard our dashboard page is not actually showing up in fact you can even pause here if you need a little extra time well one thing that might be obvious is that we are currently importing the dashboard but we're not using it anywhere so the program has absolutely no idea that we want the dashboard to be a part of this app we had it right here with the host layout but we needed to dedicate this parent route because the shared UI needs to be on the parent route to The Host layout so our dashboard is gone well there's one way to fix this but it's going to highlight what I was kind of alluding to a moment ago where I was saying that we have this kind of crazy nested repetition happening and we're going to eventually use relative routes to kind of fix this so the workaround is I could just repeat another path and say this one is also slash host and the element should be dashboard I want to make it very clear that you would never see this in production react router 6 code so I just want to make sure nobody takes this as their takeaway and decides This Is How They want to do it so let's hit save technically our dashboard is showing up react router is matching this route and it says the element is the host layout and then it looks at this child route and it says well yeah I already matched it but I guess I can display this element too in the parents Outlet so we have the host layout giving us this navigation bar and then the child route here displaying the dashboard as well so technically this is working but that leads us perfectly into the next topic which is all about using relative routes so that's what we'll learn about next the way react router works under the hood is when it is looking at a child route like the ones we have here and here and technically this one here as well inside of the context of that route it knows that this route is a child of the slash host route up until now we've included a slash at the beginning of every one of our paths but the truth is we don't need to do that all the time and in fact it's going to end up making our lives a lot easier to not have to have an absolute path like this every time that gives us the complete view of the path from the very home page at slash all the way to the end that might not seem like a huge deal here when we just have kind of two portions of our URL or of our path but if we look back at one of the pages we're going to be creating we have slash host slash Vans slash the ID of the van pricing and slash photos and that is going to start to get tedious plus if this were to grow into a much bigger site that might even get more and more and more nested and just become a little bit unmaintainable fortunately there is a better way and like I mentioned before for anybody who already knows a thing or two about react router we can clean up what we have here and make it better and the way we're going to make it better is through the use of relative routes Now Fair Warning by switching things to relative routes it is going to lead us into the next topic because we're going to break a thing or two here but that's okay that's how progress is made right the idea behind this is that the slash really should mean and should be dedicated for the very initial home page if I start my path with a slash then react router is going to treat it like an absolute path and technically as we've seen I can use that and I could just use that for the foreseeable future for my entire app and things would work if I do not use a slash at the beginning then it treats it as a relative route and what is it relative to well it's relative to its parent route in this case the parent route is not really determined we have this path of Slash which is our home page and the parent has no path it's called a pathless route because well there's no path there so it assumes because there is no parent that this is one of the first Pages like the first section of the URL here slash about Slash fans slash fan slash ID so I can do the same thing with my host here and just remove my slash and maybe we decide we get a little carried away and we're going to just remove all of these initial slashes well let's hit save and we'll see what happens okay I'm at the slash host route but suddenly my dashboard is gone but here it says that the host is the path well what's happening is because I don't have a slash here it is now relative to the parent route and the parent route is at slash host it doesn't say slash but that's because it's on the top level of our routes so think for a second if this host is relative to the parent and the parent is host what could I type into my navigation here my URL in order to get to the dashboard view you can pause now and kind of play around with that or think about it if you want well what I'd have to type in is slash host slash host hit enter and now I'm back to my dashboard so that's not ideal I go to income well that route doesn't even exist anymore and you can see actually none of it is matching because really we're defining slash host slash host slash income and now we're back to where we want it to be of course we set up these links as absolute paths to slash host slash income slash host slash reviews and so that's taking us to this unmatched blank page which we should actually put on our backlog because we probably want some kind of 404 not found page to really soak up any routes that are not being matched in our route definitions over here but that's for a future lesson let's go back okay well how could I fix this well if these routes are relative to the parent then I don't need to specify host again I can just say this is the path of income this is the path of reviews because in the context of these nested routes it already knows that the parent is host slash host so that should fix income and reviews let's hit save go to income and awesome our income page is back reviews Pages back the dashboard is still broken now at this point there's a couple small caveats that I want to talk about and I think that will probably be best served by doing it in the next lesson so before just moving on if you want you can play around with everything we've done here you can scrub back to the beginning of the video and see if you can recreate this relative path setup that I have here and when you're ready let's go to the next lesson we'll learn how to fix dashboard and a couple other minor things as well okay let's fix this weird conundrum where we have slash host slash host and that's where our dashboard lives we've already seen that the income and reviews are working because we do want them to be at slash host slash income and slash host slash reviews it's pretty common when you're creating a nested route scenario like we have here to put some sort of layout element at the parent of that nested Route Series that you're creating this layout element is of course as we've learned the one where all of the shared user interface in our case just this simple little navigation bar where that's going to be exposed and then everything else that matches more nested inside of it we'll just go into the outlet of the parent layout component because this is a pretty common setup in react router there's a way for us to say okay this is the layout element and this layout should exist on every route that starts with host or slash host but when you go there I also have a component that I want to render in the outlet of the this host layout component and not at some further nested URL path like slash host slash host just at slash host and the way that you do that is with something called an index route you can click this screenshot which will take you to the react router docs which talks a little bit more in detail about index routes but the main takeaway to remember that was at least most helpful for me is to know that if I have an element that I want to display in the outlet of the layout component but I want it to be at the same route as what the layout component is defined at then I can simply replace my path with the prop called index a way that I tried to understand this for a long time was to imagine it being like path equals slash but the problem is when a path starts with a slash it's an absolute path so doing this means that this would only display at the top level slash path up here it's like it would be the home page so the slash isn't going to work for us because that's an indicator to react router that it's an absolute path so their work around for that is to say index now there's a nuanced difference between the layout route that we have here that does include a path and the layout route we have above that does not include a path in this case the layout component will apply to well everything because everything is a child of that layout route and that's why we still see a navigation bar even though we're inside of our more deeply nested routes here now in fact I could switch this definition here so that it does include a path and the path would be path equals slash but if I do that I want you to think to yourself what tool did we just learn about that I would then have to use in order to maybe update my route so that they looked a little bit more consistent and clean well let me hit save let's go to our home page and everything seems to be working just fine that's very specific because of the way that the slash works and this being an absolute path but the point is we could also replace this path equal slash with index because once again index is saying I want you to put this element the home component inside the outlet of my parent route when it matches so when the path is just slash then first render the layout and then inside the outlet stick in the home element when it changes to slash about then I don't want you to render the home anymore because it's not the index anymore it's slash about and so you should render this element inside of the outlet of the parent I think for the sake of more closely matching what the documentation shows I'm going to leave it this way but it's helpful to point out that it was working before and it would continue to work the other way as well okay there's one other little caveat that you might be asking yourself about and that's right here we have this Vans path and then we're explicitly saying fan slash colon ID so what gives with that how come we're not using nested routing there well that's a great question if you were asking that and we're going to talk about it in the next lesson okay so what gives with having this van colon ID here if we were just talking about how we can Nest the routes so that we don't have to include these nested route definitions in our paths well I want to refer you back to when we first started talking about nesting the route component the primary reason you would want to do that is when you want to keep displaying some user interface on the page some part of your page will stay the same while other parts will display differently or new things will display on the page when you're changing from one route to the next and then we talked about how there's kind of this caution sign when the only reason you want to Nest routes is because you want to avoid some kind of repetition in your route paths let's take a look at that so the Vans and Vans ID we have this slash Vans page and it starts with explore our vans and then we click on one of these and nothing has remained the same I mean our navigation bar and our eventual footer will remain the same but that's outside the purview of these paths here these routes here so looking at these two pages because none of it is sharing the same UI there isn't necessarily a reason for us to Nest a route for just the colon ID portion inside of a nested route for vans in fact doing so would make us create a route that has a path but no element because as soon as we put an element in a parent route we have to include an outlet for that parent route and because we're not sharing any UI that parent component would be a layout route that only has an outlet in it and we end up with a whole extra component that's not really doing anything in fact Maybe Just for kicks and Giggles it could be fun for you as part of a challenge to see what that would look like so we can Nest this van colon ID route inside of a Van's route let me actually type that up as a challenge okay I'm gonna call this one a thought experiment because I personally don't believe that the way we're going to write this is going to be an improvement per se but it could be a good way to practice what we have recently learned and kind of better understand how these routes and these paths work with each other so I want you to rewrite the Vans route let me actually put this as a little separation so you know what you're working with you're working with these two routes here I want you to rewrite them so that they are nested in this case because there's no shared user interface between the slash Vans and the slash van ID route the parent Vans route that you create won't have its own element prop it's only going to have a path prop and that does mean that as part of this thought experiment you're going to have to figure out how to render something at the slash Vans route if the parent route here in the definition won't have its own element you can read the hint here which should help a little bit so pause now and work on well it's not a challenge let's maybe say work through this thought experiment okay let's go ahead and create a parent route that's actually wrapping these other routes go like that and in this case we need to move our path of Vans up to the parent route but because there's no shared user interface I'm not going to put an element here again putting an element at the parent route would mean that I would need some kind of Outlet inside that element so that it had a place to display the children routes but because we have no shared user interface I would just be creating a layout route that had nothing but an outlet in it which is totally extraneous that's not necessary at all so for this first child the Vans page I do want that to render when it's at the slash Vans route well we just learned about the index prop where I tell this route to render this element at the parents path technically speaking it usually wants some kind of Outlet in the parent element but in this case because we have no parent element it's just going to render the Vans page with no shared user interface between all of these children routes and that's exactly what we want so that should work out okay then the only other thing I need to change because we're already nested inside of this path equals Vans is I don't need to repeat the Vans and the slash here I can just say that the path is colon ID so let's hit save and things seem to be working the way that they were which is good that's what we'd expect again we're now using four lines instead of two lines which of course isn't that big of a deal but it is doing some weird things like we have a route which has no element and now we have to specify another child route using the index route so again as a thought experiment I wouldn't necessarily recommend doing this maybe there's a scenario where it makes sense but when there's no shared user interface between these routes there's really no reason to do a nested route setup like this so while that was fun to play around and get some practice under our belts let's go ahead and undo everything we just did honestly that's a really great part about practicing especially in an environment like we have here on scrimba you can mess with the code and maybe even get something completely completely wrong and it's not going to break anything if you're anything like me I suffer from some severe perfectionism sometimes and it can be really liberating to realize that it's okay when I'm just practicing I can mess everything up and then just go back to where I was before I think that's pretty cool but now it's time for us to move forward we've talked quite a bit about nested routes so let's pause for a minute on the curriculum and let's go over a quick quiz dealing with nested routes just like before I do actually want you to click into the editor here and type down your actual answers to this quiz and again of course I'm not going to give you any kind of grade or anything like that the purpose is to help you reflect on what we just talked about and hopefully wake you up a little bit just in case you've been in a bit of a dream state I know sometimes when I'm watching a course I will tune out a little bit and I'm hoping this will help combat that so pause now answer the questions in this quiz and then we'll go through it together okay what is the primary reason that we would ever want to use a nested route we saw two possible reasons but one of them is much preferable or rather one of them is much more important than the other one and that is whenever we want to use some kind of shared user interface amongst multiple different routes so I'll type that down for a reference if you have a larger app and there are a lot of nested routes that are all sharing the same name in its path I suppose there could be an argument made that using a nested route could help avoid some of that more often than not we'll focus on this primary reason which is when we want to share user interface between the routes so what is the layout route well a layout route is the actual route that hosts or contains the shared user interface portion of the nested routes so its job isn't to display the primary content from the nested routes or the routes from which you're trying to display content its primary job is to display just the shared portion that you don't want changing when you go from one nested route to another nested route as a segue into the next question another important aspect of a layout route is that it will use an outlet component I'm not going to go too much more into detail about that in this question because that is what the next question is so what does the outlet component do and when do you use it well to answer the when do you use it part first you use it inside of some kind of layout route where that route is the parent to some nested routes so maybe even more specifically rather than referring to the term layout route we would say that we use it anytime we have a parent route that's I guess by definition wrapping children routes and what does the outlet component do well it's an outlet or a placeholder that represents the place in your parent route where the matching child route will render its contents so the parent route will oftentimes have the shared user interface like we talked about with a layout route so that parent route element will contain the contents that you want shared across every child route and then the outlet is sort of like the concept of children if you have you compound components in react before where it's a placeholder where the children route elements will render I think I just said the same thing two times so hopefully it's starting to sink in let me write up a summary this is worded a little bit differently but it renders the matching child routes element prop and we'll say prop given in its wrap definition okay so then what is an index route well an index route is a child route that will match the path of the parent route if the parent route has a path defined that definition might be something you have to really think about a lot but I promise the more you use it the more it'll make sense but remember we might have a layout route as a parent which is containing any shared user interface you want amongst all the children routes but you might also want another element Beyond just the layout component to be rendered when the path of the parent route is matching or is rendered so a good way to think of an index route is like the default element that should render in the parents Outlet when the path matches the parent and nothing else I think that's a good one that we could write down I don't have the slides for the van Life app right now but a good example of this is how on our host page we have the route host and we want it to display both the little navigation bar for just the hosts that navigates us between the dashboard reviews Vans and income but we also want to display all of the information from the dashboard we could have made the dashboard display at slash host slash dashboard but just to keep things simple we wanted slash host to display both the shared user interface of that little secondary navigation bar but also all of the information from the dashboard okay that wraps up this quiz feel free to go back and review some of these answers if you'd like you can of course go back and reanswer them from scratch might be a good way to really help it sink in and as always when you're ready we'll keep moving forward with our van Life app this challenge is a bit off the beaten path for what we've just been working on but I wanted to put a little bit of space between when we added the header from before and now what your challenge is to add the footer that's just a way to test yourself and your abilities from what we learned prior so your challenge is to add the footer to the site I've even given you the markup here so you can use that in a new footer component that you create in the components folder and mostly I'm wanting to test your ability to see if you know where the footer would be added so I don't care too much about you getting the styling just right however you'll be the best judge for your abilities in CSS if it's been a little while you're feeling Rusty or you just want a little extra practice you're more than welcome to add the styled footer you can click on any of these multiple screenshots to take you to the figma design file for that if you wanted to get the details on it but otherwise I will just be handling the styling behind the scenes and mostly what I'm looking for is that on your app any page you go to will have the footer just tacked to the bottom of the page so if you're not going to be doing The Styling it will just appear maybe on this really short page like this right here below dashboard goes here on a longer page it would show up at the bottom you'd have to scroll down to see it if you are working on the styling then the idea is that the footer will always be at the bottom of the content even if you have to scroll to see the bottom then you would have an extra section where the footer sits if it's a small section like this then the footer would still be at the bottom of the page okay I think that should all make sense pause now and add the footer to our site okay you might remember that the layout component is where we are including our header and because this route that's using the layout component is wrapping every single route in our route definitions here inside of our router that means that the header is going to show up on every single page and since that's what we want to do with the footer that's what we're going to do we're going to put the footer inside of our layout route here or rather our layout component so below our Outlet remember the outlet represents whatever content will go below the header we're going to say we also want a footer in here and that's going to be at the bottom of the outlet to import our footer even though we don't have it yet created footer we'll hit save okay unknown error that's because footer is undefined so let's go ahead and create footer.jsx and we'll set this up like normal and fortunately for you I was so kind as to just give you the markup that you need to include let's hit save and great there's our footer as basic as it is and it should be showing up at the bottom of every page there we go like I said I'm going to handle the styling for you so I'll use the magic snap of my fingers and there we are so we can see that if we go to a shorter page here we have our van life footer down at the bottom the main point isn't about the CSS the main point is about this layout file you can see I've made a few changes here to make it so that everything laid out correctly great work hopefully that wasn't too much of a challenge I think the CSS was a lot harder than actually getting the footer to show up on every page and hopefully that was the same case for you okay it's time for us to jump back into some new material so let's do that next let's bring things back to a much simpler time than the more complicated app that we've been working on this is actually the current default react and react router scrim that scrimba produces when you tell it to create a new scrim with react router I've made a couple styling changes but that's about it currently I have it set up so that when you hover over one of these links it makes the link bold and underlines it this is actually going to be pretty similar to what we do in the van Life app however navigating around there really isn't any visual feedback as to where I am other than what's actually on the URL bar and of course the actual content on the page a really common practice is to have the navigation bar highlight the item that represents the page that we're currently on so if I click about and hover off of it maybe I want to keep this hover style to be always applied to this link here fortunately react router makes this fairly easy and it uses something called render props which if you're taking this course as part of the full Advanced react course you have already learned about so let's see how the this is done I'm going to replace the link import with something called nav link nav link is basically the same as link except the style prop and the class name prop can both take a function as its value let me show you what I mean first of all I'm going to change link to nav link everywhere and of course I have to do that here as well and as it stands I can hit save everything will work exactly the same as it was before and it's of course not working the way that we want it to yet where it keeps some visual feedback about what page we're currently on but that's where the difference comes with nav link let me actually put each one of these on their own lines okay this might look like Overkill since it's got so few characters in each one spreading them across five different lines is a little bit crazy but we're going to add to this this will help make it look a little more visually distinct from one another let's start with this slash about link here as I mentioned the nav link can take a regular class name just like you might expect and I could give this a string value like I don't know my link then I can save that I can go into my CSS I can Target my Dash link and I can maybe say the color is red of course that's going to add that class name no matter what route I'm currently on you'll see I'm at the slash contact route but just like we would expect in regular CSS this is styling my about text here my about link as read well with nav link we can do this programmatically let's go over to where we're using our nav link and instead of providing a string as my class name nav link allows us to pass a function because I'm going into JavaScript I need to use my curly braces and then I can provide a function and whatever that function returns will be the class name that gets applied to my nav link the reason this is beneficial is because react router will pass this function an object and that object will have a property called is active so right in line here I'm just going to destructure it this looks a little bit crazy with the curly braces parentheses curly braces but just know this is getting me into JavaScript this is my function and it's an arrow function so it's just parentheses Arrow curly braces and then inside of that function parameter I'm immediately destructuring it I guess I could say something like object and then I would have to use the object dot syntax in order to access the property in this case I'm just going to destructure it and the property that I care about in this object is called is active the is active property will be a Boolean and it describes whether or not this route the slash about route is the current active route so this is nice because I can use it to determine what my class name should be so inside my function I'm just going to use an implicit return so instead of using curly braces and then having to use the return keyword I'm going to implicitly return it's only that last curly brace there and we're going to say if is active is true so it's a Boolean I'll just say if is active then I want it to be the class my link but otherwise we'll just have an empty class or an empty D string representing the class we might also be able to do something like null let's see how this works so I'll hit save okay we're on the slash contact route remember we've only put this class name on the about link so when I go to about it turns red and it stays red awesome so it's not just on Hover right here this hover CSS rule is making it a font weight bold and a text decoration of underline but the my link class is what's making it actually red so I will make a copy of this and move it up to my home nav link and then we'll do the same down to contact and I want you to think for a second when I hit save what is going to change on our page well we're on the slash contact route and we just added this active style class name to the link that is for slash contact so when I hit save it should turn red hopefully perfect okay so now everything seems to be working you might remember I mentioned that nav link allows us to either use class name or the inline style prop and that is allowed to be a value of a function so if I didn't want to define a separate style in my CSS I could put an inline style directly here let's actually combine our hover State and our selected or our active State into one set of styles so inside my layout I'm just going to create a Styles object we'll say this is Maybe active Style and we will have our font weight of bold our text decoration of underline and we'll say our color is red now the only thing left we have to do is to actually use this active style and we will just take exactly what we had with our class name but instead of applying the last name of the string my link we will include our style of active style so we'll just say if it's active then the style should be this object of active style and otherwise well I think we can just keep note let's get rid of our class name and I will just copy these down here and clean up our class names there and this should have the same effect although now our active style includes the underline and the Bold so it'll keep it kind of the way that it is on Hover State except our hover state is not red so we would have to go over here and say that the color is red we can get rid of this style here well I'll leave it there for educational purposes I guess if you're looking through this later okay so hit save now the hover state is the same as the active State and when we click over to home that becomes the active State there awesome whether you use the nav link style prop or the class name prop is completely up to you if you're working in a team there will probably be some kind of standard or Norm that you should be following so just stick to whatever makes the most sense for that project and that team okay now that we've got the basic idea of nav link down we're going to back into the van life project and apply it over there let's apply what we just learned about the nav link element to our van Life app we have a few different places throughout our app because we have multiple navigation bars in these nested routes so we're going to work on those one at a time and there's going to be an extra thing or two that we learn along the way to start we'll do this easiest one and that is for us to style the main navigation header up here I've given you the CSS rules that you should apply to the link if that's the currently active route that the application is on and I made a little note too that we don't need to style this link that goes to the home page mostly because that's kind of our logo right now in fact I should probably get rid of this underline that's happening so only worry about these three links here don't worry about this link here with that said make sure you read through the challenge I think you should have everything that you need to know to complete this challenge so pause now and work on this challenge okay well we know that we need to change our links to nav links I do want to keep this link here so I'm not just going to change my import but instead I will also bring in nav link and then I will change all of these to navlink as it stands everything should work exactly the same there's nothing different about nav Link in its functionality but it does add the capability of adding that active class or the active style this is going to get a bit long vertically so I'm going to separate things onto their own lines and since these are going to be repeating themselves quite a bit I'm just going to keep my three cursors up here and as it mentions you could either use inline Styles or you could use a class name maybe just for the sake of seeing both ways I will start with a class name and the thing that's special about the nav link component is that I can provide not just a string as my class name but I can pass a function this is an example of nav link using a render props pattern where we pass a function and when that function gets called by the navalink component it's going to call it with an is active property on an object so it's going to call it with an object there's also an is loading property on this object but we're destructuring it to just make use of the is active property on that object and that way we know that we can check if is active is true then I want to provide maybe we'll call it active link will be the class name we haven't created that yet but we'll get there and otherwise I don't know we could say null or maybe empty string is better I'm honestly not sure last but not least let's go actually let's copy these Styles here and we'll go over to our CSS and actually maybe closer to the top is where we'll Define this here we're accessing some header anchors let's just style all anchors that have a class of active link we'll give it those CSS Styles let's get rid of these comment Stars here and I need to make sure let's see up in the header I hit save and okay well host is highlighted that's good news I click this and about is highlighted Vans is working and this one is not of course because we left it as a link this is really cool because without a whole lot of extra knowledge under our belts just understanding this kind of render prop pattern for a class name we were able to add something to our app that really does help quite a bit with the user experience in understanding exactly visually where they are without having to look up in the navigation bar especially because these days the URL bar kind of obfuscates what path you're actually on in a lot of browsers awesome work hopefully you were able to complete that challenge if not feel free to go back and try it again next we're going to go to this nested navigation bar that we have inside of our host routes and we're going to do the same thing there's going to be a small caveat but we'll get to that in the next challenge okay we're gonna do more of the same thing inside of our nested host view dashboard here or navigation bar here we have our dashboard our income View and our reviews View and none of them are really giving us a good indication as to which one is currently selected so your challenge is to do the same thing here you should know that there's a little caveat I included it in this note here there's a little bug that you're going to run into it's nothing to worry about while you're doing the challenge but we'll be fixing it right after we do the challenge this time around I'd recommend using an inline style and instead of using a class name and I'll tell you why after we do the challenge but let's get your hands on the keyboard pause now and add the nav links to our host layout navigation bar here this time around we will not be keeping any of our links so I'm just going to replace my link import and I'll select all of these links while I'm at it we'll replace it with nav link that gets a severe amount of the way there then I'm going to because there's some repeated code and it's going to get a bit long I'm going to put some of this stuff on its own lines just like before and let's go up to this two line and on the next line we're going to add a style prop instead of a class name again the value is not going to be a string or anything like that or even just to play an object it's going to be a function and that function will return the object that we want and we will receive in that function an object with an is active property and we'll use that to determine if we want the active Styles we haven't created that yet but we will or if we don't want any additional Styles applied let's go ahead and create this active Styles just put it right here say const active Styles is an object and let's pull in these properties now because this is an object and not just a CSS string get rid of this stuff we're going to have some syntax errors if we try to just copy over the CSS so we will use the regular inline Styles in react where we need that to be camel cased these will need to be strings and instead of semicolons commas easy enough I think everything is set up let's hit save okay we can see the bug here we have both our dashboard and our reviews showing as the active links but we can see that for the most part it's working we have income and reviews working and then if we go to dashboard neither income nor reviews are highlighted or have the active styles on them so why exactly is it matching both the dashboard and the reviews well an important thing to understand about react router under the hood is that it is not just matching a single route it's matching multiple routes whenever you have a nested route like this what I mean by that is under the hood react router is matching actually I think three routes here the first one is the slash route if we go to our index here as you might remember we have this parent route that has the path of Slash and that one is getting matched in other words react router is considering this an active route and that's really good for us because we want it to render this layout secondly it's matching the host route and that's again really good because we want it to render our host layout route so when we're at slash host it's matching both the slash route and the host route and therefore the link for the slash host route is being matched or rather the nav link is showing as this being an active route now when we go to income at the dashboard it was matching two of these routes this slash and this host when we're at income it's matching three routes the Slash the host and the income route because one of those matches is the host route this one here our nav link is considering this host link as an active link and therefore we get the dashboard being highlighted even when we know that it's really the reviews page or the income page that is the active page we didn't see that problem up with our main navigation bar because we decided not to change our logo here to the nav link we kept it as the original link so we didn't run into this problem but I think we would have if we had changed this van life logo to a nav link because it is Slash and host is slash host anyway I think you get the idea how do we fix it well it's really easy there's a prop that we can add to our nav link that's just called end and what n does is it tells react router to end the matching here so if a more nested route matches it won't also match this link on this route so we hit save we'll go over to income and now dashboard is no longer highlighted this might look a little funny if you're not terribly familiar with it when you just provide a prop name and not set it equal to something it considers it a Boolean this would be equivalent to saying end equals true or at least it would be functionally equivalent in the documentation they just use end so I'm going to stick with the way that they do it in the react router docs awesome work let's keep moving forward the next thing we'll be working on is the host Vans page this is different than the Vans page that we have in the navbar the main navbar up here because that lists all the vans on our entire van life site going into the host kind of sub menu the Vans page here just is supposed to list the vans that this particular host is the owner of keep in mind we don't have any kind of authentication so this is all a bit contrived but the idea is the host would only see this host link when they're actually logged in if they're a host and they would only then be able to get to this dashboard and navigation for hosts but that's beside the point your challenge is to start off by creating these first two pages you'll see there's a van list page again the vans that this host owns clicking on one of those will send you to the van detail page and that van detail page has details pricing and photos we're not going to worry about pricing in photos we're actually not going to worry about any of the user interface that you see here because the challenge is to add those routes and to to add the Vans Link in the host navbar right now we just have dashboard income and reviews we need to add the Vans link there like it says just create a stubbed out version of the pages that return an H1 for now and don't worry about adding the navigation from host Vans to the host Vans detail in other words because you're just going to have an H1 that says host fans page here there isn't going to be a way to have a link to the individual Vans quite yet don't worry we'll get there soon as a part of this challenge you'll need to decide whether or not you'll be using nested routes and I want you to keep in mind what will or won't be shared between these two pages you can take a look here remember that the navigation bar is being provided by the host layout component not the host Vans component so I'll leave that up to you and I think that's all the primer you need so pause now and work on this challenge we already have the slash host slash host slash income and the slash host slash reviews pages so all we need to do is create another route here for slash host slash Vans when that page is reached let's create an element that we'll call maybe host fans and for now we'll just create that component in our host folder here we'll call it hostfans.jsx and we'll set it up like normal as I mentioned for now it's just going to return in H1 we'll have it say host Vans list page let's go ahead and import that over here so we don't get that broken and actually let's copy this reviews one and we'll just make the change there we'll say host bans and that's the same name we already chose for our element so well we can hit save we don't have any kind of navigation there but I should be able to change the url to say slash host slash Vans and we're at the host fans list page awesome let's add that to our host navigation before we worry about the host Vans ID page or the host fans detail page you could say this navigation bar if you remember is under host layout and I will simply well let's look at the design the design has dashboard income then Vans then reviews so let's just follow that that means I will copy this income and put one right below it we'll change it to slash host slash Vans and we'll change this to say vans save awesome now we can actually navigate between these Pages now I imagine the biggest struggle was trying to figure out if you should nest the Vans or rather host Vans slash ID as a child of this route or if it should just be a sibling route like this and if you remember our decision up here in not nesting was because they didn't share any user interface and that's actually the case here as well we look at these two there's nothing that's shared between these two that isn't already being shared from a layout route above in which case it would be a lot more trouble to try and Nest these so in my opinion I'm just going to say I'm going to have a van slash colon ID and that will be a sibling route to the Vance route and we will call this host van detail doesn't exist yet but we'll create it we'll copy this host fans and change it to host fan detail and then create this component in our host pages so will say hostfand detail.jsx import react from react and get everything else set up like normal all right let's hit save no errors that's good again we don't have a way to link over there quite yet so in the navigation bar I'm just going to say host van slash one and there we go host van detail page it was a little bit subtle between the two because this one says Vans list page and this one at slash one says Vans nope that didn't work slash one van detail page and That Just About Does it for the whole challenge yeah we finished everything here awesome let's clean this up all right this gives us a good start the next thing we'll be working on is getting these nested routes implemented as well so that's what we'll jump into next because we need a way to get from our van list page or rather our host van list page to the host Vin detail page we do need to build out this page here however that doesn't have a whole lot to do with react router so I'm making it an optional challenge for anyone who wants to really Flex their react skills and exercise what they've learned in react in general to build out this page to make that a little more possible I've added some endpoints to our server the slash host slash Vans endpoint specifically that will return only the vans that are owned by this specific host that we're pretending to be logged in as you can see that it's searching all the Vans where the host ID property is equal to one two three that's not something that used to exist but up here I've added a host ID to a number of these Vans some of them including one two three I think three of them have the host ID of one two three and the others have just random other host ideas that are not owned by the currently logged in host aircraft notes around currently logged in remember all of these requests are implied to start with Slash API so when you make the fetch request you'll make it to slash API host slash Vans what actually gets displayed will be here in the host fans list page again this is an optional challenge I'm not going to be walking through the actual creation of this because it's a fair amount of work but this is the time to pause if you do want to work on that optional challenge if you know anything about me you know I don't do this very often making these challenges optional so I'll nudge you once again if you are feeling a bit shaky on your react skills then once again I really implore you to go back and to do this optional challenge but otherwise I'm just going to pull out my magic wand to snap my fingers and just like that we have our vans list page built as I mentioned there were three that had the ID of this particular host or the host ID of one two three and that is these three vans that you see here we have not yet built out the detail page we're going to work on that next if you click it it does take us successfully to the host van detail page but of course there's nothing specific to this one band here a few key things to note is that when we're mapping over our list events we're creating a link to the host Vans slash colon ID and we make sure to dynamically fill in the ID of the currently looping over van or the van that we're currently looping over in our use effect you're seeing that we are creating our fetch request to slash API fans we're setting that into the van State and because we're initializing our state with an empty array we're checking if the van's length is greater than zero and if it is then we're displaying the van elements that we created above but otherwise we're just creating this loading element here now that I look at this this isn't going to be a problem but there could be a little bug where if the currently logged in host has no Vans it's just going to say loading forever so I've used kind of a cheater's method here of getting whether or not it's loading usually we would look for some kind of loading state but that's a topic for a completely different lesson okay if you did this challenge hopefully it wasn't too hard if you didn't do this challenge I know for a fact that it wasn't too hard for you but now we're primed to work on the detail page so that's what we'll be doing next this challenge marks the start of embarking on I think the most complicated part of this app so we're just going to take it one little step at a time that said most of the things that we'll be covering should be things that you already know we're going to add some new knowledge along the way but in the meantime most of this should be doable and if it is a really big struggle for you that's a good indication that it's time to go back and just to review some of the things that we've learned already the challenge here is to start building out the shared UI portion of the host van detail page so that's this section right here at the top and if you remember from let's see one of these past slides here these last three pages are really all we have left to build this one it's a little hard to see because it's so small but this one is the detail page that we're working on in this challenge or rather just this top portion and that top portion is what's going to remain constant through the host fans ID pricing and the host fans ID photos page as well let's go back here to a little bit better of a view hopefully it rings a bell that because this is going to be some shared user interface between those pages the pricing and the photos page and The Details page you'll remember that we will end up using a layout route for this So eventually we'll have an outlet that we need to use for this challenge don't really worry too much about that you'll make it so that this appears when you're on the what is it host Vans and then the ID of the van so building this page out is not the optional part of this challenge but there is an optional portion and that's to style it so that it looks just like this if you don't feel like you need to practice your CSS at this time then you can just get all of this information displaying on the page and then I'm going to handle the CSS part on my end we're going to fine tune how the data gets into this page but for now just make a request to slash API host slash Vans slash and then whatever the ID is in the URL so the ID of this van the server is hard coded just to only pull when the ID is equal to the ID you pass in and the host ID is one two three so that's really already handled for you this is obviously not exactly how it would work in the real world but it's close enough for our purposes in learning react router so again you will just be building this top portion don't worry about changing the routes we have in our index or anything to set up for this bottom portion that's what we'll be working on in the next challenge okay it's your turn to get your hands on the keyboard pause now and work on the challenge okay let's set up some state for holding the current van so we'll say current van and Set current van is react.use State and until that data comes in we could initialize it as null or I suppose we could initialize it as an empty object let's go ahead and do null for now then we will do a use effect which is where we will grab our data we'll set up the dependency array and we'll leave it empty for now just saying if this component ever loads then we want you to run this effect and we will send out our fetch request so this will be to let's see I'm going to use a template string because I know that I need a dynamic access to the ID on the current URL so that's going to be actually let me just copy this part right here okay and then I will use a template string to inject some JavaScript now I need to figure out what the current URL is and if you remember way back we can get that from the params so I need to import use params from react effect router Dom and then I can grab the params by calling use params and let's see in our index.js I think we've called Everything ID yep so whatever I guess you could call it variable name we put here if I said this were colon whatever then over in our host and detail page params would have a property called whatever so it'd be params.whatever that's too silly so let's take that back and this will be params.id or if I wanted to I could just destructure it when I pull it in and say I only care about the ID property so then we could just say ID here okay and then we will get the response and get the Json turned into a JavaScript object and then we will have access to the data and if you know me I'm going to console log this data before we get too far down this Rabbit Hole so let's hit save open up our console not Json parentheses we need res dot Json cool okay so we get an object with a Vans property and oh this is interesting thing I guess this is the way that the server is returning the data the Vans property is an array but because of the way that I wrote This Server endpoint it's always going to return only one item just because the IDS are unique and especially when you take into regard the host ID so in that case I guess I could just always console log let's say data oops at no that's zero dot Vans at the index of zero which would always be the first object because I just know that it's always going to be one object let's just see what that looks like okay so that is the van that we care about and hopefully you were able to figure that part out because I am the creator of this server and I'm just going to cheat so I'm just going to put my index of 0 on the server because to be frank I probably should have done that in the first place so let's take off the index of zero here because now data dot Vans oops nope that's going to be let's see it's going to be that dot Vans at the index of zero okay let's see if this even works this might not even work let's say the data uh nope that's not gonna work okay bear with me here I'm actually going to change this from dot where to something called find buy and then we'll take this out the find by Method allows me to pass in an object with a bunch of key value pairs that it will find and return the first instance in our quote unquote database that matches these parameters so let's go back to host van detail and now let's see what comes in okay cool that's pretty much what we wanted it's still got a Vans property so we'll just say dot Vans cool okay again because I hadn't made that change before you did the challenge this is I guess outside of the purview of what we did for the challenge this makes a little more sense to me though okay well we don't want to console log data.vans we want to set the current van to data.vans and then in our markup the challenge just says that we need to display all the data so let's just stuff it into a div for now and then I'm just going to paste in the CSS and the markup that I used in creating this myself to speed up our process here so let's get an image we'll set the source equal to currentvan dot image URL and I can already see that there's going to be a problem here because we're initializing our current van State as null and so null dot image URL are trying to access the image URL property on null is going to throw an error so again hit save and we'll see I cannot read properties of null a quick kind of BandAid for this would be to conditionally render everything or maybe even better is just to say if there isn't a current van then will early return and we'll say return H1 that just says loading like I mentioned before we probably would want a real loading state to include here instead of just assuming that if there isn't a current van it's because it's loading and not because there's some kind of network error or some other problem but we're taking a few happy path shortcuts here so this will work for now okay let's try this again loading and then we get this Mass of image okay we're going to fix that in fact I'll just throw a BandAid on it and say that the width is equal to I don't know 150. okay let's see what else it said display the van image name price and type so we should be able to just kind of throw those in we'll say current fan dot let's see is it name yeah there it is okay name and let's just stuff these into a paragraph for now current band.price and we'll say currentvan dot type okay it's obviously not the form factor that we want but that is a great start for us if you weren't able to get to this point then I would recommend pausing and going back reviewing what we've done here honestly everything we've done so far except for the use params should not really be too new to you in react this might be a good time to mention that there's kind of a shift away from using use effects to do your fetches these days there's other methods that we're actually going to cover a little bit later in this course and some new really cool react apis that are coming out in the near future that will make this a lot easier to write and to reason about and you know what because this has actually been a bit of a challenge already it's taken a fair amount of time I think this last portion what we'll do right here is actually going to be something we work on in the next challenge if you were able to do this little navigation bar then that's perfect that's really really good we're going to do that in the next challenge if again you already did it then you can skip doing that challenge and you can just watch me do it over there in that lesson okay great work hopefully that went okay and if not you know what to do let's move on Okay I lied before we get to doing this nested navigation bar we need to spend a minute to talk about relative links we've covered relative route paths for example here we have our main route which is the path of Slash which enables us to put all of its nested routes as just about instead of specifying slash about because its parent is Slash the slash is sort of assumed a more obvious version of this is when we come down to the host ones where we have the path just as income but this is not slash income it's slash host slash income these are relative paths because this is a nested route inside of its parent route it assumes a known path leading to all of the parents above it or rather it's assumed that when we say income here it's referring to the absolute path of Slash host slash income down here we had to specify Vans and not just colon ID because we did not Nest this route as a child of this route and therefore we need to be a little bit more explicit in the path leading up to it however it's still relative because the URL is not slash Vans slash ID it's slash host slash Vans slash ID so that brings me to what I actually wanted to talk about and that's over in our host layout when we created these nav links we created them as absolute paths we said that this path this nav link goes to slash host slash host slash income slash host slash Vans and so forth however the truth is we actually don't need to do this and that's because this host layout is getting rendered right here in this route and this route is already a child of the slash route because our element is part of the route for path of host the element can assume the path of host in all of its links so if I come back to my host layout element this one that's being rendered on the slash host route I can change these to just say income fans and reviews going to talk about this top one in just a second but let's go ahead and hit save and I can see that this is going to take me to well this is the one that we didn't change because that's our dashboard let's go to income okay the link is still working slash host slash income slash host slash fans slash host slash reviews and once again the reason that's working is because this host layout is rendered or nested inside of the slash host path this means that if we have links inside of the income component here we don't need to specify the whole path leading up to income slash host slash income in fact let's see that just for the sake of learning I'm going to import a link from react router Dom and let's say that we are rendering both an H1 and a link let's see what happens if we put I don't know just something here let's hit save we have our click me I want you to think for a second where is this route actually going to take me to in the URL again if we look at the route hierarchy we have this income is is nested inside of Slash also inside of host and it's already rendering on the income sub route so slash host slash income so if I just say that the link is going to take me to this string of something it's going to take me to slash host slash income something so that's the idea behind relative routes let's get rid of these changes okay and we'll come back to our index file actually let's come back to our host layout file so this is why all of these relative paths are working something that's pretty pertinent to what we're about to work on is how to handle this nav link here that takes us to the dashboard because our route is not slash host slash dashboard it's just slash host whereas these other ones the routes are actually nested as one layer deeper in the URL we need to do something different well I guess we don't need to I could just leave this as slash host but one of the benefits of using relative routes and relative links is if for whatever reason I decide decided I wanted to change what this was called maybe I don't want it to say host I want it to say admin let me navigate to maybe the about page and then hit save I'll click on host well actually that one we didn't fix let me fix that in the header this one is oh these are also using absolute paths so let's say this is going to admin and this will say admin okay so I click admin and now when I click income my link isn't broken because it's a relative path I only had to make a couple small changes I didn't have to make a change on every link that leads to slash admin slash something else however my dashboard is still broken because it's linked to an absolute path of Slash host so let's undo these changes because I don't want to name it slash admin and we'll come back to our host layout these nav links are all fine so what exactly should we put here when basically what we want to say is I want to link to this route the route you're currently on just slash host well if you've had a chance to practice using your terminal on your computer if you want to reference the prior directory you can use something like dot dot it's a shorthand for The Parent Directory of the directory you're currently in using your terminal for example if I wanted to change directory to the previous directory I would say CD space and then dot dot which represents the Parent Directory well in a Unix terminal you also can say CD space Dot and that represents the current directory CD space dot does absolutely nothing it changes directory into your current directory but that little history can hopefully help you understand what I'm about to teach which is if we just want to link to the route that we're currently inside of I can just say dot this isn't by mistake or really has anything to do with the directory hierarchy it's just something that react router has implemented into the react router package and as a sneak peek very soon we're going to see when we might want to use dot dot but that's for the next lesson so for now we're going to say I want the dashboard to link me to the current route where the host layout out is being rendered and again a host layout is being rendered on the path of Slash host so let's go ahead and hit refresh I can hit income that takes me to host income let me come back out here to the host layout so income is a relative path Vans is a relative path reviews is a relative path and now dashboard is a relative path to slash host if I were to go back and change host to say admin I would really just have to change it here in this top navigation and in the path right here other than that all of my relative links would still be working hopefully you can see that there's a benefit in doing that and I've spent a lot longer talking about this than I originally planned but hopefully that gives us a quick primer into the next thing we're going to work on which I know I said would be this navigation bar but it's actually going to be this back to all Vans button I purposefully didn't teach this when we were doing these Vans list here because there's a little bit more we need to learn but when it comes to these fans right here adding a little back to all Vans button is something we now are capable of doing so buckle up that's where we're going next okay I even did some heavy lifting here and added this link for you and of course you can tell that I added all the styling to our van list detail page at least the beginnings of it so we have this back to all Vans link and this is supposed to take us back to this page slash host slash fans so let me click on this we have a quick mini challenge for you I want you to change the two so that it goes back to all Vans a major hint is how we just talked about the difference between saying CD space Dot and CD space dot dot in a Unix terminal or in a terminal and we mentioned how dot represents the current route when we're talking about react router relative links but before you get started a major caveat on this is that it's probably not going to do what you think it'll do but I do want you to give it a shot see if you can figure out what I want you to put here and then we're gonna learn one little extra tweak so that it will fix the problem that you're about to see okay pause now and work on this mini challenge hopefully your thought was to say well if I don't want the current route in fact let's see what happens I'll hit save I'll click back to all Vans and well nothing changes and that's because dot means the current route which is slash host slash fan slash one so theoretically I should be able to say well let's go back a route dot dot I'll hit save and what happens is well it takes us too far back we go to slash host we want it to be at slash host slash Vans this page here so why did it do that well something that I mentioned but didn't really dive deep into is the fact that when we're using relative links what it's relative to is the route hierarchy here it's not necessarily relative to the path that we currently see in the URL why does that matter well when we're here in this route slash fan slash ID or in this case slash band slash one sorry slash host slash van one to be more specific when I use the dot dot relative path the default in react router is not to go back exactly exactly one route which would be slash Vans but it's to go up one level into the parent route and our parent route is host or slash host which is why currently clicking back to all Vans takes us to slash host remember we realized that the Vans list page and the Vans detail page here didn't share any user interface and so we chose not to have a nested route for Vans like we might have otherwise in fact just for fun I'm going to show you what it might look like and we'll see how it's a little bit ridiculous if we were to Nest this route so I'll create a closing element rather for the route we'll stick our vans colon ID in there and now because we want this host Vans to show up on the index of Slash fans we'll have to create another route that's going to be actually you know what let me put some space around this just so we can see it a little easier this one is going to be the index in other words the host Vans is what we want to show up in the outlet of the parent route here well we don't have an outlet in host fans so we would need to just render an outlet let's bring in outlet from react router Dom now because I'm nested I don't need to specify Vans slash colon ID in fact it would be wrong to specify van colonid because that would mean slash host slash Vans slash Vans slash ID so let's get rid of the van slash part okay that was a bit of work and we have this kind of ridiculous just rendering an outlet in the parent here but let's hit save everything seems to be working and now that the parent of my slash ID route is slash fans the dot dot should work let's cross our fingers we'll hit back to all Vans and sure enough that takes us back there now the reason I was mentioning this is a bit ridiculous is because this is a lot of work just to get that back button to work so I'm going to undo all of that go back to the way we were we have no shared user interface between these two so there's not a really compelling reason to have a nested route scenario like we just saw so how do we fix this problem well react router has us covered if we go to the host layout no the host van detail our link one option for a prop that we can pass is something called relative and what we can tell it is to be relative to the path not the routes this means that when we say we're going back a route we mean that we're going back one level in our routing structure in our path structure not up a level in our routing hierarchy with this setup react router knows that there's a slash here and it knows that we're just going to go back one little path segment which would be this host Vans path so let me put my money where my mouth is let's hit save back to all Vans now successfully takes us just back to the parent path not the parent route that might have been a lot to take in I know we went kind of quickly if you need to watch this again that's okay understanding this relative path thing took me a while to fully a grasp but I am grateful that react router introduced this relative equals path prop because that wasn't always there and it really helps us out in scenarios like this okay I promise we're done talking about relative links let's get back to what we were working on which is getting this navigation bar working all right this challenge is going to be a little bit of a doozy so I've tried to give you the hints and the preparation you might need just to make this a little bit easier for you that being said just because it's a more difficult challenge it doesn't mean that you're not prepared for it assuming you've been following along and doing all the challenges you should have all the tools and knowledge you need to complete this challenge so what exactly are we doing we're not yet working on the navigation bar instead we're going to create a route or the routes that we need for these views underneath what we've already created to display so this view over here shows you the three different views that we're creating side by side up at top you can see the three different routes that we're expecting to use in order to see these views and so that's what your challenge is it's to set up the routes that you need here in our index file that are necessary so that we can access the host Vans ID pricing and the host fans ID photos views part of this challenge will be for you to add some stubbed out components in separate files I've already created these files for you we have the host van info the host van photos and the host van pricing components they're just empty files right now so that's part of your challenge just to fill those out but they can just be subbed out like I said you just maybe add an H2 that says pricing view goes here or whatever my first hint that I'll give you is that you need to use a special tool from react router so that we can keep all of this top info that you see over here in view while we navigate between the different sub views or sub routes that we are going to be creating this is going to require some slight changes in the host van detail page and I've tried to indicate where that will be exactly in that component now since we don't have the navbar yet you can test them manually by navigating in the URL bar by actually just typing in the path that you want to go to and actually as you might have noticed the slash host van ID view or path will display the information down here at the bottom currently we're not doing that but we are at that path so you should be able to start out by just adding what you need in order to display the information or more importantly for this challenge just a stubbed out version of that because this is a little bit more of an involved challenge I did include a hints.md file I'm not going to click on it here because it'll give away the first hint try not to go there if you don't need it but if you do start feeling stuck then feel free to go to the hints I have two hints that are separated by a lot of space so you have to scroll to see hint number two okay Lean On Your Instinct remember what you've learned rely on the community if you're really feeling stuck turn to the hints if you need them but I believe in you you've got this pause now and work on this challenge okay well the first thing I'm going to do is take this route here and turn it into a parent route to other routes currently it's selfclosing let's go ahead and not make it selfclosing and we will add a closing route element or tag here now the reason I'm doing that here again is because this van ID or rather slash host slash van ID is going to essentially become a layout route for the children routes that I'm going to create we're starting to sort of conflate what we're actually referring to when we talk about a page because if you think about it we're not really creating new pages here per se we're just swapping out a small portion of our UI but for the time being we're calling it Pages maybe this is where a good refactor of our folder structure would make a lot of sense I'm not going to do that now because it's outside the scope of what this challenge is but by doing this I'm turning this element this host van detail element what we see here into sort of a layout route or a layout component and when I have a layout component where I have child routes that need to be displayed I need to use the outlet component so before we even work on creating these nested routes let's go over to the host then detail component and my changes are going to go here this is where I'm going to include an outlet component I need to make sure that I import that from react router Dom so we'll import the outlet I think hitting save should change nothing at this point now let's go back to our index and let's create our child route this one will be selfclosing for the time being we're not going to have any more children nested which hopefully makes you a little bit happy about getting closer to the end here we're going to say that the path is equal to and actually you know what this is not going to have a path instead this is going to be the index route as I mentioned the slash host slash fan ID route should automatically and by default display this information so we're not saying it's slash host slash ID slash details or anything like like that it's just what will automatically be displayed on this route so that's what I would use an index we'll say the element is going to be well you know what instead of going down the whole path of creating the stubbed out version here and importing it let me just kind of skip that for just a second and we will just render let's say an H2 that says the detailed info goes here assuming we have this set up correctly it's not probably going to be pretty but let's hit save and look at that we have inside of the layout here the detailed info goes here perfect but if I navigate to slash host slash van one slash photos well because that route doesn't exist it's just going to give us a blank page so we're not quite there fortunately I can just make copies of this we'll change this one to have a path of pricing and let's say the pricing goes here and we'll change this to a path of photos or Foods nope photos and we'll say that the photos that'll be go here all right let's cross our fingers hit save detailed info goes here we'll manually go to slash photos hit enter oh and for some reason the URL did not listen to me sometimes this can be a little bit tricky I don't know let's try refresh okay that took a minute but here we go we have photos go here this has been quite a bit the rest of this is just kind of procedural so I'm going to import let's see I'll just copy this one since that's most closely related let me the third one so we'll bring in the host van info host van pricing and host van what is it photos components okay and then I'll just uh let's just copy this and replace each one of these okay those components have nothing in them so we need to fill them out okay so I created this one for the hostman info and we will cheat and copy copy this over to the host van what is this one photos photos go here and pricing say pricing info goes here and I think we should essentially be where we were before so let's go ahead and hit save okay photos go yeah because we're at the photos route we'll see if this even works pricing hit enter okay that takes me to the pricing page and then if I just go back to slash one and hit enter detailed info goes here now because I'm entering this in the URL bar and hitting enter it's actually doing a full page refresh but in the next challenge where we add our navigation bar that will take us from one page to the next without the whole full page refresh and flicker happening okay take a deep breath hopefully that was okay I completely understand if it wasn't even if you have been doing all the challenges I think this is probably the most involved challenge that we've had so far if you were able to do it pat yourself on the back that's a big congratulations if not again that's completely okay at this point I would scrub back to the beginning of this scrim and try doing it again from scratch as always that muscle memory is only going to set in if you are actually typing with your hands on the keyboard working through it in your mind trying your very best to get it done no matter what happened great job or good effort and now it's time to really tidy everything up by putting this navigation bar in and next we'll be working on adding the navigation bar and then figuring out how to make the actual information show up instead of these silly little stubbed Out versions before we even jump into the real Challenge on this scrim I want you to think for just a second we have here our host van detail page where on this page are we going to start writing our navbar code take a look at what we currently have where the outlet currently sits and what it's supposed to look like here we have the navbar and then the information so if you need to you can pause and think about it otherwise I'm just going to be quiet for five or seven seconds and let you answer the question will the outlet represents the switching out views or the user interface that will be changing from one route to the next and we show that our navigation bar is above that switching out view so we're going to add our navbar code above our Outlet here right here okay that sets us up for the challenge let me type that out okay this is fun the challenge text is actually here below where you're going to be writing your code now I did add the nav element with the correct class name and the CSS styles that you need just to make sure that everything looks okay so you should be able to just add your links as part of the challenge and this style should kind of work out okay so the challenge is to add the links to the navbar that's going to be above this information that's showing up below here that swaps out from one view to the next and if you need to check it out I mean it just says details pricing and photos so that's really what I mean by check out the figma design to see what the text of the links should be we also as you might notice want to make it so that there's a clear indication as to which route we're currently on so you'll have to remember how you can do that and of course you can look at the other parts of the code base where we're doing that we're already doing that in the snap bar and the snapbar and remember the details link here is just leading you back to host Vans ID it doesn't go to host fans ID details or anything like that so you'll have to remember the little trick we recently learned so that clicking the details link will take you to that route instead of one of the other nested routes okay that's enough of me talking pause now and add our final navbar to our app thank goodness it's our final nav bar am I right okay let's go to add our links here now because we want to indicate based on the current route a different kind of style for each link we're not just going to use the link we're going to which we're already importing we're going to also use nav link so we need to make sure we import that then we'll get rid of this and we'll say we're going to add a nav link and we're going to have three of them for details pricing and photos so let's just type in that text here details pricing photos now I do know that I'm going to be adding a few other things here so I'm just going to split things out onto their own lines right now and we'll put a little space just so it's a little easier to understand what's going on here okay first of all I need the two path so we'll say two equals and let's work on getting these right so hopefully the pricing and the photos was fairly easy because I'm inside of my nested route I can just say pricing and photos I don't need to specify the entire absolute path leading up to this this one is the tricky one because the details should lead us kind of back to the route where we're currently writing this code in other words all this code is living at Host slash fan slash and then the ID I'm going to use just a DOT and that represents the current path remember this host van detail is being rendered at the ID path or endpoint here host man's ID and so when I say to dot that means just go back to host fans ID and actually I think this is a majority of what we're trying to do so let's hit save we're going to see a little bug here oh actually we're not going to see that little bug till we get the styling in but I hopefully can navigate let's hit pricing awesome this is so cool photos details that takes us back to detailed info goes here perfect now let's add the actual active class that we need by using the style and again this is going to be a function that takes and is active prop or parameter and we want it to return if is active is true we'll return we haven't created this yet but we'll create some active Styles and yikes this is starting to bleed off the page here so active Styles or null okay sorry that that's being covered up there because I can scroll up and we can see that's the same I could make this a little bit smaller it's a little too small okay oh that wasn't me there we go good enough for now okay these are working no I have to hit save and we have to create active Styles so let's go up here maybe just before our use effect we'll create an active style so that's an object and you know what I'm going to steal it from my other ones so we'll just come back so in detail put it right there oops let's replace this whole thing and hit save okay this is where we see the little bug remember we have both of these matching because details is not a sibling route per se to pricing and photos we look here once again the host van info is being displayed at as an index route which means it's at this path and that means that this is matching currently even when I'm in pricing so to fix that I simply need to add let's go back down the end prop so I can say end we'll hit save and there we go okay so now details is the only nav link being displayed or being highlighted rather pricing photos perfect I hope everything went well one of the final major pieces that we're going to be working on is actually getting the correct information displaying here inside of our nested routes at first glance it might seem like it's easy because well we've already got this information why not be able to display it down there but remember we only have an outlet here we're not actually coding out the detailed info or the pricing or the photos here in this file where we have the information from our fetch request so we have a little bit of work to pass the information that we've gathered to the chat child routes so that they have access to that information in order to display it correctly fortunately react router has made this fairly easy so we'll be able to do that pretty quickly for now start to get excited we're almost done with the majority of our app we have a couple loose ends to tie off but those things are fairly minor in comparison to all the amazing work that you've done so far on this project once you're done with your little happy dance and maybe doing a lap around your house or something let's get back to work and we will figure out how to get the information into our child routes okay so here we are we have our navigation bar we have our outlet and the place where our navigation bar lives is also the place where we're getting our information from the server it's saved into State locally on this component and if we were just rendering a child component we could pass this information down through props to that component in this case we're not rendering the host bin info photos or pricing because we don't know which one of those is going to appear in the place of this Outlet fortunately react router makes it really easy for us to get information into the components that are rendered as part of this outlet and so this challenge is actually going to be a bit different than what I usually do let me go ahead and type it out the reason this is different is because I'm not going to teach you how to do this before I ask you to try and do it as part of the challenge instead I've linked the documentation to something called use Outlet context this goes directly to the react router docs on Outlet context and it will show you both how to set it up on this side of the equation as well as how to write the code on the receiving end in other words in the host man info photos in host van pricing components over there so go over to the documentation read through what they have it talks a little bit about typescript we're not using typescript so at this point you don't need to follow the advice that they have for typescript users okay pause now go to the docs and work on this challenge this makes a lot more sense if you already have some experience using context in react because in this case essentially Outlet is just a context provider in react if I were creating this I would create a value prop but the way that they've defined it I create a context prop and whatever value I pass to my context prop will be receivable in my other components using a hook called use Outlet context so we'll just go ahead and import that here for now and I guess while I'm at it I'll put this into my other components as well since I'm going to need the outlet context in each one of these okay let's actually pass something to our context before we go too far down that route as I mentioned we have the information in state called current van so let's go ahead and just pass the current van as the value of our context in this case we're passing the van object as the entire context value I guess what I could do is surround this in another set of curly braces which in the this case means I'm going to pass an object and it will have a current van property whose value is the current van object so this is the shorthand of saying this I do tend to see something like this a little more frequently than just passing the entire object by itself with nothing else so I think just for the sake of sticking with the example that the documentation gave I'll do it this way which means when I'm receiving it in the host van info we'll go ahead and say my const and I can't just say the current van is equal to use Outlet context because current van is an object that has the current van property so I can just destructure that right in line while I'm doing that again we'll go ahead and copy this into our other components and now I should have access to my current van so I can render let's go ahead and create a section and let's I don't know maybe render this as an H4 since we're pretty far down this nested route that we have going here and we're going to display the name and I can access that with currentvan.name and actually these are all kind of the same if you look at the design they're the same level of typography so we'll just use h4s for everything we'll say the category is current fan dot I guess type this probably should say type instead of category that's all right we'll say the description is currentvan dot description and well the design has let's go back here visibility public that's not actually part of our current van so we'll just kind of hard code that one visibility public hopefully that didn't throw anybody off too much looking for the visibility information inside the current van I'm really sorry if it did okay well the route we're in is the detailed info so let's hit save scroll down and awesome okay we have some styling work to do I'm just going to handle that for you okay easy enough now I should be able to just go to the photos and the pricing and do exactly the same thing so I won't make you sit and watch me do all that okay and just like that we're rendering in the image where we're pulling in the current van dot image URL we'll hit save and go over to photos perfect of course if this were a real site we'd probably have multiple photos but we're not going to worry about that because it doesn't pertain strictly to react router okay and I will just do the same thing for the pricing okay let's hit save we'll go over to pricing and perfect we have covered a ton of ground here I mean look at the app that we've been building we have three different levels of navigation we've learned about relative routes relative navigation links and well there's just too much to list assuming you've been able to follow along and do all of these challenges you really should be super proud of yourself now we still have a couple features that I think would really be beneficial for us to add and it's going to teach us a couple more aspects about react router along the way but this would be a great time to take a break congratulate yourself maybe show off all that you've been learning to a friend and when you're ready we'll move on to learning just a few more pieces about react router this would be a great point in your progress to update the deployment that you did to netlify earlier in the course we've got some great new features to show off and maybe you want to put it out on Twitter or share it to some family or friends so if you already feel comfortable deploying the updated version of your site to netlify then you can just skip this entire lesson if on the other hand you have not yet deployed anything to netlify I have a link here to the original scrim back from the beginning of this course that talks about how to set up your netlify account how to push everything using git and GitHub with GitHub desktop and everything you need in order to get your site live you can click the screenshot here which will take you back to that other scrim showing you exactly how to do that process and what we're going to do is going to be very similar to that first we're going to commit our local code to git then we're going to push our code up to GitHub and netlify will just automatically handle the rest and assuming that you already have an existing netlify project that's connected to the same GitHub repository and you haven't deleted that full folder or the GitHub repository from before then netlify will just automatically update everything for you now because we're here on scrimba when you first downloaded the code in the earlier part of the course we have diverged since then with our code by writing a bunch of new code just here on scrimba so the first thing we need to do is download this entire project again in the current design of scrimba you can find that with the gear icon in the lower right a menu will pop up and you can click download as zip once you download that zip file and unzip it you will have all of your files from the project that we have and what I'm doing here in this GIF is just dragging everything over to my existing van life folder and replacing all of the files from before now something that's important to note that doesn't happen in this process is we are not deleting a hidden file called dot git ignore so if you open the van Life app with all of the new files that just replace the old files you should still see a file called dot get ignore with the contents that you see here I've made sure that it's included here in the project in case you downloaded the zip directly from this project so hopefully that is still there for you and doesn't cause any issues if not you can manually add this and that will work just as well then if we open up GitHub desktop and we make sure that we're looking at our van life repository we'll see the list of changes that happened we can commit those changes by adding a message down here and clicking commit to main which will then send us back to this state where we have no local changes and we can push our changes up to our GitHub repository by clicking this push origin Button as soon as you do that netlify is going to see that there has been a change on your repository and it's going to upload the new version build it and deploy your site so that it's live for anyone to see you can click on the link up here which will then take you to your site and voila everything is ready to share just like before if you'd like to share it out to Twitter I think it's a great idea to build in public and to share your wins with the world so if you're active on Twitter you can click this screenshot which will prepopulate a tweet for you of course you can change it however you want especially make sure that you add your custom netlify link right here at the bottom of that tweet and that's it now we're ready to continue working on our van Life app you may have noticed that we completely skipped adding this filtering section on our vans page this is the list of all Vans not just the host vans in fact you can even see this screenshot doesn't yet include the little host link up at the top in fact you can even see that this screenshot doesn't include the host link that we added to our navigation bar but don't worry we didn't forget to do it and now it's our time to tackle this feature the reason we put it off till now is because it will require us to learn about something called search parameters or query parameters I pretty commonly hear it called both of these things so I just put search query parameters because you'll hear spoken both ways let's talk for just a minute about what query parameters are the idea of a query parameter is that it can represent some kind of change in your user interface what you actually see on the page in your app probably the most common tasks for query parameters are whenever you need to do any kind of sorting of your list or filtering of something on the page or if you have a ton of results and you need to do pagination we have a pretty limited selection of hands on our site but if we had say 2 000 vans that were listed we might want some kind of pagination that said we only show 10 results at a time and the user can click through the pages to see more pagination like that and the kind of filtering that we're going to be working on in this app usually happens within a query parameter we're gonna see in just a second what that actually looks like and how you implement it but for now we're just talking about the theory a really helpful way that I have found to think about query parameters is to think of them as a single source of Truth for some of our application State I've talked about this before in another react course that I've created and the idea is that it can be really important to ensure that the state you're maintaining in your app no matter where that actually is happening has a sort of central Hub that we call the source of Truth so that everything else just derives the way that it looks based on that single source of Truth some examples of this might be something like react state or local storage or as we're seeing here the query parameters that are in your url or you might be using a thirdparty Library like Redux where that single source of Truth is maintained in memory in a Redux store for example so like I mentioned sometimes query parameters which will exist in the URL can be used as a single source of Truth for parts of your application State a really helpful metric that I have used is to ask myself should a user be able to revisit or share this page exactly like it is and have the experience be the same or rather have the results be the same if the answer is yes then it might be worth considering raising the state of our filtering or sorting or pagination or whatever it might be up to the URL in a query parameter so you might be thinking well what about react State maybe you've even done some filtering or sorting or maybe even pagination using react State as the single source of Truth something you've probably noticed about react state is what happens when you refresh your page in fact I want you to think for a second what does happen when you refresh your page say you're maintaining a counter and you've clicked the button seven times so the count is currently seven and then you hit refresh what happens the counter resets to whatever you initialize to your state as hitting Refresh on your browser is akin to loading the app up for the first time so assuming you initialized your counter at maybe zero when you hit refresh your counter is gone your state is wiped away and everything starts fresh as such can you share the current state using react state of your app with a friend well no if I had a counter app and for some reason I wanted to share the current count with a friend and I copied the URL and sent it to them when they load it up it's going to be fresh state for them in their browser so it won't include my account that I saw in my end maybe a more realistic example using our van Life app if we maybe had four different filters and some kind of text search or maybe even a location search like if we wanted to only see the Vans that were in our vicinity so that we could easily go pick them up that might be part of the filtering that we're doing on our list of vans so then let's say I want to take that list that I've created through my filters text search location search whatever it might be and share it with a friend well if I'm holding all of that state in react State I really can't do that in a meaningful way at least not without some kind of crazy work around so this would be a great example where the state of my filters and text search and whatever else it might be might be better to raise out of react and up into the URL in reality react router is handling our URL but under the hood it's using the native browser apis that are dealing with the URL now one thing that I've noticed over the last year maybe two years is that the best practices about using react State and actually about using other parts of react like use effect they're always changing in fact later in this course we are going to see an example of how we're not even going to be doing our fetching of our let's see where do we have our vans here we're not even going to be doing our fetching inside of a use effect and saving the results in state which might seem crazy that might be the only way you've ever done fetching but there's some serious drawbacks to the way that this is happening anyway we're getting down to Rabbit Hole so let me bring us back we'll see really quickly how query parameters are actually structured as I mentioned it's part of your URL and it represents key value pairs of information that can live directly in your url I'm almost certain you will recognize this pattern you create query parameters by first starting with the question mark So in our app if we have slash Vans we would include in the URL a question mark and then we would associate some information like the key of type and we would set it equal to a value of in the system sample rugged remember all our vans have this kind of type here that's simple rugged and luxury well if we only wanted to see all of the rugged vans that were available then we might include a query parameter where the type is equal to rugged and there's nothing that stops us from having multiple query parameters you may have seen URLs that were extremely long I think if you go to Amazon any product page that you find will have a really long URL and if you look at it it will have a number of different query parameters theoretically there should only be one question mark in the URL that begins the query parameter segment of the URL but you can have multiples that are separated by an ampersand so for example if we wanted to be able to filter by the type of rugged but also filter by Price or maybe even more common is to do something like sort by price if we wanted to see prices low to high for example then we simply include multiple key value pairs in our query parameters by separating them with an ampersand and you would just do do more and more ampersands with key value pairs in between if you wanted more query parameters okay I promise I'm done talking about Theory let's work on now implementing some query parameters and some filtering into our app by including the little filters that we have so far been neglecting from our design in order to handle search parameters in a react router app we're going to use a hook called use search params you can click on the screenshot here to go directly to the documentation and one thing that's really nice about used search params is that it is very similar to the signature of use State let me show you what I mean so here we have a very simple app that has a list of Star Wars characters they're either Jedi type or Sith type we have some conditional styling happening where they're either blue or red depending on their type and our goal is to make a couple buttons so one will say Jedi one will say Sith clicking them will add a search parameter to the URL which will then make it so that it filters this list and only shows either the Jedi or the Sith to start out we can use the hook for use search params we'll just do it here at the top of our component we can say const and then we will destructure an array that comes back by calling use search params just like in use State we will get back the the value of the params we're creating so we'll call it search params and that's in the first index of the array that we're destructuring and the second thing we'll get back is a Setter function just like in you state so we'll call it set search params let's go ahead and console Log search params and let's see what we get okay so this is not just a regular object or a string or anything like that it's actually an instance of the browser native URL search params object because of this the search params object that we have here actually has a whole set of methods that we can make use of when we need to and if you're interested you can go look at all of the methods in the URL search params documentation on mdn you can click the screenshot here to go there one of the methods that is very useful is one called dot get and we can provide the name of a key in a key value pair for our search parameters and it will return the value of that parameter so for example we are going to be using a parameter called type and so if we say searchprams.get type it will return that and then we are going to console log Whatever Gets returned or rather it will return the value of that so I'm going to hit save but I want you to take a look at what is currently in our URL and determine what you think the console log is going to return well we currently don't have a query string in here so let's go ahead and hit save and it looks like from the search params object when we try to get the parameter of type the value is null so let's go ahead and actually put a question mark and we'll say type equals Sif we'll hit enter it should rerender our component and we'll see if our search parameters are working okay look at that when we console log the search params I get type we get the value of Sith if we want a more full picture of what our search params are actually containing at any given time we can use a method on the search params called Dot tostring and I'll hit save you can see what that does so we get type equals if remember we can separate the parameters with an Ampersand so if I had another one like and scrimba equals awesome and that needs to be equals okay we can see that the search params.2 string will return the entire query string it doesn't include the question mark in the beginning though so that's something to keep in mind okay so we have a way to get let me change this back we'll say we want to get the type and I'll go ahead and get rid of even though scrim is awesome I'm going to get rid of this other parameter here okay we have a way to get the value of type which currently is Sif soon we're going to learn how we can actually set our search parameters so that we can change it on the click of a button but before we even do that I think it would be useful for us to use the value in the search parameter to filter down our list of Star Wars characters so that it only displays the type that is in the search parameters at any given time so that's going to be the next thing that we learn but actually at this point let's get your hands on the keyboard let's take the small portion that we've learned so far we'll apply it to the van life app and then we'll come back to this and learn how to do the filtering you know sometimes when I'm watching a tutorial with somebody else doing all the work I find myself getting lost a little bit in their code base so this is a silly kind of intro challenge but the first thing I want you to do is to try and figure out where it is we're going to be implementing this search params challenge remember the idea is eventually we're going to add buttons here to our vans page so that when we click them it will alter the search params and filter our list so that it only shows Vans of a specific type like we have the Vans for the simple the rugged and the luxury types so if you need to pause and find the correct file you can do that or you can just maybe say it out loud or something to show that you know where it is we're going to be implementing this so go ahead and do that now because we are doing this work on the Vans page we are going over to the Vans component here and hopefully you were able to find that or at least understand that that's where we would be doing the work again the only reason I had you do that is because I know that for me personally sometimes I realize I've gotten this far in a code base while watching a tutorial and then kind of realize I actually get lost in it pretty easily because I wasn't the one doing all the work I guess that's a little different in this course because hopefully you've been typing along okay so we have our real challenge here and that is to access the search params inside of this component I guess an important distinction to make between what we're doing here with search params and what we have done in the past with state is to understand that state just lives inside of this component whereas the search parameters there's something that lives up in the URL so even though we are going to be accessing the search params here in this component we're not actually instantiating or initializing search params here instead the search params variable is simply going to read the per parameters that are up in the URL we can modify the URL and we will be modifying the URL from this component but it's a little bit different than State since state is just living in memory for this component only anyway I don't know if that clears anything up or makes it worse but hopefully that helps so I've laid out some steps for the challenge you need to use the hook that we just learned about from react rat or Dom set a variable and use it to set a variable called search params that search params object will have a property you can use to grab the value of the type parameter and I want you to save that to a variable that we call type filter and then simply log the value of type filter to the console now remember currently as it stands right now in this recording we don't have a query up here so don't be surprised if you get to the third step and you log the value of type filter and it isn't what you might think it would be to test it out you can simply type up into the URL question mark type equals and then whatever you want all right you should have every thing you need pause now and work on the challenge all right let's get started we will just do this right above our state declaration and we'll create a new search params object here so search params and we're not yet at the point of using set search params but we might as well do it now because we know we are going to use it in the future so we will call use search params and I need to import that from react router Dom then maybe right below our state let's buy some space here and we'll say type filter is equal to search params and remember this is an instance of the Native Constructor URL search params that comes with a number of methods that we just get for free like dot get dot get is where we specify as a string the name of the key in the key value pairs of our search params and it should return the value at that key of type so I'll go ahead and console.log type filter and again because we don't have a query string in our URL this I think will be null is what we discovered yeah so it's null and now I can test it out by putting in the URL question mark type equals and it really doesn't matter I'll just say blah blah blah hit enter and there it is in our case notice that we're getting it twice and that's because we are rendering the component we're grabbing the search param of type we're console logging it and then our use effect is running it's going and getting the data and then it's setting state so it's rerendering this component which is then running our code again that's nothing to be concerned about right now okay great work the next thing we'll be doing is going back to our silly Little Star Wars characters app and we will apply the search parameter to filtering the array a notable thing that we are doing here is we are not using state in order to maintain the information about the filter or the filtered down list of characters or eventually the Vans but instead the filtering and the getting of the parameter and everything this is all happening right here at the top of our component notice it's also not happening inside of a use effect or anything like that the process of getting a search param is really fast and the process of filtering down in this example the list of characters is also really fast and so this isn't something that necessarily needs to happen as a side effect inside of a use effect in react instead if we just put it here at the top level then every time this component rerenders it will redo this work and that's not that big of a deal we don't need to worry at this point in over optimizing this because it's not showing us any performance problems so here we're creating our character elements which is what Char LS is short for and it's simply taking the full list of Star Wars characters up here and and mapping over it to create the jsx elements that we want to display right here so actually I want to type out just a quick challenge for you I want you to think how we might approach solving this problem of filtering our list of Star Wars characters Down based on the type filter that we just grabbed from the search params if you want a little extra credit there's not really extra credit but if you want to I guess feel extra good about yourself then you could actually try to do this for yourself right now we can see that there is a query in our URL it says type equals Sith so if you're able to successfully do this then it should grab Sith from the URL or from the search parameters and it should only show the two Sith characters that we have one kind of gotcha here is notice that the type in the object has a capital s in it whereas the parameter has a lowercase s that's something that you will need to take into account when you're working on this okay pause now and either just think through how you might approach solving this problem or if you're feeling extra confident try doing it yourself I'm sure that there are a number of different ways to solve this problem the first way that comes to mind for me is to Simply chain a DOT filter on our Star Wars characters before we then map over the array dot filter returns an array but it will be a more limited array than what the full array of Star Wars characters has dot filter returns an array and then we can just chain the dot map on top of the array that gets returned from dot filter if it's easier to understand you also could just set up a completely separate array variable like maybe you call this displayed characters and that would be equal to Starwars characters dot filter and then you could just change this to say we'd get rid of this filter and we would say displayed characters so that would also be a legitimate way to do that actually in fact you know what I think I am going to do it this way just because there is a chance that we have no filter in fact we know that there will be cases where we don't have a filter and so I may want displayed characters to 2 sometimes equal the full list of Star Wars characters so that might look something like this if I say do we have a type filter first of all so I'll put a question mark let's actually move it down to this line if type filter is a value in other words it's in our case either Sith or Jedi then displayed characters will be equal to the full list of Starwars characters dot filter and we'll figure this part out in just a second but otherwise it will just equal Star Wars characters okay let's figure out our filter that filter takes a function we're going to have access to each one of the characters in this function we need to return true or false if we return true then it will keep this current character in the new array and if we return false it won't and so we can say if the character DOT type and remember these have capital letters so I'm actually going to say character.type dot to lowercase if that is equal to our type filter then this will evaluate to true and therefore this character will get saved into the new array of displayed characters and we already switched this to say displayed characters so let me clear up this challenge text add a little space here and we already have type equals Sith let's see if this works I'll hit refresh cool look at that okay we have just the two Sith Star Wars characters in our list I should be able to change Sif or type equals if to type equals Jedi and hit enter and awesome okay everything is filtering down just like we'd think let's test it out without a search parameter so I'll delete the search parameter up there and we have everybody awesome work I really hope that went okay of course as always if it didn't just go back and try it again and actually even if you were able to do it try scrubbing back to the beginning before we had any of this code and try doing it again anyway next up is for us to apply this concept of filtering based on the search parameters to our van Life app okay your challenge for this one is to well basically do exactly what we just did but here in our van Life app in fact it's very very similar so hopefully you grasped what we just worked on because now it's your turn to get your hands on the keyboard pause now and work on this challenge well let's just do exactly what we just did we'll create a const displayed bands and that's going to check if type filter is a thing and if it is then we will use Vans this is the full array of Vans dot filter we'll look at each van and if the van DOT type is equal to the type filter then it will return true and that will become part of the array in displayed Vans otherwise if type filter is null in other words there is no type equals whatever up there then we just want to have the full list of Vans and then when we're mapping over it we will just put our displayed Vans again sometimes this will be the full array of Vans and sometimes it will be a filter down array we'll just use displayed bands to map over that and create our van elements don't think anything else needs to change let's clear this up and I already have type equals simple so let's hit save I'll scroll down a little so we can see that there's more than just the simple ones cool so I think the next logical thing for us to do is not have to actually type it up into the URL but have a way that we can click some buttons and have that change the query that's in the URL there's actually a couple different ways we can handle this so that's what we'll be learning about next the simplest way that I can think of to add search parameters is to Simply use a link element at this point we're pretty familiar with using link to send us to a specific path like if we were going to the slash about page or something like that but we also can use a link to not specify A New Path that we're going to but instead to specify a query so I can simply say question mark type equals Jedi and have this link be when it gets clicked the way that we add the query to the top I'll just create a duplicate of this we'll say Sith Sith let's hit save ah and we do need to import link so we will import link right here let's try that again okay it's not much to look at but we do have these links here and when I click Jedi well everything's just kind of working we can see that it put the question mark type equals Jedi in the URL and because it started with a question mark react router knew that it wasn't changing routes per se it's still the slash characters route but it is adding some search params and because these search parameters changed the component rerendered it reran our code that got the type and it did the filtering and everything like that so again it's just kind of working out of the box by adding question mark type equals Jedi or type equals let's hit Sith and we can see that's working as well now let me throw in a quick challenge here okay your challenge is to see if you can add another link just right here next to the other ones that clears out the search params so in other words right now I'm filtered down by type equals Sith I should be able to press a button or a link that says clear and have it show me everything in the list again I haven't specifically taught how to do this but I'm hoping that your intuition will kick in and you'll be able to figure it out so pause now and give this a shot I found actually two different ways to do this and I'm sure there's plenty more but I'm just going to duplicate the link we'll change this to say clear and one way I found that works is just to say that the 2 is equal to an empty string we'll hit save I click clear and that clears out the search parameters and shows everything again the other way that I thought about doing this is to say that I want this to go to Dot and if you remember dot represents the current path or the current route so let's hit save I'll hit Sith to filter down and then we'll hit clear again and sure enough that seems to work as well I'm honestly not sure which one I prefer so I think either way is going to be fine I'll probably just leave it here as a DOT because I suppose you could argue that it's a little more explicit as to what we're doing we're saying just go to the current path without anything else attached to it okay that was fairly straightforward but there are a couple caveats that I want to talk about with this method of using the link so that's what we'll be doing in the next scrim okay let's learn what we just applied by adding some links to our van Life app so that we can filter the Vans by their type for now the Links are just going to have a hardcoded two string like we just practiced and the different types are going to be simple luxury and rugged I've given you some class names to use because we're not focusing on the CSS here so I've already written some CSS so for each of those links add a class name of Van Dash type and then the type of that link so if it's the simple link it'll say simple if it's the luxury link it'll say luxury and so forth for the link that will clear all the filters its class name should be van type space clear Dash filters give this your best shot I'm sure you can do it if you do get stuck we're going to walk through it in just a minute but of course as always you can reach out to the community for help too oh and one last thing is you'll add your links right here between this div that I created so right where I'm putting my cursor okay pause now and add those filtering links to our van Life app okay I can see that we already have link imported so we should just be able to create some links and while I'm at it I'll just add the class names now so our class name is going to be equal to van Dash type space and then this is the one we'll change here we're saying simple let's move this onto its own lines and we'll just leave it like that and we'll give it a two property of question mark type equals simple and let's just start out there let's see what it looks like okay and let's see if it works so I click looks like some styling needs to be fixed uh we'll click that okay we get type equals simple and we only show the simple Vans awesome let's go ahead and copy this link we'll create one for luxury and one for rugged and I guess one for clearing the filters and we'll just make some of these little changes like this and then for clearing out the search parameters we will just hit that the 2 is the current route and this will be clear filters and this will say clear filters or filter okay let's hit save okay yeah The Styling is uh still needing some work but we can see that everything is working okay sometimes when you're developing it feels a little bit like a gamble you think you've done everything right and then you find some major bugs something still a little off by The Styling let me take a look at it ah okay there was a couple Styles so I forgot to copy over hopefully that didn't throw anybody off too much but the styles are one thing the functionality is another and the functionality is on point it's working great okay so now we've learned how to set a query string using a link element in react router but you might have noticed that we created this Setter function when we're initializing our search params we have this set search params function but we're not actually using it anywhere if we're just going to link directly to a hardcoded version of our search params then we don't necessarily need that search param Setter function however there are instances where you may need to use it so we are going to refactor what we have and learn about using the set search params function that we have here let's take a look at another way that we can set the search parameters in our app the way we have our link set up is a really really simple way to do this there's some caveats with it that we're going to talk about soon but first I want to comment these out actually I'll move them outside of my components so I can comment them out and I'm going to show you another way instead of linking to the query parameter that we want we can use the state Setter function that we received when we initialized our search params so this function here set search params just like in use state is a Setter where we can tell it what the new search params are going to be so let me create a couple buttons here okay the form factor is going to be a little bit different so I'll hit save and we have buttons instead of links of course we could style these however we want so this time around because buttons are not part of the react router ecosystem like link is we are simply going to use an on click event handler in order to call our set search params function so I'll create an on click for each of these and these will have a callback function and that function is going to run set search params just like with use State the setter function can either take a new value for the search params which will completely replace the old value or it can take a callback function first we'll look at just passing in a new value one thing I've learned with set search params is that it's very flexible we can pass any value into here that the URL search params this object here can take and if you look at the documentation here I think there's four different types of parameters that you could pass in for it to generate search params one of the ways that you can initialize new search params is by passing in a string that represents the new search params you want so this is actually almost identical to what we had with our links in the URL search params object is smart enough to figure out if there's a question mark at the beginning so it actually doesn't matter you can either say type equals and then we'll say Jedi this one will say Sith and then this one will actually just say we want to set the search params to an empty string or I could put question marks here and it's smart enough to figure it out so let's see with the question marks Jedi shows Jedi we see in the URL type equals Jedi Sith is the same Clear clears them out and without the question marks it does the same okay so yes this works to pass in a string like this however I don't oftentimes see this string initialization used very often more commonly I will see a record initialization or what you could just think of it as being an object initialization and this is very similar where the object has keys and values just like our search parameters have keys and values and so I can say that the type is going to be and then I can pass in my Jedi Sith and then here we're just going to pass in an empty object which says I don't want any search parameters okay we'll hit save Jedi we see that that translated into the query string just like we would have expected and that's happening by the URL search params object under the hood Sith does the same thing and clear clear smell now truth be told there's actually other ways that we can initialize this exact same thing each one has their own use case but more often than not if you're typing it in you're probably going to see people using an object like this so that's what we're going to stick with okay time to practice this let's go over to the van Life app and you'll get your chance to practice okay challenge time again your task is to change the links that we have into buttons and to use these set search params function which remember we instantiated up here to set the search params for the filtering of our vans make sure you keep all the class names exactly the way they are pause now and work on the challenge okay this should be pretty straightforward let's go ahead and select all of our links we'll select the link to the clear filter option as well and we will change these two buttons and then instead of having a to property we'll select all those we're going to actually let's leave the string there for now we'll say that when this button is clicked so on click is going to be equal to a function we'll need to run that inside of curly braces and I can't just say set search params right here because I would need to call it and that means it will get called as soon as the page loads not as soon as the button is clicked we need to pass a function and let's go ahead and move looks like my strings are a little off that's okay we'll make it so that this string goes inside here and then we'll move this string inside actually this is just going to be an empty string remember the dot string like this like we had with the link before that's something specific to react router that it's doing under the hood so set search params is actually using the URL search params Constructor and that won't I don't think know what to do with having a string of a dot in there so we'll just have it be an empty string again when we're passing in a string we can include or not include the question mark let's just leave it there because we're actually going to change this in just a second anyway so let's hit save and type simple type luxury type rugged and gone perfect now like we learned the string is not probably the most common way to do this although it works just great instead a little more commonly you'll see an object passed in here we'll actually just manipulate the string that we had and turn this into an object like this and then for here we'll pass in an empty object which means that we have no search parameters when we set the search parameters all right let's hit save and yet again it's working like we would expect great work now there's actually a major caveat to the way that we've been doing our query parameters so far and let me show you what I mean so up here I'm going to create a new query parameter that has nothing to do with what we've been doing so far I'll say name equals Jill we'll hit enter question mark name equals Jill that has no impact on the filtering of this part of the app well and we know that it has no impact on any part of the app at this point but it's so common to have more than one query parameter each one possibly having to do with a different part of your app or a different page in your app however the way that we've structured this right now because we're hard coding a question mark type equals Jedi or Sith and over here we're hard coding this object that just has one key and value in it as soon as I click one of these buttons or these links I will lose the context of the query parameter name equals Jill so if I hit Sif now it's changed the query parameter to type equals Sith because that's what we've hardcoded and rest assured the exact same thing would have happened if I'd clicked the buttons instead and the clear your buttons would do the exact same thing it clears out any search parameters that you might have not just the ones that you care about in this specific component so if for some reason you know for a certainty that you will not have any other query parameters in your project then the way that I've shown you here so far will work perfectly however for the purposes of education and an exercising completeness I'm going to show you some methods that you might use in order to merge your query parameters with existing query parameters instead of completely replacing them so we'll do that in the next scrim the main reason I think I want to show you how I figured out to do this is because I actually struggled with this for a long time and I don't even mean when I first started coding I mean just as I Was preparing these lessons I was really trying to figure out the best way to do this and I think I've come up with a good way but a caveat to that is that it's not the only way there are certainly a thousand different ways that someone could solve this problem so I'm going to split this into two parts the first part is how we can generate a query string like we see here in our links so that it will merge any existing query parameters with the one that we're trying to add and an important thing to know about that is we won't even be using the set search params for that we'll truly just be using vanilla JavaScript in a sort of helper utility function that we'll create right here and the second part is how we can do that using these set search params because there's some gotchas with using the set search params method that tripped me up for quite a bit of time so let's start with how to generate a query string like this this does require us to to understand the URL search parameters Constructor a little bit but it's not too bad it's just vanilla JavaScript the idea is that instead of hard coding a string here we're going to call a function but this time because the two prop is not an event handler like on click is we can't pass it a function like this because it will just never get called instead we are going to run a function as soon as this component loads and that function is going to generate a string which will get put in its place inside of the two prop so let's get rid of this callback function and maybe we call this generate or gen new search param string it's kind of a mouthful and I'm going to make it so that this function will take a new key and a new value and in the case of the Jedi link we're going to say that the key is type and the value is Jedi keep in mind I haven't written this function yet so nothing's going to work quite yet but let's go ahead and copy this to this one and here we will say what we really want to do is change the type to null or in other words we'll just remove the type property from the search params entirely okay let's actually create this function so I'll say function gen search params this is going to take a key and a value like we mentioned and what we're going to do is create a new set of search params and I'm going to do that by using the new URL search params Constructor keep in mind this has nothing to do with react router this is completely outside of the purview of react router at this point the only thing we will use is we're going to initialize our new URL search params with the value of the old search params we didn't talk about this before but you might remember I mentioned that URL search params is very flexible in how you can initialize it and you can take another URL search params object and use that to initialize your new URL search params so that's what we're doing here and then all we're going to do is use those methods that we briefly mentioned like dot set and Dot delete in order to alter the search params object that we just created now we do have a couple different options for Value it could either be a string or it could be the value of null and so we're going to check for that we'll say if there's no value or maybe more specifically if the value is equal to null then we're going to use the method dot delete on the search params object again this isn't something that I've taught per se I'm just showing you one possible way to do this maybe I'm teaching this more to solidify it for my own understanding since this was such a struggle for me to grasp okay and for the delete method we're supposed to pass a string of the key that we're trying to delete we know that it's going to be type down here but since we're passing that in as the value of key or the parameter of key so we'll just say SP dot delete key if the value is not null we'll say else then we want to use a method called set and set is going to take two parameters it takes the key and the value in our case this will say set the search parameter of key equal to whatever the value is that we passed in so the key that we passed in will be the key the value that we passed in will be the value now we need to return something from this function because it's running as soon as the component loads and we know that we want it to return a string that has a question mark at the beginning let's go ahead and console.l log sp.2 string this is another method that we mentioned and we will see what that generates for us again it should run as soon as we refresh the page okay we get type equals Jedi oh I forgot to change this one to Sith let's do that okay we get type equals Jedi or type equals Sith now and so we want to return that let's go ahead and return sp.2string but we also want it to start with a question mark so let's just go ahead and put that into a template literal we'll say question mark and then we'll interpret the value of sp.2string there okay let's hit save let's click on the buttons are not quite ready but let's hit well they should still work like they were before okay so the links are working just like they were before but now let's go ahead and add name equals Bob and I'll click the link for Jedi and look at that it actually concatenated the Ampersand type equals Jedi on top of the name equals Bob now let's go ahead and hit Sith just to make sure that that's working and then we'll hit clear and sure enough it only got rid of the type property on our search params okay again this is not something specific to react router but because it was such a struggle for me I really want to at least have some reference to how you could do this in case you run into this problem so that you don't have to spend three or four days down a crazy Rabbit Hole trying to figure out how to do this in the end I guess that's a little disappointing because this isn't a whole lot of code to solve this problem but that's okay sometimes in the pursuit of Education that's just what happens okay in the next section let's actually tackle how we might do this using the buttons and the set search params Setter function okay let's tackle doing this in our buttons as well I mentioned a few times how the use search params Hook is very similar to the use statehook from react and it's not just in that it returns an array with two items that include the value and a function for setting the value but more deeply the function for setting the value can take two different kinds of parameters just like in use state it can either take a replacement value for the state or it can take a callback function and that callback function will receive the previous state so that you can use it to make changes to it let's see what that looks like we're going to need a little bit more room than just doing this inline so below our gen new search param string function we're going to create a function that's called maybe handle filter change we'll just get rid of everything here and actually we are going to need to take a parameter we'll probably call this the new filter or the maybe new type and we will change everything here yeah I think that's right and we'll say handle filter change parentheses and then we're going to pass in the new type we'll say is this one is Jedi and then we'll just do the same for these other ones this time I'll remember to change this one to Sith and here we will pass in null it might have been Overkill to pass in both the type parameter and the actual value parameter or the key and value up here since this function is currently living in the place where the only thing we're changing is type I guess I wrote it so that we could eventually move this function out to some kind of utility folder and theoretically use it across the entire application in other circumstances other than type maybe just for the sake of being similar I'll do the same thing here so we'll say we're going to pass in the actual key of the key value pair and then we will not just take the new type but we'll take the key as well and what the heck let's make this more generic too we'll just call it value okay back to what I was saying these Setter functions so we called it set search params we were just using it where we just passed in a new object that represented the replacement for the params but we found that that completely overwrote any other parameters that we might have just like the state Setter function with u State we can pass in a function and this function will receive a previous version of the params because it's an arrow function and we just have one parameter I can get rid of those surrounding parentheses and we will do something very similar up here we'll check if the incoming value is equal to null now this is where the set search params Setter function diverges pretty dramatically from the state Setter function in the state Setter function we would never take the state that we received here and make any direct modifications to it instead we would always create a copy of it somehow and only use its old values in order to determine the new values and we would return a completely new state as far as I can tell and I've confirmed this with the way that react router has some of their internal tests set up it's completely okay for us to modify the previous params object so in this case I'm going to say if the value is null then we'll run previous params.delete and it'll be the key whatever key we pass in if the value is not null then we'll say previous params.set whatever key and then whatever value and at the end because in this case we're not trying to turn it into a string we're trying to set it as a URL search params object we're just going to return the previous params again this feels a little icky to me because I'm used to having the state Setter B where you never modify the original object but as far as I can tell this is okay and I think that's all the code we need let's hit save again our links were working before we still have the question mark name Nicholas Bob up there let's go ahead and hit Sith okay it appended it to this string that's great same with Jedi and clear clears out the type but it does not clear out the name now you could go even further down this Rabbit Hole the truth is search params can have the same key multiple times so for whatever reason if I wanted to I could say name equals Bob and name equals Joe or type equals Jedi and type equals if and the way that we've written this it would would clear out okay I just had to confirm it yeah it would actually clear out both types in fact let's just see it in action well let me start out type equals Jedi we'll get rid of name equals Bob just to buy some space okay question mark type equals Jedi Ampersand type equals Sith so you can see that okay it's got both the clear function we'll just clear both of them out so that might not be ideal you would have to get much more complicated to actually search through the params object and only delete the type that you're trying to delete but now we're venturing into a realm that's much past the scope of this course in fact we might have already done that a little bit here but that's okay it's all great learning and hopefully I can save someone out there at least a few hours trying to struggle with understanding this with that behind us let's go back to the van Life app I'm going to implement some of these changes for you since it is like I mentioned a little bit outside the scope of this course and you know what let's lighten it up a little bit we'll have a pretty simple conditional rendering challenge so that's what we'll do in the next scrim okay we'll actually be doing two challenges the first one is to conditionally render this clear filter button only if there is a type parameter currently being applied in the search parameters we've been working a lot down here at the bottom of the file and changing the search parameters down here but remember every time we navigate to a new URL even if it's the same base URL with a different search parameter this entire component is getting rerendered which means we have this value up here called type filter which will always be up to date with the newest filter that we've applied so understanding that conditionally render just this button and then we will jump into the next challenge right after that so pause now and work on challenge number one because this whole component is getting rerendered we have this type filter variable which will tell us if the type is existing so it'll either be simple luxury rugged or it will be null if there is no type parameter in our search parameters so I can conditionally render this clear button by first wrapping it in a set of curly braces and we'll just use some shorthand here we'll say if type filter exists it's got a value then render this button commonly we will put something like a set of parentheses around the component like that and then we'll say otherwise render null so just don't render anything there okay let's clean up the formatting a little bit I'll put a little space here too in case that's easier to read and for some reason I want to put this on the same line I don't know if that's better or worse but it should be clear either way okay let's go ahead and hit save the clear filter should disappear perfect because we don't have any parameters right now and then when I click on these it appears awesome okay let me type out the challenge number two for you okay one of the things that's added in our CSS is if there is a filter applied then that color that you see when we hover will actually stay on the button as long as that filter is applied currently it's not doing that because it's only showing that on Hover however there's a class called selected that I created in the CSS that should make it so that it will stay that color if that filter is applied well more specifically if that class exists on the button so your task is to conditionally render the selected class name if the type filter is equal to the value that the button wants that filter to be I hope that makes sense I gave you a little bit of a hint here since it's a little bit difficult to explain but notice here that I'm using template strings but down here we are not we're just using regular quotation marks that's something that you will need to change oops not there here okay pause now and work on Challenge number two okay this line is going to get a little bit long in case you're working on a small screen I'm just going to squish this which clearly I haven't optimized my styles to handle a really really small screen like that so because we're going to be interpreting some JavaScript inside of this string we're going to use string interpolation so I'm going to select these class names and we'll change this to a template string and oh I need to surround this with curly braces awesome okay and now I'm going to stick in my dollar sign curly braces so I can say if type filter is equal to and then we will just grab these values here simple luxury or rugged then we will apply the selected class but otherwise we'll leave it as an empty string you know what just in case that is a little too wide let's go ahead and just put this on the next line like that okay first let's hit save and well this is good news the simple is already highlighted because when I hit save we had clicked the type equals simple before okay luxury rugged and clear now just by way of information one thing that I tried to do was use a nav link to accomplish this same thing but it turns out the nav link does not care about your search parameter so when I used a navalink and I accessed the is active property on the render Prop class name and tried to use that instead of the type filter equals the simple it just didn't work well what happened is all of them were highlighted because this route Vans is active and the two prop was sending them to the same path it just was changing the query string so just a little extra information for you as if there wasn't already enough to try and digest in this course all right at this point we have just a few more little odds and ends that we need to add to our app so we're going to start working on those check it out I found a loose end that I just forgot to fix when we were learning about relative paths because here we have a link that still has an absolute path I actually also found one over in the host Vans page which you'll go check out next so I'm going to make you make these changes change the absolute path in this link and the one over in hostfans.jsx to be relative paths pause now and work on these many challenges we know it's an absolute path because it starts with a slash and so we had to give the entire route all the way up to the ID here but we don't need to do that because we're already living within the context of Slash Vans and so we can just get rid of Slash bands and then the Slash and we can just have the van ID however I can actually take this even one step further if we look closely at the server the IDS are strings already and so rather than create a template string and then just the only thing I'm rendering is the value of the ID we can just get rid of our template strings entirely and say van dot ID like this we can hit save and we can see that these are working just like they were before okay let's clean this up and let's head over to the host Vans page we're just doing the same thing so I'm going to clean this up too and here we have slash host slash Vans slash ID and we can just do exactly what we did before and just display the ID because again this component is living within the context of Slash host slash Vans already and so the link is relative to say just append the ID on the end of the URL we'll hit save go over to host Vans and clicking on any of these okay works great okay there's at least one more loose end we need to clean up so we'll do that next the design did show this back to all Vans link inside the host Vans detail page and we already implemented that however the design also shows that there's supposed to be one on the regular full list of Vans detail page you can see it here we're supposed to have back to all Vans now there's actually a bunch of different ways to implement navigation with react router and we've already seen using the relative let's see where is it host van detail this relative dot dot path which takes us up one level and we talked about the relative equals path which makes it so that it's a back button relative to the path or rather it takes us up one level on the path but not one level in the route hierarchy as we have here so one thing we could maybe think to do is go here just grab this link we'll come to our host Vans no our vans detail page and then just right here above where the van is supposed to go we'll just stick our link one thing that's I guess kind of nice about this is we have relative paths and so I think this should just work now we have back to all Vans we click it and sure enough it takes us back to slash fans okay we could just stop there but let's try to think of the user's workflow here maybe they're on the list of Vans page and they filter by let's say luxury they click on Good Old Reliable red and they maybe look at this and say Ah that's not for me I'm gonna go back now when they click back what is it going to take them back to well let's see we click back to all Vans and now we're back at the slash Vans page and they have lost their filtering of course with only one simple filter it's not that big of a deal but if you imagine something like Airbnb where you set up maybe four or five or six different filters for what you're looking for if you were to go into one and then click a link that said back and it just took you back and removed all of your filters that's not a great user experience well it turns out there's a number of different ways that we can Implement how to make it so that this takes us back to just the vans that we had filtered already by luxury so that's the next challenge we're going to be working on but don't worry it won't be too difficult that's what we're going to start working on next okay so we know that we want to be able to filter the list click on one of the Vans and then have some information that shows us what the filter used to be on the last page like I mentioned there's usually a lot of different ways to do things for example one way that we could accomplish this is take the search parameter directly from the current URL and instead of linking to slash van five in this example we could just tack on that query string that represents the search parameters and have it actually lead us to slash Vans slash Five question mark type equals luxury and then when we're on this page we would have that directly in the search parameters and we could pull it from the search parameters and go back to all vans that said I personally don't love the semantics of that solution and the reason is because if I'm looking here at slash van five I can already tell that this is a luxury van the query string at the top that would say type equals luxury would feel redundant to me because this represents a single van it doesn't represent represent a list that I can filter down and at this point we could Branch into two different user experiences let's say you found this awesome van you're really excited about it you grab the URL and you want to send it to your friend if it has that query string in there then theoretically they could come to this page and they could click go back to all Vans and it would take them back to just the luxury Vans because it's been filtered and if that's your desired use case then that's the best way to go the URL is the only thing that will persist from one user to the next however my argument would be that that's probably not as common so for this instance let's assume that we really don't care about keeping the filtering when we're sharing the URL to another friend and by that I mean on the detail page when we go back to all Vans if we filter it by luxury we probably do want to share only the list of luxury Vans when we're trying to decide what van we're choosing with a friend but maybe I'm making too many assumptions we talked about earlier how the search parameters are great for something that's going to persist especially like just said from one user to the next but I want you to pause for a second and see if you can remember what is the structure or maybe what is the tool that we can use if we want to save some information while we're still here on our page but we don't necessarily care if it's going to survive transferring the URL to another person that's where State comes in and in this case I'm not talking about react state I'm talking about something called history State and don't let that be scary the truth is the browser has the ability to save some kind of state between one link or one URL and the next and react router has made it very easy for us to add things to that link state so first what we're going to do is add some state to our link we're here in our vans page this is the Vans list page and the idea is to say we want to link to the individual van but we want to pass some additional information to that page so the first thing we'll do is see how to pass that state to the next page and in the next scrim we'll learn how to you could say catch that state and make use of it and this here is actually so simple it's not even challenge worthy when I'm linking to a resource I can simply add another prop to my link called State and I could set the state to whatever I want it could be a string I could just say whatever and when I get to my next route the van ID page I can grab that state and it will be the string whatever I don't prefer to pass raw values like this in my state I think it reads A little better to pass an object and so I'm going to use my curly braces to get into JavaScript and then I'm going to pass in an object and the idea here is we want to pass the information regarding the current type filter over to the next route so that that route when we get to say one of these Vans can grab that information about the type filter knowing which type it was just filtering from and can change the link here so that it goes back to just the for example luxury bands now I could just pass a property maybe called type and say that it's going to be equal to whatever the current type filter is remember type filter is coming from the search params and so it's either going to be just the plane string simple luxury rugged or I guess it was null if there are no filters but let's think one step ahead if the idea is that I don't lose all of my query strings when I go into the van and then click back to all Vans I'm going to try and future proof this a little bit so if I do have other query strings like we had name equals Joe and I go also to rugged so now I have two parameters I have name and type we go into an individual van when I click back to all vins I don't just want to have the type filter there because maybe eventually we have this sorted by Price or filtered by Price within a certain range or whatever other filters or sorts we might have so yeah let's try and future proof this instead of just passing the type by itself I'm going to take the entire query string and pass that down so let's get our object back and maybe what I'll do is let's just call it search params and actually I could just leave it like this I could just say search params is the search params value that we have this is the URL search params object but honestly I don't think the van detail page needs the entire object I think really what it needs is just the query string this one's just a judgment call it doesn't really matter too much maybe I will just call this search and then we'll say the value is search params.tostring again and it probably just depends on the needs in your scenario but the point is this should take the entire search params in its stringified version and pass it along to the next route that we're linking to this is beneficial again if we have multiple search parameters not just one filtering by type and just in case you forgot let's console.log search params dot to string so you have an idea of the value that I'm actually passing in the state here let's save open up the console and of course right now there is nothing will hit luxury okay so it's type equals luxury if I add other ones like and name equals Joe now we have type equals luxury and name equals Joe just note that it doesn't have the question mark at the beginning so we will need to add that manually we could either do it here or I'm just going to do it on the other side of the equation in the next scrum we'll talk about the van detail page and how we can grab the state that we're bringing in by adding it to the link to that page okay so we are linking to the van detail Page by its ID and we're passing this state along with the link so let's go over to Van detail and learn how we can receive the state from the incoming link that sent us to this page doing so will require us to learn a new hook called use location and I'm going to be perfectly honest you can probably tell from the screenshot here the documentation on use location I think has a little bit of work to be done but nonetheless I link to it here just in case it gets updated or maybe I'll submit a PR and actually update their documentation to have more useful examples so I'm going to import use location use location is more like the the use params where it doesn't bring in an array like we have with you state or with use search params so I'm going to say const location equals use location and this location object is well it's just that it's an object so let's go ahead and console log it and we need to go over to the detail page to run that code okay and you can see it's an object with a number of pretty helpful properties pathname gives us the absolute path to where we currently are in our routes search would have a query string there if this page had a query string in fact I can see that by saying question mark name equals Bob hit enter okay so now we can see the path name is slash van five the search is question mark name equals Bob and that came from the query up there of course you can also see that the state says it's null and that's because I navigated to a new page by adding this query string so let me actually go back in the browser and I guess this brings up a really good point you can see that just by hitting back I was able to bring back the search state if you look in the console there's a property called State and it has an object with a search property as a reminder that's what we created we chose to call it search this isn't something browser specific the property State however is something specific from react router but the cool thing is I was able to hit the back button and bring that state back even though it did a refresh of my app and in fact even if I do refresh the app you can see the state is maintained this is what I meant by saying that the browser has its own internal ability to maintain some kind of state based on where you are in the app and that's all react router is using under the hood now there is a limitation to this if I copy this URL and I send it to a friend their browser does not have that same state there's nothing in the URL that's hidden or secret about the state that I'm trying to maintain it's something specific in our browser in fact even if I were to open a different browser and use the same URL that state would just disappear in this case though that's probably okay because if I'm in a new browser or I send the link to my friend they may not necessarily care to go back to all the luxury Vans like what I'm trying to handle here okay so by using the use location hook we have access to the state which is an object that has a search property because that's how we set it up in the Vans list page so that sounds like a pretty good time for a challenge now okay your challenge is to modify the link to prop so that it can send the user back to the previous page with the search parameters included if and this is important if they exist like the little note says here we may not have anything in the state if there were no filters applied maybe I came to that page and you can see in this case it says the state search is an empty string or as we discovered we may not be sending State at all if I were to add a random parameter up here say name equals Bob then state is null so we don't even have a state.search keeping that in mind you'll want to make sure that you code defensively so that you don't run into a bug in case that happens okay pause now and work on this challenge okay now I did leave you in the dark a little bit and I'm hoping that you just had a chance to play with the code to figure this out yourself but when we have a relative path like this with just dot dot I still can say question mark maybe type equals simple and have that work so if I hit save I'm just hard coding this of course for now I'll click back to all Vans and you'll see that our simple filter is applied so let's change this back to luxury of course what this did is it lost the name equals Bob but that's because we're hard coding it this isn't the final solution let's go luxury we'll click on a van and we have state DOT search now we have location dot State actually let me open the console again location dot state DOT search and that's going to be the query that we want to include don't let this be confused with the location dot search again that's just whatever search is in the URL at the current time when this loads and actually you know what I'm seeing something now the way that react router handle search is is including a question mark at the beginning so for the sake of consistency I'm going to make a quick change over here instead of the value just being the search params.2string I'm going to have it include a question mark so we'll just do this I didn't expect you to figure that one out that's just a choice that I'm making okay so let's try this again we'll go back to all Vans let's maybe hit refresh we'll change the type to luxury go over here okay so now our search has the question mark in it again not necessary but it seems a little more consistent to me so because of that I can just change my to prop and we could just say this is going to be a template string and it's going to start with a dot dot and then include location dot state DOT search right well not quite because again there's a possibility that the value of state is going to be null if the value of state.search is an empty string this works fine but if state is null this is going to throw an error so what I'm going to do is create a sort of backup for the location.state.search just in case it doesn't exist let's go ahead and save it we'll call it maybe I don't know we'll say const search is equal to location.state.search and there's a relatively new feature in JavaScript that's called optional chaining in fact it's new enough that scrimp is going to complain about the syntax but I promise you it still works and so I can say if location dot state is a thing then check for a search property and that value is going to be the value of my new variable that I'm setting up but if that doesn't exist let's just say it's an empty string that gives me a fallback just in case location dot states does not exist my value will be an empty string so I'm going to take my search and replace well I guess we can just delete that part and say the search will go here let's hit save or close my console to buy some space let's go back to all Vans and awesome that took us to type equals luxury perfect rugged go into one of them back to all Vans type equals rugged if you didn't know about optional chaining or you didn't want to use optional chaining you could also simply say something like location.state and location dot state DOT search this is usually how it was done before optional chaining existed in JavaScript but because optional chaining does exist even though scrim is going to complain about the syntax I'm going to leave it in here what's nice about this is it should work with any other filters or queries that we have included in our URL so if I add back my and name equals Joe I click on one of the rug Advance now we have type and name in our queries we go here and then I say back to all Vans it's going to maintain both the type query and the name query all right that was a lot to take in as always if you did struggle through this challenge now that you've seen me do it I recommend you scrub Back to Before The Challenge and just try it again on your own practice really does make perfect since that one was pretty heavy let's do a quick challenge that's going to be a little bit lighter and then we'll be ready to move on let's say a product manager comes to you and says well when a filter is applied we don't want it to say back to all Vans we want it to say back to and then the filter then so back to luxury Vans or back to simple vans so that's what your challenge is and I'm not going to give you too much more information there's certainly more than one way to do this but I want you to put on your thinking Gap and try to figure it out so pause now and work on the challenge well one way I could do this is to take the string let me open my console I could take the location.state.search string and try to just do some regular string manipulation like split it on the ampersands and then split it on the equal signs and grab the one that's after the type or something like that however because the string is a query string one way to solve this is I could create a new instance of URL search params and then I have access to the methods like dot get to get the value of the type param so that's one way I could solve it another way I could solve it is in Vans I could just pass more State through so right now we have the search I could also say I want to pass the type in say the type is going to be equal to and in this case we already have access to that with type filter and we put these on their own lines and then if I do that over in Van detail I can grab that string by location.state.type since I've already got that typed out I might as well just keep going down this path so we'll hit save let's go back to all Vans and just do a refresh we'll say rugged okay so now you can see the location.state is an object that has search and type so I'll just do something similar here we'll say const type is equal to location dot State question mark DOT type and if that doesn't exist like for example if location dot state is null then we'll just set the type to well actually let's set it equal to all because we do want it to say back to all Vans if there is no filter applied and now I can take this type and just conditionally render this word here we'll just say back to and then put type Vans okay let's see if this works let me close the console we'll hit save okay it says back to rec advance so I think it's working let's go back we'll clear the filter we'll go back to one of them back to all Vans that's great let's try luxury back to luxury Vans simple awesome again we even talked about multiple different ways that you can solve this at that point it's just sort of a JavaScript challenge as a quick recap passing State through the links can be a really useful thing okay hopefully that challenge went okay again review it if you need to and then when you're ready we'll move on a really important part of any application is being able to give useful information to people when they come to a path that doesn't actually exist on your site sometimes this happens if you have outdated links within your own site and they lead to pages that no longer exist or it might happen if somebody else links to your site and they either got the link wrong or again they're using an outdated link that no longer exists for example if I'm here and I type in slash blah blah blah and hit enter you can see there's really no useful information on our site because react router is not handling a blah blah blah route this is where a good 404 page comes in and I've seen some really creative interesting 404 pages but we're just going to keep it pretty simple for now so how can we handle this in react router fortunately it's really easy there's something called a Splat route or a catchall route and that has everything to do with what you put for your path here inside of my layout route because you can see in our example here we still have the navigation bar and we still have the footer so that's the reason I'm choosing to do this as a nested route inside of my layout I could if I didn't want to have the navigation or footer I could have a completely dedicated 404 page that didn't have those elements in which case it would go as a child of routes right here but let's keep it as a child of our slash route so I'll create a new route and a catchall route is going to be very similar to if you've ever used a universal selector or a catch Hall selector in CSS we're going to use the asterisk this essentially means if there are no other routes listed then use this route which is why it's called a catchall it'll catch anything that doesn't match elsewhere let's go ahead and put an element that just says maybe an H1 that says page not found we're still on the slash blah blah blah route let's hit save and here we go we have this is a very basic version of it but we have a page not found sort of catchall here one thing that's really cool about react router 6 is that it's a lot more intelligent under the hood about scoring the paths that we have based on what the actual text of our URL is what I mean is that even though our catchall path is at the top of our list of paths I can still navigate around my site and it's not going to prefer the first one in the list instead it's going to give a score under the hood about which of these paths best matches where I currently am in my site in the past we did have to worry about what order we put things in but we no longer have to do that now it feels a little bit out of order for me to put the page not found first so I'm actually going to bump this down to the very bottom that'll go right there and because react router is really smart about how it prefers the different paths that we have available it doesn't really matter so I can still navigate around my site just like I was before and if I were to have a link that sent me to the wrong place like slash blah blah we'll get our page not found the way that we would expect now this isn't very exciting let's go ahead and as part of a challenge have you create a bit more of a polished 404 not found page let me type that challenge out now okay I deleted the not found that we had before so if I hit refresh we'll be back to a completely blank page and your challenge is to create an actual 404 page I have the design here of course you can click on the screenshot to go to figma but the key components are just an H1 and a button that will take you back to the slash route so if you just want to put those and you don't want to spend time with CSS that's okay so you'll create a new component in the Pages directory you'll add that H1 and that button from the design and again you can style it if you want then you'll need to recreate the catchall path that we just created and you will import and use that not found component that you just created as the element for that catchall route pause now and create our 404 page foreign okay well let's just go through one at a time we'll create this new page called not found.jsx I guess you could call it 404 as well we'll get it set up like normal okay and I'll go ahead and add the message that we see in the design sorry the page you were looking for was not found okay there's no Styles quite yet but you'll notice that I also already imported the link from react router down because I wanted to send people back to the home page so I set up the link there I'll have to make it look like a button instead of an anchor later now let's make it so we can actually see this not found page let's go over to our index we will import the not found page and this one is under pages and so I'll actually move this to be up with the pages okay let's add our catch all route again I prefer this one just a personal preference to be at the end because that makes a little more sense to me we'll see that the path is the asterisk and the element is an instantiation of not found okay we're still on the blah blah route so when we hit save we should see our new not found page awesome yeah again this return to home is not styled at all like we would expect but that's something that a magic snap of the fingers can handle for us just fine so we have our 404 page we're at the blah blah blah route return to home takes us back to the home page hopefully this one felt like a quick win it's fairly easy to understand there's also some other things that you can do with these what they call Splat routes or catchall routes but for now we're just going to use it as our 404 page great work and I'll see you in the next lesson we are now basically done with the majority of the features that we plan to add to the van Life app but at the time of this recording there's a relatively new addition to react router that I want to make sure we cover and that's something called the data layer apis that were introduced in react router version 6.4 in order for us to really understand the purpose behind the data layer apis we need to realize that so far at least in this app we've basically been coding what you could call the happy path the happy path is when you as a developer just assume that the user is going to do everything exactly the way that you expect and everything just goes perfectly according to plan coding this way can be great for getting something up very quickly if you need to show it off to somebody but it doesn't account for any errors or other problems that do occur in the real world so although it's maybe a little more fun to code the happy path it's important that we as seasoned developers will code the sad path as well and that's where it forces us to imagine what could possibly go rung and makes us plan accordingly this is where we add things like error handling loading states form validation and all of those other really useful user experience things that you have experienced when you've used real applications of course you've also probably used applications that didn't code this ad path and hopefully understand that can be a pretty frustrating experience that we don't want to give to our users of the van Life app let me show you an example of that I've actually altered the server here to return a 400 level response that's just a server response that means that things are broken it's not sending back what we'd expect the syntax of this doesn't matter because it's specific to mirage.js but the point is over in vans.js when we get to our vans page we'll click on Vans and you can see we don't have any kind of useful information about how the Vans struggled to load and maybe try again later or try refreshing the page or anything like that instead the app just completely crashed because it is expecting that this fetch request will work perfectly it's setting the van's State and then we just assume that Vans exist and we're mapping over them as if everything were just fine and of course that throws a type error as you can see in the console which is causing our app to crash so in the next screencast we're going to see a little bit of the pain that is required for us to handle the error State and the loading state which will then bring us back to these new data layer apis with react router and we'll get to see that there's a big Improvement in the way that this can be handled so let's go through and see how we might fix our code to better handle the errors that we're seeing the first thing I'm going to do just for the sake of best practice is to take my fetch completely out of this component considering I may want to fetch these fans somewhere else instead of repeating this code over and over it's a better practice for me to create some kind of library or utility where I can get the vans that I need from a function and then inside of my component I would just call that function so let me create a new file we'll just call it api.js which is supposed to indicate that we are going to be interfacing with the API and I'm going to export we'll use an async function that we call get vans since I'm transitioning from what wasn't an async function before to an async function I'm going to be essentially using this code but rewriting it using async await so let's paste this in as a reference but we will change up what this looks like we'll say the response is await fetch then we will get the data we'll say const data equals await res dot Json and then this function's job is basically done it just needs to return the data and I think it was the Vans property on that data that we cared about so we'll get rid of these lines of code we're going to come back and actually work on the sad path for this because right now it's assuming that this fetch request is going to work just fine but let's refactor back here we will import our get Vans function and then instead of manually calling our fetch request here I could keep using my DOT then promise resolution syntax by saying get Vans dot then but while we're at it I might as well update this and use an async function now it's important if you remember from the introduction to react course that I taught if you took that that you can't just change your function here for Muse effect into an async function so the easiest thing is just to create a brand new async function inside here so we'll say async function maybe we'll call it load Vans just to get a different name that's going to call get vans and we will save that data we will just say const data equals and then we get to await get fans because we now are inside of an async function and before I forget because I do this all the time I'm going to call my load Vans function even though it's not quite done yet otherwise sometimes I end up pulling my hair out wondering why it's not working when it's just because I forgot to call the function okay so now I get to call my set fans function and pass in the data that we got from calling get Vans and just to make sure that this is working I'm going to get rid of this 400 response and make it so that it's working again so let's hit refresh okay good our vans are showing up we've made a little bit of refactoring using this API JS file and cool now let's start working on actually coding up the sad path just for the sake of compartmentalizing the topics that we've been learning we're going to do that in the next lesson one thing about the way that the code is currently running is that we are only initializing the fetch request to get our vans after this component has already been rendered to the page the experience is a little bit jarring if I hit refresh you'll see we get parts of our page and then it starts to load as the data comes in we do handle this a little bit differently I think under host fans we have a tiny little loading state right there which in my opinion is a better user experience than what we have going on here unfortunately the way that we are handling that in the host Vans page I think right here is by assuming if the van's length is not greater than zero then we are loading something however if we have an error the man's length is not going to be greater than zero it's going to be stuck on loading forever or maybe this is a new host on our platform they don't have any vans listed and so when they come to this page it's going to say loading forever even though there are no Vans for it to load so this approach was pretty naive and we're going to find a better way to do that so let's go over to our vans page and a relatively common way to do this is to set some loading state so I'll go ahead and create a loading and set loading Boolean which we will save in react.use state we'll initialize the loading State as false but then as soon as we call our load Vans function we will set the loading state to true and as soon as we're done setting the vans in our state we will set the loading State as false again so it will only be true for a short amount of time while it's getting the Vans but this allows us to use this Boolean of loading to either conditionally render something on the page or what I think I'm going to do just for the sake of Simplicity is use an early return so I'll say if loading is true then instead of returning the whole jsx that we see down here we'll just do something simple like an H1 that says we are loading it's not going to be beautiful we could conditionally render something maybe underneath our buttons but for now this will get the job done let's hit save okay we see our loading for just a second and then our vans pop in in fact while we're doing this just to make it a little bit more apparent if I go to server.js I can add this little feature that says maybe like it will take let's say two seconds for things to load this isn't a syntax you need to know again because it's specific to mirage.js but now if I hit save it will very clearly show loading for a lot longer than it did before before things actually get loaded okay that wasn't so bad we created a loading State we set the loading to True before we did our fetch request and then after the fetch request we set it back to false and we handle the user interface case when things are currently loading remember we would need to then do this for every component that is loading data like the van detail page the host Vans page and I think even the host man detail page has a fetch request yep for now we're just going to worry about the Vans page and it's again not so much the sad path per se because we're not throwing errors right now but of course if we were to throw errors like we were doing before where we're just hard coding a error response from the server we are not yet fixing that problem so we're going to have the app crash and that's not good so in the next screencast we're going to talk about how we can handle these errors but remember all of this is leading back to these new data layer apis that we're going to be talking about I think this buildup is important which is why I'm taking time doing it but this is also just good to learn anyway okay I'll see you in the next lesson okay I mentioned before that we had written our little API get Vans function in a happy path sort of way that didn't account for any errors that might be happening and so behind the scenes I went through and I added this little check to make sure that the response has come back okay this is something that's built into fetch it will have a res dot OK property and if it's a 400 level or 500 level Response Code then it will not be okay that will be a false value so if that happens then we're throwing an error and currently we're not handling that error in our vans.js page this is still assuming a happy path now I've changed the server again like we saw to only respond with a 400 response so let's go to vans.jsx and let's handle our sad path here now you'll notice that this says loading here and that's because if I refresh this we'll see that our bands never come back but our error is successfully throwing so let's go ahead and fix this now when I'm making this request because I don't know for certain that it's going to work correctly I'm going to wrap it in a try catch block this is the common way to do this inside of an async function and so I'll move my set Vans up here the try will assume the happy path but now I have the ability to catch any errors that might happen and the catch block will be the sad path now what should happen when I get an error well first let's just console log the error to see what shows up and actually let's go ahead and console log something like there was an error open the console okay we get there was an error and look at that we get our error that we threw from the server no from the API file this object here that has a message status text and Status we can see that that is coming through in our console just fine so now we are handling that error we're not displaying anything but we no longer show loading we just don't have any vans to display that's not super useful for the user so let's go back to bands jsx we'll buy ourselves some room by closing the console and similar to what we did in the loading State we're going to create another state that is for errors so we'll say if there is an error we will so I have set error we'll probably start this out as a null error and if there is an error that happens here in my catch block we will set the error and we'll just pass in that object that we got from the error that got thrown earlier let's go ahead and get rid of our console logs and just because it exists I'm going to use a finally block I don't get to use this super often so go ahead and put our loading to false because whether we get the Vans or we get an error we want to set the loading back to false okay now we can handle the case when there is an error we have this early return for loading we'll do the same thing if there's an error so we'll say if there's an error we'll return let's just do another H1 for now and we'll say there was an error and then we'll go ahead and just stick the error in there let's see what that looks like again I'm hard coding an error in my server.js so we know that it will error loading and it's taking a lot longer than before ah okay so I can't do this whole error object here let's maybe do error. message I think is what it was okay there was an error failed to fetch Vans it's not beautiful just like our loading isn't beautiful but it is some feedback to the user that tells them that something happened now again we would want to do this for our van detail page our host Vans page our host Vans detail page and hopefully you're starting to see that there's a bunch of repetition there's a lot happening just to handle this sad path and if you think really hard about it a major reason that all of this is happening is because we are only starting our fetch request after this component loads remember when we weren't considering the possibility that Vans would not come back as an actual array of Vans that's back when we saw that when there was an error in the server it actually crashed our app because we were trying to map over something that was not an array well if we didn't load this component before we had access to the data then we wouldn't have to worry about that and theoretically the same would be true of the loading State and the error State because we're sort of prematurely jumping to this route and then starting a fetch request for the data there's a bunch of little edge cases that we need to handle now all of this leads us back to the data layer apis react router has introduced us a way that we can load our data before it ever transitions us to the route which will allow us to get rid of quite a bit of our boilerplate code that we have here so let's finally dive into these data layer apis and we have a bit of setup to do before we can use them so let's get started with that the first aspect that we are going to learn about in the new data layer apis in react router is loaders you can click on the screenshot here which will take you to the loader prop in the route component which we're going to get to in a little bit but I think it's helpful to know that the creators of react router are also the creators of a framework called remix I've had a chance to play with remix it's an amazing framework it's a full stack application that uses react and it's definitely worth checking out but the concept of a loader comes directly from remix in fact they introduced it into remix and then they loved it so much that Ryan Florence and Michael Jackson who are the creators of react router and remix they brought the aspects of loaders and something else called actions directly into react router in fact you can even see if you look closely in the screenshot we'll see this export async function loader and there's this export async function action that's the aspect that I'm talking about loaders and actions so how does this affect react router well as as you saw we are currently using a use effect in order to fetch our data and for a really long time in react this was kind of taught as the de facto way to fetch data for your components let's say that I'm currently on the slash about route and I want to transfer over to the Vans route so I click the link in my nav bar which will take me to Vans and what happens is the about page goes away it gets swapped for the Vans page and because we're fetching our data inside of a use effect it immediately starts loading the data or rather fetching the data from some external Source oftentimes this request is pretty fast and once the request comes back with a response then we get some Json from the API that we work fetching data from and then react does its thing where it rerenders it takes that Json and displays it the way that we told it to in the code and we can certainly make this work like I said this is how things were done for quite a while but like I mentioned because we're only loading the data after we have already loaded the page or rather mounted the component component that represents our page we have a lot of extra stuff that we need to add we're saving State for the Vans themselves the loading State the error State we have this use effect which is calling the data and it's got some error handling built in we're also handling if it's currently loading and if there's currently an error and it's certainly not the end of the world but let's take a look at the paradigm shift that we're about to learn when we use a loader for fetching our data instead this might seem like a small tweak but we're going to see how it can dramatically change our code so we're here on the about route we click over on the Vans route and the first thing that happens is it delays for just a moment or two during that delay it's starting the fetch request to get the data for the Vans page and that way when the data is finished coming back from the request it is already a part of the Vans page when it gets loaded up again this might seem like a small difference but we're going to see how it's going to allow us to send simplify quite a bit of the code that we have now for a high level overview of how we will end up using loaders the first thing we need to do is to export a function we will call it loader it doesn't technically matter what it's called from the page that will fetch the data that it needs in our case we're going to be working on the Vans jsx page because this page needs data so we're going to be creating another function that isn't our component it'll just be right here above it probably that we'll call loader and that will be the function that gets the data since we're exporting it from here over in our index.jsx where we have our route definitions we're going to pass a loader prop to the route and we'll pass in the loader function that we exported from our vans page and then back in our vans component we'll use a new Hook from react router called use loader data which allows us to get whatever data was returned from the function that is doing the fetch request again this is a high level overview we're going to obviously go through each one of these steps so don't worry if this seems a little overwhelming there is one tiny little problem before we can start working on this and that is we need to opt in to the new data layer apis and the way that we do that will require us to make some changes to our browser router setup that we have here so first we're going to tackle that and then we'll be coming back and actually creating our loaders and changing how the data loading happens on our vans page before we can take advantage of any of the data apis in react router 6.4 and later we need to change the way that we're instantiating or creating our router you can click the screenshot here to go to this picking a router page in the react router docs but you can see from the screenshot that there are a couple different ways to create routers that do allow us to use the data apis and then there are some other ways that won't include the capabilities of the data apis so you can see the top of that list that does not allow for the use of data apis is the browser router and that's the one that we've been using this is actually that silly Star Wars app that we used when we were learning some search params I've cleared out anything that wasn't really relevant actually there's a couple other things up here let's get rid of those and you can see that what we were doing is importing browser router and then just creating an instance of the browser router component here well in order to use these new data apis we need to create our browser router in a little bit of a different way so the first thing I need to do is import something called called create browser router and maybe the astute amongst you would notice that with the lowercase C that means that this is not a component instead it's a function that we're going to run so I'm going to save the router that this function returns so I'll call create browser router and then save it as a variable called router now what we have always learned what we've always done is defining our routes based on a series of nested components but one thing that maybe we didn't know was happening under the hood is that this routes component it's actually taking every route that we have in here and it's just turning it into a plain JavaScript object or maybe more accurately it's recursing through all of the children of this routes component and it's turning every route and every child of those routes into an array of Route objects and those might look something like this let's say we have an array in this case we only have one route so this will be our route object and it's going to have a path which is just flash is going to have an element which is the home page component that we have there and if this were to have any child routes which it doesn't currently because it's just selfclosing but if it did then there might be a property called children and that would be another array of nested objects and so forth so this routes component behind the scenes in the source code of react router that's all it's doing with our routes here is it's turning them into an array of objects with nested arrays of objects and so forth so with create browser router we could go down the path of basically rewriting all of our routes in this case there's only one but obviously in the van Life app there's a lot more we could go through the process of converting all of those manually into an array of objects like this however in order to make things a little bit simpler for updating our code from a version prior to 6.4 up to version 6.4 and making use of the data layer apis they also included a utility function called create routes from elements so I'm also going to import that just to make my life a little a little bit easier since I already have my routes defined so we'll say create routes from elements and this is getting a little crazy I'm going to put each of these on their own lines okay so what we can do is when we call create browser router we will inside of there also call create routes from elements and this way I can put my route elements directly inside of the create routes from elements basically this function will turn my route component into an object and then it will pass that object to create browser router so basically it does all of that manual work for me to be totally honest if I were creating this from scratch without some existing routes already defined I'm not 100 sure which way I would use I'm so used to using components like this that I might just turn to that naturally instead of typing out an object or an array of objects and whatnot but I don't know maybe the standard way will be just writing out objects either way this should do the trick for us there's one last piece that we need to do and that is to get rid of our browser router because browser router was specific to the nondata layer API routers that we we could choose from we need to use something different so there's yet another thing we're going to import actually maybe I'll just replace browser router here and what I need to bring in is something called router provider and this is a component so I can get rid of my browser router and I can actually get rid of well actually I can get rid of everything here so we're going to create our new router and that's going to be by using the router provider and then we're going to pass a prop called router and its value needs to be the browser router that gets created from create browser router so I've said the word router too many times for it to make sense anymore but router equals router and then this can just be a selfclosing element and I guess let's cross our fingers we'll hit save and okay home page is still working and well that's all we have to test so I'm going to recap what we did because in the next lesson it will be a challenge to create the browser router just like we did here but for our van Life app so I have three new Imports router provider create browser router and create routes from elements I actually don't need this routes import anymore because I'm not using routes and then outside of the function where I'm going to be using this router provider I created a new variable called router the name of this variable doesn't matter and I'm calling create browser router and because I already had a route defined as a component like this I'm also using Create routes from elements that allows me to just copy and paste my entire route definitions right here into the new create browser router function that I'm calling then with this router variable defined I'm going to use the router provider and pass that variable to the router prop in my router provider component okay that's a lot to take in especially not having typed anything in this lesson so look through the code if you need to and in the next lesson I'll have you work on it yourself okay here we are back in the comfort of our van Life app your challenge is to change our router so that we can use the newer one that supports the data apis then we'll finally be prepared to start actually learning about the data apis and loaders so you'll need to import these three things that we learned about in the last lesson you'll need to create a router variable and I put a little note here just because in our example we only had a single route that didn't have any children but in this case you're just going to be copying over everything inside of our main route here and all of its children so that will go in your router variable which makes use of these different functions that we are importing and then you will replace basically everything in our app all the way through yeah everything with the new router provider that we imported I think you have plenty of hints here so I'm not going to make it too easy on you I want you to get your hands on the keyboard of course and practice everything you can practice so pause now and work on this challenge okay I am going to cheat and just copy these things we'll import those let's see there's a couple things we can get rid of let's get rid of our browser router and routes it will import those and then kind of clean up my language here and while we're at it I'll go ahead and put these on their own lines since we are running out of space okay that looks better now let's create a variable here we'll call it router and we will call create browser router and then so we don't have to manually go through and change all of these routes into an array of objects we're going to call create routes from elements and then I can just take my main route here and I'm actually just going to slide it up that creates our router and then I can replace our browser router with the router provider that will take a router prop and its value will be the router that we created above let's double check I'll clean up the challenge text and let's give it a shot I'll hit save and sure enough everything seems like it's working let's kind of navigate around our app a little bit and perfect so again we didn't change anything that will be visibly different on our page but fortunately we now can finally jump into learning about loaders which is what all of this has been a build up toward as always if you want to practice doing this again just to see the two different methods of creating routers you can scroll back to the beginning of the lesson and try it out again from scratch and as always when you're ready we will keep moving forward okay we're going to approach loaders just one step at a time the first thing we need to do is go to the page that normally would use a use effect to get data as soon as that page is mounted and what we'll do instead is export a separate loader function instead from that page that will fetch the data that we need for that page so I tried to make this as simple as I could I did move the home page from our previous example to a separate component just so we could get this even a little bit closer to what we have in the van Life app so here I have my home page and let's say I'm going to be getting some really basic data outside of the component that I have defined I'm going to create a function that I export called loader now with react router the name of the function actually doesn't matter a fun fact in remix it does matter it has to be called loader but since we're not using remakes we're using react router we can really call it whatever we want and the job of this function is to get the data that we want to get now to make things even simpler to understand the truth is it doesn't really have to be a fetch request per se I think it almost always would be but to keep it as simple as possible I'm just going to return a string that says the data is here we'll see when this comes full circle and how we actually get the data from our loader into our component in a couple lessons from now okay so it's really as simple as that we export a function whose job is to get the data that we want to have access to in our component for now we're pretending that this string is the data that we have fetched from some API next we're going to pass a loader prop to the route that renders this page the home page and we're going to pass in our loader function so let's go over to index in our case we only have one route that we're defining and notice that I'm importing home page as a default import from my home component I can also bring in my loader function that I exported as a named import or a named export over there and all I need to do now is to add a new prop to my route that's called loader and I will pass in the loader that I imported with my home page now think in the van Life app how we have multiple page Imports many of which will have their own loaders so I'm not going to be able to just import a named function called loader for every single one of them in our case it's fine because it's our only one but a really common practice is to rename it as you're importing it so I might say import loader as and then maybe say like home page loader and this should probably be lowercase and then I would change loader equals loader to loader equals homepage loader okay that's a great start it's not quite done yet but let's go back to the van Life app and give you a challenge so that you can accomplish those steps for the Vans page okay you're basically going to do the same thing that we just did but here on our van Life app it's not going to be exactly what we ultimately want but we're gonna iteratively get there so your challenge is first to export a loader function from the file that we're currently looking at for now we'll just have that loader function return the string Vans data goes here or something along those lines then over in our index.jsx file we need to import that function and we will set it as the value for the loader prop on the route that controls this Vans page pause now and work on the challenge okay let's export a function that we'll call loader and it's just going to return the string Vans data goes here and then over on index.jsx we will import it now that file was right here with the van so we will bring in the named import loader let's call it vans loader okay and down on our vans page which is let's see Slash Vans we are going to add our prop called loader and set the value equal to bands loader okay that's everything we are equipped to do right now let's go back and complete the circle so that we can actually pull in the data from our loader into the component where we're trying to get it the last thing we need to do in order to get this loader actually working is to use the use loader data hook inside of our component and up until now it may not have been totally clear what direction we're heading in because we have this random function that's inside of our component file and then over here we're importing it setting it up as the loader this seems a little bit out of place but because we've done that little extra work what's really nice about this is inside of our component we can use a hook called use loader data so I need to import that from react router Dom use loader data from react router Dom and I can use that hook to grab the data that is being returned from my loader so I can say use loader data and I want you to pause and just think for a second what do you think console logging data is going to show first think about it and then actually try to run it and see if what you thought is what actually happens well let's hit save and we get the string the data is here so hopefully that makes sense because whatever we are returning from our loader is exactly what will come back when we call use loader data so how is this different from using a regular use effect well because we are not doing our data fetching inside of the code of our component react router can delay the rendering of our home page component until the loader has finished its task so it's a slight change in the Paradigm of how things get loaded in fact if you look at the documentation react router specifically says we don't care how you fetch the data the only thing we are doing with our data apis is changing when the data gets fetched so how is that useful well we're going to apply what we've learned to the van Life app and then we're going to start making some major changes to our code which hopefully will highlight how beneficial it can be to use these data apis so let's do that next all right so let's do exactly what we just did your challenge is to use the use loader data hook to pull in the data from our loader function and then I'll just have you console log it inside of your component here of course it's not actually data yet we are eventually going to use the get Vans function which really gets data and use that inside of our loader for now we'll stick with what's here so pause now and work on this challenge okay let's pull in the use loader data hook and we will now let's do it down here we'll say const theta equals use loader data and then we will console log the data and if everything is connected upright then it should give us the Advanced Data goes here string let's open the console hit save okay Advanced Data goes here now notice that it logged it three times that's actually because we have this use effect it ran when the code first loaded and then it set the van State and so it had to reload the page again and I'm not exactly sure why the third one is happening oh because of set loading probably so we're actually going to address what's going on here but for now let's do part two which I'll type out right now so here in our loader instead of returning a string I want you to place a call to the get Vans function and return what gets returned from get Vans we're still pulling in the data and console logging it so really the only change should be what happens right here pause now and work on part two of The Challenge okay simply enough instead of returning this string we're going to place a call to get Vans which should return our list of Vans and then from our loader we're going to return that list events that came back from this function call everything else is still hooked up here so let me buy us some space here we'll get rid of that we'll hit save check the console awesome look at this we have all of our vans which came through in the use loader data now currently we are only pulling it in and then logging it we're not actually rendering that anywhere on the page we're still using the vans that we had pulled in inside of this use effect but this leads us to a really exciting thing and that is we get to delete a bunch of code we'll talk about why and actually make those deletions in the next scrim okay so instead of just console logging the data I actually removed that console log we want to use this data in the component so your challenge is to make use of the data here throughout the component instead of using our state and our use effects to fetch and to hold the array of Vans the first thing you'll need to make sure that you do is just to comment out this entire use effect block and then you'll need to figure out what other changes you need to make so that things start working again as a hint I personally would make a change up here near the top instead of going through and changing a bunch of different things down here below hopefully that's not too cryptic I'm sure you'll be able to figure it out I'm trying to be vague so that you have to really think about it pause now and work on the challenge okay let's comment out this use effect to start and then instead of going down and changing wherever it says Vans to data I'm actually just going to change here to Vans and then comment out my use state so let's hit save and sure enough everything is working we can go into the Vans we can set filters and go there this is still working awesome now if you did have a chance to play around with this a little bit you might have noticed something and that's if I go back say to the host page or the home page then I come back to bands I'm going to click it right now you'll see that there was a slight delay before our vans actually got loaded remember react router here is making changes not to how the fetch occurs but to when the fetch occurs like we saw in the slides say we're at the about page or some other page as soon as we click to the Vans page it's going to start the fetch request then and only after the fetch request has completed and the loader has gotten the data then it will transfer us to the Vans page and it will include as part of the use loader data hook the Json or whatever data it is that we pulled in from our loader function so what does this mean for us well that means that we get to do one of the most cathartic things that I think you'll ever do as a programmer and that is to delete a bunch of code for example we no longer need our loading State because we are already here at the page and the data has already come into that page so I can just get rid of my loading state which means I can also I mean we saw first of all that this whole use effect we didn't need anymore we can get rid of that and we have this loading State down here that I don't need to handle anymore so we can get rid of that so let me clean this up too while we're in the habit of deleting things I also can delete my state instead of rerendering my component because I am setting the state with the data that has come in after the component was loaded I know that the data is going to be there when I pull it in with the use loader data hook in the sense I get to treat this much more synchronously instead of having to think about how the component needs to mount and then do a fetch request and then update the state and then to rerender because the state has changed I don't have to worry about any of that the mental model for this is significantly simpler not only that but I can still do my loader code right here in the same file where I'm concerned about the display of that data that gets loaded from my loader I don't know maybe you're not quite as excited about this as I am but this is a really nice paradigm shift now there is something that we lost when we deleted our use effect and that is that we are no longer really handling any errors remember we have that catch Block in our try catch that would set the error well because we deleted our use effect we're not doing that anymore but that wasn't a mistake because react router has a way for us to handle errors and it's very simple once you've had a chance to bask in the glory of having deleted all of that useless code let's spend a minute to learn about error handling when we are doing our fetch request before the page loads instead of after surprise we're actually going to do a quick quiz before we move on to handling errors so you know the drill pause the screencast click into each of these and actually type your answers and then we will go through all of these together okay number one when does the code in a loader function actually run unlike how code inside of a use effect runs which happens immediately after a component mounts to the page a loader function runs before react router allows the route to change and that new component to load so in short a loader function runs before the component loads and the route change happens okay number two what are some benefits of using a data loader function instead of fetching our data in the use effect in a component well one of the main benefits is we don't have to handle error state which again we're going to be talking about next we don't have to write a lengthy use effect that's part of our component code we also don't have to worry about loading State because we know this component won't mount to the page until the loader has already completed its task or in other words react router will delay the transition to that new route until the loader has finished its task we know that when we access the data with use loader data we will have access to the data as if it were happening synchronously so we'll type something like that down okay number three what change do we need to make to our browser router before we can use loaders or really any of the new data layer API features in our app I guess the wording of this could be a little bit like a trick question because we just need to get rid of our browser router and we need to use one of the accepted data routers instead so we need to get rid of the browser router altogether and we need to use the create browser router function instead if you're really wanting to jump both feet in to the new system you can choose to use create browser router with the array of objects as we discussed in the lesson you can find more examples of that on the react router docs or if you already have some prewritten code that you're trying to transition to this new router using create browser router you can use that function create routes from elements to help you make use of the code that you've already written okay and then lastly what are the steps we need to take in order to use a loader on any given route first we need to define a new loader function and Export it usually it's defined in the same file that our component is being defined in and so we can write that down we'll say Define and Export a loader function secondly we need to import the function that we just exported into our route definitions and set it up as a loader on the route that we are trying to gather data for okay and lastly we need to use the use loader data hook inside of the body of our component so that we can get the data that was fetched or produced or evaluated or whatever it is inside of our loader function okay that was a lot of information but hopefully it sunk in okay when you're ready let's talk about error handling okay let's see how we can actually handle any errors that might happen now this example might be a little simplistic because we're not getting any data that will ever fail because javascript's probably not going to fail just returning a string like this so let's see what happens if I were to just manually throw an error we'll say maybe throw new error we'll give it a little message that says this is an error I'll comment out my return even though it'll never get run because I'm throwing an error manually let's see what happens I'll hit save okay we have an unhandled thrown error this is an error it tells you some of that information about the error and then it even has a little message here that says hey developer you can provide a way better user experience than this when your app throws errors by providing an error element prop on your route okay so what does that mean well if we go over to index.jsx here on my route you can see I've put things on their own lines to buy myself a little bit of room we have this element prop which is basically what element should I under assuming everything is going well well we can also add a prop called error element let me just hard code something for now maybe just an H1 it says there was an error and let's hit save okay we get there was an error this is our H1 that is being rendered instead of the element that was supposed to be rendered because our app is experiencing some kind of error one thing that's neat about this is it will handle more than just an error that's happening inside of our loader for example let's say our loader is working just fine but for some reason we maybe try to access a property of an object that doesn't exist or a function that doesn't exist or something like that and that throws an error here so let's say we're throwing a new error this is a common one we'll say undefined is not a function this is just pretending that we're trying to call a function that we think exists but it's actually a value of undefined now we're not actually using this message anywhere but let's hit save and we get our error element that we set up here so I guess the point of this is the error element will happen anytime your component that you're trying to run has any kind of error it could be an error that occurs in the loader or it could be an error That's Just Happening inside your component just spitting out an H1 that says there was an error isn't the best user experience either but hopefully you can see that you could tailor a a welldesigned and hopefully helpful error component that will display some really useful information in a nice way that isn't quite so jarring as what we have here okay so let's go back to the van Life app and we will bring back the ability to do some error handling by using an error element in our route okay let's apply what we just learned about the error element prop and we'll add one to the Vans route however you're going to do a little bit more than we just learned about this time instead of just putting the H1 directly inside of our error element I want you to create a completely separate component up here in the components folder that you can just call error.jsx at this point we're not going to get much more complex than just rendering an H1 that says something like an error occurred and then you'll want to import and use that error component as the error element on the Vans route remember right now our error is coming from the fact that we have just hard coded an error response when we try to get the vans from the slash Vans route so let's go back here to where you can see the challenge pause now and add an error component to our vans route all right up in our components I'm going to create a new file called error.jsx we will set that up and like I mentioned we're just going to return an H1 that says an error occurred we're going to revisit this later and beef this up we're going to see how we can make this a little bit more useful but for now this will do the trick over in index.jsx we have done step one so let's do step two we're going to import the error component oh and I refreshed it so now we have an error but let's uh call this error and down here maybe just right below the element we'll create an error element and we'll create an instance of our error okay so when I hit refresh react router will see we're at the slash Vans route that has a loader attached to it so it's going to run the Vans loader the Vans loader makes a fetch request to the slash API slash Advanced endpoint that we have on our mock server and the loader will interpret the 400 response as a problem let's see that's in the API git vans so in API yep it'll be not okay because 400 response with fetch is not okay and so it will throw an error and because the loader through an error it's going to search for an error element and that's the element that will get rendered so let's give it a shot we'll hit save an error occurred awesome so it worked as we would expect but right now just having an H1 this is an error occurred is not all that useful and we did take the time to provide some additional information in the error that we're throwing like having a message that at least says failed to fetch Vans that's a bit more descriptive than just an error occurred so how can we get the information from the actual thrown error to display on our page well that's what we're going to learn next all right let's learn how we can actually take the information from the error that got thrown and display that on the error element that we have set up at least that way we would have some additional information to display that ultimately would lead to a better user experience even though they're suffering through an error at that time when we have an error element that is catching an error there's a special hook in react router we can use to display information about that error so let's go to the error component that we just created and I'm going to import a utility hook called use route error that comes from react router Dom then just like some of the other hooks we can just grab the error we'll say that's equal to whatever comes back by calling use route error and let's go ahead also log the error to see what we get I hit refresh open the console okay look at what's in the console we have an object with a message a status text and a status properties I want you to think where did that object objects come from well that's the error that we threw from our api.js file we said try to get the vans in this get Vans function by fetching the data from slash API Vans and if the response is not okay in other words if it's not a 2 or 300 level response then throw this object as an error and so that object is what we're catching inside of error.jsx if we use error.jsx in multiple places then it's possible that this error will come back different so we would want to make sure that as we're throwing errors inside of our API that we're doing it pretty consistently preferably with a message status text and Status properties that said we're just going to be doing this in one place for now so I'm going to give you just a really quick challenge where you can use the information from our error object to have a little bit more of a descriptive error message let me type that up now okay so simply put use the error object that we just got from use route error to display something a little bit more helpful in our H1 here in fact you don't have to stick to Justin H1 you can go a little beyond that and design it however you want pause now and work on this challenge well the error has a message property so why don't we just go ahead and we will include the error.message as part of our H1 let's see what that would look like okay failed to fetch Vans is already better maybe I'll say error colon just to make it clear that that's an error and you know what I'm going to bring back my console log of the error here we also have a status text property and a status property this might be more interesting to a developer instead of the actual end consumer but I might want to put something like I don't know I'm curious what it would look like if I put it inside of a pretag so we'll say maybe we'll put the status so this is error.status and then a dash and we'll say error.status text see what that looks like well the pretag definitely makes it look like it's an error it's obviously not very beautiful but the point is we have an error and it accurately conveys that message to the user and to the developer okay let's get rid of some of our extraneous things here and awesome now we could make this a little more robust if we wanted to maybe check for the fact that there's a message property on here and if not then we could have some kind of generic error message and same goes for the status and the status text maybe if those don't exist on our error that we pulled from use route error we can either just omit this pretag completely or have some other kind of message there at this point I'm not going to worry about that too much along those lines if we did want to make our error a little bit more generic an important thing to know is that even though we are growing the error inside of our loader for the Vans path and that is the same place that we have our error element we can actually set up the error element to live on a different level in the hierarchy of our routes what I mean is we could say let's get rid of the error element here on the Vans path we could put it up on the main path and let's see this needs to go right there and by doing this any error inside of any child route let's say it's even the most nested child route way down here any error that gets thrown will bubble up to the nearest error element in the route configuration here so even though my error element does not live on the same route that has the error being thrown I can hit save and the error element will still correctly catch the information where the error was being thrown now in this case because we put it on the same level as the layout our layout is not getting rendered and so we no longer see our navigation bar or our footer so you'll want to be strategic about where you place your error elements but the important thing to know is that at this point this error element would now catch any error anywhere in my app even if it happened way down here if instead I put the error element down here on my what is a slash host slash band slash photos route any error that's thrown from this Vans route is not going to get caught by an air that's way down here in the hierarchy this way you could have multiple different error elements Each of which can be sort of a fallback depending on where you want that error element to show up maybe you want most of your page to show up and just one little nested portion that had the problem could show that there was some kind of error the options are basically endless and you have as much flexibility as you need to make those error elements and error boundaries work the way you want them to work in the meantime I'm going to move this back down here and as always at this point play around with the code make sure you understand what's actually going on you can come over here to api.js and mess with the error that we're actually throwing and see how that affects the rest of the app you can come to server.js one thing I did at one point was to choose a random number and to half of the time have it return an error and half of the time have it returned correctly just play with the code the more that you get your hands on it and mess with it and see what breaks and then go ahead and fix it the more you're actually going to deeply understand what we're learning about so since we've moved our error elements I'm going to hit refresh to see the updated View and when you're ready we will move on to the next topic in order for us to talk about some of the last remaining topics we have yet to learn in react router 6. we need to include some sort of authentication and there's a bit of gray area here because this isn't a course about authentication but we need to have authentication implemented at least in a very basic way in order for us to talk about those topics in react router 6. so this is a design for the login page that we're going to create and in fact I've already created it for you Hallelujah and so instead of throwing you into a bunch of code that I just wrote for you I'm going to walk us through it step by step so you know what steps I had to take to create this form and get it all set up it doesn't do anything yet we're going to be adding to the form but it's just a basic form right now the handle submit which happens when the button is pressed you can see right here the form on submit runs handle submit it's just console logging this form data this form data is just some state that we created right now it doesn't have anything in it it's just an empty email and password we have a handle change function which is going to run every time there's a change on either of the inputs this is just so that react is maintaining State for the login form data on every change and that's basically it for now with the form because the button is here inside of a form element it will trigger a submit event on the form I of course added a bunch of CSS that you can feel free to go to index.css to look up but the other piece is in our index.jsx I imported the login form and I set up a login route on the top level and then in the header I just put this little icon which is living up here as Avatar icon in our image Assets Now why do we need some form of authentication to talk about react router 6 well the main reason is this host route we want to make it so that this host route is a protected route which means you have to be logged in before you can go to this host route right now we sort of naively have this host route up here and you're able to see all the Vans whether you're logged in or not and in fact if you remember this is hardcoded the Vans to be the user with the ID of one two three I think in our user host Vans where the host ID is one two three so it's all pretty naive just for the sake of what we learned already but let's learn about protected routes so that's what we're going to be doing next I am coming to you from the future I've actually already finished recording and editing the end of this course but I did become aware of an issue that you'll likely come across time and again throughout the remainder of this course it's relatively minor it's not that big of a deal but I did figure out what was going on and thought it would be good to give you a quick update on that so you'll notice that right now I just imported this Avatar image and everything seems to be working fine but if I go a couple levels nested deeper into my URL and then hit refresh you'll see that the image breaks now in the past scrimba has done okay to just put the relative path to the assets right here inside of the source of an image element and in the past I've had to do that because the bundler that was bundling this code under the hood inside of scrimbo was webpack and I guess it was just kind of able to make this work however this was a constant source of questions from students because when you're following Along on your local machine you'll find that this just really doesn't work very well now a quick fix here on scrimba that I guess I could have done is just get rid of the relative path and have it be absolute to the root of the project so if I hit save you'll see that now my avatar image comes back that said now we are bundling all of our projects with Veet it is much faster and it's just overall better than webpack and now that means that I can inside of scrimba actually do things in a bit more of a realistic or correct way because when my project gets bundled up my assets might end up moving or getting renamed and having this hardcoded string here really won't handle the shifting around of our files very well and so the real way to do this is to import any assets that you need to use inside of your markup and I can do that by just saying I want to import let's call it image URL from and then we will just grab the absolute path to the image and put it in there and of course this is different than what you might be used to seeing because we're used to importing JavaScript functions and components and everything like that here we're importing from an npm package and elsewhere we're importing from our own JavaScript or jsx files but just know under the hood Veet is able to handle this and apparently I didn't know this until recently but apparently scrimba is also able to handle this internally so if I just take this image URL I can now use this as my source and that way when it gets bundled it will just have the correct path and file name and everything so that it works just fine so even though we're still in this nested path I can hit refresh and my avatar is still showing up so if you are following along locally then please just do it this way ignore the silly way that I had it before and excuse any times in the remainder of this course that you see the little broken image icon up there it doesn't happen terribly often but it does happen sometimes okay let's keep forging ahead it's time for us to venture into a topic that is often called protected routes as a pretty important caveat to this section it's important to know that protected routes is not really uh specifically created API that exists in react router but rather it's a paradigm or a pattern that you can use in order to protect certain routes so what do I mean by protected routes well the purpose of protected routes is to stop data fetching of sensitive information so that only logged in users can access their data and maybe on top of that the users can't access other people's data in any given website there's going to be information that you want publicly available and then there's going to be userspecific data which oftentimes needs to be protected through some kind of authentication the user needs to be logged in to see that data now at this point we're at kind of an interesting fork in this course because we have transitioned to using a data router and we've already started implementing loaders in our van Life app however I think it's going to be useful to see how this issue of creating protected routes is solved both with a data router like we're using but also in a more traditional sense when using the older routers that existed before react router introduced the data routers in version 6.4 unfortunately the approach to creating protected routes is very different between the two and so I think it's going to be helpful for us to see how we can do it not using a data router first and then we're going to see how we can use it with data routers we won't dive very deep into the nondata router version only because it won't apply to us throughout the rest of this course with our van Life app and then naturally we will dive a bit deeper in how we can create protected routes using the data routers in order to help us understand why the approaches are so different we need to remember what is happening when we're fetching our data if we're using a use effect in order to fetch our data then first what happens is we transition to a new page and then the fetch request is kicked off this means that the Vans page has to take into account the fact that there's a loading State and maybe an error state in case the data doesn't come back correctly and then after that fetch request is completed the Json will get sent to this component it will rerender and then that rerender will maybe set the loading state to false and it'll set the list events into State and therefore render the list events in react router when you have nested routes that are all displaying on the page at the same time sometimes it's possible that you end up with something called a request waterfall this screenshot comes from the remix homepage and if you click it you can go to a link there and see a much more interactive version of it that will show you side by side what a request waterfall looks like versus how remix and by association react router handles data fetching but here what you can see is we have a side navigation which might have some kind of loading State and in order for the rest of the nested a route to load this first needs to load then when this part loads or rather the sales nested route loads then and only then can we start kicking off a request to get the list of invoices once the list of invoices loads then and sometimes only then can we kick off another request in order to get the specific invoice that we're trying to see so this is where the name request waterfall happens because everything has to wait for the previous one to finish in order for the next one to start so I'm not necessarily saying our van Life app is set up exactly this way we're using some workarounds to kicking off this many requests but it's just important to know that this is not an uncommon thing in react apps so when we have a series of protected routes or routes that we only want a logged in user to access in the more traditional setup for react router a very common approach to creating protected routes is to prevent renders from happening of those protected routes or those components that have sensitive information so if the user isn't logged in then we stop the data fetching by just blocking those components from rendering in the first place and instead send the user or navigate the user to the login page and since that fetching is happening after the components are rendered to the page inside of a use effect for example if those components are prevented from rendering in the first place then the fetching will never happen this might look something like this you have your home page and then you have a series of protected routes we only want users to get to the host page or any of the nested routes under the host page if they're logged in so what this looks like is we can introduce an auth required layout route maybe to be clear auth required is just an arbitrary name that I came up with but it is a layout route that wraps all of the protected routes and the job of that auth required layout route is to check if the user is currently logged in if the user is logged in then it will allow the nested route components to render to the page and therefore they are then allowed to trigger any kind of fetch requests that they might be doing however if the user is not logged in then it's just not going to render those and instead it's going to navigate them to the login route so for the sake of completeness we are going to take a look at what this approach might look like in the code but then we're going to talk about why this doesn't work for us when we're using loaders inside of a data router with react router so in the next scrim we'll take a quick look at how we might implement this auth required layout route let's see one way that we could implement this auth required layout route in order to protect any nested routes that we don't want an unauthenticated user to access at this point you should be familiar with the concept of a layout route here we can see that we have one route that is wrapping all of the other routes in our really simple app here that only has two routes a home and a protected route and as you know the job of this layout route for example is just to create some shared user interface that will be consistent throughout any of its children routes if we go to that layout we can see that it just has a navigation and then it's got this main tag and it wraps an outlet and the job of the outlet of course is to render any children routes that match the current URL and while this is how we have been using layout routes so far there isn't anything stopping us from creating a layout route that can do some logic and conditionally either render the outlet or alternatively in the case of what we're doing here with protected routes instead send the person or navigate the person to a different route entirely so let me go in here and create a new component I'm going to call it authrequired.jsx and we'll go ahead and get this initial layout component setup then before we actually start working on the code inside of here I'm going to go and actually wrap my protected route inside of this auth required layout route so I'll need to import auth required and then we'll set that up as its own route which will be a parent of our protected route in this case we don't need to worry about anything dealing with a path because all we really want is for the elements to get rendered which will then as we'll see conditionally render either this child route or we'll navigate the person to the login route which we don't have a login route here but we'll get there soon okay so my element will be the auth required component that we just created we'll hit save we'll see that nothing is going to show up if I go to protected because I'm not rendering an outlet over there so let's go do some more work over here we'll import the outlet component from react router Dom and then just for the sake of taking things one step at a time we'll just go ahead and immediately return this Outlet of course this means that this auth required is not performing any kind of work or creating any kind of benefit but now I can go to protected and I can see my protected route component here again one thing I think could be helpful at this point is to just start making a few few comments as to how we're going to implement this auth required protected routes component because at this point we don't have any real authentication set up we're going to sort of fake our authentication so we'll say first we're going to fake our authentication that'll make more sense in just a minute and then we're just going to have some simple logic we're going to say if the user is not logged in then redirect them to the login route and otherwise we will return the outlet so here we are doing a check to see if the user is logged in and if they are already logged in then we just return the outlet as we normally would have expected kind of like we were doing right here and as we just saw in the comments if they're not then we'll simply redirect them to the login page like we show here now we've already covered quite a bit of ground in this scrim so if you feel like playing around in the code you're more than welcome to and when you feel ready we'll move on to the next lesson where we will actually Implement some of this logic you might be asking yourself how are we going to fake authentication well I'm going to take the shortest shortcut we can and say is logged in is true because this isn't a course about authentication specifically in one form or another we're going to be faking our authentication kind of similar to this so I hope that's not too terribly disappointing but it should help keep our focus on react router and how to build something in react router like when we're creating protected routes okay and then simply enough with the rest of this logic we can just use a conditional and say if the user is not logged in then I'll go ahead and move this up here and we can just get rid of this I could have an else and say Return Outlet but because we are going to return something from within our if I can just consider that an early return and then I don't actually need my else because if I'm returning in here then this return will never get run okay so how are we going to redirect the user somewhere without any kind of interaction on their part well you should already be familiar with the link component the idea of the link component is that when you render a link and the user clicks it then it sends them to another route in react router well react router also has a bit more of a forceful version of that which is called navigate and it is a component and if the navigate component ever gets rendered by react then it will immediately and automatically send the person to a new route that you specify in the navigate component simply enough I can just say I'm going to return an instance of the navigate component and just like with link there's a prop called two there's also a prop called to in navigate so I can say navigate to slash login now remember we don't have a login route registered in our router quite yet but we can still test this so I'll hit save remember I have hard coded that my authentication is currently set to true or my is logged in variable is set to true and so I'm able to get to my protected route just fine let's go home we'll change this to false I'll hit refresh and try to go to protected and we'll see what happens and okay this is great although we don't have a login page and so we get this 404 not found but the point is it sent us to the login page remember the approach we're taking is to prevent renders entirely of the protected routes and that's exactly what our auth required component has done here because it's wrapped as a parent component or rather apparent route to our children routes that are protected it intercepted the rendering of this route or rather this H1 here it's not really even its own component and before it ever allowed that to be rendered by returning this Outlet it instead sent us to the login page by doing this if we did have some sensitive information that was living inside of this component against just an H1 but imagine that this is a component that's doing some kind of fetch request to some sensitive information by stopping this from Ever Getting rendered it's not going to kick off that fetch request now before we move on it's I think important to remember that this is the approach that you would use if you were not using the features that come with the data layer apis and the data routers technically we're using a data router because we're using this create browser router function but we're not using any loaders here and the fact that we're not using any loaders means that it's okay for us to do it this way however once you introduce using loaders inside of any protected routes then everything kind of changes so as I mentioned this is about as far down this path as we're going to go I think it's really important to see this because at least at the time of recording this is the most common way that you will see people accomplishing protected routes and that's only because most of them are not using these data routers quite yet however for us we are going to jump into the future and actually use loaders and see how we can accomplish protected routes when we're using loaders it's that time again let's run through a quick quiz that deals with protected routes like before I want you to actually click into the lesson here and type down your answers and when you're done you can hit play and we'll go through the answers together so pause now and work on the quiz okay so how did we change our route definitions in order to protect certain routes from an unlogged in user well the first thing we did was to wrap all of our protected routes in a layout route that has some logic inside of it that will protect those routes if the user is not logged in with the next two questions we'll talk about how it actually protects those routes but for now for answer number one that's good enough I guess one thing we can be a little bit more specific about is that the way in which it protects the routes is by redirecting the user if they are not logged in to the login page okay number two what component can we use to automatically send someone to a different route in our app well that would be the navigate component if the navigate component renders at any time it will automatically forward them to the location or the path that we specify in the to prop so I can say navigate to slash login for example okay and lastly what component can we render if the user is logged in well if they're not logged in we will render the navigate component but if they are logged in then because we have wrapped a layout route around our protected routes we want to use an outlet in order to render the contents of the route that they're trying to reach okay short and sweet let's keep moving forward okay so let's start seeing how we can include protected routes when we're using these new features with the data later apis loaders and actions and so forth as a reminder if you're using a loader for fetching data the fetching actually happens before the route transition and before the target component the next component that you're trying to route to actually renders to the page this means if you were on the about page and you wanted to go to the Vans page when you click the link to the Vans page it's going to kick off the fetch request from the loader of the Vans page first before it ever transitions or renders the Vans page it gets the data and it includes it immediately inside the the Vans page A major benefit of this is that we don't need to check for the loading State because this component will only ever be rendered to the page if the loading is complete and there are no errors which also means that we don't have to necessarily check for the error State we can handle that in a more declarative way inside of our route definitions we saw the diagram from the remix website of a request waterfall and if you went to the website to look at that diagram you would have also seen what it looks like to load things in parallel another benefit of having these requests available to the data router before the routes even load is they know how to run your fetch requests before ever transitioning to that route so in remix which is what this diagram on the website is actually referring to but also in react router when you're using loaders if you have some nested route that you're trying to reach all of those fetch requests can happen simultaneously in other words all of the loaders that are required for your current route to display correctly are run in parallel they don't run one after the other but instead they all can run at the same time and then whenever the final one of the loaders finishes the entire completed page can render to your screen so I want to preface this by saying this is something that oftentimes leads to faster loading and arguably will also improve the user experience in the end so the reason I preface all this is to make it known that because all of the loaders for all of your routes will run as soon as you start the transition to that route it means that we can't put a layout route to wrap our routes and stop the fetch requests from running because they all just start running even before it transitions to that component we no longer can try to prevent the components from rendering because the fetch requests are happening before the opponent is rendering anyway so that means we need a slightly different approach to create protected routes when we're using loaders we're going to use a function that we are about to learn about called redirect and it's going to happen inside of our loader function so the high level overview is if the user is not currently logged in then we will run this redirect function and we'll send them to the login page inside of our loaders before any route rendering happens now at the time of recording this there is a downside to this approach and that is that the check for the currently logged in in user and the redirect has to happen in every single protected routes loader that said there is currently a proposal out there to include something called middleware inside of react router that would allow someone to run a function before any of the loaders happen again when I'm currently recording this that is not yet implemented into react router so I'm hoping in the future I can record an update that basically amends this and says now we can use this middleware to run this check instead but for now we'll just have to do a little bit of extra work in order to run all of our checks inside of every loader of every protected route okay let's see a diagram of how this works so with parallel loaders we might be loading something on our home page at which point we might go to a nested host page and all of these are going to load at the same time like we saw in that previous diagram and all of these loaders are going to check if the user is currently logged in now one of these loaders is going to recognize that the user is not currently logged in and so they will call this redirect function which will cancel any loading that's happening and it will never kick off a fetch request and instead it will redirect the person to the login page this way we still accomplish the goal of never kicking off a fetch request to protected data if the user is not logged in by the way the reason it's important not to even kick off this fetch request is if we did and the data came back if I were to go into my developer tools inside of my browser and look at the network tab I could potentially get access to sensitive information that I'm not supposed to have access to okay that's enough Theory let's actually jump into some code and see how we can implement this you should be familiar at this point with the concept of adding a loader to our routes typically we have a separate component and in that same file of that component we can export a function called loader and then we set a parameter or a prop on our route that's called loader and we just say this is the home loader for example for the sake of brevity and being able to see everything in one place instead of having a separately defined component and a separately defined loader function I'm just going to inline my loaders so let me create a loader here as well and I'm just going to make these some asynchronous functions for now and we'll just use an arrow function and open up the bodies now it's pretty important that you return something or even if you return null from your loaders because otherwise react router is going to complain we can see here you define a loader but you didn't return anything from your loader please return a value or null so the first thing I'm going to do here is just return null so we can get rid of that error suppose the homepage one isn't quite as important to us at this point so we are going to focus on our protected route loader similar to what we were doing in our auth required layout route which I left here just to be able to see but you'll notice that I've removed it from our route definitions similar to what we were doing over there we are just going to fake our authentication and so over here I'm going to say on the top line of my loader for my protected route that const logged in equals false for now actually let's go ahead and start this with true okay and then similar to what we had before I can say if we are not logged in if not is logged in then what we want to do is to redirect the user so I'll just put that as a comment here now because this is happening inside of a loader I don't need to then do any kind of other redirect or anything the loader is already the precursor to this route loading or rather this element being rendered to the page now how do I do this redirect remember right now I'm not not inside of a component I'm just inside of a regular async function which means I can't use the navigate component I can't return navigate because I'm not inside of a component that is ready to render anything to the page because of that react router gives us another utility function that is called redirect and so I can come down here and I can simply say we're going to redirect the user to slash login now a common Paradigm that I have found in my discussions with some of the core team at react router is that many people will actually throw this redirect instead of just doing a return I assume it's because it's kind of conceptually similar to a server that would be returning a 400 level error that says that the current user is not authenticated to access that endpoint either way we're not going to see that throwing our redirect is going to make that big of a difference so because it appears to be convention I'm just going to leave it there okay let's see what happens I'm going to hit save I'm going to try to go to protected and well of course that worked because we hard coded that the user is currently logged in so it's good to know that our protected route Works let's go ahead and change this to false and hopefully actually let's go home first hit refresh and I'll click protected and perfect that takes us immediately to the login page now I think this is pretty neat but I want you to pause for a second and think about this if I hit the back button where is it going to take me because the loader intercepted the direction to the protected route and before that could even render it sent me to the login page if I hit back it's going to take me back to the home page where I was before I attempted to get to the protected page I think the benefit of this is going to be a bit more obvious when we finally get back to our van Life app and start applying what we've been learning but conceptually I think this is pretty neat because the loader is running before the route transition ever happens okay we're almost ready to jump back into van life and start implementing this I'm excited to get your hands back on the keyboard I know I've been talking for a long time while we have this set up here I think it would be pretty interesting to see for just a second what we're talking about when we talk about parallel loaders and so I found a way that I can demonstrate this and we're going to do that in the next scrim okay do you remember when I was talking about how when you have nested routes how the loaders for each of those nested routes will run in parallel well we can see this in action by kind of Faking the concept of a fetch request but first we need a nested route and we don't have that per se we have this index route and then we have a protected route let's go ahead and turn our protected route into a parent so we'll close this as a separate component and then I'll create a new route and this one will say the path is I guess it really doesn't matter we'll just call it nested and it'll just say nested protected route okay I'm going to create a loader for this one as well so let me put these on their own lines create a loader that looks just like the other ones it'll be an async function okay let me get rid of the authentication stuff that we're doing up here for now and instead well let me move this return null because that's going to be important to be down there and we're going to do something fun in each one of these we're going to create a random number and then we're going to use that random number as part of a set timeout so timeout takes a function to run so we'll do this and then the second parameter is the amount of time it's going to wait before it runs so we'll put that random number in there the idea here is that we will run this function at a random amount of time between 0 and 1 seconds so that sometimes this protected route up here will have a let's do we'll just say console log protected route and down here we'll say nested protected route so sometimes this set timeout will finish first and sometimes this one will finish first and if our loaders are truly running in parallel instead of in sequence then we should sometimes see this console log first and sometimes see this console log first so I'll open up my console and we'll hit refresh but first we have to go to our protected route actually that's only going to run the protected one so let me type in slash nested at the end and I'll hit enter and okay so this time we got protected route first and then nested protected route this helps us see that multiple loaders are running one for this parent route and another for this child route but now let me just keep hitting refresh until we see something different well one thing I can do is make the spread a little bit greater we'll say maybe times two here let me hit refresh again okay here's an instance where the nested protected route finished first before the protected route this really does show us that react router is not waiting for this loader to finish before running this loader but instead both loaders are running at the same time okay that was a lot of work to get to maybe a bit of an underwhelming result but if you're a nerd like me it's kind of cool to see that these are running truly in parallel and it also helps us better understand why we're having to take this different approach as opposed to just putting a parent Route Around the other ones because if we imagine that these loaders are instead of console logging something they're making a fetch request to protected data then we can see that they're both running at the same time and so I can't simply have code inside of my parent route that is trying to stop the rendering of my child route because the loader is happening before the rendering is happening okay we're done with that aside let's go back to our van Life app final and get your hands on the keyboard with a challenge and have you implement protected routes as we've learned in the last few scrims in our van Life app actually you know what I lied I'm feeling a bit guilty for how much talking I've done without getting your hands on the keyboard so before we go into something with slightly higher Stakes by going into the van Life app and having you implement what we've learned I want you to get your hands on the keyboard now while we're still here and simply rewrite some of the code that we just wrote so your challenge is to if the user isn't logged in redirect them to the login page if you need to go back and see how we did that that's completely okay pause now and work on this challenge okay well you might have noticed that we are already importing redirect that's from when we did this before and all we need to do is check if the current user is not logged in so not is logged in then we are going to and in this case we're going to throw like we're throwing an error we're going to throw a call to the redirect function and it'll take us to slash login we have to keep our return null there just in case and so we're just going to keep that let's go ahead hit save we're currently not logged in because of this variable we'll hit protected and sure enough it takes us to the login page okay let's make our way back to Van life and it'll be your task to do the same thing over there okay we're going to try and take this one step at a time and unfortunately in this challenge you're going to get firsthand knowledge of that downside that I was talking about where you have to include a loader on every one of your protected routes in order to protect all of the routes and that's again just because they will always run in parallel as a reminder at the time of recording this there is a proposal for a middleware that would run before any loaders where you could instead write this authentication check before any of the loaders in which case you wouldn't have to write them in every single loader but as I'm recording this it's not quite yet a part of the react router API hopefully I'll be able to rerecord this in the future and update with some good news okay so I'm sorry this will be a little bit tedious of a challenge but it's going to set us up to make these protected routes for now don't worry about checking for anything dealing with authentication so that we can just take it one step at a time pause now and work on this challenge okay I am going to make use of multiple cursors here so first just because it will be a little bit long I'm going to put everything on its own lines and this is going to get significantly longer but that's okay okay the only reason I did this on its own lines is so that it would be really easy for me to include a loader on every one of these okay so we'll include a loader and for now we're just going to do an inline function here one thing to note about loaders is that they could either be an asynchronous function or not an asynchronous function I happen to know that it's going to be useful for us to make these asynchronous functions so I'm going to do that and I'll open up the bodies here and just return null okay I guess the main way we'll know if this worked for now is that we don't get any errors when we load okay perfect this was a bit procedural so in the next lesson hopefully it'll be just a little more exciting and will actually start including some checks for authentication and protecting these routes before we continue on with protected routes using loaders we do need to make a few changes to our host routes because although we have implemented the loader for our vans.jsx file we have not done that for our van detail page our host events page or our host van detail page these are all still using a use effect in order to fetch data I think technically we could still get things to work but it would be a strange mashup of these two different paradigms where loaders really should be what's used in order to get data for the component that needs it especially since we've already started creating some loaders over here inside of our route definitions so I'm going to walk us through a quick refresher on how we did loaders with our vans page and then I'm going to implement it in Van detail and then your challenge is going to be to also implement it in host fans and host fans detail so you might remember when we were doing this what we did is we exported a function called loader and all it does is return the promise that comes back from get Vans then we're using use loader data in order to get access to our vans so that we can then map over them filter them and do whatever else we need to do with them in our file if we go to api.js you can see that I have beefed up our API functions here just a little bit our get Vans function is now able to take an ID if necessary and so we're sort of overloading this function where we can either not provide an ID and get a list of all the Vans or we can provide an ID and get the single van with the ID that we specify and then we have a separate get host Vans function which is almost identical to this except it reaches out to slash API host slash Vans instead of just slash API fans okay so let's go to Van detail and refactor this so that we essentially do the same thing as we did over in Vans I'm going to come up to the top I'm going to export a function called loader eventually will see that these functions can be async if we want them to be I'll come back later and Implement that if we need to and all it's going to do is return a call to get Vans let's see let's go to Vans okay this is basically exactly what actually it's literally exactly what we had there now we need to import get Vans for that to work so we will import get vans from the API file however at this time because this is the van detail page we need access to the ID of the van that we're trying to get before what we did is we used the use params hook which allowed us to access params.id but since the loader function is not a component we can't use hooks inside of it hooks can only be used in components that get rendered fortunately we have immediate access as one of the parameters to this function to an object called perhemps and so this is exactly what you would think we will now have params.id so I'll go ahead and just console params let's refresh oh actually before that will work we need to go to our file here and set up the van detail to have a loader so we'll move these on their own lines say the loader is equal to we'll call it the van detail loader and then we need to import that so here we're importing band detail we will also bring in the loader as van detail loader okay let's give this a shot now I will hit refresh we'll open the console I'll go to Vans and then go to the van detail page and sure enough we get the object with the ID of one it looks like we have another errant console log hanging out somewhere and that's right here with console logging our location we'll go ahead and get rid of that okay so I have access to the params object it has a property called ID and so I need to make sure that I pass that in to my get Vans function and then I'll need to use my use loader data hook and that should get me access to a van object I think let's call it data we'll say use loader data and then we'll console log the data I'm going to comment out my use effect here and actually I'm going to put a set of semicolons here just so that it relegates these squiggly lines to the semicolon instead of making it look like our return is broken okay let's hit save awesome now our loading is freaking out a little bit because our van is not coming from State anymore because we are no longer fetching it so let's go ahead and call this van so that we can just reuse that name we'll comment out our state we shouldn't need params anymore because we're doing that in the loader and let's hit save oh of course I'm still trying to console log data we can get rid of our console log now okay our van is showing up so let's get rid of this code here and then we no longer need to check if van exists because we can be pretty confident that it is going to exist since we are loading it before the route ever loads or before this component ever mounts so we will get that in there fix up some of these formatting issues and let's get rid of our console log up here while we're at it hit save and cool okay now that you've seen how we can do this and how we can access the parameters directly inside of our loader it's going to be your turn to do this for the host fans page and the host Vans detail page so that's what's coming up next okay just like I did in the van detail page you are going to do for the host Vans page and the host Vans detail page currently both of those are fetching data from a use effect and we want to move that to a loader instead so that's exactly what your challenge is you can read it here one thing to note is that you will be using the get host Vans function instead of the get Vans function since we're dealing with the host routes now and also the inline loaders that we put let's see where are they right here and here for our vans page our host fans page and our host van detail page these inline loaders you'll just replace with the ones that you will import up above that you are exporting from those component files here give this your best shot if you need to look at the Vans or the van detail page that should help you quite a bit and then we'll go through it together pause now and work on this challenge okay we'll just clean this up because we know what we need to do we are going to export a function called loader we're going to return get host Vans and then we need to make sure we import that and this is coming from the API file okay we will also need use loader data while we're in this same file and we'll go ahead and grab the list of Vans we'll call it Vans just like our state so we don't have to make other changes down below at least not too many and that's going to be equal to use loader data we can get rid of our state we can get rid of our use effect always feels really good we're using the same variable name so that can stay the same and then here we were sort of naively doing a vans.length check to see if it was loading or not this of course just assumes that the host has fans in their array so we can get rid of that completely now and get rid of this completely we'll do a little reformat so much simpler and I don't need that curly brace either that feels really good to clean up that code okay we're not quite done of course let's go over to our index file and we will come up to the top and right here host Vans we're going to import the loader as as host Vans loader and then come down to our route which was this one and again like I mentioned we'll just replace the inline one with a named function okay that was a lot of work without checking how we were doing so let's go ahead and refresh and we can test this by going to the host page and vans okay our vans are coming in perfect so now we will just do the exact same thing for our host van detail and I'm going to fly through this pretty quickly we know we need use loader data from react router Dom we need our get host Vans function from the API file we're going to export a loader function we will need access to the params this time and so we are going to return get host Vans by passing in params.id we don't need use params but we do need we'll just keep calling it current van and that will be from use loader data we don't need our use effect we don't need to worry if there isn't a current van and everything else I think should be the same so let's go back to our index file we will import see where is our right here host fan detail will import our loader as host and detail loader and once again we will replace we can find it right here we have our inline we will replace it with the host van detail loader function we'll hit save and oh it looks like I got close but not quite there we'll see if we can figure this out oh you know what uh we are still using the current van State I forgot to get rid of my state we need to get rid of that because there is a duplicate declaration for it okay let's try again those fans click on one of them perfect okay hopefully that was good practice it's a good example of space learning and repetition that's been a minute since we've dealt with the loaders so this is kind of good to get the practice back in and now we're perfectly set up to finally go back to implementing the protected routes now that we're doing things a little bit more in line with how it should be done with using loaders okay so we have a task now that we're finally back to including protected routes in our loaders and those tasks include checking for the user's authenticated status which we're just going to fake it like we did before and if they're not logged in we want to call that redirect function that comes from react router Dom to the slash login page and I was about to write step three and realize that that's it I know that it seems like we're doing a lot of work here because of the way that our loaders are but we are going to see how we can simplify it a bit now rather than inside of every loader doing some kind of const is logged in equals false or true and then trying to duplicate that for every loader it makes a ton more sense for us to create a utility function whose entire job is to do these tasks so I'm going to create a new file that I call utils.js that's just down here at the bottom and we're going to create a function that's just called require auth because this is a custom function you could call it whatever you want and inside this function I'm going to use my fake login status so I'll say is logged in equals false and then I'll do my check that says if not is logged in then we're going to throw that call to redirect to the slash login page and redirect is not a global function we need to import it so I will import redirect from react router Dom and eventually we're going to do a bit more work in here but for now I think this should be good so let's come back to our index we're going to import our function that we just created that's require off from the API no from the utils file and then we do have the tedious task of including it in each one of our loaders now this brings me back to a point I made earlier about how our loader can be an async function what we currently have in our utils as this hardcoded is logged in value and this conditional check none of this is is an asynchronous operation in JavaScript this will just run line by line and it will run very very quickly however much more commonly in require auth we might be reaching out to a database of some sort or a server rather in order to ensure that the user is currently logged in and doing that may be an asynchronous operation and so we don't want require auth to kick off a request and then continue doing fetches in the loaders if the person is not allowed to access that information so although what we currently have is all synchronous we are going to pretend like it could potentially be asynchronous in turn require auth into an async function which means that it's going to by default return a promise and then we'll go over here and we will make use of all of our async functions by using a weight we're going to await require auth again even though we currently are doing synchronous operations with require auth at some point in the future we may not anymore and so it will be important that we wait for require auth to kind of authenticate the user before we do any kind of fetching requests inside of our loaders now most of these loaders are not doing any fetches and if they were doing fetches and if they are doing fetches we are importing them as functions that come from the components like this one right here so that leaves us with two different ways that we can make sure that we include this await require auth everywhere that needs it as a protected route and I actually think I want this to be a challenge because it is going to take just a little bit of critical thinking so let me type out this challenge your challenge is to include this await require auth everywhere that it is needed in order to protect all of our host routes and the nested routes they're in now one thing we can do just to simplify our code a little bit this return null is a little bit extraneous I can just say return await require auth and that should get the job done as well so I won't need two extra lines in which case because I'm using an arrow function I could simplify this by just having it do the implicit return on one line which would then look more like this okay so let me go to the home page in our utils we are hard coding that we are not logged in and so I'll hit refresh and try to get to the dashboard and sure enough it's taking us to the login page let's see if I go to slash host slash vans okay and we can see that I'm able to get to host Vans because we haven't yet completed those protected routes so that is your challenge include await require auth everywhere it's needed and it should make it because we're hard coded as being logged out it should make it so that you can't get to any of these host routes and you're probably going to have to type a bunch of them out just to test so one last thing when it does come to the loaders that we're importing things will have to change a little bit as opposed to just tacking it onto the inline loader like we've done here but I think you probably figured that out okay pause Now work on this challenge okay well I should be able to just copy this loader and put it on every line that is still using an inline loader so fortunately that covers a majority of our loaders here okay and then for the remaining two with our host fans loader and our host van detail loader we can go over to host Vans and we need to import our require auth from the utils file I'm going to copy this and just put it right over in host van detail while I'm doing this okay and then I'm going to make this an async function this might have been one of the trickier things but we did not make this async originally but now we want to make it async so that we can await require off alternatively we could just say require auth dot then and do promise resolution that way but I like the await keyword so we'll say await require auth that ensures that this function can run completely before it ever tries to get a list of the host fans okay and then I should be able to go to my host van detail make this an async function and do the exact same thing okay Moment of Truth we were able to get to slash host slash fans before because we did not have a protected route there we'll go ahead and refresh and sure enough that took us to the login page so if I try to go to slash host login page slash host slash Vans let's say slash one slash photos awesome login page also I feel like once again it's important that I point out that there currently is talks on better ways to handle this where we can include middleware to the loaders that will run before any of the loaders so that we will only have to do this in one place but for now this is what we have to work with and even though there is quite a bit of repetition here I still really like the way that loaders will run before the route Transitions and gives us a more synchronous feel to our components no longer do we need to remember about render cycles and what will cause and what won't cause a rerender in our component then having to set up error States and loading States and all these other things that were really just about managing the react render cycle and not about managing our actual data that we care to use so yes you might be thinking to yourself this is so much harder than just including an auth required component that wraps everything else but for one the benefits of using loaders in the correct way I think outweigh any of the costs that we have here and secondly we very likely might be getting a middleware solution to this problem okay we've been staring at this login form for a while now and we haven't been able to make any use of it now that we are set up correctly it's time for us to go in and actually make use of our form and I can promise you you are going to fall in love with the way that forms can be handled with react router using the data routers that we're learning about so that's what we get to look forward to next here we are back in our simplified app and what we want to work on next is have it so that when someone tries to go to a protected route that there's some kind of feedback that says here's why I sent you to the login page for example they tried to get to protected it sent them to login we should probably display some kind of message that says You must log in first we don't want that message to show up when they just go directly to the login page but if they try to go through a protected route and they are not logged in we do want to display that message now over in our auth required this is the layout component when we were doing that before we were using loaders you might remember that we have this navigate component when you're not using loaders you can just pass State similar to how we did with links earlier in the course you can pass State and that state could have a message that says You must log in first this works because when you get to the login page you can check the location to see if there's a state.mess message variable and you do that with the use location hook but now that we're not using the auth required layout route but instead we're using this utils JS in order to navigate or redirect people to the login page we don't have the option to pass a state message through this navigate component like we did before so how can we accomplish this when we are redirecting to the new location instead of using this navigate component well the most common thing that I have seen is to include a search program that includes the message that you want to send along to the page that you're about to load so in the require auth function here that's as simple as saying question mark maybe something like message equals and then we can include the message that we want to send so you must log in first okay let's see what this looks like we should be able to see that in our browser so I'll click protected and now if you look in the URL it says not just slash login but slash login question mark message equals you must log in first you might notice that it's not URL encoded if I hit refresh it automatically gets URL encoded where we have the percent 20 that's representing the spaces between the words but even if we didn't have that it would work just fine so let's go over to the login page and that is not a dedicated login page here it's just this H1 which means at this point it might be worth just throwing together a quick login component so I'll do that really quick okay so now I have this login component and then instead of rendering an H1 I'm just going to render my login component and now I should essentially have the same thing so I'll hit refresh login page goes here awesome okay now that we have a dedicated login component in the next scrim we're going to see how we can actually pull in the query string that's saved in the search param of message so that we can display it on our login page then once we've done that we'll go back to Van life and you'll have a challenge where you get to implement this in the van Life app let's see how our login component can consume the query string that exists up in the URL if it exists when it gets to the login page and actually what I want to do is have just a quick thought experiment for you I want you to think about this in our login component how should we grab the search param from the URL on the login page in the login component in order to display that message if it exists I'm not asking how we should display the message I'm asking how should we get the value from the search param of message so I'd actually like you to pause and think through this try to come up with an answer if you want you can even click into here and type down your answer so pause now and see if you can come up with an answer to this question well the first thought that you may have had if you remembered way back at the beginning of this course we learned about the use search for Rams hook which we can use inside of our component and then that gives us access to the search params and a function to set the search params and that's equal to use search params I'm mostly going down this path to show you that it should work just fine I can console Log search params and remember this search params is actually the native web search params Constructor or object and so it has a parameter called dot get and I can ask it to get the message and we'll go ahead and console log that so let's just give it a shot I'll hit refresh open the console and sure enough we get access to our search params that are in the URL however now that we're using the data router it can be really beneficial for us to just go all in both feet into really working with those apis that we get with the data router including using a loader so another way that we could get the search params let me comment this out is to include a loader so I will have a loader function and in this case I don't need to export it because I'm just kind of stuffing everything into one file here maybe just for the sake of keeping our names similar we'll call this the login loader and the login loader just like we saw before where it can have access to a params object it also will have access to the full request object this request object is a native web request object that you could just go to mdn and learn more about so let's go ahead and console log this request and I need to set my login loader up on my login page so we'll say that this has a loader that's equal to the login loader and just so we don't get that error we will just return null for now go ahead and hit refresh okay we can see in the scrimba console that it's a request object capital r request object which represents an object that has a request Constructor and in this case like I mentioned it's coming from the web this is not something specific to react router this request object has a URL property so I can console log that and we can see the full URL that does include the search params at the end if you look in the console there's the question mark message equals and then the HTML encoded you must log in first so what we can do with that request URL L is create again another native Constructor called URL and so I can use the capital's URL instructor which will give us a URL object and as I mentioned this again is just a native web interface that's one of the things that if you get involved with the new react router and the remix team they will constantly be telling you that they're just using the platform there's no need to reinvent the wheel when these tools are really amazing and they've been at our fingertips in JavaScript for many many years if you were to go to mdn and learn about URL you would also learn that you can access the search params object on top of that and that object is an instance of the search params Constructor also from the Native web so if I were to let's go ahead and console log this whole thing and we can see that I get an instance of URL search params this is exactly what we had down here where we can run this dot get message on top of it and so let's go ahead and add that on dot get message and we'll just console log that whole thing and sure enough we are back to a place where we have our message and I know that this looks a bit more verbose than what we had before but I would argue that what you're writing here is much more akin to Native JavaScript for the web as opposed to something that has been created by a thirdparty Library obviously loaders and the whole concept here this request object is being passed in by that third party library but in the meantime you have just become more knowledgeable on the native web so I think that's pretty cool again I'm probably just nerding out about this so I'm going to go ahead and well this is all chained together so I'm just going to return the message that comes back from this search params we can get rid of this return null and now I want you to think how can I grab the information from my loader inside of my login component in fact I'll just go ahead and make that a challenge okay so the challenge is to grab the message that's being returned from the loader right here and display it on the login page I'll go ahead and just erase these two lines and you can display it either I guess you only have two options it's either above the H1 or below the H1 and just go ahead and make it in H2 on the page pause now and work on this challenge in order to get information from the loader we need to use use loader data I don't need this use search params anymore so I will grab use loader data instead and down here I can grab the message from use loader data and let's go ahead and console log that message just to make sure that it came through okay okay we successfully got you must log in first but I am curious before we finish this up what happens if I just go to slash login instead okay we do get null okay so getting a value of null is not too big of a deal if I try to render an H2 that has the JavaScript value of null in it then it simply doesn't display anything but if you go into the developer tools it will show a completely empty H2 which feels a little bit extraneous to me plus I think it's informative to do a conditional render here so that other developers might see this and know that it's possible that this message will be null and so I am going to do that I'm going to instead of having just an H2 I'll go ahead and do a conditional rendering that says if there's a message then I will display an H2 that has the value of that message in it and this isn't long enough to be on its own line let's go ahead and just put this all in one place okay we're on the login page we'll hit refresh there's no message there because we didn't come from a protected route and then I'll click protected and awesome we get our message you must log in first now I know we spent a lot of time talking about this message but in the end all we did was we added this message inside of our require auth function we added a loader to our login page in order to load whatever data might be necessary to correctly display this page and then we did a conditional render if that message exists then display it in an H2 obviously we'd probably want to make it red or something that will stand out a little more okay let's go take all of this new information and apply it to the van Life app okay let's put together what we just learned by passing a message from the require auth function which is down here in the utilsjs file that says You must log in first and display that message in an H2 below the H1 that says sign into your account I wrote some CSS that just has a simple red class and so you can just add a class name of red to get some quick styling and yeah that's it I'm not going to go too much more into detail to give you a chance to think critically and actually write all the code you need so pause now and work on the challenge well we could start from pretty much anywhere but let's go to utilsjs and I'll just say we'll throw the redirect to slash login question mark message equals you must log in first okay easy enough then I could make a decision if I wanted to use the use search params hook I could do that and it would probably work just fine but again in an effort to really keep with the theme of loading any data that we need for our login component inside of a loader that's associated with this component I'm going to go ahead and Export a function called loader and I already know that I'm going to need access to the request and we'll just go ahead and chain everything kind of like we did before if it makes more sense to you to split it out where you get the URL and that's equal to the new URL of request.url and then you get the search params and then you return the value of message that's totally fine I'm just going to do it all in one so we'll say new URL of request.url that will give me an object of search params which I can use the method of get on and get the message okay I'm exporting this loader and before I can do any kind of use loader data I need to make sure that I go over to my route definitions and let's import it let's see here's our login so we'll import the loader as login loader and then add it to my login page which is right here near the top so my loader is equal to the login loader okay that means here I can grab use loader data and actually you know what I think this is a Remnant from when I was testing something before we don't need the used navigate hook right now so I'm going to get my used loader data we will do it right here after state which as a sneak peek I'm really excited to get rid of we're going to clean up this form quite a bit with the abilities that come from the new data routers so get excited about that now I can get the message by accessing use loader data and then just like I did before I will conditionally render it and we'll say if there's a message then we want to display an H2 that contains the text of that message and has a class name of red okay let's see how we did we're at the login page so we shouldn't have any kind of message when we refresh but now if I go to the host page which is protected by our require auth function I get that message in my URL and sure enough it shows up on my page I'm going to make a quick judgment call the H2 looks a little imposing maybe I'll bump this down just a tiny bit to an H3 okay that's a little less intense hopefully all that went okay I know that was quite a number of scrims just to pass this message here but we are going to be coming back and passing additional things as we are doing our redirect which will make the user experience even better but that's going to happen a little bit in the future for now it's finally time for us to come back to our forum and actually start learning about how forms are made so much simpler in react router if we use something called an action which is kind of a sibling to loaders so get excited that's what's coming up next I've got a bit of a hot take to add to this course and that is the fact that forms in react are just bad there's a number of libraries out there that attempt to make forms in react a little more bearable but the truth is they're just a really difficult thing to work with in react you can get used to it and you can get good at them but they're still pretty difficult and the reason is we try to build a system over the top of the Native input form elements that attempts to bypass the State Management that already happens natively internally by forms and brings that out into react and forces react to maintain all of that information you can see in this form which I copy and pasted from my learn react for free course that we have to create our own state that manages every piece of data that we're trying to maintain we also have this handle change event which is put on every single input and manually tracks any keystroke or change that happens to the input in order to update State and then we have to control the value so we have to tell the input that its value is what is being held in state and all of this is sort of extra on top of what is already happening internally from a form you see originally with forms you would have your form element you would give it a method so submitting the form would usually do a post request or a put request out to a server somewhere and you would add an action attribute which told it which endpoint to send that form data to and then that endpoint on the server would take that data it would process it and it would do something with it like log the user in or validate that the inputs were valid or create some new resource or anything that normally would be handled by a form so you've heard me talk about the full stack framework remix which was created by the same people who created react router and what they decided to do is to instead of completely subverting the entire purpose of a native form and overwriting it with our own logic I decided to use the native capabilities of an HTML form and remix in some more abilities with modern JavaScript and anyway all of this is to say that there's a perfectly good native ability for forms in HTML to maintain their own State and to submit their information so when the concept of actions was introduced in react router 6.4 we gained the ability to sort of go back to those earlier times when we could make forms in react a little bit easier to work with so in the next few lessons we are going to be refactoring the login form so that it can use this new actions feature from react router we're going to see an example of what I was talking about where forms in react are just pretty difficult to work with compared to Native forms which have their own State management system and submission abilities in HTML to do that we are going to complete a couple of challenges first of all I want us to hook up our form so that it at least kind of halfway works I've done a little bit of work for you behind the scenes over in our server.js file I've created a model for users and I've entered one user in the server the fake database that we have once again this mirage.js server file is not important for you to understand the syntax of but just know that I've created a user in our fake database it has the email of b.com and a password of p123 you can see of course we're just saving this raw password here which is never a good idea but that's beside the point I've also created this endpoint here for slash login which is simply finding the user in our fake database and if the provided credentials which is the email and password match the user in our fake database then it will return the user object and a fake token that we have here I've also created a new function inside of our api.js file called login user so this is the interface that you'll be using it makes the fetch request for you it handles any errors that might come back it will send those errors forward if there are errors but otherwise it will send that object that has a user in a token that came from the server so that brings us to what your challenge actually is your challenge is to pull in that login user function from the api.js file and then call login user as soon as the form is submitted passing the login form data that we are just currently are console logging and one thing to remember is because login user from api.js is an async function that means it's going to automatically return a promise in which case you'll either need to create a separate asynchronous function inside of your handle submit or you can just use the dot then syntax and chaining to log that data to the console and in case that wasn't clear from the first part in Step 2 you just need to console log the data that comes back you don't need to worry about setting anything else up at this point okay I think that's enough information for you to get started so pause now and work on this challenge okay let's import our login user function so we will import login user from see how far back do we need to go this is inside of the Pages directory so we'll go back one directory and get API I can spell it right API there we go okay and then instead of console logging our login form data I can just call log in user and I'll pass that login form data and I'm not going to bother at this point in creating a completely separate async function here like sign in or something I'm not going to worry about that I'm just going to use the dot then syntax and let's see we will get some data back and we'll consolid the data there might be a mistake or two here let's see how we're doing we'll hit save and we will enter b.com and p123 hit log in open the console and perfect there's our user object and the token that we were expecting this is the point at which you might typically take this user object and save it somewhere so that you can have access to it elsewhere in your application for example you might put it in context so that you can I don't know display the user's name or their email address in multiple places you also would likely want this token to live preferably in some kind of cookie although sometimes people might put it inside of local storage or session storage however we are going to be bypassing all of that for now because that's not terribly important for us when we're learning react router and clientside routing in general we're going to continue opting for kind of a fake version of authentication so we can see the routing aspects of authentication and then it will be up to you to actually Implement your real authentication in the way that you want our next step is to not just code up the happy path which is all we've done here we're assuming that login end user is going to work flawlessly so for the next part of this challenge we are going to code up the sad path all with the goal of embracing actions which I mentioned earlier is like a sibling to loaders which will allow us to really simplify our code and think about it in an entirely different way which I would argue is a much simpler way to understand so that doesn't mean that you can skip the next steps all of these challenges that we're doing here are still going to help make you a better react developer so I really implore you keep doing these challenges and then you will feel even more cathartic when we get to erase a bunch of the code in favor of something simpler so at this point let's move on to the next part of this challenge our job is never done as a developer until we have also taken into account the possibility of the sad path so that's what our challenge is going to be here you can see I even started this on number three because that's where we left off the job wasn't quite finished I won't necessarily read through all of these steps you should be able to accomplish everything and I've tried to specify where you might need to go to Google in case there is something in this challenge that you haven't quite tried to do before but that's okay that's the regular job of a software developer so read through these challenges one by one very carefully start working on them and when you're done with the challenge we'll come back together and work on it so pause now and code up the sad path for us okay let's go ahead and add a status State we'll default it to the string idle and let's see we'll just do that maybe right below our other use state so we'll have a status set status and that's react.use state with a default of idle there we go okay and then when the login form begins submitting set it to the string submitting and when it's done submitting whether it's successful or not set it to idle again okay so set it to submitting as soon as the form starts submitting so right here we will call set status we'll say submitting and it might be tempting to inside of my DOT then to open up that function and set the status back to idle however because we are working on the sad path and there's a possibility of a DOT catch that will eventually run I'm going to use a promise chain that you might not be quite as familiar with and that is Dot finally this is code that will run whether the promise resolved or was rejected and so in here I can set my status back to idle and that way it will go back to idle whether or not the login user was successful okay let's see that should do it for number three I'm just going to erase these as we finish them disable the button when the status state is submitting so this might have been one where you need needed to go out to Google for some answers but on button elements in jsx and well actually in HTML there's a property called disabled and in jsx I can set that equal to an expression and if it evaluates to true then the button will be disabled and if it evaluates to false then the button will not be disabled and so it says to disable the button when the status is submitting so we can say here if status is equal to submitting this will evaluate to a Boolean if status is submitting in other words if submitting equals submitting then that will be true and the button will be disabled and actually you know what this wasn't part of the challenge but I think I want to change the text to say logging in if it's currently in the process of submitting and so I can do that with just some basic conditional rendering I'll go ahead and separate these things out just a little bit to buy myself some room and then I'll open up an expression I'll say if the status is equal to submitting I'll use a ternary here then we'll say logging in and we'll do dot dot but otherwise we'll say log in here let's put these on their own lines like this okay and I think we should be able to test this now I'll hit save and I guess we can try b.com p123 we'll hit log in okay it said logging in for just a brief second it was a little bit hard to see and we still got our console log of the data back that's good if I were to maybe not enter any values in here that should be an error and okay we get our object here that is console logging with the no user with those credentials found I think we're getting a little bit ahead of ourselves but one thing that's nice is because our Dot finally is setting the status back to idle our button now says login again if we had only set the status to idle inside of our DOT then then it would probably be stuck in the submitting State because we never set it back to idle okay let's go back up we have done number four let's go ahead and erase that okay let's actually catch the error that comes back when we are maybe not submitting something or we have incorrect username and password combination so number five we need to add an error State and default it to null again we'll just do that with States so we'll have const error set error and that is react.use State and default to null when the form is submitted reset the errors to null okay so that's something we can probably just do here we'll set the error to null just in case there is an error and then the user fixes it and hits submit again we don't necessarily want that error to stick around that might not make a huge difference but we're just trying to cover all of our bases so we'll leave it there for now if there's an error from login user add a DOT catch in the promise chain then we need to set the error to the error that comes back okay so we have a DOT catch ready we'll catch the error and we will simply set the error to that error object that way we can save it in state we can start rendering things on the page age when that state changes and actually that's part number six so I'll delete five display the error.message below the H1 if there's ever an error in state okay so that would be right here kind of again to our previous message that would say you must log in so I guess we can actually you know what I'm just going to copy this line down and we'll say instead if there's an error in state then we will display oh look we're even using the same term so I can say error.message and we'll keep the class name of red as an H3 and yeah let's clean this up kind of anticipating that we did everything perfectly but we never know let's go ahead and hit save I'll just click login without providing anything and sure enough no user with those credentials found perfect if I were to say something like C at c.com we don't have a user with those credentials and put anything in for the password we should get the same thing and I guess one thing that's nice about clearing the error to null is that when we logged in it made that error message disappear which made it much more obvious that we are having yet another problem with no user with those credentials found and it's not just the same one that's from before by the way if you're wondering where this message is coming from in the first place since you didn't code up the api.js or the server.js editions that I made that's where they're coming from login user is making a request to fetch the data from API login it's passing those credentials and if there is an error on the server then it's going to throw this error which has a message property with data.message and that is coming from the server so we go to server.js and we can see that if there is no found user then we just return a 401 response and have a message that says no user with those credentials found which makes its way back to our front end and displays to the user okay that was a lot of work let's go check out the login page and admire what we've done and maybe admire isn't the right word because what we're looking at here is a ton of boilerplate code if you're using a thirdparty form library in react then you might be able to avoid a bunch of this also if you're using a fetching Library like 10 stack query formerly known as react query or SWR or one of those other similar libraries you might be able to avoid some of the spoilerplate code however we are going to see how react router has brought back our ability to use the native form element its internal state that it's already able to maintain its ability to submit that form and then we're going to process the data from that form and we'll see just how much simpler our form can get however before we jump into that I promise only one more thing we're going to learn and it's going to be very quick we're going to see that there is a programmatic way in which we can send somebody to a new route mostly so that I can check that off my list as something that I've taught you the way that we'll do this when we start using actions will be slightly different so like I said I just want to get it out there and consider it taut so that we can finally move on to actions this last topic is so simple to grasp that I'm actually not even going to bother including this as part of a challenge or an aside or anything like that I'm just going to show it to you because then we're going to jump into refactoring everything anyway we've learned about the navigate component from react router if we ever were to render a navigate component like this and of course I would have to import it from react router then it would immediately redirect us to a different route that we specify here so for example if I went to the slash about page if I hit refresh here on the login well I need to import of course I just talked about this let's import navigate okay let's try again okay so you can see it tried to load me to the login page and it immediately navigated me to the about page so that's just a refresher of that which we've already learned that is a component version of what we're going to learn which is a hook called use navigate if inside of your more programmatic code not the UI code that we have with jsx but rather the code that's actually handling the logic if in that code you want to navigate somewhere you can use the use navigate hook to get access to a function that I'll call navigate equals use navigate and this function when you call it will navigate you to a new route in fact under the hood the navigate component I believe is just using use navigate and calling the navigate function so instead of console logging our data here we might decide that we just want to navigate someone to the slash not about let's say maybe slash host page okay so I'll refresh I'll go to login and one thing that I did have to change is over here in utilsjs I made sure that this head is logged in is true that way it wouldn't forever redirect me back to the login page and let's see so be at b.com p123 login logging in and it redirects me to the host page there are options to navigate for example right now if I hit back I go back to the login page there's an option I can include that just says replace true and this means it will replace my location in the history stack with what used to be there that might not make a ton of sense let me hit refresh I'll log in again p123 I'll hit login but then if I hit back it takes me to the page I was on before I went to the login page instead of creating a new entry in my browser history for the login page it just replaces it with the new one for slash host now one thing you might be asking yourself is what is the difference then between using this navigate function and using the redirect function which we learned earlier an important thing to keep in mind about react is that any hooks that you have like use navigate they must be run at the top level of your component code however when we're working with other functions like we have with our loader and like we're about to see with our action function we're not able to use hooks like this because this function is not a component it's not rendering any UI it's simply helping the component do its job so while use navigate works if we're going to be running it inside of a component like this it's not going to help us when we're working with loaders or actions now I do want you to keep this little nugget of information that we covered about replacing the entry in the history stack because we're going to come back to that and it's also important to note that if you're using navigate like this inside of a component you're oftentimes going to need a use effect in order to avoid some kind of difficult bugs that can happen when you're using navigate okay that's enough delaying I promise let's move on and finally start learning about how we can simplify and improve our forms using react router we're back here at the super basic version of our web app that we have and I've spruced up this login form just a little bit and our goal is to set ourselves up so that we can use the new actions feature with the react router data layer apis you see natively forms know how to handle their own State and they know how to submit to some kind of backend so traditionally I might have a property or an attribute on my form that would say action and I would provide to it maybe a PHP file let's call it login.php so that when I submit this form or rather when the submit event happens the PHP file would get called it would serialize the information from the form either in a query string in the URL or it would collect it together as form data and send it to the login.php file which would then process the data and do something in response well we don't have a backend to submit to but maybe you can see where the name for the action function which we're about to learn about comes from instead of submitting into a back end react router gives us a component that allows us to intercept the outgoing request that normally would happen with the native form and process that information on the front end instead so let's get rid of this action and in order to use the action function that we're about to talk about we need to import a capital f form component from react router which is built on top of the Native HTML form but we'll use as a dropin replacement for it and because the native HTML form is able to maintain its own State and has its own way to submit the data that's in the form we no longer need to do this imperative handle change or handle submit functions that we had before which means I can start the really exciting Act of deleting some code I can get rid of my handle submit which means I can get rid of this whole function here that feels really good we're no longer going to be controlling the state of the form with our internal state which means I don't need to control the value and I don't need to watch for the on change event which means I can get rid of those four lines of code as well because we're not using handle change anymore I can get rid of this whole function our on submit is where our navigate was being used we don't need that anymore and we're going to let the form maintain its own state so I can get rid of my react State and just look at that obviously we're not working in quite the same way that we were before but the form is so much simpler to understand and reason about and on top of that as we're going to see if we need to learn information about the form we don't need to go to the react documentation on how to handle forms in the react way we can simply go to the mdn docs and learn about the form object and form data I'm getting a little bit ahead of myself probably because I'm excited to delete code so in the next scrim let's jump in we're going to learn about how to set up the action function in react router where a farm would submit typically to some kind of back end in react router our capital F form is going to run a function that we tell it to run the Syntax for setting this up is going to look very similar to loaders where we had a function that we exported that we were calling loader instead we're going to create a function called action once again the actual name for this function doesn't matter but there's pretty much no reason not to stick to the Convention of using loader and action and then in remix if you're actually building a remix app I think it does matter that this is called loader and action now it's up to you if you want this to be an async function or not I'm going to choose for it to be an async function just to make the syntax a little bit nicer to deal with and just like we did with loaders I'm going to go over to my index where my route definitions are where I'm importing my login I'm going to grab my action and that's a named export so I need to say action and then we'll just rename it as login action just for the sake of it just in case we have other actions that we were to need at some point and where before we had a prop called loader this time we're going to have a prop called action and I'll just set up that imported function as the action on this route so what exactly does this mean well if I have anything that submits a form from my login component on this login route it's automatically going to call the function that I pass into the action prop on that route so let's go back to login and maybe for now I'll just console log I'm the action function and we're going to submit this form and we're going to see something pretty interesting so I'll hit login and it looks like nothing happened if you have quite the Eagle Eye you might have noticed that in our URL it did serialize the information based on the names of the form email and password and put them up inside of the URL log in question mark email equals nothing and password equals nothing that might seem confusing at first but you would quickly learn that that's the default way that forms work if you don't tell it that you are performing a post request as part of your form then it assumes that you're doing a get request and in a get request it serializes the inputs and it puts them up in the URL however we are going to be handling our login form as a post request which means on my form I'm going to include the by the way native attribute called method and set it equal to post now one last thing before we actually submit this I'm going to get react router complaining that I'm not returning anything from my action function so I'm I'm just going to add this return null here okay now that I've told my form that its method is post and again this is something native to HTML forms this is not something specific to react router I'll go ahead and hit save and let me click on login to get rid of those query strings again we'll hit log in and sure enough I get my I'm the action function console log running now you probably remember I was talking about how Native forms would take an attribute called action where you could tell it where to submit that information to like some kind of PHP file and technically in the react router capital F form you can also include an action prop here however the react router form does a pretty good job of having sensible defaults where I usually don't find myself having to include an action prop at all generally speaking the default is going to be wherever you set that action up in your route definitions so here I told it that the login action is going to be the action that should occur on the login path and so that default will just automatically be included or understood by this form so instead of saying action equals slash login since that's the route where the action function will be handled I can just omit that and it'll usually have the correct default there okay the last thing I want to do is see that there's actually an object coming in from the action function here so we'll go ahead and console log the objects just to see what that looks like I'll hit save and submit and we can see that object has a request property and a params property that should look pretty familiar because that's exactly what gets passed into our loaders as well and that's where we're going to get access to the information that gets submitted in this form that's what we're going to be working on very soon but since we've covered a bit of ground already we are going to come back to the van Life app and apply what we've learned over there all right let's apply what we've learned about action functions and start building it into our sign in form in this case I was pretty explicit about the steps you'll need to take in this challenge so just make sure to read these steps carefully and you should have a pretty easy time of this pause now and work on this challenge okay in order to replace this form with the capital F form we will need to make sure that we import that just because this is getting a bit long I'm going to go ahead and put things on their own lines and then we'll import our capital F form and go down and replace our form let's see where is it right here with the capital F form that comes from react router okay we need to add a method prop to the farm so right here we'll say the method is going to be post and this is getting a bit long I already know I'm not going to need my on submit so I will go ahead and get rid of that and I'll leave this here just so I can reference it if I need to we're just going to worry about the form for now okay so let's see that was number one uh oh and that was number two okay so we need to create an action function in this file maybe just right here below our loader I'll go ahead and create an async function called action and I'll just have it console log action function and we'll make sure to do the return null just so react router doesn't complain to us too much okay that's number three and then for number four to register the action function on the route okay we can do that get rid of this we'll go over to let's see we're already exporting it we'll come to our index file come up to where login is we have our loader as login loader and we'll go ahead and bring in our action as login action and just like we did let's see where is here we go loader we'll say action equals login action okay let's hit refresh and let's come to login just so we can take a look at our code we'll hit the login button and sure enough the console log for Action function ran okay let's go back to our practice app and we'll learn how we can pull in data from the form so that we can actually do something with it okay let's submit our form again so we can see what gets logged to the console again we have an object that has two properties request and params we'll take just a few seconds to talk about the params and then we're going to focus mostly on the request when you see params inside of our loader or our action objects that gets sent as the parameter to the function params is referring to Route parameters so if our path were something like slash login slash colon ID or colon whatever that would mean that this path or this route has parameters attached to it that we could grab from our action function in fact let me hit save our login is going to be gone because that route doesn't exist and we'll say login slash whatever in the URL we get our login page back we can go here we'll submit the form and now we can see that the params object is not empty it has a property called ID and the value is whatever because that's the parameter for this F so it's really just good to know that in our action function if we needed access to our params for example if we were trying to update one of our existing Vans we'd be at maybe slash host slash fan one we can grab the parameter of the URL and say hey we need to make a request out to slash API fans slash one which we grabbed from this object and make whatever change was necessary let me go ahead and undo this because that's not our use case here for the login page okay now let's talk about the request object and I think just for the sake of compartmentalizing the different topics into their own scrims we're actually going to do that in the next lesson okay let's look now at the request portion of this object so instead of pulling in the whole object I'm actually going to destructure it and just grab the request part in our case we don't need the params part so we'll just leave it this way now the reason this is called request is because in a native form when you submit it it normally would send a request out to that backend file for example I've been calling it login.php or it could be some endpoint whatever it might be and the back end would process that request and do something with it in our case because we're just working entirely on the front end react router with this action function is basically intercepting that request and giving you access to it here in your action function which gives you the chance to process the information from the form in whatever way makes the most sense for you essentially this action function is replacing the handle submit function that we had before inside of our component so what can we do with this request object well one of the pieces of that request object is the form data that's coming from our form I can get access to that form data by saying const form data or really whatever you want to call it is equal to request dot form data now calling this form data function is actually an asynchronous function so I can say I'm going to await the value that comes back when the promise is resolved and that will give me the correct access to my form data object and this form data object is the native JavaScript form data object that you could go to the Mozilla developer Network docs and read about in fact if you'd like you can click the screenshot here to take you to the mdn docs about form data instances of form data have a property called get and so now I can gather information from the inputs of my form by saying form data dot get and then I would pass the name property of the input that I'm trying to get information about or rather trying to get the value from so because this was named email I need to make sure that I say form data.getme Mill and for password I'm going to do the same thing for the password so I'll say password if this email were named the name property were something like blah blah then I would have to say that get blah blah let's keep it as email for now just getting it from the form data is kind of useless to me unless I save it so we will save it in a variable called email and password and at this point I could then just process this info however I wanted in the case of our van Life app this is where we would pass the email and password to the login user function so let's go ahead and make sure that this is working correctly we'll just console log both of these we'll go ahead and hit save we will fill in bfb.com and then I'll just do ASDF and hit login and cool inside of our action function we now have access to the values of our inputs since we're here mentioning the login user function from our van life app that's a great segue for us to take what we've learned here and apply it to our van Life app however before just jumping ahead feel free to take some time to play around with this code if you want you could add an input or two and try to get the values from your action function and try to commit the process that we've done here to memory because your challenge is going to be to apply these exact same principles to the van Life app so that's what we'll be doing next okay and now it's your turn to get your hands on the keyboard you'll essentially be doing exactly what we did before your challenge is to pull in the form data from our form when it gets submitted and for now you can just log the data to the console you'll probably notice that we're still doing all of the more imperative form handling stuff that we were doing in react including saving the form data as part of react state but for now it should still work if you pull in the email and password to the action function and just log it we'll be getting rid of a lot of stuff here soon so pause now and work on this challenge okay our action needs to get access to the request and with the request we can get access to a form data object by saying await request dot form data this await can be tricky to remember hopefully that didn't trip anybody up too much and then once we have access to our form data we can get the email with form data.get email and we'll just do the exact same thing with the password let's go ahead and console log our email and password we'll hit save open up our console type in b.com p123 login awesome again our action function is slowly starting to take shape as a replacement for our handle submit but with a number of really nice additional benefits that we haven't yet talked too much about before we start a major refactor of the login component code we are going to take the email password and actually log our user in and kind of complete that workflow and then we'll come back and we'll start cleaning up our login component you might remember in our form we had an on submit event handler that was calling our handle submit function here this is the function that was logging in our user but now that we're using these actions or this action function we're no longer logging in our user hopefully it's not too big of a leap to see that really all we need to do is to take our login user function and call it up here in our action so we'll go ahead and call login user this function expects an object that has an email property and a password property and since we chose to name our variables email and password we can use this shorthand to pass in an object with these properties the login user function is an async function we can look here in the api.js file and see that it's an async function and it's going to return data but since it's an async function it's automatically going to wrap that data in a promise and I can unwrap that by using the await keyword so I'll say const data equals await the call to login user let's move our console log down here and change it to log our data we'll hit save put in B at b.com p123 and sure enough there we go we get our user object which you might then decide to put into some kind of authentication context or into local storage or wherever makes the most sense to have information about your currently logged in user and then we also get our token which we could save in a number of different ways oftentimes it's best to put it inside of a cookie which might be something that's actually handled by your server because we did go out of our way to code our sad path where we have the different status and the error states that we're maintaining in our component we're not quite ready to just delete everything but we can start down that path for example right now we are no longer meeting the state where we're maintaining the values of the inputs instead we're using the internal state of forms to handle that so I can go ahead and get rid of that local form State I can come down to my forms and I can get rid of my on change and my value props right here we don't need those anymore that simplifies our form quite a bit and because we're not watching for change just in the farm manually anymore I don't need my entire handle change function this is a great start we're going to see that we can clear up even more of this later but for now we've made some good Headway and there's one really small change that I want to make just to make our app seem a little bit more realistic even though we're still doing fake authentication so we'll touch on that next in our require auth utility function we are still hard coding the fact that the user is logged in and although I'm not going to suddenly insert real authentication and dealing with authentication context saving the user across the entire app or anything like that I do want to make it so that in some form or fashion when we log in from our form it remembers that we're logged in and then we can also log out and see how our app would react to that scenario so I'm actually going to type this up as a challenge for you okay so we're going to be saving the logged in state to local storage just again as a temporary way to fake our authentication I could have just typed this for you but I figured this might be a good way for you to navigate yourself around the app and to think critically about how this might work and play with some of the different files that we've created so when the user logs in I want you to save a value that we'll just call logged in to local storage and set the value of logged in to True maybe instead of saying save a value we'll say save a key called logged in and set the value of that key to true then over in the require auth function you need to check if the value of logged in in local storage is true instead of hard coding it like it currently is it's a fairly straightforward challenge it shouldn't be too difficult if you need a reminder on how to deal with local storage you can always do a quick Google search it's a pretty common thing so you should be able to find good answers out there and I need the spell challenge right okay pause now and work on this challenge the user is logging in here in our action function or rather we're calling the login user in our action function right now we're still only coding the happy path but we're going to get to the sad path later for now we'll just assume that everything will work well and so I'm going to say localstorage.set item with the key of logged in to the value of true in reality I think this might get stringified but that's okay it'll work because we're just going to completely remove the logged in value from local storage when they log out so that's okay for now we'll get rid of this console log and then over in our utilsjs instead of hard coding is logged in we're going to set it equal to localstorage.get item of logged in and that should be it again when we log out we'll make sure that we don't set it to false because I'm not sure if that would work I guess we can test it but we'll just go ahead and remove the logged in item completely okay let's hit refresh and we should be able to test this Now by trying to go to host so since I'm in host it appears that I am logged in I have something in local storage maybe from testing this previously that says that I am logged in and now that I think about it unless I open my developer tools which is probably what I should just do I don't have a great way to clear out my local storage so maybe what I'll do is just go to my file here in the index and I'll just type in localstorage dot remove item logged in run this code okay cool well it looks like it sent us to the login page so I think that worked and then I'll clear that what we should probably do is put just a simple button that will be temporary that allows us to clear out that local storage okay so we do see that it says You must log in first that's good we'll type in be at b.com and p123 log in and we are presented with what our next challenge needs to be because before we were redirected to the new page with this navigate function inside of our handle submit but we are no longer using our handle submit so that is what we are going to be working on next I was realizing that you should actually know everything you need to know in order to complete this challenge by yourself as a reminder the idea is once somebody successfully logs in they should be sent to the host route eventually we're going to add to that to make it an even better user experience but I wrote this a little bit vaguely so that you have to really critically think you can go look at other parts of the app if that might be helpful just a quick hint you're not going to be able to use the navigate function that's because we're going to be sending the user to this new route inside of our action function and navigate only comes from calling the use navigate hook which can only be called inside of a functional component and our action function up here is not a component at all so that's enough of a hint pause now and work on this challenge the tool that we need is the redirect function so I'm going to pull that in and you might remember that from our require auth function where we are redirecting people to another route and in this case we're including a message on top of it so back in login.js we will pull in our redirect and then right here we will call and actually I'm just going to return a call to redirect so we'll do redirect and for now we're going to hard code in the slash host route we'll clean up this challenge text and cross our fingers we'll hit save login bab.com p123 login and there we go now something I did just to make our lives a little bit easier is I included this little admittedly very ugly button here in our header that we can click in order to clear out local storage or at least to clear out this logged in value of local storage you can see it over here on components header if you want there's the fake logout function and just a simple button with absolutely no styling that when it's clicked calls fake logout now you'll notice that clicking logout doesn't actually change the user interface and that's because react is not observing local storage to make updates to the UI if that happens but now if I click host it should redirect me to the login page because it knows that I'm no longer logged in or rather that there's no more local storage entry for logged in okay hopefully that went okay for you now with this redirect included in our action we have a little bit of a funky user experience that happens so let me show you I go to the home page I'll try to go to the host page it'll take me immediately to the login page I'll go ahead and log in bib.com p123 log in and then if I as the user were to hit the back button I'm sent to the login page and maybe what's worse because we have the query string that has the message that you must log in first in the URL it means that this page that we're seeing makes it look like we're maybe no longer logged in although I can get to the host route because technically according to local storage I'm logged in so this is kind of a funky experience ideally we wouldn't be able to see our little detour to the login page at all unfortunately in order to do that it is very very easy we'll talk for just a second about the history stack in the next lesson and then see how we can essentially avoid having the back button take us back to this login page as I mentioned making this little user experience Improvement is actually a really easy thing to do in the code in the way that we have our code set up but I think it's useful to understand the concept of the history stack just in case you don't have any previous experience with it the idea behind the history stack is that your browser maintains a you could think of it as an array of locations that your browser has visited and under the hood when you transition from one route to another in react router it is automatically pushing new entries to the history stack for you so that you are able to use your browsers back and forward button the way that you would expect a regular app to work so for example if you show up at the home page it would enter in the slash route to your history stack then maybe you visit the about page so that would enter in the about page to your history stack if you hit the back button it would pop that off the stack and you would be back at the home page getting forward again would take you to the slash about page this is all exactly how you would expect now let's say our user is not currently logged in and they try to get to the host page what exactly happens well before the host page can load the require auth utility function that we set up stops the route transition from happening and that's because we set require auth to run inside of the loader for this host route and the loader will always run before the transition to the host route happens inside of require auth we redirect the user to the login page and so the login page is what actually gets entered into the history stack so that's a good thing for us however once the user logs in we are routing them to the host page in the host page and the login page are both in our history stack this means that if the user hits the back button they will end up on the login page despite already being logged in now we could change our setup so that if the user ever gets to the login page it will check their logged in status to be totally honest this is probably the best solution because then it doesn't matter how you get to the login page if the user were to type slash login then it would would automatically redirect them somewhere else so that's definitely something you could play with for the sake of Simplicity we are going to take a little bit of a different approach and while we're at it we'll learn a cool new tool that we can use so on our login page we have our form which is our login form we can add a very simple prop to that form called replace one thing that takes a little bit of time to get used to is recognizing that the submission of a form is actually considered a navigation event and so similar to how we had this little option that we have on our navigate function that says replace true this replace true says forget the current route that you're on just replace the current route which is the slash login route since this is the login component replace it with Slash host well the exact same thing is going to happen with our form because the submission of the form is also considered a navigation event we can instruct it to replace the current entry in the history stack with the upcoming entry in the history stack and so what happens is the login essentially gets removed from the history stack and we have sort of an amended history here that allows the user who now is logged in and is at the host page to click the back button and go back to the about page as if the little detour to the login page never happened so this is as simple as adding the replace prop to our form let me put these on their own lines and by adding the replace prop here when we submit our login form we will see that exactly what we saw in this diagram will happen so I'll go ahead and hit refresh I'm at the home page maybe I'll go to the about page I'll make sure I'm logged out here and then I'll go to the host route this redirects me to the login page notice that if I hit back here I go to the about page I don't go to host it didn't complete the transition to host so that never got entered in my history stack and then I will go ahead and successfully log in okay we're at the host route and now if I hit the back button it takes me directly to the about page which is just what we saw in this diagram it's where I was before I ever made that detour to the login page the same thing should happen if I were to clear out my logged in entry it will go directly to the login page not via the host route I'll enter my credentials again log in it takes me to the host page if I hit back we're back at the about page just like before again a more robust solution would be to first of all not render a login Link at all if the user is currently logged in or another solution could be to just make it so that the loader of the login page will check if the user is currently logged in and redirect them somewhere meaningful if they already are but at least now we've learned the concept of a form submission being considered a navigation event and this cool new prop that we can add to our forms if we ever want to ensure that the history stack doesn't include the route where we're currently rendering this form okay we have been working on our happy path transitioning it from using our more imperative form submission methods like our handle submit function here we've got an action function that's working fairly well let's go ahead and start coding up the sad path using our action function and moving a few things out of our component we're back here at our simplified app and I've created this fake login user function all it really does is it takes an object with an email and a password property it's just hard coding to check if those are equal to b.com and p123 and if that matches then it returns something we're not actually going to be making use of this right now I just wanted to have something there if on the other hand it is unable to log the user in then it's going to throw an error with a message of couldn't log the user in we want to start handling some errors where if the information that's passed in the email and password is incorrect we want to be able to display to the user that something is wrong before we started working with the action function we had to maintain all of our error State as react State inside of our login component however now we're going to have access to a little bit of a better way now first of all it's important to know that if I'm in my action function and I throw some kind of error let's go ahead and say we're 3 a new error there was an error okay that's just hard coded into the action which will happen when I hit login let's see what happens I'm going to hit login and we get an unhandled thrown error this screen that you might remember seeing before where it instructs us to use an error element when an error is thrown inside of our action or our component or our loader it's going to then exit out of the regular element flow of our route definitions and it's going to look for the nearest error element now we don't have an error element anywhere on here and we've already learned about that so if you need a refresher you can go back to the previous part in the course where we talk about the error elements but that's not actually what we're concerned with right now what we're concerned with is not throwing an error because we don't want to take the user away from the login form just because they got the information wrong instead we want to keep them here on the login page and simply display some information that might help them understand that their attempt to log in was not successful so in our action If instead of throwing an error we return something let me go ahead and just hard code a string that says I don't know couldn't log in this gives us a chance in our component to receive the data that we're returning from our action function and display a helpful message here in the actual component in order to grab data that has been returned from an action function very similar to how we did in a loader function we can use a hook called use action data remember when we return something from a loader we can use use loader data the naming convention is very similar for an action so we will use this use action data hook inside of our component and let's go ahead and just call it error because we know that's exactly what it is and we'll get it by calling use action data now think for a second when I refresh this page what is going to be the value of this error variable remember the action function will only run after the form has been submitted and so when we first render this component we're not automatically submitting the form and so we can see when we console log this error that we're going to get an undefined value so that just means that when we are trying to display this error we need to make sure that we are coding a little bit defensively which means using our good trusty friend of conditional rendering I'll go ahead and say if there is an error then we'll display maybe just a little H4 and because the error so to speak that we're returning from our action is just a string I'm just going to go ahead and display that error right here we do have a little class that we created earlier called red that will make this stand out a little bit more so let's go ahead and hit save we still have undefined but because we're now checking if error exists first before displaying our H4 we don't have any problems and then I'll click login and perfect we get the string that we returned from our action function great now that brings us to The Next Step which will be to check for any errors inside of our action function so that we can redirect like we were doing before if things go well or return some helpful information back to the form so that the user can take action accordingly so that's what we'll be doing next okay let's apply what we just learned about returning values from our action function in this challenge where I need you to add a try catch block that tries to log the user in with our fake login user and we pass the email and password to it if it's successful then you can redirect the user to the slash protected route but if there's an error you can return the error message that gets thrown from the fake login user function I put this down here because this is where you can start your coding you can just put this above the try catch and start your try catch right here okay pause now and work on this challenge all right so let's open up a try catch one thing that I kind of like about try catch is that I can put all of the code from my happy path inside of my try and then just catch any errors that might occur along the way this works for a simple task like this if it becomes more complex you may need to either Nest a try catch or do multiple try catches but we're not going to worry about that here so first thing we need to try to log the user in so we're going to call fake login user and we will pass the email and the password and I'm wrapping those together in an object because the fake login user expects an object to come in with an email property and a password property and I believe this is an asynchronous function so we will need to await that I mean we can just come up here and look so yeah it's an async function and it's returning an object that has an email and a token we're not really using that but just for the sake of it I'll go ahead and grab it in a variable okay and then assuming that is successful which we can do because we were here inside of our try we can redirect the user which we need to import from react router so we'll pull in redirect we want to redirect them to the slash protected route and I don't think it's strictly necessary but for some reason it feels better to me to return the redirect so we'll go ahead and add that there okay now inside of our sad path if we do have any errors in the process of trying to log the user in then we're going to receive that error and we will just go ahead and return the message portion of that error there's more than one way to do this you could send the whole error object down in case you needed other properties from that error but in our case let's just go ahead and send the message down maybe to make that absolutely clear inside of our component instead of calling this error let's go ahead and just call it error message that way it's pretty clear that we are talking about the string message that comes from our action function okay let's clean up our challenge text and give this a shot first let's try to log in for real we'll do bfb.com and p123 login here we are at our super secret information okay we'll click this to log out try to go to protected that takes us to the login page and then let's just try to log in without any credentials couldn't log the user in perfect okay with that little bit of practice under our belts let's go back to the van Life app and we will implement the same thing currently our action still only has the happy path here and so we need to as part of your challenge remove all of the error handling that's currently happening inside of our component and the error component State and create a try catch inside of our action so that our action can handle errors in a better way like we just practiced now if any of this seems like it might be a bit complicated for you that's probably another good indication that it's time to go back maybe rewatch a couple of the last lessons as we have been practicing doing error handling inside of our action function because as it stands if you've been able to follow up until this point then you should be able to complete this challenge without too much difficulty so now's your time to prove to yourself that you can do it pause now and work on the challenge okay so right here is where our happy path exists so I'm just going to wrap that code inside of my try catch and right here we will include our catch of the error we can actually see what this error object is going to look like if we look at our api.js login user function we can see that if something doesn't go okay then it's going to just throw an object that has a message property in case you weren't familiar in JavaScript you can throw anything you can throw a string or a Boolean or in this case an object you don't always have to throw an actual error object that's made by the error Constructor so I'm in this case throwing an object so that I can include a message property but also include the status text and the status just in case that's useful it's not terribly important at this time but mostly it's important to know that we have this message that is going to come from our server file okay so in login.js we will just return and I think we can just stick to the message I don't know that we necessarily need the status or the status text to display inside of our component so we will just return the error.message and then we need to use use action data so I'll go ahead and pull that in use action data and inside of our component we can grab the error we'll say maybe this time we'll also say error message like we did in our practice just to make it really clear that we're just pulling in a string message and we can get rid of or update this so it's not error.message or error anymore we'll say if there is an error message then we will display this H3 and we can start getting rid of any of the error handling that we had before so we had some error stuff here inside of our catch here we were dealing with errors let's get rid of all that and I think that should be everything we are right on the cusp of finally getting rid of our handle submit but we have one last thing that we're not yet accounting for and that is these statuses on the state of our app if it's in the process of submitting or if it's idle fortunately we have a pretty easy way to update this and so that is what we're going to be learning and adding next here in our practice app we don't yet have any code that gives us a good indication of the status of our app when we're in the middle of submitting our form in our van life what we're currently doing is setting up some local react state that has a status property and we're setting that status manually while we're in the process of submitting our form however because the form submission is now happening inside of our action we can't update our local component State because the action is not part of our component it doesn't have access to our state fortunately react router gives us a utility that we can pull in called use navigation this is not to be confused with use navigate and use navigation will give us an object that gives us information about the current status of navigation in our app in other words if react router is in the process of for example loading in a loader that navigation object can give us information about that or if we're in the process of submitting a form like we're doing here it also will give us information about that so that's actually pretty easy we can just grab the navigation object by calling use navigation and there's a property on this navigation object well let's go ahead and just log the entire navigation object open up the console I'll hit save okay and even just rendering our component for the first time we can see that it's an object it has a bunch of different properties but currently the only one that is not undefined is a property called State and we can see that that state is set to the string idle maybe you can see where I'm going with this that navigation state is going to be our replacement for the local component state that we had set up in our van Life app so now that I have access to navigation.state in fact let's keep the console log here I'll hit refresh we can see it's idle I'll go ahead and click login we can see that it changed to submitting and then it changed back to idle in our case this is happening very fast because our login user function is just checking against a hardcoded be at b.com and p123 it's not actually reaching out to any kind of database and so we don't even see a delay really but it's cool to see that we now have access to some navigation state that we can use when we want to do things like disable the button in fact I wasn't planning on doing this but let's make that a challenge because you should be able to do this by now okay your challenge is to disable the button if the navigation state is set to the string submitting and also to change the text to say logging in instead of just login again if the state is submitting now because we don't have any kind of delay in this function I added this little sleep function which is just right here it all it does is pause execution of this function for 1000 milliseconds or one second so that you actually have a chance to visually see the change that's happening when you're logging in okay pause now and work on this challenge all right so on our button we can add the disabled prop and set it equal to if navigation.state is equal to submitting and that should handle the disable of the button and the text we'll go ahead and wrap this in a JavaScript expression so that we can say navigation.state I'm going to spell this right is equal to submitting we'll go ahead and use a ternary here it's question mark then it's going to say logging in but otherwise it will say login let's clean up our challenge text and we'll get rid of this console log while we're at it refresh okay we'll hit login okay we get the logging in and don't have a space there sorry about that so we can see that's working the button is disabled and then if we actually log in we get the same thing and then it redirects us to the protected route perfect okay that's how we can set up navigation States or as we were calling them in Van life these status so now we'll go back to Van life and implement this method for tracking our current navigation State and that should allow us to finally get rid of our handle submit and the status date that we had one thing I did forget to mention is that I have a link to the documentation for use navigation right here so you can click the screenshot if you'd like to go read more about it there is quite a bit more to the use navigation hook and that navigation object that we aren't currently using in our app so it could be fun to go read up on it but once you're ready we have the challenge of including use navigation to track the current status of the form submission and remove all of the status tracking that we're currently handling manually in our state once you've done that and it's working then you should just be able to completely finally remove our handle submit function so let's get to it pause now and work on the challenge okay let us pull in use navigate actually you know what we don't need use navigate anymore so I'm just going to attack on to the end of that and pull in use navigation instead let me just double check we're not using navigate so we can get rid of this this is going to go away when we get rid of our handle submit function actually you know what I'm impatient I can't wait I'm just going to remove that completely wow that looks so much cleaner okay we're broken let's go ahead and fix what we have broken so I'm going to pull in navigation is equal to use navigation and you can probably see that I was already using the conventions for use navigation just because I knew that's what it was which means I can just change status to say navigation.state instead the idle value and the submitting value was one that I chose because I knew that it mirrored this navigation state so everything else should be able to stay the same let's clean up our challenge text we'll hit save and let's give it a shot so I'll try logging in without anything okay we did see it say logging in although I did forget to add a CSS rule for it I guess I can just do that really quick okay so let's go ahead and try it again I'll hit refresh logging in okay perfect no user with those credentials found we'll log in b.com p123 login and it takes us to the host dashboard so now we can see that our form is doing everything that it was doing before but we've been able to offload a lot of that boilerplate imperative stuff that we were doing before with all of our local state and we've offloaded it to react router so that it can handle some of those very common tasks for us if you've been able to follow up until this point congratulations I know that we've covered a ton of ground we've really refactored a lot of things including a complete paradigm shift that you might not be used to if you've been working in react for a little while I've heard someone call these new data layer apis with react router kind of like remix Lite and the truth is if you can grasp what we've been doing here then you would be really primed to jump into remix and be able to start creating full stack applications there's quite a bit more to learn with remix as well but you'll be pretty surprised to see just how familiar remix feels once you've become accustomed to the patterns of using actions and loaders changing when data fetching happens with our components and all of the benefits that come there in in the next few lessons we're going to be touching on a little bug that we have or maybe it's just a inconvenience with the user experience when it comes to redirecting to the login page for example if I go to a nested protected route like slash host slash Vans slash one here and I'm not actually logged in so I'll log out with my silly button here and then I'll try to refresh the page now that I'm logged out we'll see that it takes me to the login page and so I can go ahead and log in but then what will happen is it will automatically send me to the host route it's not a bug per se it's just kind of a bad user experience because what I'm expecting is to go back to slash host slash fans slash one one way to fix this involves two different parts so we'll be jumping into fixing that for moving on to some of the last features that we have to learn I've made a few small updates to our practice app here first of all I've moved the inline protected component that we had it's really just an H1 and the inline loader function that it had over to its own separate component file here so we have the actual component right here again it's just an H1 but this way we have a separate loader that lives over here I'm importing the pieces that I need like redirect from react router and a new require auth function which I just put over here in its own utility file here called require auth also for the sake of demonstration I added another nested route so now the protected route is apparent to this one that I just called nested and then I added a link to nested here on the navbar now I'm currently logged in just to be able to show this if I go to protected takes me to slash protected and if I go to nested it takes me to slash nested in the URL actually you know what the nested has this H1 and the reason it's not showing is because I need my Outlets so I'll go ahead and put that in here and we'll just wrap this in a fragment and put in our Outlets okay so now with the nested route we have this nested protected route H1 showing up and again that is just here in line just for simplicity's sake okay so those are just some simple updates I've made and the reason that I did that is because let me go ahead and log out let's say we want to get to this slash protected slash nested route which I can get to by clicking this nested link here so I can go ahead and do that it takes me to the login page I log in with bfb.com p123 and because of the way that we've written our login component up here in our loader we have hard coded that it should send us to slash protected in our case that's not terribly difficult to then just get to the nested route by clicking the link but the point is if we did have some kind of complex nested route that the user was trying to get to and they were redirected to the login page if we just hard code that we want to send them to slash protected it's kind of a weird user experience let's say for example they tried to get to this nested route by clicking a link from their email and maybe it has some kind of user ID in it that isn't accessible by navigating somewhere on the site but instead you have to get there at least it's much easier to get there by clicking the link in the email if we hard code that we're sending them to the slash protected route then they're going to have to open up their email clients again and click on the link again now that they're logged in hopefully it opens in the same browser and still has the same session they don't have to log in again so I'm hoping that you're seeing a limitation by hard coding the slash protected route here when we redirect the user after logging in so what we are going to focus on is making it so that if the user let me log out again and try going to the nested route if the user is redirected to the login page that we make it so that after they log in they will be redirected to that nested page instead of the hardcoded slash protected route now in the past we have been able to get the path Name by using the use location hook that comes with react router and we could make that work however because we're now using the data layer apis with three act router 6.4 we have another way that is a little more congruent with the new paradigm that we're using you see our loaders and our actions will both receive access to this request object let me go over to my protected route loader and pull in that request object and we will go ahead and console log the request actually let's do request.url well actually no let me let me do request first we'll hit save I'll make sure I'm logged out I'll go to protected and we'll open the console okay so we see that we have a request object and this request object is the actual native web request object it comes from the request Constructor you can go to the Mozilla developer Network docs in order to learn more about request and request objects have a property called URL which gives us access to the URL now we'll be able to see that when I refresh and click protected we get the entire URL and it's just a string in our case because our mini browser is running on the scrima platform it shows our full protocol we have https and then the cw1.scrima.com as our base URL and then at the very end we see Slash protected now I could go out of my way to try and grab the slash protected portion of the URL using some kind of string manipulation but another thing we can learn is that we can construct a URL again using the native URL Constructor so let me actually set this as a variable I'm going to say const URL equals new URL and this Capital URL that comes from just web apis so this Constructor is just universally available as a Constructor I can use as long as I'm writing my JavaScript code or the front end and when I pass the actual URL the string URL by accessing that request.url I've now created a URL object let's go ahead and console log URL okay and I'll try to get to protect it again okay so it's string representation is showing up exactly the same but what's nice about this URL object is I can actually access properties like path name for example you might remember when we were using the use location hook the location had something called path name and that is just coming from this URL object and so if I were to console log url.pathname go to protected I now have immediate access to the path name that I was trying to get to and if I go to the nested route I can see that it gives me the full path name of the nested route protected nested now I do want to address something here I think for maybe the untrained eye this might seem like a lot of additional work to get to just the path name having to pull in the request object and create a new instance of a URL object and then access the path name property but to be honest having been in the game for a while now I didn't really take the time to learn some of these platform apis like the URL Constructor until this became pretty much the right way to do this in remix and by association react router so honestly I actually really appreciate that I've spent a lot more time learning native web apis and spending time on the Mozilla developer Network docs then having to parse through a bunch of Google results and stack Overflow questions hoping that I get the most modern answer based on the newest version of react router but instead I can just spend time on the Mozilla developer Network docs and find the information I need because it's using the platform it's using the constructors and the tools that already exist in the web okay we've spent quite a bit of time just to get to this url.pathname but hopefully you can see in the end all I did was pull in the request create a new URL object and then access properties from that object so for the sake of time we're going to end this scrim here and in the next scrim we will talk about how we can make use of this so that after the user logs in they can be redirected back to this url.pathname so that's what's coming up next Okay so we've started diving into the Weeds on how we are going to solve this problem we now have access to a URL which has a path name property that we can use but what exactly is the overall strategy I think that might be helpful for us to look at remember it's our require auth function that is in charge of redirecting users to the login page and then the login page is in charge let's see where is the action function right here is in charge of redirecting users to the route that they're supposed to go to and this is what we're trying to fix remember we don't want this to be hard coded to slash protected so that's kind of the workflow that we have the protected loader runs that calls require auth that redirects people to the login page and the login page once they successfully log in redirects them to the route that they were trying to go to so how do we get information from our protected route which is where we have access to the request and easy access to that path name to the require auth function and then from the require author function to the login component well we saw very briefly when we redirect a user using the navigate component or the use navigate hook we're able to pass some State through the navigation event to the next location and that location object can grab the state that was passed to it however those are Hooks and those have to happen inside of components and mostly we are working inside of the loaders and actions because of that the most common way is for us to pass information through the URL so actually right here in require auth when we redirect someone to the login page I want you to think for a second how can we pass information using the URL we can use search parameters or query strings just like we did in Van life where we said question mark message equals you must log in first we can use this same strategy to pass information from our require auth function to the login page and then have the login page make use of that information to redirect us back to the correct spot so the next question then is how do we get this path name that we're able to access on our URL object to the require auth function so that we can include it in a query string maybe this would be a query string like redirect to we'll set that equal to some question marks for now and actually this seems like the perfect opportunity for a challenge okay so your challenge is to figure out how you can get the path name from this URL object from this loader into the redirect to query parameter inside the require auth function right here where the question marks are so let's come back here to the challenge text okay pause now and work on this challenge one approach you may have taken was to just pass in the URL dot pathname directly to the require auth function and then over in require auth we would receive the path name and just stick it into the query string right here however I happen to know that I'm likely going to be calling require auth in more than one place which means if I did it this way I would need to run this code and this code every time I wanted to use require auth so instead of that I'm going to copy this line and get rid of it and then just pass the entire request object down and that way require auth can do that logic and figure out exactly how to get the path name so we'll say it's receiving a request object and I'll paste in that line I'll even make a separate one that says dot path name actually I'm just going to tack on dot pathname since that's all I really care about and then we'll change our URL to say path name and then now that I have that value I can stick it here in inside my string I'll make these into template strings so I can do my interpolation here and just say we're going to pass the path name as the value to the redirect to query string okay we've covered a fair amount of ground for one scrim so in the next scrim we're going to see how we can from the login page grab the redirect to Value that's right here so that we can correctly redirect back to the right spot when the user logs in so we are sending users to the login page we're passing the information about where we want them to redirect to after the login is successful so I want you to pause here and think where will I need to write code next okay if you said that we need to go to our login page and our login component you would be correct but if that was all that you came up with I want you to think even more specifically I'm here inside of my login file that has the action and the login component a couple helper functions that are just helping us kind of fake authentication for now so more specifically where am I going to receive that query string that should be coming in through the URL remember as long as I'm logged out and I try to get to one of these protected routes I now have redirect 2 equals slash protected slash nested in my URL so again more specifically where in this file login.jsx am I going to receive this redirect to Value so that I can well redirect to the correct spot well technically I would have access to it inside of a loader function if I created a loader function I would be able to access the request object however the loader is not when I want to redirect to that new location it's right up here in the action we already have access to our request and so I can use this request to grab the URL grab the search params from that URL and use that as my redirect value right here on line 31. so right here above our try we will maybe just get our we'll say const path name is equal to and then I can just grab the URL I'm going to do this all kind of chained together so I'll say I'm going to create a new URL from request.url that's going to give me a URL object and then I can grab a property on it called search params and that is an object that has a get value and I can grab the search param with the redirect to key which should get me the value in this particular other case as we can see in the URL slash protected nested let's go ahead and console log that we'll cancel log the path name and because this is inside of my action I'm only going to see this console log if I try to submit my form so I think I can just hit login and sure enough there it is slash protected slash nested so all I need to do now is to replace this protected with path name okay let us give it a shot I'll refresh make sure I'm logged out I still have my redirect to in the URL so I don't need to change anything there we'll go ahead and log in bfb.com p123 log in and oh we were so close what happened here is our slash protected slash nested route is running a loader as soon as it loads and we did that inline right here but we are missing something from this function can you think of what it might be well we taught our require auth that it will be receiving a request object and we did that inside of our protected loader here but we did not do that inside of our nested loader so one thing we could do is just grab the request and pass it along to require auth that should fix this problem okay here we are on the nested route alternatively we could go to require auth and make sure it only does this if request exists I think since we have it fixed right now just by passing in the request inside of this loader that's probably going to be good enough for now actually now that I think about it we might have to do it that way since we want to be able to redirect back to the nested route we need to make sure that if the require auth ever gets run here then it will pass that request through successfully so it's a good thing we tested that let's just make sure again I'll make sure we're logged out go to the nested route that took us to the login page I guess that was a little hard to see because we were already on the login page I'll go home and then nested that take takes us to the login page be at b.com p123 and okay here we are now one last final thing I'm going to log out go to my login page and log in like normal bfb.com p123 it logging in and we get a problem it's taking S2 slash login slash null so this is an interesting one I think it could be a good exercise if you want to try and see if you can debug that you can pause now if you'd like to do that and then we'll be going through it together okay so why is this happening well let's go through the regular workflow just to try and debug this in the login page this action is going to run every single time we submit the form whether we are coming to our login page via another route that we're trying to redirect back to or if the user actually clicks the login page when they click the login page there is no query string for redirect to which means when this line runs this path name is going to be null because the URL does not have a search param especially not of redirect to it doesn't have any search parameters and so calling.get on something that doesn't exist will return null and then we're kind of stringifying that when we put it inside of our path name it's going to be null and because it's a relative path it's not setting it up as slash null for example I mean this would be like a string but it's not slash null then it's using it as a relative path to the login page which then takes us to slash login null a really easy fix for this would be to choose a default where we say or if that is null let's just go to slash protected so let's try this again we'll get rid of that console log hit save we're just on the login page there's no query string there we'll type in our username and password and great that took us to the default route of Slash protected and now if I log out again and try to get to my nested page Log In perfect our redirect is working just like it was before okay we have covered a ton of ground let's go back to the van Life app and see if you are able to get your hands on the keyboard and complete the challenge of implementing this redirect to pattern that we just did over there in our van Life app okay here time to shine your challenge is to implement the redirect to feature like we just did in our practice app but here in Van life I've given you some starter instructions just since it took us a little while to get there in the last app this way it can be a bit of a refresher so make sure you read through numbers one and two really carefully and then for number three you are on your own for the last part but I know that you can do it pause now and work on this challenge okay we are going to pass the request objects to every function call for require auth that happens inside of our protected routes of course so let's go to maybe let's start here in our index and we'll just see all of our inline loaders that we have that are nested inside of this host path we need to add the request object here and I think there's some more down here host and info pricing and photos so we will go ahead and receive that request object and then we will pass it through to require auth and then inside of the other loaders that are separately defined but only the ones that need to be protected with require auth so that is our host fans loader and our host van detail loader and I think that's everything so let's see where are we here nope not Vance under host host Vans okay this loader right here this needs to receive the request object and pass it to require auth and then the same for our host van deta until we're already receiving params so we will just also pull in request asset 2 require auth okay that is a good start let's go to require auth and that should be everything for one we'll go ahead and clear that out then require auth is going to receive the request we'll construct a URL actually we can just do it all in one we'll say the const path name is equal to new URL request dot URL and then we'll use dot pathname to grab the path name that the app was trying to get to when we were first trying to get to the protected route without being logged in okay and in this case we already have the message that we're passing through this is important for us to keep so we are going to add another one on top I'm going to change this to template strings and I'll just put this on this online so that it can be a little easier to use and we will add in with an ampersand we'll say and redirect 2 equals and then we'll pull in our path name okay so this alone we should be able to test let's clear this out and since we're on our own for the last part we'll clear out the rest of this challenge let's hit save okay and then I'll make sure I'm logged out I'll go maybe to the home page and then I'll go to host okay and if we look closely we have the whole thing up there we have slash login question mark message equals you must log in first and redirect to equal slash host perfect now for the last part we need to go to our login page receive the search params so that we have access to this redirect to in the URL and then use that as our value for slash host or rather in place of the hardcoded slash host that we have here so actually we already have up here where we are grabbing the search param for message so I'm just going to copy this because I guess I'm a cheater and right here we will say that our path name is equal to and then I'll just paste that in but change this to redirect to since that's the key that we're trying to get the value from and maybe I will put this on its own line just in case that's getting a little wide for anybody and I'm going to have a default of Slash host that way if someone is coming through the regular your login workflow where they actually manually go to slash login we're not going to get null in its place okay so we'll take this path name and that is where we are going to redirect to let's hit save we will log in be at b.com p123 okay so that took us to slash host that's where we had been trying to get to before I'm going to go somewhere more deeply nested let's go to Vans maybe one I'm going to log out and then try to get to pricing okay great we can see in the URL redirect to equals host slash fans slash one slash pricing let's go ahead and log in again p123 enter and here we are perfect great work I know that may have been a challenge especially that last part since I kind of took the training wheels off and let you ride on your own if you did struggle with it and you had to watch me do it that's completely okay but now is the perfect time to scrub back and to try the challenge again maybe from the very beginning all by yourself great work and I'll see you in the next grim at this point in this course we are really rounding the corner on the final topics that we're going to learn about react router and at this point we are starting to venture into some more advanced territory it's nothing to be worried about we're going to go step by step so that we can understand everything we're learning but it also will touch on a couple topics in react not react router but core parts of react that you may or may not be familiar with I'll try to give a bit of an overview of them but we won't be diving deep into those topics specifically the topic of suspense the motivation for what we are about to learn can be seen here in this little weather app that I created clicking on the weather link which I'll do in just a second will get the weather for the current location where I'm recording this and the API is actually not very slow so what I've done in the utilities.js where I'm creating this get weather function I've added a three second pause just to make it so that it's as if getting the weather took a bit longer than it actually does and this is really to highlight one of the things that you certainly noticed when we first introduced the idea of a loader see the benefit of a loader is that we can write our code as if the data always exists at the time of rendering this component for example I can say that loader data is equal to use loader data and I don't have to do optional chaining or any kind of ternary check to make sure that loader data exists at the time this is being rendered otherwise I could get some kinds of Errors for trying to access the property main of undefined for example that is a nice benefit but you might remember from Van life when we first implemented the ability to go to the Vans page and load up the Vans we used react state to show that we were currently loading the Vans and we had a nice little loading message so that the user when they click the link would immediately go to that page and be informed that the Vans are loading when we switched to using a loader because it does the fetching before the component renders there's quite a bit of a pause before you switch to the next route so here if I click whether I will click it right now three seconds feels like an eternity especially when you're not navigated anywhere and it doesn't feel like anything really happened so on the developer side we get some nice benefits by knowing that our weather component will only load after the data has been fetched and is ready for display but on the user side we have a bit of a worse experience so over the next few lessons we're going to be learning about using deferred data this is going to give us a chance to bring back that user experience where clicking the link on a route that needs to fetch data will transition us to that route immediately and it will give us a nice API that allows us to render some kind of loading state in the meantime all of which we will be able to do without creating any of our own manual react state so buckle up and get ready to dive into world of deferred data it's probably safe to assume that some of you watching this might be a little bit hazy on your understanding of promises and how promises work I won't have time to dive deep into promises but one thing that I wanted us to remember is that when a function is an async function it will always return a promise so when I say await get weather that's an indication to me that get weather returns a promise because a weight can only be used on a function that is returning a promise if I go over to my utilsjs we can see that get weather is an async function and therefore it is always returning a promise when we say return data what's really happening under the hood is we are returning a promise that if it's resolved we'll return data it's not important that you have that perfectly memorized or understood the point that I'm trying to make is that when we have our loader function and we are calling a wait get weather What's Happening Here is we are waiting for the get weather call to finish and remember get weather is sleeping for three full seconds before it even executes the fetch request and then naturally the fetch request is going to take some time to complete as well and with loaders the code inside of my loader needs to complete before the component will ever get rendered by react that's beneficial to us because we know here that loader data will be accessible to us no matter what unless of course there's some kind of error in which case this component shouldn't get rendered anyway it will have some kind of error element that gets rendered instead but in order for us to bring back the benefits of switching to the route immediately before ever kicking off the request in our loader function we need to use a utility that comes from react router Dom called defer the entire process that we're about to go through starts with react router knowing that its loader function is allowed to wait or defer the loading of our weather data to a later point and therefore will not block the user interface from loading or more specifically it won't stop the weather component from being rendered before the data is completely gathered from the get weather function now we're not quite done yet because weather is still the actual value because I'm using this await keyword which is pausing execution of my loader function so I need to get rid of a weight which means that weather is no longer the actual resolved data from get weather I want you to pause for a second and think what kind of construct in JavaScript is this weather variable now that I've removed the await keyword well we can actually console log this let's console log whether I'm going to remove my defer right here and we'll probably get some errors here but let's give it a shot and see if at least okay good we can see that weather is not the actual weather instead it's a promise object so just for clarity I'm going to rename this weather promise now that we've gotten rid of a weight there we can get rid of our console log and let's bring back our defer call now what defer expects is an object and the key of that object is what I want to call the data that eventually will get resolved whenever the promise gets resolved and I'm going to pass to it the promise that eventually needs to get resolved and become the weather data that will get passed down to my used loader data I understand that we jumped around a bit so I'm going to undo everything and just show you that we actually haven't changed all that much okay this is where we were before we needed to import defer we're going to remove our await forget weather which means that this is not really the weather it's a promise to get the weather then we're going to call defer pass to it an object give it a key of whatever we want to call the data that we are deferring till later and then pass to it the promise that it should work on resolving for us and putting at this part in the object that's coming to loader data the tricky thing about learning this and partly why I call this an advanced topic is because there's quite a bit to put together before any of it will work so for the sake of practice I'm going to once again undo everything and have you type this out again so if you need to take a look at what we just typed in again try to commit it to memory because you're going to be typing it in just a second okay let's do it one more time start setting up our deferred data just like we did together and of course you can scrub back for a reference if you need to jog your memory again the tricky part is we're not quite ready to have this actually work for us so you're just going to have to try and do it for memory pause now and work on the challenge okay let's start up here again we're going to pull in this defer utility get rid of a weight we will call defer we're going to pass an object where the key is what we want to call the data when it gets pulled into use loader data and the value is the promise so let's call this weather promise this part is not strictly required it just makes it a lot easier for another developer to understand what's going on here and we'll pass this in now of course we could gain some shorthand benefits if we just kept this as weather because I could then just say weather but for the sake of learning we'll do this again I don't have a great way to test this yet because we have quite a bit more work to do down in our component so that's what we'll be jumping into next okay let's add defer to the loader of our vans route I added another one second delay on our server so when I click the van so we can see that it does take a little bit of time to get over there in the end I think it's important to remember that it's just a tradeoff that you have you can simplify your developer experience and also parallelize all of the loaders so any nested resources can be more easily retrieved and as we get closer to adding fur await and suspense we're going to see that we can bring back some of the snappiness that we got when we first started using react router that way when we click the Vans route it will take us here immediately and we'll have some kind of indication that the Vans are loading okay so for now your challenge is just to add the fur to our loader which is up here and then there will be more to the challenge later I have a quick reminder here in case that is helpful so pause now and work on the challenge okay let's go ahead and import defer from react router I'll put these on their own lines just to make it a little easier to read okay and now I can return a call to defer we'll wrap our get Vans get Vans is going to return a promise notice that this is not set up as an async function and we're not using the await keyword so git Vans is going to return a promise just because that's what it does in the API file and I need to wrap this in an object and we'll call the value that is going to be resolved maybe Vans like this okay short and sweet as I mentioned we still have some steps to take in order for this all to work together so let's go back learn a little bit more and then we'll come back here to Van life if we try to get to our weather page now we'll see that well we are broken and that's because the protection that we had before where we could be certain that our loader data would be defined and ready for us to use when our weather component was mounted is no longer the case and that's because we are allowing the loader to defer for a later time and we're no longer awaiting our get weather call so the next piece in this puzzle is to use a component from react router called await a weight does a few different things first of all it allows us to surround the code that we will be waiting for when this component first renders and it will conditionally render only after the data has finished loading it'll make a little more sense if we just do it so I will put in my await component and this will not be a selfclosing but instead will take some children and I'm going to move this H3 and this image out and just comment it out for now we'll bring it back in in just a minute and there's two major parts to the await keyword that we need to use the first one is a prop called resolve our job is to pass the promise for the data that we're trying to get to this resolve prop and I want you to think for a second where am I going to get this promise from well up above we are returning this object that has a weather property and we're pulling in loader data kind of like we had before except before it was the actual data let's go ahead and console log loader data and we might still have this unhandled error thrown but let's see if it logged that to the console okay loader data is an object that has a weather property whose value is a promise so that's the promise that we need to pass to resolve in other words we give our promise to this await component I'll call it loaderdata dot weather and under the hood the await component will take that promise and after it has been successfully resolved it will call a render prop child function earlier in the course when we were talking about Dynamic class names with the nav link component from react router I mentioned that if you are taking this react router course as a part of my larger Advanced react course we will have already talked in detail about render props and how they work if you're taking this as a standalone course you may or may not be familiar with the concept of render props but as a quick high level overview I can can pass a child to a component and that child doesn't necessarily have to be another component we're very used to having parentchild relationships with our HTML or our jsx elements like we have already here but when I have a custom component I don't necessarily have to pass another jsx element as the child to my component instead I could pass a function for example and the code of that component could take that function and run it passing any arguments to it that it wants to that was a really quick rundown of render props and probably didn't do it justice so I'd recommend going and checking out my Advanced react course to get a much more indepth look at render props that said the await component does use render props as a child and when our promise finally gets resolved it will pass to this function the loaded weather and we can call this whatever we want but in our case it makes sense to call it loaded weather and loaded weather will be the data that we used to be calling loader data so inside of this function is where one we can have access to our loaded weather for example this icon is going to be broken because loader data is a promise and does not have a weather property that's actually the error that we see over here it's saying that we can't read the property icon of undefined and so I'm going to bring in this URL assignment inside of my render prop over here and I can make the changes needed like changing loader data to loaded weather in fact let me move this console log down and we will console log our loaded weather so we can see what we're working with and there's a chance we'll have an error let's take a look okay and it did take a full three seconds plus a little bit to actually render anything on this page but you can see that the loaded weather is the weather object that we were working with before and because the await component will only render the children inside of the render prop or rather it will only call this child function after it has finished resolving our data we can again like we had in our original setup be sure that loaded weather will exist when we're writing our code here so let me get rid of my console log and I do want real children to exist here so I'm going to return the markup that I want to display when the loaded weather has finished actually loading so I'll open this up and I'm just going to put a fragment and then pull in these components that we had before now at least we're not broken let's hit save we'll see that it will also take a bit of time for it to load so I'll hit save right now okay and then lastly we need to update loader data here to be loaded weather and let's go ahead and hit save again I'll hit save right now okay it's working obviously we haven't quite fixed the user experience issue but we were on the weather route of course we could see that even the navigation bar didn't render which is a problem of its own that we're about to fix and cool well it might seem like we're done but once again there's a lot of pieces to making this work in the way that we would expect and we can actually get some insight into the problem that we're still facing if we go to home and then go back to weather we'll see that it says a component suspended while responding to synchronous input that doesn't necessarily have to make sense but it is something that we are going to fix by using a tool that comes directly from react not even react router this time but from react before we plow ahead because we have covered so much ground I want to get your hands on the keyboard practicing these things I know that we covered a lot of ground here and it may start to look a bit complicated but the truth is all we did was we added an await wrapper around the code that we wanted to display after the data had been loaded and we put that markup inside of a child function that will receive the successfully loaded weather and allow us to return whatever user interface that relies on having that successfully loaded weather let's bring this back over to Van life so we can practice this and then we will come back we'll learn about suspense and then come back again to Van life and apply it admittedly the code in our weather app is significantly more simple than the code here in our van Life app and so I've made a note of this your challenge is to implement a weight however it's important to note that the code here is more complex and so rather than maybe spood and feed you the answer or set you up perfectly for solving this I think this might be a good opportunity for you to really put on your critical thinking hat and see if you can solve this on your own really quick I'll highlight what the issue that we're going to face is and then I'll leave it up to you to figure out a solution there's going to be more than one way to solve this in fact we're going to see two different ways so the issue is before when we were pulling in vans from use loader data we had the Vans available to us but now because we're using defer we just have an object that has the ability to resolve fans eventually the benefit that we had before was we could just assume Vans were available to us but because we are deferring the loading of our vans to after the route transition happens we have to make some other tweaks the reason this is a problem is because we are making use of this Vans array for example when we filter the Vans and create our display Advanced variable and then we map over that in order to create the van elements and then at the bottom we render our van elements way down here at the bottom so you're going to have to think carefully about where we use our await component because I can't just put it here inside of the rendered markup near the very end because because at this point in the code it has already attempted to make use of the Vans array even though it's still an object with a promise inside so give this your very best shot I understand this might be a little more difficult but I also think it's really good to stretch yourself and push yourself in order to grow so pause now and work on this challenge okay so one thing that I think will help us figure out how to organize this would be for us to accurately name what's going to be coming back from use loader data because the name Vans implies that we have access to the Vans I'm instead going to change this to something like data promise maybe this way I can immediately know that I'm going to have some problems when I try to for example filter over the Vance Ray because I don't have access to the Vans array anymore so let's go down to where we're starting to return the elements that we have and I need to decide where I want my await to live I think it might be okay for us to leave our H1 as soon as we get to this page because it's not waiting on any data but I don't know that I want my filtering buttons to display if the data isn't there so maybe right below my H1 I'm going to include my await component and I need to make sure to import that and then let's just wrap everything that we have below it that'll go down to here and we'll format this okay and then the await component will take a resolve prop and we're going to pass data promise and in our case we would just specifically want to wait for the Vans array to resolve then await expects a child function so I need to enter into JavaScript and then put in my function here and we'll open that up and this function is going to receive the array of Vans as the data now that I have access to this Vans keyword I can just take everything above it that was expecting to have access to Vans and move it inside of that child function so I want to have all of my van elements because that relies on displayed vans so I'll need to bring in display Advance which relies on the Vans array so I'll just go ahead and cut all of this and paste it down here where to go inside of my await render props function here so we'll paste it and format it okay and then I have all of this markup that I need to be returning as the children elements so we'll go ahead and cut that out and right here below our van elements we will return and then we'll paste that back in and I think we have an issue here because we're trying to return two divs so let me just wrap these in a fragment and perfect okay that seems to fix that Let's cross our fingers and hope for the best we'll hit save okay and we have an issue right now where the entire screen shows up as blank we're going to be fixing that very soon but we have our vans data showing up awesome okay as far as a weight is concerned this is a great start we could just leave it like this but I did want to show just for the sake of learning another way that we could solve this problem it's actually only going to be one extra Step Beyond what we've already done and then we'll be able to learn the final piece we need in order to get the user experience back that we're hoping for which we'll be able to show a little loading State here when we get to this component so I know this challenge might have been a little bit difficult if it was that's completely okay as I always say it's important for us to get experience by trying these difficult things so if you weren't able to solve it on your own that's okay as always just scroll back and try again remember there's nobody that's giving you any kind of grade by completing this course faster it's more important that you grasp the concepts that we're learning and reach out to the community for any help you might need for just kind of plowing ahead so take all the time you need with this code try rewrite writing it again if you'd like and when you're ready we'll move on and see another way we could solve this we've seen one solution where our await keyword is up here pretty high inside of our return and then we just grabbed everything that was above it everything that was I guess preparing the elements to be displayed and just shoved it down here inside of our return so everything is just happening right here in line this isn't terrible by any means but it is a little bit difficult to parse and to read because everything is so deeply nested but if we think about it what we have here is a function that is handling all of the preparation for what should be ultimately displayed so one thing we could do and again like I mentioned this is just a minor refactor but hopefully it will improve the readability is we can take this whole function I'm going to go all the way down here to right here where the function ends and we'll just cut this out and we can see that was the right level because we just have an empty set of curly braces now and then before my return I can just Define a new function and maybe we'll call it render and elements and then let's paste the fun function that we just created and it just doesn't need to be an arrow function per se so I'll just go ahead and tidy this up I'll format this and so now everything is multiple layers less nested and I personally think is a little bit easier to read and then we can simply pass the reference to this function inside of our await way down here at the bottom so I think at least this has simplified the level of nesting and it's also simplified our return and then if we really wanted to clean this component up we could make kind of a utility helper function where this function render van elements might sit inside of a different file and then just import it if we really wanted to so let's hit save and see if this works in the first place okay we did get the delay where the screen is blank again that's what we're going to be fixing next but everything seems to be working and we can go into one of the nested bands perfect now it's time for us to solve the last little problem you can see if I click back to all Vans we actually get an error displaying saying that a component suspended while responding to synchronous input the fix for this is not something specific to react router but instead react itself so next we're going to start learning about the suspense component in react here we are back at our trusty weather app and you might remember that we had a little bit of an issue I'm going to go ahead and refresh this and we'll see that it's blank for a couple seconds and then all of our data gets loaded in at once not only that but if I go to another route and then try to come back to whether we actually get an error that gets thrown we can see that it says a component suspended while responding to a synchronous input this leads us to the final piece in our puzzle of actually creating the user experience that we originally set out to create and that is by using something that comes from react called suspense you can click the screenshot here to go directly to the react documentation on suspense it's fairly thorough so you're welcome to read through the entire thing if you want I'm not going to be teaching all of the ins and outs of suspense as a part of this course I'm simply going to be showing you how we can use suspense to finally get to that finished point that we've been trying to get to this whole time react has introduced the ability for mostly libraries thirdparty libraries to suspend and rendering of your react application until something has finished the benefit of this is we can treat our components as if they were synchronous like we see here where we're pulling in loader data and then we are just rendering what we need with that loader data instead of initializing our fetch request after the weather component is being loaded and then having to maintain the loading State and the error State and all those other things that we used to be doing suspense allows us to wrap our suspended component which is this await component in another component called suspense now I can just say react dot suspense here or if you don't like the dot syntax you could separately pull in suspense like this just to be totally clear that suspense is coming from react I'm going to leave it as react.suspense for now I'm going to put my closing tag down here after a weight and we'll indent and then the last thing that I need to do is provide a prop called fallback the idea of fallback is that it gives react an element to render while it's waiting for the other component that is suspending to finish in this case I can just put maybe an H2 that says loading and maybe I'll be a little more clear and say loading weather and with that simple addition I can hit refresh we see loading weather and then we get our weather now notice that I put my suspense boundary you could call it underneath my weather in Salt Lake City H1 if I were to move this up by one let's go ahead and indent that I'll hit save and we just get loading weather it doesn't have that H1 displaying anywhere and then it displays what is inside of the suspense boundary because I have this text hard coded it probably doesn't need to be inside of the suspense boundary but of course if I wanted to pull the city from my loaded weather which actually is part of the data that comes in then I would just need to move this down inside of this callback function so it would be down here where I'm returning the weather specific data I think the way it currently is right now is probably fine now that we've added this suspense boundary we also are handling that exception where this component was suspending and so I can go back to my home and let's go ahead and refresh just for giggles and then we'll go back to weather we get loading weather and then we get the weather loading in finally we're back to a point where the user experience is a lot smoother and sure we've had to learn a lot along the way and make quite a few changes to the code but in the end I don't have to maintain all of that errorprone react state in the meantime it's all being handled in a very declarative Way by other libraries okay I've talked quite a bit let's practice this in two phases I'm going to erase what I did and have you do it again and then we're going to move back to the van Life app again and have you implement it there as well okay simply put your challenge is to implement suspense pause now and work on the challenge maybe just to see it the other way this time I am going to pull in suspense as a separate component up there we'll just clear out this challenge since that's an easy one to remember and we will just wrap our await in the suspense component okay and we can't forget I need to give it a fallback property this is the element that will display while it's waiting for the suspended component to finish and so we'll just put back our H2 that says loading weather hit save we get loading weather and then we get the weather okay let's jump back into van life and Implement what we've learned short and sweet to your challenge is to implement suspense pause now and work on the challenge the error that we saw earlier was that the component suspended while responding to synchronous input and that component that's suspended is our await component way down here at the bottom so any components that are going to suspend we need to wrap in a call to reacts.suspense I haven't imported it separately so I'm just going to call it react.suspense and we'll move this down here in indent and then lastly we just need to provide a fallback prop and I'll just be a little bit boring again we'll just say loading Vans okay let's refresh okay we get explore our van options and we had our loading Vans H2 there for us while things were loading in and we're back to a really Snappy user experience now I do want to be totally clear it's not that big of a deal if you don't want to go out of your way to include a weight suspense and defer because maybe the transition to the new route is not taking very long we need to remember that I did include a delay right here inside of our server so it's pretty much manufactured delay I'll come back here to Vans and then we'll click on the vents route and we can see that it's pretty Snappy anyway even if it were to delay for a half second or so before coming to the new route in the end it really just depends on what user experience you want there's one last thing that I just want to touch on really quickly and that has to do with this defer function you can see we have changed this to be an object and that's because if we did want to include additional data maybe there was something like the user that we needed to pull in and we say get user then we could have different await boundaries and suspense boundaries depending on what data we want to display first or what data we do or do not want to defer on if there was some data that was absolutely crucial for us to load before we even transition to this route then we do have some flexibility because we can come to our function we can turn it back into an async function into any pieces of data that we want to delay transitioning to the new route for we can just include a weight in front of the Promise by doing this it means that the route transition will not start until this get user function has completed but if the get Vans function takes longer than the get user function then it will transition as soon as the user is ready and will get our suspense boundary while the get Vans function is still resolving in our case we don't have any use for this per se so I'll just go ahead and delete this but I just wanted to round out our experience there by mentioning that just in case that was useful to you at some point in the future by the way that is actually documented inside of the Deferred guide in the react router documentation so if you do want to learn more about it you can go there for more information now we've been working exclusively inside of our vans component here but we still have changes to be made in the van detail page the host Vans page and the host van Details page all of these are using a loader and could potentially be using defer like we just did in our vans page so for the sake of some X or exercise we are going to implement defer and await and suspense over in our host Vans route so that's the challenge that we'll be doing next practicing one little piece at a time I think can be really helpful for grasping the concept of something but it's also super important to take the time to put all of those little pieces together and challenge Yourself by doing them all at once it's kind of like learning a new language you could memorize little phrases here and there but the real growth will happen as you practice real conversations and put those phrases together and also challenge your own understanding when you're listening to someone else speak to you maybe I'm extending the metaphor a little bit but it's similar with music you can practice small sections of a piece of music but it's a whole different experience to put it all together and what people are expecting is not for you to just perform a small piece but to put the whole thing together and it's the same with our code here so your challenge is to implement defer await and suspense here in the host Vans route so pause now and work on this challenge okay well we know already we will need to import defer and await so I'll just do that now and inside of our loader we are going to return a call to defer let's wrap that in that function and defer expects us to pass an object and we'll give it the key of Vans okay so now this should be a promise that will get resolved eventually but we will not wait for the route transition to happen but instead we will defer this data for after the route transition happens okay so inside of our host Vans we were calling this Vans maybe let's call this I think we chose data promise before let's just stick with that we'll say data promise is coming from userloader data and our host van elements needs access to vans in order to successfully complete the map so let's do what we did before where we create a function and that function will be in charge of all of the rendering tasks here so we'll create a function that we'll just call render let's say render van elements that's going to take the array of Vans and we can move this host fan elements inside of that function and I'm going to keep my H1 like we did before but we will return this so let's cut this out and inside of our render van elements so I guess it will be right here we'll paste that in actually we need to return that so I'll type in return and then paste it in and now we have a function which will be the render prop child function that we pass to the await component so let's render weight and as the child of a weight we will render the van elements and we need to tell it what it needs to resolve that's going to be our data promise dot bands okay and since await will suspend rendering we need to provide the suspense boundary so that's with react dot suspense and lastly we just need to provide the fallback finally all back prop so that it knows what to do of course this is where you'd probably be better off putting something a little fancier like a fun spinner of some sort or maybe something animated that makes it a little more exciting than just saying loading bands but for now this will get the job done okay let's see how we did we'll clean up the challenge text and hit save okay and it was it was pretty brief it showed up as loading Vans for just about a half a second while it was loading I guess I can come back to my server and putting this timing delay and hit save we'll see if that makes a difference let's hit refresh okay we get loading Vans and then the vans come in this way the transition to the Vans page is really Snappy and we at least get some kind of feedback that says that the rest of the UI with the Vans is still loading awesome work I hope that went okay putting it all together can be a really good experience especially when we see in the end it truly wasn't that much work to do and instead we got to simplify quite a bit of our code or at the very least we got to give a little bit of a better user experience to our users now at this point we still have our van detail page and our host van detail page which is not using defer await and suspense but for the sake of not beating a dead horse I'm going to actually Implement those myself for the next Grim that said if you would like to practice this even more you can go to the van detail page and the host van detail page and do exactly what we just did in the host Vans page Implement defer await and suspense just to get a little extra practice I'm going to leave it up to you I trust you to know that if you need more practice with this you have have some places where you can do that more practice and if not you can move on we have just a couple of little Loose Ends to clean up so that's what we're going to do in the next lesson look at us here at the end of this project just dotting some eyes and Crossing some T's before we can finally call it done one thing we can look closely and notice is that we are still doing a little bit of manual error handling here we are maintaining our error in state and down here we have an early return for the error but a while back we did learn about the error element property or prop on routes let's see let's go back to our index here and if we go up here on our vans route we have this error element that is handling this for us but we haven't yet implemented that everywhere that we might need it as a reminder the error element will render this error component anytime there is a thrown error either inside of this route or inside of any of its children routes if you've ever created an error boundary component using class components this essentially gives us a really declarative way to create those error boundaries on the route level but we have only done it here on the Vans path so let's open up our vans page again where our challenge text is your job is to remove any menu manual error handling code which I believe is only in this component this Vans component right here and also to set up an error element for error handling on the following routes that I have listed here as I mentioned we created an error component that you should be able to reuse for those error elements that you put on the routes so pause now and work on this challenge okay well let's get rid of our react State here and this early return we don't need those and actually this should be pretty simple I'm just going to check just to make sure but it looks like I don't have any react state that I'm maintaining here or any error handling over in my host Pages we've got host Vans yep it looks like we already removed the error handling there and host man detail same thing there okay so we should just be able to go over to our index page and honestly I'm just going to take this error element of air and start pasting it everywhere that needs it this is our van detail page we want it there we also want it see here we have a loader that is grabbing some data we'll put it there and with our host van detail page okay let's hit save we're going to log out just to make sure that we're logged out we'll go to the host page you must log in first if I try to go to slash host slash Vans okay we get the same thing login okay that loads just fine and then we can really test this by going to the server and here on the Vans page I have this commented out just in case I needed it again we're just going to hard code a 400 level response from the server and I'll go to Vans and okay it's not super pretty we could probably make some improvements here but at least our app is not completely crashing because we have this error boundary let's undo this so that we aren't hard coding an error and we'll refresh just to get our vans back you have been doing an amazing job following so far so you should definitely take the time to congratulate yourself and if you've been sitting down for a while maybe it would be a good time to get up stretch take a breather walk around outside if the weather permits and really soak in that good feeling of everything that you've learned and accomplished in this course while we're on the topic of dotting our eyes and crossing our T's I do have a little present for you so I'll reveal it to you in the next scrim now we have been staring at these default dashboard goes here income page goes here Pages for far too long and so my surprise to you is that I have completed them for you however to be honest I've taken some pretty serious shortcuts here just for the sake of getting the design up if we come to the income page we can see this graph well it turns out this graph is just an image and the image is completely static it's not pulling data from anywhere I've done the same thing over in the reviews page we have this reviews bar chart and this is just an image that's being rendered here if we go to those pages the income I just created uh transactions data array That We're looping over and displaying same with reviews we just have some reviews data hard coded right here inside of our component of course if we were doing this for real and we actually had a server where we could get this data from we would be pulling this in inside of our loader instead of doing it in any kind of use effect here inside of our component at this point in the course we have covered all of the topics that pertain directly to react router that we planned to cover I suspect you have spent a fair amount of time on the react router documentation as I have sent you there a number of times throughout the course so when you find yourself working in react router in your own projects hopefully you not only feel really comfortable with the topics that we have practiced and learned but also feel comfortable going to the documentation and learning what you need to learn I also can personally recommend that you check out the remix Discord server since react router is a part of remix if you have any questions about react router there's a really great help Channel there that some of the core contributors to react router and remix will oftentimes be able to answer questions from in the last part of this course we are going to be jumping into using Firebase as our mode of storing our data and grabbing data from a real database online our mirage.js server has served us really well throughout the beginning parts of this course and as a final way to tie the bow on this app we're going to migrate our data to Cloud firestore which is a part of Firebase and refactor our app so that we are pulling data from a real database as I mentioned mirage.js has been an awesome server for us thus far however it's time for us to move on to a real online database so that we can really round out this project piece and if you're someone who's searching for a job especially if you're just learning web development for the first time using a service like Firebase can be a great way to get real data real API endpoints that you can reach out to without necessarily having to build and maintain your own server and database so for this lesson we are going to walk through how you can set up Firebase and specifically we're going to be using firestore which is one of firebase's databases so that we can migrate our data over to Firebase and if you are following along here on skrimba.com then this would actually be a great time to stop following along here on scrimba and actually download this code to your local machine and follow along on your local machine instead in order to do that you can go down to the little gear icon in the lower right now at some point in the future scrimba's design is going to change so it's possible that this gear icon may not be exactly here in fact everything my might look completely different but either way you can search the app for this option that says to download as zip or at least worded something similar to that once you download this project to your local machine and unzip it you should have access to a folder now I'm going to be using vs code for my editor you can open that folder in whatever editor you prefer and then you need to install the dependencies now I've done that here all in one line with this double Ampersand so what I did is I ran npm install or npmi for short and as soon as that finishes I'm going to run the development server by using npm run Dev you can see that under the hood we're using Veet in order to package and bundle everything up and it should be really quick when you do this once that's all set up you should have a new folder called node modules in your project and it should tell you that you have a local environment the default I think is at Port 5173 where you can open up this project locally okay at that point we can head over to the Firebase home page you can click the screenshot here to head directly there and once you are there on that site you can click the button to get started that'll take us to a screen where we can create our first project so we'll click the button create a project we'll enter a project name I'm just going to call it van life and we can hit continue at that point we'll be given the option to include Google analytics in our Firebase project if you would really want to this will take a bit of extra setup so for now I'm just going to uncheck that and then click create project we're then sent to a loading screen and when it's ready we can click continue and that will drop us into this project overview page which is sort of a dashboard for this van life project Firebase projects can consist of multiple different applications like for example if you had an IOS app that was a dedicated IOS app and a dedicated web app for now we are only concerned with the web so I'm going to click this little angle brackets web icon here in order for us to register our web app we need to give it a name so I'm going to just put in Van life here or if you knew ahead of time that you were going to have other apps you might call this something like van life web and then I'll click the button for Register App and this will give us some important installation information that we are going to need so this would be a great time to click the little copy button or of course you can highlight it and copy it if for some reason that gets lost after you copy it that's okay it's pretty easy to get back here and I'm going to show you how to do that once you have that you can click continue to console and this will drop us into the web app that we just created for Van life and the next step is to tell our van life project that we want to use firestore as our database so probably the most accessible thing is just to click the Big Orange rectangle here that says cloud firestore or over on the left you can drop down the build option and click the firestore database there clicking either one of those will take you over to the cloud firestore homepage where we can click this create database button it's going to ask us if we want to start in production mode or test mode and this is kind of an important thing to understand about Firebase you might have noticed that a couple slides back I was completely okay exposing this API key and if you are familiar with the concept of API Keys usually you want these to remain secret for most API keys that I've used at least they expect that you keep the API key hidden you don't commit it to your GitHub repository and you only make requests using that API key from a server of some sort however Firebase is a little bit different and that's because they use something that they call security rules in order to secure your data so you can see here in production mode if you look closely it says allow read write if false which means that nobody not even yourself could read and write data to your database this is their way of forcing you to take the time to learn about security rules and actually Implement what makes the most sense for your needs but for us we're going to be okay just starting in test mode which basically says you are allowed to read and write for about the next month from when you created this database for now that's going to work okay for us you will need to make sure that you look up a little bit about how to create security rules with Firebase but for now this is going to work okay for us so I'll go ahead and click next it's going to ask us to set our location you can click the drop down and just choose the location that is closest to you geographically and then click enable that will drop you into the cloud firestore database view where once you have some data in here you'll be able to actually peruse the data and see all of the data that you have in your database what I did on my instance of this database is I actually just copy and pasted the data that we have from our six van objects and put it here in Cloud firestore for us so that as we start doing our refactoring we are primed to grab that data from firestore and that is it we have set up our Firebase firestore for us to start making changes to our code and even though that may have seemed like a lot of different steps to take if you think of the alternative which would be to spin up your own server and connect the database and have database structures and everything set up this truly was like a walk in the park so let's jump into our code and we will start making refactors so that we can pull data from our Firebase firestore instead of using our fake mirage.js server one really nice side effect of us having put all of our fetching code here inside of our api.js file is I won't have to go to all of my components in order to change where I'm getting this data from right now we're doing a fetch request to this local API which is handled by mirage.js and all we need to do is change where that data is getting fetched from so that's what we're primarily going to be working on but first we need to set Firebase up in our code so that we have the ability to access our data from firestore you might remember me asking you to copy down that configuration object if you did great we are about to use it if not it's pretty easy to get back to from your Firebase console you can click on the gear icon in the upper left and choose project settings that will take you to the project settings page and on this General tab if you scroll down to the bottom you'll see that configuration object again and you can click the rectangle to copy that so that we can use it then back in our api.js file I'm just going to paste that in and we can just clean up some of the these comments for now and I'll give a little bit of space before our actual API functions just so we can clearly see what is Firebase related now Firebase is a whole Suite of different tools and firestore is just one of those tools here we have initialized an application which will allow us to connect to our van Life Application in Firebase we also need to write code that is specific to firestore so I'm going to import a function called get firestore which will come from Firebase slash firestore now one of the major benefits of firestore that we actually aren't going to be using very much is its ability to have realtime data in other words I can create a connection between my application and the database and if that data ever changes in the database my application can listen for those changes and without any prompting on my end refresh my user's view so that the data can be real time this is perfect for applications like a chat interface where you want a new chat message that gets pushed to the database to also immediately display on your front end without the user having to do any kind of refreshing of the page however in our case we are not going to be using any of those realtime features from firestore and so I found there is actually a subset of this package Firebase firestore called slash Lite which is a lighter weight version as the name would imply of the full firestore library that allows you still to do reads rights updates and deletes but without including any of those realtime features so because I don't need the realtime feature I'm going to go ahead and use the slash Lite version of this library but if you do feel like you want to play around with the awesomeness of firestore's realtime data then you can just delete this slash light at the end now that we have access to this function called get firestore I'm going to create a database object which I'll be using anytime I need to interface with my apps firestore database and so I will set that equal to get firestore and I need to pass in the app that we just created when I was initializing the app and with that we should be set to start refactoring the fetching functions that are currently reaching out to mirage.js so that it will instead be reaching out to Firebase so that's what we'll be starting on next right from the start I'm going to show you the documentation for firestore you can click the screenshot to go over to the documentation one thing that I noticed as we are using this web version 9 which is more modular is that it includes a lot of nested function calls for example when we want to get documents from a certain collection most of the documentation shows calling this function called git docs and inside of that you pass a call to the collection function and inside of that you pass your database like the one that we created and the name of the collection that you're trying to get this might be completely fine to you maybe this makes perfect sense it makes sense to me but it's still a little bit confusing it also requires a lot of duplicated code where I'm going to be writing collection DB and in our case Vans multiple times so I'm going to do it a slightly different way I'm going to reference my collection in a separate variable so I'll call it maybe Vans collection ref and set that equal to a call to the collection function I'll pass in my DB that that I created and pass in the string Vans before anything else I need to make sure that I pull in the collection function because this is something that comes from Firebase and if you're wondering why this string Vans is here if you remember back a little ways when I was creating the data I had created a collection that I called Vans if I had named it something different I would need to put that different name here now first things first before we move on I lost a lot of hours trying to figure out when I was practicing this why my requests out to Firebase weren't making it all the way to Firebase in fact they weren't even making it to my network tab in my developer tools and the reason as it turns out is because mirage.js was intercepting every request that goes out this makes a ton of sense when you're using Mirage because you can make a regular fetch request in your code and not have to worry about it trying to reach out to a real resource or anything however it did cause me to pull my hair out quite a bit as I was trying to figure out why I couldn't get any data from Firebase but fortunately mirage.js has a really easy function that we can include called this Dot passthrough and we can put any URLs that we want mirage.js to allow outgoing requests to so if you're following along suppose one thing you could do is just delete this import server from your index file or I think maybe a better solution would be to use the this dot passthrough function and just make sure that you include this URL so that any requests out to firestore will make it past the sort of net or sieve that mirage.js puts up okay let's go back to our api.js file and start working on our get Vans function I think what I actually might do here is comment this out as I start working on them and create a new version of it so I'll just export async function get Vans and maybe I'll worry about this ID thing later if I need to something that can be really helpful to understand about Firebase because of those features where it can have a realtime component to it anytime we go to get data from Firebase it calls it a snapshot the reason is if we were to make a request to get the list of our vans and then after we got the data back let's say a tenth of a second later that data were to update somehow the data that we just got from Firebase would technically be outdated so the terminology of snapshot starts to make a lot of sense because it's sort of like a snapshot of the data at that given point in time but with the understanding that it could have changed even perhaps immediately after we finished making our get request to the firestore database so that's just a preference as to why I'm about to name this variable a snapshot so we'll call it query snapshot and that is going to come from a call we'll use the await keyword it's going to come from a call to the function called get docs I need to pass the collection reference that I want to get the documents from and that's going to be our vans collection ref and what we'll come back will not just be an array of documents but instead will be this snapshot of the query of the documents really that just means that it's going to have a bunch of additional metadata about the docs that come back when we take the snapshot so what I'm going to do is take that query snapshot and turn it into a data array that hopefully we can make it so that it mirrors the same data structure that we're already expecting in our component files so that we don't have to go make a bunch of changes to our components so I can do that by mapping over the documents that come back in the query snapshot I can access those by saying I need my equals so we'll say equals query snapshot dot docs and this one is an array of those documents and I can map over that array I'm going to look at each one of the documents in that array and I'm going to return an object and I can just do that in line by surrounding my object in a set of parentheses just so that it doesn't confuse it with me opening the body of this function and I want to include all of the data from the document so I can get that data by saying doc dot data and then calling that as a function and as it turns out this data does not not include the ID of the doc and so I also want to include that as a property here that I specify with doc.id this ID could be something that is generated by firestore when you create your documents or in our case I created this manually so that I could just have the simple IDs of one two three four five and six okay we went through that blazingly fast I guess as a side note it's important to know that I'm going through this Firebase information more as a reference instead of actually teaching it and that's because in the scrimba frontend developer career path we introduce our students to Firebase pretty early on in the career path and much of this has already been taught so I just want to preface why it seems like suddenly Bob is going really fast through this information instead of making me sit and practice it so let's go ahead and console log our data array and then we need to make sure that we also return the data array so that it can be used by any loaders that are calling get Vans now if I try to load up one of my van detail Pages it will probably be broken because the old version of get Vans was able to take an ID and those van detail Pages need to pass in an ID so let's just avoid doing that for now I'm going to go back to my home page and then we'll click the Vans page oh okay well actually this error boundary has been really helpful I called get docs and let's see where was that right here and I forgot to import it so sorry for anybody that was screaming at me to remind me to import that okay let's try saving okay so our vans came in we have our console which is displaying all of the information that we have saved in firestore what's really nice about the way that we have this setup is I didn't have to make any changes to my components or my pages because we had a nice separation of concerns where we had these API functions that are in charge of getting the data that is needed by the pages we can just make changes to those functions and get the data from a different place as long as that data is in the same shape you could say as what we had before everything should just kind of work out the component shouldn't really care how how or where the data is getting fetched from you really should just be taking that data and displaying what it needs to display accordingly okay we still have a bit of work to do because right now if we click into one of these we can see that a bunch of information is missing and that's because we have altered our get fans function it no longer has the ability to take an ID so next we will start working on being able to fetch data on a single document so that we can fix this page in the earlier iteration of our get Vans function we had this one that was a bit overloaded it was able to take an ID and if it had an ID then it would call out to this endpoint and if it didn't have an ID it would call out to this endpoint I'm going to just make an executive decision to split these functions into two separate functions one really good approach when you're creating these functions is to make sure that your function can do one thing and it does that thing really well this will also help with unit testing if we were ever to add unit testing to this project so I'm going to create a new function we'll export the async function we'll call it get van just singular and that will take an ID this does mean that we'll have to go into any files that originally was calling it Vans and passing an ID and instead just update it to say get van and we'll have to import it as well when we have access to an ID and we're reaching out to firestore we really only want to get a single document before we created this Vans collection reference using a collection function that comes from firestore this time we only need to get a single document reference not a whole collection reference so right inside of our get van function I'm going to access that document by using a new function called doc just like how collection was a way for us to get a reference to a collection Doc is a way for us to get reference to a single document so I'll need to import that we'll bring that in right after collection and I will save this as we'll just call it maybe doc ref it's going to be Doc and the dock is going to take three parameters where the collection took two it took the database instance and then the string of the collection that we're trying to get from that database we're still going to take the database we also need the string name of the collection that we're reaching into but then even one level deeper we need to pass the ID of the document that we are trying to get and that's the ID that's coming from our function right here now that we have a document reference we can get a document snapshot maybe I'll call it van snapshot and that's going to come in by calling a function called get doc just like we had get docs in order to get an array of docs I can use get Doc in order to get a single document then just like we did before where I passed the collection reference to get docs I'm going to pass the document reference to get Doc and at this point I think it actually would be helpful for us to do just a little mini challenge so I'll go ahead and type that out okay we have access to our van snapshot and in this case unlike what we were doing with get fans we aren't going to be iterating over an array of documents because we already have access to the one document that we're trying to get so I haven't necessarily taught how to do this but I'm hoping that through some inference looking at our function up here or if you would really like to you can go to the Firebase documentation to solve this Challenge and figure out what we need to return from the getvan function and as a part of that you'll have to go over to the van detail page and switch it so that it uses this get van function instead of the other get vans that it's currently using okay so pause now and work on this challenge what we had to do before was iterate over the array of documents and take each one of them and return this object here which has all of the data from the document and then it separately gathered the ID from it as well since for some reason the ID property of the document is not included in the data of the document well in our case we don't need to iterate over an array we can simply return the object that has all of the values from the van snapshot and rather I should say all of the values of the data portion of the van snapshot and then we will also create an ID for it which will be van snapshot dot ID this should put it in so to speak the same shape as what the original get Vance was doing before at least we'll hope so so let's go over to our let's see where is it van detail we're going to pull in in this case we don't need the get Vans anymore we're just going to do get van and then we'll need to make sure to change it in our loader and actually I think that might be it let's see we're already on the vanity tail page Let's cross our fingers and hit refresh and hmm then snapshot.data is not a function I bet someone else has already seen what I did wrong here we need to use await get doc okay let's try again super close awesome there we go I should be able to go back to all Vans and go into a different one perfect I guess while we're at it let's get rid of this console log up here we'll clean up the challenge and we can actually get rid of our old function as well okay now let's go back to our host pages and we will change our functions so that we're getting vans from Firebase instead of from our fake server let's switch over our get host demands to pull from Firebase instead of from our mirage.js server now you might remember over in server.js our get fans or our host fans is just hard coding the host ID of one two three since we're not dealing with authentication right now I'm going to do essentially the same thing but this time we'll be pulling it from Firebase instead of from mirage.js so in our api.js file what we are going to write will be very very similar to what we have in get vans so I'm going to copy that function and bring it down here and then I'll rename it get host Vans and comment out the code we have in the existing get host Vans and for now we also are not going to overload this the way we were before where it was taking an ID so we'll just forego putting an ID here in the parameter list now one thing to know about grabbing data from Firebase if you are trying to get the entirety of a collection then you can just pass the Vans collection reference that we created up above right here you can pass that to the get docs function and it will just get all of the documents from that collection however if I only want to grab certain of the documents from that collection then I need to create something that's called a query don't let that be confused with the query snapshot that we had before in fact we might be better off calling this something like van collection snapshot but just for legacy Reasons I'm going to leave it as query snapshot and maybe for now I'll just call it Q to mean my query and we can call a new function that's called query so we'll go up to the top here I'm going to put these on their own lines and bring in query and query is going to take let's see where are we down here query this function is going to take first The Collection reference that we want to filter through and secondly some kind of filtering operation and this filtering operation is going to come from yet another function that we pull from Firebase called where so let's go ahead and pull in where and you'll see why it's called where in just a second because when we're calling it we are going to provide three different parameters the first parameter will be one of the properties of our documents in our case we have a property called host ID and so it's saying where the host ID and then the second parameter is going to be some kind of equality operation in my case I want to say that the host ID is equal to and in Firebase we'll just use a double equals I don't know that they have the same conventions that JavaScript has with the triple equals so in the docs they talk about using a double equals so where the host ID is equal to and then we provide some kind of value in our case like I mentioned we're going to hard code this to the host ID of one two three so you can see why it's called where it's kind of like an English sentence where the host ID is equal to one two three I know that the Syntax for this is admittedly a bit strange but that's just how it is in Firebase and what we've been constructing here is a query object that we called q and that will allow us to filter documents out of the van collection so instead of getting the entire van collection we're going to pass our new Q variable or our query that we just constructed to get docs at that point everything else should essentially be the same we're going to receive an array of data we're going to Loop over it change the shape of that data so that it fits the way that we need it to fit and I think we should just be able to hit save and see everything kind of just work the way it was before in fact it's a little bit difficult to tell that it's working at all let's just make sure this is the code that's running we'll just you know Firebase at it in our console okay well that's running so great we can go ahead and get rid of this this old version of the function and because we have the same name it should just work however the function that we just deleted that we had commented out is what is controlling the detail page so this is what we're going to fix next just for the sake of completion we're just going to take a look at the instance where the host wants to get a single van now because we're not using real authentication we're not actually going to be able to make it so that only the logged in user can access their Vans remember we're currently hard coding that the get host fans is coming from one two three if I were to change this for example to 456 and hit refresh our host fans will show reliable red because in the database reliable red has the host ID of 456 and apparently no other Vans do because we're also pulling from get host fans on our dashboard by changing it here in our api.js file it also updates our dashboard at the bottom when we have your list advance but the problem is when we go to the detail page of these vans so I think if I click view we can see that the van information is not coming in currently originally git host Vans had the ability to take an ID but with Firebase if we are trying to get a single document that also is ensuring that the currently logged in user is the only one that's able to see it then we would have to set up some security rules inside of the Firebase console in order to ensure that we were only getting Vans at the currently logged in user was allowed to see since we're not dealing with authentication and really not bothering with some really stringent security rules what I'm going to do is simply go to my host van detail page and instead of pulling in get host Vans I'm just going to pull in get van as this will allow us to pass the ID and I guess I'll need to change it down here as well that way this page will get fixed again of course the problem is that anybody could go to this page and see this information because we're using a more public version of this get van function that doesn't really care what the currently logged in user is for us right now this isn't a big deal because we don't actually have any edit functionality in our app at this point anyway so it doesn't really matter somebody could just come up here and change the url to instead of host fans 3 they could maybe say host fans five and come to that page but again there's no edit access so it's not that big of a deal and that does it folks we are here at the end of the react router course congratulations great job on all of the challenges that you did all the quiz questions that you answered and in the end this amazing app that you had a chance to build by following this curriculum hopefully this gives you a really great appreciation for react router and just the concept of clientside routing in general there's a ton more that you could be learning but I think this would be a perfect time to head over to the scrimba Discord server and post something in the today I did Channel you can click the link to the screenshot here that will take you over to the Discord server and just let people know that you completed the react router 6 course and that you completed all of the challenges along the way so what comes next well as I mentioned multiple times we don't have real authentication in this app the main reason is because that would have taken us on quite a bit of a detour that I wasn't quite ready to do as a part of this curriculum but that would be a great thing for you to spend some time on just learning how to add real authentication another thing you could do is just to figure out a project that you are intrinsically interested in and build something completely unique now that you have the knowledge that you need to do clientside routing inside of an app the world is completely open to you another idea and this is a little bit farfetched but you could try to build this van Life app again completely from scratch entirely on your own it might sound mundane when I say it like that but the truth is that would be one of the best things you could do to solidify all of the information that we just learned even if you ended up building it in a fairly different way than what we did together that's completely okay it would be a great learning experience nonetheless another idea and this is a bit of Shameless selfpromotion but since you have made it here to the very end of this course I assume that you enjoy to some degree my teaching style and I apply all of my same pedagogy including tons of practices quizzes and project building over in my Advanced react course on scrimba the advanced react course does require a scrimba pro membership and it is part of the frontend developer career path which is tailored to helping people go from knowing absolutely nothing in web development all the way to being prepared for interviewing for their very first jobs and lastly you've heard me make the parallels a lot between react router and the remix framework I can highly recommend the remix framework it's a great way to dip your toes into full stack web development one of the greatest things I think about the remix framework is that their Mantra is to rely on the native web platform and so for me personally as I have been learning remix I have learned so many new things just about Native web that I feel like I probably should have known at this point in my career so feel free to check out the remix framework if you'd like to dive into a full stack framework I have been your instructor Bob zarol I'm most active these days on Twitter if you want to tweet at me or DM me you're more than welcome to you can click on the at Bob's role link here or on the Twitter icon to take you to my Twitter profile and with all of that said congratulations on finishing this course