instead of a boring portfolio why not make a game in this tutorial JS Legend Dev will show you how to use JavaScript and Kaboom JS to create an interactive developer portfolio hi everyone welcome to this new video today we will be building a 2d portfolio project so it's a 2d developer portfolio but as a 2d game and without waiting much further let's jump right into it so this is what we're going to build you can move around a house and then as you approach objects you can have a text box that tells you a bit more about uh yourself here I've selected some text for example here there's my CS degree this is my CS degree I hanged it on the wall because I'm proud of it and then if you move around you go here you have a place to have your resume can click if you click on that it will open a link with your resume hosted here for example this is just a template so this is how this is this is the idea behind a project here you have a bit of text so it's an original way of making a software developer portfolio uh I've seen a couple where it was in 3D but nobody seems to have made uh in 2D actually there there were some so I thought I would just teach you how to do it what's interesting here is that we're going to build this project with JavaScript and the Kaboom J Library so Kaboom JS is a library for making games in JavaScript it's very easy and intuitive but also for all that is the text here the text box the the text here as well this is all HTML and CSS uh here because the reason is that for this project everything should be uh interactable with the mouse or the touchcreen so if I open the dev tools and go to the mobile view and then here you should be able to move around and the text therefore should be responsive so here example you have a text and that's it you can close so for this to be achievable for the game to work on all aspect ratios it was important for me to make the UI portion of this project in HTML and CSS so let's jump right into project but before we do that I just want to mention a few things so if if you're interested in having written tutorials you can go to my substack the link will be in the description below where you can have written content that explains uh specific Concepts so on YouTube I make ful length project tutorials and sometimes you just want to know how to do one specific thing so the substack here my newsletter is for that so here for example for this project it's going to be relevant to know how to implement 2D uh topown controls uh for a mobile web game so here we go you have videos here that just showcase the results another thing I want to mention is just to uh showcase my uh buy me a coffee page so if you want to support the channel you can uh buy the the uh support with $5 a month and with this tier and you get access to this tutorial you're currently watching and all the future tutorials in advance so Early Access you you also get early access to the um do the source code and some progress updates as I do them so if you're interested in supporting the channel so I can focus more on making tutorials feel free to contribute here you can also just leave a a normal tip if you want all right so let's jump right into the project so I'm going to use for this project vs code uh it's the editor I use mostly for everything and here we're going to need a few things so let's start our project so I assume that you know how to use vs code at the basic level so you have it installed on your computer you also have it um you have no JS installed also which is going to be important for this tutorial because we're going to use vit vit is a bundler that allows you to um write your JavaScript in a more convenient way so we could use script tags as we did in a lot of the previous tutorials but with v you get uh uh you can install your dependencies by typing in npm install and it's it's just more convenient in a certain sense and you will also get Auto completion and U Snippets code Snippets from Kaboom from the Kaboom J library that tells you this is a this feature what it does which is something you don't get if you just use a script tag but feel free to follow using only a script tag if you want uh previous the setup sections of previous tutorials are going to teach you how uh so yeah I'm just going in this specific tutorial I'm not going to spend a lot of time on this so the first thing we're going to do do is to type npm create V at latest and then dot because we want to create the project within the same folder we're currently here in so here it's 2D portfolio so I hit enter and then we should have something appear need to install the following package yep and then here it's going to ask you to select the framework we're going to go with vanilla vanilla JavaScript and it's going to add a bunch of stuff so for now just do npm install Kaboom so it's going to install the Kaboom Jaz Library oops I I hit the wrong thing but hit enter is it going to work okay all right so it's going to install the project and then in your package.json you can see are your dependencies so here we have a kaboom all right now the rest of the project um we're going to need to set a few things up so the first thing we're going to set up is I'm going to remove a lot of the boiler plate you see here I'm going to remove main Jess I'm going to remove counter J I'm also going to remove this and with then v s G I think it's not needed as well so this this this remove and of and also the style at CSS we're not going to need need it for this project so delete okay now once we have this let's create a few folders we going to need the source folder SRC this is where we're going to write our code um our JavaScript code we also going to need the public folder I did deleted it by accident I wanted to just delete it was what was in the public folder and we're going to create at the root of the project a v config.js file this is going to be useful for a specific reason we want to be able to export so the way a bundler works it it compiles your JavaScript so the nodejs JavaScript that you write and the JavaScript that runs in the the browser is not necessarily this exact same thing so this bundler basically transpile or compiles your JavaScript to a JavaScript version or um it's a bit hard to explain to a version of JavaScript not not a version to JavaScript that can run in the browser as it is so y now the reason for this is that um a lot of features were not supported in the past in the browser version of JavaScript while in nodejs you could have things like convenient things like using import statements but now import statements are actually available in JavaScript in the browser so that's how I've been doing the various projects you've seen on the channel if you're familiar in the past in the past tutorials so in the V.C config.js we need to specify uh certain things so not uh just want to clarify again that not only does a bond lert transpile your code your JavaScript code so it can run in the browser it also do optimizations minification so that your your code is really Compact and takes the least amount of space all right so here I'm going to do export default and then Define config this is coming from vit so it's going to import it from vit here and then within we're going to have to specify the base so the base here when we run the npm Run build command which is used to do the transpiling and gives us the actual code gives us the actual code that is going to be used um that you actually put on your server or on h. to have your we website up we need this base thing otherwise it's not going to be able to find the assets for examp example the Sprites with used we use with Kaboom Jazz the second thing we need to specify is the build and here the minification we're going to use something called turer instead of the default es build so the reason for this is due to caboom there is a bug with the way Kaboom is made that if you just use the default it's going to give you code that doesn't work the the the actual output will not no longer work so that's why we need to install this alternative called turer which is going to make our code turer so smaller minified so once this is I should have installed it as a dependency so npm dd for dependency install um turer I think that's the command or if it's not that it's going to be the reverse all right now if I look at the package.json you can see that I A Dev dependency we have added turer okay we have everything we need so now I'm going to create a main.js file and in the index.html we're going to have to do a couple of things so I'm just going to remove that so the first thing we need is to create a style tag within the body this is where we're going to write our CSS now you could have decided to use an external uh CSS file but but because this project is not really CSS heavy it isn't really that necessary the second thing we need to uh modify is here the script tag that Imports the main.js file we need to actually modify the path to be Source like that because we we have created this Source folder in which is our main.js file okay now in the div we actually can work this out later but be um actually never mind here we're going to create our canvas that we're going to give the control of it to Kaboom so I'm going to call it game the ID is going to be game and here we're going to have a div that is going to have the ID of UI I'm not sure if I'm going to use this later on I might just remove this ID which just is going to contain everything that is the UI so the text box and text all right now that we have this in our source folder I'm going to create a file this file is going to be called Kaboom context. JS so CTX to abbreviate it and this is where we're going to set up Kaboom so I'm going to use import Kaboom from Kaboom this is possible because we have installed Kaboom JS and you can see that there is a difference in the way native JavaScript that works in the browser deals with Imports and how this nodejs version of JavaScript works so if we were to use the native JavaScript in the browser with modules you have to add the JS for the file extension you want to import but this is not needed when you're using a tool like vit okay so here I'm going to create our canvas um or Kaboom context which is going to be unique and through that object this K we're going to call all the functions we need so we're going to pass this around in our project I think this allows us to have cleaner code as we as the project grows instead of having to instead of importing Kaboom globally where every all functions can be called directly from anywhere so this is a pattern I recommend that you use for your Kaboom Jazz prod projects so in when you create a the Kaboom context you need to pass a few params actually don't need to pass any params by default but if we want to achieve the thing I I said about not making it Global you have to pass in the global property and set it to false then here this is going to be relevant for the fact that we want our project to work on moob mobile as well so we want to have the touch to Mouse property which again is from kaboom and set it to true it's going to translate all touch events uh on the phone to click events so that you can basically write your code with the mouse in mind but it's going to work just just as well with mobile and then finally we can have the canvas property where we're just going to give to Kaboom the canvas element and the way we're going to do that is by using document get element by ID and here we give it the game ID if you remember in index.html we gave to this canvas the ID of game so we're just telling Kaboom here take the the element take control of it and do whatever you want whatever you need okay so now that we have this everything is fine and in main.js we can start writing our code but you know before doing any of that let's create all the other files we're going to need so constant. JS it's going to contain as the name suggests constants which is also going to con take contain the specific dialogues and the scaling constants Etc and then finally we need the utils file which is going to contain a few functions that just to make our code look nicer so in this this project it should not take too much too long compared to my previous projects so yeah you don't if you could have made everything in just M.S if you want it all right so now in the public folder is actually where we're going to store our assets what I need you to store is the font monogram. ttf you're going to find this in the link in the description of this video if you're an early member of the yeah if you if you're watching this in Early Access you should have also a link I'm either going to drop it in the post or in the actual video so you should uh it should be obvious where to get it and now we're also going to need the Sprite sheet that we're going to use for this project this is the the Sprite sheet uh the link is in the description as uh as with the text and then uh finally we're going to use an external program called tiled to draw our Maps but for now let's just keep keep those two things and then in main.js let's actually start writing our code so I'm going to import K uh the the the context from Kaboom and here the first thing we're going to do is use the load Sprite function it's a function that allows us to load a an image as a Sprite and then we can specify a bunch of frames so here I'm giving it the name of sprite sheet and the second param should be the path where to find it and it's going to be Sprite sheet.png now the reason this is just SL spray.png PNG despite the fact that it's in the public folder so normally you would think that it would be do slash and then public SL spreadsheet the way V works is that you can assume that everything that is in the public folder can be directly accessed uh like that so this is something specific to V now the third Pam is going to contain a bunch of properties that tells Kaboom how to slice the image into various frames the first two properties is is the slice X so how many frames are on the xaxis here 39 how did I come up with this number I just counted I just counted the number of frames the the the number of frames here you could do that with tiled as well uh to give you the the number um and then this is something you should know so for example each of those is in is a a each frame in this image is a 16 by 16 tile and that means you can know roughly like if you take the the length of the image which is here 624 and then you divide it by 16 you're going to get the number of tiles of frames that are going to be on the xaxis so you can manually calculate it with math all right slice Y is going to again describe the number of frames there are in the Y AIS the same logic can be used to calculate it so knowing that every frame is 16 by 16 this is the way this Sprite sheet is designed you can just take uh look at the height of the image the properties or or here in vs code on the bottom right corner and you divide that number by 16 and you get the number of frames all right now here comes an interesting part it's called the anims property and here it's where you define you hook up specific names to specific animations so here the idle down animation for our character it's just going to be one frame and it's going to be frame number 536 now how did I discover this it's by using a program called til this program is called tiled and I think it's actually a good time to um create our Maps basically create our map and while setting things up we going to see how I figured out but just to be quick you click here on the frame you want and then you get the ID so the number of that frame now let's assume you don't have any knowledge of til so install til by using the link in the description once you have it you should have this editor let's assume you have a new project so I'm just going to create a new map and then let's um I don't remember the dimensions I I've used but don't touch anything here except specify the width as 16 pixel the height the height as 16 pixel as well as for the map size make it fixed and then take these numbers by default all right we have the the map here now another thing you can do because if you're using til on a wide monitor for example things might not be clear so you go to edit preferences and then in interface uh actually it's in theme you you you check use custom interface font and then you can select a specific font and then increase the font size this is useful for for you to be able to clearly read things once you have this in the map you can go to I think it was map properties actually maybe not World um okay in view snapping no snapping for this project uh if you clicked on snapping snap to Grid it's going to make sure that everything fits into a grid uh pattern uh I think for tiles it's in Grid uh pattern regardless but if for the collisions box we're going to draw we want to find more fine grain controls so that's why I dis activated it for this project okay now add a new tile set to the right okay now browse where you've put the the Sprite sheet in your project and Link it here so this is it so for the the path should be here and then this is specific to me so for you if depends on where you put it the actual project and then just don't touch anything the tile width and tile height should be 16 by 16 pixels and then hit okay and now you have the the spreadsheet so a good thing right now is would be to save the map so go to the the file save as and then name it map. Json and put it in the public folder of your project all right so you can see that I've named it map. Json this is the name I want you to to use and it's going to basically create a Json file in your public folder so if I minimize this and go here you can see that we have map. Json this is important because this is how we're going to know where to draw the hitboxes and where to draw certain things so if I go back to tiled for now we only care about knowing how I figured out the 936 so here it is 936 comes from the end as you click on the various other tiles you can see the various numbers that this is how you can know which frame is which okay now I'm not going to copy paste H I'm not going to write the code for this all the animations we're going to use by hand it's going to take too much time so I'm just going to copy and paste it here so here we have the idle down animation which is just one frame with the walk down the walk down animations so how do you specify animations with more than one frame in Kaboom JZ you use this uh an object you pass in an object with the from property which is the starting frame the two property which is the finishing frame and whatever or not you want to Loop this is not mandatory because by default looping is false but we want the animation to Loop always and we decide when to stop it and when you cancel it and then the speed is the frame rate so here eight frames per second for this so we have four frames in this animation so a speed of eight is what looked good so if I go back to title again you can see one two 3 and four this is how you know this is how I knew it was for animations uh for frames sorry and then here it's the same thing but with the various uh different directions so here for the side sideways we only need to have one of them I think we're using the the right one by default yep and we we're just going to flip it over when we need to make the character look left all right so now that that this is done I think we can just start uh drawing the map so I'm going to open tile again now here I really want to have the same thing but um yeah this is always a diff difficult part of the project where I just want to copy um the map layout instead of doing it manually but just to teach you so what what I'm going to do is I'm going to teach you how to make a water down like very simple version of this map and then you just take my map. Json file here and you use it uh so the the map Json file that I used in the project in the actual project is going to be in the description and this is just a u tutorial version that you can just swap out so this is this is just to teach you how to use til so once this is done I'm just going to use the actual real map. Json instead of writing the code as if anyway all right you get the point so just to teach you uh the way you draw things so let's have okay the way layers works so I'm just going to this is just a small crash course on titled how to draw maps and yeah so by default you have things called tile layers so tile layers are layers that contain tiles that you can draw there's another type of layer called the object layer which contains Collision boxes or spawn points which is basically needed to to know where to set where the collisions are Etc so let's let's say we have this first layer called Ground so you decide on the name and depending on the name the the result in Json file that you save is going to contain those those names so you can know which layer is which so here let's say I draw the ground like that so I drew a couple of tiles everything looks great now if you want you click on this button to add a new layer let's say I add another layer and I'm I'm just going to call it plants or uh props and then I can draw on top of it like that and that's basically it that's how you draw a map in kabo uh not kabo in tile now when you want to to add collisions what you do is you create an object layer call it for example boundaries and then here at the top you can have access to those shapes and then here for example a square let's say I want the player not to be able to escape outside the um the this little square so I can do here and then draw a grid like that here it's often better to have the snapping set to snap the grid if I do that it's going to be very easy to make perfect Pixel Perfect uh collisions uh yeah boundaries but now if I go back to here snapping and no snapping and I want to draw for example for this tree this specific shape and then this specific shape so you have more fine grain control and now this doesn't do anything on its own it's it's just for you to know that hey there's this layer called Boundaries and it's going to be an object layer and this is what and when you're using an object layer each object you create in that layer is going to have the XY coordinates and the width and its height so you can know what to draw what to where to draw the hit boxes when you're working in Kaboom or in JavaScript you don't you don't have to use Kaboom to use tile by the way now the other thing I want to uh talk about and it doesn't have to be a separate layer but let's say we create a separate layer and I'm going to call it spawn point uh not not spawn point what is this name anyway spawn point and then here you can use this pin and when you place it it's going to basically create a coordinate that you can use as a way to know where to spawn the player for example or NPCs or mobs Etc so this is how til works so once you you're ready with this you just save it now another thing I want to uh showcase is that this is not enough uh what we want so this is something specific to Kaboom so usually by default it's better to draw normally in a in JavaScript or in any like programming language it's better like it should be more efficient to draw the frames tile by tile instead of like having a an image that contains all the tiles but in Kaboom chz it's different in the sense that it is more performant and easier to maintain if you just go to your child editor and do export as an image so what this is going to do it's going to combine all of your tiles here as a single image so if I and only include visible layers so before doing any anything like that you need to make the spawn point and the object and the B boundaries layer invisible otherwise it's going to appear in your project and then you save and then you go to file export as image and then you export only include the the visible layer you don't touch any of that thing uh those things and then export now here if I go in my code edor you're going to notice you're going to understand so map you see all the image is baked as a single one so so here we go now this would be inefficient or less efficient in other um other libraries Etc but with Kaboom because it when you create new tiles you create new game objects it can be uh because game objects in kabon Jaz you create things called game objects which are are your usually your player your tiles anything and when you do that it is performant intensive because every game object has a few components those components do speci do some Stuff Etc so a way to get around that not have to do this or pay the the performance tax that comes with it there are many ways you can adopt the simplest one is just to bake your image uh to take your tiles and just combine them into a single PNG and just draw that as is now the tiled export is still useful because in tiled you're going to have this map. Json and then for layers that aren't tiles you get the object layer and the position of the hit boxes which is still valuable information you're going to need to draw the the headit boxes in your map otherwise the other option would be to use the on draw function in Kaboom JS to draw the tile specifically without having to create a new game object and but it's just more complicated for for it it's a better alternative but it's just more complicated and for this project I just opted with just taking a single image using a single image yeah okay I think I've teach uh I've taught you any uh everything important related to how to draw things in kab in tiled and Etc now what we're going to do is I'm going to swap the files here I have the map. Json map.png with the actual Maps so you can see actually one thing I realize now is never mind we you still need the Sprite sheet.png because it contains our character and the characters are character sprites are directly pulled uh from that image from Kaboom uh from that image are pulled the Sprite character so Kaboom still needs that but for the map for the all the other ties so you could theoretically remove everything else and just keep that and it would have been more efficient considering that when you're making a web game going you have to see how much uh data you're you're you're sending but those image are already very small anyway because it's pixel art okay so I'm going to swap my images uh my map and my Json file with the one I originally used and now if I go and look at the map. PNG you can see like the exact same map and if you look at the map. Json you can see the various tiles so let's take some time to explore how uh tiled what the map. Json what the tile export is contains so the things that are the thing that is very important is the layers property so til exports with a bunch of properties Mo most of which are useless uh for our purposes but the one that is useful is the layers property so if the layer is a tile layer it's going to contain the data property and it's an array containing the frame number that needs to be displayed zero is the absence of a frame for object layers though it's different they don't have the the data uh property what they have instead is the objects property which is an array containing every object that you've draw that you've drawn in this layer so the most important stuff is the X and Y coordinates and the width and the height of that object so this is useful for the boundaries all right so we have our map. Json everything is fine now let's load our um oh just one thing I want to to mention as well if you want to add to a boundary so this is often something you want to do you click here to uh to select an existing uh object when you are on the object layer this this little icon ignore this message for now and then you can modify the width and height Etc but you can also here in the properties tab add a name let's say I want this boundary to be to have a specific name let's say wall and when the player hits this H hits this we're going to know that hey it was a wall so you can use the name the data you pass here in Kaboom Jaz to know what the player is colliding with so now I'm just going to close this it's no longer necessary I'm just going to discard it and go back to my original so so here is a bunch of uh objects that I've named uh specifically like CS degree PC sofa table player TV exit Etc and for each of those we're going to have a different dialogue appear okay so let's go back to main and in main we're going to what going to do next is to import the actual map Sprite Which is a single PNG image now that we have baked it into a PNG instead of drawing every tile separately and then for the background the way you can set the background in cabun is using the set background function if you use this though you need to pass in a color and the way you can pass colors either via RGB or you can use the color class and the from heex method to specify a hexa decimal value the heximal value going to use for this project is 300 11 047 and now if I run the project so let's run it going to open up the terminal type in npm run Dev and then once you do that you can have click on Local Host and you should have your canvas so here we haven't done anything yet and things aren't looking great so we're going to have to change the the width uh of the div containing the canvas so that it takes the full screen so you know what let's do this um before actually writing the code Etc so let's go back to our index.html and in style tag going to add a couple of style styles so for the um for the app div so here take the ID and then we're going to specify a font a width of 100% so it takes the full width of the page a height of 100% as well 10% 100 %. and then overflow hidden so that scroll bars do not appear ever we don't want scroll bar to appear in this project how you look at the result you can see that the canvas takes the whole Space okay now let's go back to main.js and then create our first scene which is going to contain or all of a code for that specific scene I just want to make sure that um for this project because we don't have multiple different scenes it isn't needed to create a scene but I just want to show you how it's done in Kaboom JZ so to create a scene so to create a scene you use the k. scene function you give it a name I'm going to call it Main and then what comes after is a function which is going to be the code that is going to run for that scene so here is where you you draw um you write your logic for that scene but before do doing any of that you need to specify using the K.O function what is the default scene so by default the game starts it goes to to the entrypoint main.js it loads the various assets set the background color defines the scene and then go to that main scene now here this function we passed here is going to we're going to need to have it as an async function the reason for that is because we're going to need to get the map. Json data and for that we're going to use a fetch call so const map data is going to be a constant I'm going to name to basically get the the map. Json data we need in our JavaScript project so here I'm going to use await await fetch which is a default web browser API I'm going to to explain everything in an instant and then here. Json so here in one line first we await the fetch function because it is asynchronous that means that uh if you were to not use await then your code the rest of the code would continue to execute so let's say I have some logic here it would continue to run uh while fetch is still ongoing we don't want that we want to load the map data and not move not move the rest of the code here un until it's done that's why we await it so basically waiting it and then once we do that we also need to convert it into a Json uh object and for that we need to use the Json function which is also as synchronous Json method which is also asynchronous that's why we need also to await so that we don't move uh to the next line of code before it's done so once map data is done and ready we move on to the next things so here I'm just going to create another constant called layers and I'm going to extract from map data the layers property so if we look at the map. Json file you can see that the properties that one of them was layers and this is really what we care about that's why we only we create a constant just this is just for it to look cleaner you don't have to you didn't have to create a constant to get it but yeah and then here we're going to create our first game object which is going to be our map so in kabon Jaz a game object can be basically everything uh players props Etc uh what what is a game object exactly it's um it's an object that contains different components those components can be POS positions area a body or a specific Sprite and the way Kaboom works is that by passing in an array of components you specify behaviors for your your uh game objects so it's a basically an entity component system I think so how do you how do you create a game object there are many ways uh actually two the first one is the make function which allows you to create the game object but not display it on the screen the add function adds it to the scene so either you have a choice either you make it and then later on you have to call the k. add function and pass in the game object like that or you use the add function from the getgo and pass in your array of components here so for the map what components are we going to need we're going to need to uh this the Sprite component to display the the Sprite the actual map the way we do this is simply by using the Sprite component which is offered by Kaboom and passing it the key for the Sprite you want to display we specified the key in the load Sprite function for the Sprite uh for the image map.png that's why that's how Kaboom is able to know in advance where what to display actually now the next component we're going to add is the positional component and it specifies the position that the game object will have on the screen when it is displayed and here it is zero well it's not necessarily only when it is displayed just the position that you could have regardless if it's if it is displayed or not and then if you use the add function then it's going to to draw it in that spe in that specific place and then finally we're going to need the scale component and we want to scale up our map because it it's pixel art it's small and we want it to be a bigger so a good practice I'm going to do is in the constant. JS I'm going to create a constant exportable constant I'm going to call it scale factor and I'm going to set it to four so we want to increase it four times and then in main.js I'm just going to use that scale factor constant and call it so it should automatically import the scale factor constant in case it doesn't add this at the top of your file all right now the next game object we're going to create is the actual player and for that I'm going to create a constant I'm going to call it player I'm again going going to use the make function here and the Sprites we're going to pass is the Sprite sheet itself but with a default animation this is something you can do when you have imported a a Sprite that has many frames so a Sprite sheet you have access to this second pram where you can specify a default animation and here it's going to be idle down now the second so the second component we're going to need is the area component this creates a hitbox for our player automatically and within you can add so uh it's not very visible so I'm just going to format this myself and then explain so the k. area component allows you to create a hitbox automatically for your player for your game object but you can specify things within by passing in an object with the following properties you can specify which collisions you want this game object so the player game object to ignore and I want to actually this is not necessary we don't need that this because in the in the project I I did it a different way uh initially but then then I found a better way which doesn't require to really need that at all but what we do need is to specify a shape so by default it creates a shape that is roughly the shape of your Sprite but sometimes you want really to control the shape of your hitbox exactly and the way you do that is by passing in an object with a shape property and then use for example k. rect which is going to create a rectangle and then the first param is the position which is the vector two my Vector 2 is X and Y coordinates and you can specify here the vector 2 is going to be 03 so we want the hitbox to be drawn from the origin and then plus three on the xaxis from the origin of the player itself so the area is going to be slightly placed slightly differently than the Sprite itself so that um the head the hbox I is positioned properly and for example the the player doesn't look like they're sinking in a platform or something like that so this is something you have to play with yourself to determine which um which values are the best and now the second and third third params are the width and height of that uh hitbox I'm going to go with 101 it says on purpose smaller than the player Sprite Which should be 16 by 16 now k. body make sure uh is another component that actually makes our player a tangible physics object that is can be collided with and yeah that's basically it it's done automatically by kaboom now we can also use the anchor component to draw the player from the center instead of from the top left corner so this um the way things are drawn by default is that the X and Y coordinates are actually the coordinates of the T top left corner of the object you want to draw if you don't want that you want the X coord X and Y coordinates correspond to the origin you do uh you use the K do uh k. an anchor and then specify which so from the center now it's not the X and Y coordinates that are in the wrong position it's the the where the image is drawn from so that's something so for example uh yeah so the player instead of being drawn from the top left corner where the top left corner of that image will be the x and y coordinate of that player it's going to be the center drawn from the center so feel free to try and change the values or just try without and and then hit F the F1 key to open to the debug mode in KJS and then you can see the difference all right now we need a k position component uh we aren't going to specify a specific position now we're going to do this later when we're getting the data from our map we going to use this spawn point so here if I go back to tiled you can see I created a layer in the original called uh spawn points and it's just this little pin with the name player which determines where to spawn so if I click on it here you can see I've decided on this name I just wrote it here and then it's going to give us the X and Y coordinates so so we're going to know where to place the player all right uh another thing we need to do is to scale the Sprite for the player because for now it's going to be small it's going to be a 16 by 16 and we want it to be at least the same let scale the same as the map so that everything looks right and then finally well not finally but we have what comes next is in Kaboom JS if you want to hold properties for that game object you can pass in in your array of components a an object and then do put whatever properties you want and then they're going to be accessible directly by doing for example player. speed if I create this speed property here and I'm going to put it to 250 I'm also going to create a direction property is going to be useful to know which animation to play by default it is down and then is in dialogue uh property which is initially is false so what why we want this is that when the player is a is in dialogue that means that the text box is displaying text we don't we want to prevent the from being able to move or do anything except read the text and click on the close button all right uh the last thing we're going to add to that game object is the player uh tag so the way actually I'm not sure it's going to actually be useful for this project but I'm just going to add it for now it's when you want to check for collisions if you give a tag to your game object you can then use the on Collide function to know okay this collided with that a tag and that means to run this type of logic so it's a way to identify your game object all right so if I look at the result nothing yet of course because we haven't put anything now that we have the player Etc let's write the logic for actually displaying the boundaries and then as we write this we're going to write everything else we need okay so so here we need a for Loop which is going to iterate through the various layers we had here and then depending on the layer so if the layer do name equal equal boundaries so if we are on the boundaries layer how do I know this it's by looking at the map. Json export and then here you can have for each layer you have a name key the name key this is how you know which name a layer has if they have any all right so if I go back to main I have the layer name equal equal boundaries and then if I we going to need a for Loop which is going to iterate through all the boundaries of layer do objects remember that when you're dealing with an object layer which is the case for the boundaries they have access to the objects property which is an array containing all the objects in that layer and the objects in that layer are just objects with x y and width and height properties as well and now here we use the map object and then we add another game object to it so we can have child game objects by taking an existing game object and using the add function method on it so what I'm going to do here is I'm just going to copy and paste it it's going to be faster and then I'm going to talk over the code so we have an area component with a specific shaped shapes that corresponds to the width and height of the boundary itself this comes from tiled and from the tiled export in map. Json you see each object has a width and a height uh this uh maybe we created this needlessly because the width is zero and the okay never mind anyway so you have your objects from here and then I specify the spe specific shape we want which is a rectangle and you can do this by calling the wct making a new instance of the W class and then here you have as the first param the the coordinates of that hitbox relative to the game object we're creating we're just going to pass in an empty Vector that means we want the rectangle here to be at the same position as the overall game object so yeah the child game object because it's different then the there's the position of the game object itself and then there's the position of the the hitbox so the area for that game object and here by setting the vector two to being zero that means we have the ex exact same uh game object uh game position sorry and then finally we add the body tag this is important so that we can add the is static property what it does it it basically makes sure that the only way uh that means that the player will not be able to pass over it so it's going to be really stuck and that's uh yeah it's going to be U how do I say the player will not be able to overlap and this is how you do walls in kabon jazz and then finally we pass in the name of the object which was defined in in the tile export this uh gives us the tag it's going to act as the tag of the game object is how we're going to be able to identify what the game object is what the boundary is and this is going to come in handy later on because we're going to be able to know what to do when the player collides with it now that we have this right below if the boundary name of that specific uh boundary that we just created in kabj so this we're just taking the name out of the tile expert because we want to do something different so if uh we want to actually here set the on collision events so if the player we have the on Collide method on the player because we use the area component when creating the player we're going to do boundary. name so the first param of the uncollided method is the tag of the second game object you want to check collisions with we want to check the collisions of the player with this game object with the following tag which is boundary. name and then here we have a function that that is going to run as the second param when yeah so it's going to run when there is a when the Collision occurs and here we're going to set the player property is in dialogue to being false uh true actually so that we're going to later on be able to prevent the player from moving while the text box is being displayed and then here we're going to write a this is actually where we're going to write the dialogue display the dialogue sorry so is dialogue is here it's from here and then now if I go to so let's put it to do here to do and let's go to ut. JS and in there we're going to create a new function that is going to take care of displaying the dialogue so export function display dialogue and then the first par is going to be the text and on display and is going to be a method we're going to pass whoops a function sorry that that is going to run when the text is finished displayed so we need two things we need to get the dialogue UI which is basically the textbox container so I'm going to do document. getet element by ID and then text box text box box container all right once this is done uh let me look if I we have it actually the markup for it we don't so let's go first create the markup for it in h in HTML so here we're going to have first of all inside of the div the UI div we're going to have a P tag that P tag is going to have the class of note we're going to later on create the CSS for it and basically it's just an instruction to tap and click around to move now that we have that I'm going to create a div within and this is going to be our actual dialogue UI so I'm going to give it an ID of textbox container and then the Styles here we're going to actually this is not a really good practice to do if you are in uh making a website but I'm going to use the style tag here for a specific thing for the display setting the display to being none you could have just created an ID here um a selector here but I'm going to because I'm going to change this through JavaScript I'm going to use this but actually I think you could just use a I think class list or something like that to so I create a class and then I remove it but you know for for this project I'm just not going to bother with that okay so now I'm going to create another div from within this div is going to whoops so let me do this uh maybe I should increase the font size a bit more Yep so the div here is going to have the class of button actually text box it's going to actually be the text box itself and from within I'm going to have a P tag that is going to contain the text and I'm going to give it the ID of dialogue and then for the going to have a class for it as well which is going to be UI text and later on I'm going to fill those in right below we're going to have another div and then a button the div is going to have a class of button container this is so we can create a container where the button is always going to be on the right side of the screen I'm going to give an ID to this button to being the close button when the player wants to close the text the text box I'm going to give it the class of UI close button now let's write the dcss for it as well since we're here I'm going to load our font font so in kabj you can load the font if you want to display it via canvas but because we're displaying via HTML the text I'm just going to use the CSS for it so font family monogram that's the name of the font and then the source for the font is URL and then it's monogram. ttf and now it should be able to find it out here in the public folder okay now the body tag let's style the body tag as well this is just going to set the font family for all of the body tag to being to using monogram or as a fallback you're just going to use monospace so mono space is a font that should be already in your browser by default the font size by default is going to be two two REM so two REM one REM is basically the the size of the font uh of your browser said by default in at the root so usually it says 16 pixels and then you can decide you can zoom in and zoom out in your browser control so it takes the so here it takes the the the font size and multiplies by two so two times the font of your browser so that it will adapt it going it's going to be responsive by default and then here I'm going to do overflow hidden so here instead of having overflow hidden here I'm just going to put it in the body so that the scroll bars don't appear and then in however in the app selector all of this is going to have a position of relative this is so we can position it precisely with X left and by specifying the left and the top left and the right and bottom Etc so that we can it's going to how how do I say it it's going to leave the document flow and we're going to have much more Gran granular control of where to put it it's like if you would put an element on the canvas you really control the X and Y position of that uh element you put in the canvas so this is basically a way to achieve the same thing in Kaboom JS uh in CSS sorry now let's add for our wait a minute we have the text box I don't think this is I made a mistake this should be an ID and not a class and now below here we're going to have the class of text box uh the ID sorry of text box the selector for it and here by precise by uh specifying position absolute this is where you actually get the full control of where to put it by using the left property uh I'm going to put 10% the right at 10% as well so it's going to look good I'm going to put the bottom at two view height so it takes the view height and then it's it's a measure a measurement relative to the view height so it it's going to adapt regardless of the um of the the screen of the user the minimum height we're going to need is 10 view height this is what looked good this is for the text box you're going to see an instant when we'll see the result the background so this is the color of the text box let's put it white the okay so we have the background the Border radius I'm just going to put three pixels it doesn't matter the outline style is going to be black or solid is it the color solid the padding is going to be one ram as I explained Ram is based on the font size of your browser and it makes it responsive basically and then what do I need display Flex we're going to create cre a flex container now this is some CSS knowledge I would I assume that you have it you have this knowledge already if you don't read up on Flex containers there are plenty of great articles and posts online explaining everything so we're going to have display flex and then a flex direction of column so so the children of our Flex container are going to be positioned in the column we're going to set the flex wrap to being to wrapping so that when there's no space it moves on to the next row we're going to justify the content to being Flex start this is so that um the text within the uh the text box starts at the top left corner uh align items as well I'm going to do Flex start um I think I'm I always mess up the justify content and align items one if is for the the axis for which the the content is flowing and the other one is for the cross AIS so for both of those case we want it to do start at Flex start which means it's a top left top left and and uh yes so it's top left basically and then play with the those values as you you're going to see how they are affected then word spacing word spacing is going to be 0.2 remm this what looked good so word spacing is selfexplanatory so the the words appearing in the text box and then here we're going to have a little drop shadow so we're going to have a filter and then a drop shadow with the following arguments um REM and then a color RGB so this is really took straight from the mdn documentation with just a bit of tweaking in terms of colors yeah I don't really know maybe there's some explanations here yeah you have uh drop shadow here so here it is explained the where are the pams where are they um it does it explain okay okay it's in French by the way anyway you're going to figure it out uh by just looking at the docs mdn docs type in drop shadow CSS you going to understand all right now the UI text class going to have a margin of zero and then user select none this is important so that the player cannot select the text and have highlight it like that usually you don't do that in a game and then finally you have uh actually there's two there's a couple of selector to Define so UI close button I'm just just going to copy what what's left it's not much and I'm going to go over it so UI close button uses this font family uh for some reason you need to specify this otherwise it uses it doesn't use the font and I'm not sure why border style none border radius three pixels some padding and then it it should it should inherit the font size actually maybe you could do inher par it here as well and should work and then button container it's going to align itself at the end of the text box so that the the buttons always going to be appear appear at the top right corner and then the note is going to be again position absolute is going to be at the top left corner so left and then top one VH display Flex Flex Direction column Etc and then this is the color of the text it's going to be have that color yeah I save everything look at the result you can see that here you have tap click around to move here it doesn't matter if you can select or not but for the text box we don't want you to be able to select text actually you know what let's also put it as user select none just to make sure that it looks like a game and that's it uh if I now try to select I can not you see all right now we have this we can simply go back to our .js and write the rest of the logic we had here so we need the following so I'm just going to copy and paste that here so we get the text box container we get the dialogue so the dialogue is actually the P tag here where we actually put the dialogue in and then what what we're going to do is we're going to set the the display so initially remember in our markup I said I put style display none this is to make all of this Invisible by default when we want to show the dialogue we can use the style attribute here and set the display to being block and this is going to make the the textbox container visible so which by extension means that the dialogue box is going to appear and the text is going to be visible now we're going to implement text scrolling and this is very simple in HTML you this is the code for it so I created an index which I set to zero and then the current text is going to contain the text we're going to add to the element the the the inner HTML here of the dialogue box now inner HTML is not really recommended to use because you can be victim of cross site scripting so here in this our particular case it doesn't matter because we're not accepting user input input so it should be safe to not to use in our HTML and it's kind of required because when we want to have our dialogue box you're going to have sometimes the text that appears with links to your GitHub or things like that as attributes Stag and if we were to use inner text for for example then those uh attributes that we pass the the yeah the links are not going to be rendered as links and will not be clickable so here we use the set interval function in JavaScript this is something that is basic like vanilla JavaScript and every 5 Seconds uh it's going to run this the the function here we put a reference to that interval uh that set interval event so that we can cancel it clear the interval when we're done with it and then as long as the index is inferior to the text. length so text. length is the text that we pass here then we take our current text we append the specific character at that specific index of the text and then we put it all in the inner inner HTML and uh yep and then we do index Plus+ and then we skip this until this the condition is no longer true and then we clear and that's basically it now we need to write the logic to um have the onclose button so the when the button needs to be closed to do something like that I'm going to put this outside but still in the display dialogue function if I paste you have we get the close button by using a simple get element by ID and then I create this function called on close button click it's going to call the on display and function this is a useful because we in this function going to set the player uh is in dialogue attribute to being false without having to pass the player to this method this function so this a handy way of using an out passing a function from the outside that does has access to player the player object so that we don't have to add a third param here and it doesn't make sense really why would you need the player to display the dialogue so that makes a much more sense and it's much more extensible for example if you want to do other behaviors when the display is over and and then here the dialogue UI install display we put it back to none so that the dialogue section of the UI is going to be invisible we set the inner HTML back to being empty empty this you could have used inner text it doesn't matter and then we clear the interval if it's not yet the case and then we close we remove the event listener because we're going to add it so we remove the function itself within the function so it's recursive so here we have at the end we create the event listener when the when there is a click and then it runs this and then it removes itself as the event listener so so that's it now if we go back to main.js we can here in the todo section have player um not player call the display dialogue functions going to import it automatically actually it should automatically import it from the utils file and then here I'm going to pass the dialog data so here for now let's put test or todo that's our text that we're going to display and then here we're going to have a function and this function actually just its role is just to set the player is in dialogue to being false so that the player can move again and yeah so look at the code here and that's it so if I think I have it I Collapse this and then if however so we should probably put a continue at the end so here after all of this we continue that means we skip to the next situation ation of the for Loop and then here if the layer oops the layer. name is the spawn points well the spawn points layer which is where the the the player spawns we're just going to have four con entity of layer. objects there's just one entity but I'm writing the code to be generalizable so that if you decide to put more than one entity in the tille export it's going to still work and then so if entity. name is equal equal to the player so this is going to be the player so that's this is the name I'm going to put player. position because I added the positional component when created creating the player game object despite having set it up to nothing I can access the attribute position and set it manually after having created the game object and here I'm going to use a vector 2 which is just the x and y coordinate and the position we're going to use though it's going to be very specific it's going to be whoops not what I wanted to yeah so we're going to take the position of the x coordinate of the map you do this by accessing the pause property and then the x coordinate and then I'm going to add the entity dox which it tells us where to place the player and we multiply this by the scale factor because remember we we're basically multiplying everything by four so that everything is nicely visible and big enough same logic for the ycoordinate and then finally here we use the add function in Kaboom to add the player game object we created in the scene and then here you can continue or doesn't matter because we only have like two layers or anyway so now that we have all of this it's time to I'm going just going to collapse all this section we're done with it and then here I'm going to um I think that's uh let right just some code to make the camera follow the player so by default in cabun you have the camera object already created you can call the gam cam pause so the camer system already exists you can just control it so I'm going to take the player world position the reason we using World position instead um actually doesn't matter really because we haven't created the player as a child object so so if you're using if you're creating a game object as part of a child of another game object you use World position to convert the its position to being the position of the in the actual canvas and not relative to the parent so here I'm going to use player. pause. x and then player. doy plus an offset of 100 so this campuse is going to set the camera position to being this in the x coordinate and this in the ycoordinate now if I look at the result okay I have the character but uh the map is not appearing I'm wondering why actually why is the map not appearing is it doing everything right um wait a minute so if I go back to the top where we created the map we have okay I haven't added it to the to the canvas but you know what because we're doesn't matter let's use add instead to immediately add it to the the canvas and here we go the map is displayed if I press F1 you can see all the the collisions and for the specific objects you're going to have TV sofa table PC resume project exit Etc now the player cannot move so let's fix that and then uh also we're going to need to add some other stuff like uh setting the camera scale so depending on if the player is using a small screen or a big screen we want to make the the camera zoom a bit or not to compensate so here um so let's actually write the logic for moving the player so I'm going to use the k. on Mouse down so because this is a very simple project compared to other tutorials I made I'm not going to write those methods inside of the player let's just use the on and take the the player game object directly here and yep so when on Mouse down is an event in Kaboom JS it takes in a function and it will pass to it the mouse button that is currently being pressed on mobile it's just going to consider a tap basically and then here if the mouse button is not equal to the left M Mouse click or the player is in dialogue then we return early that means we do nothing we don't move and this makes sense because we don't want to allow the player to move when a right click is pressed instead of the a left click because if they press both at the same time they're going to move twice as fast it doesn't really matter because it's not a game we're building really but just so you know and here if the player is in dialogue of course we don't want to allow the player move to move while they are in dialogue we want them to focus on the dialogue okay now for movement we're going to need the following snippet of code so let me just okay so that's all there is to it when it comes to mov we need the world Mouse position that means because we're using the camera the mouse position is going to be really um according to the canvas and not according to the world the world can be much bigger than the canvas because the world is much more than what is visible by the camera and when you drag around this uh what happens is that if you use the k. Mouse pause the mouse position directly you're going to at some point get stuck I wrote a Blog Post article on my substack link is in the description so feel free to read read it to get a better understanding and by the way subscribe to my sub if you want uh for more like written content yep so the only thing we need now to move the player is to use the move to function that is available on the player because we have the I think the area component the body component I think because because of the body component so some certain methods in Kaboom JS are only accessible once you have added certain components when creating that game object so the first param is which what is the target position you want and we want the world Mouse position so we want the player to move towards this at the specific speed and here we just get the speed from the player which we defined here all right now if I look at the result we should be able to move and here we go and then you can see we Collide and then Todo there's nothing that appears and then Todo again Todo we haven't written the content but that's almost all there is to it you know the next step is really to code the direction various directions so make the player face different direction scaling the camera according to the the device being used the the resolution otherwise sometimes it's too big and becomes too big and actually putting the content inside of those text box and that should be it so now let's actually write the logic for scaling the camera and then we'll write the logic for the directions and then we'll add a text hopefully that order so here for the camera scaling I'm just going to in the .js we're going to create another function right below export function set cam scale and then here we just pass the context so we can know we can compute how much we need to scale so here I'm going to create a constant I'm going to call it resize factor and it's going to have access to the width of the canvas you can have access to the width of the canvas by calling the width method on the Kaboom context and the height um as well and then we have this division to get a factor and then if the resize factor is inferior to one that means we will simply set the cam scale cam scale this is a kaboom method to being just one uh you can also do two VC one which is just going to set it to one uh otherwise an lse statement you could either have an lse statement or if if you want to be fancy you can and more clear you can have an early return and then here right below you can have k. cam SC scale cam scale and then k. Vector 2 and we increase the scaling so we Zoom by 1.5 in both X and Y uh Transformations so 1.5 all right so now we have this I'm going to go back to main and and where we're going to call it is we're going to call this function first in in two occasions the first one at the beginning we just do set cam scale and then K and also every time we resize the cvas so you can know when this happens by using the on resize Kaboom uh method which takes in a function that that is going to run when this occurs and then you just can call the set cam scale and then pass in the context here so let's look at the result so here you can see everything is much better and then as you decrease the thing it's uh smaller I think or is it that's uh let's take an iPhone SE and then let's uh yeah it seems to relatively work maybe I'm not sure let's gradually yeah all right yeah so it's it does yeah it does change okay sounds good now what we need is to basically display the correct animations and Sprite depending on the direction so what I'm going to do to be able to know when the player should be facing left or right or any of those uh angles is to first store the mouse angle which is just going to be the angle between the player so you can do that by using the angle method of the position of the vector of the position of the player so player. pause. angle gives you this and then you can pass in the world Mouse position and it's going to be give you the angle between and with that I'm going to first specify a lower bound which is going to be 50 and a um upper bound which is going to be um 125 going to see in an instant why we need this and then we have our if statement so here I'm just going to copy and paste and talk over it so first condition if the mouse angle is superior to the lower bound and inferior to the upper bound and the current animation isn't walk up then we will play the walk up animation and set the player direction to be up if I look at the result it's when the mouse is here imagine that you had a circle and then here if your mouse is within a certain range actually for now you're not going to see the difference so let's say my mouse the angle here and here so you're on the circle as long as my my mouse is still within those position the up animation is still going going to play however if my mouse exceeds for example here we shouldn't now this is not very clear for now but let's add the conditions and then you'll see so now what comes next is the for the down animation so it's it's the same thing with negatives instead so now if I run and look at the result if my mouse is here and I click Mouse down the up animation is going to play if I my mouse is here the down animation is going to play now if I do whoops okay let's whoops okay let's say I'm I'm here so if I do this and then I change you see it dynamically change as long as I hold the mouse because now the the mouse position is within those upper and lower bounds of the this imaginary circle in terms of angle so now I'm just going to add the two other conditions this is for the left and right then here right below so for the right it's we take the absolute value of the mouse angle and as long as it's superior to the upper bound we flip the player X to being false this the flip X X is useful because we only have one animation for the walking it's called walk side and by default it faces to the right that means that if the player was flipped uh mainly because of the other animations where we do flip so for the left side then we put it back to false so that the the player looks at the correct direction and then here the same thing but with flip X being true instead and uh as long as the mouse angle is inferior to the lower B down the absolute value so we don't care about whether or not it's negative or positive Etc so this is so it works on both sides of the circle the imaginary Circle so now if I look at the result you see and you can have directional movement like that now you see that the animations of the the player never stops right uh the way to go about that is to use the uh on Mouse release method in Kaboom JZ I'm going to paste it right below so here let's a let me collapse everything here and yeah on Mouse release if the direction is down we put idle down if the direction is up we put idled up and if uh it's neither then we put the idle side and because we flipped we fli the player uh it's going to point towards the correct direction by default we don't need to do anything so if I look here I do this here you go then like that and then I hold I release sorry I release the mouse and then the player stops and uh basic that's basically it now the only thing is really the content here and what we're going to do here for that is I'm going to go back to where we I think it was here when instead of having to do we're going to hold the content of our dialogue inside of an a constant I'm going to just call a dialog data uh let me just look it up so I'm going to copy and paste it and just explain to you the the how how it works and then you don't have to use the same text so here you have a dialogue data object with keys that corresponds to the tag of the boundary so for the PC you have this text and then you can see me using the a tag here to have links Etc as if it were HTML and now here in main.js instead of doing this what you do is just you you get the dialog data constant from the constant file so it should import it automatically otherwise do it manually here here it is and then here you just pass in the boundary name to corre uh select the correct text to display and that's basically it the project is done if I go here and I go here if you want to exit J Legends portfolio just close the the tab and then here that's my TV I've been watching Tech YouTubers a lot recently the primagen Theo pirate software milky Etc and then here that's my sofa I like to relax and Etc and then you get the point so if I open up the um the uh debug mode you can see when there is the PC key here those are the name of the various boundaries and this is how we we use them them to as keys for our dialogue data so here for example this is my Dex my desk on it is my resume check it out and then it's a link with an a tag so here if I go here the a tag where is it uh constant you can see uh the link to my resume Etc so this is your free don't don't just copy what I wrote here write your own dialogues to tailor it to your uh your yourself basically and that's basically it thanks for watching this tutorial hope it was uh something that you you like to to learn about and uh yeah thanks for watching feel free to subscribe for more content related to game development uh specifically JavaScript or web related game development but hopefully not only maybe I'll try try to do other types of uh development uh or with other Stacks so maybe making games with Lua or some stuff like that in the future so yeah feel free to subscribe and share this video if you found found it useful all right thanks for watching bye