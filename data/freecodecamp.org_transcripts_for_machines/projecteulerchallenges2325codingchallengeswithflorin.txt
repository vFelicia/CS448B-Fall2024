hello hello and welcome another live stream in which we are going to continue our journey to solve project Euler challenges so far we solve 22 problems or challenges or however however you want to call them and if we're going to solve the well all of the 100 ones in the project order one have the challenge then we are almost a quarter away right hopefully today we are going to get problem 25 and solve it we'll see hello everyone say hi in the chat if your life and we can start with problem 23 let's see what this says non abundant abundant sums all right that's an interesting word a perfect number is a number for which the sum of its proper divisors is exactly equal to the number for example the sum of the proper divisors of 28 would be 1 2 4 7 and 14 added up which is 28 all right so that means 28 is a perfect number good a number n is called deficient if the sum of its proper divisors is less than n and it's called abundant if the sum exceeds all right so then the perfect is equals right then deficient is less and abundant is higher all right good as 12 is the smallest abundant number so for which the sum of its divisors is bigger than a number right we have 1 2 3 4 & 6 to be 16 the smallest number that can be written as the sum of 2 abundant numbers is 24 all right so 24 to abundant number that means 12 and 12 right okay by mathematical analysis it can be shown that all integers greater than 20 thousand 123 can be written as the sum of the two abundant numbers what can be written as sum of 12 on numbers alright so let's see again all integers greater than oh okay that's interesting however this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant number is less than this limit yeah so this is why I'm reading out everything this is pretty interesting and probably a little confusing all right let's see again so this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that can that cannot be expressed the sum of the abundant numbers is less than this limit all right let's see what we need to find the sum of all possible positive integers less or equal than n which were given here which cannot be written as the sum of two abundant numbers okay so they sounds complicated all right so we have to do a lot of calculations well let's let's see so we need to go over all the numbers from 1 to N right so let's write it down pretty confusing this one yeah a lot on to the right I actually take it took a look before in the stream just to see what we have to do and it got me confused there but let's see we already for those of you who joined for the first time this is what how we roll all right reading the text then we're solving it by solving small pieces the time right and then we unite those pieces and hopefully it works well we got so far so hopefully we'll get further we'll see all right so is 1 then I less than equal to n I plus plus right good so we have that which is a good start ok so let's see again find the sum of all positive integers which cannot be written as a sum of two abundant numbers all right so what we know that an abundant number has the sum of its divisors bigger than a number right all right now we kind of need to go over all the numbers let's think so find the sum of all positive integers which can be written as a sum so already when you say some there are two numbers right when it's at numbers and some of the numbers from 1 to n cannot be written as a sum of two abundant numbers but for that we need to see all bonded numbers right which could potentially be added to get that number does it make sense it kind of makes in my mind but yeah it's it's it's confusing a bit all right let's see we will need a function which will give us all the divisors right we did this a couple of times so let's let's do it again I guess let's put this here and let's see how we did it get divisors and we pass in a number and here let's see we go up to half of it right 1 2 4 7 14 yet so forth let I equals 1 I less than number divided by 2 I plus plus and we're going to create a div Visser's array all right and we're going to return this tvs are three like that and here we're going to do if number modulus I is zero then it means the peas are and we're going to push it here they feel sort push I all right so at least one thing it's done now we need to see if it is abundant so function let's see how we're going to do it we're going to give this function the number and the divisors we're going to add the visitors and we're going to compare it to the number right so he is abundant let's think so is abundant the number we can just pass in the number actually let's not pass the divisors and here we're going to get a divisor so Const the deserts will be get abusers of the number I said that let's say number let's be consistent here number alright oops I had all right sorry I had I had the wrong overlay my back that's the overlay from my own Street all right good but yeah give these life signal like anyway and feel free to support the precut cap if we go camp channel by becoming a member by donating I can I think you can do that yeah all right good close the parentheses there so what we did here we got the divisors and now let's see we need to have the sum so the sum will be divisors and let's use the good old reduce accumulator number emulator plus number and 0 so this goes over all the numbers in the divisors and as them all up in this accumulator and and returns it yet so now what we want to do is to see if sum is greater than number if it is then this number is abundant right get get get get get so we did that we're one step closer now let's see again find the sum of all positive integers which cannot be written as the sum of two abundant numbers okay now what I'm thinking you we somehow need to store all of these abundant numbers and let's see thinking okay so we need to go over the numbers from 1 to N this song so we're going to need two numbers from the abundant array which you don't have yet but we're going to create and if we cannot find a sum then we will store that number okay let's see but how about the Sun so these sums we could I'm thinking in order to store the abundant numbers we could use an array we could use an object which is a set I'm thinking I'm going to use an array so let's see abundant numbers will be an empty array and we're going to go over all of these numbers and we're going to check if it's an abundant number although I'm not sure if we should go over all of them but let's see hello our pan welcome how are you today okay if is abundant we have this function right he's abundant he's abundant I then we wanted to abundant I guess and that's a long name but hello push pie and let's return this abundant numbers let's see what we get I want to console the clock yes all right abundant number 36 why we don't have 12 so that's an itch already hmm okay don't like this is it because there are a lot of numbers here No so something something is wrong let's see what's the output of calling console that log is abundant tough we know that that should be right because it says here and well it's logical for it to be let's see it's false okay so that's not good let's see the divisors DB source one two three six KIC we went from one up to number divided by two but we need two equals here all right good so now that will work properly good we don't need this anymore all right look at that so now these are all the bundle numbers which is interesting to say the least we don't have any bundle number above 1,400 that's weird let's see okay it's somehow weird right but I guess all right so we have all these abundant numbers now as I said that none don't know exactly if we should go over all the numbers here and to create a banner numbers from them but now what I want to do is to create an interesting loop this is not the most optimal way to do it but hopefully it will work said every programmer ever we want to go over these numbers and then go through the bundle numbers array and check all them to see well add them up let's see so we want to add them up to see if we have that number or we could do something else I just had an idea we know that we need to find the sum of two abundant numbers right and we have an array of those about numbers so what if instead of going over all the numbers and checking of the array again to find the sum what if we create the array of the sum of the Bunin numbers does that make sense so let's here let me write this down maybe that would make sense then add up lengths so we go over all of these twice this will be still less than doing this basically every time we go over the numbers from here okay and we basically want to add them up in another array so we have bundle numbers come some of bundled yeah it's a weird okay let's see Let X be abundant numbers of I and left Y the abundant numbers so we get two numbers from this abundant array and we add them up so sum of abundant that push X plus y so we basically now have all the subs right and the last thing to do is to go over this array those are these numbers from 1 to N and check if we have if we don't have the Sun because we have to find the sum of all positive integers which cannot be written as a sum of two abandon numbers all right I feel like we're getting closer but let's see one thing I feel we'll have in this is that we'll have a lot of duplicate numbers which is I guess fine not a number here that's not good and it broke the browser here let me not counsel this for now let's optimize this pit so comes some I guess we could just cross here it'll be X plus y if some let's see some of abundant includes so if it includes already don't want that it so if it's not included we want to push it so basically now we're sure that we won't have the number twice right band and why do they have to be so weird my mates okay is this a way we can speed this up a bit so we're getting all the bundle numbers and then we adding them up King what if when we get an abundant number we add we added up with all the numbers already here we away so we don't do this again but let's go with it for now let's hope that this won't break maybe we can test with smaller numbers like thousand all right and now hopefully we don't have duplicate numbers we still have not a number which is weird why is that we should only have numbers okay so we get number from there we do the sum number is not a number some I want to console that vlog X Y and some I want to see where is that not a number sorry one dad well I want to run that list okay twelve undefined eighteen undefined what's the index zero 246 okay so act why is undefined this is weird why is that why we have undefined index two four six the last one yeah 246 is the last one but why we cut that if it's abundant we push and we push and find oh that's why we go up to the inclusive alright good good gets it we find the bug and we squished it yet so now that's done we shouldn't see not the number now which is good we're one step closer all right get so these are basically all the sums a lot of time what we want now we're getting closer let's see so what we won now find the sum of all positive integers less than n which cannot be written as the sum of two abundant numbers so we go over the numbers right from 1 to N and if that number is not in this array then we want to add them up to a song right I think that's let's see let's sum 0 well actually let me put it here for let I again 1 I less than we're going to optimize this a bit eventually I less than equal to n so over all of the numbers I plus plus and here if we don't have it in the sum of abundant so pretty much anything like this here it doesn't think it's not included then we want some plus equals I and we want returned it son right so something's not Oh all right we're getting a number that's not the number we want the tests maybe there yeah time out alright alright a lot of loops here which is not good we need to optimize this and the idea from the chat okay so you today today to do could this oops look at this here that's one improvement I think so if we had abundant numbers and then we do this okay let's see let's ban don't be and find and if this is abundant then abandoned well bi and let's see why did they do this I want I still want to push it but if we have abundant over the abundant numbers so let's abandon numbers push band and I guess I can do this here okay now I want to go over abundant numbers numbers for each number and I want to do the sum here sum of abundant that push naam plus abundant right so we kind of create some here pretty much what we do here right X will be the abundant number and Y will be the bundle all the bundle numbers from the sum we already sorry abundant numbers here oh yeah that's good this abundant numbers alright so now we should not need this but then again this could be done here so we push the number I guess we don't dis then we can use I so we push the I and when we push it we go over all of them and we add them up inside to create a sum of abundance and we can do also this to check if we don't have it already do we need to do that this will kind of go over all the numbers worse adding more number at having duplicate numbers or going over the array to check all of the numbers and don't push it otherwise I guess this will slow it down a bit and then we're already going here over let's see how this improves it the bundle is not defined okay number sorry all right we don't get a good number now but let's see if it still times out if it is then oh yeah then we're still not good at doing a very good job staking a lot where can we improve you like key and ideas in the chat don't leave me maybe someone last time I did a extreme summer reached out to me and Facebook to tell me you did run there so you can do that alright this card I'm thinking how can we improve this you like we could save some time this up there because basically were but we don't have all the sums how many numbers do we have here ban hamma ban on the length Oh that many numbers what if we do this will that help I've come some num plus I and then we do this whoa that helps a bit that helps a bit Oh from 1689 Sam's and thousand that's a bit all right so then let's leave this there the idea should be the same how the number changes infinite loop online eight oh well I don't like this here yeah let's see still times out no not good we have a loop here we have another loop here yes here's the thing we can simplify here we get the divisors and here we add them up why not have the sum of the desserts well I guess let's move this and here we're going to create a sum we save some loops it's all about performance now sum is zero and if it's divisible than sum plus equals I so then we don't need this and we don't need this and we don't need this right so we just check if it is at his or right here and thinking how could we check our performances still turned out perfect so okay there are a lot of numbers that's why Oh oops oops we need to return some here but I guess it's still time doubt but still at least we don't have the link there else you one thing I noticed and maybe we can use is that you saw how many abundant numbers we had which were under well less than 10,000 abundant numbers that flank 339 numbers and when we go to to 20,000 1041 that's not good maybe the wicked competitor is messing with us again or is it maybe not should yeah Candace back here it's weird that always in the stream the first one is the hardest all right you can see how this name number changes so it's probably not you know what let's get this code and let's run it in vs code which should be about faster and well at least we can see what we get right so let me open this NBS code well it won't be timed out the worst will break the Mac but we've been there scripted yes if it breaks just be patient I'll be back it happened once so hopefully it won't happen again all right and now let's go with small number just to see how well it works node script the GS alright okay so that's good that's the lacked at least let me do something note man scrape Jas Q so this will run always whenever we save alright now let me put this to the right oh it's fine what about ten thousand yep so this takes a while you you each sad do we have some mistakes somewhere this is why it's not faster who knows just trying to see what's happening here yeah that's definitely not fast okay I don't know how we can improve this so getting to be abundant we need to get all the desires and to well check if the sum is greater so yeah look at how much it took to do all that it was something to test let's see console that time you you you the name of the timer I just want to see how well fast it is get so time and time and so on so that time Hey well started and we're going to run it again your console that time end let's put bigger camp okay and let's run it with last numbers okay call milliseconds that's good let's see 3000 what that's faster yes something's wrong with that alright that's about 10,000 oh whoops whoops here is where I want to have it after it calls the function right my bad all right 2934 3741 33 good but about 3000 now all right now this is more likely okay you can see that 600 ish if we have 5000 will it be let's see so for a thousand was 33 so should yeah that felt right that times the amount so this is five seconds three seconds and for ten thousand well it will be yeah it shouldn't be double or triple because we have more numbers and it needs to calculate between more numbers all right in the meantime let's see let's do small adjustments and see if we can sort of improve it stepbystep and eventually have it well be submitted or at least oh we could at least see if we have the correct number right what is it so for ten thousand we need this number oh yeah but we're not doing the sum here so let's this son three seconds oh yeah yes let's see we're going over the numbers we check if it's abundant if it is we push it to this array and then we go over the array and we get the sums right because we need to see if that number is in between some you know when you start to go on a path you kind of don't see other paths though maybe this is where I'm stuck now three seven three one zero zero four three seven three one zero four so at least we know we have the correct answer but now we just need to speed it up all right yeah at least we have the characters they should work but the time out can we use this statement which I don't understand however this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two banner numbers is less than this limit okay so the greatest number that cannot be expressed is less and not sure if that tells us to create this number that cannot be expressed is less yeah okay doesn't help I think does it Lauren where are you you're my you're the Joey to my Chancellor or the otherwise all right yes so it takes 33 seconds which is a lot a lot of numbers what else do we know one loop another look yeah another loop wellwellwell they speed up let's let's try it with 3000 let's run it a couple of times and see how much we get right around 600 let's write it down for three thousand is round six I know sixty six ninety six thirty yeah all right around that what if we don't day so we just push okay look at that so you can see that it's faster is the same thing with more numbers you this is if way check for 3,000 is round and read if we don't check all right maybe using a catch like a dick to store the numbers he's a thief abundant like in bull if the numbers in the cache you don't need to check for TV source wait a second for deserves but we we don't so we just get the number you we get the numbers diffusers well I kind of have one idea we could spit up things although I'm not sure how much what would work we kid a check here if sum is greater but I'm not sure how that will work because if we go up to half of it how many divisors could have 12 has the most and only the last one yeah that won't help alright let's continue this this pad so for five thousand we have let's run two more times 1.6 1.5 1.9 all right that's not good yeah I guess if we don't check and if we check just died trying to find little things to speed it up well look at that difference so if we check well it's a lot more because is that function is abundant got called every time but don't ya I know we kind of check all the numbers if they are abundant which we shouldn't really because we all need to get the sums all right so we know they've done in only laughs we don't need to check it's faster that way so 10,000 should be faster now last time it was 30 so minutes sorry seconds where it was we had the correct answer somewhere here yeah 33 seconds yeah these are just small clicks I'm not sure 20 seconds so that's all but so ah good don't like this always goes and it checks I don't want to do that how fast will it be whoa whoa no dad's fast basically we go over disarray 10,000 times this is where they right now how can we check it's not included all right I have another idea we can use an object so some of well I guess somewhat abundant old be an object and some of abundant of some will just be set through or whatever so now we have an object where the property is the number and the values true so we don't do this we don't do this and so let me show you what's the sum abundant now how it looks like the last numbers obviously look at that see so we basically have all the numbers here this is probably faster way so now instead of doing this we just need to check if some of abundant of I write if it's true well if it's not true then we add it up to the Sun does it make sense so we get the sum there in the sum of abundance and it will be set it through and now if this number is not there then it means that it cannot be written as a sum of two abundant so then we added up to what the final saw a lot of sums a lot of things that's it well look at how fast that is now okay this should this should be now the way although one thing we could do here is be false and that remove this so if it is in disarray then it falls it's not well it can be written as a sum and we don't want to add it up for the final countdown all right let's see how fast is now for ten thousand look at that it's fast but it's not right why it's zero if some abundant of I oh I guess it's undefined it sounded fine then we added alright look at that whoo this was hard let's copy this over and still taking a lot but finally way did it oh boy let's say this was hot how long it took Inc it to the web you can't see a timer here anymore but how long have been extreme Oh for almost an hour whoa yeah so that was the issue we were going over a raise to check if it's inside and that's pretty slow so just checking the object I guess a set could do but I don't know exactly after you set that well so we're doing the object trick Thank You Larry all right let me remove this and this and yeah okay I guess this could be set to pretty much anything if it's not in there so it's undefined then you want to to be done all right Sammy tango good [Laughter] no permutations ouch this is hard oh but well at least we're closer to at least doing 25 problems Lex lexicographic permutation x' a permutation is an ordered arrangement of objects for example 3 1 2 4 is one possible permutation of the digits 1 2 3 4 if all of the permutations are list numerically or alphabetically we call it lexographic order the last lexographic permutations of 1 2 & 1 0 & 2 are wellpleased what is the end lexicographic permutation of the digits this okay [Laughter] we're busted I don't know I remember always googling how to do permutations okay and also need to have them in order and look at how many numbers there Emilia okay pretty fun these challenges are getting harder harder it's a classical interview question for Google I believe yep probably so I guess I won't be hired by Google then you how we're going to do this 0 1 2 0 2 1 1 0 2 1 0 two zero one two one zero all right this is four three zero one two three zero zero one three two zero what's the next what's the next 3 2 1 0 2 3 1 0 3 2 0 3 1 2 0 3 2 1 and then all of these again wait 1 in front looks like a recursive function to me yeah I know it is recursive function the table let's think I don't know how we did it so you when do we know when to swap you if we would have all the permutations then while it will be easy right we just get the end here this take another hour and not the best recursive functions hah and trying to remember how we did should we just look for how to do it and for some reason failed it's cheating with the permutations and they also have to be in order you you take your time this is fun yeah fun watching probably I bet it's fun for you curse now how can we move this to the right and then a kiss first what's the logic here zero zero zero zero zero zero 1 1 1 1 1 1 2 2 2 2 2 zero so we prepped here we have two six six numbers times 4 right 24 permutations here we have so this is 24 here we have 6 what's the Matt here I think one times two times three one times two times three times now there is a ho doesn't matter how many they are we need to find the end one look at this we have here zeroes one's and then his twos look at how we have here to add them well the millionth almost the millionth number is to here so we probably have million permutations for the one element is that element like a returns a with two characters you can serve the second char before and after the a so you have two permutations okay but what's next let's let's read about let's see what we could use loosely speaking an arrangement of its numbers okay we know what it is how can we find it you you okay you you in random we could random them up until we have them out that'll be fun you generational in a lexical order oh okay this is text we can read it maybe we'll get an idea this is not cheating right there are many ways to systematically generate our permutation of a given sentence segments let me zoom in here one classic simple and flexible algorithm is based upon finding the next permutation in lexicographic order if it exists it can handle repeated values for which case it generates each distinct multiset prepetition ones even for ordinary permutations it is significantly more efficient than generating values for the Lamar code in EXO graphic order possibly using the factorial number system and converting those to permutations it begins by sorting the sequence in weekly increasing order which gives it's like lexicographical in minimal permutation and then repeats advancing to the next permutation as long as one is found the method goes back to narayana pandita sorry if I mispronounced your name 14th century India and has been rediscovered frequently let's see the following algorithm generates the next permutation vector graphically after given after a given permutation it changes the given permutation in place look into the factorial number system well so we're learning here it's not cheating we're learning you can use this okay find the largest index K such that a of K is less than a of K plus 1 if no such index exists the fermentation is the last fermentation okay you lost in the first but okay it's a crap oh I think I know find the largest index L greater than K such that a of K less than eval swap the values of a of k with that of a of L reverse the sequence from a k plus 1 up to and including the final amount a of n okay let's see we have an example for example given the sequence which is an increasing order and given that the index is 0 based the steps ours are false index K of 2 the K equals 2 because 3 is placed that an index that certifies the condition of being the largest index that is still less than a k plus 1 which is 4 all right index L equals 3 because 4 is the only value the sequence is the greater than 3 in order to satisfy the condition the values of a 3 & 8 a 2 & a 3 are swapped to form a new sequence the sequence after K index to the final element is reversed oh the sequence after K minus index a to editor's NYK index all right so the final event is reversed because only one value lies after they index the three the sequence remain unchanged in this distance that's the leg lexographic successor of the initial state is permitted following this algorithm the next liquid graphic the permutation will be 1 3 2 4 why [Laughter] and largest index case such that largest in this case is that half K less than so what's now here index k death no such that a of K is less than afk No [Laughter] okay at which point a of K less than 8 K plus 1 does not exist you you find the largest okay I think I see it which is hard to follow yeah so we find the largest K which is three here because well we can go we need to have a k plus one which will be 4 yet when we found that we also need an of L which will be well this needs to be greater so it will be for this case and we swap them right ok now we have this here we find 2 to be well largest for and then L will be three again the largest integer greater than cases that yeah and we swapped them but that's not true right in the sequence after K minus index reverse the sequence from a k plus 1 up to and including the final program element oh I think I say this one so as I said this all these properties and then we'll reverse them 4 2 3 4 2 3 1 No I still it is hot let's see why I said to look into factorial number system a lot of pretty stuff here permutations no idea well we kind of have the algorithm we just need to implement it largest case there's a day of cases in a K plus1 no such indexes is the permutation is the last rotation find the largest index L greater than K such that a of K less than 800 so we go from the right we go from the hole I'm thinking the largest queso I still don't and fully understand how we went from this to this if we can find out them I think we're done if that's a big if okay find the largest index L greater than K such that is it on the right okay yeah I find the largest index al greater than K such that Oh so yeah I was right there we swap these two the sequence from a K plus1 which is the so up the valleys then if we swap them it will count this will be the one which was swapped or it's the one which will be up to and including the final element so for some reason okay let's let's write it down so we have one two three four we go here we find the largest which is well secondtolast likely like well and this one and we go one two four three now will be this K will be this what we're doing with our by the way yeah we're swapping them good now that's the first thing next we get this this is K this is K plus 1 and this is K well and we welp them so it will be one for two three but then it does this reverse the sequence from a k plus 1 up to and including the final element so I think this one now one when we inverse them three to four right let's find let's see if we managed to find the correct next element then your goal uhh test the largest case is a take a less than a k plus one so what's the largest three now all this is not the don't doesn't go there so three now and then the largest L greater than K such that a k less a of K is less than a of L for we swapped them on four to three and then we reverse from K plus 1 these reverse thing is not familiar to me although I but looking at it it should be 1 3 4 right we get to death probably this is our ending the project Euler charge they're just well more likely to be even harder than harder you can we find something else okay let's read more maybe maybe maybe I don't understand that right for some reason although I have everything they're not sure if you do if you do and then let me know if you do let's see permutations in lexo graphical order yeah I feel like you all right let's look at this this eye feels a bit better so so the given string and nondecreasing order and printed the first fermentation is always a string sorted in non decreasing order start generating next higher permutation do it until next higher permutation is not possible if we reach a permutation where all craft is assorted in non increasing order then that permutation is the last get steps to generate the next higher permutation take the previously printed permutation and find the rightmost character in it which is smaller than its next character let us call this character is the first character so something similar write that K we had where are you okay so find the largest cases that yeah so it's second to second to largest okay now find the ceiling of the first character ceiling is the smallest character on the right the smallest largest index greater than K okay so then I don't see them being the same here now find the ceiling of the first character ceiling is the smallest character on the right of first character have changed so a lot of missing the factorial number system if you have one two three the total permutations are n factorial which is six so if you see the permutations of two and three are and after being too you will have a change on the left most digit after two permutations Oh I think I see we're going two three one two two equals change one change to one three yeah kind of see where you're going but still I don't know how to apply it let's see again here find the ceiling of the first connector seeing is the smallest character of on right of first character which is greater than first director let us call the co character the second character swap the two characters found in a buff step sort the substring in um this creasing border after the original index of first character sort let us consider the string ABCDEF let previously printed permutation of the DC EF e ba the next permutation is sorted out order should be d e ABC f let us understand above steps voila the first character will be C C path ok the second character will be e why isn't it smallest character on right of first character which is a greater where is e on the right here it's f on the right okay after swapping this we got d e f CBA you what you does anyone understand what they're doing here first character is C the second character is E for swapping the two we got so swapping this with this isn't it DC a BEF the final step is so disappearing after the character ya know get it alright let's go back to what he said so you know the leftmost character going from zero to one in the sequence change it after counting nine nine factorial of nine is it factorial or just exclamation mark yeah I see here the implementation but I won't look okay a lot things here you one second so I know the leftmost character going from zero to one in the sequence change it after counting nine factorial by Alex and what did I do in the mean in those well meantime I don't know okay introduction previously permutation oh this is while coding I don't want to get cut just copy paste code I want to understand the logic behind it I don't boiler problem 24 this is what we have to do so yeah no no no okay recorder man you hmm so 0 1 2 3 will change to 1 after 3 factorial which are 6 characters so then 2 will change after 1 factorial will change after zero one two three after three factorial right which is 6 this will change after 2 factory which is 2 this will change after well this will change these two were always changing right so 0 1 3 2 and then 2 factorial now these changes and changes with the last one right right 0 2 these changes with this one say this is what I don't get changing but to what they should be here let me look at the next one maybe we take a break from this one 1000 digits Fibonacci number what's the index of the first term in the Fibonacci sequence to contain n digit you yeah I guess this will be easier let's do this and I'm going to learn more about fermentations and we're going to do it next week okay just addresses them get it now so Fibonacci is well for those of you don't know we get to start with one and one and then the next number will be that previous two numbers added up so 1 + 1 2 + 1 3 3 + 2 5 and so on and so forth sorry Laurent I missed ya let's let's do this one seems easier Fibonacci the 12th or f12 is the first time to contain three digits what's the index of the first term in the Fibonacci sequence to contain n digits alright so we need to add the Fibonacci numbers up and we need to get the digits and when we get the first number to be twodigit we just yell it out oh we all doubt the index yeah it's a tough one although if you know permutations then shouldn't be the tough but alright okay so let's see what functions do we need I need the function to calculate digits and we get the number let's call it an and we return and plus we convert it to a string all right guess we could say to string that lect all right and here we start with let's see let a be one let B be one and let index be to and while while to don't do this while too let temp or well I guess you can stamp B a a B sorry not sorry okay so we store be yeah a okay I'm losing it now B equals B plus a and a equals B right so the next one will be the previous two and a equals temp not be this is why we store it alright and index plus plus if get digits get digits count if get digits count of B equals and then we return index all right how how can be this so easy and then the previous one so hard how I don't understand I really don't understand okay as I said if you know permutations then well it's not part but yeah I know I don't like having all this all than this one not be solved nine factorial is 360 2880 so and item in the sequence will have the digits zero at the beginning because did not change for at many numbers and trying to see what Lauren is saying here I understand what you mean but how can I use that because I don't see that okay you kstew because three is placed the next certified condition of being the largest index that is less than a Custer which is four okay now history because the sequence is created entry in order to satisfy the condition a K less than a how the values of a to a of two and a half there swap from the from this week sequence sequence after k I don't see this K index K of index to the final element is reversed because only one value lies after this index the three the sequence remain unchanged in this instance that's the lexographic successor of the assist LT is permeated sequence from a K plus1 including the final element so basically tastes fun you you you order of all permutations of n equals length of N equals 4 generated by different algorithms the permutations are color code color coded where one is red with yellow trees green four is blue you yeah you you all right I don't know what to do we should we continue this next some reason so yeah we also need to implement it so we need to go over the Ray if we have an array right and we need to find this condition then find the largest index L greater than K such that then we need to find this condition yeah all right I'm going to stop here I'm going to read more about it and then we're going to it next week I'm sorry about that but I just don't get it now oh well what else we have here this looks also funny yeah numbers all right thank you for watching sorry I couldn't finish that one maybe you could which is perfect let me know you can DM me well you can email me or you can join the discord and we can talk there but they couldn't figure out now but I will somehow someday thank you for watching I wish you have a great day and I'll see you next time bye