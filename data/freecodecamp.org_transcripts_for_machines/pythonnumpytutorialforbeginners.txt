how's it going everyone and welcome back to another video today we're going to be going through the numpy library which is considered to be kind of the fundamental package for all scientific computing in python so it's a super super important library uh it's kind of the base for a lot of the other like major data science libraries in python so like pandas that i've done a video on before it builds pretty much like entirely off of the numpy library so it's super important and kind of because it's important it's because it's this like base uh the way we're gonna do this video is i'm gonna start off with kind of a background information on how numpy works and i think really having that intuition is helpful for when you actually start writing code with it so we'll do the background information and then after that we'll jump into all sorts of useful methods and ways you can utilize this library as far as actual code goes as always make sure to smash that subscribe button throw this video a thumbs up uh follow my tweeters tweetergram instagram twitter github too hit the bell for the notifications throw this another thumbs up yeah to begin numpy is a multidimensional array library so what that means is you can use numpy to store all sorts of data in onedimensional arrays twodimensional arrays threedimensional race fourdimensional rays etc and so the common question you kind of ask or i'm commonly asked when you know you first bring up numpy is why do you use numpy over lists so the main difference comes from the speed so lists they are very slow meanwhile numpy is very fast and so why are lists slow and numpy fast well one reason is because numpy uses fixed types so what that means is imagine we have this three by four matrix three rows four columns and it's all integer values and we're going to kind of look at how those integer values differ between numpy and lists so let's just zoom in on that 5 that's there in that matrix so our computers they don't c5 they see binary that represents five and so this is the number five in binary and it's eight bits which makes up a byte so our computers read uh information in bytes so when we use numpy this this one bit five is actually by default going to be casted to this int 32 type which consists of four bytes uh and so it represents five in a total memory space of four bytes so in 32 and you also you can even specify so by default it's in 32 but you could even specify that you didn't need all four bytes to represent this value so you could specify within numpy that you wanted maybe an n16 which is 16 bits or two bytes or even if you had really small values into eight which is just a single byte on the other hand with lists there's a lot more information you need to store as an integer so in lists lists use a builtin int type for python and so that builtin in type consists of four different things it consists of the object value which you know has its own bits associated with it object type the reference count how many times that that integer has been specifically like pointed at and the size of that integer value and so if we break this up into the actual binary that it represents we can take the object value and that's represented as a long which is like 8 bytes the object type same deal reference count same deal and then the size i believe is a little bit smaller i think it's only 4 bytes but as you can see that's a single integer within lists using the builtin int type it requires a lot more space than numpy so basically the takeaway from this is that because numpy uses less bytes of memory the computer can read less bites of memory quicker obviously so it's faster in that regard another reason that i didn't specifically say is that when we're iterating through each item in a numpy array we don't have to do type checking each time so in python builtin lists you could have a list of like an integer then a float then a string then a boolean and you'd have to check each element you're looking at what type it is but numpy we don't have to do that so another reason it's faster is that there's no type checking when integrating through objects moving on another reason that numpy is faster than list is because numpy utilizes contiguous memory so what that means is imagine that this kind of arraylike structure is our computer's memory so we could store information in any one of these memory blocks so if we had a list the way that that would look in a list's memory is that our list would be kind of scattered around so maybe we have a list that takes up eight memory blocks the thing is that these memory blocks aren't necessarily next to each other so you have some information here you have some information here you have a good amount of information in here then you skip a block here here and skip two blocks you have some information here so it's all kind of scattered around so kind of if you have an eight item array what that looks like is that that array is actually just or that list is just um containing pointers to the actual information that's scattered around our computer's memory and so it's just that all the information is not right next to each other kind of you have to bounce around your computer's memory a bit and it's not super super fast to like rapidly go through and kind of potentially perform functions on all items at a time or subsets of the items a numpy array however uses contiguous memory so all eight blocks in this case would be right next to each other and this has all sorts of advantages um and also just to mention real quick you'd also kind of have to have to store somehow where the start of that memory is and then like the total size and the type of memory block but it's a lot easier than this kind of pointer structure that's up here and so the benefits of numpy using this contiguous memory are a couple of different things so the first benefit is that our cpus our our computers have these cindy vector processing units and so when this memory is all like right next to each other we can utilize this unit and basically what cimd stands for is single instruction multiple data so we can like if we have to do an addition of like a lot of values instead of just doing one addition at a time we can use this cmd vector unit and basically perform computations on all these values at one time so it's quicker in that regard another reason it's quicker is that we more effectively utilize our cache so our kind of our quicker memory in our computer basically if we load in all these values we can keep them close to where we need to access them and like perform all sorts of operations while as in the list case you'd maybe load in like half of this but then this other half because it's scattered around in different places you'd have to like go back and like reload that in uh to your cache like you know just be overall slower because you'd have to do more like longer memory lookups within your computer okay so we kind of went over some of the performance benefits but how are lists different from numpy well lists we can do insertion deletion appending concatenation etc and we can also do those same exact things in numpy i guess the big difference though is that within numpy we can do all that and we can do lots and lots more and we'll see the lot slots more throughout the video but as a simple example imagine we have these two arrays one thing that we can do that's really nice in numpy is that if we try to multiply these one item at a time we could do that in in lists you couldn't multiply one and one three and two uh five and three um etc but when we do the exact same computation within numpy it allows us to do these you know single value like itemwise computations which is pretty neat and pretty useful so that's one example and you'll see a lot more throughout the video uh so applications are known by there's all sorts of applications i think the first one the kind of the first one that comes to my mind is that is a kind of a matlab replacement you can do all sorts of mathematics with numpy i think i should say that i think the scipy library has even more mathematics like functions and whatnot so if numpy isn't cutting it for you try to look through the scipy documentation you might be able to find even more but yeah it's pretty powerful the math that numpy can do it's useful in plotting it is the back end of many different applications so pandas which i've done a video on before it is just like the core component of pandas library it really allows pandas to work um if you've seen my connect 4 how to program that video i use numpy to store the board and then in future videos i'm going to do you can you can actually store images uh through numpy so like png images you can use numpy to store all the information and like do all sorts of cool stuff that i'll uh post future videos on uh let's see also another i think useful reason to know numpy is that it's kind of like pretty important for machine learning applications both directly and then also kind of indirectly because one of the key libraries or key kind of concepts you learn with machine learning is the idea of like tensors and tensors are pretty connected to kind of like the tensor libraries are pretty similar to like the numpy library it's just a way to store all sorts of values so knowing numpy will help you kind of be able to do some stuff with machine learning all right to get started with the code the first thing you're going to do is import the numpy library and just so we're on the same page i'm using a jupiter notebook to use to code this up but you can use whatever editor you prefer also all this code that i'll be going through will be on my github and the link to that will be in the description okay so import numpy as np if that works for you great if it didn't work you'll have to do a pip install so you can go ahead into your terminal and type in pip install numpy and so uh it's already installed for me so and if pip doesn't work for you try pip 3 install numpy that should work so the first thing that's important to know is how to initialize an array so we'll just say that a equals np dot array and then within this we just basically pass in a list so one two three this would be a one dimensional array containing the values one two three as you see uh and you can go ahead you're not using jupyter notebooks and print a okay cool so we could also initialize a little bit more complex arrays so we could do like a 2d array of floats and i could do that the following way we're going to have a list within a list so here's some floating values and then we're going to make this two dimensional so here's some more float values and let's go ahead and print b cool so now that we know how to initialize arrays uh and you can keep doing this like i can nest lists within a list within a list to create a threedimensional array etc some other useful things to know about this is how to how do you get the dimension of your numpy arrays so if i did a dot number dimensions so this tells me that it's one dimensional for a and if i did b dot and m it would be two shape is another important function so get shape uh if we do the first one a dot shape this is all we have to do it's a vector so it's only going to tell me the one dimension because it only has one dimension so it's size three if i do b dot shape it's going to tell me the rows and the columns so this is two rows and three columns so it should print out two by three as it does okay other things we want to know how much memory our numpy arrays take up so we can get the type and also get the size so if we want to get the type we do just a dot type oh sorry a dot data type in 32 by default so even though these are small values by default it specifies that it should take up four bytes or be an n32 if we wanted to specify what type we wanted to store at so maybe we knew that we didn't have many like big values so we could do like an n16 and so that would take up less size and you can see the difference in size and i say so right now it's in 16 and if i want to see the size there's a couple different i guess important functions with this we could do a dot item size so this should tell me two bytes as it does if we left this as an int 32 it will tell me four bytes down here as it does you can also do i think the total size um i guess a dot size is uh the total number of elements so the total size would be a dot size times a dot item size um another way to do that is i think just number of bytes as you see that's the same thing and um you can also do this with b it's like b dot item size bs are floats and i believe that this is an eight byte type so if i do b item size as you see yeah it's eight so floats are going to be bigger than um floats are bigger than integers usually unless you define this as like an int 64. and so yeah you really i usually don't even worry about the data type too much i don't specify it but if you really want to be efficient try to specify this so that it fits all your data but um if yeah i guess it fits all your data as tightly as possible all right so now that we've gone through some of the basics let's actually show how we access change specific elements rows columns etc so imagine we have the array there's gonna be a two dimensional array so i'm gonna make this kind of long and you'll see why in a second okay so this is a two by seven array if i print that out okay and i could prove that it's a two by seven by doing a dot shape that's just a reminder so what if we wanted to get this a specific element well to do that we can use this notation of row comma column so this is the row index this is the column index so i could just do something just like a let's say i wanted to get this 13 right here well that would be in the second row but because we started python indexing at zero be the first row and then the zero one two three four five fifth column so yeah that gives us the 13 as you see down here and one thing that's kind of cool is you can also use the negative notation similar to lists so i could also say the negative second element would be 13 as well because this would be negative 1 and then negative 2. so there's a couple different ways to do this but we'll stick with the first one okay let's say we wanted to get a specific i can't spell row that's pretty straight forward as well so in this case if we wanted the first row we would do zero and then because we want all columns we use the basic slice syntax similar to lists i can just do a single column and that will get me everything in the row that's nice what if we want a specific column well if you know how to do rows you probably know how to do columns a let's say we wanted this row right or this column right here three and ten that would be all the rows and then the zero one two column that gives me the 310 and from here we can do even some more like tricky stuff so um uh let me just say getting a little more fancy and we have the start index this is just a reminder start index end index and then finally the step size so if i wanted to let's say get between the numbers two and six every other element so two four and six well to specify that i would do well i want the first row and then i want to start at the first element the two and i actually screw that up it should be one so i start at the two then i want to end here at the six which is the it's exclusive so that would be uh i want to actually go to the sixth element and then i want to step by two because i wanted two four six so i do one six two and that gives me two four six and i can also use the negative here and do like negative two ah what happened there oh shoot that was going backwards i didn't want to change it there i wanted to change the six to be negative two ah okay it's exclusive so i wanted this to actually be negative one a little bit more of a fancy way to do that okay so that's how you access elements and then if we wanted to change something it's pretty straightforward too let's say i wanted to change that 13 that i originally accessed well i can just do like 20. if i print out a now that original element that was 13 is now 20 and you can do the same thing for um series of numbers so like for an entire column let's say we wanted to replace this 310 column i would do something like a colon two equals let's say i wanted it to be all fives i could start like this and as you see it's all fives five five and then if i wanted it to be two different numbers you just kind of specify the same shape as what you've subsequent so it'd be like one two so now you see that we have a one two in that's position really quickly let's just show a 3d example if i had a 3d so we'll say b equals numpy array of all this and if i print b so if we want to get a specific element here the recommendation i have is work outside in so work outside in so let's say i wanted this four right here well the farthest outside would be which one of these do i want and i want the first set so i want this area right here so if i wanted that i would do b zero and then now that i'm in here i want the second row so i want the three four so that would be one and now that i'm within this i want the first or the second yeah the second element but the first index like that so that gives me the four and you can do similar type stuff with like the colons in here so each one of these dimensions that you're indexing you can be all fancy with uh how you access elements so i can do something like this and you know get three four seven eight you can kind of play around with this and see how changing different things changes what you get and if you wanted to replace in this case um basically you just have to create a subsequence that's the same dimension so if i did b one this that gives me three four seven eight let's say i wanted to change that to nine nine eight eight as long as it's the same dimension it's gonna work so nine nine eight eight if i try to like do something like nine nine nine eight eight it's gonna have an error all right so that's the basics of indexing i think by the at the end of the video i'll do a little like um challenge problem on like some advanced indexing so look at the end of the video for that all right next let's go through how to initialize all sorts of different types of arrays so to start off let's uh initialize in all zeros matrix and to do that there's a nice builtin function called np.zeros and we can first i guess actually all we really need to do is specify a shape so i did like mp05 it's gonna just give me a vector of five length five but i also can pass in a more complex shape so if i wanted it to be like a two by two or two by three let's say as you see there i could do three dimensional two by three by three you could even do four dimensional if i wanted to two by three by three by two it gets pretty crazy but yeah uh you can do all sorts of zeros with that next let's do an all ones matrix pretty similar to the last one and p dot ones of let's say four by two by two and there you go and you can also specify the data type here so if you wanted like all ones but in 32 uh you can go ahead and do that so all ones all zeros however you might want to initialize a matrix that's not ones or zeros any other number so for that you can do np.full and this one takes in two parameters so the first is the shape so two by two and then the next is the value so if i wanted all 99s then it's a two by two with 99 another useful and you can you know that has a data type too so if i wanted that to be float 32 there you go and i'll put a link in the description to a list full of these like array creation routines uh useful to know is there's also this full like um there's this full like method and basically that just allows us to take a shape that's already built so let's imagine we wanted to reuse that this array that we i guess had in in the last section a well i think it's still loaded and let me just make sure well i can pass in and make a array that's the same size size of fours let's say by doing full like or actually i think i don't even have to pass in a dot shape i just have to pass in a there we go if i didn't use full like i would have to do full of a dot shape i don't know if that's that useful for you but i guess it's potentially good to know okay next one let's say we wanted to initialize a array or a matrix of random numbers so random decimal numbers to start to do that we do np dot random.rand and we specify the shape so let's say four by two oh no what did i do wrong uh huh actually confused tuple state oh okay yeah this one's a little bit different so instead of passing in a tuple you can pass in directly the integers you wanna the integers of the shape so it's a kind of a weird thing to remember so if i did the 4x2 this way i would actually pass it in like that and when you get errors like this oftentimes you can just do a quick google search and realize that that's what you need to do so i can even keep going so i could do a four by two by three of random numbers between 0 and 1. i could also pass in something like a dot shape i don't know if this would work let's try yeah so if you wanted to pass in like a shape you can do a random sample a dot shape and that now you see gives us the same shape as our a from up here so yeah rand and then there's random sample which is another method we'll keep it as random four by two okay what if you didn't want just decimal numbers but you wanted random like integer values well to do that we can do random.rand i'm getting np.random.brandint and in this one we're gonna pass in the start value or if you don't specify a start value it's gonna just start at zero um and so if you don't specify a shape then it's just gonna do one number so let's say we wanted a three by three ah what did i do wrong and this is not shaped it's actually size and yeah all the documentation has these like you know you're not expected to memorize all of these things what i think it is helpful to see is that you see that you can do these types of things so like when you're thinking about a problem you can like kind of point back like oh i remember that that's possible uh maybe do a google search on how to get it but yeah random.random07 with size 3x3 is here you can also specify like a different parameter so let's say i wanted four to seven and i think and if i keep running this too it's kind of cool you can see it changing and so it looks like that seven is exclusive so if i wanted to include seven i would stop a little bit later you could also throw in like negative numbers here cool all right uh what else other than a random integers maybe you wanted to do like the identity matrix you do identity of three this one only needs one parameter because the identity matrix by its nature is going to be a square major matrix what else is useful maybe it's useful to repeat a array a few times so to do that you could do say we had the array um one two three let's say i wanted to repeat that three times pass in the array you want to repeat and then that's print r1 see what happens okay and then if i specify the axis equals zero oh no it did do anything uh what i can do is make this a two dimensional array i think because it was a vector it didn't do what i wanted to what i wanted to do is one two three or one two three one two three one two three so if i wanted to do that now i made this a two dimensional array and it will repeat the inner part uh on the zeroth axis so it'll be basically making it rows there you go so if i made this equal to one that's going to be what we saw before cool okay so next here's a picture of an array i want you to try to initialize using everything that we kind of just went through so all these different methods so look at this picture and then try to put it together without just manually typing out all the numbers because you can imagine like this isn't too too big but if you got into a matrix that was massive you'd want to know how to build it up using these kind of like fundamental concepts okay so here's the solution to that so i can do output equals i'm going to start with making everything ones so ones and it's gonna be a five by five of ones print output so this is what i have now okay and now basically what we're gonna do is fill in this middle part with zeros so z i'm going to just say equals np dot zeros and that's going to be a three by three and if i print z now we have this now what i can do is fill in the middle element so that's 1 1 with a 9 and now if i print z we get this and then finally we need to replace the middle part of the ones matrix so output the middle part so that's going to be the first row to the third row so i want the first row to the third row and then i want the same thing with columns because it's the middle first column to the third column and actually this is an exclusive value so it needs to go to four and that's going to equal z and now what happens when i print output is yay we got what we're looking for and actually one thing that i think is nice is instead of using four i can also do negative one so basically the from the first element to the last element uh do that and as you see it didn't change this last initialization i want to go through i guess is a little bit different it's uh over on the concept of copying but something you got to be really careful about so i'm just going to quickly mention it i want to do explanation points there we go um okay so imagine we have two arrays or we have one array let's call it a and so now a is just a normal array as you can see and let's say we want to make b a direct copy of a so now i'm going to just do b equals a and then print out b and as you can see it's still one two three and so i'm like okay i have this copy like things are cool it's fine i want to change the first element in b so i'm going to do b zero equals 100. here's the issue my printout b looks good the issue lies in if i print out a look what happens i just printed out a and a now has a 100 instead of the 123 that i initially set it as and that's because when we did b equals a we just said that the the variable name b points the same thing as a does we didn't tell like numpy to make a copy of what is the contents of a so that's that's why because we're just pointing at the same exact thing that a is pointing when we change the value it also changes the value of a so if we want to prevent that we can use this dot copy function oh sorry i shouldn't do it yet um b equals a dot copy and then when we run the cell as you can see one two three it's still there because now we're just copying the contents of what's in a and if i print b it has the 100 200 100 2 3. okay so one of the big uses of numpy is all the math capabilities it offers um so just to kind of show some of that um one thing that it can do is elementwise um i'll just make those four values elementwise addition subtractions element y is i guess arithmetic so here we have a print out a um and if i wanted to do something like a plus two um adds two to each element you can do a minus two subtract two from each element a times two as you can see uh a divided by two um divides everything by two uh one thing to note with and you can also do stuff like uh a plus equals two so now i printed out a in this column it's going to be 2 plus everything it's kind of cool you can do like the same type of math that you can do in python you can also create another array an mp.array and that's like let's say one zero one zero and i could do something like a plus b and that should be two two four four oh and because i added if i rerun this okay two two four four like we expect uh so all sorts of useful things you could even do like a to the second power 1 4 9 16 and that might have made it a bigger data type i'm not sure um cool we can do stuff like take the sine of all the values so let's say we had a we do np dot sine pass in a gives us all the sinusoid of all those values which you know and you have like the cosine of all those values all sorts of useful things that you can form on an entire array or entire matrix all at once and if you want all the different things that you can do i'll paste in a link here this will all be part of the as i mentioned before i have this on my github so if you look in the description you can find this exact notebook so yeah look up the routines right here for math all sorts of cool stuff all right moving on we're gonna still be in math but let's jump into linear algebra type stuff so here we are doing linear algebra so this is kind of like basic all sorts of functions you can do on elements uh linear algebra so this is like really i feel like when i'm using matlab it would be doing these linear algebra type stuff so let's say we have two matrices and the big difference with linear algebra is like we're not doing element wise so like in this case this b we're doing elementwise computation so like a times b in you know linear algebra you're trying to multiply matrices and that's a different process so let's say we have two matrices we'll have a and i'm going to use the syntax we learned about earlier i'm going to say this is a 2 by 3 matrix of all twos or actually let's make this 2 by 3 matrix of ones so we have a as you can see and then we'll have b which is equal to np dot full it's going to be a 3 by 2 and it's going to be a value 2. so if i print out b now we have this and if you remember linear algebra you have to have the columns of the first matrix be the equal to the rows of the second one so as you can see this says three columns and this has three rows so we're good there so we would multiply this row by this column um and you know you do the the process of matric multiplication we're not going to walk through the whole thing but we should end up with a 2 by 2 matrix at the end if we want to do matrix multiplication and it doesn't just automatically occur if you try to do a times b it's not going to work because these are different sizes so we can do is mp has a matrix multiply function and if i pass an a then pass in b we get 6 6 6 6. did i say enough sixes i don't know but uh yeah it uh multiply those two matrices um you know and if i try to switch up this dimension in the middle uh it's not gonna work because it's now incompatible uh yeah that's matrix multiplication you could also want to do maybe some other stuff with matrices so let's imagine i wanted to create the or to find the um let's say determinant of a matrix so we could as a sanity check you know make c equal the identity matrix and if you are familiar with linear algebra you know that the identity matrix has a determinant of one so if i do linear algebra dot determinant of c we should get one 1.0 as we get so find the determinant you know there's all sorts of other good things like eigenvalues you know the inverse of a matrix so what what do you multiply by a matrix to get the identity matrix um and so yeah all sorts of good stuff on that like i guess i'll do and if you want to have all this information on the other types of linear algebra stuff here is some useful information definitely go to this link and as i've said a couple times in this video this notebook is on my github page so you can find all this there but yeah there's so many different things that you can do with matrices and linear algebra using the numpy library okay continuing onwards let's look at some statistics with numpy so kind of the easiest things we might think about when we think about sorry um statistics there's like min mean max etc so let's say we have this array so let's say we want to take the min of it you can just do np.min of stats that's going to give us the one that you see there you can do mpmax of stats six you could also do it on like a row basis so if i said axis equals one that's going to give me the min of the first row and the min of the second row or maybe this is a better way to see it if i said x is equal to zero well it's going to give me all the values that are up top here because those are all the the mins uh so yeah you can do all sorts of cool stuff with min and max with this same thing with max let's say x is equal to zero x equals one three and six is the biggest value three is the biggest value and the six is the biggest value you can also do np.sum of stats if i do it just as is it's going to sum up all the elements in the matrix and then same thing i can do row or column so actually equals 0 is going to add up all these terms going downwards next let's talk a little bit about reorganizing arrays so kind of the i would say the key method within reorganizing arrays so if i have the array i'm going to call it before and let's say that that is equal to this value right here so we have before i'll print before out looks like that so let's say we wanted to instead of this shape that it currently has which is a two by four um let's say we wanted to make it a i don't know a eight by one or something or maybe a four by two um or a yeah all sorts of different things we could do i'll start with eight by one so we have before and if we wanted to make it something else we can do after equals before dot reshape and then we pass in the new size we want it to have so if we wanted it to be an eight by one you can pass it in like that and we can print out after as you can see it's an eight by one now i could also say maybe i wanted it to be a four by two so now you got that you could even pass it in as a two by two by two as long as it has the same amount of values like it's fair game so as you see two by two by two still works with the reshape uh what doesn't work is like if i wanted it to be two by three um the values don't fit in so when you get errors with using their shape it's usually because there's a mismatch between the shape you're trying to resize it to versus the original shape moving onwards let's look at vertical stacks so vertically stacking vectors or matrices and you know dimensions are important in vertical stack as well so vertical stacking matrices let's say we had these two arrays if i wanted to stack um you know one two three four on top of five six seven eight i can do mp.v stack and i can pass in v1 v2 and as you see now they're part of the same matrix and one two three four is on top of five six seven eight what i can even do is keep passing these in so let's say i wanted like three copies of this five six seven eight and only one copy of this or i could enter tweet weave them that's a vertical stack horizontal stacks are pretty similar and also note here like i can't do that the size is mass mitch miss match so yep horizontal stack very similar um let's say we had um we'll use uh some notation we've learned before we had these two matrices so if i printed out h1 you got like that and then h2 is this well i want h2 to be on the back of h1 i can just do an mp.h stack horizontal stack and that will be h1 and then h2 and that did not work because i did not surround this in parenthesis either parenthesis or brackets i think they both work yeah there you go so now we've horizontally stacked the zeros on top of the or to the right of the ones all right let's get into some miscellaneous things so first off imagine you have uh you know some sort of text file with all sorts of data and for whatever reason you choose you don't want to use pandas but you want to load all that data from that file into a numpy array well we can do that without too much trouble so i have this text file that i created as you can see here this is on my github page you can download it there this is just really simple data but it shows kind of what you can do with it all delimited by commas called data txt what i can do is i can do mp and i can use this function called gen from text and i pass in the name of the file which is data.txt and then i pass in a delimiter which is the separator and that's a comma and if i do that you see that i get that data that i just showed you um you get that i can increase the zoom here i get that um as an array so that's pretty nice so i'll just call this file data equals and file data yeah one thing you notice though is it automatically cast it to a float type and what if i wanted it to be an integer well i can do another function as type which basically copies all the data into a whatever format you specify so i'll say n32 and as you can see now all this stuff is here and if i go ahead and print file data now it is back to what we had originally and the reason it's back is that this actually makes a copy because the float type and the n32 type are different sizes it can't just like in place um copy everything it doesn't really make sense to so if i did file data equals file data uh dot as type into 32 and then printed out file data as you can see now it's all floats so that's how you load data from a file and you can change up this delimiter based on how your data is split but i think that this gen from text will handle your new line breaks properly if that's how it's formatted write in the comments if you have any questions about this okay the second thing i want to go through is um what happened there i didn't want that to be marked down ah the second thing i want to go through with this miscellaneous section is some advanced indexing so there's some really cool stuff you can do with numpy i'm going to say boolean masking and advanced indexing so what can we do here so let's say i wanted to learn where in file data the value is greater than 50. so if i just type in file data greater than 50. it's pretty cool that you get false or true based on whether that specific location was greater than 50. so as you can see there's four falses and then a true if we go to our data four falses and then 196 is in fact greater than 50. so that's like one way and you can do all sorts of cool stuff with it it's like you could do greater than equal to you know all sorts of different combinations one thing that's pretty neat is you can do file data and then you can index based on where it is greater than 50. and by doing this you grab only the values that actually have a value greater than 50. so that is pretty cool and kind of the reason that this right here works is that one thing i did not mention until now is that you can can index with a list in numpy which is pretty cool so if you have the array one two three four five six seven eight nine and i wanted let's say the zeroth spot the second spot and then the last spot i could do mp or let's say that this is a i could do a of 0 1 and or i wanted 2 3 and 9 so i would do 1 2 and then 8. as you see that gives me two three and nine i passed in a list and it indexed those spots so basically it also works if you like had trues and falses it like basically if it is true then it knows to take it if it's false doesn't so that's why this up here works we could do all sorts of other things so let's say um i wanted to figure out if any value in any of these columns was greater than 50 so i can do a np.any file data greater than 50 and the axis of zero so that should tell me like if we looked downwards on all of these are any of the values greater than 50. let's see what happens so false false false false true that's correct true these two values are greater than 50 this even though this one isn't um false true yeah true true false true cool so this is telling us you know where what columns have a value greater than 50 and i can also do np.all and as you can see there's less trues in this case i think the only time that all the values are greater than 50 are right here yeah you see there's one true in the fifth spot which corresponds to this right here uh what else can we do with this um if you did axis equals one it's gonna be the rows you can also do multiple conditions so i could do like i want file data to be greater than 50 and let's say file data is less than 100 and this syntax is very similar to pandas here and as i said before numpy builds is what's the base of panda so it makes sense ah no the truth value of an array with more than one element is ambiguous how do i do this i think if i do something like this it will work not positive let's see yeah what happened no i need to end it yeah cool so this is all the values that are greater than 50 but less than 100 so like the first true should happen at the sixth spot one two three four five six as you see uh and i could do something like all the spots if i wanted to make all this not so this means not greater than 50 and less than 100 this is going to be the reverse of what we just did so yeah now the um sixth spot is the first false so this meant not so yeah all sorts of cool stuff you can do with this boolean masking and advanced indexing i mean yeah any sort of like condition i'll put a link and some more information about this all right quick little quiz on uh indexing this is kind of using all sorts of advanced stuff that you just learned in that last section include and then also like some of the original stuff so first question uh basically pause the video after i ask it and then try to figure out what the command would be so we have this matrix and how would you index this part of the matrix so this is the second and third row and the first and second column or zero and first column so it looks something like this rows columns next question how would you index this this is something we haven't done before but you potentially with that last section might have an idea if not no worries so to do this one you need to use two different lists within your uh indexing so it's gonna look something like this we need the zeroth first second and third row and then the first second third and fourth columns that's what that is and then final question how would you index this this is like also something we haven't immediately looked at but you might be able to get especially with that last one take a second all right that would look something like this where you get the zeroth fourth and fifth row zero fourth and fifth rows and then you want columns three onwards so this would like three onwards works you could also do like three to five you'd also do three or like a list of three four but yeah that's one way to do it it's a fun little quiz i don't know it's i guess good to revisit this type of thing and like think critically about it all right thank you guys very much for watching i think this is all i have for this video peace out