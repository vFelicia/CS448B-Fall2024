Learn how to build a platformer game in Python. This game will have collisions, gravity, animated characters, and much much more! Tim with Tech with Tim teaches this course. Tim has one of the most subscribed software channels on YouTube. In this video, I'll be sharing with you how to build a platformer game in Python. This game will have pixel perfect collision. It will have an animated character, as you can see here. It will have single and double jumping. It will have all kinds of different animations for falling, jumping, colliding with obstacles. For example, you can see here, when I hit the fire, I kind of go into this hit state. I will show you how to generate different objects, how to scroll the background. And really, at the end of this video, you will have a solid, fundamental understanding of how to build a platformer game in Python. And you can go and extend this and build really anything that you can think of. I will even include a ton of free assets for you that allow you to change your character, change the terrain, change the background, and do all of that extremely easily. In fact in this tutorial alone, I will show you how to use four different characters. Let me show you those characters before we continue. So this is the second character here. This is being referred to as mask dude. This is the third character. I'm calling this guy the ninja frog, as you can see. And finally, we have this character here, which is called Pinkman. Now in this tutorial, you will learn how to use all of these characters and you can swap them out with a single line of code. All right. So let's go ahead and get into it now. Since this is a long video, I do want to spend a minute here just talking about who this video is designed for exactly what you're going to learn and what you can expect to see. Don't waste your time if you don't want to go through it. So this video is really designed for people that have a bit of experience with Python. Ideally, you are an intermediate or a Python programmer. You understand the syntax, you know, for loops, you know, functions, you know all of that. If you don't feel free to follow along. But I'm not going to be explaining those basic concepts. Now, this video will teach you how to build exactly what you see here. So by the end of the video you will have exactly this. And if you're not interested in waiting until the end of the video, then you can download the code from the GitHub repository that I will leave in the description. That's also where all the assets are going to be. So regardless, you're going to have to download the code from GitHub. Again, I will leave that description, download that, open up the folder and kind of we could start working from there. Now really what I'm going to be showing you here mostly is sprite sheet animation, pixel perfect collision using what's called masks, and then how you can do the scrolling background generating objects, all of that kind of stuff. That is really the hard part when it comes to generating a platformer game. Once you have all of that down, it's very easy to extend this, to add levels, to add like, you know, a finishing flag, to add coins, to add, you know, lives. You can turn this game into anything you want. And that's how I've designed this, is that you have the base and then you can go and make it kind of a full fledged game and work off of that. So that said, I will stop talking now. I think this game looks really good. I'm excited to share this with you guys. So let's get into actually building it. So right now I have Visual Studio code open. Obviously we're doing this in Python and I already have high game install. Now the first thing we're going to have to do is install PI game, which is the module we're going to be using. So to do that, go to your terminal and type pip install PI game. If that doesn't work for you, you're going to try pip three install PI game. If that doesn't work, try python hyphen m pip instal pi game. If that doesn't work, try python three hyphen m pip install pi game. If none of those work, I'll leave two videos on the screen that show you how to install that module. Now, once you have PI game installed, I'm going to assume that you've downloaded the GitHub repository. Go to GitHub. There's a little button that says Click to download, download the folder extracted to your desktop and then open it in this code or whatever editor you want. So you have something that looks like this. You should have an assets directory inside of assets, you should have a bunch of different folders. Then you should have a main python file that contains all of the finished code. Now obviously we're going to write the code from scratch, but you can either work off that existing code or you can kind of clear the file and type along with me, whatever you want to do. I quickly want to run through the assets folder and then we'll get into the code. So in assets we have a ton of stuff. We're not going to use most of this, but I wanted to include all of it so that you could kind of continue the game later if you want. So we have, for example, backgrounds. These are a bunch of background tiles, so you can change kind of the theme or color of the background very easily. I'll show you how to do that. We have items like boxes, checkpoints, fruits, etc. We're not going to use any of those. Then we have main characters. For main characters, we have a bunch of sprite sheets inside of here and I'll show you how we can split these sprite sheets apart and use all of the different kind of animations inside of your right. So we have that for my stud ninja frog, Pink Men and Virtual Guy. All of the file names are the exact same. Okay, then we have menu. We're not going to be using anything from there. We have other, we have terrain. We are actually going to be using terrain specifically. We're going to pull out this kind of block here. But you could change the block again if you want to do that. And then we have traps and we are going to be using the fire trap, wherever that is right here that has kind of an animation right where the fires go. But again, you can add all of this stuff later on. I'll show you kind of the based on how to do it and then you'll be able to extend from there. Okay. Now that we understand the assets, I apologize for such a long introduction. Let's get into writing the code. I also need to plug the idea of the course programing expert. So if you guys want to get better at Python, check that out from the link in the description. Okay. So let's start at the top. Our program here. By importing everything we need, we're going to import LS, we're going to import random, we're going to import math, we're going to import PY game. We're going to say from OS import list directory and we're going to say from OS stop path import is file and join. Now the reason I'm doing all this OS stuff is because we are going to be dynamically loading all of the sprite sheets and the images so we don't have to manually like type out the file names that we want. I'll show you how we write a function that just loads these folders here, kind of splits the sprite sheets automatically and gives us all of the images that we're interested in. Okay. After we do that, we're going to say py game dot net, we need to initialize the py game module. Then we're going to go down here, we're going to set a caption for a display. I'm going to say py game dot display dot set underscore caption. If you're unfamiliar with what this is doing, the setting the caption at the top of the window, I'll try to explain most the PY game stuff as we go through the video. I also have a ton of videos umpire game on my channel if you want to check out something a little bit more basic. Okay. Now what I'm going to do is define a few global variables that we're going to be using here. The first one is going to be the background color. Now we'll use this for now until we implement our own background. And for the background color, I'm going to make this white, which is going to be 255 to 50 5 to 55, all of our colors and py game are going to be in rg. B Okay, so red, green, blue, that's what we have for our background color. We're going to define the width and the height of our screen. For some of you, you're going to have to make this smaller if you're on a smaller display. For me, I'm on a2k monitor, so I'm going to go with a thousand by 800. But if you're on again a smaller screen, you might want to make this just a bit smaller so that it works for you, although it doesn't really matter. Make it whatever size you want. Next I'm going to say my focus, which is my frames per second, is going to be equal to 60 and I'm going to define my player velocity equal to five. And this is going to be the speed at which my player moves around the screen. Okay. Now that we've done that, we need to set up a game window. So I'm going to say PI game, dot display, dot set underscore mode, and I'm going to pass the width and the height to this window argument here, this mode argument. And this is going to kind of create the PI game window for us. I'm going to store that in the window variable and there we go. We have kind of our global variables created. Now I'm going to make a main function and I say to find main, this main function is going to be what we run to kind of start the game. So inside of here, I'm going to take a window and at the bottom my program, I'm going to say if underscore, underscore, name, underscore, underscore is equal to underscore, underscore, main, underscore, underscore, then call the main function and pass the window argument. Okay? So hopefully you can see kind of the structure of our program already. The reason I have this line right here is so that we only call the main function. If we run this file directly, if we don't run this file directly, say we imported something from it, then we won't run the game code. Okay. So that's why I have this inside of Main is where we're going to write kind of our event loop. The event loop will be what's handling, say, the collision and moving our character, redrawing the window, all of that kind of stuff. This kind of good practice to have your event loop in one place. So inside of the main function, we need to set up a few things. The first thing we need is a clock. So we're going to say clock is equal to pi game time, dart clock. We also need to define what is it a while loop that's going to continually loop and act as our event loop. So I'm going to say run is equal to true. I'm going to say wild, true or well run string and then the first thing I'm going to do is say clocked tick. Yes. Now FIPS members are variable right here. What this line does is ensures that our while loop is going to run 60 frames per second. Okay, so no more than 60 times per second. That's what this ensures. If you're on a really slow computer, chances are you could be running less than 60 frames per second. But in my case, I'm on quite a fast computer, and if I didn't put this year, then you'd see that my game would be like way faster than yours. So we need to do this to regulate the frame rate across different devices. Okay, now that we have that, we're going to say for event in game dot, event docket and the first event that we're going to check for is if the user quits the game. If they quit by quitting, I mean they hit the red ax in the top right hand corner. Then we need to stop the event loop and exit our program. So I'm going to say if event type is equal to per game, don't quit. Then we're going to say run is equal to false and we can break out of this loop. Then we can go down here and we can say hi game talk, quit notice. This is outside of the wall loop and then we can put quit, which will actually quit the Python program. Okay, so now we have our basic event loop and what should happen if I run the code now is a plug in window should pop up. Nothing should be on the screen. And if I hit the red arrow, it should close. So let's try this and see what we get. K Notice it says platformer and then I hit X and it closes. Perfect. We're well on our way to creating the platformer game. All right, so now that we've done that, I actually think that the first thing we can do is generate our background. Then once we have the background, we can create a basic player that we can move around the screen. And once we have that, we'll start doing all of the animations. And then later in the video, once we've got kind of the bulk of the stuff done, we'll handle the collision and all of the movements. Right? Okay. So I need to make a function here and I'm going to call this get underscore background. Now before I dove into this, let's have a look at our assets folder again. Now, what I want to do is use these tiles, right? They're just tiles. I believe they're sizes 64 by 64, 32 by 32, something along those lines anyways, we want to use these tiles and tile, the whole background. So what I need to do is essentially create a whole grid of these tiles based on the size of my screen. So the way I'm going to do that is by using a folder here. This folder is going to return to me. So not this folder, right about this function. This function is going to return to me a list that contains all of the background tiles that we need to draw. So that's we're going to do here with get background. Now what we want to take is the name sorry. As I was saying, the name is going to be the color of our background and that's going to allow us to change what background that we're using. So the first thing we need to do here is load this background image. Now it's very important that when you run this file, you run it from the directory that the file exists. Now, the reason I'm saying that right now is because the way I'm going to load this image relies on the fact that you're running this code from the directory that it exists in. So see here that I'm in desktop Python platformer and then notice tutorials inside of that directory. That's why this is going to work if you try to run this code from a different directory, says see the desktop and then I tried to run this, then I'm going to get an issue. So just make sure you're in the correct directory. I just want to say that before we even get into this. Okay, so I'm going to load my image and the image is equal to py game dot image, dot load. And then what I'm going to do is join the assets path which is directly in the directory this files in with the background path here, if I spell background correctly and then with the name which is going to be the file name that I want to load, which is really just the color of the background. Okay. Now that I have that, I want to get the width and the height of this image. So I'm not guessing what it is. So I'm going to say underscore, underscore width. Height is equal to image. Don't get underscore rect. Now when you do this, it will give you the x y width, height. I don't care about the x y. So I've just put two underscores here denoting noting that I don't care about these values and then I'm able to grab the width and height. So now that I have the width in the height, I'm going to say tiles is equal to an empty list and then I'm going to loop through essentially how many tiles I need to create in the X and the Y direction. So going to say four, I'm in range and then I'm going to take my width, I'm going to integer, divide this by the width of my tile and I'm going to add one and I'm going to do the same thing for my height here. So I say four Jain range height over the height of my image plus one. Okay, so notice width here is the width of the screen. Height is the height of the screen. I'm integer dividing this by the width of my tile and that tells me approximately how many tiles I need kind of in the x direction to fill the whole screen. Then just to make sure that I don't have any gaps, I add one and I do the exact same thing for height in the y direction. Then what I'm going to do is say, actually, yeah, I'm going to say rect is this rect snow where I say pause is equal to I multiplied by the width and j multiplied by the height. And this is going to denote the position of the top left hand corner of the current tile that I'm adding to this Tiles list in PI game. When you draw something on the screen, you draw it from the top left hand corner. So what I'll be doing is continually moving the positions based on how this for loop is going, right? So for every I, for every j and multiplying it by the width and multiplying it by the height, and that gives me the accurate position. I need to place every single tile in on the screen. Hopefully that makes a bit of sense, but that's how this is working. And then I'm going to set to start append my position and then I'm going to return my tiles. I'm also going to return the image so that I can know what image I need to use when I'm drawing all of these tiles. Okay. Now that I have my background, I'm going to go into main, I'm going to say my background is equal to get background. And for the name I'm going to reference here in the background folder any of these images so we can use anyone we want. I don't really matter. I kind of like the blue one, so I'll go with blue. Feel free to change this though on your end. And there we go, if I can type this correctly. Okay. So going to say background comma, BGP, image like that. And now I want to set up something that's going to draw my background. So I'm going to make a function here and I'm going to say draw. This is going to take in a window and for now it's going to take in a background and later it'll take in everything else you want to draw inside of here. I say plugin, dot display, dot update. And before I do that, I'm going to draw my background. So I'm going to say four and this is going to be tile in background like that. And then I'm going to say window doublets and actually I need to take my BG image as well. So let's take that and I'm going to draw the background image. And then what I need to pass here is the position I want to draw it at, which is going to be tile. So what I can actually do is just convert this to a tuple. Notice the tile is going to be a list, right? Tile is going to contain kind of my XY position. You can see that here. Right? We're appending pause, which is a list of x, Y, and now that I think of it, so make it easier. Let's just make this a tuple directly and now we don't need to convert it. Okay. So in case anyone's confused, what we're doing here is looping through every single tile that we have, and then we're going to draw our background image at that position, which will fill the entire screen with background images. Then what we're going to do is update the display, the reason we update it so that every single frame we kind of clear the screen. Right. And we don't have old drawings still on the screen. You'll see what I mean in a second. But this draw function is where we're going to do all of our drawing. For now, the only thing we need to draw is the background. Later it will be the player, the blocks, the obstacles, etc. okay, so now I'm going to go inside of my wallet. I'm going to call this draw function that we just created. I'm going to pass window and then of course, I'm going to pass my background and my BG image. Okay. Now this reminds me that I no longer need this background color. We're not going to use that so I can get rid of that there. Okay. So at this point, assuming I've loaded the image correctly, we're now going to see this tiling the entire screen. So let's save and run and notice that we get it right. Styling the entire screen looks pretty good to me and we can quite easily change this if we want by just going here and saying okay, rather than blue, I want yellow. And we say yellow and now we get a yellow background. Great. So that's kind of the advantage of how I've done this here. You can change the background to any color you want. Well, given that's in the background directory, now that we have our background, what should we do next? Well, we probably want to put a player on the screen and start seeing some images for that player. Now, the player itself is the most complicated aspect of this program. There's a lot of movement going on with it. So we'll start by just creating like a block for our player, kind of move the block around, have a jumping around. Then once we do that, we'll do all of the sprites and animations just so that we can get some more progress before we dove into that because it is a bit of work. Okay, so let's go here and let's say class player, we're going to use a class for our player. It kind of makes sense here. And this class is going to inherit from page game, dot sprite, dot sprite. Now I don't typically use sprites when I'm working in pie game, but I'm going to use them in this tutorial. And the reason for that is that it makes it very easy to do pixel perfect collision when we have two sprite objects which we're going to have because we're inheriting from the pie game sprite class, we can use a method that tells us if the sprites are colliding with each other. So just understand, that's why I'm doing this inheritance. You don't have to understand exactly what the Sprite is, but it kind of denotes that we have some properties on our class and then it allows these special paging methods to use those properties to handle the collision for us so we don't have to write anything too complicated when it comes to the collision, although we still do need to handle it a bit. Okay, so what we're going to do here is define our initialization area, taking a self, an x, y, width and height. Now the width and height will really be determined by the image that we're using for our player. But for now, since we're going to have like a block for our player, and so we add that image, we're going to have a width and height. Now that reminds me that I just need to set a color for my player. So I'm going to say color is 250 500. I'm making this a class variable just so it's the same for all of my players and I have access to it just right on the class. Okay. Now what I'm going to do is say selfdoubt racked is equal to pi game dot rect and then pass my x y width and height. So rather than representing all of these values individually, we're just going to put them on the rectangle. And this is going to make it a little bit easier for us to kind of move the player around and do collision and all of that. So really, it's just a couple that's storing for individual values. When I make it party game direct, it means we can use it in some kind of special equations and whatnot. Okay, now for our player, we're going to have to have a few values. The first thing we're going to have, I'm getting a bit ahead of myself here, but is going to be the x velocity and the next is going to be the Y velocity. Now the x and y velocity is going to denote what we call it here, how fast we are moving our player. Every single frame in both directions. Right. So the way the will actually move our player is we'll just apply a velocity in a direction and then it'll just keep moving in that direction until we remove that velocity. Now this will be great, for example, for something like gravity or jumping, and you'll see what I mean in a minute. Okay. Now, do we have that? We need to add something known as a mask. For now, I'm going to say the mask is equal to none. And then I think that's all we need for right now. So now that we have that, let's add our first function here, which is going to be the move function. So MOVE is going to take in a displacement in the X direction and a displacement in the Y direction. And it's going to say the self direct X plus equals the direction x or displacement x, sorry and self director y plus equals the displacement y. Now if we want to move up or down or left or right, we just change the sign of this d x or d y right? Okay. So now we have move next. What we want to do is create two functions, one for moving to the left. And this is going to take in the velocity you want to move in the left direction and the next is going to be moving in the right direction. Again, this is going to take in self and vel now to move left. What we're going to do is say R selftaught x velocity is equal to and then this is going to be negative velocity. And then to move to the right, we're going to say self that exfil is equal to VEL. Now the reason we use negative velocity here is because if we want to go left, we have to subtract from our exposition in PI game. Remember our coordinate system is that zero zero is the top left hand corner of the screen. So if I want to move down I add to my y coordinate. And if I want to move to the right, I add to my x coordinates. If I want to go up, I subtract y. If I want to go left, I subtract x. So that's why I'm putting a negative value here. I know it seems a bit weird how I've just done move and now I'm saying move left here and I have negative. Don't worry, you'll see how this works in a second. Next I'm going to say if self direction does not equal left, then selftaught direction is equal to left. And I'm going to say selftaught animation count is equal to zero. Now, we're not going to use these right now, but I just want to add them in for now at least, and you'll see why in a second. Now, I'm also going to say up here, selftaught direction is equal to left. And the reason I'm adding this direction is because I need to keep track of what direction my player's facing. So later, once I have my sprites, I know if I'm showing the animation to the left or I'm showing the animation to the right now, the animation count. I were resetting that when we change directions. And the reason we're doing that is so that the animation doesn't look all wonky when we go from going left to right, we need to kind of reset the count that we're using to change the animation frames. Again, you're going to see that later as we go through the tutorial. Now I've just added up here. Softer animation can equal zero just to make sure we don't get any weird errors later. So now I have my direction. I'm animation. Perfect. Okay, now I'm going to copy this. I'm going to put the same thing in move right. And I'm going to change the direction here to say right and then right. So now we know what direction we're facing at all points in time. Okay, perfect. Next, what we need to do is we need to have some kind of draw function. And we also need to have what I'm going to call the loop function. And in fact, let's do the loop function first. So I'm going to say, fine loop. And inside of here I'm going to take in self and focus. Now what loop is going to do is be called once every frame. When I say frame, that's really one iteration of the while loop. And this is going to move our character in the correct direction and handle things like updating the animation and all of the stuff that we constantly need to do for our character. So for right now, I only care about moving in the right direction. We'll handle the jumping later. So what I'm going to do is just say self, don't move. And I'm going to say that we're going to move based on our x velocity and our Y velocity. Now notice we're updating our x velocity here when we move left or we move to the right. So now if we call loop and we have some velocity in the X direction is going to move our character to the left or to the right. Okay. Again, all this will start to make sense as we get through the tutorial. There is a lot of stuff I need to do kind of upfront before I can just show you instantly. So hopefully you guys are following along. But I just want to note we eventually of course will see how all of this works. I'll walk through the code, so no worries if it's a bit confusing right now. Now what else do we need to do inside of loop? Well, we need to update something known as The Mask, which I'm going to get to in a second. But before we can do that, we need to define what's known as our image. So I'm going to say define and this is going to be draw and this is going to be the function that handles drawing on the screen. And for draw, we are going to take in our window, which I'll just represent with Will. Now what we'll do for now is we'll just say Pi, game, dot, draw, dot, rectangle will draw the rectangle on the window, which is the first argument here. It's where we're drawing it. The second argument is the color which is going to be selftaught color. Then the last is directing. So I'm going to say that is selftaught selfcorrect. Now notice the rect here, right? Has our x y with height and when we move we're updating the x and y of the rectangle, which will then change where we're drawing it. If I can find it here on the screen. Okay, so that's what we need for drawing now, actually, for now, I think that's okay. We will add to this obviously in a second, but I think we can generate a player, draw the player, see it moving and then go from there. So let's do that. So let's go to Main here. I'm going to create a player. I'm going to say players equal to player. I need to pass an X, Y and a width and height. So I'm going to pass, let's say 100, 100 and let's make him 50 by 50. And then what we can do now is pass our player to the draw function. We can then take player inside of here and we can say, player don't draw and we can pass the window. Okay, so I will move the player in 1/2, but for now, let's just see if this is working, if it's going to show up on the screen. So let's run the code and notice that now we have a red rectangle in the top left hand corner. Obviously nothing's happening right now. We're not moving it around the screen. We could see it showing. So we have our player we're drawing the player on the screen now. We want to start using some of these methods right, moving left, moving right, etc.. So I want to separate my movement into a function. So I'm going to say define handle, move like this. And for this right now, we'll just take in the player. Now instead of handle move. What we're going to do is essentially check the keys that are being pressed on the keyboard. If you're pressing left or you're pressing right, then we'll move the character to the left or to the right. Eventually, we will check for collision and we'll do all of that. So I'm going to say key is equal to pi game dark keys actually not key squeaks get underscore pressed. This tells you all of the keys on the keyboard that are currently being pressed. And I'm going to say if and actually this is going to be key really we should call this keys, though, because this makes a bit more sense. We're going to say if keys and this is pi game dot k underscore left. This is the left arrow key if you want it to use the a key then you would use a like that. Yeah, actually I'll go with left arrow kicks. That's what I usually do. But you can use a or swap it however you want. And then I'm going to say if this is the case, then player dots move underscore left and how much do I want to move the player likes we have to pass the velocity. Well this is going to be my player velocity. Right. Okay. Next I'm going to say if keys and this is PI game. Okay, underscore right. Then I'm going to say player dots move underscore right again same thing I going to move this by my player velocity. Now it's important that before I do this, I set my player velocity to be zero. Now the reason this is the case is because if I don't do this, what will happen is as soon as I move left, this is going to set my player velocity right, which you can see here, my XFL, it's going to set the X velocity. Now, once I set that, I'm going to continue moving in that direction until it gets set back to zero. So if you wanted to make it so, when you press a key, you just continually move in that direction until you press a different key. Then you could omit this bonus case. We only want to move while you're holding down the key. So I'm going to say player to Excel equals zero. There's a lot of other ways to go about doing this, but I just want to stay consistent with our movement because of how we're going to do the gravity. So for now, just bear with me. We essentially set the velocity to zero and then if we are moving left or right, so for pressing these keys, then we change the velocity to be, you know, the negative player velocity or the positive player velocity based on the direction we're moving in. Okay. That's actually all we need for handling the movement. So let's put the handle movement function where we're going to put this we're going to put this before we drop. So it's a handle move when a passed my player. All right now I need to make sure before I do this that I call my loop function okay and I pass my ops. And the reason I need to call loop is because loop is what actually moves my player, right? If you look at loop, it's moving my player in the x velocity and y velocity direction. Every single frame. So if I set the x velocity, well then I continue moving again. If I said the y velocity, I move in that direction. But that only works if we're continually calling this loop function. Okay, good. So we've made great progress so far. Let's see if we can move our player where if I've made a mistakes, which are very likely. So let's run the code and let's see. Okay, so I'm going to hit my right key. You can see I can move to the right and I can move to the left. Obviously, if I wanted to go up and down, I could implement that. But we want to have a jumping, which I will show you in a second. But we kind of need collision before we can do jumping. Very good. All is looking great so far. Now let's implement gravity so we kind of fall down. Then we can do kind of the sprite sheets, then we can do the collision because the collision makes more sense. I guess once we have the the sprite sheets done. So let's implement gravity. Now gravity is a little bit complicated because we want to have like kind of a realistic gravity, right, that actually implement some basic physics. What I mean by that is, rather than just having a constant velocity, we want to actually have an acceleration for our gravity. So as many of you know, if you're in physics gravity, the acceleration is 9.8 meters per second squared. I believe that's what the acceleration is. Anyway, in our game we want to emulate something similar to that where it feels like the longer you're falling, the faster you fall. You're not falling at a constant speed that makes the game just feel like really, really unrealistic. So the first thing we need to do is pick some value that we want our gravity to be. And this is the acceleration of gravity. So keep that in mind. So for this, I'm going to make a variable in my player class because it's the only place we need it right now, I'm going to say is equal to one. So gravity is equal to one. If you want gravity to be faster, obviously you increment this value, right? Make it large. Okay, now inside of loop, this is where we need to handle our gravity. So every single frame in our loop, we're going to increase the Y velocity by our gravity. However, how we know how much to increase the velocity by varies on how long we've been falling for. Yeah, I know this seems really weird, but we essentially need to keep track of how long we've been falling so that we know how quickly we should be increasing our velocity or how quick we should be accelerating downwards. So that means that I need to create a variable here called selftaught count and given we should really call a song better, I'll call it fall count. And this will essentially tell us, okay, how long have we been in the air for? How long have we been falling? And we'll use this value to determine how much we increment our velocity by. So I'm now I'm going to say myself the y underscore velocity and I'm going to add to this the minimum of one or and I'm going to take myself not count. And this is my fall count divided by the frames per second, multiplied by the selftaught gravity. Now, this isn't truly what the acceleration would be, but this will give us a kind of somewhat realistic looking gravity in the game. So just bear with me. So what we're doing, we're taking our full count, we're dividing it by FBC. The point of this is that if I want this value to be in seconds, then I need to take whatever my count is, which I'm going to increment every single loop. In fact, we'll do this right now, plus equals one and I divide it by EPS with my FBC 60. As soon as this is 60 that I've been falling for 1/2, I take that amount time, I multiply it by my gravity and then that tells me how much I'm going to increment my y velocity by. However, this is going to start out being really, really small, just like fractional decimal decimal amounts. So just to make this a bit easier for us when we do our collision, I'm going to increment this by the minimum of one or this value. So every frame we're moving at least one pixel down and it doesn't take us like a full second before we really start feeling any effect of gravity. Hopefully that makes a bit of sense. You guys are understanding me here, but just bear with me. I've experimented with these numbers quite a bit, so I think this should be fun. Okay, so now that we have this, what should happen when I just click Run here is I should just start falling immediately on the screen. And obviously until we have some platforms, a collision, we can't really stop falling if we have gravity. But let's have a look and let's see how it works right now. Okay. So you can see that I fall and notice I'll do this again, that I start falling slowly and then it picks up the pace. Right? So this is somewhat realistic to how gravity would actually work. And that's what I was trying to implement when I did this. Now that we have done that, it's time to move on and have some kind of sprites or images. I was going to do this later, but I realized that we can't really do the collision, which is going to be pixel perfect collision until we have some kind of images. That's that's really all we need. We need our sprites. So what we need to do here first is examine what our sprites look like for our characters. Now, remember all these characters pretty much the exact same. They just look different. But in terms of their movements, their animations, the number of images, they're identical. So whatever I show you for one of these is the same for all of them. Hence why we can just kind of swap them out. So when I go to Mask dude here, let's zoom in. You can see that we have, for example, double jump. I just picked a random sprite. She now this sheet has six different animations or six different frames which represent what this guy is going to look like while he's kind of jumping or double jumping in the air. So what we need to do is we need to split this one image into the six individual images and then loop through those images at some frequency or some time so that we can show them on the screen and show an animation. Right. We need to kind of manually do this. Now, some of these are single frames like falling is a single frame that's easy hit. Okay? This is like, you know, the guy disappears for a second, kind of expands, goes back. You get the point. We want to loop through these animations, idle single frame. Actually, no, idle. It's not a single frame. It's a bunch of frames. This guys arms it kind of wagging up and down. We have jump a single frame, run a bunch of frames and then watch them. Now notice here with these images that they're in different directions or let's say they're all kind of facing, right? So another thing we're going to have to do is rotate this image to face left when our character is facing left. So that's another thing we have to handle that not only do we just have to split these images up, we also have to get a rotated version of them so we can show you moving in a different direction. Same with jumping and with being idle. Like whatever direction you're going. We need to show the image flipped in that direction, so don't rotate or flip. That's what we're going to do. Okay, so let's do this first thing I will do actually, is I'll write the function that will flip our image. So I'm going to say flip sprites. This is going to take in a list of sprites and I'm going to return pie game, dot transform, dot flip and this is going to be sprites true false notice as it says here, this is indicating what directions you want to flip in when I past. True, this means flip in the extraction when I pass false. This means don't flip in the y direction. If you want to flip both, you'd past true twice, but we don't want to do that. So I have pie game to transform the flip sprite and then this is going to be for sprite in sprites really I could call this image but you get the point because we have flip now we're going to write a function which is load sprite sheets and should we call it sheet or sheets? I think sheets is fine and what this is going to do is load all of the different sprite sheets for our characters. So it's going to give us a spreadsheet for double jumping, for hitting, for falling. And then within our character we can pick what sheet we want to be using, what animations we want to loop through. So I'm going to take in directory one, in directory two. And the reason I'm doing this is so that I can load other images that aren't just my characters and this will be very dynamic. I also want to take in the desired width and height of my image and if we need to load multiple directions so I'm going to say direction equals false is the default parameters so that we only load like the left and the right side images like we flip the images if you passed this equal to true. Okay, now the first thing we need to do is determine the path to the images we're going to be loading. So I'm going to say join assets dir one, dir two. Notice I can use join because I imported this from oh stop path. Okay, now I'm going to get all of the images in this directory. Now the way I do that, as often as the images is equal to and this is going to be f for F in list directory again notice I can use that. So import here. We're going to list all of the things that are inside of this path directory and then we're going to say if is file and then this is going to be join path and F so what this for loop is going to do here this I forget what you actually call this when you write a for loop in a list anyways but this line is going to do here is load every single file only file that is inside of this directory. So again, we're just going to get every single one of these file names and then once we have this file names, we can load that image and we can then split that image up into the individual images that we want to get. So we have images now I'm going to say all sprites is equal to a dictionary. And what I'm going to do with this dictionary is have key value pairs where the key is the, let's say, animation style and the value is all of the images in that animation. Okay. So all sprites now I'm going to say for image in images and I'm going to say that my sprite sheet, so the individual sprite sheet I want to load here is going to be equal to pie game dot image default load and then this is going to be join path and image and then dot convert alpha, which is essentially going to allow me to load a transparent background image. Okay. So we are loading the image which is just one of the files that we found right from this path. And we just need to append the path to it, right? So whatever the path to the directory is, plus the image name. Okay, we're going to load that in. We're going to get the transparent background. Now that we have this, we need to get all of the sprites in this image. So going to say sprites is equal to and now it's going to be a list okay. So again, the processes load all of the different files. Okay, we have all the files, these are sprite sheets. Now we need to get all the individual images from the spreadsheet and load those, get some going, say for I in range and then this is going to be sprite sheet get underscore width integer divided by the width of the image that we're loading now. Width is going to be the width of an individual image inside of our animation or inside of our spreadsheet. So if I know this is say 32 pixels, I pass 32 and then it gives me a bunch of images that are 32 pixels white. That's how I'm doing the loading. So that's why it took width and height here. Okay. Now that we have that, we're going to say surface is equal to game dot surface and then this is going to be width height. We're going to pass py game dot s c which allows us to load again transparent images. And then I'm going to pass 32 here, which is the depth. Don't worry about that. But this just what we need to load these images and now we need to create a rectangle which is going to tell us where in this image, an image being the sprite sheet that we want to take, an individual image from and bullet it onto the surface. I know this seems really weird, but what we're doing is we're going to create a surface that's the size of our desired individual animation frame. We're then going to grab that animation frame from our main, main image. We're going to draw it onto the surface and then we're going to kind of export that surface. That's the way that we have to do this. So I'm going to say rectangle is equal to PI game dot rect. And for the rect this is the location on our original image that we want to grab this new frame from. So I'm going to say this is I multiplied by my width and then zero and then the width and the height of my image. Okay, now that I have that, I'm going to say surface dot bullet. Bullet really means draw and I'm going to draw my sprite sheet, but I'm going to draw this at zero zero and I'm only going to draw the portion of it which is my rectangle. So notice this is my source, this is the destination, and this is the area of my source that I'm drawing. So in position zero zero, which is the top left hand corner of my new surface, I'm drawing my sprite sheet, but I'm only drawing the frame from my sprite sheet that I want. Okay, then I'm going to say Sprite, start, append, and I'm going to append my surface, but I'm going to make my surface two times larger because that's what I want to do. I want this to be bigger than the default size. So I'm going to say pie game dots transform dot scale to x and then I'm going to scale to X my surface. Okay. Again, I know this seems a bit complicated, but now we have essentially stripped out all of the individual frames. We've just scaled them up to be double their size. So if they're 32 by 32, we've made them 64 by 64. That's what scale to X does. And now we need to handle the directions. Okay, so now we need to say if direction, then all underscore sprites and this is going to be image dot replace, it's going to be dot PG, it's going to be an empty string plus underscore, right is equal to our sprites. Now we're going to copy the same thing, copy this and put it here and now this is going to be underscore left is equal to and this is going to be flip sprites. So what we're saying here is if you want a multidirectional animation, then we need to add two keys to our dictionary here for every single one of, our animations. So for falling, for hit, for idle, we need a left and a right side. So the right side is the one that we already have. So we're going to say, okay, all sprites at and then we're just going to strip off the dot page from whatever the name of our base image was that's going to give us run, jump, idle, hit whatever the name of our files and then we're going to spend on her school right or underscore left now for underscore right, that's our basic sprites for underscore left. We need to flip all of those sprites and we already wrote the function that did now otherwise then what we'll do is say all underscore sprites at image dot replace dot pinky with an empty string. This just removes that up pinky and then it's going to be equal to sprites. Okay then we can return all of our sprites. All right. Probably one of the most complicated aspects of the code that we need to write. So don't worry, we are done now with loading images at least. Well, we'll have to load our block, but that's going to be a lot easier than loading our sprite sheets. So this now will load a spreadsheet for us. Now that we've load our sprite sheet, we actually want to start using this. So inside of player we are going to grab our images. So I'm going to say my sprites is equal to and it's going to be load spreadsheets and now I need to pass what I want to load. So now I need to pass the main character directory. And actually this is main characters. Okay, so have a look here. So inside of assets, right? Yes. So we're joining assets with Dir one in dirt two. So the first directory I pass is main characters and then I pass the second directory, which is the name of the character I want to load. So mask dude, ninja frog Pinkman or Virtual Guy, you can pick whatever one you want. I'm going to go with mask dude for now. Now for width and height. Be within the height of this, going to be 32. So make sure you do this 30 to 32 and then you pass through because we want a sprite. So both the left and right side animations, that's what we want. Okay. Now that we have that, we are going to change our draw here so that we're drawing our Sprite now for for now, we're just going to draw like one simple sprite to see how it looks on the screen. Then I'll go through animating the Sprite and showing you how that works. Okay. So rather than pong game, do draw out rect. I'm going to say self that sprite is equal to and then this is going to be selftaught sprites at idle. Now Idle is one of the name for our animations, right? So if we go here you can see we have idle jump etc. So I'm accessing the key from my dictionary and then I'm going to access the first frame of this key, which is zero because every single key is a whole sprite, right? So now that I have my Sprite, I'm going to say window applet and then this is going to be self doubt sprite and I'm going to bullet this at selftaught rect on x and self doubt rec dot y, which is the position on the screen. And then if we want, we can just turn off the gravity for right now so we can kind of see it on the screen and it doesn't just disappear. Okay, let's try this out. Let's just make sure it actually loaded correctly. So let me run this and we are there. Okay, so let me see what error we got here. Run this again. It said key key error idle. Okay. So the issue here is that since we load a directional sprite, we need to reference either idle right or idle left. So we can actually do this by saying idle underscore plus self direction. And then so long as we set the direction which we did here to left, this should work. So now it'll change based on if we're going left or right. So actually you'll see that it should swap as we change directions. Okay, let's try this now. All right, so now we have this guy facing left. If I go right, he turns right, left, right. Perfect. Now we want to see him animated. So as I was saying, let's get into the animation. Now, this actually can be pretty easy because we've already loaded in all of the frames that we need. So I know that we don't have a ton to show right now, but a lot of the hard stuff is done for this video, so just make you aware that all this time has not gone to waste. What we need to do is we need to come up with something that has a way to kind of update our Sprite or update what we're showing on the screen. So I'm going to write a function here called Update Sprite, and I'm going to take itself and I'm going to say Sprite sheet is equal to idle. Now, this is the default spreadsheet. If we're not moving, if we're not jumping, if we're not falling, if not being attacked, we use idle. However, if we are running or we're doing something else, then we use the other sprite. So now I'm going to say if my selftaught x velocity does not equal zero, then my sprite sheet is going to be equal to run. So if I have some velocity in the x direction, then I'm running, right? So then I want to change this to the run spreadsheet. So I'm going to say my sprite sheet name is equal to and this is going to be my sprite sheet plus and then underscore and then plus the self support direction. Perfect. So now we just change the main sprite sheet name so it'll run, jump, whatever, we add the direction to it. And this tells us, you know what exact sprite sheet we want. Okay, now that we have that, what we're going to do is say the sprite that we could be using for this animation is equal to self dot sprites and this is in all capitals at the sprite sheet name. All right. Now that we've done that, we need to essentially iterate through these sprites and every few seconds change the sprite that we're showing so that it looks like we're animating. So we need to add a variable here that is going to account for the amount of delay between changing sprites. So I'm going to call this the animation delay and make this equal to five. Okay. Now I'm going to come here and I'm going to say that my Sprite index, which essentially is Sprite that I want to be using here, is equal to my self dot animation count, which we're going to increment the second integer divided by my selftaught animation delay modulus by the length of the sprites that I'm using. Now, let's just put some parentheses here for order of operations and let me explain what we're doing. So we have an animation delay that's every five frames. So every five frames we want to show a different sprite in whatever animation we're using. So if we're running left, if we're idle, whatever, it doesn't matter. We want to show a different one. So we take the animation count, we divide it by five, and then we mod whatever the line of our sprites is. So if we have five sprites, then when we're on, say, animation, count ten, we're showing the second sprite right? You get the idea. So this is dynamic. This will not work for any single sprite. So hopefully you guys understand how this animation count is kind of working. But we're trying to pick a new index every animation frames from our sprites, but we want this to be dynamic. So we're using the length of the sprites. And again, it's just it's dynamic work for any single sprite sheet we have now. We need to select our sprites. We say selfdoubt Sprite is equal to the Sprite, so we have access to at the Sprite index. Then we update our animation count by one. Now what we can do is remove this here from draw and we just need to now call the self dot update sprite from our loop. Okay. So now that we've done that, we'll call this, we'll update our Sprite every single frame and then we'll draw that updated sprite on the screen. Okay, let's run it and let's see what we get. Notice, we have idle notice. I can run to the right and I can run to the left. Now, if you think this is too slow and some of you may argue that it is, then you just make this number smaller. So make this three. Okay. And now it looks like we're running a little bit faster. So it's completely up to you how you want to animate this. I'll do two for now and let's see if this looks better. So actually, I think three was a pretty kind of happy medium here since go back to three again, you guys can change this. It's up to you how you want it to look. Okay, now that we have that, we're almost ready to start doing collision. However, we need to introduce something known as a mask. So I'm going to make another method here and say, define update. Now what we need to do here is essentially update the rectangle that bounds our character based on the sprite that we're showing. So it's different like kind of sizes to the sprites, right? Some are a little bit taller, some are little push the left or pushed to the right. And the rectangle that we have, we want to be essentially the same as the sprite that we have. Again, I know this seems a bit weird, but we're going to do this are going to say self direct is equal to self dot and then it's going to be sprite get underscore rect. And we're going to say that the top left of this rectangle is equal to the self direct dot x and these selfcorrect dot y. Now pretty much what's going to happen here is depending on what Sprite we have, if it's slightly smaller, slightly bigger, whatever, we're going to constantly adjust the rectangle specifically we're going to adjust the width and the height of it, but we're going to use the same x and Y position that we've had for this rectangle. If you don't understand that, it's fine. It's not a massive deal. This line is not crazy important, but it's just trying to make sure that the rectangle we're using to kind of bound our character is constantly adjusted based on the sprite that we're using. Now, what's more important is this line, which is updating the mask. We're going to say self, that mask is equal do pi game dot mask dot from the surface and it's going to be selftaught sprite. Now let me quickly explain this. A mask is essentially a mapping of all of the pixels that exist in the Sprite. So whenever we draw something on the screen, we're really drawing a rectangle, right? But the rectangle may not have nontransparent pixels, right? So only part of the rectangle is actually filled in. Hence why we get kind of a circular image, a dynamic image, whatever. So what this mask tells us is where there's actually images or where is not where there's actually pixels. Sorry. And this mask allows us to perform pixel perfect collision because we can overlap it with another mask and make sure that we only say two objects collide if pixels are colliding, not if the rectangular box is colliding. If we did rectangular collision, then it constantly looks like we're hitting something even when we're not. Because the rectangle for our character is larger than where all of the pixels for our character are. You've probably seen this in a lot of games before, but what the mask does is solve that problem for us and allow us to do this kind of pixel perfect collision. It's very important, though, that you call this mask. If you don't do that, this collision is not going to work properly. It needs to be mask because the sprite that we inherited from here uses this rectangle and uses this mask property when it does the collision. All right. So now that we've done this, I just need to call this function. So I'm going to go here and say selfdeport update and now we're done with most of what we need for the player. So what we want to do now is we want to start adding blocks onto the screen and then letting a player fall, collide with those blocks and then be able to jump. Because obviously we can't really jump until we have something to jump off of. Otherwise, jumping in thin air doesn't make a ton of sense. All right. So let's create another class here. And this class I'm going to call object. And this will be a base class that we use for essentially all of our objects, just so that the collision will be uniform across all of them. So again, we're going to inherit from the Sprite class from PY game and we're going to define our initialization. So define a net. We're taking self x, y, width and height and name which for now is going to be equal to none but could be equal to something. Or they're going to say super dot underscore underscore init which will initialize the superclass, which is this one right here. Now the reminds me we need this as well in our constructor for player. So let's put that in player. Okay, now we need to define a rectangle and say self. That rectangle is equal to py game dots rect and then this is going to be x, y, width and height. We're going to say selftaught image is equal to py game dot surface and then this is going to be width height and then we're going to say py game dot source alpha like that if we spell py game correctly. Again, this just supports transport transparent images for us. My apologies. And then we're going to say selftaught width equals width. Selftaught height is equal to height and selftaught name is equal to name. Where I'm going to say define draw, I'm going to say self and window like this and then we're going to say win doublets. And this is going to be selftaught image and then we're going to split this at the self dot rect dot x and he's selfcorrect dot y okay I know I went fast. Essentially, this is just a base class. We're not actually going to instantiate this, but this just defines all of the properties that we need for a valid sprite. So we have a rectangle, we have our image, we are drawing the image and then in a class. So we're about to use, we're going to inherit from this and it will just save us from rewriting a bunch of functionality that we don't need. So the idea here is that all we do is modify this image. When we change the image now, the draw function will automatically draw it accurately on the screen for us. And all these other properties we're just saving in case we need them from our child class. So I'm going to make a class now called BLOCK. This is going to inherit from object. Now we're going to say define init around second self, x, y and the size of our block. Now since the block is a square, we just need one dimension not too right. We're going to say super dot underscore underscore init. We're going to pass XY size size. So notice this constructor requires four arguments. We have to pass four here. We just duplicate size because it's the same for the width and height. Then we're going to say block is equal to load block, which is going be a function that we write in a second that will take a size. We're going to say self, image, doublet. Imagine that this is going to give us an image, okay, which it will in a second. When we write it, we're going to hit the block at position zero zero and then we're going to say the self dump mask is equal to py game don't masked from surface we're going to take our self that image and there you go we have our mask which we need for collision. Okay, again, I know this is a little confusing. It'll make more sense in a second, but we're using this object which now has this draw function built in for us. It also defines subtract, it defines the width and height and all of that stuff. Here, what we do is we get the image that we need, which we're going to write this in 1/2, then we bullet this image to our image, which is a pie game surface. And then we say selfdoubt mask you you'll do piling up to mask the from surface selfdoubt image. We also could just say self that image is equal to the block, but let's do it this way for now. Okay, so let's now write our get block function, which I'm going to do beneath our get sprite sheet or load spreadsheets. I'm going to say get and I'm going to take in a size. Now what I need to do here is essentially find the block that I want in my train folder. So I'm going to say path is equal to join assets and then this is going to be terrain like so. And then we're going to use the terrain dot PNG file. So if I go here, you could see that we have terrain, terrain and then what we want to do is load this block, which I'll be showing you how to load in 1/2. Okay. Now that we have done that, now that we have our path, we're going to say the image is equal to py game dot image, dot load and we're going to say path again to convert alpha so that we get a transparent background. We don't really need it for this one. But just in case later we load string does have transparency. We will and we're going to say surface is equal to pi game dot surface. And for the surface we're in a past size size which is the width and the height of our surface and past pi game dot source alpha with a depth sorry of 32 we're going to say rectangle is equal to pi game dot rect and then this is going to be 96 zero size size. Now let me slow down for 1/2. If we go to terrain, we can see that we want to load this guy right here. Now, I've already done the math. This image starts 96 pixels from the top of the screen. So that's the reason I'm putting 96 there because I want to start at 96. So 96 zero is my position and then I want to load the size of this, which I think is going to be either 96 or 64 or something along those lines. Anyways, if I wanted to load, say, this train image, then I would still have 96. But my y position would be different. In fact, the Y position would probably be a little bit less than 96. It might be 80, it might be 85. I'd have to experiment with it to see exactly where this image starts. But I just want you to understand that what I'm passing here, when I say something like 96 zero, I'm passing the position that I want to load the image from from the image, right? So I'm picking out a part of this image and this is like 96 zero. That's where I am picking it right here. Hopefully you guys understand that. But if you want to load a different train image, then you have to adjust these to be the starting position, the top left hand corner of whatever image it is you want to load here. And if yeah, I was going to say we can load different one, but I don't want to waste time guessing which one it is. So you guys can mess with that if you want. But let's just load this top one, which I already know works. Okay, now that we have that ran, it's a surface dump blitz and we're going to blitz the image and again, we're going to blitz it at zero zero, but we're only to hit the area of it which is represented by the rectangle. Then we are going to return high game dot transform dot scale to x surface. Okay, so we've passed what size we want our block to be. Then we create an image that is of that size. Okay. We then say rectangle is equal to 96 zero size size. Right? And then we blitz this image onto our surface, which will be the image that we return. And we return this scaled up by two times. So it just doubles the size that we pass here. You don't have to scale it if you don't want, but I want it to be larger so I am scaling. Now I understand again, Spike, if using this size is going to be the dimension of this block, so you want to pass whatever the size from this sprite sheet is that you want to get. In our case, I think it's going to be 64 or something along those lines. So that's what size will be. You guys can mess around with this, but really what you're going to be changing is these two values and the size. That's what you're going to change when you want to load a different image for your block. Okay, so now for block, we have to block or load block. I call it load block or get block. I called it get block. Okay, so let's change this to be get block. All right. So now have a block. Let's create a block. Let's draw a block on the screen and let's do some collision with our blocks. Okay? So let's go here to Main and let's say blocks is equal to and let's just start by creating a single block. So for our block, let's just put it kind of randomly on the screen for now where do I want to put this? Let's go with something like actually, I'm going to create a variable first, say block size. Let's put this at zero height minus the block underscore size. BLOCK size is going to be equal to 96. Okay. And then for the size we're going to pass, block size. Okay. So the size of our block is actually 96. I lied. It is not 64. It's going to be 96. So we're going to create a block that's going to be positioned at zero height, minus block size, which is going to put it at the bottom of the screen. And then the size is this. Now we need to draw blocks. So I'm going to pass blocks to my draw function. Okay. And I'm going to go here and actually let's call this objects and we're going to say form objects or for objects in objects. If we could type this correctly, object dot draw. I'm struggling here with the typing and we will draw this on the window. Okay, so we have our block now. Let's quickly look at this again right. We load her image. Okay, we got a block, we have her size now. We create the block down here and then we put it on the screen. Let's run it and see if we get a block. And of course, we got an error. What's it say here? I need to run this again. I take zero positional arguments, but one was given. Okay, so let's go to our player class here and we can see update. I forgot to add the self parameter, so let's add that in and that should fix it. Okay. So now you can see that we have a block. So now what we can do is create a whole floor of blocks if we want to do that and then we'll implement gravity and then collision with the blocks so that you can see that you can land on the block and we can jump off of the block. All right, so let's make a whole floor. So to make a floor, we can do this instead. Floor is equal to we're going to say. BLOCK It's going to be high times. BLOCK Size. It's going to be height, minus block size, block size for I in range. And I'm going to say a negative width with times two. And we're going to divide this by the block size and by block size. Then for my blocks, let's actually just replace this and instead we'll just pass for okay, what I've done here with this for loop is I've said I want to create blocks that go kind of to the left and to the right of the screen. So I don't want to just fill the current screen because we're going to have scrolling background in the second, which will implement in a minute. Anyways, I want to have some kind of go into the left and some going to the right. So I'm taking my negative with over the block size, which is how many blocks I want to the left side of the screen. And then I'm taking my width times two and I'm integer dividing that by the block size again. That's how many I want to the right of the screen. Then I'm taking I, I'm multiplying it by my block size, which is telling me the x coordinate position that I want my block to be on. And then this is always going to be same because I want it to be at the bottom of the screen and then for my block size, well, I want that to always be the same. Okay. So let's run this now and see what we get. And now we get a bunch of blocks. So now that we have these blocks, let's make it so we can collide with the blocks. And so we have gravity and we actually fall onto those blocks. So the collision all right. Collision is a little complicated, but let's write it and let's see how we can how we can get it going here. So inside of Handle Move is where we're going to handle our collision, which means we need to have a list of objects that we can potentially be colliding with. Now, we are going to write a function here called Handle Vertical Collision because we need to handle the vertical and horizontal collision differently. For now, we'll just start with vertical orientation player objects and the displacement in why that we just moved now we're going to have collided underscore is equal to a list I'm going to say for object in objects. These are all the objects we could be colliding with. I'm going to say if my game dot sprites, dot collide mask and then we're going to pass our player and our object. Now, remember, I told you Collision was going to be simple. Well, there you go. This is all you need to do to determine if two objects are colliding. The reason we can do this is because our objects we've inherited from the Sprite class and on them we have a mask. So we're going to use this mask property as well as the rectangle property. When we collide with the mask. So I passed my player, I passed my object and this will tell me if I am colliding with my object. Perfect. Now if I am, I'm going to do some stuff differently depending on what direction I'm colliding in. So if I'm hitting the top of the object, it's going to be different than if I'm hitting the bottom. So we need to handle that here. So I'm going to say if my displacement Y is greater than zero, really, this should be velocity. But this fine, then what I'm going to do is place my character on top of the object it collided with, so I'm no longer colliding with it. Now, what this is saying is if I'm moving down on the screen, so if I'm moving down, then that would mean I was colliding with the top of this object. So if I am, I'm going to take the bottom of my player rectangle, which is my bottom, my players feet essentially. And I'm going to make it equal the top of the object. I'm colliding with this. Another advantage of using rectangles. You can use this kind of bottom and top property and avoid having to do, you know, add the height and that kind of stuff. So that's what I'm going to do now. Otherwise I'm going to say if my display so y is less than zero and I suppose this can be an elf, then what I will do is say my player direct top is equal to the object rect bottom because if I'm moving up, which means I have a negative velocity, then I am hitting the bottom of an object. So I need to make my top be equal to the bottom. Okay. This just makes it so you don't like, say, stay inside of the object. Excuse me? You go outside of it and it looks like you collided, but you didn't go through the object. Now, one thing we also need to do here is need to call the method player down landed and player dot hit head, which I've not yet created. And we're going to write these to handle what happens when we land on a block and when we hit our head on a block. Okay, then we're going to say collided objects, dot append and we're going to append our object and we're going to return our collided objects just so that we know what objects we collide with so that we can check if we collided with like fire or a certain special object or something like that. Okay, so let's handle vertical collision. Now we need to write the landed and hit head method. So let's go to player and let's do this. So I'm going to say let's do it here. Landed Self. Now what do we do if we landed? Well, if we just landed, then we need to reset our gravity, our fall counter. So we're going to say self dot fall count is equal to zero. So that way we stop like adding gravity, right? Okay. What else do we need to do if we land? We need to say that our y velocity is equal to zero. If we let it on a block, stop moving us down and I'll add this in. Now we're going to say our self, that jump count is equal to zero. We're going to do something with jumping that involves double jumping. So we'll have a jump counter. I'll just put this here now and then we'll use it later. Okay, so that's if we landed. Otherwise I'm going to say define hit head for self. I'm going to say self doubt count equals. If we hit our head, I want to reverse our velocity so that now we move down because we're moving up, right? So I'm going to multiply my velocity by negative ones that when I hit my head, I kind of bounce off the block and go downwards. That's what's going to look most natural. Okay, so that's all we need for right now, for hitting the head. Now we can add our gravity back and when we add our gravity back, what's going to happen is will fall. We'll hit the block, we'll move us to the top of the block, and then we should just build a move on top of the block. Let's see if that's going to work, though. Although it's not going to work if we don't add the function call. So let's add the function call here in handle move. We're going to say handle vertical. We'll pass the player, the objects and the player y velocity. And the y velocity is essentially how much we just moved right. Okay, very good. Now let's make your handle move. We need to pass our floor, so let's do that. All right, let's run the code. Let's see what we get. And boom, look, we land on a block and we can now run on top of the block and everything is looking very good to me. Okay, so that's pretty good. Now that we're on top of a block, we can jump and then we can deal with hitting blocks. What do you call this? Horizontally, right? So that we can't, like, run into a block and we'll also make the background scroll and then we'll be pretty good. We'll have a lot of this tutorial finished. I want it to make us jump. Yes, let's make a jump. Okay. So let's go to our player and let's create a variable here. Selftaught jump underscore is equal to zero. Now, based on the way of coded, this jumping is actually quite easy. I can say define jump self and when we jump all we're going to do is say self doubt y underscore velocity is equal to the negative of self dog gravity multiplied by whatever factor you want in terms of the speed of your jump. So I'm going to multiply gravity by eight. The reason I'm doing this negative is that I jump up in the air, right? So now that I've done this will happen is as soon as I hit the jump key, I'll jump up into the air. It's pretty straightforward. And the reason that's going to happen is because my y velocity will change and what will bring me down is the fact that inside of my loop, if I go to where loop is, I'm constantly applying downward gravity. So what I'm doing is changing my velocity to go upwards and then I'm letting gravity take me down. So that's kind of the benefit of how we've quoted this. Jumping is very easy. Now I'm also going to reset my animation count to zero. I'm going to say my jump count plus equals one. I'm going to say if the selftaught jump underscore count is equal to one, this means that I'm double jumping. So if the jump counts equal to one when I hit jump, that means it's just going to be equal to two. Now, let me take this. Sorry and put this down here. Then I will say self account is equal to zero. Yeah, I think so. That makes sense. No, I want to do it this way, sir. Okay, so what I'm trying to do here is make it so that as soon as I jump, I essentially get rid of any gravity I've already obtained. So let's say I was, like, falling. And then I landed and then I jumped. There would be some gravity on me keeping me on the ground. So I want to remove that gravity so that when I jump up, it's in the factor, like it's not taking into account and then I'll start applying the gravity after I jump. Hopefully that makes a bit of sense, but this should say fall count. So as soon as I jump, I'm resetting the fall count to be equal to zero so that any gravity I've accumulated I'm removing. But I'm only doing that if this is the first jump I'm making. Because for the second jump I want you to have to time it based on like when you're jumping, right? So if you jump a second time close to when you jump the first time, you will jump higher than if you jumped at like the peak of your jump when you're gravity would be the highest. Okay. I don't know if that makes sense, but just just fall along here. This I mess with this before this works, trust me. All right. So we have jumping now. I think that's all we really need. Jumping? Yeah, that seems good to me. So now if we want to jump, let's make it. So when we hit space, we jump so we can do that inside of handle move. Actually, I'm not going to do it. Handle, move. I'm going to do it here in the event loop. And the reason for this is that if I do it in handle move, what's going to happen is if I press the jump key and I hold the jump key down, I'm going to keep jumping a bunch of times. I don't want to do that. I just want to jump once when I hit the key and then I have to release the key and press it again to jump. This tells me if I'm holding down the key, what I'm going to do in here tells me if I released the key. Yeah, you'll see. Yeah, this is the dude. So I'm going to say if event type is equal to PI game dot key down, then we say if events dorky is equal to pi game. Okay, underscore space and my player dot jump count is less than two. So I'm going to allow double jumping. Right. So I'll have two jumps then I'm going to say player dot jump. Okay, that should be all we need for jumping. So let's try it out and let's see if this works and I can jump and notice I can kind of run and jump at the same time. Now what I'll do now is add like falling and jumping animations because obviously it looks kind of weird right now when I'm jumping, but there you go. We can jump. Nice. Okay, so let's add the the animations now. So if we go to update Sprite, all we need to do here is we'll say if self dot and actually I need to refer to my cheat sheet here because this is a bit more complicated. I thought, I mean to say if not self if self doubt y underscore velocity does not equal zero, then what I will do is say if selftaught jump count equals equals one, then I'm going to say my sprite sheet is equal to jump. I'm going to say self, self don't jump count equals equals to. Then my spreadsheet is equal to double. Now this is actually going to be if my velocity is less than zero, which means I'm moving up. Now, the next one that I want to add is I want to say if and actually these are all going to be LFS Well not that one, but this one I'm going to say f myself. The y underscore vowel is greater than zero this means. I'm moving down, then my spreadsheet should be equal to fall. Okay, so this is handling regular jump and double jump and this is telling me if I'm falling, let's try it now and let's see what happens when I jump. Okay, so it's kind of glitching a little bit. The reason this is happening, I believe, is because we are applying gravity even while we're on the ground. So my y velocity is always greater than zero and something greater than zero that's greater than zero again. So I will show you how to fix this. All right. So actually, the way that I'm going to fix this is a bit of a hack, but it's it's going to be good. No work here. So I'm actually going to say if my self the Y velocity is greater than self, dot's gravity times two. Now the reason I'm going to do this for fall is so that I don't immediately start glitching into this false state when I have a really low amount of gravity being applied to me when I've gone off the block and then I've fallen down to the block. So let me show you what I mean by just kind of running the code here. So You can see that what happens is when I hit the block, when I collide with it, it's going to reset my gravity count and then I'm going to kind of spawn to the top of the block. So when I'm on the top of the block, going to be slowly falling down to the block. Then I'm going to hit the block. When I hit the block, it's going do the same thing. It's going to bring me to the top, reset my gravity count. So what was happening before is that we would go to the top of the block and then our gravity would increase a tiny bit, right, to increase to be one pixel per second or something along those lines, which would mean we were falling. So then we were falling. We hit the block and then it reset it so it kept glitching between the two states. So what I've done is just made it. So we have to have a significant amount of gravity before it starts showing that false state. So now it doesn't look glitchy on the screen as I'm jumping around. And you can see that what actually happened is when I jump and I get to the peak of my jump, you can see that it starts the falling state because right now my velocity is change directions. Right now I'm going down. Okay, so now we have jumping, now we have running around and colliding with blocks then quite a bit actually. The next thing I want to do is make it so that objects move on the screen. Then we will do our horizontal collision and then we will pretty much be done after I add kind of that like fire state, right? Or that let's call it a trap, something like that. Okay. So we want to do scrolling background. Scrolling background is actually fairly easy. The way that we do a scrolling background is we simply offset every single thing that we're drawing on the screen by a certain amount. So any object that we have, we don't change its position at all. We just change how we're drawing it on the screen so it doesn't affect any of our collision. All it affects is what's seen, right? So what's happening in the background is we may be colliding at a really far position to the right. We're showing the position currently on the screen. You see what I mean? But what this involves is having some offset X, which I'm going to say is equal to zero now the way that I want to have it and I'll just illustrate here, is that when I'm on the screen, I only start scrolling the background when I get close to the edge. So like here, right? It would start scrolling. Whereas if I'm in the middle and I'm kind of moving like this, don't want it to scroll the background until I get to the edge. Oh, also notice you can double jump here. I kind of forgot to mention that part, so I'm going to implement that where essentially once we reach a certain boundary, then the screen will start scrolling. All right, so how do we do this? Well, we can do it just directly inside of our loop here. We're going to do it here. We're going to say if B player dot rect dot x minus the offset x plus the player direct dealt with. And actually, now that I think of this, we're just going to do this, we're going to say if the player dot rect dot right which will account for the width minus the offset x is greater than or equal to the width minus a variable that I'm going to write in a second, which is scroll area width and any Blair dot x underscore velocity is greater than zero. Then we are going to say offset underscore x and this is going to be plus B player x velocity. All right, let me just write this variable then I'll explain how this works, because we also have to do the other side. So as I scroll area with is equal to 200. What that means is that when I get to 200 pixels on the left or 200 pixels on the right of the screen, I start scrolling, okay, so here what I'm doing is I'm checking if I am moving to the right. That's what this checks. If my x velocity is greater than zero, that means I'm moving to the right and this is checking if my character is right on the screen, like if it's crossed a specific boundary. So I take whatever the right position of my player is, which could be very far off the screen. I subtract whatever offset we currently have. So if we're offsetting everything by 100 pixels, for example, I subtract that so I know where I'm actually showing the character on the screen and I say if that's greater than the width minus the scroll area width, which means I'm at say 700 pixels, something like that on the right side of the screen, then I'm going to offset the screen by whatever the velocity was that my player just moved to. Right? So that will make it look like I'm scrolling. Now we can say or and do the exact same thing for the left side. So I'm going to say if player dot rect dot left and this is actually going to be is going to be plus the offset. I'm going to check if it's plus or if it's minus. No, it's going to be minus again. Minus. The offset x is less than or equal to the scroll area width and my player dot x underscore value is less than zero. Then I want to do this now. Let's move this down on the screen a bit. I'm just going to add some parentheses that my condition is correct. Okay. So I think that should be good. Again, I'm checking to the left and to the right side. If I'm moving to the left, I want to check if I'm at that boundary, if I'm checking to the right, or if I'm moving to the right. So I want to check if I'm at that boundary and then I increment my offset X. Now, all I have to do to account for this is add an offset X to my draw function and draw every single object offset by this x. So I'm going to go here, let's say offset, underscore x. And now just to all of my draw functions, I'm going to pass offset x, offset underscore x, I'm going to go to all my draw functions and I'm going to add this offset X and what I'm going to do is just subtract the offset X from the exposition. I'm drawing everything out since it minus offset x and we'll take in the offset underscore x. Okay. Now the reason this works, if I move to the left, my offset x is going to be negative, which means everything is going to push to the right side because we're adding to the position for it. If I move to the left side or sorry if I move to the right side, the offset X is going to be positive, which means everything going to move to the left. So it has a scrolling background effect. Let's just run it though and see if it works. Then I can fix it if it doesn't. Okay, so I start running here. You can see that now the floor is going to start going with me once I reach this boundary. However, on this side, right, like what I'm in the middle is not doing anything. I have to get to a certain boundary which is kind of invisible on the screen, and then it starts scrolling with me, which is what I wanted to do. And then notice if I jump here, boom, I fall off the platform. Let's do collision with blocks in the horizontal direction. So to do that, I'm just going to add a block here. So I'm actually going to make a list. Let's say objects is equal to Asterix Floor. Now, if you ever seen like kind of dot, dot, dot in JavaScript, that's what this does in Python. It just essentially breaks this floor into all its individual elements and passes them inside of this list. So imagine it if me just writing this here, that's what it's doing, and then I'm going to pass another block. And for this block, I'm going to place this at let's do zero. And then for the why, this is going to be the height of the screen minus the block size times two. Now the reason I am multiplying this by two is so that I get it a bit higher on the screen so that we can kind of run into it horizontally. And I'm going to pass my block size. So just see, now I want to go and rather than drawing my floor, I want to pass objects and same here with handle move on to pass objects. So let me run this. So now you can see that I have that block there right now. Notice that when I hit the block, I kind of go to the top of it. And the reason I go to the top of the block is because right now I'm only handling my vertical collision. So when I hit the block, I a little bit of gravity because remember, there's always some gravity on me when I'm on the floor. And so it thinks that I've hit the top of the block, so it spawns me on the top, the block. So we need to make it now so that when you hit the block in the horizontal direction, it kind of pops you off of it so that it doesn't think you're hitting the top of the block or the bottom of the block, alternatively, which you'll see in a second. And in fact, let me add one more block to show you. Hitting our head on the block. So let's add another block. Let's make this at same block size multiplied by. And then for the heights, it's two times four. Okay, now we have another block. Let's see where this guy is. Now I can show you that I can hit my head on the block. Right. And I can't kind of go above it. Okay, anyways, we have that. Let's do our horizontal collision. So the horizontal collision is a bit weird to implement. The idea behind this is that since we're using our Sprite Collide mask, we want to make sure that if we collide with a block horizontally, we move ourselves off of that block so that it doesn't think that we're colliding with it in the vertical direction. Now, you just saw that happen. We hit the block. It thought that we were hitting it like the top of the block. So it put us on the top of the block because that's what this line does right here. So in our horizontal collision, we essentially need to check, okay, by moving in this direction, are you going to hit the block? If you are going to hit the block, we want to prevent you from moving in that direction so that you don't hit it, collide with it, and then we like spawn to the top of it. So let me write it and I'll explain to you how it works. But it's just very important that we check the horizontal collision first. Then once we check that, we check the vertical collision because we only want to check vertical collision if we are not colliding with a block horizontally or if we haven't already handled or if we have already handled the horizontal collision. Again, the idea is we don't want to be thinking that we're hitting the block on the top when really we hit it on the left or the right side. So we've got to check that first. So I'm going to make a function you say define collide mean it's a player objects a displacement X like that. Now I'm going to say player dot move and I'm going to move my player in the displacement X direction and zero in the Y direction. The reason I'm doing this is I want to check if with the current velocity that my player has, if now the reason I'm doing this is I want to check if my player were to move to the right or if they were to move to the left, would they hit a block? That's that's what I'm checking essentially by moving the player preemptively. So now what I need to do is say player to update. Now the reason I need to call the update and let's go here to update is because I need to update the rectangle in the mask before I check for collision. So again, what I'm doing is I'm preemptively moving my player to where they would be moving if they're going left or right. I'm updating their mask and their rectangle and then I'm going to say for object in objects, if pie game dot, sprite dot collide mask and then I'm passing player and my object. So this is why I needed to update my mask in my rectangle. So I move my player, I update it and then using that updated mask, I check what I be colliding with an object. Now I'm going to say collided object is equal to none. I've got to spell colliding correctly. If I am, then I'm going to say collided and this is just going to be object is equal object. Then I'm going to break. Okay, then I'm going to say, player, don't move and I'm going to move them back and then I'm going to say player dot update. Okay. And then I'm going to return the collided object. Okay. So what I'm doing right, I'm moving my player, I'm updating the mask, I'm checking if they would with something. If they were to move in that direction, then if they did. Okay, I get that collide object. It doesn't matter if they do or they don't. After I check this collision, I have to move them back to where they originally were. Stuff to reverse the movement and then update the mask again. Then I return collide object. Okay then moving checking if we had anything either way. Moving back to where we were before. This is preemptively checking before we allow them to move into a block. All right. Now what we need to do, use this function R to allow us to move left or right or to disallow us from moving left or right. So I'm going to say collide, underscore left is equal to collide player objects and then negative player. Well, then I'm going to say collide underscore right is equal to collide player objects and then player and then I'm going to say and not collide left and not collide right again. What we're doing here is we're checking if we should be able to move left or if we should be able to move right based on our current position. That's why I make that preemptive movement. And then here I only let you make the movement if that movement does not cause you moving into a block or colliding with one, now that we have that, that should actually handle our horizontal collision, that's actually all we need. All right. So let me run this code and let's see some here. Okay. Obviously, that's still working. And you can see that I can't go through the block now. Let's go here. And actually, I'm getting a bit of a bug on the right side. Okay. So that time it worked, but it's a little bit glitchy and I have a feeling it has to do with the animation count of me running because it's only some times when I'm running and I hit the block that it spawns me up here. So I'm just going to do another little hack here and I'm just going to multiply this by two. Both of them here. The reason for this being that I'll just make it so there's a little bit of space between the block and that way. Me changing the sprite isn't going to affect. I collide with the object or not, because remember the sprites kind of shift to the left or to the right a little bit. So just by adding this multiplied by two, it should make it so that I'm never going to be colliding left or right. It will make it. There's a bit of space. See how there's a bit of space between the block now. But that's okay because now I'm never going to have that collision bug where it's going to spawn me to the top. And really you could just add one or two pixels, but you can see that that kind of fixed it right there. Okay. So now we have collision with blocks, we have a scrolling background, we have double jumping. I think that the last thing that we need to add here is the fire thing, right? Kind of got trap or you hit it and you kind of flash and then once we've done that, we'll pretty much be done. The tutorial. All right, so let's write our class for representing our fire. So I'm going to say class fire. This is going to inherit from object as well. And this is going to be animated. We're going to have animated fire. So this will take a bit more work, but I think it'll be worth it. It looks pretty cool on the screen. So I'm going to take X, Y width and height and then I'm going to call my super initialize. So super underscore, underscore net self x, y, width and height. Okay. And then for the name of this, I'm actually going to call it fire. Remember that we can pass a name. The reason I'm adding a name to the object so that I can determine when I collide with the object. If it's fire and if it's fire, then I want to do something right. Okay. So for self fire, I'm going to use our load sprite sheets function for directory one. This is going to be traps and for directory two, this is going to be fire. Now if we go here to traps, you can see that fire is one of our traps we have hit off on. Okay. Now there's also a bunch of other traps, right? So you can you can pick a different trap if you want. You could pass this blink one or whatever. The thing with these ones is that they have some more animations. So there's a bit more logic you need to handle for them. So that's why I'm going with fire, because it's a pretty simple one to do now up here for fire. I'm again going to have my animation delay, so let's make that equal three and now let's specify our image. So Let's say ourself that image is going to be self. The fire off. We're going to start with it off and then zero. Okay, then I'm going to say self mask is equal to pi game masked from surface selftaught image like that. Okay then I need to set an animation. So I'm going to say my animation underscore count is equal to zero just like we did for our player. And I need to set myself dot animation underscore which for now is going to be equal to off. Okay, now I'm going to make a few functions. My first function is going to be on my first method and I can say selftaught animation name is equal to. And if we look at fire we see we have hit off on, we're not going to use hit, we're just going to use off and on. Okay. Now we're going to have off self selftaught animation name is equal to off. Okay and then we'll our loop we'll say define loop self. And inside of our loop we're going to do a very similar thing to what we did inside of our player loop in fact. So somewhere that I can copy pretty much all of this right here. So let's copy all that and let's paste that. Yeah. Now for update rather than actually just calling it update method, we'll just copy the stuff from the update method here and just paste it down. Okay. And rather than self that sprite, we're going to change this to image. And I actually think that once we remove the direction here, this is all that we need for our. All right, so now we just need to make a few changes. We're going to get rid of this sprite sheet name and rather than Sprite sheet name, we're going to say it's self dot animation name. And now we should actually be good to just use this. So let me space this out a bit. We get our sprites, okay? This is it going to be self. That's sprites. No it's going to be self. That's right. It's going to be self. Doubt fire. Which is this. Okay. Really, I should call this something else, but fire is going to represent all of our fire images. Okay, so I'm using this to get my different animations. I'm getting the animation name that I'm currently playing, either on or off. And then I'm saying my sprite index is equal to self done animation count divided by the self. That animation delay mod the amount of sprites, same as what we have before. My image is equal to sprites at sprite index and then I increment the animation count, update my rectangle and update my mask, which is important for the collision. And I'm good. Now last thing I want to do here is I want to just check if my selftaught animation count is greater than if this divided by myself, that animation delay is greater than the line of sprites. Now the reason I want to do this is so that my animation count doesn't get too large. Now you'll notice in my player class I actually didn't do this. Now that was intentional because if you do this, then it kind of messes up how the double works. You can do it if you want, but you'll see that it kind of messes with things. And with our player, we're constantly resetting the animation count when we jump or when we go left or when we go right. So that value doesn't really get too large. But here for our fire, since it's just static, like it's just sitting forever, what will happen is the animation count if we never change it back to zero, we'll get to an extremely large number which can kind of lag our program. So what I want to do is just make it smaller, right? So if it goes beyond what the actual animation, what do you call it, this is the line of the Sprite start. Then I want to set this to zero. It's important I divide it by the animation delay, though, because if I'm dividing it here, I need to divide it here before I set it back to zero. Okay, so now we have fire and that's actually all we need for fire. So now we just need to add it to our objects. So let's create it. Let's say fire. So you go to fire and what do we need to pass for fire in x, y, width and height so we can pick where we want to put this? Where do I want to put my x and Y? Okay, for now let's go hundred and let's go. Height minus the block size. And then I don't know how tall my fire's going to be. I've got to see how big I want to make this. Let's make it say 60 and then we'll go 30 to 64 here. Okay. So if we look at fire, it's quick. We have a look here and go to off example or on the size of this is 32 by 64. Okay, that's what the size is and you need to pass that correctly to the fire class, otherwise it won't load the image properly. So we take our height minus our block size, 64, which will put us on top of a block. Now I will put this at. Yeah, 100 is fine for now for the X and yeah. 32 width, 60 for height. There we go. We have our fire now. I was going say fired up on I'm just going to turn it on, we'll just leave it on forever. You can turn off programmatically if you want. And then inside of objects, all this place, my fire. Now that I've done that. It should just show up on the screen when I run my car. So I got an issue. Let's see what the bug is here. Of course, the output is not showing up correctly. This is an it takes from 5 to 6 plus positional arguments which seven were given. Okay, I see the issue here. Let's go back to our fire. And we don't want to pass self. Let's remove self. Okay, let's run this list index out of range so that fire off zero. Hmm. Okay. I'm wondering why that's giving us an issue we have off here. So that should have been. Okay, so let's go here and let's print selftaught fire and let's see why it's giving us this this bug here. All right. So I have determined the issue, and the issue is that I passed the incorrect size here. It's actually 16 by 32. So it's passing too large of a size. And that's why it wasn't giving us the correct number images. So let's change this now and run. And now we should be okay. And there we go. Now we have fire. But however it is off now the reason it's off is because we didn't call the loop method on fire. So let's fix that and also get rid of the print statement that I put here that I don't need anymore. Okay, so let's go down to Main and where we have player out loop. Let's call fire dot loop and is asking for the piece. I don't know if I took that in my loop here. No, I don't need the props for that. So let's get rid of that. Okay. Now let's call it and it should start being on fire object has not shoot sprites. Okay, let's go fix that error. My apologies. Fire. We have Sprite somewhere here that we don't want self. That Sprite is going be self thought image and selftaught image. All right, start with that. Let's run it now. And there we go. We now have a moving fire. And notice that I can kind of be on top of the fire, right? So I can collide with it. And it's like pixel perfect collision pretty much when I'm hitting it. So now the last thing we need is to just make it so we go into that kind of hit state. When we do hit the fire, that's actually pretty easy to do. We just need to add a kind of state to our player to know if we're hit or not. So we're going to say selfdeport. Hit is equal to false. We also want to hit counts because we're going to only be flashing for a certain amount of time. Then we're going to have a method here to fine hit self. Self to hit equals true in self that hit count is equal to zero. Then we're going to go in loop and before our update sprite, we're going to say if selftaught hit, then selftaught hit count plus equals one. And then we're going to say if selftaught hit count is greater then and we can just pick some value. But let's say fpace multiplied by two, which is going to be 2 seconds, then the self taught hit is equal to false. Then we go here into our update sprite and we say actually at the top here, if selfdoubt hits, it's important you put this at the top, by the way. So I'm actually buddy here. Then we are going to say the sprite sheet is equal to hit. Great. Then we want to now determine if we actually got hit. So we do that from our collision functions which are going to be here. All right. So we have collide left. We have collide, right. And we're going to have vertical collide. Now, what we're going to do is we're essentially going to loop through all of these objects and we're going to see if we hit fire. Now, the way we'll know if we hit fire is by looking at all the objects that were returned here. And it will tell us, well, if we hit fire or not. Right. Because we can look at the name of the object. And if the name of the object is fire, then we know we have fire. So I'm going to say to check is equal to collide left, collide right and asterisks vertical collide. Now I realized that inside of here I only returned one object, whereas inside of here I returned all the objects I was colliding with vertically. Really, we should probably be returning all of them from here as well, but I think this is still going to work. So we'll just leave it how it is for right now. So I to say, for object in to underscore check these are all the objects we collided with. Remember I'm going to say if to underscore, check and to underscore check dot name is equal to fire then player dot hit is able to trip. Okay that is all we need. And actually I'm going to say player to hits I want to call the method I don't want to set it equal to true. So what we're doing here is looking through all the objects we collide with, if any of them are fire, then we will put hit on the player. The reason I'm doing this first, if to check, is because these could be none, right? We could have no objects we collide with. So I need to make sure I handle that case before I try to access name on an object that isn't defined. All right, let's run the code and let's see. And player has no object, no attribute hit count. Okay, so let's go to player and let's go to hit count and let's make that equal to zero. I guess I forgot to assign that. All right, let's try this. Now, list object has no attribute name. Okay, interesting. Let's see here. Okay. All right, so I'm using to check when I need to be checking object. So let's fix that. And the code blue object is not callable. Okay, player dot hit. Aha. So let's call this make hit. It's because I have an attribute with the same name as my method. So it's accessing the attribute when it should be accessing the method. So I'm just going to say make underscore hit. And now that should fix the problem for us. Run the code and there we go. Now it looks like I'm always being hit right now. That, of course, is a bug. So hit is equal to false. Let's let's check our hit count. It's because if selfdoubt hits off the hit count plus, it goes one if self the hit count is greater than selftan equals false. Maybe we need to reset our hit count as well. Okay. And there's probably a bug here. Let's scroll down, keep scrolling with our so we have to check if okay you would be a name equals it goes fire player don't make hit okay I'm not sure what the bug is. Let me run this again. And yeah, it seems like we start out in the hit state, so maybe it's an issue in here. Let's have a look here. If selftaught hit spreadsheet equals hit. But we are we hit right away for some reason it's making us hit immediately. Okay. Let me have a look here. Yes. And I'll be right back. All right. So I've realized I made a silly mistake here. I actually have this collided objects append outside of this if statement and that was causing all kinds of bugs and issues for me. I think I was doing some print debugging, so let me get rid of that here. Anyways, I just moved it back now. So that is in the correct location. So now if I rerun this now we should see that when I hit the fire it puts me into kind of this hit state last 2 seconds and then it ends. All right. So that's it, guys. I think that's pretty much going to wrap up this video. This showed you how to create a platformer, how to do animations, how to be sprites, how to do a scrolling background. Obviously, there is a ton of stuff that could be added to this game, but I really want to leave that to you. Obviously, I could spend hours, days, months working on a game like this, but I think this is a solid enough base to really give you guys a good foundation to go out there and create something pretty cool. Obviously There's all kinds of assets that I would leave in the GitHub that you can use. I have all kinds of other PI game tutorials that you may want to reference. If you want to learn about Menu's sound effects points, scoring, all of that kind of stuff. You guys go my channel search pie game tutorial. You will see a bunch of them. Those will show you how to do a ton of other things that you know you may want to add to this game. So I hope you enjoyed this. This was a ton of work. As always, the code will be in the description if you did enjoy make, surely they like subscribe to the channel. Consider supporting me by purchasing something like programing expert and I hope to see you in another YouTube video.