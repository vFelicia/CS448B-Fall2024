in this course JS Legend will teach you how to make a game in JavaScript with the capl library and how to use Tori to make it installable on a Windows PC JS Legend dev has created many popular courses hi everyone welcome to this new tutorial today I'll teach you how to make a desktop game in JavaScript so JavaScript is usually used for the web but with a technology called T you we're going to be able to make a game that is installable on your PC so we're going to use Tori and the capl library if you don't have any experience with both of them I'm going to explain everything so this tutorial is really for you in the sense the only prerequisites you need is a good fundamental understanding of JavaScript now let's get started so the game we going to build here is a Flappy Bird Style game so you jump here and then when you hit the obstacle you have your previous best score that is always written to dis so you have the concept of this save file and this is something I wanted to teach you because this is one of the main draw of having a desktop game in JavaScript is so that you can save your games so usually JavaScript is used for the web and in the web you know you have local storage but it isn't a very safe way to store data because as soon as the player clears their browser cache it's going to wipe out the save so this is one of the main aspect main draw of having your game as a desktop game if it grows above of a certain size and you need to keep track of save data so let's jump right into it so in this game one thing I forgot to mention is that we're going to have multiple inputs it's going to be a very simple game because I want to focus on the actual Tor Concepts and the capl concept so capl is the library for making games that is very easy it was called Kaboom Jaz previously if you want to know why the Rebrand you can watch the previous video by the way I I made a a lot of tutorials on Kaboom JS and how like C playay basically now how to make games with it so if you're interested feel free to watch those as well they are still relevant because the difference between capl and Kaboom is just the name for now all right so here we're going to implement keyboard controls so just by pressing the space button you can jump we're going to also Implement Mouse control so by clicking you can jump but also Gamepad control by pressing the South button you're going to be able to jump so uh this might sound strange what is the South button so look at this little schematic imagine this is a controller the South button is the button the action button that is always at the South here so it's a way that capl uses those terms so that it can be independent from the actual type of controller so an Xbox controller versus a PlayStation controller have different symbols on them but at the end of the day the x button is here for the PlayStation and the for the Xbox I don't remember actually here is it A or B that is down there but by just using the South name we can just have our uh game be agnostic regarding this so let's start the project so there are some prerequisites uh that you need to have so in terms of following this tutorial you only need to know JavaScript the basics but as for the installation process and also by the way I'm going to do this mostly on windows so the reason I'm doing this on Windows because this is the machine I have and also the expectation for games is usually that they run on windows so if you're going to publish a game on Steam it's really not worth your time to support Linux and Mac OS usually now maybe with protown uh with the steam deck it's it's changing a bit but yeah so you need to follow this um this page so it's going to be linked in the description it's the prerequisites so you need to set up this on windows by the way you can still follow this tutorial on Mac OS or Linux there are some instructions but at the end of the day the execut the executable you're going to get is not going to be the one for Windows so here we're going to set up Windows uh now here I have the link in the description follow the instruction here you have a few things to install so one thing I want to mention is the web view2 thing so Tori compared to electron which is another solution technology for basically making desktop apps using JavaScript HTML and CSS is that with electron it packages a whole Chrome browser for each version of your app so if if it's on Linux or Mac OS Etc it's always going to package a fixed version of Chrome and the advantage of that is that your app is going to be rendered the exact same way regard regardless of the platform however the drawback of this is that it's going to make your app bloated so because electron has to package a whole Chrome browser that means an executable that does basically nothing so a project empty project is going to be I think 100 megabytes now with Tori the actual end game like the full game uh that I've shown you earlier is only 6 megabytes so you can see that it's really not bloated and the way Tori achieves this is by have using the systems web view so for each operating system they have a web view that Tori uses but the issue is that is that you cannot really make sure that the app is going to be rendered the same way on all platforms because uh you know different browser engines have different particularities it's mostly the same but not it's not exactly the same the reason I'm going to use Tory for this tutorial is because it was very easier to set up than electron less bloed since uh on Windows and also on other platforms but the most important aspect that uh basically determined that I wanted to use Tori instead of electron is the fact that I really am targeting Windows only for this project so I don't really care or feel any of the drawback of the fact that it's not exactly the same browser engine on the various other platforms because I'm not publishing to other platforms all right so once you follow this so you install and by the way another drawback perceived drawback is that it needs to have this web V2 runtime install on the users ma machine that is going to use the app but now it should be available on all windows 11 uh PL uh operating systems distributions but not on Windows 10 uh or certain or Windows 7 I think and then the reason for that is well it's it's not available by default and if you were to just distribute aexe made with Tori then this would be an issue because you would have to make sure that the user has the web view to install on their machine now this is not an issue in the end because we're going to distribute the installer the MSI and this installer that we get after building the project is going to install this web view2 runtime on the user's machine if it's not already available so you don't have to worry about anything and yeah you need to install rust even though in this tutorial we're not going to use it really we're just going to well we're going to R write some commands but we're not going to write rust basically it's just the project itself is built with rust because there's a JavaScript API that you can use to read and write to a file which makes it very beginner friendly I guess all right so follow this and once you have uh followed the prerequisites for your platform let's jump right into the project all right so what are how do we start a project so also you have to have nodejs installed this should have been mentioned in the prerequisites link that I've shown you earlier on so you need to run npm create ta at latest dot here if we're in a folder so I'm using vs code as my editor I have created this kbby folder because creb is the name I've chosen for this project and then once I'm in this project I can use the dot notation here so that it's it's going to create the project files within the the current folder I'm in if you were to emit this it would create a different folder for you so run this command and then maybe I should increase the font size already just to make sure that everything is visible and then the package name you have to specify your package name I'm going to call it kbe uh tutorial actually just creepy I'm going to use typescript and JavaScript this project uses JavaScript but you need to use like which one for your front end you want and then npm and then here do not select the vanilla UI template because the vanilla UI template is just going to be a build lless HTML CSS in JavaScript so we still need to use a build system because it's very it's more convenient to install and use the um Tor API that way so I'm going to take the react template but I'm going to remove everything that is related to react for this project and then choose JavaScript here all right so we have everything we need now I'm going to open up the package.json and you can see that we have a couple of dependencies we going to need to remove so we're going to need to remove react and react D because we're not going to use them so I'm going to type in npm uninstall react and then react D all right right the package have have been uninstalled and then I'm going to also uninstall this vgs plugin react we don't need that as well so I forgot to do that so let's do it here we go npm uninstall uninstall here we go and then that's it and now we can install the cap playay Library so cap playay can be installed in many different ways it can be installed using a script tag uh much like I did with Kaboom Jazz but for this project since we're using vit inside of it we're just going to use npm npm install C play and I'm going to install a specific version this is uh I'm making sure to pin the version here so that if you're watching this in the future it's going to always work this tutorial at least so it's a selfcontained so 3,000 that's the version 0.1.7 U if you're not familiar with KL and Kaboom it works in thousand so version 1.0 is actually one version 1,000 version 2.0 is 2,000 version 3.0 is 3,000 this is the the the naming convention that I used it say it's strange but I don't know the reason why but yeah that's it it is what it is so I'm going to hit npm install cap play with this version now we have capl installed let me check in the package.json and here we go okay so before we do anything I'm just going to collapse this I'm going to collapse this as well and I'm going to go to here so here to run Tor you need you have this Tory command just to make things convenient for us we're going to have rename those commands so we're going to have Dev do do browser and Dot browser here to differentiate from the two other commands I'm going to write here so I'm just going to do preview this is just a name I have decided for myself but here instead of having Tori here we just going to have when I run npm run Dev I want to run Tor Dev which is going to actually start the application and the reason we're doing this is because we have two systems going on we have vit which is a bundler that bundles your web code and then puts it on a local host that you can use and then there's Tory which takes this output at the same time and puts it in a desktop app desktop window so that's why we have those two commands even though for this project we're not going to use vit directly like that we're going to use Tori Dev so the other command is build and Tori build so just to check that everything works uh but because we are using the react template I'm going to remove everything that is within here so let's remove all of those files I'm going to also remove everything within the oh oops within the public folder oops all right delete this all right now we have the the index.html we don't really need much here I'm going to remove this I'm going to remove the head tag I'm going to remove it the HTML I'm going to remove even this it's it doesn't matter and then here instead of jsx it's going to be JS and then in the source file I'm going to create a main.js file now in main.js I'm going to call what we need for cap play so I'm going to import cap play from cap play and then oops and then here I'm going to initialize the capl context which is basically creates the canvas for us you call the cap playay function like that and then pass in a a bunch of options the width of the canvas is going to be uh 1,280 by the height which is 720 and then here I'm going to use the letter box options those are all options that comes from Capa so here letter box true makes our game our game will scale regardless of the Windows size while maintaining the aspect ratio and then here I'm going to put whenever or not we want this to be Global to be false so we don't want capl functions to be available globally we want to all capl functions to be callable from the K the context this will make our code cleaner and then we you want to scale the canvas two times this is what looked good uh and then this is for everything within the canvas it's going to become relevant later on so let's do that now let's go back to the terminal and run npm run Dev and then here it's going to compile your project and then you're going to have to wait a bit before it compiles and usually you're if you modify things related to Tor config I'm going to go over the file here then the application will have to close and reopen otherwise if you just modify JavaScript content here a code here it's it's usually it should usually hot hot reload I have something messed up I need to modify something in the Tor file here yeah here you should run the dev browser and then build browser and so really the preview command it doesn't matter so I'm just going to cancel this out and then everything should work all right so if I do this and then okay what's the issue cannot find the package VJs plugin react so here let's remove everything related to react in the v config because we have removed it so everything should be like that and now just so you can see uh I removed this and another option called plugin react so now let's run it hopefully it works this time around yep when you see Local Host and then it's compiling and then downloading the various crates we need this this is only done the first time I think and then it's building yeah so it might take some time it's a bit slow at but this is only like the first time all right so it was a bit slow but it's the only once you do this and then now it should hopefully open up and here we go we have our window with our canvas and then if you press F12 so let me just increase that a bit if I press F12 you'll have your console this ignore this we just remove the favicon it doesn't matter since it's a desktop application and yep so we're ready to start working on the game so let's try let's import our assets so I'm going to close this by the way you can just leave it open like that so here we go I'm going to go here and for the assets let's we're going to put them all in the public folder all right so I have imported all the assets sets you're going to find a link in the description or multiple links in the description to get everything here so I'm going to go over everyone so this is the background.png for our game clouds we're going to have a colliders data. Json which basically defines the hitbox for every platform uh obstacle so the the height and width of that hitbox and where to put it so the X and Y cordinates uh this is better I thought it would be better than having to pull an external editor like if you want interested in how to make like more serious games using an external editor called tiled watch the previous tutorial I made on the channel here are a few sounds we have the confirm sound so when you click on the button the HT sound and the jump sound those are made using a website called GS fxr.com obstacle layer here so the obstacles and then one thing also is the icon so here you can provide a bunch of different icons and there's a an icon command in Tori but for this project since it's I only care about Windows I just imported this icon for my project so just you'll find this in the description just put it in the under the source dtory and then icons folder here all right so if I look at the project you can see the icon appears here now all right I'm going to minimize this and we're ready to start working on our project so let's go back to the source folder and then in main.js so the first thing I'm going to do is to actually load bunch of our assets the way you do that in capl is to call either the load Sprite function or the load sound function there's also the load found function uh not F font sorry so load Sprite works this way so you pass in the name of the Sprite you want to use so kby this is going to be the the key that we're going to refer to in our code base and then the second param is the actual Pam so the Pam here is going to be the path to the assets which is going to be kb. PNG Dash cre so the reason it's just a dash is because when working with vit the public folder can be will automatically be linked to the root of the project so you don't have to write public SL k.png so that's the first one and that's basically it for the Sprite so I'm going to copy and paste the rest that you need here so load Sprite obstacles backgrounds and clouds much the same way for the sounds it's similar but the only thing that CH changes is that you use the load sound method instead all right one thing I want to implement right off the bat is to allow the player to go into full screen so for now if you press f11 which is us usually the keyboard shortcut for going full screen well it doesn't work so to implement this we're going to have to use the Tori API so Tori allows you to use a JavaScript API instead of rust if you want to do things that touches the native like Windows system like the the native app system so writing to a file changing the full screen etc those are things handled by the game window itself so you have this file called T.C com. Json which handles all the permissions to what you're allowed to do all right so you have a bunch of permissions and the permissions we're going to use here we going to need to edit is two things so here in our tor.com Json go to the Tor and then allow list uh um property and then here we're going to have two things so we're going to use the fs key for file system and allow us to read a file so said this true to write a file to write to a file set also this to true and the scope so the scope is here is let me just put it scope and then I'll explain so and then add a com so what is this um later on in the project we're going to need to write the save data as the save files basically uh this is a score actually I'm going to need to write this to disk so that when the player plays again some other time we know what their best score is always and for that we need to be able to write to a file and read to a file and here the way Tori works is that you need to enable each permissions each either you enable everything by using the All property or for each of those apis you enable what you need and usually the the best practice is to always enable what you only need and the scope here is the files the folder you're going to have access to only and here we're going to need to set pass in the app local data folder and by having this notation so everything in the app data local now the app local data folder is going to be accessible to our Tori application so we're going to be able to write to any file or or yeah write to any file within that folder or read any file within that F folder and the dot star here is for that as well so here this constant or this um name comes from the Tory documentation there there are various uh constant like that and it refers to if you go on Windows and you type in run in the command start the you know the windows the search bar on Windows to the left you and you type in run and then here you type in app data and you have a local local low and roaming and if you go to the local folder this is where maybe you're not seeing it maybe I can zoom y I can see so in this local folder you're going to have a folder that is the name of your application and in that folder everything you can read and write within that folder let's replace this with kby kb. game and then if you do this if you refresh uh it's going to rebuild it here you can see that we have this if you look at the path appdata local and then kb. game was created automatically by the application when it runs for the first time or when when it is installed so here is everything we're going to write the save file here we're going to read it from here Etc hope that was clear so now yeah replace the identifier make sure everything is saved and uh the other permission we need though is for with the windows permission so window permission and the exact permission we need to be able to set this to full screen is the set full screen permission and I'm going to set this to true so now if I go go back to main.js and I go here down below we can write the logic we need to make the window Go full screen when the f11 key is pressed so I'm going to add an event listener so you can do this in two ways either you do document or add event listener or you can just call add event listener directly like that and then here a key down event we want to listen to and we need an async here because the API the Tori API is asynchronous so here we going to have an EV for the event or we could call it event if you want and then here if the event code equal equal f11 that means the key was pressed so actually here a better name would be the key and then key. code is f11 key if this is pressed we're going to have first an if statement that is going to call this API so app window and you can see here app window it's going to import it from the Tor API so click on that it should import it at the top of your file and then here what will happen is that first you check if if it's full screen so is full screen you use this this is from the API if it's if it turn out turns out to be the case then we're going to set it back to not being full screen so the F1 key uh acts usually as a toggle so we can use the set full screen F function that we allowed the permission for in t.c. Json to turn it off so with false and then we have an another if statement here actually we should return early so if I have this like that I put it within brackets and we return early and then here down below if that was not the case that means that the app window is not full screen so I can just do app window and of course don't forget to await well actually it's not necessary to await here because there we don't do anything afterwards so set full screen and then set test to true so here we needed to await so that we don't move on we don't return before we are sure that actually yeah we don't return before we are we are sure that the the app was set to full screen in this case it doesn't I don't think it really matters but here it would matter because otherwise we would return a promise and not the actual value so yep okay so let's test it out so I'm going to open the application it is here now I'm going to press f11 and we can see that it is full screen now if I put it back here it's not anymore all right so now let's actually start working on the game and we're going to create two scenes so in cap playay the way you create a scene is by calling the scene method or function and then giving it a name and then passing as the second param a function that is going to contain the logic for that scene so we going to need two scenes we going to need the first scene called start which is the menu and then the first the second scene I'm going to call it main it's going to be the actual content of the game and then I'm going to call the go function which will go to the start scene when the game starts so start function main function and and uh start scene main scene Etc so I'm going to write a new file here I'm going to call it ut. JS it's just going to contain a few utilities that are going to be used uh for now we're just going to create a function that makes the background a certain color so I'm going to call make I'm going to call it make background I'm going to pass in the K context so I don't have to import K everywhere which is the c cap playay context and then I'm going to call the add function so the way cap playay works is that you create game objects using the add function and passing it an array of components so the array of components you pass in which usually are components that are offered by kipl they will then come together to create a game object with specific behaviors and properties so here I'm going to use the rectangular component from capl I'm going to call the width method and height method so that this rectangle takes the full height and width of the canvas I'm going to set the color by using the color component of that rectangle so I'm going to set the color using the color component H for the rectangle so it's not a color component of the rectangle it's just a color component offered by kaboon that allows you to modify the color of a game object so here I'm going to call the from heex method which can be accessed like this and allows us to specify a heximal value so by default the color components takes RGB values which mean three params uh that can vary from 0 to 255 but we want a specific color and the hexa usually in pixel art or in art you use hexadecimal instead of like RGB to specify colors so that's why what I prefer to use and then finally we're going to have a last component from KL again called the fixed component which will make the actually yeah yeah which going to make the the background independent from the camera because the camera is going to follow the player but by the way I think this is useless because in a Flappy Bird Style game the main the player never moves actually they just jump and it's the platforms that moves or the obstacles that moves towards them so this component is not necessary so let's use that in our main in our first scene the start scene I'm going to just going to call it make background and pass in the K here context that comes from here now if I look at the result you can see that here we have bars here that does are the just the the black bars and then you have the appropriate color I prefer my black bars here to be black and not white so here in the body I'm just going to have a style tag we're not going to spend too much time in CSS just one thing body a selector and then set that to being background color and then black so now it will look much nicer y I think this is better so now what comes next is to actually draw the background so I'm going to create something called a map game object it's going to act as the parent of all the game objects that are props or obstacles clouds Etc they're going to be all CH children of that singular map game object so this is a feature that allows you to do is to create game objects but also to have child game objects and parent game object so here we create a parent game object like a usual game object with the add function and we pass in the following array of components we can use the Sprite component offered by Klay and then you specify the key for the Sprite Which was defined earlier on in the load Sprite function so here I'm going to have the background as the Sprite I want to use for this game object I also have access to the positional component which allows us to set the position of our game object here z z because it's the background want it to be at the origin and by the way in game development things are drawn from the top left corner uh unless you specify the center to be the origin of the Sprite or the game object and then finally I'm going to actually scale our game here so here I'm going to use a I'm going to create a constants DJs file constants count uh constants DJs I'm going to export const and I'm going to call it scale factor because the the pixel art is going to be too small so for things to be visible I'm going to have to scale things a bit now you have two options actually either let's scale it four times either you make the camera zoom in or you make the Sprites scale so either one should work so scale factor is going to be the thing I'm going to use here don't forget to import it otherwise you're going to have an error so I'm going to import import import scale factor from whoops from constants now did I get this right export yep should work okay now let's go back to main so we should have our game object it should appear on the screen and you can see that we have our background looks pretty nice now we're going to have to add the clouds and the way I'm going to go about this is I'm going to create the clouds as a child game object of the map so the way I do this is by having a call to map. add so every game object has also the add function as a method that allows you to create game objects but this time they are a children of that game object instead of a global game object and here I'm going to again have a Sprite component where the clouds and when you create a child game object what happens is that their position is relative to the parent game object which is pretty handy here however we are going to need to call the positional components so that we can have access to the position and be able to set it if you don't do that you cannot modify the position so even though I don't need to specify a value here because I just want to later on modify the cloud so they move in a certain direction uh I still need to call the Sprite uh the positional component and now the last one I think we here in Kaboom JS what's handy and allows you to get away with not using classes Etc is that each game object can have as part of their ARA of components an object which you can specify in their its properties so here I'm going to specify the speed property as being a five so it's going to be the the rate at which the clouds are going to move so here I'm going to store the reference to those clouds here because by default when you all create a game object using the ad it always returns that game object even as a child of another game object it will return the child game object object and here we have multiple clouds and not just one under the same image so that's why it's the Cloud's game object and not every individual Cloud as game object which is better for performance reasons so here what I'm going to do is I'm going to use one of the other methods that are available is the onupdate methods on every game object which runs this function every frame so usually 60 frames 60 times per second so here I'm going to use the clouds move method which is also offered by Klay on game object which allows you to just move a game object along the X and Y coordinates at a certain rate so here I can use the speed I've defined earlier on and access it like this so the game object name do the property T and then here it's going to be as the first bam that means it's going to move to along the x axis uh yeah positively so to the right and then for the y axis I don't want to change this the speed so it's going to be zero and now here right below what we're going to do is a clever trick so for now if I run this the clouds are moving to the right and then once they are fully gone to the right they'll never come back so what I'm going to do is I'm going to use a clever trick is I'm going to make sure that once the Cloud's uh position cloud. pause you can access the position this way and that's why I needed to to use the pause component if you didn't use that you wouldn't be able to access the current position so if the cloud clouds. position is uh X because it offers you both the X and Y value but we only need the x value is superior to 700 which is when when they leave the frame the the visible area of the canvas then we're just going to set back the position of along the xaxis to be of minus 500 the reason we do this is is they go all the way back to the left immediately they teleport back to the left and then they will continue their movement so basically we have infinite clouds that uh go from left to right so if I go here now here I'm not going to wait uh for this to be done but you you'll see you'll notice while playing game the final game that as the CL clouds move to the the right and they moved fully to the right so that they are no longer visible they're going to appear back from the left because they are teleported back so now the last thing we need for that scene is to add the obstacle as another game object to the map and here we're going to need the Sprite obstacles so the obstacle Sprite and I think that's it and by the way because initially we scaled the map game object the parent game object everything else the the children are also going to get Scaled by the way forgot to mention that for the last game object the obstacle game object we're going to have to specify the position as well by using the position component but not ex not necessarily passing in a value because we're going to modify this value later on and read it and here we're going to use the area component which is also offered by KL and allows you to specify a hitbox for your game object actually you know what I think it's not necessary here because the hit boox is going to be dependent on something else but for this yeah here in this case we don't need it we don't need it going to see when we're going to need it later on and uh that's it or maybe yep that's it I think that's it yeah so yeah we we don't need anything El so if I look at the app you can see so basically what we're building here in the start is the start menu basically that's it so we're going to put the the creb character here and the play button and then actually in the main is actually where we're going to write the actual Logic for jumping Etc what we're going to do now is create a player. JS file which is where we're going to write the logic for crey the main character so that uh we can reuse that in both the start scene in the menu and in the actual game so in the main C so I'm going to create a function which is going to act as the Constructor it's going to be called make player and it's going to take in the context and then here we can use the make method from capl which what it does is like the add function but the only difference between make and add is that make create the game object but does not display it on screen later on we're going to add if you create if you make an add call to a make to the result of that is going to actually create it so for now we just we're just are worrying we're just are focusing sorry with creating the game object itself so here I'm going to use the Sprite component with kby so that this is what is displayed here we're going to have an area component which defines a hitbox and can pass in an object with the shape property to specify a specific uh hitbox shape we're going to have a rectangle you can create a rectangle rectangle by using the k. rect with a capital letter in capl and the first Pam is the Y and X position relative to the the game object itself and you can have this as a vector 2 Vector 2 is just going to be in X and Y coordinates as a single data structure so here we're going to have zero for the first Pam and then 1.5 so that means the hbox is going to be placed at the position Z and 1.5 relative to the game object and then the third uh second and third param of the rect method or function is just going to be the width and the height of that rectangle so here the width and height is going to be 8 by5 so creb the character itself is 16 by 16 but by having this hitbox being 8 by five it's going to be more generous since it's a hard game and it will reduce the amount of Rage that the player will experience and then be by default I said earlier on that in C play or in Game Dev in general things are drawn from the top left corner but in this case it would be better for things to be so the the player game object to be drawn from the center and you can specify this by using the anchor component offered by Kay and passing in Center here as the string to use this you need to have the area component defined otherwise you're going to get an error and then finally going to scale the character as well the this game object like we did with the other one and this is where we can use our constant again here and then finally going to have an object here which is going to contain properties and methods that are useful for the player so here I'm going to have first an is dead is dead Boolean initially false which going we're going to use here to know when to display the scoreboard and when to restart the game and then the speed is going to be 600 which is the value that felt nice I'm going to have a key controllers array here which is going to hold event listeners to the various input controls we're going to Define and the reason we're doing this is because when the player dies we want to cancel all those controllers and by having them in an array and then iterating through them can disable the player control so that the player can no longer move once they die all right so now let's create our first method which is going to be the set controls method here U this is arbitrary and by the way if you're not familiar with this notation is equivalent to having this like that which you might be more familiar with so this method I'm going to call it set controls its goal as its name suggests is to set the controls this is not from Kay this is just a name I've decided to call this function I'm going to call it later on so here I'm going to store the jump logic I'm going to write into a simple small function so because it's a really a small function by convention I'm going to use the convention that if it's a reusable piece of log that you're not going to use elsewhere I'm just going to use this notation for the function and otherwise I use the function keyword this is a personal preference and you you can feel free to do what you want and here we're going to play the sound so here in main.js we imported the sounds for the various situations so when the player jump or gets hurt and here when we set the control when the player jumps we want to play the jump sound which we can use the key here of if you remember main. J the jump sound is here and uh yeah to play a sound you call the play Method from the C playay uh context and then here I'm going to use this. jump and this might be confusing where does this and jump comes from and why comma here so that's a mistake on my part so this can be used to refer to the whole game object so when you create methods within this object here you have access to the ual all all of the game object which is pretty handy that means that this refers to the game object itself now jump here is offered by capl it allows you to automatically Implement jumping and I realized I forgot to add the body components so this jump method comes from the fact that we used the jump the body component which we didn't so now it's time to add it so the body component allows us to make our game object um susceptible to gravity and also allows us to uh have the jump method so which implements jumping automatically for us you can modify various properties either within here the jump or within the body component itself here I'm going to set the jump Force to being 600 and there's the mass that you can modify Etc by the way go to the kj.com go to kls.com which is the where you're going to find the document ation for K so we have jump Force everything is fine and then let's actually Implement our jumping so here I'm going to use this. key controllers and I'm going to push to it the various uh event listeners we're going to create so here we have access to the following so this on key press well actually you can use a global K on key press and I don't remember why I did this this way but I think it's more performant to actually I don't see any reason to to use this here so use K here and then on key press which is offered by K play you can have an example here you pass as the first Pam the key you want to use and the second param is the function that is going to run when this is pressed there is another way of doing it where you only have one Pam and you have the key param here is going to give you every key which is a more handy way and better way to do it but in because in this project we only have one input really then this way is fine watch my previous Adventure platformer tutorial to know how to use more advanced feature of Klay it was called Kaboom then but everything is applicable the same yeah the same knowledge basically so here space and then we're going to call the jump logic so we're going to pass the function here so this this is going to result in an event listener controller and this controller is when space key runs it uses it runs it fires off the Jump logic function now as I said in the beginning of the the tutorial we will have more than one input method the other one is the click so this this um key controllers push maybe key controllers is not the the the right word here maybe I should call it input control input controllers would be a better name because it's not only for keys in the keyboard so here we can use the onclick method from C play and you can just pass in the jump logic here it's going to fire the function you pass in when the player klicks and then finally I'm going to push the the one for the game pad so for Gamepad you have K playay offers you the on game what's the name on Gamepad button press on Gamepad button press and then you specify the South as I've explained earlier you're on South come from the fact that if you look at the controller this button is to the South basically and now here the second param is the actual logic so jump logic that is going to fire off all right now we're almost done I'm going to call up the set controls here I'm going to call the disable controls which is going to be called not not dispat Advance disable controls which is a method I created I decided to create those function it it's not from K just making making sure that you understand that here disable here disable controls what it's going to do is just going to iterate through the key controllers actually now it's called input input controllers and then for each uh you could use a more performant for Loop but it it's only three elements so it's not that useful so key controllers and then arrow and then key actually key controller for each key controller it's going to we're going to call the cancel method which is available on each of those controls so if you look at the documentation I click on e h oops ah there's no intellisense it seems anyway these return these calls return in event controller all right so now in main.js I'm going going to right below here let's add the player so const player and then we're going to call the add function and within we're going to call the make player function that we defined earlier on that now should be imported from the play.js file here so now what I'm going to do here is remove uh first pass in the K here the context so that we can have access to the various Kaboom methods and then in here you can modify the position like this and as a vector 2 like that so you can use the vector 2 method to create a vector two on the Fly and then here we're going to put it at the following coordinates so I'm going to copy and paste this because it's not really that relevant I'm just going to explain one thing here so here k. Center gives you the center position and you have access to the X and Y coordinates of it and here we just make our creb character relative to the center position by a few given offsets here this is what looked good so if I look at the result it's here wait a minute so something went wrong I'm just GNA do F12 and here I have the let's go to the console and then the body require okay we didn't use the positional component so I forgot to add this to our def definition of the player so now if I run this again you can see that the crey character is here which is what we want actually by the way and now the last thing we have for this start menu scene is the start button and when it is clicked or when the player presses enter or when the player presses the South button on the game pad we should start the game so here in main.js we're going to have to create a play button so here we're going to do it the same way so I'm going to create a constant called play button I'm going to create a game object out of it and here there's no new Concepts so I'm going to copy and paste the code feel free to pause there's actually there's one New Concept is the radius so when using creating a rectangle by the way don't this is the rectangle component creates a visible rectangle do not um confuse this with the hit but k. rect this is not a component this is just creating a rectangle hitbox so there's a difference between the two so once when you want to create a rectangle that is visible you use the rect component from kipa when you want to create a rectangular hit boox in the shape use the k. rect here all right so radius of three so it's well rounded and then here we're going to add a child to the play button so right below here and it's going to use a new component that you not familiar with if you haven't used K playay before it's the text component it takes as the first Pam the text you actually want to display and the second param can take the size the font Etc here we just want the size so the size is going to be 24 with a this given color so it's a darkish color which follows the palette I used for the assets all right so now everything should be here should be fine let's look at the result we have the play button but if we click nothing happens if we press space nothing happens so here I'm going to use the same pattern we used in the for the um set controls for the player so I'm going to copy and paste create a disposable I guess small reusable piece of logic function here using this convention it will play the confirm sound and then go to main main is the other scene which is actual game and then we hook this up to the various input methods so on click on key press on game button press all right so now it's time to write the logic for the actual game here I'm going to create a constant I'm going to call it score it's going to be initially have zero so Y and by the way one thing is we're going to implement the save system right now actually instead of writing logic here in our start scene so let me just collapse it just to have a clearer picture so yeah I'm writing in a very big font so that you can be like really see the code but it's kind of inconvenient so we're going to have to Define our save system so I'm going to create a file called save dogs which I'm going to write the logic for that how we're going to go about save saving our score so the pattern I used for this is something very simple what I do is I create a function called make save system it takes a save file name you want to use for the game and then within it returns a an object this object has a first a data property which contains the data we're going to SA save it's going to contain an async method called save it's going to contain another async method that is going to be load the reason those are in async is because we're going to call the Tory API within and the Tory API is a synchronous so here in our save function what we're going to do is we're going to call the right text file method from or function from the Tori API this is something from Tori it takes three params it takes the save file name so actual name the the path or actually the yeah the save file name not the path and then here actually it's two yeah three the content and then the sorry so it takes the the name of the file the content which is just going to be a Json stringify so we're going to convert our data here so we can use this. data into text and then it the final one is going to be the base directory so the D deer it's an object that you need to specify the base directory and then app local data this is how going to be able to write the data here to the save file name which is going to be save. Jon and along the base directory app local data if you weren to not use this it wouldn't allow it and here base directory is imported from here it's a an enom and app local data is basically like the the thing the folder I've shown you earlier on all right that's it that's how you write to a file and if the file didn't exist before it's just going to create it and if it already existed it's going to override it so you might need to append in certain situation but for our project we can just overwrite when the score that the player has acquired in the current game is higher than what was written on disk and then the load function here is we're going to have a try catch because we might attempt to try to read a file that doesn't exist especially when the player first opened the game the goal of this is that we will store into the data property that we created here the the actual data so J from the the file so we going to use Json parse which is going to parse the text uh the string that we stored inside of our save. Json file so here we're going to call the await read text file API from Tori pass in the say file name and then the second param is just a deer so deer directory base directory and then app local data and then if for some reason it's not possible and this occurs when the file doesn't exist and it happens when the player first install install the game for the first time or they installed the game in the past uninstall it and then removed the save file from the local folder then what we're going to do in this case we're just going to set the data property from within the game to an empty object and then when we're going to save we just going to write to a new file to the to the file basically to a new file because it didn't exist all right we have everything we go here uh we want here so now we're just going to EXP Port our safe system so I'm going to have a constant call it safe system which is going to be we're going to call the make safe system and we're going to pass in that we want to store this in save. Json so when the player opens up the game they go to the start scene and at the end of the start scene we're going to call our save system this should be imported from our our file just to make sure save system has been imported and then here what we're going to do is we have save system and then we're going to load so initially if the file didn't exist then we're going to have an if statement which is going to make sure that if the save system dot um data Max score which is a property that doesn't exist yet um by the way the it doesn't exist yet so I'm I'm assuming like we have the the the player they open up the game for the first time that means there's no data so we load the data from our safe system and this is called going to go into the try catch is going to be catched because it doesn't exist you cannot read a file that does not exist that means that this the data is going to be set to basically the the default so when we arrive here for the first time after having loaded the the the data then the max score property doesn't exist and this is where we're going to actually set it so save system. data. Max score we're going to initially set it to zero then we're going to save that data that we just wrote Into the data object to disk by calling the save method and then reloading it to actually this is not necessary to reload it here but because we just write the same thing and then we we don't need to reload it so I'm going to not need that so here we go and uh the reason I'm doing this is just to make sure that if the player opens up the game for the first time we have actually a Max score property that is created in that save. Json file all right so now let's write the meat of the game which is the main scene here I'm going to have a variable I'm going to call it score which is going to increment as the player is surviving and avoiding the obstacles now the next thing I want to do is I'm going to import the colliders data so I'm going to use an await and then an await and then fetch and then the reason I'm doing this is to fetch this colliders data so here I'm just going to do. colliders data. Json and then once you receive once you receive a response here you need to await the response and then you need to await again while it is converted to Json usually people do this in two calls they first store this into a response constant and then call Json on it but I prefer to have it on one line here for con for conciseness and then here I'm going to create colliders data and it's going to be the colliders object. data and the reason it's do data is that if you look at the colliders data Json it's a data property with an array and we were only interested in the array so that's why I'm storing it as its own uh constant and then I'm going to call make Background by the way this should probably be called call at the top the first thing we want to do because the background we set here is is dependent on each scene so you cannot have a global background that you can set but actually you could you can use the set background but the issue with the set background is doesn't respect the aspect ratio the letter box that means that if you call this method from KL it's going to color even in the the place where it shouldn't be like the black bars so it doesn't in respect the aspect ratio all right so we have the make background here and yep so now what comes next is we're going to use set gravity so that the player is going to be affected by gravity the value the G value that was uh that felt nice was 20 2,500 uh set gravity is a method from Kay so yeah by the way if you see still Kaboom context here it's because it was previously called Kaboom all right and then here the logic is going to be very similar to what we had initially I could have abstracted this into a function by the way I noticed something is I called this map you could have called it level and then later on in my or source code on GitHub I used level here which is inconsistent and I should probably do better so I'm going to just copy and paste here so this first part and just for the sake of consistency let's use map everywhere because it's the same logic copy and paste it basically so here you could create a function that takes care of all of this uh I'm not going to do this just to go faster because the the the main draw of this tutorial is really to teach you how to have this all as a desktop app not necessarily the game itself if you're interested in more like code organization and tutorials where I take care more of that you can see my other tuto watch my other tutorials so here we have okay so I replaced it with map and then here for we going to have the platforms like we did initially here and instead of level it's going to be map and then here it's the different logic so actually never mind uh yeah yeah this is a different logic so here we also had the platforms if you go to the logic we had for the start menu we had clouds we had actually yeah we had the platforms here but now we need to actually do something with the platforms that's why I store them inside their own constant and then here below we're going to use the on update on update methods that is called every frame and here I'm going to make all the platforms move by the way the platforms are just a single Big Image so it can be treated as a single entity it's not multiple Sprites so here the move function we're going to move to the speed platforms. speed here and then zero and and then here is going to be something else so we're going to use the same logic that we used for the clouds so we're going to have as long as the position is inferior to certain value well as soon as the the platform's position is inferior to a certain value we're going to replace the platforms to being to the right and then we progressively increas the speed so that it is a challenge for the player so here's the comment I left here by the way the source code is available on GitHub might be a slightly different from what I'm writing here but you can use it as a reference and then here we have this now and we can have the loop method something from K so every second it's going to fire run the function past as a second peram and here we're just going to increment the score by one simple way to uh calculate the score and then here is where we're going to have add the hitbox to all the platforms or the obstacles maybe obstacles would have been a better name since it's the the name of the Sprites here but initially I wanted to make a Kirby like and then teach you how to use Tory but I thought would be like too complicated and it's better to isolate and do something simple that so that you can be familiar with how to make like desktop games all right so here we as I said our obstacles are a single image and by using the collider's data we're going to know where to draw the hitbox for each of those obstacles within that image so we're going to create child game objects of the platform's game object so here for going to use a for Loop or const collider of colliders data we're GNA add for each of them to the platforms game object we're gonna add so the platforms is a child of the map and every collider here is going to be a child of the platform so that their position is relative to the platform the obstacle image that means when this image moves the all the colliders are going to move at the same time without any extra logic from our part and then here uh it's the same thing so I'm just going to copy and paste actually there's one thing different is static so here we create a hitbox with a rectangle with a collider width and collider height this comes from the Json file which has these these values we place the X the position X and Y this is going to be relative to the platform the obstacle image which is what we want and then here the body by calling the is stat by setting the is static property to being true what will happen happen is it's going to be solid so that our player cannot pass through and it's going to act as obstacles all right now we're going to need to create two other game objects that are going to sit at the top and bottom of the screen and those two game objects outside of the for Loop but still in the main scene are going to act as walls up and above so here it's the width the rectangle is going to be the width of the whole screen one is going to be placed at the top of the screen but not visible and the other as well and we don't need them to be fixed since we're not going to modify their position the player positions play the player position isn't moving at all anyway oh by the way never mind I think it uh actually might might need this anyway let's keep it for now and then going to remove it if it's not necessary I'm think thinking of an edge case but it might not be actually a case all right so now if I look at the result you can see that we have nothing for now and but the the platforms are slightly increasing in speed so now let's call our player so const player make player pass in the K and then right below player position the position that sounded nice looked nice was 600 by 250 we're going to set the player control so that the player can start start moving and then we're going to have going to use Cap's On Collide logic so when this on Collide method available on game object is that when the player on collides with this so by the way I forgot to explain what is this this is a tag you can set it so that you can use them later on in on Collide calls to know to check for collisions so here on Collide when the player on collides with the tag here the tag here is going to be the obstacle obstacle so every game object that has this tag is concerned by this uh this um method that is going to is going to fire so basically when the player collides with the obstacle this runs what will run here is first we check if the player is not already dead so player is dead make sure that this is if it's true that means we don't run the logic that comes afterwards and then we play the her sound then we set the platform's speed to being zero and because of that because we set the platform I don't think fixed is necessary because the player is not moving so the camera is not moving at all so let's set it to like that so platform speed is going to be set to zero then we're going to disable the player controls so disable controls of the player and then here I'm going to have to do and create score box and then set player is dead true so let's play our game okay where's the player by the way you can use the F1 key to open the debug mode oh I think I know because we called the make player we didn't add it to the screen so you need to call it within a add because make player uses the make function which creates the game object but doesn't actually added to the scene so now it should work so if I go here here we go go we have our game so let's uh on purpose hit and then nothing happens okay now if I refresh again using F5 and I go to the top yeah so those walls that are not visible are here to prevent the player from going out of bounds so yep and here where are there yep so those are the the walls those two game objects here okay so the last part is really to create the scoreboard so I'm going to the scorebox not board well it could be a board scored box. JS so here we're going to have an export function and then make score box takes the context K but it's going to also take a position I think yep it's going to take a position which is going to be a vector 2 which going to have X and Y coordinates and that's it and oh of course one last thing is the actual current score and now here we're going to use the save system and we want it want to load from the file the save system because we're going to have to compare to the actual uh Max score so making sure to read the file that we have saved so that we can do the comparison here here so if the score is superior the current score is superior to the save system. data do Max score Max score if that's the case then we're going to put it in the save system Max score the new score the new maximum score and then we're going to call await and then save system and here is actually where we do the saving so we can call it save by the way this should be a sync so we can use a away and this is the actual thing that writes to dis so maybe I should have call it save system. write and read but I think load and save are pretty understandable terms so now let's create our box and here I'm going to use the make function as well so here the make function and the reason I want this fixed though is yeah because here it's important to have it fixed independent from the camera camera because depending on where the player is on but actually never mind the camera shouldn't even be moved in the first place so there's no need for that so here nothing new uh except for the outline component which creates an outline and we can give it a particular color as the second param this is going to be the outermost container and then I'm going to add as child game object the various text we need so this is something I'm going to just copy and paste because it's tedious to write here we go uh let me just go up so you can copy so this is the previous best score text which we take from the Save system and a given position Etc here same thing for the current score and then current rank which actually we didn't write the compute rank method function so yeah let's just copy this for now those two hit pause and maybe like that can see everything now I'm going to go in utils and the rank compute rank is just going to give a rank depending on the score value so here export function compute rank in utils and then you pass in the score and then depending on the score we're just going to give it a letter based grade so the rank and here I'm just going to copy and paste the logic just a bunch of if statements maybe you should have used them maybe I should have used a switch case here but yeah so if the score is superior to 30 S rank Superior to 20 a rank Superior to 10 B rank Superior to two c Rank and D if you have zero one or zero and and that's it so now if I go back to the scoreboard uh scorebox let's import the compute rank import compute Rank and uh yep so now it should compute it so if I play the game uh by the way I did not call this score boards but but we haven't finish who haven't finished we need to do the following we need to create the restart button and the same logic for the restart button and then return the container which is the whole parent of the box so here we have this restart button that as a child of the container as well which is going to be a rectangle with this color and then it's going to be uh drawn from the center nothing new here no new Concepts and then here as a child of the restart button going to have the text play again again with the following size Etc and then here I should have followed this is just a real reusable piece of logic that isn't used elsewhere actually it is used elsewhere it's not the first time that we have something like that uh but I think it was a different every case right here it's jump logic and I think it was used where it was used it was used here right go to game so maybe this should go so we have this here let's take this let's go to utils Let's create another utils let's write it as a proper function well well they're both proper function I mean like with a function syntax let's go back to main let's just ah the issue now is that we need need to use an arrow here and then call and passing the K and then an arrow here and then pass in K and then an arrow here and then pass in K because we don't want the function to be called immediately if you were to pass it and it would be called with the parenthesis it would call it immediately but we still need to pass the context so that we need to wrap it inside of an aror function definition so that's that and then the above let's go to U Tails here and add it go to game that means in our score box I can just remove that I can go above I can import it go to G here we go and uh here we go so we have the on click Etc so on key press the various inputs this again again could be abstracted away but I want to keep things simple for this project and then finally we return the container which contains everything so the whole score box and then in main.js if I scroll down in the todo we're going to call k. add score make scorebox pass in the context pass in the following position I don't remember the actual position I used at the end of the day we just pass in the center k. Center here position which is well I should have probably hardcoded it here in scorebox if it's the center but imagine in a future use case where we want to display more components like that score box at in various different places so it doesn't hurt I guess and then finally has this third peram the score that we had in Main and here we had to find it above here in our main scene all right so that's basically it and uh now I think our game is done yeah I think our game is done uh so let me check okay we have a mistake uh does not provide a goto games core box just utils does not pro if I go to utils go to game and then if I go to the score box ah okay because we need to wrap it under a arrow function I'm just going to copy and paste this save all right now things should work um yeah so I didn't read the the proper error message so what's the issue syntax error the requested module source u.j does not provide an export name go to game is that true yes export sorry I missed I missed that now if I go here we have our game and then let's die and okay what what's what is that W trigger is not a function what do you mean uh okay I made a mistake somewhere oh I know why if I go back to main here remember this was an await here we return a promise so it's trying to add a promise as a game object doesn't work like that so we need to use a wait here uh okay wait a minute only allowed within a sync function but this needs to be a sync so the scene itself needs to be a sync uh not not the same the um the UN Collide call back so that means we don't need to have here as a oh we need because we need we needed to make a fetch call to the Json file which contains the collider data all right so I think that's it previous best score three current score one previous best rank C so let's try beating our score here we go we have CC as the rank okay let's try let's try for 20 at the same time we're we're going to test a few things so all right 15 current rank B so next time if I die here previous best score 10 ah okay it's not doing it right that's probably due to the fact that I here I did not load it in the main in the start sorry scene if I go to where I set up the safe system I did not load the safe system here I need to load here as well now the last part of the tutorial H it's basically getting the executables getting ready to distribute the project so I'm going to close the project and then you're going to write npm run build so now it's going to build the project it's going to compile and this is going to take a maybe a lot of time at first when you do it for the first time it's the first time building the project so let's wait all right it's almost done compiling and as I said this compilation step takes a lot of time the first time you do it but then uh it's relatively quick afterwards so now there's only one thing left and here we go running and then producing the MSI which is what is useful to distribute all right the project has been built after a long time now to get the executable you can go here to source. tari Target and release and then in bundle this is what you want to distribute either the MSI or the the NIS so either one of those two should be fine the reason I want you to distribute these instead of the C kirby.exe file is that this these are installers and if you uh if the player is is either playing on an older machine and doesn't have the web view2 system installed on their machine then the installer is going to take care of installing it for them all right uh so yeah just distribute that on h. or steam either one of them and that's it this is how you make a desktop game in JavaScript all right thanks for watching I hope this tutorial was useful for you and yep that's it uh feel free to subscribe for more JavaScript Game Dev related content bye I forgot to mention something very important in the project is that if you want your um executable so once uh the Tor app is installed so when the your game is installed on the user machine if they hover over it and this short description property is not defined is is going to display a Tory app and I would assume you want a description of your project to appear and not a Tori app so to have this description you need to go to tori. conf. Json and then under the bundle add the short description and your description here so that's all