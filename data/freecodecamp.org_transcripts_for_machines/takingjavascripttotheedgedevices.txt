today i want to talk to you about taking javascript to the edge um so the vast amount of choices that we have in modern iot is is crazy compared to what we might have had five ten years ago you know you've got choices of devices hardware attachments you've got languages deployment mechanism different different deployment mechanisms and frameworks and i'm going to try and demonstrate all of the different options that you do have and how we can then use these to deploy javascript to edge devices so choices firstly you need to decide which device are you going to run your code on now in the past you may have only had the option of a for a few small system on chips or a couple of microcontrollers you might have had a very restrictive set of development and debugging tools you know maybe the only one on windows os x or linux architecture you might not be able to control that just whatever you had at the time fortunately this isn't the case anymore so here is a subset of single board computers that resin currently supports you can use any of these in any project that you'd like we've got the raspberry pi and the raspberry pi zero these have got um different architectures different clock speeds different price points and basically you pick what works best for you um you know you've got the raspberry pi's they've got usb they've got hmi everything you'd expect we've got the intel nook these are x86 they've got all of the io that you'd expect on a normal computer albeit less we have the nvidia tx1 and they've also got the tx2 these are designed for doing machine learning at the edge you've got the raspberry pi costing about 30 pounds the pi zero costing around 10 pounds the tx2 costing around 300 400 pounds so again it depends what you're after and what you're looking for but the point being you've got a choice for what works best for you so this gives you a blank canvas on which to build and maybe if you chose the raspberry pi you have your device is designed to have some swappable hardware or hats oh additional hardware so we've got hats for the raspberry pi which stands for hardware attached on top love the name by the way on the left we've got the sense hat this was designed for the astro pi project which aimed at getting contributors code in out of space and this actually this this hat was sent to the international space station with some code by members of the public we've got a speaker hat this means that if you want your device to be able to make noise player music that kind of thing that's easy put it straight on the gpu gpio header we've got a motor controller that means any dc motor you can supply some power and then use the raspberry pi to control those motors we've even got a high def touch screen that you can put onto something in the size the palm of your hand so these are examples of different kind of inputs and outputs that you can very easily add to your iot project with the minimal of installation and set up and often there's libraries already available everything's ready to go so you've chosen your device you've chosen the additional hardware that you want to add on all of your sensors all of your output mechanisms that kind of thing now how are you going to deploy that code to your device so with modern iot deployment there wasn't really that much option that many options so being from risen i'm going to talk about how we have enabled iot projects to deploy their code to their devices containers containers are great so containers are a way of packaging up all of your code and your dependencies and putting them into an environment which when you run them will be exactly the same you can make sure that your target can download can run can clean up after your code without knowing a single thing about your application itself these containers are created from images which are a set of layers building on top of one another to define the environment in which your code should run so i'm going to talk a little bit about how we make those images and then how we get those onto devices so images set of layers just like this rock balancing thankfully it's a bit easier than that so you start out with what's known as a from line so sorry this is a dockerfile and a dockerfile you use to define the image that you want to build they have a set of commands each one being a line and each command in the dockerfile will produce a new image which is the image before it plus whatever additions that command has added so generally the first command that you add is a front line what this says is use an existing image as a base on which to work from and this is known as a base image as you might imagine so what we're saying here is take the image resin slash raspberry high 3 node and build upon it now this image was created by resin to run on the raspberry pi um it's a debian environment it has node preinstalled uh npm preinstalled and it's the bare minimum that you need to deploy a javascript application next we've got a run command so this run command what this says is take my base image run aptget update so run the debian package manager and decide what packages are available and then we're going to install curl and also let's say that these are dependencies of your application you know maybe you're going to do some downloading of music and then playing it so what we've done here is we've taken the base image we've added another layer which says i've got the debian base image with curl and ulcer on top and that's it so what we need to do next is copy our application our application source code into our image so we've used the workdir command what that is is it says every command that i run from this point on should be in the working directory and in this case i've chosen usr source app you can think of this as equivalent to doing cd usr source app in your shell and then running some commands it's running in that directory after that i've taken a copy command and this copy command says in the current directory there is a directory called source in that directory there's my source files i want to take those source files and add them to the working directory of this image so each line is creating a new image the uh the workday line would create an image that's got the debian node image it's got curl and elsa it's got some metadata let's say that the working directory of this image is usr source app and then there's another image that is built on top of that which says all of my source code is in that working directory so now we need to define which code is going to be run when um when we when we turn this image into a container for this we use the cmd command cmd command says when we take this image and convert it into a container what should happen when we start that container what what should be done so this says i've got an image when this image is turned into a container and it's run it should take the app.js file that we added in the previous copy step and it should run it with node so simple as that okay so we've got an image how would we then deploy it to our device i'm going to kind of rush through this a little bit because i'm not talking about resin i'm talking about javascript so you would create a application on the resin dashboard and download the resinos image for your device resinos is an operating system that we've created specifically for devices which have a thin host os they run exactly what you need and nothing more and your user container will go on top of that and that's all you need that's resonators it will connect to our dashboard and handle all of that so this is this would be how you do that but that's irrelevant you would install a resin cli again if you want more information on this we can look at the documentation but in general you just install the resin cli you do a resin login which would take your application your user account and associated with your local instance of resin cli now here comes the magic so we would use resin push so you would do resin push and then whatever your application name is this would take your current directory which includes your docker file it includes your source code it would package it up and it would send it away to our cloud build servers our cloud build servers come in different architectures we've got x86 we've got arch 64 we've got arm v7 anything anything that you can deploy to we've got a native cloud builder ready there to build your code into an image so you've sent your code to our builders it's built successfully hopefully and this then gets sent to what's called a registry the registry is a a server in the cloud that holds a lot of images and you ask for an image by name it checks if you have access and you download it so we've got that and it's been installed but why why would we want containers why are containers a good thing for iot deployment now at first thought at first glance it might seem you know we've done a lot of all this work but what has it given us why why is this something that we want to do so let's talk about the benefits of containerbased deployment in an iot setting isolation so the first isolation so when you're writing code for an iot device often it can be a lot more complex than your typical desktop application you know often you need to have a lot closer to the host operating system you know a lot closer to the hardware on the device on which you're running you might need to interface with the networking or again specific hardware isolation allows you to draw a line around your user application and say this is allowed to do this specific set of circ of tasks if something goes wrong in those tasks we get rid of that container and we start again what that means is your host operating system cannot be affected with a container that's acting badly unless you've configured seriously wrong what this means in the iot setting is you don't brick devices so if you imagine you've deployed an iot device to something in the middle of the sea you know in the middle of atlantic ocean if that device suddenly goes offline there is nothing you can do other than send somebody to go and either fix it or recover it and that's not an easy task if we use containers and something goes wrong we tear down that container and we start again and the device is fine it's pristine reproducibility so when you're using containers you have an environment in which your code runs and that environment is the same on your device it's the same on your local dev environment it's the same on your testing infrastructure it's the same everywhere so if you discover a book in your code you can reproduce that bug locally and fix it locally and in the setting of iot security is a massive thing these devices are in people's homes they're running machines they're everywhere security is a big thing if you see a security problem you need to fix that security problem then and there and being able to reproduce and fix locally is is brilliant application delivery i think personally is the most important part of using containers for iot so for a typical iot for a typical desktop application you've got several different methods of deploying it you've got auto updaters you've got web apps you've got add a push you've got ftp if you need to but if you have an iot project and that device is not on the same local network that you are your options are pretty limited we need some way of telling the device that the update is ready we need some way of the device downloading the application without knowing anything about the application itself and we need a method of tearing down that application should something go wrong now docker containers enable you to get all of these things for free this is what docker was designed for and this is what docker does very very well also if you have a container and you push an update you've got a device out in the field that's got a 2g connection we're talking you know two three kilobytes a second what you can do is say okay i have this container and i need to move to this container we can work out what the difference between these containers is we call it a delta just download that delta on the device and apply it to the container that the device has this means we move from container a to container b with the absolute bare minimum of data transferred so we've chosen our device we've chosen our additional hardware we've chosen our deployment mechanism now we need to choose our software stack and we're at a javascript meetup so let's assume that we all want to use javascript because we all know and love it hopefully so why would we want to use javascript at the edge that's an interesting question there are a lot of programmers that know javascript using the stack overflow developer survey from 2018 70 of respondents use uh javascript 17 to use typescript which is a superset of javascript and whilst it is typically being a language to use to create web applications in recent years it's definitely proved itself to be an extremely competent and useful general purpose library allowing javascript to be run at the edge means that we can take all of this knowledge in which 70 of programmers are already familiar with and apply it to a complete whole new set of problems we have a gigantic existing ecosystem of packages for javascript i took this graph from modulecounts.com today we've got you know a lot of popular package managers at the bottom and then far and away at the top we've got mpm with what is it 500 000 packages at the start of september and now in july at 450 plus packages a day it's it's got a lot the beauty of this is that these can be used in an iot setting with zero changes in general normally so the next point doesn't just apply to javascript but applies to higher level and more modern languages in general so in the past for embedded devices it would have initially it would have been originally written in c or c plus plus or add a push even assembly you know partially this would be this was because we'd need to squeeze every single cpu cycle or every single byte out of memory now we've got single board computers which run at gigahertz they've got gigs of ram this just isn't that much of a problem anymore and programmers will prefer to use prefer to use languages that aid maintainability and ease of use ease of debugging rather than getting that raw performance and i think that's why javascript has been used on the edge so much already and why i think it will continue to do so so what does javascript at the edge actually look like surely it's got to be different hopefully not it should be exactly the same because it's javascript it runs on the node engine it has the same data models it has the same behavior so you can write code for the node engine on your desktop and it should behave exactly the same to code that you run on your device ignoring any hardware differences you know maybe you're simulating some hardware your test suite should be just as effective when you've run it locally to when you've run it on your device and your node modules should be installable both locally and both on your device and they will exactly behave in exactly the same way so i want to show you what how well javascript can lend itself to edge programming so this snippet of code is from a node library created by resin to interface with the sensor that i was talking about earlier it takes a handle the led matrix chooses an xoi sets pixel pretty standard javascript we've all seen this it's pretty standard this it's not special in any way you would you wouldn't be surprised if you see this on some web application it doesn't change at all so what about using the sensors because the sensor has a lot of sensors what surely it's going to be a bit hard to use them nope we've got exactly the same javascript that you'd find in any other web application it's pretty standard you could create a handle for the imu also known as the inertial measurement unit request the sensor data and provide a callback again standard javascript you'd see this anywhere this is typical doing something extremely nontypical for javascript and it just works it does exactly what it's supposed to do we've got the same javascript objects that pass through json.stringify we've got the same error handling as a normal node cord callback would it just works even hardware events are made extremely easy so i'm sure everyone's familiar with a javascript event emitter but so what what you would do in this case you would ask for a handle to the joystick you would set up callbacks for joystick events so in this case we've got press release and hold and this is again very very typical javascript and this is running on a device out on the edge so we've chosen our device we've chosen our additional hardware deployment mechanism we've chosen our software stack the only thing left to do is for you guys to write some code so one of the beautiful things about containers is you often make a distinction between application state and application data anything that needs to be kept should go in application data and how we actually do that at resin is what's known as docker volumes and these are just segmented parts of the file system which can hold data application state on the other hand would be lost so you would design your program in a way that if it needs to recover and go back to a certain point you would read application data now this is nice because it means that if you have a bug in your code that would change your application state in a weird way if you tear it down and bring it back again and it works going from data to state then it should work fine this was a javascript at the edge and i hope it was very informative