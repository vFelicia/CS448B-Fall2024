so hi i'm daniel lemay i am a developer at phase 2 technology and i am here to talk to you about graphql and how it can help improve your apis and as well as make them more discoverable and a joy to use to your frontend developers out of curiosity who has heard of graphql most everyone who's actually used it even tinkering so about half of the people have heard about it all right so i know when i first got into graphql and started looking to it like it was seemed like this big ominous scary thing and a lot of people that i've talked to of like oh graphql that's like really complicated like i don't know if i can get into it well it's not so i'm hope to kind of give an introductory overview of what it is and what some of the problems that it solves are and give you some tools to get started with it if that's something that you're interested in so first i want to talk about something that i don't think we always keep in mind and that's latency because a lot of us as developers were on really good internet speeds we've got either on a wired connection or really good wireless so here's just some average latencies um so average latency this is just to get your network request going wired connection 0.3 milliseconds it's pretty darn fast wifi connection three milliseconds we're already in order of magnitude higher 4g which we've got pretty good 4g coverage especially if you're in good metropolitan areas now we're already at 64 milliseconds 3g we're up to milliseconds now as we develop more mobile first and keeping in mind the international market like we need to keep this in mind and it's something that can be really easily overlooked because hey it runs fast for me but a lot of people are consuming things on their phones they're nowhere near even your even your wifi connection so russ has this good thing and this bad problem that comes with so here's a sample api request response from the yelp api this is all of the data that gives me for one singular business it's a lot which is exactly how rest is designed you give me this endpoint i'll give you all the details about this business or hit this endpoint and i'll give you an array of businesses that meet meet this category like that's exactly what rest is supposed to do problem again keeping in mind mobile is this is a lot of over fetching like you have a seriously increased payload and it only further exacerbates itself when i now need to take some of this data and make another api call so i have to wait for this data to get back fine pull out that piece of data make another api call still having that latency effect sometimes you get two three round trips like it can can really start to bog things down and if i'm looking at that api as a frontend developer because i do most of my work as frontend like it just gives me a giant migraine so here's a sample api structure for a really basic block so i've got users who can create blogs so i i have the a user api endpoint this is obviously somewhat contrived like i'm not trying to build the most robust api example in the world uh so slash user gives me the user object which also has an array of posts that they've created and we have posts which returns me all of the posts that they've created i'm sure we can add some imagination in there to make it more efficient and then post will give me all the data for just a specific post so let's say i want to create an index of said posts i'd probably hit the user api get the array of posts or get their id then hit the posts api with their user id to get all of their posts everything all i really care about is the title the slug maybe an excerpt like i don't need all of that data but i'm going to get it because that's what rest does it gives it to you whether you like it or not so that's where graphql comes in so according to graphql.org that's the specification graphql is a query language for apis and a runtime for fulfilling those queries with your existing data so a couple things that graphql is not it is not a framework is not language specific you can integrate it with most major programming languages and i have a link in the resources slide at the end that you can say oh i want to build a front end i want to build a back end here's the language it'll give you all the libraries that you can use so graphql is a specification it was written by facebook to fulfill their increasing graph data needs and all these interconnected queries and to find a more efficient way to get the data that they need so graphql.org you can find the actual specification there and then there's multiple frameworks that have built up several layers of abstraction to make it a whole lot easier to use so key things first what problems does graphql solve and have huge impacts on your performance so you decrease your payload size because you're only getting the data that you need and it reduces the number of round trips because i'm no longer waiting for data to come back on the client and then making another request i'm getting all of the data that i need back in the single request all of the fetching and all the looping is handled on the server it increases developer experience through automatic documented apis which is amazing who here has tried to use a horribly documented api yeah that's no fun or the documentation is out of date or something's changed nonexistent even better yeah just just great fun throwing the computer out the window so graphql includes amazing documentation out of the box and updates as you build your api you're no longer relying on someone to maintain documentation using a system like swagger to document your api it's just included and that's because of how it's set up it also has deep integration with modern front end javascript so react view all of the modern frameworks i think angular also has some plugins for it which include caching which reduces their need to even fetch data from the back end which again further increases performance so how do we do this so graphql creates a declarative data structure so you declare all of the different fields that your data structure has and what types they are so if you aren't familiar with type systems like this is this is going to be kind of new it's not all loose and fancy free like javascript as we generally think of it you can connect different data sources in the same query so let's say i need to get some from a database some from a third party api endpoint something from a lambda function you can include all of those in your your graphql server um through the resolvers you also only have one endpoint which as a frontend developer like that makes me so happy i don't have to deal with environment variables of like oh i'm in dev so i need to have this url for this endpoint here and oh change it to this url in production and have to tie all of my react component codes to all of these ridiculous urls and oh the the url change like you don't have to deal with any of that you set up one one url and then all of the queries all of the mutations run through the one url it's amazing it also enables really good mocking so if you're developing your back end and your front end right alongside of each other you can set up hey here's what the data store looks like and you can plug in mock resolvers for the front end and they'll pretend like they're actually getting real data from the back end even if the back end isn't set up yet and then when the back ends are ready to go live you just pull out that line of code and you hook it up to the real back end and we already talked about client caching a little bit so graphql uses types so vanilla javascript is loosely typed for better or worse like it's one of those things that people either love or hate i will say that after getting into graphql i really just like loosely typed javascript and i've gone full in on using flow uh so with vanilla javascript you can have loose equality the string of one equals one that's going to render true and the string of one with strict equality to one is going to equal false so when you're using loose equality it's using type coercion to determine if the values are equal graphql uses strict typing so there's no coercion so you can't do any loose equality it basically treats everything like with strict equality you declare your field types on the server if there's any mismatches whatsoever it's going to throw an error like it gives you no wiggle room which sounds intimidating but then you don't actually have to worry about the structure of your data you're going to get exactly the structure of your data that you declare which makes development really really nice and you can also declare the field as nullable or nonnullable so default types that you get with graphql in the spec out of the box you have a string an integer float boolean and id id is really just a string but it flags it in graphql terms as something that is not meant to be human readable so like if you have an id for your your document id from your database like that's auto generated that's where you would use the type id when it gets parts it's still a string but it's not something that you're going to be like printing out to the screen so getting started with graphql server we declare all of our types for our different data so this is actually a sample type from a react native application that i've been building so we declare the type with the the key keyword type and then whatever we want to name it you can name that whatever you want and this is going to look really similar to like a json object without all as much of the uh there's no commas like and if you throw in commas it'll yell at you that might take a while it took me a while anyways i kept on trying to put commas on like being the good good javascript developer that i was um so but similar to javascript object the the keys on the left the values on the right uh so we've got id which is of type id created at is the type date so here we've got the document id from mongodb because that's the database that i'm using for the project title is of type string and that exclamation point says that that's a nonnullable value so every brew entry must have a title it cannot be null we also can have subtypes so like json architecture we're used to seeing like objects within objects you can do that with graphql but you can't just say like ingredients and then open up a new object like it'll throw an error at you you have to declare a separate type and then you insert that so like type ingredients is just another type just like brew entry except it has the key values of sugar water and tea which actually is a further subtype so you can nest them but you nest them a little bit differently than traditional json you can declare your own custom types so you don't have to stick to the default types that you come out of the box you just have to say how they're serialized and deserialized in the database with graphql declare that in your schema and then you can use it elsewhere and you can also use enums or union types so the brew method where it says allowed brew methods that's an enum type so it's only going to allow one of several values so then we define our queries which are in their own type called query that's a reserved phrase for setting up your queries in graphql and you declare the query name as key and then you define what it returns so here all brew entries returns an array of type brew entry so they kind of build up on each other you can also define optional arguments again with the appropriate types noticing a pattern types types types which where this comes in in handy is with some tool a great tool that ships with called graphical and the builtin documentation and you'll see why this is so amazing in a little bit so brew entry accepts the singular argument and it's a required argument because again we have that exclamation point so it expects an id and it's going to return a singular brew entry you can also do mutations on our database so here we've got new brew entry and so we've got something a little bit different here we have an input type so input types are different than regular types they're set up the same except an input type is what is declared inside those arguments so they're they're very similar like the brew entry input is basically the same except it doesn't have the id field because obviously there is no id it cannot be required because it has not been saved to the database yet so a newborn entry is going to expect a brew entry input it's going to return a brew entry update brew entry is going to take the id and the input return the brew entry and then removing it it's going to take the id and delete it so there's a lot to digest and we still haven't even well how does all of us actually hook up like actually huh kombucha yes i i'm like a true hipster portlander so schema is only half the half of the things with graphql and setting up the server you also need to have resolvers and so resolvers basically tell the server what in the world it's supposed to do with this data structure so we set up our resolvers in an object map and we've got key root values such as query and mutation so in that object we have okay all brew entries is going to return brew entry dot find brew entry is a mongoose model that i have set up mutation is going to take in the new brew entry it's going to take in the arguments and return the saved output and i know it's a node meet up but we still got to talk about the client because this the servers only half the excitement and where graphql really shines is how it integrates with front end code so out of the box benefits is you get a data store similar to redux without all of the boilerplate by the way no there's like next to no boilerplate which is awesome there's been several like large organizations that have shifted from redux to graphql and eliminated very large portions of their code base that was taken up with redux you get caching out of the box you don't have any data massaging in the client because you're declaring the data that you want and that's all the data that you're getting back you're not getting you're not under fetching you're not over fetching you're getting exactly the data that you want back and so you don't have to massage it on the client's end again you can get exactly the data that you need for each view so for example that blog post index if all i want is the title of the slug and an excerpt all i ask for is that and that's all i get you can focus on more developer friendly and discoverable methods than a plethora of endpoints again you've got that one endpoint and you've got a really discoverable api and you have an amazing tool set to help write queries faster so here's an example of the query syntax in the client side you open up with a set of brackets call the query open up another set of brackets and say okay i want the id in the title that's going to return a data object the root uh the root key on that is going to be the query name and again it returns an array of brew entries and each one is only giving me the id and title because that's all i asked for so we're gonna go into the star wars api and bump that up a lot so here's what is like one of the most mindblowing things ever so graphical which is not a typo it is graphical because apparently the people who made it were very tongueincheek includes this docs tab and this ships with any like graphql at least with any of the major frameworks that are implementing it and if i pull this open the star wars api doesn't allow me to mutate their data so i only have this query so i can click on this query and now i can see oh here are here's the all films query and oh it takes an argument of after you can give me a description you can get vehicles you can just drill down into your api and see what everything looks like and as my schema changes that automatically updates because it's driven and produced by the schema so there's no manually updating of documentation there's no out of date documentation you can deprecate certain fields on your graphql schema you can include notes of why it was deprecated you can include descriptions like you get all that out of the box so we'll just open up a query and we're going to say okay i want all films and we'll open that up and another nice thing is if i hit control space i can see okay i want edges node they're using relay which has this edges and node concept and i can say oh i want the title and i want the release date and you can just start playing around with it character connection edges you can build up really complex queries we'll just run this now here's all the data that i get back and what's really cool is since it's just a specification it this nasty url is actually encoding this query so i could plug in this url like even if i didn't want to set up a graphql client in my frontend code i could plug in that url into a fetch call and i'm going to get exactly that data object back really cool also this is exactly the format that i need in my front end code so i always test my queries in graphical test my mutations get it working right rather than having to navigate through three different screens oh error didn't get this data back the way you wanted no i'm going to do it right here i'm going to get the instantaneous feedback get it right and then just copy the code over it's fantastic so here's some resources um and the link to the slides is at the bottom howtographql.com is a great video tutorial series built by the folks at graph pool now prisma which do a database as a service um and will do your like they can set up um they do a sql database and you can just say okay here's the data set that i want and how i want it set up they'll like auto create a lot of your schemas and your resolvers for you you can plug in authentication they'll set it all up for you i mean you're paying a service fee but they do have some free tiers if you just want to tinker around with it and they also did release an open source library if you want to basically use their technology but not have as many of the bells and whistles but run it on your own servers graphql.org is uh the specification page graph.cool we just talked about graphql stack is that uh reference i was talking about earlier where you can someone like took the time and blessed them for it and went through all the different types of whether you're doing backend serverless front end what language you're writing in and you just do a drop down and it'll say oh well here's the if you're writing in python on backend server here's the frameworks if you're writing an elixir if you're it's amazing apollo graphql i think is one of the best um javascript frameworks they have both an express server and a client server that they're continuing to iterate on and doing really well with i love collecting graphql links because it's kind of a passion of mine so that's my pin board with all of my graphql tags and if you're interested in checking out the kombucha log application that i'm building it is on github although it's not being as actively developed now that i'm working uh full time so all right well thank you so much you