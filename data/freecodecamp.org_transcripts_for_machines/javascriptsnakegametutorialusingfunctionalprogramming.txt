in this video i want to take you through this snakelike game that i've built using javascript and more precisely javascript in functional style or in functional programming styles so with the focus on purity small functions and composability so as you can see here now i'm running this snake game in the browser and ah you can see also there that i actually crashed sorry my camera is in the way so i can't really see what i'm doing in the snake game so but but this is the browser implementation and because i i tried to put the focus on modularity it was kind of trivial to make one sort of gui for the browser and then another gui for the terminal so if we jump over here to this side you can see if i just look at where i'm at now i'm in a folder called snake where i have a few files and what we're looking at here in in the browser is this web.html file but what i can also do is i can run this cli.js file through node and then we can place snake in the terminal so if we if we run cli through node you can see that we now get snake but in in sort of terminal mode let me make this a bit bigger so the x's represent the snakes the dots are the grid or that's traversable and the olds are the apples that you need to to eat in order to become longer and the interesting portion is of course or the interesting part is of course that this runs on the same quotation marks engine like we've separated the game engine from from the visuals of the game which is generally what we should do right we should separate presentation from the business logic so my interpretation of most of these snake tutorials or actually game tutorials that you find on the interwebs is that they are focused on just getting a quick version up and running quickly essentially but what i want to do as i tend to do with all of these videos is instead talk about design so i'm by no means saying that this is a perfectly designed snake game at some point i just said okay never mind let me just drop this make this video and i'll leave it to you guys to hopefully improve upon this game and make it even better or rather i should say improve upon this code and make this codebase even more modular and elegant that would be fantastic so if you do have comments please do shoot those in the comments or or if you do fork off from this code base and make changes please do post your changes in the comments that would be really interesting to read but anyways when we focus on modularity we can again trivially achieve this kind of thing where we have one implementation for the terminal and one implementation for the web which uh of course if we generalize this notion what we're talking about here is that you might have a single core and then multiple different implementers of that core or users of that core so that might mean that you could have let's say a multiplayer portion of your game or you might expose your game through an api or you might make an ios version and an android version and a web version of your game and so forth and now i'm saying game but actually we're talking about applications right so generally what i usually want to talk about is is design of programs is how we keep programs alive over longer periods of time and how to to increase modularity and so in some sense then this game is just an example of that but but anyways you could also just see this as how to build snake using functional programming in javascript let's get going so let me cancel out of the game here and let me make this full screen okay so again let me just show you uh the files that i have in this folder here so the main snake implementation is in this file called snake.js that's sort of the core library or or the the game engine in some sense and then these three files web.css web.html and web.js that's essentially that's essentially the web interface for the snake game so that's what we were looking at when we were playing in the browser those three files and then this cli.js file that's the uh node implementation that's that's what we're looking at up here right that's the terminal gui for through which you can play this snake game and then finally this bass.js is some base function so essentially when doing functional programming as i've talked about in other videos we tend to pass data last and we tend to have functions that are curried so we tend to have functions that are partially appliable but of course javascript doesn't work this way so that's why i implemented a few functions myself such as map and etc and of course like if you would build an extensive game you would probably use a thirdparty library such as for example ram.js or another library implementing the fantasyland specification but for the sake of this video i really wanted to keep everything selfcontained i don't want to use any thirdparty libraries and this is why we have some code in this base in this base file but then of course we have this readme file just because i've put this up on github and by the way you can find the link to all of the code in the description i might have moved it elsewhere but the link in the description should work let's actually start by looking at the web end so let's start with web.html so let me open vim and then let's open web.html and as you can see i mean this is clearly just any old normal html file where we we are loading in the the style sheet uh here i'm doing some funky stuff i'll explain that in a moment but then in the body we have a canvas setup that's uh of a size 700 and of a height or over width 700 and of a height 500 and then i'm loading these script tags and maybe it's maybe people nowadays always load their scripts here and then make sure that the dom is loaded in the scripts files i was just lazy and put them here to ensure that when i load uh this web.js the canvas has definitely loaded but yeah that's a completely different discussion but anyways you can see here that i'm loading in the base library then i'm loading in snake and then i'm loading in web.js so so clearly i mean this is because i don't have a build system set up where i don't have a build process set up so i mean clearly if you were building this and actually shipping this on the web you would you would probably somehow like minify all of your all of your files into a single main.min.js file right and you'd only load that and that would do everything so you would come construct a single javascript file from all of your other javascript files but now this is just a simple example so let's not bother with that right so then we're loading in the base library and the base library will expose a bunch of cons globals or it will essentially define a bunch of functions that are available on the global scope and uh same thing for snake and then web is the actual machinery of this web implementation or i shouldn't say the machinery is the is the actual main entry point of this web application and then let me just quickly explain this i mean this i do let me actually let me open up a split here and open up snake.js in order to show you that so snake.js because i i started with the the cons with a command line implementation actually from the beginning i was thinking that i only should do the command line implementation but then i figured actually it's so easy to make another web implementation so let me just make a web implementation as well i'm a big fan of trying to keep it as absolutely simple as possible from the beginning and this is why i was so actually i started building this snake.js file and and and i started doing it in a sort of stepbystep fashion where i implemented one function at a time where it's like okay this function needs to be able to do this right so like if we have a list of snake points and we want to compute the next snake point given a movement in some direction what would that function look like right and then i did that step by step for for all of the different pieces and then sort of from the ground up build the the snake implementation but anyways i because i did this i want to make use of the module system in node so you can see here in the end that i say module dot exports and then i export a bunch of actually first constants and then three functions and same thing goes for this base libraries if we go to this base library here you can see that this base library exports a bunch of functions so clearly module.exports is not available in uh the browser if you're in a similar scenario with some production code you should of course look into something like browserify or maybe there's something more modern now but but but now i mean we just do it we can just hack it up so so i just simply said that in the global scope i said that require is a function that returns an empty object right and module is an empty object and module dot exports is also sorry so so let me also say i mean i said require here but i said that the problem in in this right hand was the module exports but actually we have so in snake for example snake actually does require right so so snake the snake implementation or the snake game engine depends on the base uh functions the functions in the base library the base library helper functions so here we make use of the word require so so the browser does not have the word require and the browser does not have the word module nor module.exports and when i say word i mean of course i mean keyword sorry um so anyways we just say that require is a function that returns an empty object module on the other hand is an empty object and module.exports is a function that returns an empty object just just to make them not fail right they're not doing anything useful and then i'm relying on the fact that i know that both sn base and snake and web are all defining the fun their functions like this right here's a function here here are a few other functions here a few other functions and so forth so so if i just run these this code in the browser they will be exposed as global functions so just a quick and hacky way of getting this to work but anyways that's the web right so what it does so you can think of this as that web is actually the entry point or web.js is the entry point and then web.js needs to first require base and then require snake and this is why they're in this order or actually i mean to be perfectly frank rather web needs to require snake and snake needs to require base that's actually the more proper way of saying it so that's that's web html let's let's now look at web.js right so so what does this actually do so we don't have a ton of lines here right let me just scroll through this file you can see here at yeah 53 here i'm saying i mean i added a comment here to say that this is the main portion right so let's actually start from this main portion so what web.js does so so the javascript that will be run in the browser when we run the browser version of the snake game right first we do draw so these are actually two lines right sorry i just i thought it was prettier to put them on a single line so first we do draw one initial draw and then we say request animation frame i don't actually really know what that is but it's something like well the next time the browser will redraw redraw using this function please or something along those lines so people who develop games tend to use these so window the request animation frame and then we pass the function step or the function that's returned by invoking step with zero and so importantly usually people do this right they pass a function but i'm actually invoking the function step because step when invoked will return a new function and the reason for that is to avoid one global or another global so so step needs to keep track of how much time has passed since the last step right because so if i'm not mistaken like i mean request animation frame might be called different times depending on the i guess frame rate or something like that of your browser or the frame rate that you can manage to get on your browsers like depending on the performance of your computer your the request animation frame will be or rather the function that uh we pass the request animation frame will be called with different intervals different time intervals depending on the performance of the computer that you're running it on so in every call to step we need to check the delta we need to check the diff between the current time and the last time we rendered and that's why i passed this first variable because here i'm saying then that or this first zero because i'm saying that the time since the last redraw was zero so we're saying let's instantly redraw so so here you can see then that here's the definition of the step method right so the step method or the step function i should say sorry it takes a t1 so time step one or time stamp i should say a timestamp one at a timestamp two and then it says okay what's the difference between timestamp two and time step one and if that's greater than a hundred and i don't really know let's think about this so i can't really remember but i assume this is in milliseconds so that would mean a hundred milliseconds right so a tenth of a second so every tenth of a second we enter this portion and all of the other times we enter this portion and now you can see how this works right because if we do enter this portion if there if if 100 milliseconds has passed since the last time we we updated or the last time we stepped then what we want to do is we want to say this state global this global state variable i'll get i'll get to this in a moment equals the next state given the current state right this is kind of typical functional programming right instead of doing mutation we're just saying that we have this global state variable global i mean you don't you shouldn't have a global state variable but like but i mean in this case it happens to be uh to be global but essentially the point is containing your state into a single variable and then passing that state through a function that produces the next state right from that given state so instead of saying well here's my state here are the actions that i want to do let's change all of the variables so that it matches the new state because then some things are more difficult to reason about because we have mutation all over the place instead we say well here's the old state let me pass you that and then if you compute what the next state would look like given that old state well then i then i know what to do with that right so that's what we're saying state is this this state variable and we say next is a function from snake from the snake engine and when we pat and when we pass state to that it will compute the next state and then we will set this set the state here this mutable state here to this new state and then we will do draw right and draw i haven't even bothered about trying to make immutable in any kind of sense because like like the canvas libraries or they're like the canvas and apis of browsers or like there's tons of there's tons of mutations that would be extremely painful maybe there is a way to do that if you have an idea of how to do that please do shoot something in the comment that would be or in the comment section that would be very interesting to read about anyways so so that's for the if branch or for the true case right for the false case what happens well in the false case or in other words when enough time hasn't passed 100 milliseconds hasn't passed since the last time we updated then we simply do my camera is in the way i can see but but we simply do the same thing or we say or rather i should say we don't compute the new state and we don't redraw importantly but we do request another animation frame and and to that we tack on uh or or we throw in a function that's that says step again from t1 so notice the difference between this line and this line right in in this line we have t2 and in this line we have t1 t2 and t1 and t2 here is because we want to have the new point that the current timestamp as the as the next time step that we want to compare again so it's like as the as the next time step that we want to say has a hundred milliseconds pass from this time stamp right that's what we want to do when we do redraw but when we don't redraw we want to compute from the old timestamp we want to say well you started at timestamp zero and now 50 has passed 50 is not enough so keep on keep on waiting but you should compare against zero and not against 50 because if we if we keep updating this if we keep changing this to t2 here if i said uh t2 here we would never redraw right or maybe in the odd case if it's like it's super laggy or something like that right but but assuming we have good frame rate then then we would essentially never call this and that'd be problematic so this is why we're saying t1 and of course i mean maybe this wasn't clear but what request animation frame does is that it passes a timestamp and that is this t2 then and i don't actually know i mean it's not it's not like it's a date because we start from zero but maybe it's something like the time since the the this browser session was initiated or something like this i mean this since the page was rendered i should maybe say but anyways i mean i have no idea so don't take my word for that but that's that's the update method but actually let's go up to the top here because i feel like what i what i didn't say is this that the state variable that we talked about is defined here so so notice comment that says mutable state so this is so this is the state variable that contains the state of the game at all times and it's global quotation marks like it's it's shared across all of these functions in this file and and what you can do is is that the functions or actually the functions don't there are two functions that change it i should say right there's the there's the step method that changes it but there's also this key events thing like there's this listener for key events and that thing also changes the state right so actually let's let's look at that uh at once right or wait first let's begin here in the top so so we can say okay so so we say let state is equal to the initial state and where does this initial state function comes from i mean this is the problem of working with globals it's very difficult to see where things are actually coming from since they're not actually scoped i'm realizing now maybe i should have scoped them so that instead of making these functions all functions in this file i could have put them inside an object and that would give us a name space here so that we could say snake dot initial state because that's kind of actually what we're looking at here like if you would use required you would get that for free but but anyways yeah i should have fixed that maybe yeah but anyways that's from the from the snake.js file so snake.js file has a function called next here right and we'll talk about this when we get to the snake.js file but but but suffice to say for now that the next function takes a state and computes the next state given that state oh sorry i was about to talk about initial state and not about next but that's that's next right that's what next does but if we look at initial state that's just a function it's it's a i think it's called a unit function like it's a constant in some sense so it's a function that takes no arguments so it's nullary and it returns uh an object that is essentially a state representation but it's the initial state so the initial state is essentially always the same so when you start a game you need to start from the initial state so yeah that's the way we invoke this this state variable now let's go back down here and let's now talk about these events so we say window dot so now my camera is really in the way add add event listener key down so that's the first argument and then the second argument is this function that takes a single argument which is this variable named e which is the event and then we can extract the key variable or the key property from that event and then we switch case over or over essentially that variable and then we say okay well we want to be able to control the snake using wasd the keys and h h j k l uh so here's the wasd and here is h j k l but then we also want to be able to use the arrow keys right so and depending on which one of these we press we want to compute a new state we want to say that the new state is what the old state was but plus quotation marks plus this new direction so these are constants north west south east these are constants that i've defined in this snake.js file where we have north and south and east and west right and these are essentially just i guess maybe you could think of them as vectors i'm not really sure but like they have an x direction and a and a y direction or a velocity in these directions right so north means moving zero x but negative one y that's the definition of north within the context of this game but but anyway so so we want to cue those in and we need to pass the current state because again remember the snake game has no clue of the current state that we have right it's it's uh actually i should say this it's pure except for that the snake snake.js file has some randomness right so here we have one function that does some random stuff and and i mean remember randomness is is impure because it relies on things such as system date and etc so given the same input you won't get the same output but i mean i was pragmatic here it's just thinking like there's no point trying to do something more complex here in my mind it makes sense for a function that computes a random position within a grid to be within the snake.js file and not elsewhere but anyways there are clearly solutions for that but i'm just being pragmatic but but essentially so so then the snake and q method needs to be passed the current state we need to pass the current state as we do here right and we need to do that because as we do here because again it's it's almost pure so it doesn't know what state we have it doesn't keep track of its own state and and q is also defined here in this snake snake method and again we'll get to this when we start to talk about the the snake stuff but essentially as you can see here it takes the current state and it takes a move it asks whether the move is valid and if the move is valid it does this if it's not it does that right so if it's not valid it just returns the same state it does it does no changes but if it is valid then it says okay we want to merge yeah we want to compute a new state that is the old state plus that this moves property has changed to the old moves concatenated with an array containing only this new move so this is an extremely complicated way of just saying append but immutably append the last move to the list of moves but we haven't even talked about the state tree so we'll get to that in more detail but that's that's in queue and this is sort of the basic game loop right like if you think about this game first from the from the main here we draw one initial time and that's sort of the the first drawing but then we say we'll start stepping from zero and then we keep doing the step method okay step and step and step and step and so forth and whenever we've it's been 100 milliseconds since the last step we compute the next state from the old state and then we redraw and then again we just keep on looping quotation marks keep on requesting animation frames so that's that's sort of update and draw but then there's also this other exogenous force that that can enter right like there are also key events like when the user types uh keys we listen to this and if you happen to type a key that's that's one of the arrow keys then we need to compute a new state so so then we're also saying well you need to set the new state to the old state plus this new key that's being pressed i would say that that's that's fairly clear again like the the benefits of mutation or the benefits of avoiding the mutation is that whenever you want to change things usually it's pretty easy to change things because you don't have to think about state so for example i'm not sure if you noticed but when we played this game well sir of course how could you have noticed it's not actually visible and think about that but the way the game worked from the beginning was that if i'm traveling in the direction west as i'm doing now and i press east right i'm traveling leftwards but if i press the opposite direction if i press east right or conversely if i'm traveling to the right and i press the left key so if i press the inverse direction or the opposite direction of the direction i'm traveling in i would instantly crash because it's like the snake is moving in this direction right and it's like it's it's immediately just going directly into its own tail right and some snake games actually did work this way and was extremely frustrating and that's what i noticed here as well like when i was playing this it just messed me up all the time because i kept on crashing when i wanted to try out the game so i figured okay let's actually remove that functionality from from my snake game and that's when i added this valid move portion to nq so previously nq used to only do this right it used to only just merge in whatever motion you you added into the queue of motions or into the queue of moves but now i said well actually let's let's avoid this sort of inverse situation so if you pass the inverse so that's what value move does it checks whether it's the inverse and if it's not the inverse yes then it's valid but if not if it is an inverse then then we will ignore it and we'll just pass the old state so we'll not cue the move right so it's these kind of scenarios that we often find ourselves in when we use immutability like when we realize okay would be cool if the game could do this or actually this is a this is a tricky thing let's let's not actually make it do this let's make it do that instead right and then we try it out and it actually turns out to be fairly simple most of the time but anyways okay so so so this is the whole this is the the web portion right we have we have the step function we have the event listeners we have let me here in the main let me just put that back on one line we have this main that that initiates it and then we haven't talked about what draw actually does right so as you can see here is the comment says game loop draw right so so this function draw and it's also pretty simple like as you can see from the comments here like i was contemplating separating this into multiple functions but given the mutable nature of the canvas library and like given the fact that we probably won't reuse this code i just figured whatever let's just make this let's actually just make this a long function that does does all of these things like one by one so what it does is that it it clears the canvas right so so ctx here is another global variable because yeah what to do right so so let's actually start from the top right so so the first line says okay let's let's make a constant variable called canvas and let's from the document get the canvas or let's get the thing that has the id canvas so if we look at the html thing you can see that canvas here actually has an id of canvas just to make it simple for myself right so so i i grab that canvas and then we get the context for that so that we can draw so so in ctx is is a context variable then we have these position helpers here we'll talk about these in a moment but what we do then is that we first clear this canvas by saying okay let's set the fill style to this uh like blackish color i guess and then we we draw a rectangle over the hole of the whole width and the height then the next step is that we draw the snake right so then we say let's set the fill style to something which is greenish and then let's map over the snake so so this is where it sort of gets interesting right because it's like the different graphics engines or the different gui's or the different sort of interfaces can have completely different ways of interacting with this stage right but but so the state exposes dot snake it exposes actually lots of things like like moves and apple and and so forth and so forth but but we're just going to make use of snake and of apple so what we do is just that we map a function over uh state.snake and so snake is an array of positions so it's it's or it's a it's a it's an array of points points being objects that have x and y coordinates and of course this is not an actual proper map because i don't care about the return results so this is actually more like a for each that actually mutates the canvas but map was a shorter word so whatever any in each of these iterations of the function what we do is that we say well using this fill style fill a rectangle in the context from this exposition this y position over this width and over this height and now you can see why these x and y methods and these x and y methods are just helpers for me to so that i'm not duplicating the same math all over this place so if you remember what we did was that we drew rectangles right so notice how the snake so every point in the snake or every uh piece of the snake or just think of the apples for example take up sort of one quotation marks pixel and pixel meaning uh like traversable pixel in this grid maybe i should say tile actually like it covers one tile and so what we do then here is that we compute uh the the the position of these tiles so x1 here will return the width of one tile and y one here will return the width of one tile and what happens when we do this y of some position is that if if the ycoordinate is zero then we'll put then it'll turn to zero right because if we look at the implementation of y here we say uh take the canvas height and divide it by the number of rows that we have in the state so like if the sorry i forgot to say that we have the r here as well right so so if r is zero r being the the y coordinate right so let's say that the y coordinate is zero then we multiply that with the height of the canvas and let's say that the height of the canvas is a hundred and then we divide that by let's say uh 20 which is the uh the number of rows let's say so the number of tiles in the y direction now this is not necessarily correct with in regards to this particular scenario but just hypothetically it makes sense then you can see that we get zero right because that's a zeroth position like that's the pixel that we actually want to draw from but if we take one we get five if we take two and we get ten and so forth and if we take 20 we get a hundred because like that's the that's the last pixel and actually 20 doesn't exist if we have 20. it's 19 would be the last one because it's height will also be 5 and then 5 will take it up to 100. but anyway so so those are just two helpers in order to to not have to duplicate that as you can see we use these x and y things here as well so that's the way we draw the snake and then we do that for the apple as well so we say okay here we don't have to actually iterate we just say fill rect at this x position at this y position using this width and this height right and the width and the height is the same because the apple is as large as a tile just ah as all of the pieces of the snake is is is as large as the tile but the position is based on the on the x position of the apple right so so the x position and the y position so we're saying compute the y position from this coordinate which is defined by state dot apple dot y and then finally we draw the crash so let's just think about so let's let's just look at that right like if i if i crash into my own tail notice how the screen flashes quickly red right or quickly flashes in red there you go right it quickly flashes in red and how we know that that has happened is that i decided that well if we don't have a snake in the game field that means that either the game is just started or there was a crash so actually if we just refresh the page you can see that it blinks red and maybe this is an unwanted feature and we should try to solve this but i just figured whatever let's just not think about that now so if there is no snake right so essentially then we're saying that if state.snake.length is equal to zero so if we don't have a snake then we should essentially draw this red rectangle over the whole screen right so that's the way we're indicating a crash and and that's the whole drawing thing and i i mean a moment to pause and reflect right like like the point here is that this is all graphics right like assuming that we can use this uh state structure for all of the graphics engines assuming that state tree gives enough information this can be completely focused on just the visuals right and and it is not sort of intermingled with all of the business logic so if we say ah actually let's change the color of the snake it's trivial to find the place where we can change the color of the snake or let's make the apples round it's trivial to find the place where we make the apples round instead and we don't have to worry about accidentally messing up some of the other core business logic because that's in a completely different place so we have to be really silly in order to mess that up so anyways that that's the draw that's the draw function and i think actually we've covered all of the stuff here here then right like first we just grab out the canvas we set up this mutable state that's based on the initial state we we construct these two position helpers that will make us position things in this uh grid or a visual grid in the browser and then we construct this draw function that will take the mutable state or based on the mutables they draw a bunch of stuff on the canvas and then we have this game loop that whenever it's called checks whether it has passed enough time in order to progress to the next state and and redraw or whether it should just keep on ticking and then we have these these listeners that listen for events or listen for keystrokes and produce new states based on these keystrokes where the new states contain the new keystrokes or contain the directions that we want to move in and then finally we have this this main that sort of just initiates and starts the whole thing up and of course i mean we didn't actually need this first uh this first draw here in the in the end right like the only difference if we have that or if we remove that you can see that there's a quick flash of 100 milliseconds where we don't have a board that's essentially the only difference and that's why i added that because then immediately we should get the board actually now that i think about it it's almost hardly visible like like you can see i mean loading the page probably takes quite some time anyway so so yeah i mean you might want to remove that okay but that's the web portion let's now actually look at the snake core library i think it's probably easier to start with that and then look at the the command line implementation so let's go to snake.js so again this is we we've glanced into this file a tiny bit but but not too much so i think actually there's too much code here right so let's start from the top let's just scroll through quickly first to get an idea like we have about yeah 61 lines of code and if you have ways of making this again more elegant and more concise not not concise as in cold gold pheasant just for the sake of conciseness but as in elegance then please do shoot something in the comments that would be massively interesting but what we start by doing is just requiring this base library that we've defined again as we've talked about with some helper methods i'm not sure if we actually ever looked at that but here's the base library right yeah we did quickly look at that but we just define a few a few functions such as for example map and as constant and identity and all that stuff but let's forget about that for now right but we load the functions from the base library and then we do this and this is kind of just me hacking again so i apologize for that but what i wanted to do is so base for example exposes the function map right so you have base dot map but whenever i use i don't want to have to say based on map i just want to be able to simply say map and refer to base.map because they are helper functions as i mean in some sense you could argue that that some of the functions defined in base here are functions that should be defined in javascript if javascript was actually aiming to be a functional language like so functions such as map or reduce are defined in the prelude of haskell so they're defined in the base library of haskell reduce is actually called fold in in in haskell but and not just that i mean tons of other methods such as identity and constant and lots of other things some of them are not like prop for example like because haskell is aesthetically typed language and and javascript is dynamically typed language so if we look at the base library here for example i define the helper method prop which essentially takes a key and then takes an object and extracts the value under that key from that object and it's trickier to define an aesthetically typed language actually now that i think i'm thinking about it actually it's completely defined upon aesthetically typed language it's just probably not as useful right because you're probably using static typing because it gives you benefits and when you're starting to use this sort of key value pair syntax this dictionary syntax then you are exposing yourself to runtime errors because you might end up in situations where the key doesn't exist but anyways that's tangential what i wanted to say is just that in javascript because of the dynamic nature of javascript some of the functions that we might want to put in the base library quotation marks make sense to put in the base library but might not be functions that we want to put in the base library in other languages but anyways this is total sidetrack that's why i'm doing this right just to expose all of those functions so i can say k and id and map and so forth and not have to say bass dot map and so forth so so that's that okay let's move on then we have these constants right these constants we've already talked about we need some way of talking about the different directions and maybe you could argue that these should be functions that or again like nullary functions that take no arguments and return this but anyways i just define them as constants then we have uh this point operation and actually i was thinking about this a while like this is not excellent because if you could check for deep object equality right like i think in many of the javascript libraries you can do that in many of the testing libraries you can so actually like object deep equals or or deep equality of two objects is actually a very useful thing to have in the language so actually i mean the implementation of point equals should essentially just like if you pass point one and you pass point two then the implementation should essentially be point one equals equals point two if if equality in in javascript was based on the deep structure of an object and not the the reference to that thing in memory or the pointer to that thing in memory but anyways i mean and even if it didn't look like this it should perhaps be the deep uh the deep equality between p1 and p2 and maybe if we do that in the current fashion it would look like this right and actually if we have that then point equals is essentially equal to deep equals if you think about that because if i put both of these at the same time you can see i mean what we do is simply that we take one x here one y here we pass the x here and we pass the y here so we're just applying that function so so then it's really it's the same thing like we don't even have to take any arguments we can make it point free and and that's the reason i'm complaining about this like point point equality is nothing special like i want to say that the x point equals the x point and the y point equals the y point of the two of the two things or not the point i mean the the x property of point one equals the x property of point two and the y property of point one equals the y property of point two like that's the check i want to make but that's just a check of equality so that's why i'm saying like that's a bit silly and that was disappointing but i think it was just overkill to implement deeper quality a function of deeper quality in in the base library but at least now you know anyways let's move on so so then we have a bunch of boolean methods right so so what i mean here is i mean a bunch of functions that take some particular or potential arguments but also also the the current state and then given the current state answers questions so the questions that we want to have answered is whether the snake will eat upon the next update given the current state and whether the snake will crash given the current state in the next update so if we have this current state and we have a list of moves so we have a list of left right up down etc given the next move and the current state will the snake crash that's that's the things that we're asking here and then this thing is of course as we talked about before whether a particular move is valid but that's before we enter the the move into the state so i mean maybe we could have done it in a way we could have just blindly added moves into the state and then have a function that computes a a clean state without any invalid con consecutive move combinations or without any any sort of inverses in the list of moves but but i chose to do it this way maybe the other way would have been more elegant but so you pass a move first and then you pass a state and then it says yes if this move is okay given this state so if it's okay to add this move to this state and the way we do this is just that we say okay well so let's think about this we do logical or between this thing and between this thing right so let's just let's put these uh like this just temporarily so that we can think about it right so we're doing the same thing twice we're saying either either something holds for for the xaxis or something holds for the yaxis or for the y direction and if either of these hold then it's a valid move and what needs to hold is that the uh x velocity of the move of the of the last stacked move of the of the next move that we have when when we add that to the new move that we want to add that needs to be different from zero so so what we're saying is that if we are moving in x minus one then if we add one to that then that would give zero because if we're moving in this direction and then we add one so one would be this direction that would be the polar opposite of that thing or of that direction similarly if we're moving one and we add negative one we get zero because we're if we're moving in this direction and we add this direction then these cancel out and we get zero right and that's the scenario that we don't want where we're crashing into our own head but we're saying that either the xaxis needs to be different or the the y needs to be different i mean since you can't since you can't move diagonally yeah this is in some sense probably overly complicated because clearly if the yaxis has a value then x will be zero and if the x axis has a value or if the x direction has a value then the the y will be zero so there's probably a more simple implementation that you could you could look for so let's go backwards by putting this back on one line and then let's look at the next stuff actually before we go any further let's let's look at the stage right so initial state let's go here i mean we said previously that there's a function called initial state that returns the initial state that all of the other states are sort of built from so in the initial state we have just a few things right we have some number of columns and some number of rows and th these are just in order to i mean maybe it's not the best place to store these because they won't change or they shouldn't change over the over the course of the game but maybe if you would think in terms of levels then maybe this could actually change but who knows but then we have a list of moves and the initial in the initial state we start with east in the list of moves as you can see right like when we refresh the game we always start from the same position here and we always start by moving east and that's because the default move is east and we can't see here because the default snake is empty but what happens after a crash is what causes the snake to start at 2 2 but we'll see that later and then we start with the default apple actually at 16.2 so maybe that should be a random position but for some reason i chose to put it there so again you can see that the apple always starts here so we'll always automatically catch the first apple right by just leaving the snake to do its thing so that's the initial state but let's now jump back now now you know sort of what that contains and of course the snake thing right like we were saying the snake is is an array and it is an array of positions or points right so things that look like this right that have an x coordinate and that have a y coordinate and this is why we're saying point equal or this is why i said point because we call these these things that have dot x and dot y we call these points so yeah actually so let me jump down i think it's actually easier just just to follow along from down here instead instead of going line by line because the order wasn't superb so let's actually just look at the next method here instead so when we looked at the web implementation if we go oh sorry to webjs here you can see we talked about how we call how we call the next function here right when we step the game we say the new state is equal to the old state ran through this the next function and the question is what does the next function do well the next function is i make use of this library method called spec which the library ramda i think they call it apply spec or something like that but i just called it specs so you can see spec is a fairly interesting method it has this it has this slightly tricky implementation where it takes an object and then it takes some value and then it grabs the keys out of this object and maps over the keys constructs a new object from that key and runs the function that hides under that key applies that function to this x that we passed to this value that we passed and then it reduces over merge so it simply merges all of these different different objects that it produced into a single object and that's a pretty complicated way of saying that essentially what we do here let me just i mean if i if i retype this implementation we could retype it as that let's think about it next is a function that takes a state and returns a new object where the new object if i had a spread syntax i could say is the old state right plus or actually let's not use this person let's be explicit so take some state and and and returns a new object where rows is equal to state of rows calls is equal to state dot calls moves is equal to next moves while being past the state and snake is snay a next snake being past the state and apple is next apple being past the state so that's essentially that's essentially what we're doing and actually i mean if we would express this in function syntax as well these first two just to make it clear uh really that why we can use spec in this lower implementation is because this is essentially then just using the prop method that we talked about before so if i say prop here pass row yes sorry like this right i pass these props as a string and then we pass the state as the second argument and sorry i'm using curried or functions that allow partial applications we actually need to invoke the function like this so that would be the same thing and now if you look at that right if you look at that implementation you can say okay well actually next is a function that takes some state produces a new object where the state needs to be passed to all of the functions or rather i should say it produces so next is a function that takes some state and produces a new object where this new object contains a bunch of keys and to determine the values under all of these keys we need to execute a few functions but these functions they are not nullary we need to pass them some arguments and the argument that we need to pass is essentially the state like if you line this up you can see all of them are past the state so essentially what we did is just that we we sort of made it point free we remove this portion notice how we do this we remove this boop and then we say okay all of these need to be past state okay but that's that's why we have the spec method so then we say spec and then we pass state here okay that's that's also the same thing but then we're back into the scenario that we looked at before where it's like well well actually next is now a function that invokes this this function spec by just passing the x that we pass it right like next is a function that takes an x and runs another function through that x or over that x and then we don't even need to specify the x we can just we just remove the state here like we remove the explicit call and then but then we remove this explicit variable here and then we just say next is the running of spec over these functions and then we pass it some states so i mean i would argue that this is more clear but yeah i'm totally empathetic too if you have a different opinion like as soon as you start to learn a few of these really common functional programming i wouldn't say patterns but like functions essentially these these common functions that we tend to use all the time like constant and id and map and reduce and pipe and compose and i would argue for dynamic languages this method is like super common uh or this function spec or or apply spec is super common so when you start to recognize these i actually think this becomes the easier version to read but there's a whole discussion about whether point free is is sensible or not i can shoot some links in the description if you're interested in that but anyways let's move on so that's that's the next method and we've all already talked about enqueue what enqueue does is essentially that you pass it a state and you pass it a move and if the move is valid then you merge the move into the list of of current moves that you have stacked up right so so the reason we're stacking them up by the way is that if you think about it what we can do oh sorry let me collect a few of these just to get a tail but what we can do is that we can stack moves like this if i just mash the buttons sorry now i have a tail now i can do this okay so if i just mash the buttons and then i let go let's see if this works let's not crash i just mash the buttons and i let go you can see that we've stacked a few moves and the reason we do that is because of if you've ever played this the game of snake you see like literally in this scenario right like now i just want to go right down for example like immediately right and then immediately down and then i can just queue down after right so i just press write down and then i've cued it so like if we didn't do something like this maybe we wouldn't be able to get both of them in actually now that i think about it that would probably work still i don't know maybe you have some opinion opinion about that i mean what wouldn't work is this sort of stacking but then again this stacking isn't necessarily super useful i assume but anyways let's get back to the code that was the original intention of why i did it as a list so yeah that that's enqueue so we've talked about in queue we've talked about next we've talked about initial state and what we i guess what we should do now is just talk about well first let's talk about these so the next state is computed from the old state right and rows when we do prop rows and prop calls as we looked at in the other implementation that just equates to the same value like we just say this value is whatever the old value was but however next moves let's actually look at the next moves right so let's search for cons next moves right and what this does is that it says okay it takes some state and and remember so what it the intention is that it takes the whole state but the intention is that it should produce only the list of moves right so it takes the hole and it produces the part so we take the state and then we say okay state.moves.length is greater than one so so we say if we have more moves than one then we should drop the first move right so so drop first is a function that i've defined here in the base drop first which is i mean it's trivial we just call a slice on an array slice and then pass one but i just did this to make it more readable right because now we can actually like very easily see what it does so we say drop the first from state moves or if the if the length of the the moves list is not greater than zero right so so if we have only a single move left then it will simply be a state of moves so what this means is that if we have more than one move we will drop the the first move because we've used it like in the next in the next state we won't have this this uh we won't have the first move left because we've now used it but if we have only a single move then we shouldn't do that because we want to keep repeating that move right that's how we're achieving this effect where it just keeps moving right i mean i'm not touching anything but it just keeps it just keeps moving to the right so that's because we we keep that in and and of course let me just quickly mention again that you can using functional programming you can make a lot of things point three point one and point two i've also kind of mixed this this sort of objectoriented dot syntax with this function syntax where you truly like truly have a function and then pass the data and i i'm a bit disappointed about myself for doing that but anyways i mean i just figured let's stay pragmatic but probably like here you we should do something like this like length of state that moves because this this dot syntax is fine because this is purely data but then length is a function on that but but this is a sort of give and take i mean i don't think we're going to be able to get away from this anytime soon in javascript because like maybe my terminology is a bit shaky here but if you've tried haskell for example like you have adhoc polymorphism and you have parametric polymorphism and adhoc polymorphism is kind of like polymorphism and objectoriented programming and so so the so the thing in haskell is that you can actually define a length function that takes some data and then does different things depending on the type of that data that's a bit tricky in in a language such as javascript because we don't have adhoc polymorphism in that way the way we achieve adhoc polymorphism is through objectoriented polymorphism is is by saying that length is a function that exists on an object and in in a dynamically typed language such as javascript we say well everything is a duct type right like if it quacks it's it's it's a duck so everything that responds to length is lengthable but which implementation of length you get depends on which object you call the method length on so i mean it's a give and take like we probably have to mix these two types of syntax before we have facilities for ad hoc polymorphism that looks a bit more like something like haskell in javascript which probably we maybe won't because maybe i'm not realizing how difficult that would be to implement in a dynamic language but anyways now we're way out of the zone so so so let's get back into this game but i just wanted to mention that that i'm completely aware that that's it's not it's not superb anyways how do we compute the next position of the apple well if this is where we get to this we'll eat that we talked about right like if the snake will eat the apple given the current state then we need to spawn a new position and that's when we're using this r d pulse that we talked about that's that's the that is the function in this snake library that is impure or actually i mean then next apple becomes impure because it's making use of an impure function but whatever so if the snake given the current state will eat the apple then we need to spawn a new position for the apple based on the current state if it's not right if it's not if the snake is not going to eat the apple then the apple will maintain in the maintain its position that the new position for the apple will be the same so so let's actually for the fun of it i mean let's actually do the same thing in both of these cases right like we have the cases where it will eat and we have the case where it won't eat so let's change the won't eat case to also uh spawning a new apple at a random position and then if we refresh this and run this again you can see that it's absolute and total madness right because now we have the apple is sort of respawning at new locations regardless of whether we're eating the apple or not so actually i mean i don't know the probabilities here but it's probably i have no idea whether it's higher or lower but like it's a very tricky game to play so this is surely not what we want then and and then also for the fun of it let's try the other thing like let's say instead of when we eat an apple that's spawning it at around a position let's just spawn it at the same position let's say that the the new position of the apple is the same as the old position of the apple regardless of whether we ate it or not then we can see that what happens is that we don't spot a new apple right the game works fine but we can just like hands off and then just leave it like this because we're just going to eat all the apples until we crash actually it's probably still tricky again because the snake will take up all the screen and then it's going to be tricky to eat the apple but anyways i mean clearly what we want is a random position so we want is this like we spawn a new position when we eat the apple and again that was like this is some of these things are very easy to to think about when you have immutability like i would imagine that going back and forth between these two changes would be more difficult if you had it would potentially be more difficult if you had mutable state depending on how you add structure you caught clearly next thing let's let's move the next head right so next head uh well let's think about it this way we have next snake and we have next heads maybe these should be in the other direction right so so and i think next snake was called in the next method here right so yeah so we're saying snake is equal to next snake so if we go back to next snake here and next snake makes use of next head so let's actually talk about next snake first so let's first think about the snake right look at this like let's actually grab one more apple here so now so now we're a snake of three dots right if you look at it now we're four but so so the snake is a list of positions and now it's a list with four elements that each have positions and i think if i'm not mistaken i will have to see either the first element or the last element in the list is the head of the snake so what we do is that we just when we need to move the snake we remove one element in the end and then we add one element in the beginning and when we eat right think about it look at what happens when we eat then we the snake is prolonged so what happens is that we add one in the front but we don't remove one in the end or i shouldn't say we add one in the front what i mean is we do compute the next position of the head but we don't remove one from the tail right so we have the snake here and then we're saying okay if you if you're not eating we should just take the snake and move it here but if you're eating then we should take the head and move it here but this tail should be fixed we should not remove anything from the end because it's this removing that makes that gives the appearance of it moving right because it's actually that we we remove this thing maybe it's easier maybe if we just think about one daughter like if you have one one dot like one one one snake head then what happens when we're not eating is that we're just saying okay remove this boop and make another one here and that gives the appearance of moving right and then and so forth but if we're eating we're saying create the new one right you have one here create the new one but don't remove this one right so so we give the appearance of prolongation and not of of or of extension and not of of moving of course it's moving as well but but anyways so that's the way that we structured that by the way i mean i tried this in multiple different approaches i also try i mean it's an interesting game because you can also approach it by building up a grid and then sort of making operations on that grid so like you have a two by two uh array like a matrix but anyways maybe if you if you try out the solution along those lines maybe again shoot something in the comments that would be interesting to look at so to compute the next snake what do we do well what we do is that we have two ifs we have two nested if so we say okay if the snake will crash right given the current state given the current direction given the current world if in the next state that we are now computing will the snake crash or not like if it will crash then the next snake is going to be an empty raid then we're going back to this sort of initial state thing we're saying let's go back the snake is an empty ray however if the snake won't crash we do any of these things and if it won't crash we're asking this well is it so that the snake is eating because if it's eating then what we want to do is just that we want to add the next head we want to compute the position of the next head like we did here with the hands right like we have one we have this we have a snake here and we want to add the snake here or we want to move it here right and if it's eating we just want to compute this new position and then we want to concat that into uh the current or with the current snake however if it's not eating then we need to move it or we need to give the appearance of moving that means we can't just compute the new position but we also need to drop the last position so we need to remove something from the end and let's just think about whether it's it's in the head or not so what we're doing is that we're saying that the head is an array and then we concat that with the old snake yeah so what we're doing is that we're adding into the beginning right so we're not it's not that we're pushing in positions into the end of the snake but it's more like we're adding at index zero and then we're shifting all of the other ones uh backwards so i haven't at all thought about performance and efficiency but i mean clearly there are probably multiple ways you could improve this code but so that's what happens when we're when the snake is eating we are adding a new head but we're not removing the tail and if it's not eating we're adding a new head and we are removing the tail so actually i mean if we if we remove this drop last just to try this out right then we're saying it's going to get longer all the time so if we run this now you can see just like it's it's never ending like it doesn't matter if we eat or not the snake is just growing and growing and yeah that was tricky for me to handle but as you can see right like the snake just keeps on growing and growing and growing again like a trivial thing to change but we go back to uh to actually dropping the mast and of course if we did drop last here as well just to be exhausted let's try that as well that would mean that even if we are collecting apples nothing happens like the snake isn't actually prolonged so of course what we want is that like this okay that's the next snake but then okay as we were saying next next next snake makes you some next head so the question is how do we compute the next position and that's actually pretty interesting right so let's look at next head so again next head the structure is that it takes a state and it produces a single position right so think about it i mean next snake takes a state and produces a list of snake positions next head takes the full state and produces a single position that represents the head of the snake and what it does is that it it too has to ask an if question and the if question that it asks is that do we currently have a snake or not right like if the length is zero like if you look here right uh as we talked about in in next snake of course when we crash we completely wipe out the snakes so that we don't have a snake so when we compute the next head it might be that we're trying to compute the next head from from no snake at all so this is why we're asking is the length zero because if it is zero then this we want is like the default start position maybe i should have had that as a comment or something like that actually if you look at it if we refresh here you can see that this supposedly is 2 2. ah actually let's think about it that means so x 3 and y 3 if you start from 1 so this is why i mean maybe one would assume that it's here but actually this is 1 1 because this is 0 0. so here it's 0 0 one one and then two two so uh so yeah we start at two two all the time and that's essentially because when the length of the snake is zero then we spawn at two two and again i mean we could do r and d let's say r d pulse uh given the state yeah that should work as well then we are starting at random positions we're always starting going east but now we're spawning it at random positions we're spawning the snake at random positions but i i figured this this makes sense i mean it's kind of nice to start from from two two and also it's obvious that you've crashed so that's what happens if the stink is zero like if it's the initial case but if we do have a snake like if if the length of the snake is currently longer than zero what do we do well this i found pretty cool we create a new position that has an x and then that has a y of course and what we do is that we take the i mean think about how these two look very much the same right like x and y is essentially the same thing but what we do is that we say the x position is the current x position of the snake of the of the current head of the snake right what's in the zeroth position plus the x of this move that we've stacked the next move that we want to grab so so the the move that is pending the move that it that we're supposed to execute now and remember like the moves that we can have are are any of these north south east west east west west so if we have east stacked right as in the default case then then x will be one so what we're saying here is that we're saying uh state dot is snake so we're taking taking the state position snake position and supposedly if we start at two uh at as we've defined as the sort of default start position here so if we start at at two and then we say plus and we add one because east is one so the default direction is one then we get three right because the current head is at two two or if we only think about the x position the current head is at at x two and then if we add one we end up in x3 right and that's actually the next head now the question that and of course maybe what we should mention is that this of course works for negative as well so if you have if the position is two and you add negative one then you get one because you're moving in the other direction and the reason then that we have this mod thing is that we're making use of the modulus operators so actually i mean in the best of worlds i wouldn't have had to write that i i should have been able to write something like let's think about this so so this so the same calculation mod uh state dot calls that that's the way i i wanted to use like we want to use the the mod operator but apparently the modulus operator in javascript behaves differently than i had expected in regards to negative numbers but think about it the reason we use modulus here is that because we want to have this wrapping effect right like notice how when we go out of the right end of the screen like it's a torus right we go out on the right end of the screen and we show up on the left end and similarly if we go out on the left hand we show up on the right and and and that modulus operator is actually everything that's needed to implement that because what we're saying is that if the grid let's say that the grid is 12 like right let's think of a clock so if i'm not sure if i can do mod here actually so if i do 10 yeah i can't okay so let's do it in google so so if we do 10 modulo 12 for example we get 10 because so so let me be more clear so so if 12 is the width of the grid and we're talking about the exposition let's say so the number of columns that we have to work with is 12 and that means that 0 is an okay position 11 is an okay position 12 is not an okay position so if we do 0 12 modulo 12 that means that it's the zeroth position so what i mean is that 12 is the size of the grid and 0 is the position that we want to position the next head in if we don't think about this wrapping around right like then you could say position 316 right like even if you have a grid of 12 actually i mean we could do that that's that's the point of modulo so if we do 316 modulo 12 that means that if you try to move to position 316 you should actually be at position four because you've wrapped around you've looped around multiple multiple times but if we just think about the edge cases right like zero yields zero so that means the zeroth positions that means we're not changing zero and if you do 12 you also get 0 because 12 modulo 12 like 12 divided by 12 gives a remainder of zero so that also puts you back in in position zero which makes sense because we're saying it's zero indexed right so so because we have the zero index the max index is 11. so when we try to go to 12 we should wrap around back to back to zero so maybe i'm not making a superb job of explaining this but but every number then between 0 and 11 inclusive will be the number that we pass so if we pass 2 we get 2 if we pass 3 we get 3 if we pass 4 we get a 4 and so forth but if we pass higher numbers which happens when we are at position 11 and we pass one right so or we add one right so this is more like the scenario that we have we are at position 11 we pass one and then we do modulo 12 of that so that gives us 12 that we do modulo 12 on and that gives us zero that makes us wrap around back and let's let's jump into note quickly and look at this so actually i should have done this in notes from the beginning so so 10 modulo 12 gives us 10 uh 10 right and but 12 modulo 12 gives us zero which wraps us around backs similarly 13 then gives us one but this is a case where that we're never seeing however what i would want is that negative 1 should also wrap so negative 1 should put us in the other end of the 12 and that's the way i was expecting that that modulo was behaving so let's see can we actually can we require the base library from here so let's try to require base oops sorry base equals required oh sorry because i now i declared it twice but messed up so let's restart jump back into nodes so let's require the the base library sorry i'm such a confused person so let's jump into node and let's say const base is equal to require from the current directory the file called base let's just be specific and say dot js right and that works then we have the base library and base i mean the base area that we've defined in this project and base has the function mode right so this mod however works differently i mean it works the same if you pass 10 and 12 again then you get no sorry it's the okay sorry for for other reasons i did it in the other order so here i pass uh so this if i pass it this way i mean 10 modulo 12 then we get 10. if i pass 12 we wrapped around to zero similarly for 13 but again we never end up in that scenario but now if i pass negative one we wrap around in the other direction and end up at 11 and modulo 2 and so forth so so yeah and that's a different implementation of of modulo uh and i think i left a comment here yeah i left a comment here to link that you can check out if you're interested in the source i think that came from a stack overflow post or something like that so anyways that was those one of these moments where you go like ah excellent like it's awesome when when math can make problems that seem a bit tricky to solve in programming and but math makes them trivial those are the good days right but anyways so that's why we do modulo here so what we're saying is that this is the raw quotation marks the raw new position and then we say take that position and do modulo of of the the size of of the rows or the colds depending on which one we're working with so that we wrap around but yeah that's that's next head and so next snake is is based on on that next head essentially and yeah the randomness here we've talked about the initial state we've talked about next we've talked about enqueue we've talked about oh my god we actually talked about everything now so yeah i think we've talked about everything and that sort of covers it in in getting to the point where where the snake game is operating uh something like this because we also looked at the the web html and js file and of course i mean i also have this web.css file with just some basic styling in order to make this look a bit prettier i mean if we remove i'm not even sure like if i remove this stuff it looks like this right i've actually zoomed in so this is the this is what we actually draw on the canvas but this is just some basic styling that i added in order to make it look like this but yeah that's it before we wrap this up let's actually also look at the cli so the command line interface so i'm opening up cli.js right and let me just map a keystroke here in vim to run node on cli.js or to run cli.js through node so if i just hit that we're running this and again you can see this works fine and actually i mean this is a pretty short implementation as well so the game loop is a bit different here we still do this sort of showing and stepping but what i do is i set an interval yeah so what we do is we make use of set interval right which is this function in javascript that calls a function with a regular interval it's also expressed in in milliseconds but here actually i run it every 80 milliseconds so yeah for some odd reason i chose a different interval for the terminal application maybe we should change this to 100 in order to sort of make it have the same speed but never mind i mean that we can trigger the change but essentially what this set interval does is that it it does these two things right if we pass a function to set interval that first calls step and then calls show and actually i mean now that i think about it what we could have done is we could have said pipe step step and then show like so over 80 and that should be the same that should be the same thing right and actually that didn't work and i think it has something to do with like the console log here or something like that so like the context disappears but never mind let's not think about that now and either way i mean piping here is not necessarily a sensible thing to do because a step and show are are mutating functions or there are functions that like i mean compose and pipe we usually use when we actually want to pipe compose functions like because we're actually passing data through now we're just do saying do this thing and then do that thing so like never mind but anyways so set interval what it does is that it calls step and then it calls show and it does that every 18 milliseconds and what show does let's start with the show right so so both of these both show and step or functions that don't take any arguments and show what it does is that it console logs this strange character which works as a clearing right like if you think about it actually if i if i remove this i think that would be the most simple way of describing this like if we remove this and then redraw you can see that the game works right but if i if i scroll out you can see we have multiple versions of the game where the the lower one this one here in the bottom uh this one is is the active one because that's the freshest one the the other ones are histories and actually we are we are printing and printing and printing so it's not like it looks static but it's not actually static i mean it's like a moving like these old animated movies like where you draw where wherever where you pull past the strip of multiple images and that's actually exactly what happens now like this is a strip of multiple images anyway sorry let's stop thinking about that now it's pretty interesting but um if we if we add that character we keep clearing the screen all the time so that we're just it's it's like clearing the canvas so that's that's the first part part of show like we clear and then what we do is that is that we have these uh these functions on the object matrix right so so here you can see we have a comment that says matrix operations and then following that there's a constant called matrix which is sort of a module with a bunch of functions that operates on matrices and actually i mean i use the word matrix here indicatively like it's not actually truly a matrix but what we have is that we have an array of an array like we have a twodimensional array where the first i think first i do rows and then i do columns or maybe the other way around uh so anyway the the things under matrix under the matrix module are then things that operate on on this type of structure uh so what we do is essentially then that we say okay matrix dot to string of mate matrix dot from state given the current state so here we probably could actually use pipe in a sensible manner so what we're doing is that we're saying yeah pipe matrix matrix from state and then matrix two string and we're piping that through the state ah so this is probably the reason why i didn't do this because the line turned out to be longer like if you compare the two lines this is actually longer but that should work fine as well and like if we run that that doesn't work fine oh sorry my bad this is probably why the other thing didn't work as well we're not using a raid syntax i should pipe like that yeah sorry so that's probably why the other thing didn't work as well no maybe didn't have anything to do with the console log but anyways uh so yeah we could use a pipe there instead but as just said i mean even even if i remove that sort of array here you can see that this line is longer and i just figured never mind let's just do this but anyways both of these things are equivalent but yeah maybe maybe this one is more clear so maybe let's keep that one i guess i didn't because of the length of the lines like you can see we're at 88 we're at column 88 but anyways let's keep it like that for now so so that's show so what it does is essentially it clears the screen it says construct a matrix from the current state remember the state is the same kind of state that we used in the web gui right like that's what we're saying like we use the same state tree but we do different things based on the state tree and thus we can show a command line interface and we can show a web interface so from this current state we we produce a matrix and then we take that matrix and we pass it to two strings so what we do is that we produce the matrix and then immediately we turn that matrix into a string so actually i mean maybe you could argue that i've made it unnecessarily complicated in some way and maybe we should find a way which is more similar to the web approach where we sort of just immediately do what we or display what we want to display but to me this seemed like the easiest approach like having this intermediate data structure that's this matrix like thing because i mean if you think about it we print this pretty much as as a matrix right like this is this has a number of rows and it has a number of columns and actually if we look at two string here in the matrix module you can see that this is where it becomes obvious that it's fairly trivial because two string takes i wrote x's x's here because like usually in functional programming you can you will see people say like x's or s's or something like that to indicate that you have an array of something so you have an array of x's here but i i tend to write x's x's i'm not sure if that's conventional i hope that's conventional because it seems sensible to indicate that it's an array of an array of x of x's so and that's why i say x is x is here on the outside and then x is here on the inside so the way this works is that we map over the the outer array and then for every inner array we join up all of the values with a space if you think about it you can see here that there's a space in between there's a space in between all of the different dots like if we didn't have that space uh probably this one yeah this actually does work right this doesn't look very nice also because columns are a lot narrower than than the rows so so we need that extra space in order to sort of make it look a bit more nice so we join it up with space and then we join up each of these rows with a backslash r backslash n which is essentially a line break so that we can print it as a single string that that sort of looks like a grid and actually i just realized i used to have a 0.3 or not a 0.3 version of this but rather a version that's more similar to the make function here where instead of actually calling map on the axis of x's we say map and past the axis of x's because i guess that could be more elegant than this but anyways there are multiple ways you can rewrite this function and some of them are probably a lot more elegant than the way i've written it now but anyways that's the two string function and of course if we think about this method again like what we're saying is that we first do from state and then we do two string so we start with this from state and then we do two strings so from state what that does is that it creates one of these excess of x's it creates one of these grids or one of these matrices uh containing the appropriate values and how we do that is essentially by piping right we say well we need to pass this state so we take the state as an argument and then we pipe it through a few functions but the first function makes the matrix the second function adds the snake to the matrix the third function has the apple and the fourth function adds a crash if there is supposed to be any crash so again these are sort of immutable methods in order just to keep my head straight in this so matrix.make we can see up here right the matrix that make here i called it table and not state because a table is anything that has calls and rows but i mean actually what we will pass is we will actually pass this date but since we only care about the calls and the rows i figured i'd call it table here and what we what make does is essentially that we use this helper function rep right so if we look at the base library uh cons rep here we have the implementation of rep and what rep does is that it takes a constant and then it takes an n and then it maps this constant using the function k which is the const function over the range from 0 to n so this sounds a bit bonkers but what this actually means is that if if you have actually let's let's jump into node and let's look at this so a const base is required right and then we have the base library and then we can say base dot rep and if i say a and then i'll pass 10 you can see that we get 10 a's if i get past three we'll get three a's right then if i instead of a if i have one here i'll i'll essentially get an array with this thing repeated the number of times as the second argument that we're passing and rep was implemented in terms of range and what range does is just that let's see if i can remember the syntax if we do this right then we get a range from 10 to 20 we get an array of all the elements of 10 to 20. so what we were doing is that we were mapping over that range in order to have an array of multiple elements and what we were mapping is that we were mapping the function k of the the constant that we were passing so when we did base dot rep a 10 here up in the beginning for example then our constant is a so if i say k of a then i have oh sorry bass dot k then i have a function that accepts an argument but it doesn't care about which argument it it's passed regardless of what argument is passed it's going to respond with a and that's how we can when we map so so actually let's let's do that manually like if i have that range from 10 to 20 and then i map over that and if i map k of a we will replace oh sorry base k in base.k we will replace all of the values in the rearray with a and that is essentially the way that a rep works and yeah i guess range and k as well and and map but anyways so that's why we do rep rep here so so i think it's it's pretty interesting i mean what we do is we repeat the repetition of period or this the string period over the number of columns that we have in this table we do that for every row that we have in this table so that's a pretty concise implementation of making a a twodimensional array filled with dots right so that's the first thing we do we make the matrix based on the state we make the matrix from the state but then here we have these three functions that we want to use to add additional things to this to this matrix we want to change particular we want to adjust particular cells in this matrix and note how we're passing states to these because essentially this one only requires the state to be passed once but these actually require the state to be passed twice so we'll invoke them like this so add snake is a method that can be defined only when we know what the state is and this i mean i was struggling a bit with this i think this didn't turn out super nice so if you have any suggestions of how to rewrite this properly super interesting if you want to post anything about that i was toying with the idea of probably using the s combinator or converge or something along these lines but probably we could find out more sensible ways of expressing this but anyways what we do essentially is so add snake what it does is that when given some state it will it will produce a function that's essentially a pipeline where we spread the mapping of setting x or rather i should say spread the result of mapping the value x over the snake so essentially this is the thing about it i mean this looks a bit hairy but like but actually it's not that strange i mean so the thing about it like the snake in the state is an array it's an array of positions so what we do is that we map the function of setting x and setting x in the matrix takes a particular position and so by mapping that we get a a list of functions that we then spread over this piping so we spread it into arguments so we make a function that went past a state we'll run that state or sorry not when past the state when past a matrix we'll pass we'll run that matrix through a bunch of matrix dot set transformations that set sets x at that particular position and if you look at set i mean set is also fairly straightforward what it does is that it takes a value and then it takes a position and what it does then so the position is then a point right maybe i should have said points or something that has an x and y and it calls adjust on the y or adjust at the y position but then passes the adjustment of the x position of the constant of the values so so what we do i mean actually i mean if we if we express this in a less strange manner actually what this is is that we're saying well i mean if we would do this in a mutating fashion uh what it does is that it takes another argument because it's point free right so so it takes it also takes the matrix and what we do is that we say the matrix uh of the position y and then position x is equal to the value and then we return the matrix like and then we return the matrix so that's essentially what what the set method what the set function does but but now we're mutating and so now we're trying to do that without mutating and when doing that we also got rid of the matrix variable here and and of course adjust is a function that we defined here uh in in our base base helper library but of course it's also available in a lot of different libraries and what adjust does is simply that it takes an n which is an index it takes a function and then it takes some kind of collection some x's and what it does is that it changes it runs the function at the index n of the x's right so so it's a way of if we go back here right like if we say uh list index equals value or more specifically if we say function over if we run a function over the value at that index right that's what what this version of adjust does and then and then we pass k here because we're not actually interested in running a function over the value we don't care about the old value we just want to replace it with a new value so that's kind of a general version of of adjust and yes so so this we do in order to to so essentially what set does is that when given a value when given a position and we're given a matrix it produces a new matrix that looks like the old matrix but where the value at the position has been updated to the new value and that's essentially what we do with set right and so that's why we use it in in add snake and we also use it in add apple and actually not add crash because here we did a more simple implementation i guess but yeah that's how we use it in add snake the way we use it in add apple is much more simple much more simple then we just simply say matrix.set and we set uh to an o at the position of the apple right so state that apple contains a position and we're just saying matrix that's set at that particular position right so i mean this we could change to an a and then if we run you can see that we now have a's instead of o's that represent the apple uh so that's the apple and then the crash is very simple here we just say that okay if the snake length is zero in other words if we don't have a snake if we've crashed or if we just started the game then we map the mapping of the constant dash so over this grid think about it the grid is a list of lists so over every column or row depending on which order we structured anything maybe it's row so over every row we map but we map the function that is the mapping of every column and over that we map the function k which is constant that returns regardless of what it gets it returns whatever we passed it and what we passed it in this case happens to be this dash symbol or this this pound sign this uh hashtag and that's only what we do if we if we don't have a snake so if we've crashed but if we hadn't crashed then we passed id and why do we pass id because id is the identity function so that means that well if we haven't crashed then the grid needs to stay the same if we didn't do that let's just say let's say we did this in both of the cases so instead of doing id we do this mapping again then it'd be a constant crash like we're just it looks like constant we're actually just redrawing this constant and recomputing this constant all the time but yeah so so that's why we need to to pass the id and if we didn't do this this mapping of pound that wouldn't be the end of the world it would just not be obvious when we've crashed so what we want to do is visualize like like we did in the web right like here when we crash we have the screen sort of turns red like that right and here in the terminal we want we want every position to be replaced by a dash and that's that right that's so these are the matrix operations that we have we we can make a matrix we can set something in the matrix we can given some state produce a function that when given a matrix adds that snake to the matrix similarly for the apple and similar for a crash similarly for a crash and then we can take a matrix and turn it into a representable string and then here we have the from from state function that essentially first makes a matrix adds a snake adds an apple and adds a crash all in order so that we can simply just call that from from over here uh in our game loop when we want to show okay that's that's show then we also have step but step is super trivial similarly if we go up here into the top like similarly to the web right like if we go back to web.html you can oh sorry not so web.js you can see here in the top that we have this mutable state where we say that the state is equal to initial stage for some reason i chose lowercase as since uppercase as here that makes no sense but in the cli here we have a variable called state which is which starts as the initial state from the snake and that is the mutable state and the reason that that's mutable is of course that we need to listen to these key events so i'm not gonna bother you about how this listening to keys work but this seems to be i like the way we do it in node when we want to listen to key presses so we capture what's in standard in and if we happen to press control c we need to exit the process because people need to be able to exit the program but if not then i'll just do two upper on it so so we don't have to worry about lowercase w or uppercase w and then we just look for wasd as as in the webcase right and hjkl and we look for up left down right arrows and what we do is actually the same thing let's let's look at this so yeah so the state is equal to the enqueuing of the old state and the new move and then we break and this is the same thing as we had here in the web where we said okay nq based on the new state this new move and compute a new state from that and and replace the mutable state with this new state that's computed and that's the way we do that and yeah i guess i guess that's pretty much it so to do that read line we needed to read in the base note library read line it seems that there are other ways of doing it but this seems to be the easiest way so yeah it kind of seems like that's it it seems like a lot of cold in some sense right but if you think about it what i would argue and what i would argue is that what we've done is that the snake implementation is actually only this file it's actually only snake.js like this is this is the implementation of of snake the other stuff regards how to display the snake game like what graphics version or engine you want to use your snake with what gui you want to use your snake game with so which way you want to display snake to the user and which way you want the user to interact with your snake game so again like if we think broader than game programming functional programming is really susceptible to modularity and so what i mean is when you produce small functions you can really quickly feel how they become very composable and very reusable but yeah i mean but if you actually know exactly what you're building and you know that you're not expecting any change and you have a strict specification then yeah maybe you don't need to be worried about change but if you are worried about change like if you're building an application that might change over time or if you're building something that might be shipped to multiple platforms then approaching something even like game programming kind of like we've been approaching it today i think actually makes a ton of sense what do you think let me know in the comments and let's discuss beyond that if you thought this was interesting and if you want me to decompose any other games let me know like tetris or pong or whatever i mean shoot something in the comments either way clearly this code can be improved a lot but hopefully you find something useful as we dove through this piece of code yeah i'm christopher i'm the guy that you just saw in this video i hope that you liked the video and i really hope that you felt that you learned something if you did like the video i would suggest that you check out my youtube channel the link to my youtube channel is in the description so thank you again very much for watching and i hope to see you in another video either here on this channel or over on my channel i'll see you in the next one