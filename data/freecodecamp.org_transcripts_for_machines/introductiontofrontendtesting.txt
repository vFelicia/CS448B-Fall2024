so thanks for having me it's great being here thanks to robert and daniel for giving me the opportunity to speak what we're going to discuss today is just the general overview to testing i'm going to talk about what is testing why do you need testing um it's not going to be too technical all right so if you already have some experience uh i hope it's not too boring okay um i was planning on doing like a quick live demo at the end where i can actually show off how you can test some small web application which unfortunately since technical issues we can't do today but i'll just walk you through the code on github real quick and see to make the the best out of it i guess right quick bit about myself where am i well my name's hans like i said already i'm not a frontend dev okay yeah full stack of frontend devs i am not i actually have a java and csharp background and just recently got started with ruby so if you see any code that looks like garbage is not my natural habitat okay i am tutoring at the technical university so i'm helping out with teaching there coincidentally in the subjects testing and software quality assurance so you see how this how this works yeah and i myself am a big fan of testing why do i like testing my first job was in a testing firm um and yeah i like testing because it like protects us from the code from the evil that is code okay what do i mean by that um no program is kind of hard a lot of people have written about how software today is kind of sucks i remember an article i read that was titled the coming software apocalypse it was really like oh my god we're all gonna die um problem is software's really complex today and that causes a lot of issues okay um what i mean by software is very complex quick guessing game for you all what do you reckon an average car like not average but luxury car today like smart car uh how many lines of code does the software in that car just the software stirs the car and everything how many lines of code are in there you reckon it's going to be 1 million is it going to be 10 million or 100 million give me a show of hands so i know you're not asleep who thinks it's 1 million okay one all right who thinks it's 10 million 10 million lines of code in the car a bunch of people who thinks it's a hundred million just one okay was a trick questions actually 600 million lines of code okay 600 million lines of code for a freaking car that's what we've come to complex code means a lot of errors all right um you know it's like you touch some piece of software and basically breaks as soon as you're like poked it an example i always give for critical software errors is the story of the ariana anyone has a clue of what ariana what the ariana is exactly yeah it was a rocket that was built in 1996 by european space agency and the story about ariana's rather sad one they built this thing they developed it for 10 years cost about 400 million bucks then i launched it and it went up like four kilometers and then it blew up because someone didn't convert some floatings into ins properly and the rocket did like a flip and then went bang okay 500 million lines of code because of a teeny whiny era that was almost no more than 20 years ago uh a more recent story um maybe you followed uber selfdriving cars um there has been an issue with one car in the beginning of august the car basically ran over pedestrian like full stop just went through and they found out well it registered her well no problem with the sensor sensors but for some reason the car decided not to stop okay so i just went um which is very sad so we have some issues with software there's a bunch of problems what can we do to avoid these issues obviously we do testing okay so it doesn't matter if you talk about cars or web applications or just small functions the concept's always the same you have some components some system and it's supposed to do something in a way of like a car is supposed to start properly your web application is supposed to display some values properly this function right here is supposed to divide some numbers calculate the division easy peasy how do you know if it works well how do you check if your calculator works you try it out type in some numbers does it display the correct result if it does so good if not you found an issue this is what testing does you take your system in some state precondition you chuck some values in there and you check if what it puts out is correct that's basically it this is a test okay um what's the issue with this piece of code yeah so what input would make that fail uh yeah if b0 exactly in any other language if this was not javascript it would be an issue this javascript so it just puts out infinity so if you want your code to behave that way then it's actually correct um might be a bug in the javascript language i don't know might or feature we might argue that yeah so we got covered what the test is it's always the same input output on some system okay what does testing mean now i said you check if it works by putting some stuff into it actually man it's kind of kind of wrong actually testing is the process it says here actually of executing a program or system with the intent of finding errors and that's the important part you don't test to check if it works you test to check it doesn't work you reveal errors basically there's this comic that says compares programmers or developers to testers and programmers like i'm making something at the test is like i'm breaking something and that's really what this is about why do you want to break your stuff because if you break it someone else doesn't have the opportunity to right so you find an error you hopefully will fix it not let it go to production and then it won't fail in production that's good we want that why do we want that why do you actually care if you produce working software i personally think it's a bit of our responsibility personal responsibility as developers we build stuff for the world to run on okay we want that stuff to work we don't want to contribute to the health scape that is programming today okay we want to build nice things and i hope you all kind of want to do that if that noble goal doesn't cut it for you want to save your dignity and money because errors that live in the wild are pretty expensive like a rocket blowing up that costs 400 million pretty expensive if you find that issue spend my half an hour testing something finding the issue fixing that bit cheaper yeah and also especially in the security scene where you have issues with security that can cause a lot of embarrassment if you have problems security issues or bugs stuff like that yeah so in reality combination of both i think this should make it clear why you want to test good i got the motivation covered hopefully now we're going to talk about the types of errors that you can reveal with tests thing is i said testing is the process of finding errors okay which errors there's a bunch of errors that can happen many diff different errors we don't have time to cover them all so we're just gonna talk about regression tests or regression errors what's a regression it's something that you've all if you've developed for more than a week you've already seen that it's this situation you develop some wonderful feature you build it and let's say you test it you make sure it works so you try it out try to break it and it doesn't break all good you say you push it to production it's fine let it run there you work on some other stuff three months later you decide to let's try my old feature again like just coincidentally you touch it it breaks like what the actual that's a regression you have something that used to work no it doesn't and everyone's like what happened that yeah to avoid these kind of errors you have regression tests okay so what do people do in reality to avoid regressions um i've actually worked with places or seen places where each time they have a release let's say you have a release of some big piece of spanking software every six months they would spend they had had a manual test suite with several thousand tests and they would before each release they would take a month with something like between 15 and 20 testers and those testers would run a manual regression test suite for a month out of six months development time okay so if you have lots of features lots of stuff to test regression testing is going to take a lot of time we're developers we're lazy we don't want to spend a month testing something each time we release it especially in today's world we have to release fast we can't really do that and the automation luckily smart people have developed a bunch of tools to allow us to automate this process so you don't have to each time you change something manually see if it still works you can instead write your tests by coding so you see it here there's some i don't even know what the framework is basically you write the um the test code and that will do this process of putting stuff in checking if it works automatically and the good thing is well you spent some time developing the test beforehand but now you can rerun those tests at the press of a button and you see that here you don't even have to press something like the framework just detects if anything changed if you change your code it's going to rerun your test and it goes like this okay so test automation can really help you avoid these doing the same thing with testing over and over again what in an application can you test so we get covered okay what kind of errors do we check where are we going to check them if you have some application um there's very many ways to many things to actually test the most intuitive thing would be um let's assume you have an application that has this email input field where people enter the email and they say okay and then at some point they're gonna get sent on registration mail or something like that okay the intuitive thing maybe would be to have your automation system really interact with the application you'd have the web web thing with the input field and button and your framework would interact with that input field type something and automatically press a button and at some point it would check some mail server if an email with the correct content has arrived right would work but there's other ways to test the application you don't always have to test the whole thing together that's why i say the whole system end to end you can also simply take some components out of that system and test those like in isolation that's for example an integration test where test components together or unit tests where you test a single component for example just to make the class that sends mails it gets a string and it sends a mail you test that why do you do that two things first of all each of those levels so to speak reveals different errors again if you have a unit test that's very good at uncovering issues that are related to functionality some small issue with the component integration tests much better with finding issues that occur when different components don't quite work together as well as this should right or endtoend tests imagine these really do basically what a user does so they're often called acceptance tests um that would detect like stuff like is a button actually visible because it will actually try to click the button and it isn't there well you found that so good at different things that's the fury part oh no it's not quite sorry um the other thing with these levels is that they have equal cos not equal they have different costs associated with them unit tests are very easy to write and they're very quick to run and to end tests not so much they're harder to write take longer to execute and this is where the testing pyramid is going to come in who has already seen that before today okay how many times like daniel how many times have you seen this in the talk exactly you're all gonna i'm happy that i'm the first one to actually show this to you if you attend any test about talking at all ever again you're gonna see this it's very very popular because it's true of tells you how should you automate your how should your automation test suite look lots of unit tests bunch of integration tests not too many endtoend tests so the balance between cost and risk what kind of issues can you find how much money do you want to spend that's it with fury but alas there's no uh live demo instead i whipped up a quick application that i would normally how do i get all full screen no no it doesn't work something ctrl p shift f command shifter yeah we got it i'm not a mac user in case you haven't noticed all right so i whipped up a quick application that i would normally i prefer a test suite and would normally run that we quite can't do that so instead i'm going to show you the application i will show you the tests i wrote and you just have to imagine that they actually run okay if you can do that use your fantasy so let's look at the application first fair word of warning i had to come up with an idea what am i going to build that's easily testable and demonstrate some concepts of testing and the only thing my brain could come up with was let's make an application where you manage kittens that fight each other to death kind of thing i don't know so this is not it because that doesn't work sorry about that oh come on enter right why doesn't it go oh my god did i mention i'm not a mecca user jesus what do i need to do don't do that all right what yeah yep okay how do i copy it command c no no no not enter i'm not gonna hit enter command and now um okay can i paste something here caps lock maybe like that [Laughter] maybe we found a bug through testing that i've never witnessed something like this maybe does it need does does it need like an http in front maybe i don't know just can i press enter now all right so um right so i made this a monstrosity um you can see you have a list of kittens all right and it's fairly simple you can also edit and delete them let's have a look at some kittens i i don't like that one i please didn't test it no what's actually happening i didn't test it on safari that's exactly right okay we'll just have to do it that way so um as you can see you you can put in some stuff and it should hopefully yeah so it will update this score that tells you how murderous this kitten is okay and um so what can you test you can do unit tests or endtoend tests let's look at oh my god not the same thing again with github how can i get to a new tag jesus christ okay github.com so i'm gonna just quickly show you what the unit tests could look like all right for that and like i said you will have to imagine that they just work let's see right so this is an angular application doesn't really matter that it is um just gonna have a look so this what i showed you that the score that's calculated that's a perfect example for a thing you can unit test okay because it's fairly simple just take some values and puts out the number so let's look at what the code look looks like so that's it doesn't really matter what the syntax like you have this component the battle score service well has a method calculate battle points that takes a kitten and returns a number okay and what does it do then well if the kitten's null there's nothing to return returns zero otherwise it takes the attributes of the kitten cuteness speed blah blah and calculates your battle points easy peasy so very clear what the function is very easy to test unit test right this is a unit a simple simple component simple function to test now let's have a look at the test bit more stuff um still can't move so i have to imagine me pointing so this is a test file and remember what a test looks like just number back you have a component you have some input and you have some expected result we're gonna use that here first of all you can see in like the line six line nine we create a system the thing that we want to test in this case it's a battle score so it's the component we want to test our calculator whatever and then we have actual test cases that start with it in line 12 20. okay let's look at the first one line 12. um first of all has a name what does it do it should return a correct battle score and then you set up your input remember the input of the battle service function was a kitten so we create one with its attributes strength and so forth next line after that is the actual execution of the test where we take the function and we put stuff in this is our actual let's do it part and then we record the result now the last thing we have to do we compare the actual result with what we get back and that's the expect expect the result that what we actually get with what we want should be 10. and similarly we test if it works for now easy peasy right normally it's a an issue of just executing command in this case ngtest and this will run all your tests automatically and will also watch your files for changes and if you break your application you refactor it and you do something bad it will show you well you have an issue easy peasy let's have a look at the end to end tests so this is the component a single component that we can test and go back to the application something that is lends itself to an endtoend test would be scenarios like does it display the list in the index correctly or when i press delete is it actually removed from the list or if i edit it in the edit field is it actually updated in the index things like that so multiple views needs the whole application that will be an end to end test and we're going to have a look at what an endtoend test looks like angular luckily makes it fairly easy to set this kind of stuff up like i said another frontend dev so i'm pretty happy and you'll already notice when we look at this uh ab spec endtoend test file it's a bit more involved right you have stuff like page that navigate to i mean the concept is the same you do something and then you have an expectation an expected result um but you see gets longer involves more pages for example in line 25 we just check if we click the button remove it from the list and you see it's already getting a bit like longer and needs more syntax also uh maintenance is harder you see that we calc we get items by selecting the links in the actual html all right um imagine if you change that up if you give it if you use css selectors and you change your css your tests are going to break that won't happen with your unit test good how the hell am i going to get to my presentation chrome where was it there it is okay so that was the practical part sorry again it didn't work out let's summarize what we've learned today first of all programming is its own kind of healthscape which i hope you don't have to learn too much but testing can help you with that okay we learned about regression tests why use them and we also talked about what test automation and test levels is so i hope i didn't give you too much stuff like okay very risky show of hands uh who's kinda like this was a bit too much for me like i did who's like that show of hands okay one two all right too fast who could follow along nicely and understood most of stuff wow okay thank you and who's like i don't give up okay never mind um so that's for the summary if you're interested to learn more about testing first of all just send me a message um i'm always happy to help people out like i said i'm very passionate about testing let me know what you think let me know if you have some problems with testing something specific talk over that and there's some great books out of software testing or the art of unit testing and you can also visit the ministry of testing website they have great resources so that's it from my side you can check out the slides hosted them with reveal jess gonna have a look at the other thing what was it we mark jess gotta check that out and yeah do we have time for questions sure but thank you for the talk yeah thanks