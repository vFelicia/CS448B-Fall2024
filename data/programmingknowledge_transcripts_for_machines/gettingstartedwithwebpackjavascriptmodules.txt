hello guys welcome back to another tutorial hit the bell icon button so that you don't miss out any tutorial I'd like to welcome you all to this course on webpack sponsored by edge Mullenix my name is Mathew rammer and I'm looking forward to guiding you through the virtual jungle which is web pack and JavaScript modules in the first place I will be talking to you about JavaScript modules because knowing something about JavaScript modules provides crucial backgrounding to anyone who is seeking to use webpack with facility there are two more tracks this track and a following track 3 in this initial set one for webpack course training these two tracks along with the overview at track 1 you've already worked through with me comprised the information I feel supplies to you with the basic prerequisites for you to go on and learn web pack proper and properly JavaScript module systems are intimidating to most developers but understanding it is vital for modern web developers the intimidation is felt by more than just new developers just as good thinkers divide their ideas into categories and subcategories so do good programmers divide their programs into modules and functions modules can be compared to entries in an encyclopedia each entry collects around a particular topic good modules like entries you would expect in an encyclopedia are highly selfcontained having distinct topical practical use this allows them to be shuffled removed and added as necessary without disordering the system overall there are lots of benefits using modules in order to avoid a Frankensteinian orifice codebase once referred to as spaghetti code one of the chief of these benefits is maintainability a welldesigned module will lessen the complex interdependencies within the parts of the code base as much as possible so that it can grow and improve more or less autonomously maintaining modules is much easier when modules are decoupled from one another's pieces of source code going back to the analogy of an encyclopedia if you wanted to update an entry it would be a nightmare for a small change to one entry to require you to tweak every other entry as well instead you'd want the formatting and layout so arranged as to be able to make improvements under any and each topic without other topic entries another benefit to opting for modular design is the ability to use name spacing no name spacing comprises a set of symbols which are used to organize objects of various kinds so that these objects may be referred to each by name name spacing is beneficial because JavaScript demands that variables outside the scope of a toplevel function are global now scoped determines the accessibility visibility of these variables but only within the program variables defined inside a function are not accessible visible from outside the function because of this it's common to suffer namespace pollution we're completely unrelated code are sharing clusters of global variable names sharing global variable names between unrelated clusters of code is bad development practice since doing so allows the situation in which unrelated functions may be depending on the same variable or method name modules allow us to avoid this namespace pollution by creating a private space in which to Park our variables another benefit of modular practice is reusability of code fact developers do reuse their code from old projects recycling it into new projects as they see appropriate for but let's take this example suppose you find copied to your current project some utility methods you wrote from a previous project problem if you find a better way to write some part of that recycle code you'd have to go back and remember to update it everywhere else in the project where you'd recycled it so being modular using modules helps you more easily keep track of the code and thus allows you to recycle the code without anxiety's there are many ways to incorporate modules into your programs let's walk through a few of them note the module development pattern is classified as a JavaScript development pattern JavaScript natively doesn't support the class keyword but the module pattern can be used to mimic in your project the concept of a class note in objectoriented programming a class function is an extensible program code template for creating objects classes provide initial values for state member variables and for implementations of behavior using member methods this mimicry simulates pseudo public and private methods and variables inside a single object in a similar way to how classes are created in other programming languages like C sharp or Python this simulation allows us to create a public facing API an application programming interface so as to be able to expose to the world those methods we choose to at the same time the module pattern allows the encapsulation of private variables and methods within a closure scope this may sound trivial but without some sort of encapsulation it is a matter of time before two modules conflict with each other encapsulation is essential to prevent conflicts and ease development there are several ways we can accomplish the module pattern in this first upcoming example we'll be using an anonymous closure by putting all our code in an anonymous function that will help us accomplish our goal note an anonymous function is a function which has been declared without any named identifier to refer to it as such an anonymous function usually is not accessible to the developer to reference after its initial creation remember in JavaScript functions are the only way to create new scope look at this piece of code this function prints out the string hello world bias having used this construct our anonymous function has its own evaluation environment also known as its closure and upon closure we can immediately evaluate it note a closure comprises a combination of a function bundled together enclosed with references to its lexical environment the surrounding State in other words a closure allows us access from within an inner function to an outer function scope in JavaScript closures are created every time a function is created and always at function creation time to use a closure define a function inside another function and expose it exposing a function is to return it or pass it to another function the inner function having been exposed will have access to the variables in the outer function scope even after the outer function has returned this procedure then lets us hide variables from the parent global namespace and this hiding provides for a distinction between public and private by using this approach you can also use local variables inside this function without risking accidentally overriding existing global variables the first console.log output hello world while the second console.log outputs hello i am a global variable smiley face no the closure nonetheless still has access to the global variables note that the parentheses around the anonymous function are required this is because statements that begin with the keyword function are always considered to be function declarations consequently by us using surrounding parentheses we avoid any declarations and create a function expression instead another approach to modules used by libraries like jQuery is the global import a global import is similar to an anonymous closure except now we pass in Global's as parameters take a look at this code in this example global variable is the only variable that's global the benefit of this Global important on a'mma sin closures is that you declare the global variables upfront thus making variables emphatically visible to developers working with the code another approach used by developers is to create modules by using a selfcontained object to interface like so this approach lets us decide what variables or methods we want to keep private for example my hello and what variables and methods we want to expose by putting them in the return statement this approach is very similar to the global imported except that this way you ensure all methods and variables are kept private until you explicitly choose to expose them know the syntax of all these approaches are often described as IIF ease or if ease immediately invoked function expressions the approaches you have looked at all have one thing in common this is a use of a single parameter global variable to wrap the code in a function thereby creating a private namespace for the global variable by having used a closure scope while each approach is effective in its own way each has its own particular downside let's examine the downsides of these approaches one by one let's soon we have two such modules a and B B must have a to operate but a does not depend on B let's also assume that for sake of good practice a and B are in separate files for one as a developer you need to be aware of the right dependency order and to remember load your files strictly in that order as a developer who is managing dependencies getting these vital things right gets harder the larger your software becomes another downside is that any of these modular approaches can still lead to namespace collisions what for instance if two of your modules get named the same name or what if you have two versions of a module and you find you are needing both can we design a way to ask for a modules interface without going through the global scope and that's what we'll be answering in our next lesson other module systems in our next lesson will be introducing and discussing common j/s and asynchronous module definition I'd like to welcome you all to this next lesson set one of the course on webpack sponsored by edge onyx my name is Matthew rammer and I'm looking forward to guiding you through the virtual jungle which is JavaScript modules in our previous lesson we covered a theis immediately invoked function expressions as a way of addressing JavaScript modules in this current lesson we'll be answering the question can we design a way to ask for a modules interface without going through the global scope CJ s common j/s modules are one method to deal with these problems situations a CJ s common Jas module is essentially a reusable piece of JavaScript which exports specific objects making them available for other modules to be able to requisition for in their program now CJ s is a volunteer working group and it designs and implements JavaScript API s in the case of declaring modules nodejs frequently uses this volunteer working group format for modules for CJ s each javascript file stores modules in its own unique module context just as if it were wrapping it in a closure in this scope we use the module exports object to expose modules and we use require to import when you're defining a CTS module it might look to you something like this we use the special object module in place of reference of our function into the property module exports this lets the CGAs module system know what we want to expose so that other files are able to consume it then when a developer wants to use my module she can require it in their file like so there are a few obvious benefits to using CJ s over the module patterns we discussed before these are the benefits that it avoids global namespace pollution by making our dependencies explicit and provides a very compact syntax note CJ s takes a sir / first approach and synchronously loads modules CJ s using synchronous loading matters because if we have three other modules we need to load CJ s we'll load them one by one synchronous loading doesn't damage performance on the server but it does hurt application performance when you're working with JavaScript in a web browser this performance difference arises because reading a module from the web takes considerably longer than reading from a disk remember for all as long as the script that loads a module is running it blocks the browser from running anything else until the script is finished loading this strange behavior arises because the JavaScript thread stops until the code has been loaded so much for CJ s what if you want to load modules asynchronously what we'd need is called a synchronous module definition or AMD for short loading modules asynchronously using AMD looks something like this what's happening here is that the define function is taking as its first argument the complete array of the modules dependencies these dependencies are loaded in the background in a nonblocking manner and once all loaded they define a call to the callback function given now in general a callback is a function that is executed once another function has come back from being called that is has been executed hence the name call back in general callbacks may serve any prescribed purpose but in our case with AMD the callback is serving to dominate the environment in which a module may be used next the callback function takes as arguments the dependencies that were loaded in our case my module and my other module allowing the callback function to use the dependencies finally the dependencies themselves must also be defined using the defined keyword for example my module might look like this so we see that unlike CJ s AMD takes a browser first approach alongside asynchronous behavior to get the job done note there are a lot of people who strongly believe that in a browser it just isn't favorable to go dynamically loading files piecemeal as you start to grunt code I suspect this disfavour is due to the need for orderly loading so as to avoid omissions of definitions occurring I suspected also concerns dependencies having not been loaded so as to properly relate to one another aside from a synchronicity of loading another benefit of AMD is that your modules can be objects functions constructors and strings even JSON as well as many other types of module can load but CJ s supports only objects as modules no AMD isn't compatible with IO file system nor with any other server oriented features available via CJ s also with AMD the function wrapping syntax is a bit more verbose compared to CJ s is simple require statement for projects that require you to support both AMD and CJ s features there's yet another format available universal module definition or UMD UMD essentially creates a way to support either of the two sets of features whilst also supporting the global variable definition as a result UMD modules are capable of working on both client and server here's a quick taste of how UMD goes about its business as you we noticed none of the modules in the example were native to JavaScript I should know clarity here that JavaScript supports only its own native modules which is why we are and why we have to be simulating our modules here and using them with JavaScript instead we've created ways to emulate a module system by using either the module pattern CJ s or AMD tc39 which is the standards body that defines the syntax and semantics of ECMAScript has lately introduced builtin modules with ECMAScript 6 or es6 es6 modules relative to CJ s or AMD managed to offer the best of both worlds compact and declarative syntax and asynchronous loading note declarative programming is when you write your code in such a way that it describes what you want to do and not how you want to do it it is left up to the compiler to figure out the how here's an example in this example two copies of the module are made from the counter original the first when we export it and another when we require it moreover the copy of the module available in the main J's file is not disconnected from the original module that's why even were we to increment a counter it would still return the value of one the counter returns one because the counter variable that we imported is a disconnected copy of the counter variable come from the module so incrementing the counter will increment it in the module but this won't increment your copied version the only way to modify the copy version of the counter variable is to do so at the place where in the copy has been put you cannot modify via the original module object nor where this original is situated es6 creates a live readonly view of the modules we import these live readonly views allow you to split your modules into smaller pieces without losing functionality thank you for watching don't forget to subscribe to channel if you like the video do give us a thumbs up and share it also check out amazing discounts and offers on our premium poses in the description below