hey guys welcome to the next video on open CV tutorial for beginners using Python in this video we will discuss about smoothing or blurring images in open CV so smoothing which is also known as blurring is one of the most commonly used operation in image processing the most common use of smoothing operation is to remove noise in the images now when smoothing or blurring images we can use diverse linear filters because linear filters are easy to achieve and are also relatively fast now there are various kinds of filters available in open CV for example homogeneous gaussian median or bilateral filters which we will see one by one so first of all we will see the homogeneous filter so homogeneous filter is the most simple filter and in homogeneous filter each output pixel is the mean of its kernels neighbors now in homogeneous filter all pixels contribute with the equal weight and that's why they are called homogeneous filters now those of you who don't know what the kernel is I have explained about kernel in the last video so you can see the last video and in simple word a kernel is a shape which we can apply or convolve over an image and you can use for example numpy to create this kind of squared kernel so in homogeneous filter the kernel looks like this image which you see on your screen so in homogeneous filter kernel K is equal to 1 by the width of the kernel multiplied by the height of the kernel so let's say we want to use a kernel of 5 by 5 then using this formula we will have K is equal to 1 by 25 and then we will have our kernel matrix of 5 by 5 once so let's create this kernel first of all and we will see how to use this kernel for the image filtering using 2d called involution or homogeneous filter so what I have right now here is the simple code which loads this image using matplotlib and this code you might already know because I have explained in detail how matplotlib works and how to read the images using OpenCV one thing to note here is I am just converting the image from BGR to RGB because matplotlib reads the images in the RGB format and OpenCV reads the images in BGR format so this conversion is necessary so let's define our kernel so I'm going to just say kernel is equal to NP dot once and then we are going to take the kernel of five by five so we are going to define this kernel five comma five of once so I'm going to just say n P dot float32 here and then we are going to divide this kernel by 25 because our kernel is of five by five because the formula which we have seen in that formula we have the kernel which was a matrix of once and then we have the multiplication of one divided by the width and height of the kernel so that's why the multiplication of the width and height is 25 that's why I have taken 25 here so now we have our kernel so we can define our destination image using this kernel and we are going to use CV to dot there is a method called filter 2d which we are going to use which is used for this homogeneous filter so here the first argument is the image the second argument is the desire depth of the destination image so for now we are going to take it as minus one the third argument is the kernel so now when we have applied this kernel on our image using 2d filter let's see what the output will look like so I will name this image as 2d convolution and the destination is the final image which we got using filter 2d and let's increase this range by two and let's say we want to show this image on matplotlib in 1 by 2 format okay so I'm going to just run this image so this is the result on the left hand side is the original image and on the right hand side is the 2d filter applied image so this is the image which we got by applying the homogeneous filter using filter 2d function so you can see on the corners here there is little build noise and after applying this to deconvolution over this image you can see all the corners are now smoothing and overall this image is now smooth and or blurred a little bit so these noises are removed or suppressed by this blurring so this is one way of blurring an image using filter 2d right filter to the function now as in onedimensional signals images also can be filtered with various lowpass filters or highpass filters etc so lowpass filter helps in removing the noise or blurring the image etc and highpass filters helps in finding ages in the images now when you want to achieve image blurring we need to convert over the image with the low pass filter kernel now there are some algorithm as I said there are various kind of algorithm available in open CV so we will also see them one by one so first algorithm is the blur method or it's also called the averaging so what I'm going to do is I'm going to define a variable called blur and then I'm going to call a method called CB 2 dot blur okay so this is the method which we will use to apply averaging algorithm for blurring the image and this takes two argument one is the image and second is the kernel so the kernel we are going to apply is once again five by five and now we are going to just see with the result of this blurring method so we are going to just loaded using the matplotlib so range I'm going to increase it by 1 once again and let's see this these three images in one by three format on the matplotlib window so this is the result and you can see the original image the result which we got using the filter to the method and the result we got using the blur method which is also called averaging so the result is more or less looks the same to me because we have applied the same kind of kernel to both the functions so this is the result of filter 2d function and this is the result of the blur function now there are more functions which are available in open CV so let's see them so the next algorithm which we are going to see is the Gaussian filter algorithm so the Gaussian filter is nothing but using different weight kernel in both x and y direction so in the result pixels located in the middle of the kernel have the higher weight or bigger weight the weights decreases with distance from the neighborhood center so pixels located on the side have smaller weight and the pixels located on the center have the higher weight so when we take a 5x5 kernel its result is going to look like this which is shown in the image and now let's see how we can use this Gaussian blur in our open CV code so I'm going to remove this semicolon which I somehow added here and let's declare a variable called G blur for Gaussian blur and then we are going to use CB to dot Gaussian blur so the method name is Gaussian blur and the argument here they are same as the blur method so first argument is the image itself second argument is our kernel we are going to take the same kernel of five by five and the third argument here is the Sigma X value which we are going to take zero for now let's see the result of the Gaussian blur method when it's applied to an image so I'm going to just define one more title which is G blur or Gaussian blur or let's take this name which will be more clear and then our result image is G blur and let's increase the range to four and let's say we want to show this image in two by two format so two rows and two columns so I'm going to run this code and for OpenCV logo the results looks the same you can see for the 2d convolution of filter 2d method or blur method using the Gaussian blur you can see there is a little bit different between the blur method and Gaussian blur method results the Gaussian blur result is more better in my eyes than the blur method let's try this Gaussian blur with another image so I have this image called halftone underscore Gaussian underscore a blur and I'm going to run this code now with the new image and you can see the result now so this was the original image which have too much noise here so you can see the pixels here which have too much noise and after applying the Gaussian blur you can see this IMH in much better way and all the noise is removed so the Gaussian blur method is designed specifically for removing the high frequency noise from the image like this one now let's see the next method which is called the median filter so median filter is something that replaces each pixel value with the median of its neighboring pixel so this method is great when dealing with something which is called saltandpepper noise now if you don't know what the saltandpepper noise is you can open the Wikipedia and under this URL or just search for saltandpepper noise Wikipedia page and you can see more details about saltandpepper noise so you can see this is an image and there are some pixels which are distorted here so there are some pixels where the white dots are there or white noise is there and there are some places where the black noise is there so that's why it's called saltandpepper because we have white pixels which are distorted like salt and we have the black pixels which are which looks like pepper so that's why it's called saltandpepper noise so I have this same image which I'm going to use as a source now so it's called what are not PNG in my case and now let's how we can use the median blower method so I'm going to just define a new variable called median and then I'm going to use a CB 2 dot median method so this method is called median blur where the first argument is the image and the second argument here is the kernel size now one thing to note here is that the kernel size must be odd here so this must be a 3 or 5 or 7 and so on except one okay so when you just give 1 it's going to show you the original image and let's say we just give 3 here as the kernel size or in our case we have the kernel size of 5 so let's take the 5 kernel size here so let's just show this result of the median filter in the matplotlib window so I'm going to just increase the range 5 and let's say this is 2 by 3 matrix now I'm going to run this code and now you can see the results of all the filtering method and you can see the best result you get using the median filter method so when you have this kind of saltandpepper dots on your images then you can use the median filter now let's see the last filter which is called the bilateral filter so by using all these filters for example homogeneous filter or averaging or the Gaussian or the median filter we not only dissolve the noise but we also smooth the edges and sometimes we need to preserve the edges that means we need that all the ages must remain sharp even if the image is blurred so let me show you one example so I have this Lenna dot PNG image so I'm going to define a variable called bilateral filter and then there a method called CB to dot bilateral filter and this bilateral filter takes the first argument which is the image the second argument is the diameter of each pixel neighborhood that is used during the filter so let's take it as a nine the third argument is the Sigma color and the fourth argument is the Sigma space so the speak Sigma color is the filter Sigma in the color space and Sigma space is the filter Sigma in the coordinate space so for this we are going to take this filter Sigma color and Sigma space as 75 and 75 here and let's see it in the result window so bilateral filter and then the result bilateral filter and this gives me error because this image is called Lena dot jpg not PNG so jpg and then we need to increase this range by one to see all the six images and let's run this code and let's see what happens so you can see the result now so let me make it a little bit bigger so you can see them and from here also so now you can see by applying the bilateral filter the edges are preserved in a much better way so here you can see the hat border is blurred but here you can see in the result the border of the Hat our rap is preserved so the images in which you need to preserve the borders then you can use the bilateral filter so bilateral filter is highly effective in noise removal while keeping the edge sharp so these are some of the methods and algorithms you can use to smoothen or blur your images using open CV I hope you've enjoyed this video and I will see you in the next video you