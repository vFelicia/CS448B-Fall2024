hey guys welcome to the next video in Python thread tutorial for beginners in this video we will see how thread synchronization works in the case of multithreading in Python and we will talk about how to use locks in the case of thread synchronization so first of all what is thread synchronization so thread synchronization is defined as the mechanism which ensures that whenever two or more threads are executed in parallel or concurrently and if they are sharing the same resource in that case all the thread should not work simultaneously or parallely on the same resource so let me explain the thread synchronization problem with the diagram so in this diagram you can see there are three threads and all these threads are sharing the same resource it can be a global variable for example so as long as all these threads are accessing the shared resource one by one not at the same time everything will work fine but the problem arises when two or more threads try to access the same global variable or shared resource at a particular time and this kind of situation is called the race condition so a race condition occurs when two or more threads can access the same shared data and they try to change the value of this same shared data at the same time and whenever this kind of race condition occurs the value of the variables may be unpredictable because if two threads are working on the same global variable at the same time you will never know which thread has worked on this variable so the result is the unpredictable value of a variable now let me explain this problem with an example so I have this sample code in which in the first line I'm importing threading module and in the second line I'm just declaring a global variable now I have two functions here one is thread tasks and other is mean task now inside this thread task function I want to increment the value of x every time by one so this is the code for this and I want to increment this value by one ten times so that's why I have used this for loop in the range 0 to 9 so it's going to increment the value of x 10 times inside this loop now because this X is a global variable I have just added this global keyword in front of X so our function knows that this X is not a local variable it's a global variable so this function is simple enough it just increments the value of x 10 times inside the loop and this X is this global variable which we have declared outside this function now in the main task what I'm doing is I'm creating two instances using the threading module with the help of thread class this we have already seen in the last video how to create threads using threading module so nothing new in this I have created two instances t1 and t2 and I'm passing the target is equal to the function name which is this function which is tried a task so both the threads will call the same function tried task and then I'm just starting both the threads with the help of start function and then I'm just using the join methods on both of the instances now here inside our main if condition I'm just calling our main task in which our threads are created and executed and then at last I want to print the value of x when all the thread execution has been completed so let's run this script and let's see what happens so you can see here the result here is 20 which is expected because we are incrementing the value of X 10 times using two threads so the value of X will be incremented ten times by thread t1 and ten times by 22 and as a result the value of X becomes 20 but as soon as I increment the value of this range let's say this is 10,000 and I want to just execute this program once again there is no problem until now we can just run this program again I mean again we will not see this problem because we are incrementing the value of x 10,000 times with a single thread so we have two threads and the result is 20 thousand which is absolutely fine now let's increment the value of range once again 200 thousand and now I want to show you the problem so as soon as you do this you can see that the thread synchronization problem occurs so here you can see the result is not two hundred thousand which we were expecting because for such large value this scenario of thread synchronization is happening so the two threads try to work on the same variable at the same time and as a result the value of x is unpredictable so this thread synchronization problem you will see when you try to work on a same variable multiple number of times so in this case we have a hundred thousand iterations and both the threads try to iterate over the same variable using two threads and the result is unpredictable let's try to execute this once again so you can see the result is always different every time I execute this program because the result is unpredictable so how to solve this problem so one way of solving this problem is by using the locks so first of all let me just change this program and try to use locks in this Python script so to use locks what you can do is you can their local variable here for example lock is equal to threading dot class called lock so this is going to give you an instance of lock now this lock clasp have to method one is acquire and other is released now acquire method is used to lock and release method is used to release the lock so let me just complete this script and then I will explain what does these functions do so what I'm going to do is I'm going to pass this lock instance as an argument of the thread task function so I'm going to just write as is equal to and then we will just pass over lock instance as an argument of this treaded task same we will do for the second thread and because we have passed this argument we need to add this argument here also so I'm going to just pass the lock instance as an argument of this function and now at last what we are going to do is just before we change the value of the global or the shared data we use this lock variable and call the method called acquires and just after you finished changing the resource or the shared data you use a method called lock dot release so once again we have passed this lock instance which we got from this lock class as an argument of this function so this is the lock instance and there are two main method inside this lock class which are acquire and release this acquire method you use to acquire the lock this lock can be blocking or non blocking so this acquire method takes one argument which is true or false by default the value of argument is true which means that this acquire is blocking by default so what does this lock dot acquire we'll do it locks the axis of the shared variable in our case this is X and at this time only one thread can work on this variable whatever thread have the access to this function at a particular time so until and unless one thread execution is completed on this variable after that this lock is released that means that the other thread can work on this variable using the lock once again so whenever second thread wants to try to access this variable it will just lock the access to this variable first of all and then work on this variable whatever you want to do you want to increment the value or change the value of x and then release the lock and releasing means that we once again want to allow the other thread to work on this shared resource so this mechanism will allow only one thread to access this shared resource at a particular time so the Treader synchronization problem will not occur so now let's just run the program once again and let's see what's the result so you can see this problem and this problem is coming most likely because of this problem because we haven't provided ours as the tupple so we need to provide the sog as our tupple so always remember whenever you want to pass any argument using this args keyword you need to pass them as tupple so once again I'm going to just try to run this program and you can see the result is whatever we expected so because we are incrementing the value of x hundred thousand times and there are two threads which are working on the same variable so we get the two hundred thousand result which is expected now let me run this program again and again and you can see every time now we get the expected result which is two hundred thousand so this is how you can solve that thread synchronization problem using locks so this is how you can use locks to synchronize your threads in Python I hope you have enjoyed this video and I will see you in the next video