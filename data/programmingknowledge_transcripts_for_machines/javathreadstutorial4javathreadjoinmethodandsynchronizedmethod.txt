hello guys welcome to the next video on Java thread tutorial for beginners in this video we will see what does join keyword do in Java threads and how to use join keywords in Java so let's get started I'm going to give you an example and uh I will show you how you can use this join keyword so I have this blank project with a blank main method and first of all what I'm going to do is I'm going to Define a simple thread object so I'm going to uh call thread T1 is equal to new thread and inside this Constructor I'm going to uh implement this runable here and uh then I'm going to uh call The Run overload here so implement the method let me close this thread Constructor with semicolon and and this uh bracket and inside this uh run method what I want to do is I want to once again create a for Loop and this time I want to iterate this for Loop to around 10,000 for this example okay and now what I want to do is I want to create a private variable which will be a static one and which will be a integer okay and I will name it as count and and I will initialize this count as zero okay and now what I want to do is I want to increase this value of count inside this for Loop by one every time this for Loop iterates okay now similarly I will create a second thread object this is our first thread object which is T1 I'm going to copy this and I'm going to paste it just below this and I'm going to name it as T2 okay so we have two thread object T1 and T2 and I want to uh start thread 1 and thread two now so I will just call T1 dot start and t2. start okay so what this will do is it's going to start the thread one and then thread two and then what I want to do is I want to print the value of uh count now so say out and I want to print the value of count okay and if you want you can just write so what I want to do here I want to increase the value of count which is this variable and I want to increase this value in both the threads so both the threads will share this count variable and increase its value when we iterate over this Loop grop okay so this count variable is accessed from thread one also and thread 2 also and what uh we expect we want to uh print the value of count at the end of uh the threads one and thread two now let's see what happens when we uh run this program so let's uh run this program and let's see what will be the output so we will run this and here we can see the value of uh count which is printed here is zero now the reason for this is when we create thread one and thread two and when we uh call the start method on this uh thread one and thread 2 this returns immediately when t1. start is called and then this returns immediately after T2 start is called and then this will print the value and after printing the value uh This Thread T1 and T2 will start so basically This Thread one and thread two will not wait to end themsel before printing the value of count that's why this is printing count is equal to zero why because thread one will start thread two will start and it will uh before looping through this uh loop it will print the value of count because this start will not wait until this thread one is dead and thread two is dead and it will print the value of count before the end of these two threads that's why we can see the value of uh count is equal to zero okay now to solve this problem what we can do is we can use use a keyword called join okay so what we are going to do we are going to use the keyword called join on T1 and T2 so let's uh introduce this join keyword join and this joint throws so we need to enclose this joint inside our Tri catch block so when you click this bulb you see that add throw declaration or surrounded by Tri catch so we will surround it with uh Tri catch block and inside this Tri catch block we will also call t2. join okay so what does this join keyword do here okay so let's see what this is doing so in Java this join method can be used to pause the current thread execution until and unless the specified thread is dead so when we uh call this join this join will allow This Thread to be dead or uh to be uh you know finished until and unless this second thread is called and finished okay and once these two threads are finished and then only we will print this value of count here okay so this join waits for for the thread to complete and then only allows the execution of other code after that okay so now let's run this program and let's see what happens so I'm going to save this and run this and now it's printing the value of uh count around 13,000 something okay let's run this once again 11,000 something right run it once again 10 ,000 something okay so this at this point it's increasing the value of uh count by one and we will expect that this count should reach at least 20,000 because uh we are uh uh you know iterating 10,000 in one thread and 10,000 in other thread right so we will expect the value of count should be 20,000 but it's not 20 ,000 when we print this value it's around 10,000 and it's random 9,9 and 18,350 so why this is happening now so okay this join will wait for the thread to complete but this operation we are doing on this count which is increasing the value of count by one is really slow in the terms of computer execution so for example this count is something like this okay so it takes the value of count and then increases the value of count by one and then uh places in the same variable count so in the computer terms it's a long process and for example both the thread if they want to access this variable at the same time one will win and it will increase the value of of count by one okay so in this way both the threads are trying to access the value of count and increase it and that's why this uh count value is not reaching up to 20,000 now to solve this what we can do is we can use a keyword called synchronized so what we will do now is we can create a method for example public static void and we can name it as in count to increment count okay and what we can do inside this method is we can increase the value of count by one as we were doing inside this Loop okay and we can call this ink count inside our for Loop instead of this uh count increment like this okay in here and in here so basically this method is not doing anything but when we add a keyword called synchronized here so let's add a keyword called synchronized let's see what happens when we run the program so run the program and it prints 20,2 now it's printing 20,000 to because in our condition I should be less than or equal to 10,000 so when we do I should be less than 10,000 here and here and we will save the program and run it once again it prints 20,000 and we can run this program many times and it will always print the value of count is equal to 20,000 now what this synchronized keyword is doing here now in Java every object have its intrinsic lock and what this lock does is it locks the access of uh certain variable when this lock is called until and unless it uh does its uh operation on this variable and it can be only accessed by one thread only so this lock or this intrinsic lock can be called only by one thread at a time and if two threads wants to access uh one variable which is logged then one thread has has to wait for the acquiring of the lock and other thread will acquire the lock and uh do its operation so the synchronize calls this lock in background so this count can be accessed only once by one thread at a time okay so one thread acquires it and increase it and then other threads acquires it and increase it okay so in this way this synchronize solves the problem of thread interleaving uh in a way that it allows uh this variable to lock so that it can uh do its operation and then allows the other threads to do its operation so in this way the keyword join and keyword synchronized Works in Threads in Java so I hope you have enjoyed this video please rate comment and subscribe and bye for now