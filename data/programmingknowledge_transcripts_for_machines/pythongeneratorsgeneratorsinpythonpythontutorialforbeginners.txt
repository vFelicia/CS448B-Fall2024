in the last video we have seen how to use iterators in python now in this video we are going to learn how to use generators in python so first of all what are generators so generators are the simple way of creating iterators now simply put a generator is a function that returns the iterator object on which we can iterate upon so let me give you an example of generators and then we will see why it's a simple way of creating iterators so what I'm going to do is I'm going to create a simple function my funk and inside this function I will use a special keyword called yield instead of return now after this keyword yield let's say I want to return some values so I'm going to write first of all a and then once again I'm going to use yield and I'm going to use B here and once again I'm going to use this keyboard yield and again I'm going to return C here so if your function contains at least one yield keyword then this function is called a generator function so how this yield keyword is different from the return so in the case of return the statement is immediately terminated entirely so after return you cannot do anything inside a function because after using this return keyword the statement is terminated entirely but the yield statement pauses the function and saving the state of that function so let me demonstrate what I said so I'm going to create a variable X and I'm going to just assign the value of my function to this variable X now on this X I can use our next function so as I said whenever you use at least one yield keyword inside your function it becomes a generator and I also said when you use a generator it returns the iterator object so this myfunc generator function returns the iterator object which we are saving inside the X variable and we can provide this X variable which is a iterator object as an argument of this next function which is going to give you the first value which you use with the yield keyword so let me just run the code so right click and then run the file and you will see it's going to give you the first value which you use with the yield keyword now after that let's say we use this next function two more times then it's going to give you the next value and once again when you use the next function it's going to give you the next value so it's like using the iterator on which you can use the next function but it's much simpler to use because you just need to use this yield keyword instead of implementing the ITER method and the next method inside your class which we have done in the last video now after using next three times because we only have used this yield three time let's use the next function fourth time because now in the fourth time your iterator is already exhausted and let's see what happens so you will see it's going to give you this exception which says stop iteration which we have already seen in the case of iterators also which I have shown you in the last video so generators are similar to iterators but they are more simple to use and create so you don't need to throw any exception the generator will take care of throwing this exception by itself so what is the difference between iterators and generators so as we have seen in the last video that in order to create an iterator laws we need to implement two methods which are ITER method and the next method so if you haven't seen the last video I will recommend you to watch that last in which I have shown you how to create the iterator class so whenever you need to implement the iterators they are more lengthy and sometimes counter intuitive now in the case of generators the methods like ITER and next are automatically implemented so this generator which we have implemented here will return the iterator object on which we can iterate upon so now what's the role of this yield keyword so whatever value you will right after the yield keyword it's going to return that value and immediately after that it's going to save the status of your function so that means for example whenever we call this next function for the first time with this x value then it's going to return the first value which you use with the yield keyword as soon as you do that your function is going to save the status of this iterator that means the iterator is at a and then whenever you call the next method once again your generator is going to remember that last time it has returned the first value and now it's the time to return the next value and this will go on and on until you use this yield keyword so let me give you one more example let's say I will declare a variable n and the initial value of n is 1 and then I'm going to just yield this value and for the first time and also above the yield keyword I'm going to print the value of n so I'm going to just give the string and after this string I'm going to just print the value of n same print statement I'm going to use before the other yield keywords also and before using this n keyword with other yields statements I'm going to increase the value of n by one every time so before the next year I'm going to increase the value of one months again and before the last shield also I'm going to increase the value of n once again so we have used yield three times and every time we are increasing the value of n and let's use the same initialization of my funk and also I will use this print statement three times and when I will do this I'm going to run the program and you will see what happens let me use this next function only once and when I run the code it prints the print statement using this print statement and then gives you the value of n which is one at the first yield then we have increased the value of n by one so now the value becomes two so when we call the next method once again it's going to give you the value of n and also it's going to print the next print statement so let me just move this below this expression so we will see the increment here also and similar we will do with the third yield statement so when I use this next third time is going to print the third value so basically your yield keyword is saving the status after it returns the value associated with it and it resumes the status whenever you use the next next function now let me show you one more thing and that is how you can use this yield keyword with the for loop so let's say I will create a for loop and I will say for I in some range and let's say this range is up to five and after this I want to print the value of I for example so here I will print the value of I and then what I'm going to do is inside this for loop I'm going to return the value of I so now we don't need this n variable so every time from the for loop I'm just returning the value of I in each iteration and let's see what happens so let me use this next function only once and you will see it's going to first print the value of I which is 5 here which is little bit strange I thought I have written here range here but it was something else let's rewrite range function here inside this we have provided 5 as the range and once again when we run the code is going to print the value of I which is 0 now every time you use this next function it's going to give you the next value of I which is 0 1 2 until the 5 so let me just run this code once again and you will see it's going to give you the value until this for loop is valid and as soon as you go outside the range it's going to give you this exception which is stop iteration exception so everything in generator is working similar to the iterators which we have seen in the last video so how about we recreate the class which we have written in the last video when I have shown you the iterators example which is list iterator class so I'm going to write a similar code to iterate over this list of numbers so what I want to do is I want to rewrite this code using the generators so let me just split this editor so you will see it readers and generators side by side so I'm going to close this from here so on the left hand side we have generators file and on the right hand side we have that iterators file so let me just remove this code from here and what I'm going to do is I'm going to create a new function and I'm going to name it as list iterate a function with the smaller L and smaller I so this function takes a list as we have seen in the case of lists iterators which was taking a list as the argument so here also we are going to give this argument which list and inside this function what I'm going to do is I'm going to use a simple for loop for I in and I will iterate over the list which we have provided as an argument so we will iterate over this list using the for loop and then we are going to yield the value of I every time when we iterate over this list using this for loop and that's it so it's that simple to recreate the whole class of iterators using this generator so the biggest advantage here when we create the generator is we don't need to implement this ITER method or this next method and we also don't need to raise this exception from our function or a class whenever we create the generator the generator function will take care of the stop exception by itself so the only thing which remains now is we just need to create a list so we will use the same list as we have used with the list iterator class and instead of this class I will just replace it with this list iterator function and you don't need to do anything so you don't need to use this ITER method to get the iterator object this function is going to return the iterator object by itself so now we just need to call the print function and the next function and inside the next function we just need to pass this variable which we have got from this generator function which we have created and when we run this code so I'm going to right click and run this code once again it's going to give you the first value of the list which is 1 and when you do this several time let's say we call this function 6 times which is the length of your list also is going to iterate over your list and print each and every value which we have inside the list now if you use this value seventh time that means our iterator is exhausted is going to automatically throw the stop iteration error so we don't need to create or raise this top error by ourself generator function will take care of it by itself now as we have seen in the last video also we can use a for loop with the iterators so you can also write for X in your my list variable and then you can print the value of X every time and this is going to give you the same result and you can see it gives us the same result which is all the elements of your list which you have provided here so now this whole list class is performing the same operation as this small piece of code which we call generators so let's discuss the advantages of using generators first we have already seen that generators are easy to implement second is generators are more efficient if you want to perform the same logic with the normal function so let's say you want to perform the same functionality which is to iterate over the list of these numbers and let's say this list is big enough let's say this list length is 1 million then if you are using the normal function your normal function has to store all the 1 million values inside that list variable and that's not very memory efficient but whenever you use this kind of generators they are more memory efficient because they are not going to store 1 million values in the variable your generator function is going to work on the values one by one so let's say you want to stream some data let's say you want to stream a video and you don't know the length of the video then in those cases the generators are much efficient because they will work upon your stream in steps it's not going to wait for your stream to come entirely and then work upon it so generators are good to work with streams also so these are the few advantages of using generators in Python so that's how you use and create generators in Python I hope you have learned something new this time and I will see you in the next video