hey guys welcome to programming knowledge in the previous video we have seen what htl actually is what all it contains and other stuff right so from this video on which we are going to focus on implementing the contents of stl implementing the classes which we get with stl to increase our productivity right and more importantly in this video we are going to discuss about vectors to the core and the reason why i picked vectors is because we already are familiar with it and you actually get an idea of how vectors actually work to the core in this video because it's actually easier for you to catch up right so let's just begin with it so i'll just begin by including the vector class what's happening to my spellings vector right and i can actually create a vector class so vector into v right so this is basically a vector which can hold integer type objects now what is a vector vector is nothing but a dynamic array that's it so what is happening here is that so if you see how we deal with an array in c plus plus or even c what you do here is that you just say that right so int a of 10 so it's basically 10 it's basically a space which can contain 10 integers which is basically 40 bytes of continuous memory that's what you're requesting to the computer or the operating system when you say this statement right but what a vector does is it doesn't know how many elements you need you want it to store so basically whenever it gets a new element it's going to create a new array for that and i'm going to prove that exact thing to you so what i'm going to do here is instead of in i'm just going to create a custom class let's say c over here right so class c and i'll just say public i'll just create a constructor which will just say object has been created so this is basically for visualization of how it actually works so if i just say object created right and then i just do destructor right i just create destructor and i just say c out object destroyed slashing right now i have a small class which is basically empty it doesn't do anything but the important point here is that it notifies you whenever an object has been created or destroyed so what i am going to do here is create four objects a b c and d and if i run this code uh well the output is not surprising you will be seeing that four objects have been created and four objects have been destroyed right so now what i'm going to do here is i'm going to make things more exciting what i'm going to do here is that i'm going to push back this element so if i just do v dot push back a we don't push back b right v dot pushback c and then v dot push back d i did that and i run the code well it's the previous code i need to build and run this and now you see i have four objects created but then these many objects get destroyed right why is that i did not even create the object but then vector somehow is creating new objects now why is that happening that's happening because when you start with vector like this the capacity of this vector is actually one it can only hold one element of this class c right so whatever you put here if you put a hint it can hold only one integer if you put float it can hold only one float right and the other things are going to get dynamically occupied on the heap now you have uh you know your memory gets partitioned i did not talk about this i know but then i'll just give a quick overview of that but what you have when you run your program is well your memory is split into different portions and what we as programmers are interested in are the stack and heap so stack is basically where all your variables which are part of your script or your part of your instructions because all these are basically instructions to the cpu right so if you open the assembly you will just find instructions so all the variables which are involved in that instructions are actually stored in the stack so if i just say vector v the actual position of v is in the stack right and then if i just say int a or even the c a b c d so these four objects are on the stack but then what happens inside is whenever the program needs extra memory during the runtime right because uh well i created five objects but maybe during the runtime it had to create another sixth object but then it doesn't have it it did not request the cpu for that much memory so it's going to request the cpu during runtime for some extra memory so cpu is just going to allocate some memory from the heap and it's going to store everything there so that is what he best and this is extremely slow well it's not technically extremely so it's not as low as you think but then compared to the stack it's really really slow so that is why whenever you code make sure that you put all your variables inside the stack well you try at least to put all your variables in the inside the stack right because stack is not really big but if if it's required they try to minimize the usage of heat but then if it's required well you can't help it but use the heap right so that's about it but why i'm talking about this thing over here is whenever i push back an extra array is being created on the heap and then all these elements are being copied there so i can prove that to you if i just keep a copy constructor over here so if i just do cons see other right and i can just put a statement over here that this has been copied right so object copied and now if i run the code well let me just remove this i'll just comment this thing out and run this you see every time four objects have been created that's fine and then a has been copied inside the position right a has been copied inside the vector now b has to be copied but then there is no space since i told you that vector starts out with one capacity so it's going to copy a copy b and then destroy the location where a was there and that's what is happening now so again i want to copy c i don't have space so i create a new space a b c are copied a and b are destroyed again i want to copy d so well this time only one copy has been done that's because vector doesn't actually uh you know it doesn't increase space one by one it it kind of it has an algorithm which can increase space depending on the size of the current vector right well that's another story but then it's not exactly one by one that's why you're just saying that d has been directly copied inside but uh in case there's a need then well the bottom line is that in case there's a need you are copying objects which is bad right so that's the point now you want to reduce this how can you do that well whenever you you're using an array you kind of know what the size of id is going to be right so you can at least estimate the size of the array right size of array or vector whatever it is so what you can do is reserve that much space right so if i if i just say reserve so what this is going to do here is if i pass in some number say n which is this thing size type n it's going to reserve that much space inside the memory so this copying is reduced so now if i just do let's say 10 uh let's say i expect 10 elements but then i just store four it's okay right but then if i expect 10 and i store 20 then only 10 elements are getting copied but effectively right so that's a kind of uh well underlying assumptions you need to make while using vectors because they are storing objects and copying objects is really bad because here well this class doesn't have anything it's literally the size of this class is one byte right and that's also not required because that one byte is used just because i'm defining this class right so there's no a variable inside this it doesn't hold anything it's just a class it's just it's just some template which doesn't do anything that's why it's just one byte but then if you have a class which does something and then it has some heavy parameters then it's really bad when you're copying objects like this every single time right so it's going to be a serious performance hit on your program and you want to reduce that and that's why you reserve some space so that that copying is actually reduced now if i run this i'll be getting only four copies right so four items created four items copied eight times destroyed right and technically you cannot pass references well you think that the copying can be stopped by passing references but you cannot pass references because references exist only for existing variables right so you need to create extra variables then but that's useless right so it's it's as good as copying right so it's not really good it's not really predictive but then what you can do is what some people do do this right what they do here is that they store pointers now why pointers because a pointer is just an address it's just a number right so copying a number it's not at all cost effective it's just you know flipping the bits right so copying a number is that simple so what happens here is that people just store the pointers inside the vector and then store the actual object somewhere else so maybe in a linked list or some something like that right and then they access the pointer and then point to the location where the object actually is so that's also actually a good practice i should say but that's highly debatable people say that i should keep items the objects inside the vector but then some people argue that keeping pointers is more effective but then it's up to you you can use it however you want but if you are going to use directly uh the objects inside the vector then do reserve the space because if you are not going to reserve the space it's going to be a huge performance impact on your program so that's about using vectors as a storage container i think i spoke a bit long about this thing but then it has to be addressed and if you're learning c plus plus it means that you want the performance right so it's really important that you know about this uh what pushback does but then there are other functions too but i'm not sure how they actually work in other compilers because i'm not really used to this mingw compiler right i use msbc the microsoft visual studio compiler and then in from c plus plus 11 they have a function called m placeback instead of pushback so when you push back you actually create another object and then push it back so it's basically you're creating a new object but then when you emplace back what you do here is that you actually take the existing object and then push it inside the vector so that's actually happening but then i don't know but in this particular compiler with just a min gw right it doesn't implace back correctly well as as much as i know it doesn't replace that correctly right it's just working just like push back i tried it before so if you want to try it it's just available after c plus plus 11. so you need to go to your compiler and then check one of the flags so c plus plus 11 or 14 right you need to check one of them but but then in msvc it works as expected so when you x in place back it doesn't create a new object but then it implies it it puts the original objects inside the vector right so that's about m plus back you could try it out but maybe i'm wrong right so if you know that correct me but then that's about pushing back and then storing items inside the vector and other things are kind of simpler so now let's just go and talk about the constructor of vector so if i just do vector v i have a constructor so i can just create existing object i can start the vector with some objects so let's say i want to start with three integers i can just do that and the default is zero if you want some other integer you can just do that so if i just put comma minus 1 it means that uh i'm starting with three elements with 1 the difference between reserve and this thing is that it starts out with that much well it already has three elements but then when i reserve space it doesn't have any element but it has the capacity to store those many elements so that's the difference right so that's about the constructor if you do that what you're basically saying is that i want three elements each of them are minus one right and you can also directly assign it so you are implicitly converting it to a vector that's also possible i could just do one two three uh well let me just do something like minus one five four zero and nine right so you understand why i'm doing this in a second so i can just do that that's also possible and now coming to iterators now i just completed containers well let's go in order so what what it did what they just completed is the container part of vector now coming to the algorithmic part right i'll just include an algorithm header file so i'll just say hash include algorithm right and what i can do with algorithm is that i can search find sort and all these things so i'll just say i'll just show you sort and then uh find right but then you can do lots of things with the algorithm header file right there literally function for almost all the algorithm uh things you algorithmic things you need for you know dealing with the data right so for sorting it's really simple i just need to sort from where i need to start from the beginning now this begin and end are actually iterators and we'll talk about what iterators are but i already told you in the previous video that you can think of iterators as pointers so it's more or less the same so you can just say that it's the pointer to the beginning of the vector and if i do v dot end it's basically pointed to the end of the vector it's not the last element it is the end so it's basically one after the last element and then i want to sort all these things in the ascending order so default is ascending right and i can just show the elements of this vector so please excuse me for now i'm just going to use the for each loop i'll explain what it does in another video but then you can just write down your normal for loop if you want to if you don't understand what this is but uh it's fine right it's just going to print out the elements so yeah i'll just say c out i and then put a space and then put a new line over there and now if i run this i'll be getting minus 1 uh 0 4 5 n which is basically sorted order of this vector right and now if i want to sort it in descending order i have few options what i can do here is i can just say greater int right and then this now what it's going to do here is that it's just going to uh send the greater elements to the first it's basically going to save which one of them is greater and then it's going to sort it accordingly so now if i run this i'll be getting the list sorted in well vector sorted in the descending order now if this is confusing what you can do here is that you can define your own function it doesn't really matter and that's what you're going to do if you're going to sort you know vectors of classes or you know vectors of structure something like that well vectors of structures you cannot sort them in ascending or descending order unless you say how to sort them right so the how is what this parameter is and i can create a function to do that so if i i can just create a boolean let's say larger right so which one is larger i'll just take two integers into a and b because that's what my type of object is so it's an integer and what i'm going to do here is i'm just going to return if a is greater than b or not if it is if it is right if a is greater than b it's going to be in the beginning of the list if it's not it's going to be at the end of the list and then it uses some algorithm right so you have searching algorithms but then it's uh going to use a very specific algorithm for sorting and you don't have to worry about that unless you're a beginner it's highly optimized and it's going to sort your list in no time so it's i think it's n log n time right so if you know the complexity so that's the time complexity of this algorithm and space is i think one right so i'm not really sure about that so what you need to do here is that you need to send in this particular function as as a function pointed now i i know i haven't spoken about function pointers yet but then you can think of function pointers are just the name of the function that's it right don't call the function you don't do that this this is basically calling the function but you're just passing which function to call so i'm just saying that call this larger function every time so i do that run this code i'll be getting the sorted array over here and now if i want to sort it in no ascending order i will just reverse the sign so if a is less than b it's going to be at the beginning or else it's going to be at the end if i just run this i'll be getting it in the ascending order right so that's how you sort vectors and then you can find vectors well i mean find items inside the vector so what i'm going to do here is i'm just going to say find and then from the beginning till where do i want to find i want to find till the end and what do i want to find i want to find whether this is 0 or not so if i do that and this is going to return me an iterator it's going to return me the position right so it's going to written me you can think of it as a vector pointer right it's going to return me that so it's basically this thing vector and iterator and let's say i t right so if you don't want to write this whole name you could just replace it with this thing or two that's what it does auto it basically uh what it does is it guesses the type for you it types the type for you right so don't just plug in auto everywhere i shouldn't be using this this is actually a bad practice if you write bigger code you'll find it harder to debug but then it's fine because it's just one single page of code right so it's fine if i just do that and now what i can do here is i can just compare it so if i t is not equal to v dot n because if i don't find the item i'm going to be at the end right if i'm not at the end it means i have found the item so i can just say that she out item found and you already have the iterator to that point so it's fine or else what you can do here is that um you know say that item has not been formed so see our item not found right and then i'll just put this new line over here right and if i run this you'll be seeing that i have found the item because 0 exists so if i just do something like 100 which doesn't exist and then run the code again um yeah run the code again you see that item has not been found because the iterator has moved to the end of the position end of the vector i should say right so that's about finding and you have lots of other things you have find there find if not and all those things i'll leave it to you to explore std algorithm is really really useful and searching sorting and all these things are actually very very common tasks you will be doing when you are actually programming a solution right so that's about algorithm and then i traders i actually talked about iterators over here so this is what iterators are but then you can also use it as a as a way to actually look through the vector so that's what they are true as i told you eye tracers are nothing but you can just think of them as pointers they are nothing but pointers i should say right so what you can do here is that you can just do something like vector in iterator and then again if you don't want to type this whole thing just put auto vector iterator i t equal to i'm just going to start from the beginning and v dot begin with and all these are going to return iterators they are going to return pointers okay so v dot begin and then i t is not equal to v written so till i don't reach the end and then i can just increment this iterator and i can just use it just like a pointer so i i could just do star i t to get the value at that particular location so i'm sure you're familiar with pointers so that's how you can do it right and here i could just put a new line to separate the debug output which code blocks generate and if i do that i can see my vector so minus one five four zero nine so it's just like a pointer right and pointers are really useful iterators are really useful and it's it's out of practice that you understand how to work with pointers but because in the beginning it just seemed useless right even i felt pointers are really useless but then over time they do make a lot of sense so pointers are really helpful so that's about everything vectors can do and then well i only talked about in session well there's a deletion thing as well what you can do is v dot pop back it's going to remove the last element and now if i just show you that right so auto i and v i can just print out i right and then just run this code i'll be getting minus one five four zero the nine has been removed right and then if you want to erase something you can erase it with your iterator right it again it's a pointer to the location where you want to erase so let's say i want to erase 4 so how i can do that is i can just say v dot begin plus the index so index of 4 is basically it's 0 1 2 right so i can just say plus two right so zero if i just v dot begin it's basically this thing plus one is this plus two is this so i can just do that and now if i just run this you won't be seeing four there right so minus one five 0 and 9 4 has been deleted and then if i want to delete a range of elements that's also possible so let's say i want to delete from 5 to 0 so i can just say v dot begin plus 1 and then for 0 what i can do here is i could just say v dot begin plus what is that zero one two three right i could do v dot begin plus three or i could do this minus one so v dot n minus one is also zero so i could do that and either way if i just run this i will be getting the same output which is minus one and nine all these things have been erased so that's about arrays and then if you want to clear the entire vector what you can do here is just say clear right what it does is it completely removes every single item inside your vector and then if i just run this you will be seeing that nothing exists inside the vector so that's all about vectors and now coming to the point of when to use it and when not to use it whenever you want to access elements in random right so let me just put it in bold no use vectors whenever you want to access elements frequently this is really really important if you are not going to access elements frequently don't use a vector right let me just stress on this point uh why am i telling you this the reason is because vectors act like arrays right so vectors are more or less like arrays they are continuous blocks of memory but then every single time you are adding an element you are effectively creating a new memory location right and then you are copying stuff and then deleting stuff that's really bad you shouldn't be doing that you should be avoiding doing that right so what we need to do here is whenever we we need a any like structure when do we need a relaxed structure when we want to actually access random elements if i want to just access the fifth element or the fourth element or randomly access the second element when when i'm doing such things i do need a array right i cannot use something like a list because as i told you in one of the previous videos list if you want to access nth element of a list you need to travel from the beginning to the nth element right but in case of an array you already know the starting position you know the size you add the size to the starting position you get to the point where you need it right so it's just like that so if i want to get to zero what i can do here is just say v dot begin uh this is the starting position plus three right that's that's zero for me right so it's just simple as that that is why you generally tend to use vectors or arrays or whatever whenever you want to access elements more frequently if you want to store elements more frequently if you if you think that you will be adding and deleting elements very frequently then you should use list not vectors and list is going to be a topic for the next video so be sure to check it out but then the bottom line is that use vectors whenever you want to access elements frequently and how you can reduce the performance hit is by using reserve or you know tricks like that so that's about vectors there's actually a lot more things to vectors which you can actually browse and find out but these are the things which are really important for you to know and in the next video we are going to explore less so till then happy coding