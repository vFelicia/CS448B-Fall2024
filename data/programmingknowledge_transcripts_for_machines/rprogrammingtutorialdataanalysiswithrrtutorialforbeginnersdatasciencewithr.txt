hi there my name is Alex Santos and I'm assistant professor of text and computational linguistics in our solo University of Thessaloniki in Greece in this video I combined the content of a series of shorter videos that I uploaded on my YouTube channel related to programming with the our language the r programming language as some of you may have already heard is one of the top programming languages for analyzing modeling and visualizing data so these 15 short videos focus on explaining basic concepts of our programming related to vectors in their sub setting to opening and reading text files in R and they're primarily made for people who would like to learn our from scratch and they have no prior programming background in R and they would like to be able to learn and use our effectively for the data analysis the next video that I will upload on the programming knowledge channel I will again contain the combination of shorter videos on our programming focusing on factors and data frames until then if you'd like to watch these shorter videos as they come out pass by and subscribe to my youtube channel whose link you can find in the description below that's it for now enjoy the videos before you start learning our you need to first carry out two necessary installations for starters the program in our sure enough you need to have our installed then you will need our studio one of the most well known IDs that will be hosting our our programs ID stands for integrated development environment and by integrated development environment I mean the set of tools provided to you in order to swimmingly develop an our program for instance some basic features include an editor with code coloring that very easily help you spot keywords variables and other types of fire objects that you will be learning in the next videos also code Auto completion and debugging you will be able to acknowledge the power of all of these features as you become more proficient in using our before we begin with installations notice that the order of installations matters you first need to install our before you install our studio our studio will share its foreign our installation on your machine before it is installed first things first though let's install both software programs first for Windows and then for Mac let's first go to our sufficient webpage our project.org then you follow the download link on the upper part of the page next screen shows the available mirrors from which you can download the software you can choose the mirror of the country you live in or run nearby and follow the respective link let me follow Greece's link since I live in Greece and next step is to choose the operating system of your machine now you choose windows in the next screen click on the base link and then you simply select the download our link at the time of this video recording our latest release version is three point five point two now you save the file and then double click on it to execute the downloaded dot file now a new popup window appears that gives us the chance to set the installation language here I choose English next popup window is about the terms and conditions of using are under its ganoub public license you simply move on by pressing next as you will do for the next few windows regarding the selection of components the setting of startup options the Start menu folder and the additional tasks our is installed and you are one installation before you are ready to go it's our studio stand now first you need to visit our studios official web page then choose the products tab and select our studio you find the download they are studio desktop link for your laptop or desktop PC in the next window you choose to download the free version and finally you pick the windows installer you choose to save it somewhere on your disk that you can easily access and then wait until it's downloaded after downloading it you simply double click on it and choose next for the remaining screens until the finished button appears you the only thing that remains is to actually find and open our studio you go to the Start menu and then you find our studio and load it now you're in front of our Studios environment where you will be working throughout this series as you can see there are four panels the two ones on the Left above and below will concern us most of the time since these are the places where you will be writing your our code for the first few videos you will be working on the lower left panel the so called our console and after you start feeling a bit more comfortable with the language we will start with writing our first our programs on the upper left panel and run them from there I will prepare a video for explaining how to use the upper left panel when the time is right the remaining two panels have special functionality that you don't have to worry about right now but just keep in mind that as we move along the series I will help you discover some of the benefits of using them while programming so far with Windows let's head to Mac's installations installing our for Mac does not make much of a difference you go to ours official page you follow the same download link and then you choose the mirror you want to download the software from you would usually want to find a mirror from your country or a neighbor one I chose the Greek mirror in Crete as I live in Greece in the next screen I choose the download R for Mac link after that I pick the latest release package at the day of recording this would be our three point five point two now our is downloaded the next step is to install it press Continue then agree to the terms of the license agreement choose your disk if you are the only user of your Mac and install insert your password to allow the installation by entering your password and then the installation begins you wait a couple of minutes until the window with a successful installation pops up lastly let's install our studio for Mac you first need to go to our Studios web page choose our studio from the products tab then our studio desktop and download finally you click on the free version link and then on the corresponding Installer installer for Mac after having downloaded the dmg file you simply click on it and let it do the installation finally you drag their studio icon on the Applications folder and you're ready to go now to open our studio you click on its icon and you are in front of ours to the environment that is identical for both Windows and Mac as you can see there are four panels the two panels on the left above and below will be the ones that you will be working on since these are the places where you will be writing your art code for the first few videos you will be working on the lower left panel the so called our console and after you start feeling a bit more comfortable with the language we will start writing our first our programs from the upper left panel and run them from there I will prepare a video for explaining how to use the upper left panel when the time is right there are two panels included a number of useful features that you will discover as we move along the videos of the playlist now you are set to go and enter your first our code chunks hi there as I mentioned in the first video of this playlist throughout this series you will see the common steps obstacles and advances that are provides in handling analyzing and modeling language data to that end the GLC dot sample data package a package that I created and now distribute through my github account will often serve as the basis for explicating the new concepts as we move along but what is in our package in our package is a set of programs written in our or datasets in spreadsheet like form that are can understand accompanied by detailed documentation as to how to use them for efficient data analysis in our case the GLC dot sample is a plain data package that and that means that it includes only data and is accompanied by documentation as to what these data represent particularly the GLC dot sample package includes metadata such as the first language the communication skills level in the proficiency test scores in the listening and writing tasks of 100 students of greatest second language recorded for the compilation of the Greek learner corpus abbreviated as GLC jill sees an error annotated learner corpus that you can download from the link I will include in the video description below there are two steps that you need to always have in mind when it comes to using in our package first you need to have the package installed in your machine in case it's not included in besar namely when you installed R in our studio if it is not installed you need to install it with a couple of specific commands that you will learn here the installation is done only once so you don't have to do that again next time you open our studio you then only need to load the package in order to use it so after installing an external package the second step is just that namely to load it before you are able to use its commands but GL seedot sample package is an external package meaning that it is not available immediately after you open our studio as I just said and needs to be separately installed the GLC dot sample package is distributed through github a well known online repository of our packages used mostly by programmers all over the world there are three steps for installing the GLC the sample package first step is to access the jillsy dot sample packets in github and for that you need to first install the dev tools package that provides access to github so you first write the line of code that you see right now on console on the bottom left panel of our studio the install that packages command or function as I will more often call the chunk of code that includes a name followed by opening and closing brackets will install the dev tools package then after successfully installing dev tools you need to load it so that you can use its commands or else functions to access a GL c dot sample for a slightly more advanced tutorial with information on the distinct categories of our packages on how to install and browse through them check out my earlier video on our packages and I provide a link in the video description below now you simply need to load the dev tools package with the library function after loading it you need to use the installers called github function are provided by the loaded package dev tools what you see inside the parentheses is a string signified by the surrounding single quotes with the address of the resource the deals with all sample packets in the github address inventory what this means is that the function install a underscore github searches through the available online github accounts and goes to my account that is the Atlantis part and then to the repository with a package GL C dot sample after finding it it's job is to simply install it on your machine while installing the GOC you'll see dot sample package a message appears on the screen waiting for your input ignore it by pressing the enter key as it does not make any difference for you right now next step is to load the package with the library function before we are able to use it and now we are ready to use the loaded data offered by the package from now on you can use any of the death data of the package for your packages for taking a brief overview or GLC dot samples vectors you need to use the data function for the time being you're not equipped to understand exactly what goes on in this code Chang don't worry about that you will soon be able to do so just type in what you see in the console for now what this function does is that it asks are to provide information about the content of the data sets in the GLC dot sample package the output will be displayed on the upper left our studio panel there you will see the names of the distinct data sets jillsy underscore part one to GLC underscore part four that corresponds to the four distinct areas tested within the standard language language proficiency assessment test used for the compilation of the Greek learner corpus and they include the learners scores namely scores on listening reading speaking and writing tasks also g gr underscore communication underscore skill records the levels of l2 great learners communication skills in Greek while jillsy a no score l1 the students l1 profiles you can browse through a more detailed documentation for each of the data sets by simply preceding the name of the data set with the with a question mark as I did here with the question mark GLC underscore part one data set wrapping up on the code of this short tutorial you'll learn to install load and explore the GLC dot sample package with the install underscore github library and data functions correspondingly now that you installed the GLC tooth sample package and know how to load and browse through its content it is high time you start getting your hands dirty with real language data analysis in the next videos hi there most of the times you will need a way to store and access values that describe a single aspect or feature of the collected data a vector is a onedimensional data structure in R that you can use to do that by one dimensional I mean that its members are of the same type and represent a single feature for instance the response time measurements of a single experiment the recorded first language of a set of students as in the vector jillsy underscore l one of the GLC dot sample package that we will see in a minute or even responses to a single questionnaire item in this and the next couple of videos you will learn how to explore and handle character vectors namely vectors whose members sure enough are of character type after watching this video you will be able to use our code for getting the length of a character vector for obtaining its first or last n items and also for extracting its unique elements let's jump directly on GL c underscore l1 a character vector included in the GL c dot sample package that reports the first language or l1 of a sample of 100 students who's written productions were recorded during the compilation of the Greek learner corpus for more information on the package and the Greek Lerner corpus visit the earlier video in this playlist recall from the previous video that before using any of the date of an externally installed our package such as the GLC underscore l1 vector you need to load the GLC dot sample package that contains it that means you need to use the library function now you can choose to either display the content of the GLC underscore l1 vector on the console by calling its name as I just did here or to display it separately on the upper left our studio panel with the view function as you can see most of the l1 entries of the vector are Albanian this is interesting to observe as the collected data come from Greece its neighbor country moreover soon you will see that you will be able to quantify this intuitive first observation the first you are going to want to know when you have a character vector is the check its length namely the number of elements it contains this will reveal whether all the recorded values have also been included in a vector you can achieve this with the length function here as expected the length of the vector is 100 since the number of students is 100 getting an overview of a vector can be done with a head function this function takes a vector as its argument and outputs its first six entries by default for those who wonder what an argument is just look at what inside the parentheses that follow the name of a function is if a function has more than one arguments these must be separated by a comma the function head requires at least on argument the vector or the variable that represents it GLC underscore l1 in our case but can also take optional arguments that enhance its functionality here I use an external america argument T is 25 that will overcome the number 6 that by default is defined when no second additional argument is added in other words as you can see our returns the first 25 entries of GLC underscore at 1 the function tail returns the last six entries and as with head if you enter the number 25 as an additional argument the last 25 entries will be returned in a vector with various language profiles such as GL c underscore l1 you might also simply want to get a first feeling of the variability of the data in our case the variability translates to the number of distinct recorded l ones in a vector with 100 pretty recurrent l ones it is not so hard to monitor the different languages although not very easy either however imagine if you had a vector with entries of greater variability and much bigger in size for simply getting the different languages of a vector you can use the unique function what unique does is that it eliminates duplicate elements from a vector that is given as its argument and returns a new vector that keeps only one of its type let's say so the resulting vector includes the nine languages that appear in GLC underscore l1 one time or more notice that the resultant na entry which means that there are some missing data for at least one of the 100 students in other words for some of the students the l1 has not been recorded and there can be many external reasons for this to have happened you will see how to handle this type of data in a later video the vector is as diverse as including languages such as Punjabi Arabic Romanian Bulgarian and Georgia gamma gathers wrapping up on the code of this short tutorial you'll learn to ask for the length of a character vector with the length function to browse through its first and last n items with the head and tail functions correspondingly and to remove duplicate entries with a unique function so that you can have a first insight of the variability of the data one of the fundamental concepts in our and in programming in general is that of a variable conceptually you can think of a variable as a name that stands for a value and it works much in the same way a post address does namely a post address is a conventional name followed by a number that everybody shares to refer to a specific building so you can think of a variable as an address that you first a constant value or object as we call it a in our here the variable name refers to the string Alex since all our values have a specific data type think of the analogy of a specific building that belongs to the type of buildings a variable does not belong to specific data type but it refers the value that has its own data type in our case the value Alex assigned to the variable name is of type string but the variable name does not belong to any type only its value does in other words variables can also be thought of as typeless names that refer to objects both of these definitions I just mentioned are identical okay now how do we create a variable or else how do we assign a value to a variable the answer is by using the left direction arrow which is a combination of the less than symbol with a hyphen on its left side you use the variables name with no quotes around it and on the right side of the arrow you place the assign value the arrow is also called the assignment operator here I assigned the value of first string to the variable called first underscore variable lastly the assignment is completed as any other command that you add it on the console by pressing the enter key then the ars interpreter is called to evaluate the assignment statement notice that after pressing the enter key nothing shows up on the console that doesn't mean that something is wrong it just means that R has done its job and now variable and its values have been recorded in the memory you can then use this variables name to easily access the value assigned to this variable and you can do that by simply type in the name of the variable and then pressing the enter key as I did here you can also change the value of a variable by assigning it a different one the first underscore variable is now assigned the string not really now let's see the kinds of restrictions are puts in naming variables I could name a variable human underscore being underscore 1 2 3 dot world and assign it the string with my name but I could not name a variable starting with a number as you can see here with the one two three underscore human underscore being dot world also you cannot have variables starting with an underscore let's try a dot add in the beginning of the name followed by the sequence of digits one two three as you can see it does not work either however if a name started with dot was followed by a character the variable is created successfully lastly I cannot use reserved words in our to name a variable reserved words are keywords in our that have a special meaning for instance I could not use the word for as a variable name for is a keyword especially reserved for starting a for loop as you will see in later tutorials summing up on the naming conventions variable names can be a combination of letters digits period and underscore it must begin with a letter or a period if it starts with a period it cannot be followed by a digit and reserved words in R cannot be used as variable names our variables resemble the variables used for language data research this means that they both stand for a value and express a single feature for instance jillsy underscore l1 is a variable that stands for a vector of the GLC dot sample package and then codes your language data variable namely the first language of 100 students GLC underscore l1 is then an our variable that links the concept of a first language with the actual collected student data the process of linking scientific concepts with a collected data through variables is often called operationalization the variable jillsy underscore l1 is a result of operationalizing the concept of a first language recorded in the collected sample before finishing this tutorial make sure you take one more walkthrough of the code on variable assignments and the hours of variable naming conventions let's practice the functions that you learned in the previous video on a different vector of the GLC dot sample package on gr underscore communication underscore skill before that you need to load the package GL C dot sample that contains it with the library function as usual now you can browse through the gr underscore communication underscore skill vector with the our studious view function the members of this vector represent the 100 students communication skills level in Greek passing an eye over the vectors elements you can observe that the students communication performance Greek is very good now let's ask for the length of the vector no surprise it is 100 next step is to get the first n items of the vector I chose its first 30 members and for the last 30 members you need the tail function you what about the unique elements of the vector or else how many assessment levels have been recorded for this you can use the unique function that outputs a vector with five members in our case although the number of unique elements is small you will often deal with character vectors that contain a big number of unique members in order to get the number of the distinct members of the vector you can use the unique function in combination with the length function that accepts as its argument the vector returned by the unique function as you can see the unique function is placed inside the parenthesis of the length function this is possible to do since R evaluates the expression in a from inside out fashion what I mean by that is that when R deals with nested expressions such as this one it first evaluates the most deeply nested expression the one that is inside the parenthesis then it gets the returning value a vector in the case of unique and passes it back as the argument to the length function that is why the length function takes as its argument the vector with the unique elements of G R underscore communication underscore skill and returns its length of course you could achieve the exact same thing in two steps you could first assign the resulting vector of the unique function to a variable as I did here with a unique underscore communication variable and then insert the variable as argument to the length function if you are feeling shaky as to what an our variable is check out the earlier video that explains the concept in detail here is the code summary so far feel free to pause the video you like and take a look at it until now we worked with character vectors loaded from the GLC dot sample package what if you wanted to create your own vector that would be the case if you had a small data set or if you wanted it to test some hypotheses on a sample of data and for that you need it to hardcode it into an R character vector so combining some character values into a vector can be achieved with a c function here i combined the three strings Greek English and German into a new character vector r's interpreter evaluates the expression and displays the resulting vector of course you can assign the vector to a new variable so that you can access it later as i just did here with a variable called languages so let's bring it all together and see how we could do something more creative with our data and with the freshly acquired knowledge let's assume that we would like to create a new vector with two elements the numbers of unique elements in the two character vectors GLC underscore l1 + gr underscore communication underscore skill the first step is to think of how to get the unique elements of the two vectors that is something you already know how to do and you saw it in this in the last video next step is to think of how you could get the lengths of the vectors returned by the unique function that you also know and just saw a minute ago each of the values returned by the last two statements will be an entry in the new vector so what remains to be done is to put these two code chunks together in the same vector and you can do that by using the C function that constructs a vector its arguments will be the members of the new vector that means we put the two earlier code chunks inside the parenthesis of the C function and separate them with comma as we do to a function that accepts more than one arguments finally we store the resulting vector to the variable lengths so that we can access it later by calling it you can see that it has two numbers as its elements 5 and 10 for the number of distinct languages and the number of distinct assessment levels of the GLC underscore l1 and the gr underscore communication underscores kill vectors correspondingly there is nothing special about this seemingly complex code chunk rewind what I said a minute ago about the way our deals with nested expressions namely by evaluating from inside out any complex code expression and you will see how the complexity vanishes now is your time to do something with the data so here are 2 coach ank's I prepared for you I would like you to tell me which of them number 1 or number 2 returns the length of unique elements of the first 50 members of GLC underscore one feel free to pause the video run both coach ankhs and think about the output you get I'm looking forward to receiving your answers or any question that may have come up in the comment section below I'll come back to the solution of this short exercise in the next video decoding mentally the way that our evaluates nested expressions is definitely the first and decisive step to understanding our code and creating your own art programs in the last video you were assigned a short code exercise there you were asked to check which of the two lines of code one or two could produce the length of the vector of unique elements for the first 50 members of GLC underscore l1 let's first take option number one when writing nested code in our recall that by a nested I mean that one function is placed as argument within another function the most important thing to remember is the order of opening and closing brackets that indicates the arguments of a function and the commas that separate the arguments of a function in other words you aren't puzzled the code by looking at parentheses and commas and that is exactly what you need to do here in order to interpret what this line of code does recall also from last video that our evaluates expressions in and from inside out fashion so starting with the innermost expression we know that R will evaluate it and return the first 50 members of the vector GLC honest world 1 or else the first 50 languages of students of Greek as a Second Language the next level up is unique that takes the output of head and gives back the number of unique members it contains which is 5 let's head to the second option here the inside function head has only one argument and returns the first six members of TLC underscore l1 whereas the unique function has two arguments namely the head function and numbered fifty finally the outermost function is length that has only one argument the output of the unique function R starts to evaluate the innermost function head and as you already know by default when no second argument is given it outputs the first six members of the vector Jill siano squirrel one at the next level uniq has two arguments however when you learned about the unique function you may recall that it accepts one argument and not to let me explain what happens here the first argument we think the parentheses is the required one it is a vector whose unique members will be returned in our case this is the vector with the first six members of GLC underscore l1 returned by head and the second argument is number 50 apart from the first required argument unique allows for further arguments that for the time being are not functional meaning that they are not processed in any way in a later video when you will be learning about functions I will explain you type of argument called the three dots argument for now you simply need to keep in mind that although we said unique requires a single argument it also allows for further arguments that do not play some additional role in this case in other words what the code of the second option does is that it returns the unique elements of the first six members of TLC underscore l1 that is why option number one is the correct choice for spawning two the code exercise karthick vectors are valuable data structures that store one or more strings as you saw earlier in this series in this tutorial you will dig a bit deeper in the building blocks of a character vector namely its members strings you will learn what an our string is how it is defined and lastly you will see some of the basic tool tools our provides you to handle and explore textual data stored in character vectors so let's zoom in on strings a string is a piece of text represented as a sequence of characters B that letters numbers and symbols let's have a look at some strings in our studio I have written a string here our gives people the heebiejeebies and by pressing enter our console returns back the same string with its quotes showing you that it evaluates the string that you gave it correctly namely as a string a string as you can see is not identified with an actual word a single string may contain a whole natural language text or even more than one texts what matters for a string to be evaluated as such is that a sequence of one or more letters numbers or symbols is enclosed within either double or single quotes that delimit is bounders moreover the quotation must be done consistently what does consistently mean in this context though it means that when you are creating a string you need to pay attention to end the string in a consistent manner with the same type of code you started with in this string I created the second go I chose double quotes to put around the string so I use this type of code in both its beginning and end the same applies to single quotes if the string started with a single code as this one it should end with a single quote if the string contains quotes in it as in the case of having quoted words then the pairs of quotes inside should differ from the ones outside here let's try to replace the single quotes in the string with double ones and see what happens in this case I got an error message that indicates that there is a problem with the sequence of symbols within our string let's try to understand why this happens following the quotation syntax rule I just mentioned namely that the type of quotes is a means for marking the start and end boundaries of a string and that the ones inside should differ from the ones that mark the borders of the string then the sequence I just wrote consists of two strings with some symbols in the middle that do not belong to either strings so there are two problems here first I declared two strings on a single line and there are also some symbols the people part that do not belong to the string and that also do not represent any variable or function and hence cannot be evaluated by our the same applies if you chose to mark the boundaries of a string with single quote okay so let's put aside strings for a moment and let's head on to character vectors again recall that character vectors are sequences of strings and you're going to learn some very basic functions or commands if you like but I suggest that you get used to the term function instead of command since that is the right term to use and these functions you will see will allow you to handle character vectors and take some basic information about them let's assume that you would like to get the number of characters of each of the strings within a character vector let's further assume that each member of the character vector is a word string namely a string that corresponds to an English word followed by punctuation for example the exclamation mark is in the following vector that contains has its members the words of the previous string notice that I assigned the character vector as a value to the variable sentence to achieve this the end char function is useful what n char does is that it takes as its argument a character vector and for each of its strings it calculates the number of characters then it returns a new vector with the counts of characters of each string on the preowned the positions they were in the initial vector let's see it in practice the first position of the new vector is the number one the number of characters of the first word are of the vector assigned to the variable sentence on the second position five for the following member of sentence the verb gives on the third position in the outputs three for the article there and so on and so forth within char you can get a good first overview of the vector sentence imagine you had a vector with its members being word strings of a whole text then n char would give you the lengths of four words in the text this might be considered a valid factor for measure in sentence complexity in terms of both comprehending and skimming through a text in fact the number of characters in a text is already considered as a factor by researchers of the field of psycholinguistics the next crucial step is to see how you could arrive at the character vector with word units as members such as the vector sentence this is an important step to know how to do since if you have a character vector with words as its members you could employ are to obtain insights from the textual data so how do we get from a row text to a character vector that has word strings as its members our provides numerous functions from different packages but to that end I will use here the base our function STR split as I mentioned in an earlier video on our packages functions that belong to base our are considered inbuilt functions which means that they can be used from the very beginning of any our session and do not belong to an external installed package so the library function does not need to be used you already learned some other bizarre functions and these are they see or the length functions that you saw examples of other basic functions that you already learned in previous tutorials are the C function for creating vectors in the length function for getting the size of a vector okay starting with a row string R gives people the heebie jeebies i will first have to assign it to a variable and here i choose to call it row dot txt the STR split function takes two arguments the first argument is the string to be segmented represented here by the variable loaded text and the second argument is the segmentation criterion namely the criterion for splitting a string I use the empty whitespace character for that notice that the whitespace character is surrounded by quotes to signify that it is a string keep in mind that even though it signifies the emptiness it still has length one and by using the whitespace character as a segmentation criterion I mean that the whitespace character is used to mark the boundaries of the members of the new resulting object or in other words the places in the string that the new members will be cut this will become clear to you when you see it in a minute in order to get the character vector there is one last step though STR split segment strings into sequences of word strings but does not return a character vector instead it returns a list signified by the double square brackets you haven't seen list yet and there will be separate videos on lists dealing with how to define and manipulate them but they won't bother us now for now you simply need to know how to convert the list return from the STR split function in the character vector that you know for this you need to use the unlist function the unlist function takes a list as its argument and as its name suggests it returns a vector in this case it takes the returns list of the sto split function recall that in the case of applying a function on the output of another function you could either do it in a single step by putting the STR split function within the parentheses of the analyst function or in two steps where you first assign the returned list of STR split to a variable and then put the variable into the parentheses of an list I suggest you go the indirect way so that you get used to defining and using variables here the word that lists variable is assigned the value of the list returned from the STR split function and the work that vector variable stands for the converted character vector let's check on word that vector as you can see the result is a character vector that consists of word strings by the way the process of segmenting a piece of text into a sequence of natural language word strings is also called tokenization now you are in a position to use the familiar by now functions for handling character vectors and to get some basic insights of the text for instance you can ask for the length of the vector or in other words for the length of a text in terms of word units as you can see the text consists of six words or you could ask for all the distinct words of a text with a unique function again they were unique words are six since no word is repeated most of the times euro textual data will be stored in files in your computer and you will need to import them in R this means that in order for you to be able to further process your text files in our studio you should first convert them into our objects namely character vectors and strings that are can understand and allow you to use functions for handling strings and character vectors such as the ones you learned in the last couple of tutorials in this short tutorial you will learn to do that namely to open and read text files into R objects into that end I will use the three different options that are provides us they reach our the read lines and they read file underscore file functions so first things first let's take the text file lorem underscore ipsum dot txt that you will be importing in R that contains a big part of the lorem ipsum text here it is I opened the text file with an editor called sublime text but you could have opened it with any plain editor such as notepad for those not familiar with the lorem ipsum text this is a specific blind or dummy latin like text used very often by the desktop publishing industry as replacement text for testing purposes essentially the lorem ipsum text is there when the text content is not the issue at hand as in our case so here we don't really care what the content of the text file would be I already saved the text content of lorem ipsum to this file in the folder YouTube within my home folder for using the same text file to practice what you see in this tutorial you can go to this link that I also added on the video description below then copy the lorem ipsum text open your favorite text editor and paste and save it as a txt file in a folder that you will set as your working directory in the way that I will show you right now it is crucial to understand at this point that in order for art to open this text file you need to show are exactly where the text file is placed within your machines file system although we'll prepare separate videos specifically on how our navigates through your file system via file paths for now keep in mind that you only need to set the folder with a text file or Aman description dot txt leaves as your working directory briefly the working directory is the folder whose files will be directly available to our to do that you go to one of the right panels that displays the file system of your machine the panel that you see right now placed on the top right will probably be shown on the bottom right side of our study on your screen but apart from the positioning of the panel's nothing else is different in my art studio settings so you go to the folder that contains the text file that you would like to load in our in my case it is the YouTube folder in my home directory and double click on it now you simply go to the tab more open it and select the set as working directory and from that moment on every file that you will put in this folder will be available to our for reading it there are three options for opening and reading row texts in our the first option is to use the read lines function that opens a text file and reads or converts its content into a character vector whose members are the distinct lines of the text I saved the output to the variable called lorem ipsum the argument of read lines is the string with the name of the text file that is why it is surrounded by quotes as you can see each member of the vector lorem ipsum maps the separate line of the original text the end of the line in the original text file is marked with the newline character as you will see in a minute the new line is the criterion for segmenting the original text and creating each member of the new character vector lorem ipsum also note that some members consist of the empty character that means that there were some blank lines in the original text file until now in this series you met some methods for handling character vectors but you did not learn how to retrieve a specific member or a range of members of any character vector you'll learn how to do that in the next follow up tutorial for now let's use the length function that you already saw to find the number of lines in the text as you can see there are ten lines recall that in the last tutorial you show how to use the STR split function on a single string and then the length function to find the number of words in that string the output of red lines though is a character vector and not a single string for which you could use STR split to segment it into words for reading a text file directly into a single string you could use the second option of using the read char function the read char function takes two arguments the first of which is the string with the name of the text file and the second argument declares the number of bytes that should be read by R for declaring the number of bytes you can use the file dot info function you're not equipped yet to understand what goes on in this chunk of code but you will soon be able to do that let's have a look at the variable lorem ipsum dot string that stands for the content of the original text file as you can see the line boarders of the original text file are marked with the newline character signified with a backslash followed by in the text between the newline characters were separate lines in the original text now you could use the code demonstrated in the last video tutorial to segment the string into a character vector with words of the lorem ipsum text as its members using the STR split function and the unlist function you now you can ask for the size of the text in terms of words with a length function which is 543 the last option is to use the read underscore file function of the external package radar which is available in cran recall that to install any external cran package you use the install that packages function if you need to brush up on our packages and on how to install one go ahead and visit my earlier video on the subject apart from the card that you see right now in the top right side of this video I will also add the youtube link on the description below after loading the package radar you can use the read underscore file function that does exactly the same thing with the read char function namely treats and converts the text content of the file into a single or string the difference with red char is that it only needs a single argument with the name of the text file and you don't have to add a second argument that specifies the suitable memory size to allocate of course since you now have the whole text as a single string again you can do exactly the same thing that I just did with lorem ipsum dot string namely to segment the string stored in lorem ipsum dot string dot radar into a character vector with words of the lorem ipsum text as its members using the combination of str split and unlist lastly as previously you can get the text size in terms of words with a length function which again is 543 wrapping up this tutorial make sure you check out the code summary some tutorials ago you were introduced to the concept of a character vector as a onedimensional data structure in R that you can use to store values of type string and recall that by one dimensional I mean that its members represent a single feature of the data be that the first language or the country of residence of a speaker or some other theoretically interesting feature that can be encoded as strings in this tutorial it's about time to dig a bit deeper into character vectors and learn about their second defining feature namely that each member in the character vector is implicitly assigned an index or else a numbered position let's take a simple example of a character vector to see how indexing works in R this character vector has four members or indices the two terms can be used interchangeably here that stand for the position of each member in increasing order if we start counting the characters from left to right number 1 is assigned to the string read number 2 to yellow number 3 to blue and number 4 to green as you notice then indexing starts with the number 1 as opposed to other languages such as Python that start counting from 0 and for that reason they are also said to be zero based languages so when you hear that R is a one based indexing language they mean exactly that namely that it's indexing system starts with a number 1 now the next natural question to answer is how do you retrieve values out of character vectors or equally equivalently and to use the write our terminology how do you subset a character vector sub setting in our is very powerful and unbelievably efficient among the three ways of sub setting that you see right now on the slide I will focus on the first way in this tutorial the others will be presented in the next tutorials using the indexing of a character vector is the base a tool for subsetting a character vector and secondly you need the subsetting operator of square brackets so let's jump directly on into our first example of subsetting a vector for that I have taken the character vector of the earlier example with the strings of colors as its members and assign it to the variable colors for subsetting the vector colors you need to use these subsetting operators besides the name of the variable that stands for the character vector and between the opening and closing square brackets you insert the index that corresponds to the value you would like to retrieve so if you'd like to retrieve the second value of the vector you simply insert the number 2 within the brackets for the fourth member of the vector then you would simply use number 4 apart from subsetting a single value with using a single index you can also subset a range of values for that you need to use the arrange operator represented with the colon punctuation mark that needs two numbers on both of its sides left and right the one on the left represents the start of the range and the other one right the end of the range of values you want to subset so by writing this code of chanc you ask art to return you the values of the second the third and the fourth member an important note to have in mind that you can see in the output that our returns after subsetting the vector colors and of any vector for that matter is that the retained output is a new vector a number one on the left of the output signifies that one it's right starts the first member of a new vector the returned vector let's take another pretty often scenario let's suppose you needed to get specific values that are not besides to one another or in other words they are not placed they are placed in various positions within the vector in this case the range operator is of no use to us what you need is instead is to use a vector of indices within the subsetting operator the chunk of code that you see simply says give me the first and third member of the of the character vector colors and this is one more example of nested code the nesting comes from the fact that the vector is placed within the sub setting operator evaluation is done as you already know by now in a from inside out fashion namely the vector with a values one and three is evaluated first and then these two values are given as inputs to the sub setting operator another pretty common scenario is that you might need to extract all values except some specific ones for which you know their index in that case the minus operator is at use you simply put it in front of the index that you want to exclude here assuming you want to exclude the first member of the vector you put minus one inside the square brackets and you are done so all members of colors are returned within we are returned within a new vector except the first one if you would like to subset the second and fourth member and exclude the first and the third you simply get a bit more creative by using the tools you just learned and you create a vector of negative indices that you would like to exclude and put it within the square brackets equivalently you could put the minus in front of the vector with the same effect namely are here interpret this code Chang in the following way give me back all the values of the vector that do not belong to the vector inside the square brackets lastly you can't mix positive and negative integer integers in a single sub setting this line of code simply returns a false message that indicates that a last remark that is that although some of you may not have already thought about it when you learn the basic tools of navigating through an character vector with the head and tail functions you already did the basic sub setting on a character vector however these two functions are limited in the values that they can achieve and the ways they can do that and they cannot by any means substitute the subsetting mechanism that you just started to learn right now just keep in mind that you only scratched the surface of ours flexibility and power to subset vectors wrapping up this tutorial make sure you check out the code summary last time you were introduced to the concept of subsetting a character vector more specifically you'll learn to use the first of the three different ways of subsetting character vectors namely using indexing and for that I used numbers within the square brackets operator let's turn our attention now to another way of subsetting a vector by using relational or logical operators this method allows to retrieve data that fulfill one or more conditions and therefore it is a very useful tool for powerful explorations in the data that reveal the underlying characteristics of the data set however this powerful technique for exploring vectors and other more complicated our objects as you'll see in the near future comes with a cost namely you need to understand how the underlying logic of using it works and to that end I will spend some time in the following videos to help you grasp the jist of it so in this video you will see how relational operators in our function and as a necessary intermediate step on your path of understanding and using them you get to know the boolean values a new type of data that is retained when you use these operators no worries I will take one concept at a time the first step is to learn how to express yourself in R when asking whether two or more values are the same or differ and in general how to use relational operators as we call them for doing that so lay back and in a couple of minutes you will have understood how you use them in combination with the square brackets for retrieving sets of values out of a character vector so let's dive in the first operator is the Equality operator signified by the double equal sign with the equal operator you can compare two values for equality for instance the following line is about to compare the two strings on the left and on the right of the equality operator notice that since I typed these two strings although their content is the same namely it consists of a number of specific symbols that happen to be same and in the same order they will still be interpreted by our as two strings and not one what we asked it to check is whether these two strings indeed consist of the same symbols and in that exact same order now as it usually happens when you ask something from our it will return you a value in our case when you will be asking it to check for equality between these two strings it will always be returning you one of the two values true or false true if indeed the two values and the comparison are the same in the way I just mentioned and false otherwise let's go directly to the example the two strings here are the same and therefore as expected the return value is true in this second line I get false because apparently the two strings do not consist of the same characters of course you can use the Equality operator if you want to check whether two numeric values are the same as here appreciate that the values true and false are not strings of four in five separate characters they have their own status as values and together these specific two values comprise their own data class or type you can think of these two values as being the only two animals of one species being a type of data as the character symbols in our are called strings this type of data also has its own name and is called the boolean type of value so the values true and false are the two boolean values let's move on to the second operator the opposite relational operator namely that of inequality this one checks whether the two objects are not the same if they are not the same then the true value is returned if they are the same though then false is returned so in the evaluation of the following two lines we expect the exact opposite values namely in the first one the value true since the inequality of the two strings is indeed true and the other way around for the second line of code now these operators can be used for comparing or run to values for instance you can use the equality and inequality operators for comparing two character vectors pairwise let's see an example of how this works I created two different vectors here and assign them to the variables name underscore one and name underscore two if I use the Equality operator the two vectors are compared are compared using their indices namely the positions of the strings within each vector the first string in names underscore one will could be compared with the first string in names underscore two the strings in the second position of both vectors we saw will also be compared for equality and so on and so forth the result is now a vector of boolean values where the index of the vector of this retell parent vector maps to the boolean values of its comparison namely the first member of the vector false is the result of comparing for equality the string election draws from names underscore one and ningke's and Nick four names underscore two the second value true is for comparing the strings in the second position of the two vectors assets may just mentioned namely the two identical ones Georgia in terms of their content moreover you can compare a character string with the whole vector of strings the comparisons are done pairwise again but this time the one side of the comparison always includes the string in this line of code what's compared is the string alexandros with each member of names underscore two a third member of names underscores too as you see is equal to Alexander's and that is why the third member of their tenth effect vector is true the last case we're going to see is when the two sides of comparison are vectors with different sizes and the pairwise comparisons are not done in a onetoone correspondence some members of the bigger vector are not compared with new members of the other side however the pairwise comparisons are done but this time the comparison starts all over for the smaller vector let's see this example I renamed the vectors name underscore one and name names underscore two into name Santos Co three in name's Andrew score four correspondingly and made one more small change namely I deleted the last two members of names underscore one Zaheer and Ibrahim when the pairwise equality comparisons are done the prey last comparison for Zahir is done with the first member of name Santos code three namely with Alex honors since there are no new members names underscore three and that is why it starts all over four names under school three for Jim of names underscore for the comparison is done with the second member of names and score three Georgia so this might not be a desirable feature if you compare your language data since you care whether the vectors you want to compare have the same size and there are other ways for remedying this short cam of the relational operators as you will learn later now the last and crucial thing to note is that internally our stores boolean values is two numbers 0 & 1 0 corresponds to the false boolean value and 1 to true what this means is that when you see the value true you would rather think of it as the number one and the number 0 for the value false let's see why this would be useful for you since the vector of boolean values returned from the comparisons of name Sanskar 1 and name some score 2 are internally represented as a vector of ones and zeros you could sum all these zeros and ones of that vector and you will find the number of pairwise comparisons done with a quality operator for names underscore one in nimes underscore two that have identical strings since false values are simply translated to zeros when you would create the sum of all these internally represented numbers of the retained vector of boolean values they would not contribute anything to the sum of these internal numerical values let's go ahead and find the sum of internal numbers not represent internally the boolean values you can use the sum function that takes all the numerical values of a vector it gives its some in our case it recognizes that the boolean values are translated as numbers and so it proceeds and takes their sum that is why it outputs a number number four which means that the two vectors have identical strings and four in four different positions as you can see I use nested code whereby the relational statement is placed within the sum function which means that the function sum will take as its input the vector of boolean values let's try it to check with the number of times a specific string that we are interested in is identified with any of the strings of names underscore one recall that this is the case of comparing pairwise a single string with each member of a character vector here the sum function outputs one and that means that there is only one successful pairwise comparison for equality let's try the same for the inequality operator as you can see by placing the inequality operator in the same place I get three the number of the rest of the pairwise comparisons when the two members of the two vectors are not equal recall that the size of the two vectors is seven let's check now the inequality comparison between a string at a vector as expected again the number is six that's it for now last time you were introduced to the concept of a boolean value into how a boolean value is interpreted in the context of comparing two numbers two strings and two vectors for equality or inequality you also learned what happens under the hood when it comes to comparing unequal in size vectors the question now is how does this relate to sub setting values from a vector will hang on in there before you attempt to answer this question since you need to learn a bit more about the rest relational operators in this video so the next complementary relational operators are the greater than and less than operators let's have a look at them when it comes to numbers things are pretty easy for instance here I check whether 4 is greater than 5 and sure enough I get the false boolean value back on the contrary when I check whether 5 is greater than 4 I get true if I change the greater than 2 the less than operator I get the exact opposite results as expected as you can see here if you compare two strings with the less than operator our checks the alphabetical order of the initial letters of the two strings in this case a from Aleksandras precedes tea from tantos and we get the true value back so this greater than and less than operators are not such useful operators for comparing two strings after all if you think about it the last two relational operators are the less than or equal to and the greater than or equal to operators this mainly applied to numbers in a short while you'll be able to appreciate their usefulness especially when you will learn how to subset vectors with the help of relational operators so as expected for indeed is less than or equal to 5 and 5 and 4 is definitely not greater than or equal to 5 the same applies to strings but as you saw a minute ago our son is done in terms of order in the alphabet so in the first case since a definitely precedes T we still get true whereas in the second case the opposite apart from the simple relational operators assigned specifically for comparing two objects are allows more complex relational operators that combine more than one of the simpler relational operators that you already saw the first one is the so called element wise logical or operator signified with a vertical bar let's go directly to an example with the GLC underscore l1 vector of the GLC dot sample package first you need to load the package as always before you use the GLC underscore l1 vector recall that GLC underscore l1 is a vector with the first language profiles of learners of Greek as a second language assume that you want to check which of the learners in jillsy underscore l1 have either Albanian or Russian as their first language this translates to two different comparisons combined with the or operator the first on the Left checks whether each member of jillsy underscore L 1 is equal to Albanian whereas the second on the right checks for equality comparison 4 of each member of jillsy underscore l1 with Russian in the middle of this complex statement is the or operator and the whole can be thought of as the following instruction give me back which of the learners are either speakers of Albanian or Russian the result will be a vector with boolean values depending on whether each of the members satisfies either of the two conditions for instance the first speaker does not have Russian or Albanians here first language where is the second one does let's head to the second complex relational operator the elementwise end operator the end operator returns a boolean vector where the true values represent members that satisfy both conditions on the right and the left side in the context of the previous statement if we replace the vertical bar that stands for or with a ampersand that signifies the end operator it is impossible to take a single true value in the retaining boolean value vector since no member could be both Albanian and Russian the end operator makes much more sense for Strings when it comes to using them for subsetting more complex objects such as data frames as you'll see in the near future for now for using end it makes sense only for numeric vectors let's see what I mean by this with an example on GLC underscore part one I remind you that the vector jillsy underscore part one store's listening task scores of the same 100 students of Greek as a second language let's see which of the students got a score less than 14 and more than 10 if you would like to see which of the students has less than 12 but not 10 you can use a combination of the existing operators for inequality and less than as in the code here along with the logical end essentially the conditions on both sides of the logical end are checked which means that when each member of chilly underscore part 1 is less than 12 and also is not equal to 10 then in the new vector a true value is recorded and the false wall and false value otherwise now it's worth noting that you could add one more condition in the previous complex expression as in this code Chang where true values are turning they are returned in the resulting boolean vector for members of GLC underscore part 1 that are less than 12 they are not equal to 10 and they are also greater than 5 recall that by a boolean vector I refer to a vector that solely consists of true and false values so the resulting boolean vector reflects whether the members of a vector satisfy the conditions of a complex expression ok now how do we use this knowledge in subsetting vectors well if we nest these complex expressions within the subsetting operators namely the square brackets then the retained or retrieved values will only be the members of the vector that map to the true values of the boolean vector let's interact what I mean by that let's take the simple expression with the less than operator if I put this expression within the square brackets then the output will be a vector with those values of the GLC underscore part 1 vector that satisfy the condition as you can see here from the retrieved vector similarly if I put within the square brackets the more complex expression with the logical end operator that we saw a minute ago repeated here then I get the values that satisfy both conditions let's try out the logical order this time in this case those members of jillsy underscore part 1 will be retrieved that are either less than 10 or more than 12 as you can see our has a very powerful mechanism in retrieving vectors values by allowing you to express for the values you want to retrieve as complex conditions as you like as we move to more complex data structures ours subsetting mechanism becomes even more important in preparing your data before you build your first statistical models in this short video you will be presented with the last way of subsetting vectors that of using character vectors as selection criterion let's see what I mean by that sometimes you may need to create a character vector whose members have tags or names attached to them that signify an attribute or feature for instance you may have a vector with the first language profiles of some speakers and you may want to attach the name of the language family that each of the languages belong to let's create such a short vector that will serve our purposes and name it a l1 underscore profiles l1 underscore profiles has the names of eight languages some of them pretty common in Europe such as Greek and German and some others as exotic as the Nigerian Congo languages Vanda and jewel for assigning a name to each member of l1 underscore profiles that represents the feature offenders you may use one of the following two ways depending on what you want to do next the first way is to use the names function what this says is that the vector with the language families of each language of l1 underscore profiles on the right of the arrow assignment operator is taking its place as a named vector attached to each member of the l1 underscore profiles vector separately let's check now how the resulting vector looks like as you can see the vector l1 underscore profiles has the language family name on top of each language what this means is that the vector is the same as earlier but now additionally it contains some more information about its members in other words the language families of the languages in l1 underscore profiles are considered metadata let's move on to the second way of creating a named vector for that I will be using the same vector but now stored under the variable name l1 underscore profiles underscore 2 to leave l1 underscore profiles and chains and work later with that now the second way is to use the set names function this function takes the l1 underscore profiles underscore two as its first argument and a vector with the names as its second argument the names being the language family names set names outputs a named character vector while it keeps the original vector l1 underscore profiles underscore two intact this means that unlike the names function that attaches the names directly 121 underscore profiles with set names you need to attach to assign the output separately to a new variable I chose the variable name alone underscore profiles underscore named here as a as a result you now have two vectors the initial unnamed vector l1 underscore profiles underscore two and the named vector l1 underscore profiles underscore named so if you want to give both vectors they are named and the named one you can use the set names function otherwise if you simply need to create a named correct named character vector out of an unnamed one use the first way with the names function so far with creating named character vectors let's head on to learn how to subset a named character vector for doing this I will choose the work with the l1 underscore profiles vector I created earlier although I could do the exact same things with l1 underscore profiles underscore named vector the reason why named character vectors can be useful is that you may subset members of a character vector based on their own they're attached named attribute in the case of l1 underscore profiles you may want to subset languages that belong to a specific language family for doing this you can use a character vector with language family names within the square brackets operator for instance for picking the first indoeuropean language you insert the character vector with a string indoeuropean as its member within the square brackets notice that such a vector does not return all languages of l1 the underscore that belonged to the indoeuropean language family but only the first one the position of the languages in l1 underscore profiles does not play a role you can subset l1 underscore profiles for other language families without caring about the position the respective languages are placed in l1 underscore profiles moreover you don't have to care about the positions of the members within the sub setting vector as you can see in l1 our score profiles the Turkic language Turkish is placed after the japonic language of Okinawan okay it's just mentioned so far the sub setting does not result to all languages of a language family in other words the character vector does not function as a selection criterion in the same way a conditional statement does for doing that namely for sub setting all indoeuropean languages for instance you could use the familiar by now conditional operator of equality as expected this line of code returns those languages whose name is into European let's see what happens under the hood the quality operator checks whether each of the names of l1 underscore profiles is equal to the string in the European for each comparison it outputs a true or false value the result of all comparisons is a logical vector that contains true and false values the job of the sub setting square bracket operator is to give back those members of l1 underscore profiles that are in the same position with the true values of the logical operators retained by the evaluated relational statement of equality in other words it outputs those members who is assigned name is into European for sub setting both indoeuropean and japonic languages you can use the logical or signified by the vertical vertical bar as demonstrated in the previous tutorial lastly you can obtain the same result with the in operator that you haven't seen until now the in operator checks whether each of the members vector on its left side belongs to the vector on its right in return it's a logical value for each pair of membership checking let's have a look at the retained logical vector the first false value results from checking whether Niger Congo belongs to the vector that contains the language families that we would like to select namely into European and japonic the next is true since the second member of l1 and the score profiles is assigned the name into European that belongs to the vector on the right of the in operator moving one step forward if you embed the statement within the square brackets the true values of the returned logical vector become now the selection criteria for the members of l1 underscore profiles so that's it for now don't forget to freeze the video on this slide in this video it's your turn to gain some handson experience by solving a few subsetting code exercises I admit that the three code exercises I prepared for you may be a bit challenging but I can assure you that if you follow the previous tutorials you have nothing to fear so the initial setting of the data to work on in the exercises is the following suppose you have three vectors whose members describe three features of a group of 50 speakers the first vector has recorded response times from an online conversation experiment for that these 50 speakers participated in the second vector has their scores on a language proficiency test and the third vector has their first languages for constructing the specific scenario I'm going to take advantage of the vectors in the GLC the sample package the first thing we need to do is to load the package ill see the sample with the library function as usual for preparing the first vector I choose the R norm function to create a simple random sample of 50 numbers that supposedly represent response times and follows a normal distribution with a mean of 5 and a standard deviation of 1.5 these numbers are supposed to represent response times in terms of seconds here I also round the numbers of the vector to two digits after the decimal point with the round function after completing the first tutorials that introduce the basic so far I will visit our norm and all the concepts related to the most commonly used probability distributions for language data analysis and explain them from scratch so no worries if you did not understand exactly what I just said for now the important thing to note is that the resulting vector has 50 numbers with a mean of 5 seconds and most of the data are around around this number around 5 seconds with an average spread of 1.5 seconds now each time you run the code of this last line you get a different simple random sample from the same distribution which means that if you run it now on your console you will get a different vector of numbers but always with a mean of five and an SD of 1.5 in order to work with the exact same vector I just created go ahead to the link in the description below and after you visit it copy the vectors the vector of numbers you see there paste it on your art studio console and assign it to the variable x underscore sample for creating the second vector you are going to extract the first 15 members of the GLC underscore part one vector which I stored here as test underscore scorers underscore sample we are almost ready to go we need to create the third vector now and we are going to do that by extracting the first 50 l ones from the jillsy underscore L 1 vector and name the vector l1 underscore sample now let's get down to the exercises notice that you you now have three different vectors whose members encode three features for 50 people in the exact same position meaning that the first member of all three vectors are the test score the response time and the first language of one in the same specific speaker the same holds for the second members of all vectors and so on in some sense these vectors could be part of a single threedimensional data unit since they all describe three different aspects of these 50 people that is why as you will see in the near future table like or spreadsheet like objects that comprise of rows and cones are really useful for encoding language language data information and you can do that with data frames in R for the time being I'm going to say at the exercises of this video let's get on to the first one here you are asked to subset the L ones for the people who have score more than 13 and response time less than four seconds lastly you're asked to find how many of these extract these figures are as a hint for completing the exercise you may subset one vector by using another vector within the square brackets since remember the data of all vectors in the same position mapped to the same individual pay attention to the formulation of the exercise it uses the conjunction end twice which means that both conditions must be satisfied the second exercise asks you to return the L ones of the speakers with a response time more than 5.5 seconds or those that have response time less than 4.5 seconds notice that this time you need to choose the set of L ones that either satisfy the first or the second conditions the or here is not exclusive which means that the vector with the desired outcome includes both the L ones of people who had a response time more than 5.5 seconds in the L ones of the people who had response time a time less than 4.5 seconds in the last exercise you need to return the scores of the speakers that have response time greater or less than half standard deviation or SD away from the mean and Albanian as their l1 recall that the SD of times underscore sample is 1.5 seconds this exercise is a bit more complicated to solve on the previous ones for completing it you need to think in terms of preparing a stepwise plan the first step is to find how many seconds equals greater or less than half an SD away from the mean of five seconds the second step is to implement the or conjunction for comparing the members of x underscore sample with the specific two numbers that you'll have that you will have found in the previous step the third step is to implement the end part of the exercise namely to choose only the l1 speakers of Albanian so I'm looking forward to receiving your answers or any question that may have come up in the comment section below I will come back to the solution of the exercises in the next video since by now you already familiarize yourselves with a basic so far it's about time to start thinking of how you can have our find specific files in your machines file system and manipulate them so that in the second step it will be able to import these files as appropriate our objects meaning that it will take these files and then convert or transform them into objects that belong to one of ours data types such as character vectors or objects of a more complex data type such as data frames that we will see in later videos but before being able to import files into our it's essential to understand the concepts of a file system and a file path and also to navigate your file system with some basic art functions and that is what you are going to learn in this video let's start off with some basics and break down the concept of a file system first a file system is a set of files and folders of your machine that respects a certain hierarchical structure and that you come across every day when you open and work on your computer all operating systems have graphical user interfaces that represent folders or directories as envelope icons that you can double click on them and see their contents by the way I use the terms directory and folder interchangeably since both folders and directories essentially mean the same thing they are simply meant to contain one or more files or other folders the folders and the files that live inside a specific folder can be thought of as nodes of a tree is the one that you see here where the folders are colored colored orange and the white colored nodes underneath them are the files that you are used to see when you doubleclick on a folder files are leaves of the tree meaning that there is no way that you can place any file inside them or else they lead to a dead end the tree that you see right now is also called a file hierarchy and is a valid representation of a part of a hypothetical file system three representations like this one reflect the hierarchical structure of the files and folders in your machine of course the whole file system is much more complex since it includes a big number of branches and has many more files and folders that make its III representation much harder to display on a single slide that is why I simply omitted them and replace them with the three dots so this tree then is a partial representation of the file system a special place on the tree is its top node also called the root folder and is always signified with a forward slash the second important concept that you need to understand is that of a file path a file path is a description of a path that reaches a specific node or branch of the tree from any other place on the tree knowing how to traverse the file system in R is important since it helps us signify the path from and to any specific location on the file system that are should follow in order to find a specific file and read it so in other words through file paths you give our directions edge to where to find a file in your file system let's have a look at two paths the first path starting off from the root folder goes all the way down to sub underscore nesting underscored fear of through testing underscore deer and sub and ur score testing underscore dr1 and then ends up at this sub underscore testing underscore deer following the second path here you start from the root directory again and then through the folders testing underscore deer and sub done the score testing underscore dr1 you reached the place of the file task and score file 5 now how do you indicate a path to a specific folder or file in R or in any other programming language for that matter there are two ways of doing that through describing the path starting from the uppermost node of the tree the root folder or through describe it's relative to a different location on the tree and not the root folder the first way is implemented with an absolute path and the second one with a relative path so for writing down the absolute path leading to SAP underscore testing underscore d2 you would first need to add the root folder that is always signified with the first forward slash then the folder that is within it while the rest of the folders of the path that lead to stop on his Core testing underscore tier two are separated with more forward slashes notice the two different uses of the forward slash that is the first use in the beginning of the of the absolute path that denotes the root folder and the second use for the noting is separator between the folders for understanding what a relative path is it is better to first answer a very sensible question that a novice our user may have what does it mean to give directions to our when I actually don't know where it's starting point is is it always the root folder or some other place in other words you would need to know where the actual working directory of far is throughout your session or else which place of your filesystem are has my immediate access to let's head to the art studio console and find that out in our you can find the current working directory with the get WD function the returned output is a string that shows the actual folder in the file system whose files are has immediate access to the current working directory as you can see is the folder sub underscore testing underscore dr2 folder so they returned out which is actually in absolute path now let's get back to the second type of paths the relative paths relative paths are passed to specific folders or files written relatively to some location on the filesystem other than the root folder as I just said so you could define a path to a file relative to your current working directory let's have a look at a couple of relative paths on the tree that you saw let's assume that your current working directory is the SAP underscore testing underscore dr2 folder and you would like to describe the relative path to the file test underscore file file in order to do that you simply follow the structure of the tree you first need to go up one level and find the branch SAP runs Core testing underscore dr1 and then go down again to find the file test underscore file 5 the notation for going one level up is a double dot using a double dot in a path automatically transfers you to the folder a bowl namely namely to SAP underscore testing underscore dr1 then you again have to use the forward slash to indicate the next step to follow in the path since you already reach the SAP underscore testing underscore zero one folder the only step that remains is to go down to test underscore file 5 and you do that last last step by simply writing down the name of the file you want to reach let's take a second example suppose you are again at the same working directory as previously but now you need to go to test underscore file too this time you know that you need to go to levels up first through a SAP runs core testing underscore dr1 then through testing underscore do and then one level down to test underscore file to from the previous example you already know how to write down the first step going up and no surprise you need that here too the second step is no different from the first one though which means that I need the double dot again the last step is to go one level down after the last forward slash and I simply write down the name of the file I want to reach namely as test underscore file lets get down to practice now and try to change our current working directory to other locations within our tree using absolute and relative paths to make things easier for you I created the files and folders of the tree you see within my file system and I suggest you also create a file structure similar to our tree within a convenient place in your files them so that you can follow along the code of this tutorial as you saw earlier by using the get WD function we found out that the current working directory is the one we've been using as a starting point for the relative paths examples in order to change the current working working directory you need to use the set WD function the argument that this function takes is a string with the path to a location that you would like your new working directory to be so let's say you would like your new working directory to be testing underscore Deere which means that you would need to go to levels up in the hierarchy for this happen as you know by now you should place two double dots in a row separated by the forward slash that signifies the change in location now let's check out whether our new working directory is where we want it to be with get WD okay good notice that for setting a working directory you need to specify a path to a directory as its name says and not a file if file is not a location that contains other files and cannot be a working directory let's change our current working directory back to the previous location to levels down that means simply that you write down sequentially the folders underneath one after the other and if you want to check out the effect of the change you made you can use the get WD function again for setting your new working directory using an absolute path you simply need to write down all the folders starting from the root folder down to the one you're interested in so for setting the testing underscore D folder as the working directory I would have to write down the following path as the argument to the file to the function set WD the next step for you is to be able to programmatically ask for information related to the working directory for instance for listing the files and folders of your working directory you can use the list dot files function you can also list the contents of a different folder on the tree without change your working directory by simply using relative paths for instance let's say you would like to see what the contents of SAP underscore testing underscore dear one is to do that I write the string with a relative path of the folder I would like to checkins Condon's going one step down means to simply include the name of the folder sup underscore testing underscore tier one is the argument to list dot files function as I do here if you only need to see which folders your working directory has ignoring the files in it you list them with a list deer's function here as expected the only folder included in testing underscore dear he is sup underscore testing underscore dear one check that out on the tree that we saw earlier the output is a character vector whose members are the paths of the folders it contains notice that the first member of the return vector is a single dot a single dot represents the current working directory you don't need to know more about the single dot since it's related to the way that the file system is handled internally for now make sure to interpret the single dot in the beginning of a path as the current working directory relative to which the rest of the path can be described let's move on to asking for information about specific files within a folder and let's remind ourselves once more the contents of the working directory with the list dot files function now with the file dot info function you can ask for information about specific files as I do here with the test underscore file 6 file the output includes lots of useful information let's go ahead and see them one by here on the size indicates the file size and bytes apparently since I created empty files for the purpose of the video test underscore file 6 is empty as high and has size of 0 there is dear column indicates whether it's a folder or a file we got four since it's not a folder the mode is octal is an octal number that indicates the file permissions for all potential users this number specification has its roots to the UNIX operating system and the way that the files have been treated historically in UNIX based systems I suggest you go ahead and look up for the set for how to set file permissions and if you are interested especially if you are working on the team will share the same computer or network of computers the EM time signifies the last modified time stamp meaning the last point in time that the file was modified the seat time indicates the time stamp that the file was created while the eighttime signifies the last time it was opened the last four columns describe information about the owner of the file the group the file belongs to and as said just a minute ago it applies to shared accounts or computer networks hi there I hope you're fine and enjoy the videos of the playlist so far I haven't posted a new video for a while since I was preparing the animation of this video based on this new astonishing Python animation package called money I'm pretty excited with my name and the animation quality it provides and I hope you share this excitement with me let's see and of course any comment or advice for further improvement one on what you see here is more than welcome so let's move on to the meat of this video before moving on to factors and data frames in the next videos I intend here to present the our code solution to the first exercise of the video number 14 it was called subsetting card two vectors practice and more in this first exercise you were asked to subset the L ones of the students in the vector l1 underscore sample and to remind you l1 and the sample is a vector that includes the first 50 members of the GLC underscore part 1 vector who at the same time have scored 13 or more out of 15 in the language proficiency assessment test in the test scores are stored in the test underscore scorers vectors as you'll see in a minute and also have had a response time less than 4 seconds based on the injuries of the vector x underscore sample recall that x underscore sample is a vector with synthetic data meaning that the injuries of x underscore sample did not come from real recorded data but they were created for the purpose of these videos with the are norm function so x anushka sample contains a simple random sample of 50 numbers that represent hypothetical response times of a time measured experiment of the same people in the test underscore scores in the l1 underscore sample vector now since each time you create a simple random sample with the are known function naturally you get a different vector with 50 different random numbers if you would like to replicate the exact same response times with this in the earlier video feel free to visit the link in the video description below copy its content paste it on your RCA console and store the result two times underscore sample vector a variable name following the same name link you can also copy the two other relevant vectors l1 underscore sample and test underscore sample and test underscore scored sorry create it in video number 14 and used here and follow directly what I do in this video recall also that times underscore sample follows that the data stored in the time Sanders core sample vector follow a normal distribution with a mean of five and a standard deviation of one point five seconds now I assume that the three vectors are are aligned in terms of their members namely the first member of test underscore scores records a score of a student who has had a response time that is the first member of times underscore sample in the first language of that person is also stored in the first position of L underscore sample and so on going back to the exercise the last step for completing the exercise was to obtain the L ones of the speakers with that performance apparently this last part rings a bell for using this subsetting operator on the l1 underscore sample vector but I suggest we take things one step at a time there are two things that need to simultaneously be satisfied students with scores more than 12 and response times less than four seconds translating these two conditions in our code means you simply add the pieces in place as here what is important to understand here is how our proceeds in executing each of the two statements for the left statement are takes each member of the vector test underscore scores and compares it with the score 12 and this is where the left Bart does and the result will be a vector of logical values as you will see you then the same will happen for time underscore samples members each member will be compared with the number four that stands for four seconds and the result will again be a logical vector you for finding those students with both scores more than 12 and response times less than four seconds our proceeds in the same manner as earlier namely it simply compares the resulting logical vectors of the two separate comparisons and outputs a new logical vector with true values in positions that both logical vectors have true values in them and false otherwise the ampersand or logical and operator serves exactly that purpose namely it compares the results of the first comparison with the results of the second comparison and assigns a true value when only when the pairwise results are both true let's see the contents of the final logical vector directly in our studio console as expected here you can see there's the resulting logical vector but what was actually asked was to retrieve the first languages of the people with these performance and that means you need to think in terms of what you have to do to subset the relevant first languages of the l1 our score sample vector actually you're almost there since you already prepared the logical vector that will function as the picking mechanism within al l underscore sample recall that the three values of the resulting logical vector will be translated internally as once by our and the false values as zeros then the subsetting operator represented by the square brackets as we already know will retrieve the languages on the exact same positions that the logical vector had once in it so let's actually do this last step now you enter the complex statement within the square brackets and there you have it the first languages of the people with score results more than 12 and in response time less than four take a moment to think about what one can do with such powerful subsetting mechanism with a single line of code you can perform now this kind of complex sub settings that serve you choose subgroups of yours objects or of your texts if you're working on corpora that meet very complex and specific criteria so that you can focus on that group and test your hypothesis or build your models for your research that's it for now I hope you liked the animation and helped you real clear out the concept of subjective and of course if you liked the content of these videos don't forget to subscribe to the channel to get notifications when new videos are released see you in the next video