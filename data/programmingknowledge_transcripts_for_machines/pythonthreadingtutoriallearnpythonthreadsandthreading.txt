hey guys welcome to the Python thread tutorial for beginners so first of all what is a thread so a thread is an individual and separate unit of execution that is the part of a process now what is a process a process is simply our running program so for example if you run a browser it's a process if you run a video game it's a process now inside this process multiple threads can work together to accomplish a common goal and threads allows the program to run in parallel that is the single most important benefit of using threads so let me give you an example so when you play a video game it has to handle few tasks for example it has to handle the graphics and the user interface and if you are playing the multiplayer game it has to handle the networking and all those things it has to handle in parallel because it has to remain responsive at all the times so how does this videogame handles those parallel tasks the simple answer is threads it can assign one thread for graphics one thread for user interface and other thread for networking so by using threads the beauty game can always remain responsive and it can run the task in a parallel way now let me explain threads using this diagram so you can see this whole blue box here is a process and the threads exists inside this process so in this process you can see three threads now inside those threads you can see there is a code and local variable so a thread is a lightweight process that exists inside the process also a thread is a sequence of control flow the difference between the thread and the process is that the tread exists entirely inside the process and share its resources so let's say inside this gray box we have the global variables that each tread will be able to share those global variables and in addition each thread can have its own local variables and its own control flow to work with those local and global variables now a single process may have multiple threads of execution and as I already said that threads are useful when an application wants to perform many concurrent tasks on a shared data now let me give you one more example so think about a browser it has to handle the landing pages or the animations or if you want to open multiple website on different tabs and you want to run video in one tab and if you want to do another task in other tab most of the time the browser always remains responsive and the browser can handle multiple tasks at the same time so it uses threads to always remain responsive now there are two different kinds of threads one is a kernel thread and other is a user space thread or a user thread now kernel threads are the part of operating system while userspace threads are not implemented in kernel the userspace threads can be seen as an extension of function concepts in programming languages now each process have at least one thread and that is the main thread so if you don't even create a thread inside a process it has at least one thread and that is process itself now let's talk about the advantages of using threading so the first advantage is multithreaded programs can run faster on computer systems with multiple CPUs because these threads can be truly concurrent on multiple CPU computer systems the second advantage is the program can remain responsive to input at all the times this is true both for single and multiple CPU computer systems now the third advantage is threading allows to do something else while a thread is waiting for IO tasks or any other tasks to complete so it always remains responsive the next advantage is some programs are easy to Express using concurrency which leads to elegant solution and as a result they are easier to maintain and debug so some programs or some processes are inherently concurrent in nature and the next advantage is threads of process can share the memory of global variable so as I have already shown you in the diagram previously that multiple threads can share the memory of the global variables at the same time so if a global variable is changed in one thread this change is valid for all the threads a thread can have local variables also as we have seen in the diagram now let's talk about some of the issues or challenges you will face while programming threads for a program the first challenge is the scheduling so to execute a threaded program it must rapidly switch between threads so a program should be able to switch between threads efficiently and conveniently the second issue or challenge is the resource shirring so as I told you that multiple threads can share the same memory of the global variables so since threads share this memory and other resources it must be careful because operation performed in one thread could cause problem in another thread the next challenge you could face is of synchronizing of the threads so threads often need to coordinate their actions and as a software developer you may have heard about race condition of threads which means the outcome depends on the order of thread execution and often for synchronization we use locking primitives now that was the general description about threads now let's talk about the threads in item so in Python a thread is an object like any other object that can hold data this object can also be used to run with methods the object also can be stored in the data structures and this object can also be passed as a parameters to the methods also in Python our thread can also be executed as a process and during the lifetime of a thread it can have various states now in Python there are two modules which supports the usage of threads and these two modules are thread module and treading module now there is one thing to note here is that the tread module has been considered as deprecated for quite a long time so often users are encouraged to use that threading module instead of the thread module so if you will see in Python 3 that thread module is directly not available but indirectly you can use underscore thread to use the thread module and this is to remain backward compatible with the previous versions of the Python now the difference between the thread module and reading module is that the tread module treats the tread as the function while the module threading is implemented in an objectoriented way so in the next videos I will show you how to use these two modules in Python to create threads and handle threads in Python in the last video I have given you a brief introduction about threads and threads in Python in this video we will discuss about a module called thread module now if you remember in the last video I have told you that thread module is considered as deprecated in Python 3 but if we want to use thread module in Python 3 we can still use thread module using module called underscore thread and this is for backward compatibility so I just want to give you a brief demo about thread module in Python 3 so you will have some idea about thread module in Python 3 so let's get started so first of all in order to use thread module you need to import it and then generally you will write thread but in order to use the thread module in Python 3 you need to use the underscore thread here okay so thread module is not directly available but it's available using this underscore thread module and for printing and giving some delay to our functions we are going to import a module called time now using thread module it's possible to use functions in separate threads so we are going to create a function and then we are going to execute this function in separate threads so let's define our functions and I'm going to name my function as print underscore epoch and if you don't know what is a pape it pork is the start of January first 1970 and we are going to try to print the number of seconds from apoc till now and inside this function we are going to provide two arguments first is the name of your thread so I'm going to just write name of thread and the second argument we are going to give is the delay okay so this is your custom function you can provide any name here and any number of arguments here and now inside this function first of all I'm going to create a counter so I'm going to just write count and I'm going to initialize this count with 0 now inside this function what I'm going to do is I'm going to loop around and inside the loop I'm going to provide some delay so we will be able to see the thread execution so let me just provide the while loop here and we are going to just check whether this count is less than 3 and inside this while loop we are going to sleep for some time using that time module so I'm going to just write time dot sleep and we are going to just pass this delay argument inside this sleep function so I'm going to just write delay here which will be the delay in seconds so for example if I provide the delay of 1 then our while loop will sleep for one second now after this we are going to increment our counter so I'm going to just write count and then plus equals 1 which is going to increment the value of counter by 1 now after this in order to see whether our thread is working or not we are going to print something so let's print something using the print function so what we want to print so let's say we want to print the name of the thread whatever name we will provide for the thread and then I'm going to just give some indication here let's say this is some line and then we are going to print that time since epoch so in order to print time since epoch we will use this time module and then we just need to use the time function inside the time module so using this print function we will know which thread is executed and at what time it's executed so now we have our function and now this function we want to execute inside the thread so in order to execute this function inside the thread first of all I'm going to use this thread module and there is a special function inside this tread module which is called a start new thread function so I'm going to use that function so let's just call this function which is thought underscore new underscore thread now if you hover over this function and when I press ctrl on Windows or command on Mac and then I hover over this function you will be able to see the signature for this function so this function takes 3 arguments 1st argument is the function which we want to execute inside the thread second argument is args which we provide to our function as tuples so 2nd argument we need to provide as tuple and inside this tuple we will provide the number of argument which we want to provide to our function and third argument is that kW adds option and this kwr is an optional dictionary for the keyword arguments so let's provide the function name first of all and our function name which we want to execute is print underscore epoch and you need to remember that you need to provide this function name without any parentheses okay so just provide the function name as the first argument second is the number of arguments so we have provided two arguments for this print a pop function so we need to give these two argument in the form of tuples so first argument let's say is the name of the thread so we are going to just say that this is the thread 1 which will be the name of this thread and the second argument is the delay in seconds so let's say I want to provide 1 second delay in the while loop so it will sleep for one second this delay we are providing in order to see the thread execution because thread execution is so fast that it will be difficult to see the execution of threads without this delay now I told you that the third argument is the optional argument so we will not provide the third argument to the start new thread so this statement is going to create a new thread and it's going to execute this function inside this new thread so till now we only have one thread so let's create the second thread and to create the second thread you need to repeat this function which is start new thread and then you need to give the name to your thread so I'm going to give the name thread too and let's just change the delay so here I am going to provide the delay of 3 second to the thread 2 so now we have created two threads and this function will be executed in both that threads so let's see if this code works or not so I'm going to just run the script and you will see as soon as I run the script it exists without printing anything and this is because thread takes some time to be created and we need to wait for the thread creation so we need to provide some mechanism to wait for that thread creation and this wait we can provide in two ways one is we can just provide the blank input function which waits for the input so using this input function we will wait for some time until these threads are created and now we will see if this works or not so let's run this script once again and let's see what happens so you can see now you will be able to see these print State and you will see that first of all thread one is executed and then thread one is executed once again because we have provided only one second delay between the loop inside this thread so thread one will be executed faster than thread two so first of all thread one is executed and the ik bak time is printed and once again this thread one is executed because the delay time is less and then thread two is executed and the Epoque time is printed here and then thread one is executed once again and at the end you will see that thread two is executed two times because you can see that here we have the counter limit which is less than three so let's try to increase this limit to five and let's see how many times this print statement is printed so let's run the program once again and let's see what happens so once again this thread one is executed two times and then thread two and then thread one is executed three times once again and then tried to comes and you can see rest of the threads are executed then so here you can see thread one is executed one two three four five times and thread two is executed also five times so in this way you can start multiple threads and execute different functions inside those threads now I told you there is another way of waiting and this is by providing the while loop so I'm going to just provide wild one and inside this while loop I'm going to wait forever so I'm going to just say pass and this is an infinite loop which is like waiting so I'm going to just close this script first of all and then run the script once again and then you will see the same effect which you have seen in the case of input function also now here one more thing to consider is the return of this function so if this function which you want to execute inside the thread returns successfully the thread will silently exit but when your function terminate unexpectedly then unhandled exception will be thrown and thus track trace of that exception will be printed on the terminal so if this function throws then strike trace will be printed and this will be an unhandled exception so in order to avoid this unhandled exception you can also provide the try catch block here so here you can provide try and then i'm going to provide some space here and here also and after this code I'm going to just write accept and inside the accept you can provide any error so you can print that this is an error so inside this print function you can just write that this is and or anything which you want to write inside this accept block you can write using the print function or whatever you want to do in order to handle this exception you can do inside that accept block so let's run this script once again and let's change the delay here so I'm going to provide the delay of two seconds and here I'm going to provide the delay of let's say four seconds and let's run the script once again and this script runs and you can see after two seconds the thread one print statement is executed and then after four second thread two print statement is executed and this tried execution you will be able to see in those intervals so this is how you can use thread module in Python 3 in the last video we have seen how to use thread module in Python now in this video I'm going to show you how to use threading module in Python and I'm going to give you some introduction about threading module how to create threads using threading modules and how to use threading module now threading module is more powerful and it has more higher level support for creating threads in Python so let's see how to use threading module in Python so in order to use threading module first of all we need to import it so I'm going to just import threading module and once threading module is imported we will be able to use threading module the second module which I am going to import here is the time module which we have also seen in the last video because we are going to create the same function and we are going to use this function using the threading module which we have seen in the last video now I'm going to create the same method which I have created in the last video also which is print a box so I'm going to just copy this method in order to save time and then I'm going to just paste it here so now we have our function which we want to call using the threading module and we want to create some threads using this threading module and call this function inside those threads so first of all I'm going to write this condition which is for the main method which is if name is equal to underscore underscore main underscore underscore and under this condition what I'm going to do is I'm going to create two variables let's say first variable name is t1 for thread 1 and then I'm going to call the threading module to create a thread now inside the threading module there is a class called thread which we will use to create threads so just call the thread class here and constructor of this class takes several argument when you hover over here inside the parentheses you will see the signature of this thread class so it can take the target it can take the name of the thread and arguments also it can take in the form of tupple and it can also take the keyword argument in the form of dictionary so for our purpose we need to call the function which is print Apoc so we need to provide a target so in order to provide target we are going to just write target equals and the name of the function so the name of the function is print epoch which we are going to call and this you need to give without the parentheses so just remove the parentheses in front of this method when you use it as the argument in front of target the second argument which we want to give here is the arguments which this function takes so this argument we can give using the odds parameter so I am going to just write as equals and then in the form of couple I'm going to give the name of the thread and that delay to the thread so let's give the name to the thread let's say this is thread 1 and the delay which we want to give here is 1 so this statement is going to create one thread and let me create one more thread in order to create multiple threads and instead of T 1 I'm going to change the name to T 2 so we have T 1 variable and T 2 variable and in the arcs I'm going to change the name of the thread which is thread 2 and let's say I want to give this delay of 2 seconds to the function using the thread 2 so now we have two variables T 1 and T 2 which is an instance of that thread class now using T 1 and T 2 we can call a method called start in order to start the thread so I'm going to just call T 1 variable and then call a method called start which is going to start the thread T 1 similarly I am going to call the instance T 2 and I'm going to call the method start on this instance T 2 also so start method we use to start that threads now if you remember in the last video when we have created the thread using the thread module we have given this condition which is the infinite loop and this infinite loop we have used to wait until the execution of thread is completed now in the trading module which is the new module this facility is available using a method called join so on T one instance I can call a method called join and on T two instance also I can call a method called join and this join method waits until thread one and tried to is completed its execution and then at the end we can print something let's say we are going to print that everything is done so I'm going to print done here so let's rewind what we have done inside this script we have an imported threading module and time module and then we have created the function which we want to call using that threads now in order to create the thread using threading module we need to call the class called thread inside the threading module now this class constructor takes several arguments and right now we have given two arguments to this thread constructor which is the target which takes the name of the function which we want to execute using this thread and second argument we have given here is the args which is the argument which we want to give to the function which we want to execute same we have done for the thread two also now the start method on these instances is going to start the thread for T 1 and T 2 and the join method we have used to wait until thread 1 and thread 2 is completed their execution so let's run this script and let's see what happens so I'm going to right click and then run the threading example Python script and you can see straight away that this output is printed here similar output we have seen in the case of thread module also so in this output thread 1 is printed and the Epoque time is printed and then thread 2 is printed printed using the thread 2 so this output is printed using the thread 1 and thread 2 output is printed using the thread 2 and because we have given different intervals for a thread 1 and thread that's why we can see that thread 1 is printed and then thread 2 and then thread 1 is printed two times and then thread 2 is printed and then thread 1 is printed once again two times and then rest of the thread two outputs are printed now let's take one more example and what we are going to do at this example is we are going to create two different functions and we are going to try to call these two functions using these two threads so the first function I'm going to create here is the print underscore a cube which is going to print the value of cube of the number which we will provide as the argument to this function so I'm going to just write print here and then using this print statement I'm going to print the value of cube of the number so here I'm going to just write cube and then I'm going to provide these curly brackets and then I'm going to call the format method after this string so let's call the format method which we use in order to format a string now inside the string we want the cube of the number so we will just multiply this number three times so num Astrix num Asterix num which is going to print the cube of the number once again let me just copy this function and then I'm going to create one more function and this time I'm going to name my function as print square so I'm going to just write print square here and then I'm going to just write square is equal to and here I'm going to just print the square of the number now in this statement where we have created t1 and t2 instances the target we can change which is the name of the function so now our target is print cube and print square without the parenthesis we to give the name of this function so print cube and print square and arguments have also changed so earlier print epoch used to take two argument and now we just want to give one argument to the function and let's say it's two and also the print queue function takes one argument and let's say it's two also now let's run this script and let's see what happens so you will see that there is an exception here which is some kind of a weird exception which says that exception in thread two and this exception is this print square argument afters Asterix must be iterative all right so the problem here is we need to give a comma here which tells this parenthesis that this is a couple value okay that's why it's giving the exception so if your function takes one argument then you need to give the value of that argument and then give the comma so that it's able to understand that it's a tuple and then once again when you run this script you will see the value of cube is printed which is eight and square is printed which is 4 so this cube value is printed using thread 1 and square value is printed using the threaded 2 so in this way you can also call a multiple function using multiple thread instances using threading module so this was a brief introduction about reading module in the last video we have seen how to use treading module to create threads in Python now in this video also we are going to see how to create threads using threading module but we are going to see in this video how to subclass from the thread class which is available inside the threading module and then create threads out of that class instance so to start with I have the same method which is print Apoc which I want to inside that's Fred so now here after this method what I want to do is I want to create a class so I'm going to create a class and the name of the class I'm going to give the name as my thread for example and one thing we need to do here is we need to subclass from the thread a class from the threading module so we are going to just call first of all threading dot thread so we are sub classing from the threaded laws now inside this my class first of all we are going to define the init method so let's define this init method and in this init method we are going to pass two arguments same as this print Apoc function so first argument will be the name of the thread and the second argument will be the delay so let's provide these two arguments first is the name and second is the delay now after this inside this init method we need to call the parents init method which is threading dot red dot in it so we are going to just call threading dot thread dot underscore underscore init method which is going to call the parent init method which is treading dot treaded right now once you have done that we can just simply define some local member variable for the name so first of all self dot name is equal to name and self dot delay is equal to delay so now once we have our member variables what we need to do next is we need to override a method called run which is available inside the thread class in a threading module so I'm going to just define run method and we are going to overwrite this so first of all what this one method do so the run method is the entry point for the thread now in the previous video if you remember we have called the start method on the thread class right so the start method starts the thread by calling this run method so under the hood start method calls this run method so if we override this run method that means when we call the start method from the thread class this run method is going to be called so now we can do some logging here so what I'm going to do is I'm going to print first of all start thread and then I'm going to print and thread now between the start thread and and thread logging I'm going to call the print a pork function and this print epoch function is going to take two arguments which is name so I'm going to just pass the self dot name which we have assigned to the member variable and second is the self dot delay so once again when we call the start method on the instance of this my thread class this run method is going to be called by the start method automatically because we are sub classing from the threading dot thread class now once we have I would run the method and we have created the init method we can create some instances of my class so I'm going to create some instances for example t1 is equal to my thread and then we are going to pass those two argument first is the name so let's say the name is thread one and the delay we want to provide here is let's say one second because this delay is going to go to the print a pork method which is this one right once again we are going to create the second instance let's say t2 and once again we are going to call the my thread class which we have subclassed from the thread class and once again we are going to give these two argument first is the thread so this time I'm going to name it as thread two and the delay I'm going to give here is two second let's say and now after the instance is created we can call the start method and the join method on these two instances so let me just call t1 dot start and then we are going to call the t2 dot start and once we have the start which is going to start the threads we are going to just call the join method and by now you already know what this join method do which is to wait for the thread to be completed so I'm going to just call the join method on t2 also and let's run the script and let's see what happens so I'm going to run the script and you can see first of all start thread has been called which is from the logging of this print method and then thread one is printed and the Apoc time is printed and then thread 2 is printed and the Epoque time is printed because we have given the one second delay for the thread 1 so thread one will be iterated faster than thread two because we have provided the delay of 2 seconds four three two and one second quartz red one as soon as the thread ends we can see this print statement which is n thread and after the end of the thread two we can see this print statement which is and thread two we can also print here so let's print some more things here so we can print the name of the thread so I'm going to just write self dot name and we are going to do the same for the end thread also so I'm going to just print here also self dot name so we will know which thread is starting and we tread is ending once again I'm going to run the program and now you can see start tread thread 1 so 21 is started and then tried to is started and you can see first of all thread 1 is ended and at last thread 2 is ended so this is how you can subclass from the thread class which is available inside the threading module now inside the threading module there are some special methods which we are going to see now so the first method is so let me just go after this start of the threads so here what I'm going to do is first of all I'm going to use the print function and inside this print function I'm going to call the threading module and there are some special methods for example first of all we are going to see what is the active count of threads so what are the number of threads which are there inside this program this is going to print the number of threads now the second method which I'm going to show you is the threading first of all let me just call the threading dot we are going to call the current thread so this is going to print the current thread which is active right now and third match third which I want to show here is threading dot enumerate and this enumerate method is going to enumerate the number of threads which are active so let's run this program once again and let's see what happens so I'm going to just run this program and first of all you will see 3 is printed using this print statement which is threading dot active count so active count is going to give you the number of threads and you already know that we have created two threads and one main thread is already available so total number of threads are three here which is printed now the current thread here this print statement prints this output which is the main thread so right now at the time of this print statement main thread is active now this enumerate method as I said is going to enumerate over all the threads which are available so main thread is available and then we have created thread one which is this one this is the name of the thread one and then when I scroll here you can see thread two is available so total three threads are available main thread thread one and thread so these method you can use to just find out how many threads are there what is the current thread thread and you can also a numerate over all the threads there is one more method so I'm going to call this method here and I'm going to print it inside the print function and this time I'm going to use the instances so T 1 dot and there is a method of available here which is get name which comes from the thread class and because we are sub classing from the thread class this marm and because we are sub classing from the thread class this get name is available inside the my thread class also and same we are going to do here also so print and then T 2 dot get name so this is going to give you the name of the thread by default so I'm going to just run this script once again and you can see this is going to print thread 1 and this is going to print thread 2 now you might wonder why this name is thread 1 hasn't tried to because this get name method is going to give the value of self dot name which we have assigned using this name argument so this name is overwritten in the subclass which is my thread class and that's why it's giving us thread 1 and thread 2 name which we have provided if we change this name let's say t1 and t2 and once again we run the code you can see the name also changes to t1 and t2 so this is how you can subclass from the thread class which is available inside the training module and we have also seen some of the method which are available inside the threading module which are useful to us in this video we will see how thread synchronization works in the case of multithreading in Python and we will talk about how to use locks in the case of thread synchronization so first of all what is thread synchronization so thread synchronization is defined as the mechanism which ensures that whenever two or more threads are executed in parallel or concurrently and if they are sharing the same resource in that case all the thread should not work simultaneously or parallely on the same resource so let me explain the thread synchronization problem with the diagram so in this diagram you can see there are three threads and all these threads are sharing the same resource it can be a global variable for example so as long as all these threads are accessing this shared resource one by one not at the same time everything will work fine but the problem arises when two or more threads try to access the same global variable or shared resource at a particular time and this kind of situation is called the race condition so a race condition occurs when two or more threads can access the same shared data and they try to change the value of this same shared data at the same time and whenever this kind of race condition occurs the value of the variables may be unpredictable because if two threads working on the same global variable at the same time you will never know which thread has worked on this variable so the result is the unpredictable value of a variable now let me explain this problem with an example so I have this sample code in which in the first line I'm importing threading module and in the second line I am just declaring a global variable now I have two functions here one is thread tasks and other is mean task now inside this thread task function I want to increment the value of X every time by 1 so this is the code for this and I want to increment this value by 1 10 times so that's why I have used this for loop in the range 0 to 9 so it's going to increment the value of X 10 times inside this loop now because this X is a global variable I have just added this global keyword in front of X so our function knows that this X is not a local variable it's a global variable so this function is simple enough it just increments the value of x 10 times inside the loop and this X is this global variable which we have declared outside this function now in the main task what I'm doing is I'm creating two instances using the threading module with the help of thread class this we have already seen in the last video how to create threads using threading module so nothing new in this I have created two instances t1 and t2 and I'm passing the target is equal to the function name which is this function which is try to task so both the threads will call the same function try task and then I'm just starting both the threads with the help of start function and then I'm just using the join methods on both of the instances now here inside our main if condition I'm just calling our main task in which our threads are created and executed and then at last I want to print the value of x when all the thread execution has been completed so let's run this script and let's see what happens so you can see here the result here is 20 which is expected because we are incrementing the value of x 10 times using two threads so the value of X will be incremented ten times by thread t1 and ten times by 22 and as a result the value of X becomes 20 but as soon as I increment the value of this range let's say this is 10000 and I want to just execute this program once again there is no problem until now we can just run this program again I mean again we will not see this problem because we are incrementing the value of x 10,000 times with a single thread so we have two threads and the result is 20,000 which is absolutely fine now let's increment the value of range once again 200 thousand and now I want to show you the problem so as soon as you do this you can see that the thread synchronization problem occurs so here you can see the result is not 200 thousand which we were expecting because for such large value this scenario of thread synchronization is happening so the two threads try to work on the same variable at the same time and as a result the value of X is unpredictable so this thread synchronization problem you will see when you try to work on a same variable multiple number of times so in this case we have a hundred thousand iterations and both the threads try to iterate over the same variable using two threads and the result is unpredictable let's try to execute this once again so you can see the result is always different every time I cute this program because the result is unpredictable so how to solve this problem so one way of solving this problem is by using the locks so first of all let me just change this program and try to use locks in this Python script so to use locks what you can do is you can declare a local variable here for example lock is equal to threading dot class called lock so this is going to give you an instance of lock now this lock class have two method one is acquire and other is release now acquire method is used to lock and release method is used to release the lock so let me just complete this script and then I will explain what does these functions do so what I'm going to do is I'm going to pass this lock instance as an argument of the thread task function so I'm going to just write as is equal to and then we will just pass our lock instance as an argument of this credit task same we will do for the second thread and because we have passed this argument we need to add this argument here also so I'm going to just pass the lock instance as an argument of this function and now at last what we are going to do is just before we change the value of the global or the shed data we use this lock variable and call the method called acquires and just after you finished changing the resource or the shared data you use a method called lock dot release so once again we have passed this lot instance which we got from this lock class as an argument of this function so this is the lock instance and there are two main method inside this lock class which are acquire and release this acquire method you use two acquire the lock this lock can be blocking or non blocking so this acquire method takes one argument which is true or false by default the value of argument is true which means that this acquire is blocking by default so what does this lock dot acquire will do it locks the access of the shared variable in our case this is X and at this time only one thread can work on this variable whatever thread have the access to this function at a particular time so until and unless one thread execution is completed on this variable after that this lock is released that means that the other thread can work on this variable using the lock once again so whenever second thread wants to try to access this variable it will just lock the access to this variable first of all and then work on this variable whatever you want to do you want to increment the value or change the value of x and then release the lock and releasing means that we once again want to allow the other thread to work on this shared resource so this mechanism will allow only one thread to access this shared resource at a particular time so the Treader synchronization problem will not occur so now let's just run the program once again and let's see what's the result so you can see this problem and this problem is coming most likely because of this problem because we haven't provided args as the tuples so we need to provide this AAG as our tupple so always remember whenever you want to pass any argument using this args keyword you need to pass them as tupple so once again i'm going to just try to run this program and you can see the result is whatever we expected so because we are incrementing the value of x hundred thousand times and there are two threads which are working on the same variable so we get the two hundred thousand result which is expected now let me run this program again and again and you can see every time now we get the expected result which is two hundred thousand so this is how you can solve the thread synchronization problem using locks so this is how you can use locks to synchronize your threads in Python I hope you have enjoyed this video and I will see you in the next video