Welcome back to the Internet Simulator tool for Computer Science Principles. The tool has changed a little bit from the last time you saw it, in order to make certain things easier. Let's take a look at the changes. The widget now lets you enter ones and zeroes instead of A's and B's as before. Last time you and your partner had to work together so that you didn't set the wire or send at the same time. In this version, we've solved that problem for you, so now when you hit send, everything you typed in the key will be sent out at the bit rate you select. It can go a lot faster now. You or your partner don't have to do anything to receive a message. When the message comes in, it will just show up in the received message log. You also no longer have to worry about squashing each other's messages. The wire is now a twoway street. You can both send messages at the same exact time and each of you will receive the message intended for you. We also have a new slider called "Chunk Size". Chunk size actually does two things. The first is that it allows you to clean up your bits to make them more readable, so if you have a protocol that requires five bit chunks, you can use the slider to clean it up. To understand the second thing the chunk size slider does, we need to look at something else. You'll notice a checkbox under encodings that says "Decimal". If you check it, you will see the decimal equivalents of the binary values. Of course, how the binary is interpreted depends on how many bits per chunk you're using, so that's the second thing the chunk size slider does. It defines how many bits will be used to interpret the decimal number Notice how when you change the slider, the decimal numbers change. Important to note is that if you have extra bits dangling off the end, they will get padded with zeros before sending. You can type numbers in decimal and see their binary equivalent below You have to put a space between each decimal number you type so the tool knows how many digits to encode in binary. However, be warned the numbers still respond to the chunk size, so if you type a number that's bigger than the chunk size can handle, it actually overflows and you get seemingly weird results. Notice that at four bits per chunk, 15 is '1111', which is the largest 4bit number you can make, so 16 causes the four bits to overflow and it rolls over to all zeros. And 17 is one bigger than that, so it rolls over to '0001'. This is actually how most computers deal with overflow. This is exactly the same behavior we saw with the binary odometer widget. Even as numbers get bigger, there are only so many bits. So once you're at all ones, it rolls over to zeros and keeps going up from there. So with automatic sending and receiving of messages and the ability to define your bit chunk sizes and see the decimal values that correspond to them, you're all set to define protocols and send messages composed of numbers. Happy bit sending!