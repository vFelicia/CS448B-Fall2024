00:09 - all right
00:11 - make sure this is worked and kicked up
00:14 - all right
00:16 - great
00:18 - then we are back here for the
00:22 - continuation of our code academy live
00:24 - stream for our quiz app welcome back to
00:26 - everyone who is here live watching along
00:28 - with us and hello to people who are
00:30 - tuning in later
00:32 - uh if you want to catch up with where
00:33 - we've been so far
00:35 - the link that is in chat right now is a
00:37 - link to
00:39 - the version of the project where we have
00:41 - ended up with last time so i'll go ahead
00:43 - and link that out here
00:45 - so if you'd like to follow along by
00:47 - looking at the code you can feel free to
00:49 - go ahead and follow along with that
00:51 - there if you'd like instead to follow
00:52 - along by just watching and piecing it
00:55 - together you're welcome to do that too
00:57 - so
00:58 - uh without further ado let's go ahead
01:00 - and get back into it here so let's take
01:02 - a look at where we ended up last time
01:04 - and the problem that we were trying to
01:06 - solve
01:08 - so where we ended up
01:10 - we had our application in a state like
01:12 - this here
01:14 - so
01:16 - we
01:17 - built out our initial quiz application
01:19 - we had built out some of the controls
01:22 - that we could kind of play around with
01:23 - to get to see some of the other options
01:25 - so we ended our session with that last
01:27 - time
01:28 - and we built out some of the basic logic
01:30 - that would let us tell learners of users
01:33 - of our application whether or not they
01:35 - got something right or not as they're
01:36 - working through it
01:38 - so let's take a quick look at where we
01:39 - ended up
01:40 - so we have here asking what the first
01:42 - computer bug is we select
01:44 - in this case the month we get a green
01:47 - because that's what it is and then
01:49 - we get a bar showing up here that
01:51 - doesn't do anything
01:52 - and if we collect select something
01:54 - that's not the right answer it turns up
01:56 - red instead
01:57 - so a great start to our quiz app uh but
02:01 - we don't yet have a full game out of
02:03 - this so what we have so far is a way to
02:06 - showcase individual quiz questions to
02:09 - people who are using our application
02:12 - but there's a few things that we have
02:13 - missing
02:14 - as we stop as we're just talking about
02:16 - we'd love to be able to click on this
02:18 - next button and have something show up
02:20 - so that we can transition to the next
02:22 - question have the text here change to
02:24 - two out of four have this question
02:26 - update
02:26 - have all these clear out and have these
02:28 - answer choices update as well and that's
02:30 - what we're going to be doing in the
02:32 - session today is figuring out how we can
02:33 - use the concept of a view model which
02:36 - we'll talk about in a little bit to
02:38 - build out a more fully featured game
02:41 - that can present multiple different
02:42 - questions
02:44 - so let's go ahead and get started first
02:46 - with the easy task of making it so that
02:48 - this thing here is at least a button
02:50 - instead of just being a block of text
02:52 - now that's pretty easy to do with swift
02:54 - ui so let's go ahead into our
02:57 - bottom text
02:58 - and right now we can see that this is
03:00 - just text we'd love for this to be a
03:02 - button instead so that we can click on
03:04 - it
03:05 - we can do that by just adding in a
03:06 - button here
03:09 - and then we can see that the initializer
03:11 - for button takes in an action and a
03:13 - label
03:15 - maybe we don't know what the action is
03:16 - yet but our label can just be this texts
03:19 - that we have made down here
03:23 - for action we can just say uh
03:26 - say
03:28 - print
03:30 - hi
03:30 - we'll figure out something to do with it
03:32 - and now we can see that this should
03:34 - build and compile and then we get a
03:36 - button here we can see it turning blue
03:38 - instead
03:39 - now it's not going to do much yet it's
03:41 - just printing high and that will only
03:42 - actually happen once we have it hooked
03:44 - up a simulator as we saw before
03:48 - but now it's a button and we see that we
03:50 - can click on it
03:51 - let's do one other thing with this we'll
03:53 - do the same kind of trick that we saw
03:54 - inside the game view
03:56 - uh we had an answer button here and we
03:58 - had this on click property which let us
04:03 - decide we didn't know what we're doing
04:04 - with it yet and then pass in something
04:06 - new
04:07 - and hey the question in chat
04:10 - this is uh swift actually which does
04:12 - look very similar to kotlin swift is
04:14 - used for building ios applications
04:17 - uh okay so let's go ahead and then add
04:19 - in
04:20 - the
04:22 - on click here so we can say
04:24 - on click it's going to be
04:28 - something that
04:30 - will get passed in later and then we can
04:32 - go ahead and specify that action here
04:36 - once we add this as a property it's
04:38 - going to tell us anywhere we use this
04:39 - bottom text so we need to specify what
04:41 - we wanted to do just like it's a button
04:44 - so we can go ahead and fix that here
04:47 - we'll have i think one more place where
04:48 - this is going and we'll go ahead and
04:50 - clear that too and hello from uganda
04:53 - that is exciting
04:55 - i hope i hope you're ready to learn some
04:57 - ios development stuff here as we
04:59 - continue adding some features to our
05:01 - game
05:03 - okay so now we fix that we have a place
05:05 - where we can be adding uh to our bottom
05:08 - text nozzle button inside it as well
05:10 - that we can pass some functionality into
05:13 - uh great
05:14 - so now let's get back to that central
05:16 - question
05:17 - we have our game
05:19 - uh we can see it inside this tab view if
05:21 - we like but our game doesn't really
05:22 - accomplish anything we can see one
05:24 - question which is great but it can only
05:26 - ask one question and we really want to
05:28 - have multiple different questions that
05:30 - we can be presenting
05:31 - a single question isn't actually
05:34 - powerful enough in our game view we want
05:36 - our game view to be powered not just by
05:38 - one question but to be powered by an
05:41 - entire game a whole list of different
05:43 - questions that we can be presenting
05:46 - to the user as they're navigating
05:47 - through it
05:49 - in order to do that we're going to want
05:50 - to go ahead and add a game object
05:54 - another model which is going to
05:56 - represent all of the questions and set
05:59 - the way that the users can interact with
06:02 - our application
06:04 - so let's go ahead and do that first
06:05 - inside models we're going to make a new
06:07 - model which is going to represent the
06:09 - whole game that we're working with
06:12 - so to make a new file here you can right
06:14 - click on models click on new file
06:17 - we're going to make it swift file
06:19 - and then this is going to be our game
06:24 - so
06:25 - we have a game class that we're building
06:27 - here
06:29 - now what is a game well in this case
06:32 - it's a list of all of the different
06:34 - questions and figuring out how
06:36 - users can
06:38 - navigate through them and get informed
06:39 - if they're right or wrong
06:41 - uh and
06:42 - hate a new person late for broadcast
06:44 - good to see you here we're building out
06:46 - a quiz application for an io for ios
06:51 - oh yeah and the software for this is
06:52 - xcode which you can download on macs
06:55 - okay so on our game we need to have a
06:58 - list of questions that are available
06:59 - here
07:00 - so let's go ahead and give our game the
07:02 - questions we're going to use
07:04 - our question that we built up before
07:06 - has this static property which is all
07:09 - the questions that we're going to have
07:10 - in our game
07:11 - so we can go ahead and give our game
07:14 - those questions as it's starting
07:16 - questions
07:18 - and because it might be nice if the game
07:21 - was a little bit different each time we
07:23 - can just go ahead and shuffle it so that
07:25 - every time the order is a little bit
07:26 - different
07:27 - so they're presented in different order
07:29 - which is the same thing that academy
07:31 - does on our platform as well just
07:32 - shuffle those quizzes let's close
07:34 - questions
07:36 - okay so we have the questions that we're
07:38 - marching through which is good now we
07:41 - have some concept of multiple questions
07:43 - um but we still need to have a current
07:46 - question and a way for advancing them
07:48 - to represent that what we can do is we
07:50 - can have an index which we're using to
07:53 - store which question that we're
07:55 - currently on we want to start at the
07:58 - first question and move through each
08:00 - question until the user is done with it
08:03 - so we're going to go ahead and make our
08:05 - current question index which tracks what
08:09 - question are we on right now
08:11 - we want to start
08:13 - at question zero because array is start
08:16 - at zero for for developments
08:19 - so this is our current question index
08:22 - and then we can give ourselves a little
08:24 - bit of a convenience property here to
08:27 - say what's the current question we're on
08:29 - we could write out any time we wanted
08:31 - that like questions at this index so
08:34 - let's just make a little helper property
08:37 - to give us that here so that's current
08:39 - question
08:41 - which is going to be
08:43 - the current question index inside
08:47 - of our questions right here
08:50 - so we're starting to build out our game
08:52 - to capture the information that we need
08:55 - in order to have
08:57 - the questions that we're able to answer
08:59 - in order for the users
09:01 - okay
09:02 - so we have these here which is a great
09:04 - start and now the last thing that we're
09:06 - going to need is a way of advancing our
09:08 - game state how do we get to the next
09:10 - question
09:12 - once the user is ready to see the next
09:14 - question they've tapped on that next
09:15 - button we'll need to update our game
09:17 - that that happens so we're going to make
09:19 - a method here
09:20 - called advanced
09:22 - game state
09:23 - and this is going to go to the next
09:25 - question
09:27 - we can do that by just getting
09:29 - the next question so next question
09:32 - index
09:34 - which is going to be equal to the
09:36 - current question index plus one and then
09:38 - assigning that here
09:40 - and yeah absolutely shuffling uh makes
09:42 - the questions appear in a random order
09:44 - so the questions will always be these
09:46 - four questions you can always add your
09:47 - own questions uh but this will make it
09:50 - appear in a shuffled order so that it's
09:53 - not always
09:54 - this question appearing first it'll
09:56 - appear in a random order each time
09:59 - okay so we have our next question index
10:01 - which is going to be the current
10:02 - question index plus one
10:05 - and then we want to assign our current
10:06 - question index to be equal to the next
10:09 - question index
10:10 - when we try to build this we see that we
10:12 - have an error this tells us that self is
10:15 - immutable well
10:17 - we all know that in real life self
10:18 - changes a lot we change over time and
10:21 - there's actually a way to mark that
10:22 - inside of xcode now it expects that
10:26 - unless you specify
10:27 - otherwise
10:29 - that all of these properties should stay
10:31 - the same
10:33 - you can tell it no it's okay i know this
10:35 - is going to change
10:37 - by clicking down here and just clicking
10:38 - on the fix option which tells us that we
10:40 - want to make this function mutable
10:43 - so now it says that this function rather
10:45 - is a mutating function it can change the
10:47 - state of our application
10:50 - so that builds now we have our concept
10:52 - of a game
10:54 - now it's not much of a game but it's a
10:56 - game we have our questions we have a
10:58 - question index we know where the current
10:59 - question is and we can advance the game
11:01 - state
11:02 - there's one other good concept that we
11:04 - should use here which is the concept of
11:06 - encapsulation
11:07 - and what that means is when
11:10 - we are developing with our game
11:11 - structure and the rest of our
11:13 - application
11:14 - we only want to have access to the
11:17 - properties that we need to be using
11:20 - so for example we're going to need to
11:22 - call this advanced gamestate method so
11:24 - we need to be able to have access to it
11:26 - but we don't really need to know what
11:28 - the current question index is that's
11:30 - kind of internal business that this game
11:33 - can deal with by itself
11:35 - that's kind of private like we don't
11:36 - want to get into its inner workings and
11:38 - figure out what its current question
11:39 - index is unless we really need it so
11:42 - what we can do is we can mark that these
11:44 - are private
11:46 - and then these are
11:48 - the default which is internal
11:51 - you can leave that out because that's
11:52 - kind of the default there and then what
11:54 - we can also do is just add a little note
11:56 - for ourselves that these are going to be
11:58 - in internal methods
12:01 - internal methods and properties
12:05 - and that these here
12:07 - are private properties
12:09 - private properties
12:12 - what this mark does here aside from
12:13 - making it show up in a neat kind of
12:15 - green way is as you're looking here you
12:17 - can see that it kind of breaks out the
12:18 - different sections you have
12:20 - and if you're using uh there's this mini
12:23 - map option here
12:25 - and you can see that these marks are
12:27 - added really big so it's really easy to
12:28 - find other plans
12:30 - our files are still pretty short right
12:32 - now but occasionally you might be
12:33 - working with files that are
12:35 - dozens or well hundreds or thousands of
12:38 - lines long and it became can get really
12:40 - easy to get lost for what's where so
12:42 - adding these are called pragma marks can
12:44 - be an easy way to find things you're
12:46 - looking for
12:48 - okay so now we have our game
12:50 - now how do we work with our game
12:53 - we could go to our game view
12:57 - and then just start making a game and
12:59 - working with the game directly
13:01 - however there's a general design
13:04 - principle when building ios applications
13:07 - that tells us that that's not such a
13:08 - good idea and that's called the model
13:11 - view view model question here
13:15 - and before getting into it why is the
13:16 - var current question
13:18 - oh yeah
13:19 - quick note on syntax it's a great
13:20 - question uh this is what's called a
13:23 - computed property what this means is
13:25 - every time you want to know what the
13:27 - current question is it runs the code
13:30 - that's in between these curly braces
13:32 - so this just states what the what kind
13:34 - of thing it is this is called type
13:36 - annotation in swift
13:38 - and then in between here is how it finds
13:40 - the answer to the current question
13:43 - um some languages don't have this we
13:45 - could have also written something like
13:47 - get current question
13:50 - question as a method like this
13:54 - this would have done the same thing
13:58 - but the syntax is a little bit nicer
14:00 - because functions imply that we're doing
14:02 - something or changing things and this is
14:04 - just a property we're just getting it
14:05 - here so there's lots more you can look
14:07 - at for
14:09 - what computed properties look like like
14:11 - technically you write out these get
14:13 - keywords which show the same thing we
14:15 - have all of those in our intermediate
14:17 - swiss course if you want to get deeper
14:18 - into them for now the important thing to
14:20 - get from it is that it's just a way of
14:22 - accessing the current question and then
14:23 - this is type annotation to talk about
14:25 - what it is
14:27 - it's a great question though
14:28 - and the reason why we can't do equals is
14:30 - because it changes over time if we said
14:33 - current question index with an equal
14:35 - sign and then this index changed later
14:37 - our current question would still be
14:38 - stuck in the past so we have to
14:40 - re-compute it each time someone asks for
14:43 - it because the current question index
14:45 - might be different
14:47 - okay
14:48 - so
14:49 - now that we've gone and built our game
14:52 - out here we're talking about how to
14:54 - integrate it with the rest of our
14:55 - application
14:57 - now the general design principle to
14:59 - touch on briefly is called a mvvm
15:02 - architecture which stands for model
15:06 - view model and view so m
15:08 - v vm model view view model as
15:11 - architecture
15:13 - the general way that you describe
15:16 - building an application is we have our
15:18 - views which we can see up here and our
15:21 - views are all things that users can see
15:24 - tap on and work with directly they're
15:26 - where information gets presented to
15:28 - users and where the capture intends from
15:31 - users like if they tap on a button or
15:33 - enter text in or take a photo or
15:35 - something
15:36 - our models as we've seen are where the
15:38 - business logic and data are housed
15:41 - so this is kind of the business logic
15:44 - like our questions for application
15:46 - or our core logic about how to advance
15:49 - through the game as we're playing it
15:52 - now how can we relate the game
15:55 - and the game view
15:57 - if we just put it in directly
15:59 - our game would be very tightly coupled
16:02 - to what our game view needs it might
16:04 - have specific things that we need in our
16:06 - ios application that maybe other people
16:08 - wouldn't need as much
16:10 - the idea when you're building models is
16:12 - that they should be reusable in lots of
16:14 - different contexts
16:16 - this question that we've built
16:18 - works great in our ios application
16:20 - but it would also work in a command line
16:22 - application there's no reason why we
16:24 - have to be presenting things visually
16:26 - with this model here maybe we want to
16:28 - build a text-based version of our
16:30 - application we could still use the same
16:32 - question model doesn't use any views
16:34 - it's not talking about anything that the
16:36 - use that learners or users of the app
16:38 - can see
16:40 - so we want our our each of our uh models
16:43 - to be
16:44 - reusable in a lot of different contexts
16:47 - but that means we still have to do the
16:49 - work of translating these abstract
16:52 - businessy data concepts
16:54 - into
16:55 - views that we can actually see
16:58 - while the view could do it itself it
17:00 - would get really bloated pretty quickly
17:01 - because there's going to be some logic
17:03 - it needs to take care of
17:05 - so what we need to do instead is build
17:08 - an intermediate layer called the view
17:10 - model which is responsible for
17:13 - taking in information from the model
17:16 - and then communicating it to the view
17:18 - and so this is uh the new style of
17:20 - architecture that's used for swift ui
17:22 - you might also see mdc or model view
17:25 - controller architecture in older
17:26 - applications but this is a really clean
17:28 - and elegant way to divide out different
17:31 - pieces of your application
17:33 - so the work our view model does is it
17:36 - gets bound to our view so as the view
17:39 - model changes
17:40 - our view is going to go ahead and update
17:42 - automatically which is super convenient
17:44 - and we can keep our model this kind of
17:47 - pure business abstracted layer which we
17:50 - don't have to worry about bleeding in
17:53 - any sort of view logic into it it just
17:55 - gets to know what the state is of our
17:57 - game at any given time okay so that's
18:01 - very theoretical that's kind of like
18:02 - what view models are for what does that
18:05 - actually look like in practice let's go
18:06 - ahead and take a look
18:08 - we want to build a new directory here we
18:10 - have our views we have our models let's
18:13 - build that view models layer where we
18:14 - can be housing those
18:17 - we can do that first by making a file
18:20 - which is going to represent our game
18:21 - view model
18:23 - which is still just going to be a swift
18:24 - file
18:25 - game via model and we're going to go
18:28 - ahead and give it its own directory here
18:32 - which is going to be
18:34 - view models
18:37 - uh
18:38 - generally good to not have spaces in
18:40 - your names it'll work most of the time
18:42 - but occasionally you might get some
18:43 - weird errors from it
18:45 - okay
18:46 - and then what we could do is we could
18:47 - even reorder these so it matches our
18:50 - mvvm style so we can have our models it
18:53 - can also be really hard to like get this
18:55 - in the right spot when you're dragging
18:57 - it takes uh it takes a bit of finesse
19:01 - okay
19:02 - how's that almost
19:05 - almost
19:06 - all right so we've got our models our
19:08 - views and our view models we can expand
19:09 - those out again
19:11 - okay now what is our game view model
19:14 - gonna do well we know it needs to relate
19:16 - between our uh game view and between our
19:20 - game model
19:23 - we're going to make this a class and
19:24 - we'll see why in a little bit here the
19:26 - classes are very similar to structures
19:28 - but there's a key difference we'll get
19:29 - into in a second
19:32 - so our game view model is going to be
19:34 - our way of relating our game to our view
19:38 - so the first thing it's going to need is
19:40 - going to need a game
19:43 - so our game view model now has access to
19:46 - this game here
19:47 - now our view is not actually going to
19:50 - have access to a gate so anything that
19:52 - the view needs to do it has to go
19:54 - through the view model it's the
19:55 - gatekeeper to any of the logic that
19:57 - we're interested in
19:59 - so
20:00 - uh what does it need to do well we can
20:03 - start figuring that out by going into
20:04 - the game view and i'm going to open this
20:06 - up side by side
20:07 - if you hold down option and then click
20:10 - on a file it'll open it up side by side
20:12 - next to it which is pretty neat
20:14 - and open up our game view here
20:17 - we'll not gonna nothing's gonna look
20:19 - different for a little bit so we're just
20:20 - gonna go ahead and hide that and now we
20:22 - can see we have our game view over here
20:25 - on the right and we've got our game view
20:26 - model over here on the left
20:28 - so
20:30 - we really don't want this to just be a
20:32 - question anymore our game view needs to
20:34 - display the whole game it's not just for
20:36 - displaying a single question
20:38 - so we're going to do something dramatic
20:40 - we're going to go ahead and delete this
20:41 - question
20:42 - replace it with a game view model and
20:44 - then see a lot of different errors that
20:47 - we see so let's go ahead and take a look
20:51 - so let's go ahead and make our
20:53 - view model
20:54 - view model
20:56 - and make that a game
20:59 - view model and we can just make a new
21:00 - one with it
21:02 - and get rid of our question entirely
21:08 - as expected that seems like it broke a
21:10 - lot of things
21:11 - so we're going to go through each of the
21:13 - dependencies we had on a question and
21:16 - give those to our viewmodel instead so
21:18 - it knows how to be displaying
21:19 - information
21:21 - uh and before that you can make a trick
21:23 - in a question if they get the right
21:25 - answer you change the question since it
21:27 - becomes wrong i love it uh kind of like
21:29 - a was that game called like the
21:31 - impossible quiz it was like kind of like
21:33 - a classic web kind of thing you can
21:35 - absolutely build something like that if
21:37 - we have time we can see i could mess
21:38 - around with it at the end
21:39 - um but that's absolutely something you
21:41 - could mess with and there's lots of neat
21:43 - stateful tricks you can use there
21:46 - um okay so let's fix some of these bugs
21:48 - now it's important when you're
21:50 - developing to not get scared when
21:52 - there's a bunch of like red errors
21:54 - coming up when you're when you're
21:55 - programming something that's a that's a
21:57 - normal part of refactoring is you make a
21:59 - change you see a bunch of errors and
22:01 - then you work one by one to fix them
22:03 - in our case it's uh the errors are
22:05 - telling us exactly what we need to do
22:07 - which is why selecting a compiled
22:08 - language is super helpful is because
22:11 - once our code compiles again we know
22:13 - that we haven't broken anything too
22:15 - obvious though we still may have
22:17 - introduced some bugs we don't like
22:20 - so let's go ahead and fix these
22:22 - we know that we need to get the
22:23 - questions text is the first thing we're
22:25 - displaying
22:26 - well we need to get the question from
22:28 - here so let's go ahead and get access to
22:30 - that
22:31 - so we're going to need the uh to get the
22:34 - question from the game here from the
22:35 - game view model
22:37 - so we can go ahead and copy i wouldn't
22:40 - just say this here
22:42 - so
22:42 - we want yeah so we want to go ahead and
22:45 - have the question text
22:47 - question text and this is just a string
22:50 - games have a current question
22:53 - and questions have question text
22:55 - so now instead of having this single
22:58 - question we're going all the way back to
23:00 - the game through the view model to
23:02 - figure out what the text should be
23:04 - so here we can replace this with
23:06 - view model dot question text
23:10 - that build error goes away and now we
23:12 - can see some more errors that we can be
23:14 - resolving
23:15 - this is trying to figure out all of the
23:17 - indices to know what the for each looks
23:19 - like we can grab those two so we can say
23:22 - answer
23:23 - indices
23:25 - uh and the type of this is kind of a
23:28 - range of integers all the indices that i
23:30 - can show up
23:31 - uh game.current question that possible
23:34 - answer dot indices and now we have all
23:36 - the indices
23:40 - now we can replace
23:41 - this string here with
23:44 - view model
23:46 - dot answer indices
23:48 - great now we need to get the what should
23:51 - the text be for a particular answer we
23:53 - can build a little method that'll do
23:55 - just that
23:56 - so we can call this like answer text
24:00 - or
24:00 - index
24:02 - which is just going to give us just the
24:03 - text that we should be showing for each
24:05 - question
24:06 - for each index
24:08 - and we can do that by here looking at
24:10 - the current question
24:12 - that current question
24:14 - dot possible answers
24:17 - at whatever the index is
24:19 - and we can go ahead and replace this
24:21 - here
24:23 - with answer
24:25 - view model
24:26 - view model dot answer text for index
24:32 - and then down here we're looking at if
24:34 - the guest index was the correct the
24:36 - questions correct answer index
24:38 - so now we can just go ahead and make
24:40 - that happen from the game here
24:43 - all right we did leave the sugar
24:44 - uncovered too many bugs but we're fixing
24:46 - them all
24:48 - so we can go ahead and then have our
24:50 - correct
24:51 - answer index
24:54 - which is just a
24:57 - c
24:58 - int
24:59 - which is the current questions correct
25:01 - answer index
25:04 - and then we can update this here to be
25:05 - our view
25:07 - model
25:08 - dot correct answer index
25:12 - and last
25:13 - now because our game view here
25:16 - doesn't take in a question it just has a
25:18 - game view model we don't need to give it
25:20 - what question we're working with our
25:21 - game is going to decide that so we can
25:23 - go ahead and get rid of this from here
25:26 - and from
25:27 - our game view that we build inside of
25:30 - the tab view
25:33 - okay
25:34 - so all those build errors went away so
25:37 - let's go ahead as the a good first step
25:39 - let's see let's see if we broke
25:41 - something that's always that's always
25:42 - exciting so let's go back to our game
25:44 - view
25:46 - go ahead and resume
25:50 - and
25:52 - great we can see that it randomized it
25:54 - so we see a different question now so
25:55 - that's great and when we click on
25:57 - something great wrong answer shows up as
26:00 - red and we get that next button which
26:01 - doesn't do anything yet
26:03 - but shows up here as we wanted to
26:06 - okay
26:07 - that's always a good first step of a of
26:09 - a refactor is we want to make sure that
26:10 - we didn't break anything so so far so
26:12 - good
26:13 - we can see it's shuffling to pick new
26:15 - questions each time we're playing it
26:16 - here which is exactly what we're looking
26:18 - for
26:19 - okay so now let's go ahead and build
26:21 - that next function in here
26:23 - uh let's go ahead and click on
26:26 - making it so that clicking on next
26:28 - actually advances the question
26:29 - our game already knows how to advance
26:31 - questions it finds the next index and
26:34 - then goes and reassigns the current
26:36 - question index to be that and then all
26:38 - those places where we're talking about
26:39 - the current question we'll recalculate
26:42 - to find what that answer should be at
26:44 - least that's the hope
26:46 - so let's go ahead and build that into
26:47 - the view model so that it knows how to
26:49 - advance questions
26:51 - by giving it a
26:53 - advanced game state
26:56 - advanced
26:57 - game state
26:59 - and this just
27:00 - passes along
27:04 - uh great so we can see we had an error
27:06 - same thing that we saw before
27:08 - this game we just said was just not
27:11 - supposed to be changing so we can mark
27:12 - that it's okay for interchange
27:15 - okay
27:16 - and last let's go ahead and pass in back
27:19 - in the game view
27:21 - uh whereas it's
27:24 - great so the bottom text here instead of
27:26 - doing nothing
27:27 - let's go ahead and make it go to the
27:28 - next question
27:30 - so view model dot advanced game state
27:33 - okay
27:36 - this looks promising let's see let's see
27:38 - if we got everything hooked up that we
27:39 - need
27:41 - okay we're playing we click on binary we
27:43 - click next
27:45 - nothing happens
27:46 - now we got almost everything hooked up
27:49 - but there's one really crucial concept
27:52 - uh that we need to be using to make sure
27:54 - things are updating
27:56 - remember when before we had the index
27:58 - and we weren't allowed to change it
28:00 - unless it was marked as state
28:02 - there's something very similar happening
28:04 - here
28:06 - just like
28:08 - we need to mark things state so that
28:10 - swift ui knows to update things when
28:12 - they change
28:14 - we need to do something like that here
28:16 - our view model is definitely changing
28:18 - things are things or things are
28:19 - happening we're clicking on the button
28:21 - we are advancing our game state and we
28:23 - can parse that out and kind of prove
28:25 - that so to speak
28:26 - by using some break points
28:28 - so it's a good debugging technique
28:30 - if we go into our game view model
28:33 - uh and we could put a break point here
28:35 - we can just verify that everything's
28:37 - actually connected
28:41 - once our simulator pops up
28:45 - they do take a minute sometimes
28:48 - yeah so these are just clicking on if
28:50 - you haven't seen breakpoints before you
28:51 - can go ahead and just click on the line
28:53 - number and that makes this little
28:54 - bookmark show up
28:56 - and when you have that bookmark show up
28:57 - it means that whenever your code gets to
28:59 - that line uh it just waits there and
29:02 - then you can kind of poke around and get
29:03 - to see some of the internal state that's
29:05 - happening
29:07 - so if we
29:08 - answer here and click next
29:10 - we see that this stops we we got to this
29:12 - line we're really trying to advance the
29:14 - game stage
29:15 - but still nothing's happening
29:18 - so let's take a look at why that is
29:21 - like we mentioned before when we're
29:23 - using uh what we want our views to be
29:26 - updating things have to be marked as
29:27 - state
29:28 - now
29:29 - we can't mark
29:30 - this as state because it's a little bit
29:32 - complicated there's there's a whole
29:34 - object here it's not just a single view
29:37 - that's up
29:38 - it's not just a single thing that's
29:39 - updating it's like this whole game
29:40 - that's updating it might have any number
29:42 - of things that we care about that are
29:44 - updating that change what this looks
29:46 - like
29:48 - so what swift did is they introduced a
29:50 - special keyword for these objects which
29:52 - is called a state object
29:57 - that's the marker we want to have here
29:58 - state objects can change so they need to
30:00 - be variables changing things and not let
30:03 - constants
30:05 - now the problem is that we can only have
30:09 - observable objects as things that we
30:12 - have marked as state objects
30:15 - the reason for that is because
30:18 - things that are marked as observable
30:20 - object so swiftly knows that they can
30:23 - change and knows to update people when
30:25 - they change
30:26 - so we need to go back into our game view
30:29 - model
30:30 - and mark that it's an observable object
30:35 - now we've this should compile
30:37 - and this is indicating
30:39 - that from our views perspective
30:42 - hey this thing here is stateful it's
30:45 - going to change and when it changes
30:48 - all of these things might need to be
30:49 - redrawn a new thing has to be shown to
30:52 - the user the different question which is
30:54 - the goal of this originally
30:56 - um
30:57 - our game view model then has to be
31:00 - marked as observable objects
31:03 - to showcase yeah i can i know i'm a
31:05 - thing that can be observed i'm going to
31:07 - change
31:08 - and the last thing we have to do is mark
31:10 - what are the things we should be looking
31:12 - for again
31:13 - and that's by using this published
31:15 - marker
31:17 - there's other ways of doing this as well
31:19 - but this published marker says
31:22 - i am an observable thing
31:24 - as the game changes publish those
31:27 - changes to whoever is paying attention
31:30 - and because this is paying attention and
31:32 - hasn't marked a state object then it
31:34 - will go and update itself
31:37 - let's actually see if that happens first
31:40 - so we click on play
31:42 - we get this here we click on binary
31:46 - click resume that froze
31:49 - uh we click on something we click on
31:51 - next
31:52 - and great the question changed
31:54 - we see that we have a different question
31:56 - appearing now and the answers all change
31:58 - there's a couple things we're going to
31:59 - need to debug but we definitely are
32:01 - making the right kind of progress here
32:03 - so to recap what what what happened with
32:05 - this process we built our view model and
32:08 - we just built it without any special
32:10 - fancy swift ui markers and we found that
32:13 - even though the code was running
32:15 - things weren't hooked up exactly
32:17 - correctly we clicked the button and
32:18 - nothing happened
32:20 - the way to fix that
32:22 - is to mark
32:23 - what is a and this has to be a class
32:25 - because only classes can be an
32:26 - observable object for kind of lower down
32:28 - swift things
32:30 - but we have to make our view model a
32:32 - class
32:33 - and that's marked with observable object
32:35 - and this marked with is called
32:37 - conforming to a protocol again we have
32:39 - lots more on protocols in our
32:41 - intermediate swift course
32:43 - and then four things that are marked
32:45 - with observable object
32:47 - anything that can change that you want
32:49 - to
32:50 - redraw when they change you have to mark
32:53 - as published
32:55 - then we can mark this whole thing as a
32:57 - state object
32:59 - so great so this is great progress we
33:01 - now have the ability to show other
33:04 - questions in our application
33:06 - as we click on next we can see that
33:08 - we're rotating through the different
33:09 - questions
33:11 - now there's a few buttons all right
33:13 - anyone can type in chat what are some of
33:15 - the bugs that we're looking to fix here
33:18 - what's wrong with this with with the way
33:20 - that this application works right now
33:24 - uh perfect question change but the
33:26 - number of the question did not change
33:28 - totally that's one thing that is wrong
33:30 - with this
33:31 - right so this says one out of four we
33:32 - click next still one out of four that's
33:35 - not good that's a bug we have to fix
33:37 - uh what else what else is wrong with
33:38 - this
33:45 - it's definitely gotta fix that one out
33:47 - of four thing
33:48 - but there's something a little weird
33:49 - happening too once we click the next
33:51 - button right you can see that we're
33:53 - clicking next
33:55 - this changes this stays one out of four
33:57 - but the kind of bottom part looks a
33:59 - little bit out of whack as well looks
34:00 - like there's something not happening
34:02 - there that we'd like
34:04 - so as we click play again
34:07 - we can see that when we click on one of
34:09 - these options
34:11 - this is all good it starts off as green
34:13 - we have the button showing up as the
34:14 - right colors here but once we click on
34:16 - next
34:19 - i didn't click on anything and it just
34:20 - started as the wrong color just started
34:23 - filled in and all these buttons we can't
34:26 - click on
34:27 - that's definitely not the behavior that
34:29 - we're looking for here
34:30 - so in order to make sure that we're uh
34:33 - well having a real quiz that we can
34:35 - present to people we need to make sure
34:37 - that we're updating
34:39 - uh we're clearing this out and resetting
34:41 - every time i click on something
34:43 - so let's go ahead and fix those but
34:45 - first let's take care of the issue
34:46 - that's scott pointed out earlier
34:49 - uh where we are going to fix this little
34:51 - one out of four thing forgive me if i'm
34:53 - not pronouncing your name correctly and
34:54 - yeah absolutely we have to change the
34:55 - button color back there's a little bit
34:57 - of delay on this that's totally right
35:00 - uh okay so how can we go ahead and do
35:02 - that well let's go ahead and take this
35:03 - one out of four oh we just have this
35:06 - hard-coded so we can go ahead and fix
35:08 - that by going back to our view model
35:12 - getting rid of that and then say we need
35:14 - to have our kind of like progress text
35:16 - as a concept that might encapsulate that
35:19 - so we've got our progress text which is
35:22 - text which is a string
35:24 - and our progress text is going to be
35:28 - question something
35:31 - out of
35:32 - something else
35:33 - well
35:34 - we kind of need to know how many
35:35 - questions there are and we don't have
35:37 - access to that yet
35:38 - we can find that out by going back to
35:40 - the game
35:42 - and then here we can start exposing some
35:45 - more properties from the game so we
35:46 - could say something like the count of
35:48 - the questions
35:51 - uh
35:51 - and we also need to get the current
35:53 - index
35:54 - a couple different ways we could do that
35:56 - the easiest way to get the index is just
35:58 - to mark this as private set
36:01 - sorry private set here
36:03 - which means that
36:04 - we can read this but we're not allowed
36:06 - to write it from any other context so
36:08 - that should give us access to it
36:10 - and then we can do the same thing for
36:12 - the questions just to get to know but we
36:14 - only really need to know how many there
36:15 - are so we can actually just grab the
36:18 - question count
36:19 - that's that should do it just fine here
36:21 - and just get the questions
36:23 - count like this here so again this is
36:26 - just some playing around with some other
36:28 - things we can do with encapsulation
36:31 - so
36:31 - what can we do from there now that we
36:33 - have a question count and our current
36:34 - question we can go back into our
36:37 - game view model
36:39 - and we can say that this is not question
36:41 - x it is question
36:43 - uh game
36:45 - dot
36:46 - current question index
36:48 - out of
36:50 - we could say it's out of four but maybe
36:52 - we add more questions we wouldn't have
36:53 - to want to have to remember each time to
36:55 - be adding to be changing this around as
36:58 - we added more questions so now we can
37:00 - just grab it from our question count
37:04 - for what the progress text should look
37:05 - like
37:07 - okay
37:08 - then we can go ahead and build we can
37:10 - see that that updates which is great
37:12 - let's go ahead and see if we fix that
37:14 - bug before getting into the the real
37:15 - serious one of the where the resetting
37:18 - is not working
37:20 - so we stop
37:22 - resume because we made a bunch of model
37:23 - changes
37:26 - we play
37:27 - all right we see first computer bug
37:29 - and now
37:33 - what do we miss
37:35 - let's see so we've got our viewmodels
37:37 - current question text
37:39 - actually what did we miss it's an
37:41 - interesting question
37:45 - okay so that still says one out of four
37:46 - and we're expecting it oh well it's
37:48 - right here we didn't change our view
37:51 - so we can go ahead then and make sure
37:52 - that our view is reading from our view
37:54 - model correctly
37:56 - so view model dot progress text that's
37:59 - why it's always good to make sure that
38:00 - you're testing things as you're
38:02 - developing them because you might not
38:03 - actually be implementing things in the
38:05 - way that you think you are again very
38:08 - normal process for development is things
38:10 - don't work how can we fix them
38:13 - now this is almost right we can see that
38:14 - this is zero out of four now again
38:16 - that's because arrays started zero
38:19 - so we can fix that by just adding one to
38:21 - it inside of our view model
38:23 - just like so
38:26 - now when we go back to our game view
38:29 - and resumed because we updated our model
38:32 - our viewmodel rather now we can see that
38:34 - it has the correct number here and as we
38:37 - play we see that it's going to correctly
38:40 - update to the second question
38:43 - okay
38:44 - so solve the first part of that we fix
38:46 - this we're reading from the game we can
38:48 - advance through the questions correctly
38:50 - great
38:50 - let's go ahead and work on the resetting
38:52 - part
38:53 - now there's a lot going on for the
38:54 - resetting and part of the problem is
38:57 - all the resetting code is just owned by
38:59 - the view
39:01 - it keeps track of our guest index and it
39:03 - figures out what the color is
39:06 - now we could try to do some messy things
39:08 - inside our view by like
39:11 - resetting this to nil each time that
39:13 - someone guessed and doing that in the
39:15 - button and then sending it back again
39:19 - but that's a little bit messy
39:21 - and that's messy because maybe we want
39:23 - to have a feature where we could like go
39:24 - back and look at previous questions
39:27 - voice recognition be fantastic that's uh
39:29 - we'll see if we have time for that at
39:31 - the end uh making no promises but that'd
39:33 - be fun
39:34 - uh siri integration
39:36 - uh yeah so but let's so the reason we
39:39 - want to have the index not inside of our
39:41 - view is maybe we'll want to keep track
39:42 - of this for later on
39:44 - so let's go ahead and add that to our
39:46 - game
39:47 - we would love for our game to keep track
39:49 - of the guesses that have been made for
39:51 - each question
39:53 - now how can we do that well inside of
39:55 - our game
39:56 - we can make a new private property
39:58 - that's representing
40:00 - guesses that have been made
40:02 - so private bar guesses
40:04 - and this type is going to be a
40:07 - dictionary
40:08 - where the keys are the get are the
40:10 - question
40:12 - and the uh value is what index the
40:16 - guests for that particular question
40:19 - i believe we have content on
40:21 - dictionaries in our
40:22 - kind of learn swift course so if that's
40:25 - a new concept you should go ahead and
40:27 - read some more on dictionaries there
40:29 - they're also called maps or hash maps
40:31 - and many other languages but the idea is
40:33 - we want a way that you give a
40:36 - question in and we tell you what the
40:38 - guess index was or if it was nil if no
40:40 - guess was made
40:42 - so we're going to want a type that maps
40:45 - a guess
40:46 - to an integer
40:48 - now it's going to complain a little bit
40:50 - and it's complaining because uh well i
40:53 - guess there's nothing we want a question
40:55 - it's gonna complain because it doesn't
40:57 - know how to have questions be keys
41:01 - this is a little bit more in depth of
41:03 - how hash maps work the basic idea is
41:07 - the things at the beginning have to be
41:09 - hashable which means you need to find a
41:11 - way to turn a question into a single
41:14 - number
41:15 - so you can go ahead and put it into an
41:17 - array that's what hashing is it's a way
41:19 - of turning really complicated things
41:21 - into numbers like if you've been
41:23 - following any of the apple features
41:25 - about uh detecting inappropriate images
41:28 - on people's phones there's a lot of talk
41:30 - about the hashing that they're using for
41:32 - it and that's because hashing is a way
41:34 - of transforming an image
41:36 - into a single number so then you can do
41:38 - things with that number and compare it
41:40 - or store it
41:42 - so we can mark that this is hashable
41:45 - and here it tells us the compiler is
41:47 - very helpful telling us exactly why this
41:49 - isn't working
41:50 - uh we can do that by just adding this
41:53 - keyword right next to our question
41:56 - so our question is now hashable
42:00 - because this is a fairly simple
42:02 - structure swift can figure out on its
42:05 - own
42:06 - yeah so we don't have to worry about it
42:08 - it's really it's really the beauty of it
42:09 - swift is figuring out on its own how to
42:12 - be turning this into a number and
42:13 - storing it we don't have to worry about
42:15 - the process that it's using to do that
42:17 - uh if our structure was more complicated
42:20 - we would need to add in a special uh bit
42:23 - of command like a hash into hash value
42:26 - and hash into and we'd have to define
42:28 - these and tell it hey how do you turn
42:30 - things into numbers
42:32 - and
42:33 - here and how do you get the number back
42:35 - from the original thing
42:36 - but because this is simple enough
42:38 - supposed to do that for us automatically
42:41 - and the real in-depth answer is it's
42:43 - it's not just turning a number and
42:45 - storing it the way hash maps work is
42:47 - that there's like an underlying array or
42:49 - list we turn it into a number and then
42:52 - we kind of count
42:53 - buckets in the list
42:55 - until we get back it's kind of like
42:57 - duckduckgo you're just kind of counting
42:59 - one by one
43:00 - until you get to the spot that it should
43:02 - put it at and then you slot it there so
43:04 - lots more on hash maps and on
43:06 - dictionaries on codecademy platform but
43:08 - the basic idea is we want to get a map
43:10 - here
43:11 - and hashable will let us do that
43:14 - uh so back in our game we now have a
43:16 - place to be storing our guesses which is
43:18 - great
43:19 - uh
43:20 - then we can go ahead and give a function
43:22 - so that the user can make a guess
43:26 - and make a guess at an index we're going
43:28 - to make it simple and just always you're
43:30 - only able to guess for current questions
43:33 - uh
43:34 - if there was a different if we need to
43:35 - go back and change guesses around we
43:37 - could add that in that functionality
43:39 - later
43:41 - so we can go ahead and make our guess at
43:43 - the current question
43:44 - and set it equal to whatever the guest
43:46 - index was right here
43:49 - then in our view model we're going to
43:51 - need to have a way to make a guess and
43:54 - to translate that in
43:56 - now our game view still has this guest
43:58 - index
43:59 - we don't want this anymore the guest
44:01 - index should be only part of our view
44:04 - model
44:05 - and our game model but it shouldn't be
44:07 - part of our view
44:08 - we can do the same thing we did before
44:10 - let's open up our view model side by
44:12 - side
44:13 - let's just get rid of this
44:16 - and now let's figure out what we needed
44:18 - it for
44:20 - okay
44:21 - so one thing that we needed to do is we
44:23 - just set the guest index here directly
44:26 - now that we know our now that we have
44:28 - this make guess we can go ahead and add
44:30 - that to our model
44:32 - so we'll call this make guess
44:36 - or current question
44:39 - at
44:40 - index
44:42 - and then this will just go ahead and
44:43 - tell our game to make a guess at the
44:45 - index
44:48 - so we can go ahead and tell our view
44:50 - model to make a guess for the current
44:52 - question index and we'll just go ahead
44:54 - and do that
44:57 - we also have this thing that we're
44:59 - checking for if the guest index isn't
45:01 - nil
45:02 - this has always been a little bit clunky
45:04 - it would be great to have a concept here
45:06 - to have uh a variable called something
45:08 - like guess was made
45:10 - uh what's the point of guessing oh it's
45:12 - a great question so to clarify when i'm
45:14 - talking about guesses here i mean as a
45:16 - user who taps on a button
45:18 - that's the act of making a guess
45:20 - so if we're looking at the application
45:22 - which i can bring up here
45:25 - uh
45:26 - well this doesn't compile right now just
45:27 - slightly unfortunate
45:31 - okay so if i'm looking at this here and
45:33 - then i click on objective c that's
45:35 - making a guess
45:36 - so they're guessing index zero for this
45:39 - particular question or if they're
45:41 - clicking on typescript they're making a
45:43 - guess at index two
45:45 - there could be a more exact phrase
45:46 - naming is always very hard maybe like
45:49 - selected answer or choice maybe that
45:51 - could be a better name for it
45:53 - um but we've been using the phrase
45:55 - guests to kind of refer to how people
45:57 - are using it which now that you
45:59 - mentioned it is not necessarily assuming
46:01 - the best of users of our application uh
46:03 - so maybe maybe choice is a much better
46:05 - concept let's go ahead and fix it first
46:07 - just to get a compiling and then we can
46:09 - change the name around because that's an
46:10 - excellent point uh we'd like people to
46:12 - be making choices rather than guesses
46:15 - they said they should have some idea of
46:16 - what they're doing hopefully
46:18 - let's go ahead and fix these errors
46:19 - first
46:20 - so when we talk about guest index or
46:22 - chosen index or selected index which
46:24 - might be better names for it we're
46:26 - checking to see if they made a guess or
46:28 - if they made a choice
46:30 - so we can make a variable to represent
46:32 - that here
46:33 - we call this something like
46:34 - guess was made
46:37 - and this is a bool it's either yes or no
46:40 - and the answer to it is
46:42 - if the guess at this index
46:46 - isn't nil
46:48 - now in our game we made this private
46:50 - we can do the same thing here where we
46:52 - can get access to it but we can't change
46:54 - it only the game can actually change the
46:56 - passes
46:58 - so then we can go back
47:01 - and ask our game
47:03 - at the
47:04 - youtube guesses
47:06 - yeah selector choice is better we're
47:08 - actually going to change that afterwards
47:09 - i just want to fix these errors first
47:10 - here it's a really good point
47:13 - so we have game dot guesses at
47:16 - what is it the current question index
47:19 - uh
47:21 - current question index here or actually
47:23 - sorry we actually have a um
47:26 - guess this is by question so we have our
47:28 - current question
47:31 - do you actually we don't have a current
47:32 - question that's there we just got it
47:34 - from game dot
47:36 - questions which also don't have
47:39 - all right so we need to get the current
47:40 - question then so we can be passing it in
47:42 - here so let's go back to our game
47:46 - that's a lot of negotiation oh would you
47:48 - have a current question okay cool
47:50 - so we can go ahead i don't know why that
47:51 - wasn't showing up
47:52 - and take our game dot guesses at game
47:55 - dot current question like so
47:58 - and then we want to make sure that this
47:59 - isn't still
48:02 - cool so now we can go ahead and use this
48:05 - guess was made which is much more
48:06 - descriptive
48:07 - and to say it's if a guess was made then
48:10 - display this
48:13 - so that's all pretty straightforward and
48:15 - then the last thing we have to do is
48:16 - take this color for button and
48:18 - figure out how to fix this here
48:20 - and of course these are viewmodel
48:22 - properties
48:23 - so we just have to add that in
48:27 - okay so then our last step here is we're
48:28 - going to want to take this color for
48:30 - button
48:31 - and we're going to want to move it
48:32 - essentially all into the view model
48:35 - the view could own this we could have a
48:37 - way of translating the color back and
48:38 - forth but it's probably going to be
48:40 - simpler to just relate it here and have
48:42 - the view model tell us what the color
48:44 - should be
48:46 - so we're just going to go ahead and
48:48 - get rid of this from here
48:51 - move this into our view model
48:55 - note here that our view model uh we just
48:58 - had foundation it's going to complain
48:59 - because it doesn't know what a color is
49:02 - so we can do that by importing swift ui
49:04 - instead
49:07 - ah swift ui it's a great question this
49:10 - is directly from my mind i i if only i i
49:13 - have built this out before as a way of
49:15 - preparing for it it takes a lot of
49:17 - practice before you can build out
49:18 - something fluently here so i wouldn't
49:21 - expect anyone really to be ever to kind
49:23 - of have everything in place the first
49:25 - time and just put it together usually
49:27 - you have to build something out a few
49:28 - times to get a good sense of it that's a
49:30 - good question though
49:32 - okay so now we can go here and figure
49:34 - out how to fix this guest index
49:36 - and this guest index uh
49:39 - we can now grab from our guesses here
49:42 - so we can do the same thing and grab
49:44 - this guess
49:47 - like so
49:49 - and then we just have the correct answer
49:50 - index already here
49:53 - great so now we have our color for
49:54 - button
49:55 - and then the last thing that we can do
49:57 - is put in that this is a view model in
50:00 - the property instead
50:03 - okay there's a little bit of debate
50:05 - about whether the view model should have
50:08 - swiss ui in it at all it could still
50:10 - make sense to leave this inside the view
50:12 - that wouldn't be necessarily wrong it's
50:14 - just different ways of organizing it
50:16 - okay so everything compiles again which
50:19 - means this is a good time to see if we
50:21 - broke something so let's go ahead and
50:23 - put up our canvas here
50:26 - resume
50:28 - let it reload again
50:30 - and
50:32 - go and play
50:34 - okay so we can see here that as we click
50:36 - on things some virtuously we click next
50:39 - and it clears out it works
50:41 - we oh hopefully it works
50:44 - it works so as we keep clicking on
50:46 - things we can go ahead and see that our
50:49 - game is updating
50:50 - and our view model is also updating to
50:53 - reflect these changes now
50:55 - because our
50:56 - guesses are stored inside of our game
51:00 - instead of inside of the view
51:02 - now this doesn't have to worry about
51:04 - where we are it's all the game view
51:06 - model's responsibility which is a great
51:08 - thing to have so that our views can be
51:11 - simple and not have to worry about more
51:13 - than just how do i show information and
51:15 - how do i collect information
51:18 - uh so
51:20 - let's go ahead and make that last change
51:21 - while we're looking at it i really and
51:23 - you can let me know how you pronounce
51:24 - your name correctly i believe that was
51:26 - uh
51:27 - suggestion
51:28 - uh
51:29 - which if only i could be a wizard uh but
51:32 - for how we can go ahead and update uh
51:35 - the naming convention we're using
51:36 - internally
51:38 - i agree i think that guesses is a worse
51:40 - name than maybe selection
51:42 - i think selection might be a better name
51:44 - so let's go ahead and open up our global
51:46 - find menu by passing shift command s
51:50 - that brings this up
51:51 - and we can see every place in our
51:52 - application where we're using the term
51:54 - guess
51:57 - now we can do the simple answer
52:00 - of if we click on this find and put it
52:02 - down to replace
52:03 - we can just replace guess with
52:05 - selection
52:08 - we can say match case here and that will
52:10 - get rid of all the capital ones
52:12 - ignore in case we'll bring in
52:14 - all of them here
52:16 - so let's go ahead and see so if we're
52:18 - searching we want to change all guests
52:20 - to selection we can see that guesses
52:22 - will change to like selections a little
52:24 - weirdly so let's go ahead and do this
52:26 - first and change guesses to selections
52:30 - uh
52:31 - let's search on this
52:32 - and then we can see here we'll change
52:34 - this to selections
52:37 - and then we can do the same thing for
52:39 - guess
52:41 - and selection
52:46 - then we can go ahead and
52:49 - do the same thing for
52:51 - uh
52:52 - things that are not capitalized here so
52:54 - change guess to
52:56 - selection with a capital g
53:01 - and replace these
53:03 - and i think
53:04 - guest
53:06 - is going to become selection
53:10 - uh which would which one where
53:12 - um
53:13 - we have a guest
53:15 - uh
53:16 - just popped up
53:18 - it was guest index i think so it would
53:20 - be like selection okay
53:23 - make selection for current question
53:26 - that seems okay right
53:30 - was there somewhere else that it might
53:31 - have been messy as well
53:35 - let's ignore case let's still we can
53:37 - kind of scan through these it's always a
53:38 - good thing to look out for though
53:47 - this would be selected index
53:49 - all right so we can go ahead and fix
53:50 - that here and call this selected index
53:53 - that's a great catch thank you
53:56 - okay
53:57 - and then
53:58 - selection index
53:59 - see find and replace is a powerful tool
54:02 - but one that you have to be careful with
54:04 - uh
54:05 - but you can see that with a little bit
54:06 - of tweaking there um this is a great
54:09 - place to be showing like how kind of
54:11 - code review can work in development
54:13 - environments is there is a suggestion
54:15 - from someone looking at code that we
54:16 - could have a name to make things better
54:18 - and then we could just use a global
54:20 - finds to be figuring out the places
54:22 - we're talking about guesses and cha and
54:25 - phrase it instead as selections
54:28 - and i like that i think that makes a lot
54:29 - of sense it's a it's a concept of a
54:32 - selection rather than a guess at random
54:35 - so we can always change it back if we
54:37 - don't like it or we want to change
54:38 - something else but uh it's it's good to
54:40 - be names our names are hard names are
54:42 - always hard when you're when you're
54:43 - developing
54:44 - so appreciate the suggestion from that
54:46 - there and let's uh as always go and make
54:48 - sure we didn't break anything
54:52 - okay
54:54 - click on something we made a selection
54:57 - great
55:00 - okay
55:02 - so
55:03 - great
55:05 - okay perfect and let's check out the
55:06 - last one
55:08 - oh no
55:09 - someone crashed
55:10 - well this has actually always been here
55:12 - i just i just wasn't clicking through
55:14 - all the time
55:15 - but
55:15 - see if you can find out why do we think
55:17 - this crash right here what's going on
55:19 - what a crash
55:20 - the review kind of we can see what it
55:22 - looks like in the simulator as well but
55:24 - the kind of question all you is why did
55:26 - this crash see if we can figure it out
55:28 - uh this is what's called like a run time
55:30 - error so this is pretty bad as a user
55:33 - like imagine that this was your phone
55:35 - and as you are playing this quiz and
55:37 - happily going along and tapping on
55:39 - things
55:40 - suddenly when you click on this next
55:41 - button
55:44 - well this happens here and then your
55:46 - phone just stops or freezes what happens
55:50 - on real phones is that uh your phone
55:52 - knows that this is kind of just totally
55:54 - broken and just kills the application
55:56 - that's a really bad user experience it's
55:58 - one of the worst things that you can do
56:00 - when you're
56:01 - making an application is
56:03 - having just hard crash for people
56:05 - because they can't even use it anymore
56:07 - there's no kind of broken functionality
56:09 - or whatever
56:10 - so why did this happen
56:11 - well
56:12 - as we can see from running it in a
56:15 - simulator it actually crashes and tells
56:17 - us what the problem is
56:19 - and this is why it's always good to
56:21 - occasionally be running things in the
56:22 - simulator instead of just in the preview
56:25 - because the simulator has a lot more
56:27 - powerful functionality like the break
56:29 - points and being able to go and use
56:31 - other bits of the phone change settings
56:33 - and here we can see that it knows where
56:35 - it crashed
56:36 - and it just highlights that line right
56:38 - here
56:38 - uh yeah you're totally right it's
56:40 - because we finished four questions
56:42 - but we're still trying to go to the next
56:43 - question
56:44 - right so if we look here
56:46 - we can use a little bit of a trick to
56:48 - look at what is the current question
56:50 - index
56:51 - this po just stands for printout
56:54 - and we can see that it's four
56:56 - well what are the indices of our
56:58 - questions so if we say what are the
57:00 - questions indices
57:04 - what are the questions indices it'll
57:06 - tell us that the upper bound is four
57:07 - which means has to be less than four
57:10 - four is out of bounds we only have
57:12 - having four questions means that we have
57:14 - a question at index zero index one index
57:18 - two and index three
57:20 - no question index four that'd be a fifth
57:22 - question we don't have a fifth question
57:24 - so we crash
57:25 - well that's not good behavior as we
57:27 - talked about
57:28 - we can go ahead and fix that by having
57:30 - this advanced game state
57:33 - and if we've already been through all
57:35 - the questions
57:36 - we probably shouldn't go to the next
57:38 - question
57:39 - we should just end the game and have
57:40 - something else that we're doing
57:42 - we can do that by checking to make sure
57:44 - that this is a valid index here which is
57:47 - why we wrote this a little bit in a
57:48 - funny way you might be more used to
57:50 - seeing something like
57:52 - uh current question index plus plus or
57:54 - current question x plus equals one we're
57:56 - doing it a little bit more step by step
57:58 - so that we can check to make sure that
58:00 - it's what we want it to be
58:02 - so here we can ask the question to say
58:06 - if the questions
58:09 - uh indices
58:11 - doesn't contain the next question index
58:14 - or
58:16 - then the game is over
58:19 - and if it does then the game continues
58:21 - by going to the next question
58:24 - so what does it mean here for the game
58:26 - to be over
58:27 - well we could just print that the game
58:29 - is over
58:30 - print
58:33 - game over
58:34 - and let's see what happens now
58:39 - so as we run our application and we're
58:41 - doing this in the simulator so we can
58:42 - get those print statements we answer
58:44 - questions
58:46 - answer questions oh and game over
58:49 - great so as we
58:51 - keep tapping this is just still the
58:52 - game's over it's not letting us try to
58:54 - advance the next question it's not
58:56 - displaying anything else advancing game
58:58 - state no longer tries to go to the next
59:00 - question
59:02 - and you can see how powerful all of the
59:03 - swift ui binding is is just with that
59:06 - little bit of publishing changing this
59:08 - index makes everything change
59:10 - automatically which is really cool did
59:12 - not used to be that straightforward for
59:14 - building ios applications
59:17 - so we can end our game here
59:20 - uh and then let's just add a little
59:21 - property here just to represent whether
59:23 - or not the game's over
59:25 - so just make a
59:27 - uh game is over which is a pool
59:31 - and we can go ahead and then just set
59:33 - that here to be game is over is true and
59:36 - it should start off as false
59:41 - and then we don't need to annotate it
59:44 - okay so now we're ending the game
59:47 - it doesn't really do anything it just
59:49 - kind of tells us that the game's over
59:51 - but it doesn't break anymore so that's a
59:52 - good sign
59:53 - so that's as far as we're going to get
59:55 - to in this session here for our
59:57 - application we'll do a little bit of
59:58 - recap in a second but we can see that
60:02 - uh our game ends and where we're gonna
60:04 - end uh
60:06 - land off for for next time is saying hey
60:08 - we can advance through our quiz
60:10 - which is fantastic
60:13 - and
60:14 - we can go ahead and
60:17 - end the game but nothing happens so next
60:19 - time what we're going to look is
60:20 - figuring out how can we transition from
60:23 - this game view to a different type of
60:25 - view entirely so that some happens once
60:29 - the game is over
60:31 - uh okay so let's do a little bit of
60:34 - recap to figure out how our application
60:36 - is working here and what we added
60:38 - uh so let's see if we can still bring up
60:40 - the side by side thing
60:42 - we added in this game structure right
60:44 - here this is all totally new and this is
60:46 - our model that's representing how we're
60:49 - playing the game we have our questions
60:51 - we have our question index we can have
60:54 - some properties that we're exposing to
60:56 - our view model so that i can access them
60:58 - and then the big ways that we're
61:00 - changing it is advancing the game state
61:02 - to go the next question and making a
61:03 - selection to go ahead and reflect the
61:06 - selection that the user has made
61:08 - we added that in we went and then we
61:11 - added in this whole game view model
61:13 - which is just we can see a way to talk
61:16 - from a way to bridge the gap between
61:19 - the view and the model
61:22 - the important things to know for our
61:24 - view model is view models all need to be
61:26 - classes
61:27 - they have to be marked as observable
61:29 - objects so that once they change
61:32 - uh they update things that need to be
61:34 - updated
61:36 - and the thing that is going to be
61:38 - changing has to be marked as published
61:40 - this means as the game changes and the
61:43 - game changes
61:45 - really just by the current question
61:46 - index changing and the selections
61:48 - changing
61:49 - kind of that's how the game changes it's
61:51 - a lot of power from just these two
61:52 - properties right here
61:54 - uh
61:55 - but as these change then our game goes
61:57 - ahead and updates and it knows because
62:00 - it's marked as published that it should
62:02 - make available to anyone who's paying
62:04 - attention to it what those changes are
62:07 - we mark that we're paying attention to
62:09 - it that we care by inside the game view
62:13 - here is marked a state object which
62:15 - means that as this thing changes
62:18 - we know that the view should change as
62:20 - well and that's how all the pieces are
62:22 - connected between our view
62:24 - our view model
62:26 - and our model
62:27 - the view owns all of the views here and
62:29 - owns a state object view model
62:33 - the view model is marked as observable
62:35 - object it's a class and it marks the
62:37 - model as published
62:39 - and then the model is just a swift
62:41 - structure here that owns the core
62:44 - business logic about how the application
62:47 - uh should be should operate as the user
62:49 - interacts with it
62:51 - what the logic should be how how the
62:53 - business should change
62:55 - so that's what we covered here in this
62:57 - section uh in this session that we went
63:00 - over we're gonna pick up next time is
63:02 - figuring out how can we be adding in
63:05 - some the last bit of our application so
63:07 - clicking on this
63:08 - takes us to some final screen and ends
63:11 - the game and we can restart it and get
63:13 - some information about how we did and
63:15 - all those other nice features that would
63:17 - be good to see in a fully featured quiz
63:19 - application
63:20 - so
63:21 - uh that's what we're going to cover here
63:23 - for today that's we're going to cover in
63:24 - for next week thanks everyone who tuned
63:26 - in live for this one uh or if you were
63:29 - able to catch up and watch the video
63:30 - later on
63:31 - uh if you have any questions more for us
63:34 - we'll be back here next week uh and you
63:36 - can also feel free to reach out to us on
63:38 - the codecademy discord or on the uh
63:41 - codecademy forums
63:43 - so it was a pleasure getting to build
63:44 - some more applications with all of you
63:46 - here
63:46 - uh and then we will see all of you here
63:49 - next week for what i believe will be the
63:51 - last session in our ios quiz app
63:54 - development