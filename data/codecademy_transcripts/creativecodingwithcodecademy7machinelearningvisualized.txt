00:00 - how's it going good how are you
00:03 - i'm good uh let's let's wait a couple of
00:04 - seconds here before we get started to
00:06 - just confirm that we're live
00:08 - think all right yeah i think we are good
00:12 - to go
00:13 - um so hello everyone uh my name is alex
00:16 - this is another edition of
00:18 - creative coding with codecademy i'm here
00:20 - again with g1 juwon how's it going
00:22 - good uh everything's going well this is
00:24 - already um session seven which is
00:26 - actually
00:27 - um amazing that we've made it all whole
00:29 - way this far
00:30 - but yeah we got one more
00:33 - uh next week is going to be our last
00:35 - session but for today's session
00:37 - what we're going to be doing is we are
00:38 - going to be looking at a machine
00:40 - learning algorithm visualized using p5
00:43 - so again uh i i led the session last
00:45 - week which was very much focused on like
00:47 - let's learn this core let's learn about
00:50 - object-oriented programming through the
00:51 - lens of p5
00:52 - similarly this lesson is going to be
00:54 - let's learn about the k-nearest neighbor
00:56 - algorithm through p5 and so again g1
01:00 - you're really the p5 expert i think that
01:02 - as we're doing this uh
01:04 - i'm sure you will have lots of input
01:05 - onto different ways that i could make
01:07 - this prettier and more artistic
01:09 - um but for the most part what we're
01:11 - going to be doing is you're going to be
01:12 - seeing my very unartistic
01:14 - brain just coding out this algorithm and
01:16 - explaining the algorithm
01:18 - um as always we've got the chat open on
01:20 - youtube so if you want to talk with us
01:22 - there or ask questions there
01:24 - um very happy to chat with you there
01:27 - and then uh anything else from eugene
01:29 - before we get started
01:31 - no i'm excited cool let's do it
01:34 - so i'm gonna share my screen here
01:37 - [Music]
01:39 - all right um first thing that i want to
01:41 - say is before we get started
01:43 - i've linked in the youtube description
01:45 - uh a link to our k-nearest neighbor
01:47 - course
01:48 - um so if you want to dive deeper into
01:50 - this and go through the whole course
01:52 - um that's available to you and then the
01:54 - other thing that i've linked
01:55 - is the solution code which i'm going to
01:57 - walk through here
01:59 - so before we get started coding this
02:02 - thing
02:02 - let's actually talk about what this
02:04 - algorithm is doing
02:06 - and so this is a supervised machine
02:09 - learning algorithm
02:10 - which essentially means that we are
02:13 - uh given some data which in this case is
02:16 - going to be
02:17 - these dots on the screen we're going to
02:19 - try to
02:20 - predict something about a new piece of
02:22 - data let me actually randomize my points
02:24 - yet
02:25 - more okay more even split so
02:29 - the k nearest neighbor algorithm first
02:30 - i'm going to talk about it just as these
02:32 - dots and colors and then we can talk
02:36 - about
02:36 - okay what does this actually mean for a
02:38 - real application because who cares about
02:39 - dots and colors
02:40 - but for now let's just look at the dots
02:42 - and colors so
02:43 - right now what the k nearest neighbor
02:46 - algorithm does is it says okay we have
02:48 - all of this existing data
02:50 - we have dark blue and light green
02:53 - data that each have an x and y position
02:56 - and so we can draw them on
02:57 - a map and now if i come in with a
03:00 - new piece of data if i have something if
03:03 - i have a new dot
03:04 - that doesn't have a color but it has an
03:06 - x or y position
03:08 - the thing that we want to do is assign
03:09 - it a color and the way that we do that
03:11 - is by looking at
03:12 - its nearest neighbors so if i start to
03:15 - mouse over
03:16 - the um the canvas here you'll see that
03:19 - it kind of looks like i'm painting
03:21 - um different colors and so what's
03:24 - happening here is that
03:25 - each time i move my mouse i'm saying
03:28 - okay i have a new piece of data that i
03:29 - don't know the answer to i don't know if
03:31 - you're
03:32 - green or blue and so what we're doing
03:34 - right now and you can even see
03:36 - uh the three the three dots highlighted
03:40 - in yellow those are my three nearest
03:42 - neighbors
03:43 - and since they are all uh light green
03:46 - i'm gonna say
03:48 - okay if i had a if i had a uh
03:51 - unknown point where my mouse is that's
03:53 - also gonna be green
03:55 - if i move up here now where my mouse is
03:58 - again that unknown point
03:59 - two of those neighbors are blue and one
04:01 - of them is green and so we're gonna say
04:03 - okay we're gonna classify that unknown
04:04 - point
04:05 - as dark blue so that's that's really the
04:09 - the essence of the algorithm is we have
04:12 - known points
04:13 - we have points where the class is known
04:16 - and this is why it's a supervised
04:17 - machine learning algorithm we
04:19 - have a data set where we know things
04:20 - about it already we're saying we're
04:22 - going to use that information
04:24 - to try to classify unknown points and
04:27 - it's kind of cool you can see
04:28 - we can uh kind of paint the decision
04:31 - space here
04:32 - and we can see okay where where would
04:34 - things be classified as green versus
04:36 - where would things be
04:37 - classified as blue
04:40 - interesting so it's not just about the
04:43 - distance
04:44 - of the the new data point between uh
04:47 - between the existing points it's also
04:49 - about how many
04:50 - of those near points are for one
04:53 - category versus another
04:55 - yeah exactly and that's actually where
04:57 - the k in k nearest neighbor
04:59 - um comes from right now k is three and
05:01 - so you could think of that as okay i'm
05:03 - looking at my three nearest neighbors so
05:04 - again when my mouse
05:06 - let me re-randomize it to clear it off
05:07 - when my mouse is right here
05:09 - my three nearest neighbors are uh
05:12 - you know those three three points that
05:15 - are highlighted in yellow but if i move
05:16 - down here
05:17 - it's three different points i can also
05:19 - then change k
05:20 - and see okay if k is seven the decision
05:22 - space is gonna look different
05:24 - right uh things are gonna be classified
05:25 - differently because um we're looking at
05:27 - a wider
05:28 - section of the original data so what
05:31 - what would be some of the use cases like
05:33 - real life usage use cases where you
05:34 - would apply this algorithm to then
05:37 - yeah so so right so this is um
05:41 - uh points floating in space with colors
05:44 - the thing that we're trying to classify
05:45 - as a color
05:46 - the example that i always like to use is
05:49 - um classifying like movie ratings
05:52 - um and so you could think of something
05:56 - like
05:56 - uh light green is a thumbs up
06:00 - and dark blue is a thumbs down so
06:03 - let's say you've seen 20 movies or
06:06 - however many dots there are here
06:07 - yeah i believe there's 20. you've seen
06:09 - 20 movies already
06:10 - you've given some of them a thumbs up
06:12 - and some of them a thumbs down
06:14 - and now you can use that existing data
06:16 - to say
06:17 - okay this movie that i haven't seen
06:20 - uh am i gonna like it or not and i'm
06:22 - gonna figure that out by
06:24 - look by taking a look at the movies that
06:25 - i have seen and seeing
06:27 - which movie you know how similar my
06:30 - unseen movie is to the movies that i
06:32 - have seen
06:34 - so thinking about that you you might say
06:37 - okay then what are my two dimensions
06:39 - right i have
06:40 - uh all these points have two dimensions
06:42 - they have an x coordinate and a y
06:43 - coordinate
06:44 - you could say the x coordinate of the of
06:46 - the point is maybe
06:48 - um the year it was released and the y
06:51 - coordinate of the point
06:52 - is how many minutes long it is and so
06:55 - you can plot out all your movies where
06:57 - okay something that's way over on the
06:59 - right
06:59 - if i said x was when it was released
07:01 - maybe that's released in
07:02 - 2020 and if it's way over on the left
07:04 - that's released in 1920 or whenever
07:06 - the first movies were and then uh
07:09 - the y dimension if that's movie length
07:11 - something near the bottom might be a
07:13 - really short
07:14 - 60 minute movie something near the top
07:15 - might be a long four-hour movie
07:18 - and so you can start to say okay let me
07:20 - take all the movies that i've seen and
07:21 - rated
07:22 - put them into this gra you know plot
07:24 - them like this
07:25 - and now any movie that i haven't seen i
07:28 - can find it
07:29 - the year it came out and i can find how
07:30 - long it is and then i can say okay if my
07:33 - point were there
07:34 - would you be light green or would you be
07:36 - dark blue
07:37 - so it's a it's a way to classify things
07:39 - that um
07:41 - classify movies that you haven't seen
07:42 - before based on the movies that you've
07:43 - already seen
07:45 - cool interesting um another really
07:48 - common
07:49 - uh or really an example that's kind of
07:51 - easy to wrap your mind around
07:53 - is looking for apartments so you can
07:55 - think of the features of your apartments
07:56 - could be
07:57 - okay uh um price
08:01 - and square footage and then again the
08:03 - thing that you're the thing that you're
08:04 - determining is whether or not i might be
08:06 - interested in buying that
08:07 - and so you go and see 20 apartments you
08:10 - get your data set you say oh i i was
08:12 - interested in these i wasn't interested
08:13 - in these
08:14 - and then you can use that existing data
08:16 - set to then say
08:18 - okay this apartment that i haven't seen
08:20 - do i think i'm going to like it or not
08:22 - based on those
08:23 - those apartments i did see it could also
08:25 - be interesting to do
08:26 - to have like a plotted um points of you
08:29 - know like price could be on the x-axis
08:32 - and square footage going to be on the
08:33 - white axis and the color could be
08:35 - coordinated into
08:36 - manhattan versus brooklyn and you could
08:38 - make a guess
08:39 - um if the point was on there is it more
08:42 - likely to be a brooklyn apartment or a
08:43 - manhattan apartment that could be
08:45 - interesting thing to figure out
08:47 - totally and and i guess like a couple of
08:49 - things to talk about before we get into
08:51 - this is
08:52 - right now in all of these examples we've
08:54 - dealt with
08:55 - two features um looking to classify one
08:58 - thing so
08:59 - right movie release year and length uh
09:02 - trying to classify whether or not we
09:03 - like it
09:04 - the thing is that you can expand that to
09:06 - three dimensions so you can imagine
09:08 - plotting these points in
09:09 - three-dimensional space and then finding
09:10 - the distance between them
09:12 - so that would be like you know release
09:14 - year um
09:16 - price or release year length and
09:20 - production budget yeah budget exactly
09:22 - you can even do booleans like
09:23 - is you know tom cruise in this movie or
09:25 - something
09:26 - that could be a feature um so you can do
09:29 - that in three dimensions
09:30 - and then the really crazy thing is um
09:33 - you can do that in
09:34 - n dimensions so you can do it in four
09:36 - dimensions five dimensions and
09:38 - obviously that becomes really difficult
09:40 - to visualize
09:41 - but it's the same principle of i have
09:44 - this unknown point that's floating in
09:46 - you know ten dimensional space let me
09:48 - compare let me find its nearest
09:50 - neighbors in 10 dimensional space and
09:52 - see what class there they are
09:53 - so you can uh you know you can add more
09:55 - and more features
09:56 - um if you have those features to play
09:58 - around with
10:00 - interesting so you can get more and more
10:02 - complex
10:03 - as as complex as you want it to be yeah
10:06 - exactly and there's lots of
10:08 - i mean this this then starts to really
10:10 - get into machine learning
10:11 - um and like good machine learning
10:13 - principles of which features do you use
10:15 - which one shouldn't you be using
10:17 - um an interesting example that you gave
10:20 - of like budget
10:22 - is you have to think about the scale of
10:24 - your features
10:25 - so for example if um
10:28 - if one feature is in the scale of the
10:32 - millions and the other features in the
10:33 - scale of the tens then that feature
10:35 - that's in the scale of the millions is
10:37 - just gonna totally dominate in terms of
10:38 - distance right because like
10:40 - you know these two points might be a
10:42 - million units apart in this dimension
10:43 - and one unit apart in that other
10:45 - dimension and so
10:46 - you know your distance calculation gets
10:48 - it's a little bit hazy there so there
10:50 - might be things that you want to do to
10:52 - normalize your features um so tons of
10:54 - ways that you can dive even deeper into
10:56 - it but
10:57 - yeah that's the that's the main concept
11:00 - is that we have points in space and
11:02 - we're going to find the k closest points
11:04 - in space
11:04 - and uh and look at the class of those
11:06 - points
11:08 - cool cool cool okay folks in chat if you
11:11 - have any questions about the algorithm
11:13 - itself
11:14 - happy to answer it but for now let me
11:17 - let's go ahead and try to code this up
11:19 - um
11:21 - cool let me also pull this to the side
11:24 - just so i can have my solution code up
11:27 - in case i screw something up
11:29 - um cool so
11:32 - let me get my chat window all right
11:36 - um okay cool so i think the best way to
11:40 - start
11:41 - this project is to first of all make it
11:44 - object oriented so
11:46 - our last session is very relevant to
11:48 - this let's define
11:49 - what a point is and so let me
11:53 - go ahead and do that juwon what are the
11:56 - features of these
11:57 - points do you think first i guess
12:00 - there like you said there needs to be
12:02 - some sort of an x and y
12:03 - position right so that we're gonna need
12:07 - a um a attribute for x and y
12:11 - yeah and we can i guess that's that's
12:13 - something that we haven't talked about
12:14 - which is to
12:15 - um provide arguments as constructor i
12:18 - can't remember if we did that or not but
12:20 - that's something worth mentioning that
12:21 - we can talk about later
12:23 - oh yeah and in fact we did we what we're
12:26 - going to do for our uh
12:28 - for our version here is we're just going
12:30 - to like randomize the x and y points
12:32 - so we almost don't even need attributes
12:34 - we could just make them random right
12:36 - here
12:36 - um but yeah actually let's do that so
12:40 - we're gonna need
12:40 - x and y and then one other thing what
12:44 - else do these points all have
12:46 - color yeah color so that is the
12:50 - class of the point right so um
12:54 - yeah that's the class and eventually
12:57 - that class is going to be represented as
12:59 - a color but
13:00 - internally let's just represent that
13:02 - class as a one or a zero
13:04 - okay so cool let's
13:08 - do a little bit of setup here of just
13:10 - giving it random
13:12 - x and y uh values and
13:15 - let me find so if i do
13:19 - what was the p5 function for getting
13:21 - something random do you want it was like
13:22 - random
13:23 - [Laughter]
13:28 - so when we create a point we're going to
13:31 - give it
13:31 - a random x value between
13:35 - zero and the width of the canvas and
13:38 - uh same thing for the height and then
13:41 - for the class what we want is we want
13:43 - just one of two numbers right we want it
13:44 - to either be a
13:45 - one or a two um there's a couple of ways
13:49 - that you can do this i'm gonna
13:50 - i'm gonna do the way that i did this
13:52 - when i was coding this up but you want i
13:53 - bet you have a better way to do it
13:55 - so i did math.random
13:59 - which you can replace by random yep so
14:02 - yeah let me just do
14:04 - that's a that's a random number between
14:07 - zero and one
14:08 - right excluding one right uh so if i do
14:11 - random two that's between zero and two
14:14 - and actually two and these are all
14:17 - decimals right
14:18 - so now if i floor that i believe this
14:22 - will give me either
14:23 - zero or one right yeah i think so
14:26 - i think that's what we'll get is there a
14:28 - better way in p5
14:30 - to just say i want a random number
14:31 - between zero and one or either zero or
14:33 - one
14:34 - um i think that's that's exactly how i
14:36 - would do it
14:37 - to be honest okay cool yeah so again
14:41 - if you uh this random number is going to
14:44 - be
14:44 - a random decimal between 0 and 2. so
14:47 - that might be 0.075
14:50 - and then floor says just cut off the
14:52 - decimal basically round down so if i get
14:54 - .05 that's going to become a zero
14:56 - if i get 1.99999 that's going to become
14:59 - a 1.
15:00 - so the only things this is ever going to
15:02 - be is a 0 or a 1.
15:05 - cool all right let's also quickly write
15:09 - something to draw the points
15:11 - so i'm going to call this just yeah
15:14 - display i guess
15:17 - i'm going to draw an ellipse at
15:21 - this dot x
15:24 - this dot y i'm gonna make it
15:27 - uh 20 by 20. i think i only need one
15:30 - parameter there but
15:33 - and so that'll draw draw on ellipse we
15:34 - can even run this and of course it
15:36 - doesn't run anything yet because we
15:37 - haven't actually created points um
15:40 - let's go ahead and do that so in setup
15:43 - we can say all right let me create
15:47 - i'm going to create this as a global
15:48 - variable again something that's like
15:49 - maybe
15:50 - not great uh you want to use let instead
15:53 - of bar
15:54 - thank you um
15:58 - so i'm going to assign points to be an
16:01 - empty array
16:02 - um let's also have num points
16:06 - let's just code that in as a variable so
16:08 - i can not hard code that everywhere
16:11 - and now i'm going to uh add
16:14 - 20 points to this array so for um
16:24 - uh so i'm going to do 20
16:27 - 4 loops running 20 times um what am i
16:30 - going to do
16:31 - i need to push a new point into points
16:34 - so points dot push new
16:37 - point
16:41 - cool and then so that's creating the
16:44 - points
16:44 - and in terms of drawing the points i'm
16:46 - going to do the exact same thing i'm
16:47 - going to have a loop
16:49 - and instead of pushing a point to points
16:52 - i'm going to
16:54 - grab the point from my array
16:57 - and tell it to draw itself which i
16:59 - called display
17:04 - all right let's see
17:07 - excellent there are my points so we
17:10 - haven't done anything with the color yet
17:12 - so that would be something that is
17:14 - responsible in
17:15 - uh display so let's say
17:18 - um if this dot class
17:24 - oops sorry if it's uh
17:27 - zero for now let's just do fill
17:31 - red 255.00
17:36 - and then in javascript is it
17:40 - no just else or unless are you going to
17:43 - do one or the other are you going to
17:44 - also
17:45 - check if the class is something else i
17:48 - mean i guess we could do else because we
17:50 - know it's either gonna be zero or one i
17:51 - was gonna do an else if just to
17:53 - just that way if somehow it we screwed
17:55 - it up and it wasn't zero or one then it
17:57 - would be
17:58 - i guess you could do elsif
18:02 - yeah let me let me do lsf so else if
18:04 - this dot class
18:06 - is one then
18:10 - let me do red this one will be green
18:14 - also one more note um in javascript you
18:16 - want to make sure that there
18:18 - are you know equal regardless of type so
18:20 - you want to do three equals
18:22 - cool yeah so again this is my kind of
18:24 - lack of javascript knowledge
18:26 - so is that like if if this dot class
18:29 - were a float
18:29 - and this is an int then those wouldn't
18:31 - actually be equal
18:34 - okay cool all right
18:37 - so we've got our points they're being
18:40 - randomly generated each time we run this
18:43 - they are being redrawn which is great
18:47 - so now we can actually dive into writing
18:50 - the k nearest neighbor algorithm
18:51 - so what do we want to do we want to say
18:56 - wherever my mouse point pointer is i
18:58 - want to find the k
18:59 - nearest points and so to do that we're
19:02 - going to need to
19:03 - have some measure of distance
19:06 - there's a lot of different ways that you
19:07 - could measure distance um
19:09 - the most kind of common one is just the
19:12 - straight line distance
19:13 - so that's using some you know
19:15 - pythagorean theorem stuff
19:16 - uh a squared plus b squared equals c
19:19 - squared
19:20 - there are other distance metrics that
19:22 - you could use one is called
19:24 - um manhattan distance so rather than
19:27 - looking
19:28 - at like the diagonal from my mouse to
19:31 - this point
19:31 - it says how far over are you and how far
19:35 - up are you so it's kind of taking the
19:36 - two other sides of the triangle rather
19:38 - than the diagonal of the triangle
19:40 - um it's called manhattan distance
19:42 - because it's um like street blocks where
19:44 - i'm like oh i'm
19:45 - i'm 10 points over and 15 points up
19:49 - interesting and so i'm 25 points over so
19:52 - again this is kind of something that we
19:53 - go go through in the
19:55 - class itself but there are different
19:56 - reasons why you might want to use
19:58 - different district district
19:59 - distance metrics but for this let's just
20:02 - say
20:03 - we are going to use the straight line
20:06 - point between the
20:07 - between the two points um
20:10 - cool so we want to do that and then
20:14 - really what we want to do is we want to
20:16 - compare our distance to
20:18 - every point that exists um because we
20:21 - don't know which which point is going to
20:22 - be the closest right
20:24 - visually you and i can say okay my mouse
20:26 - is here the closest three points are
20:27 - like that one that one and that one
20:29 - but the computer can't just like look at
20:31 - it and see that so what the computer has
20:33 - to do is
20:34 - it has to look at every single point and
20:37 - say
20:37 - which are the three that i'm closest to
20:40 - so
20:40 - let's start trying to write that up
20:44 - um i'm gonna do that i'm gonna make it a
20:46 - separate function
20:48 - called classify mouse
20:55 - and um yeah we can give it no parameter
20:59 - for now
21:00 - um so again just saying maybe we should
21:03 - give it a parameter uh so we
21:04 - let's give it a parameter of k so given
21:08 - k where again that's the number of
21:09 - neighbors how is my mouse gonna be
21:11 - classified
21:12 - so right uh g1
21:15 - where my mouse is right now um if k
21:19 - were actually let me go here am i
21:22 - uh that's still even gonna be hard uh
21:26 - okay if my mouse were here
21:30 - and k were three what would my
21:33 - what would the classification be i think
21:36 - it would be green
21:37 - because there's a green one on the left
21:39 - corner there and then the green one on
21:41 - the bottom right corner there and
21:43 - there's one red
21:44 - one but because there's two green ones
21:46 - it would also be green
21:48 - yep totally um and then if if k were
21:51 - four
21:52 - the fourth closest point is probably
21:53 - that one and so we have a tie
21:55 - we'll have to think about what we do in
21:56 - ties if it were five
21:59 - looks like it would be green again it
22:00 - would be three versus two if it's if it
22:02 - were six it's back to a tie
22:03 - this one might start getting in the mix
22:05 - that one might not be closer or not
22:07 - but so that's kind of what we what we
22:09 - have to think about we're
22:10 - given k our classification might change
22:13 - from from green to red so we're going to
22:15 - need to know how many neighbors we
22:17 - actually care about
22:19 - okay cool cool so
22:22 - like i said we want to look at every
22:25 - point
22:26 - and find the distance from that point so
22:28 - let's do that by just creating a list
22:30 - so let distance is it's an empty list
22:36 - i'm going to grab my for loop for
22:39 - all of my points
22:44 - all right so what do we want to do in
22:46 - this for loop we want to say
22:48 - i want to add to distances the distance
22:51 - between my mouse
22:52 - and the point itself so g1 i had
22:55 - in my solution code i had written up a
22:57 - big nasty function so like
22:59 - doing the pythagorean theorem a squared
23:01 - plus b squared equals c squared
23:02 - you said hey there's a a p5 function
23:05 - that does exactly that for you
23:07 - um so we don't have to do that ourselves
23:09 - so do you know what that
23:10 - function is yeah there's a function of
23:12 - if i just called this
23:13 - so like short for distance and you give
23:16 - it
23:17 - um a set of four arguments first two for
23:20 - the first endpoint and then the other
23:22 - two for the second end point
23:24 - and um yeah it's generally mp5.js it's
23:27 - used to
23:27 - measure the distance between your mouse
23:29 - and an existing element and shape
23:31 - element
23:32 - in canvas so you can most common use of
23:35 - that would be like to detect whether the
23:36 - mouse is on an element or not
23:38 - so we can i think we can use that um
23:40 - this function
23:41 - instead of doing the it does behind the
23:43 - scenes exactly what you're saying the
23:45 - measuring the pythagorean
23:47 - distance between the two points the
23:48 - straight distance to between the two
23:50 - points but i think
23:51 - we can save everyone from the actual
23:54 - mathematics of it and just use the
23:55 - function
23:56 - yeah for sure um okay cool so i actually
23:59 - changed my the name of my rated
24:00 - distances because we're going to be
24:02 - storing multiple distances in there and
24:03 - let me first just save this as a
24:05 - variable
24:06 - as distance equals um
24:09 - okay so calling the dist function i need
24:12 - to give it four values now
24:13 - i can give it my mouse x
24:18 - my mouse y and now
24:21 - the x position and the y position of the
24:23 - point that i'm looking at
24:24 - so the point that i'm looking at is what
24:27 - did i call this
24:28 - points are sort of oops points are
24:31 - stored in the array called
24:33 - points points of i
24:36 - is the point that i'm looking at and
24:38 - then i want that points
24:40 - x value and then that points y value
24:48 - um cool
24:51 - and then that's the distance and so let
24:53 - me just push that on to distances
24:55 - so distances dot push
24:58 - um
25:01 - did i screw something up why is that not
25:03 - blue
25:04 - um i think it's just because it's a
25:08 - local variable i don't think there's
25:09 - anything wrong with it
25:11 - but you might want to put a let before
25:14 - distance even though
25:15 - you know javascript is fluid and that
25:17 - will work but
25:18 - yeah cool and so now actually what i'm
25:22 - going to do just to see if this is going
25:23 - to work i'm going to
25:25 - console.log distances
25:31 - and then i need to call this function
25:34 - somewhere
25:35 - so i'm going to say okay in the draw
25:37 - loop
25:38 - after i've drawn all my points let me
25:40 - call classify mouse
25:44 - with uh some parameter of
25:47 - k i'll say for right now k is three even
25:49 - though we're not doing anything with
25:50 - that yet
25:52 - and so we should see a bunch of things
25:55 - continue
25:57 - um so let me actually stop this before
25:59 - my computer overheats
26:02 - but so what that was doing was every
26:04 - every frame of the p5 loop
26:06 - which again is happening 60 frames per
26:08 - second
26:09 - um it's looking at where my mouse is and
26:11 - then it's comparing it to every other
26:13 - point
26:13 - so this is what our array looks like my
26:16 - mouse was
26:17 - 216 um
26:20 - units yeah pixels away
26:23 - from uh one of the points 247 away from
26:26 - another one of the points
26:28 - so and there's all 20 points
26:31 - so cool um in theory now we could say
26:34 - uh let's or let's sort this list
26:38 - from lowest to highest and then just
26:40 - grab our
26:41 - k closest points um
26:44 - juwan do you see an issue with that what
26:46 - are we missing if we just say
26:48 - let me sort these uh these distances and
26:51 - grab the
26:52 - three lowest ones how are we gonna tell
26:55 - which um index
26:58 - that would be the top three would be if
27:00 - that makes sense because right now we
27:02 - have it per index right and if we
27:04 - shuffle them
27:04 - um in the order that we want we're going
27:07 - to lose the order
27:09 - yeah exactly so if we were to sort this
27:12 - great it's
27:13 - it's awesome that there's a point 56
27:14 - pixels away but
27:16 - as soon as i start reordering this list
27:18 - i'm going to lose which
27:20 - pixel or which point that was connected
27:23 - with
27:23 - and the whole point of doing this is we
27:25 - need to see
27:26 - okay what it what were the classes of
27:29 - those points right we need to
27:30 - say were you red or green in order to
27:32 - make our um
27:34 - in order to classify our unknown point
27:37 - so
27:39 - juwon what would you do to fix that how
27:42 - would you
27:43 - uh because i think there are a couple of
27:44 - different things that you can do here um
27:46 - how would you kind of keep track of
27:48 - what distance is connected to which
27:50 - point
27:52 - um i think there could be a number of
27:54 - things um i don't know if my
27:56 - answer is going to complicate things but
27:58 - you could we could create what's called
28:00 - a um
28:02 - you know 2d array so to speak and so
28:04 - that we could sort based on
28:06 - one number in that one array so that so
28:09 - okay backtracking a little bit we could
28:11 - have one mega array
28:12 - and in it with individual elements could
28:15 - be another array
28:16 - that is a pair of index number and the
28:19 - value itself
28:20 - and then we could sort it based on the
28:22 - value itself and then so then
28:24 - you you reorder the arrays inside of the
28:27 - bigger array rather than
28:29 - moving around the h just the value
28:31 - itself that makes sense
28:32 - yeah totally so instead of pushing on
28:35 - just the distance what we're going to do
28:36 - is we're going to push on
28:38 - an array of distance and then
28:41 - let's say i just the the index of that
28:43 - distance was at
28:44 - so now if i run this code oh we haven't
28:47 - oh we are calling it okay and we look
28:51 - again i stopped it just because it
28:52 - keeps running forever if we look at one
28:54 - of these now we can say
28:55 - okay the yeah
28:58 - uh 318 was connected to
29:02 - um uh the point at index zero
29:06 - uh 190 was connected to the point at
29:08 - index one
29:09 - and so now if we shuffle up this uh if
29:12 - we shuffle
29:13 - up this list if we sort by this first
29:15 - number we will
29:16 - hopefully uh be able to reference back
29:19 - okay you were connected to point number
29:21 - one or you were connected to point
29:22 - number zero
29:25 - cool this is like maybe one of the
29:28 - trickier parts
29:29 - of of doing this is now we have to write
29:33 - kind of our own custom sorting function
29:35 - and i'm actually curious to see what
29:36 - happens if i just tell it to
29:38 - sort so if i do uh
29:41 - distances dot sort
29:47 - let's see what happens i don't know
29:48 - what's gonna happen here i don't
29:50 - think is it gonna work i don't think
29:53 - it's going to
29:53 - work yeah so let's see
29:57 - oh
30:00 - [Music]
30:02 - okay so it's sorting i always run into
30:05 - this in in javascript when i'm trying to
30:06 - sort and honestly i don't know
30:08 - uh how to get around it i believe it's
30:11 - sorted as if this were a string
30:13 - so the ones came first then the twos if
30:16 - i scroll all the way to the bottom
30:18 - uh you know the eights and nines are
30:20 - towards the bottom um
30:23 - so yeah that didn't quite work
30:27 - yeah so it says it's comparing i'm
30:29 - looking quickly looking up the mdn box
30:31 - but it's comparing their sequences to
30:33 - the utf-16 code units value so yeah
30:36 - it's checking it as like a string value
30:38 - as if the this was
30:40 - um that the the number that we have is a
30:43 - string
30:44 - so basically the ones come first and
30:45 - then the twos will come and then the
30:47 - threes will come
30:48 - so it doesn't matter if it's 200 or 2.
30:52 - yeah exactly and so i got to feel like
30:55 - there's a better way to
30:56 - sort a list of numbers in javascript but
30:58 - i don't know it
30:59 - um and so what i did is i wrote my own
31:02 - custom
31:03 - sort function so the way that that looks
31:06 - is you can
31:07 - pass and and again i think i'm probably
31:09 - gonna like have the terminology wrong
31:11 - here
31:12 - um as a parameter i can pass
31:15 - a function
31:19 - that takes two values and so it's saying
31:22 - okay if i'm sorting
31:23 - thing a and thing b
31:26 - if a of uh
31:30 - if the so thing a and thing b are
31:33 - one of these sub arrays of distance and
31:36 - i
31:37 - so a of zero is the first thing that
31:41 - we're comparing its distance
31:43 - if a's uh distance is greater than
31:48 - b's distance um
31:54 - then i'm going to return 1 meaning a was
31:57 - greater
31:59 - and then otherwise i'm going to return
32:01 - zero
32:02 - uh sorry return negative one meaning
32:06 - b was greater um
32:10 - now if i do this
32:16 - now let's see if this works
32:20 - [Music]
32:22 - seems good so far yeah
32:26 - i do have to say i would probably have
32:28 - done exactly the same thing as you did
32:30 - alex
32:31 - in javascript just because um so sort is
32:34 - an array method right and we are able to
32:36 - use this sort
32:37 - method because distances is a an array
32:41 - and there are a number of um javascript
32:43 - functions that you can use that is
32:45 - specific to method called method
32:47 - array methods because array in
32:48 - javascript is also kind of considered as
32:51 - an
32:51 - um javascript built-in object and that
32:54 - uh
32:54 - when we create arrays it kind of is a
32:57 - the same way as looking at it as if
32:59 - we're creating an instance of the array
33:01 - object
33:02 - and so in this way there are a number of
33:04 - um different methods that we can use
33:05 - that you can only use for
33:07 - um array objects and in javascript that
33:10 - can be a little bit confusing because
33:12 - javascript's not supposed to have a data
33:14 - type
33:14 - but um yeah this is where it gets a
33:16 - little bit tricky but the sort
33:18 - fun method can take in what's called a
33:21 - function expression
33:22 - as an argument of the sort method which
33:25 - is what alex has done in there
33:27 - and if we take a look at the mdn um
33:30 - documentation which i will post very
33:31 - soon into the chat
33:33 - this is basically what they recommend
33:34 - you do in the end on documentation that
33:38 - if you want to sort between two numbers
33:39 - and basically what happens in here
33:41 - is that even though i was returning um a
33:43 - one or a minus one depending on whether
33:45 - one is greater than the other
33:47 - what that will do is that the sort
33:49 - method will do it apply for
33:50 - all the other things and it will um go
33:53 - in like a loop so sort function
33:55 - behind the scenes will be running a loop
33:57 - and do all of these comparisons between
33:59 - all the numbers
34:00 - in the e um or the elements i guess
34:03 - all the elements inside of the distances
34:06 - um
34:07 - array and this particular one because
34:09 - you want to compare you know
34:10 - whether one one numeric value is greater
34:13 - than the other numeric value that we're
34:14 - referencing because
34:16 - um our distance is uh array is a nested
34:19 - array in an array in an array you have
34:21 - to specify which
34:22 - element in that one element area limit
34:25 - you wanted to compare it
34:27 - to and then it will do it for the whole
34:29 - loop and then order it
34:30 - so in a way you can think that this is
34:33 - actually quite a
34:34 - short a short way of doing it really
34:37 - yeah and so uh to be clear if i if i
34:39 - reverse the order here if i put the
34:40 - index first
34:42 - and then the distance second uh i would
34:45 - then say
34:45 - okay the thing that i want to sort based
34:47 - off of whenever i'm comparing two things
34:49 - in the distances list
34:51 - i don't care about i don't wanna sort by
34:53 - i right
34:54 - i wanna sort by uh the distance which
34:57 - now because i've reversed it is a of one
35:00 - and b is one
35:01 - and so if i run this again we should
35:03 - hopefully see
35:07 - um same thing yeah
35:10 - my mouse was like right on top of some
35:12 - uh five pixels away
35:14 - um there's some implement uh
35:17 - implications of ties right so if
35:20 - if my mouse is exactly the same distance
35:23 - away from two points
35:25 - um it's going to return so if if a of 1
35:29 - and b
35:30 - of 1 are equal it's going to return
35:32 - negative 1
35:33 - meaning b was actually greater so
35:36 - again it's i guess it's not
35:39 - really it'd be really hard to even
35:42 - demonstrate this
35:43 - but i suppose be aware that if two
35:47 - if two points are exactly the same
35:49 - distance away from
35:50 - uh uh from your mouse
35:53 - you have to choose one to be closer than
35:55 - the other right you can't say both are
35:56 - equally close
35:57 - i suppose you could but then things
35:58 - would get very complicated um
36:01 - and so it basically kind of it kind of
36:03 - arbitrarily picks b
36:04 - to be the one that's closer um but it is
36:07 - gonna be
36:08 - really hard to demonstrate because as
36:10 - you can see in the
36:12 - um the first element of the arrays they
36:14 - go
36:15 - up to i don't know how many number of
36:16 - the decimal points that is but um
36:19 - you will have to be really really
36:21 - accurate and it's not something that
36:23 - i guess we don't have to worry too much
36:24 - about because we're demonstrating this
36:26 - in p5
36:27 - but it could potentially be a little bit
36:29 - of like a
36:30 - edge case scenario because if you have
36:32 - like you know like very specific
36:34 - scientific points between one or the
36:36 - other and if there is a chance where
36:38 - these two could be
36:39 - you know exactly the same then it would
36:41 - arbitrarily choose
36:42 - b over a yeah same thing with uh
36:46 - whatever distance function you chose to
36:48 - use could affect this where
36:50 - again the thing that we're using is just
36:51 - the straight line distance
36:53 - which results in these decimals but if
36:56 - you did something like manhattan
36:57 - distance which is
36:58 - how many pixels over and how many pixels
37:00 - up are you away from uh
37:02 - from the point then we're not really
37:03 - going to have these decimals so
37:05 - still pretty unlikely that you would
37:06 - have that you'd be exactly the same
37:08 - distance away from two points
37:10 - but i guess slightly more likely than uh
37:13 - than using um straight line distance
37:18 - cool um where are we so we've got our
37:22 - point of let me just okay
37:25 - we've got our sorted
37:28 - list of distances and furthermore we
37:32 - have the
37:33 - uh index associated with those closest
37:35 - points
37:36 - so now what we want to do is we want to
37:37 - say let's grab those k
37:39 - closest points and see if though if
37:42 - red or green wins right or are there
37:44 - more red close red points or more close
37:46 - green points
37:47 - so let's do another for loop so let me
37:51 - even
37:52 - um grab my for loop
37:56 - because i'm lazy um
38:00 - let me also set a global variable for k
38:03 - uh no we don't even want a global
38:04 - variable for k we're using
38:06 - just though three yeah uh
38:09 - so i want this loop to happen three
38:12 - times
38:13 - and what i want to do is i want to let's
38:16 - set up two counter variables
38:18 - so class one
38:22 - um
38:26 - probably uh other clever ways to compare
38:28 - these two things
38:30 - um but i can say okay let me now go
38:33 - through my sorted
38:34 - array so i want distances
38:39 - of i i already used i so let me i don't
38:41 - know if that matters or not but let me
38:44 - use j here it shouldn't matter but yeah
38:48 - yeah um okay so let me go through my
38:51 - sorted array
38:52 - let me grab the k closest point so this
38:55 - point
38:56 - i want to look at its class so that was
39:00 - the points class
39:05 - and now i want to say if its class
39:09 - was zero there's my python trying to use
39:12 - colons uh
39:16 - if it's class with 0 0 let's do class
39:23 - i'll name these 0 and 1
39:27 - class zero uh does plus plus exists in
39:30 - javascript
39:31 - yep yep it does and then
39:36 - if it was one then
39:40 - uh class one but alex i'm thinking
39:43 - this might create an error though
39:46 - because
39:47 - the distances um array is now
39:50 - in each of the elements is an array
39:53 - right so if we
39:54 - refer to all of that what we're saying
39:55 - is that we're expecting
39:57 - the elect the array that has a pair of
39:59 - eye and distance to have
40:01 - a class called or sorry an attribute
40:03 - called
40:04 - class which it doesn't so we're going to
40:06 - have to recall
40:08 - yeah so in fact let's let's run this
40:11 - code and see the error that
40:13 - that happens um which we're not gonna
40:16 - get an actual
40:17 - error c because i guess it can
40:21 - it just neither of these happen right uh
40:23 - i'm asking for the class
40:25 - of of something that looks like this
40:28 - um which i guess it's just like that's
40:30 - undefined or something yeah it will
40:31 - return a null
40:33 - yeah yeah so in fact i can just to
40:36 - demonstrate this
40:38 - let me log that
40:42 - grab my consoles yeah so there's the the
40:44 - undefined because i screwed this up
40:46 - so we don't want to compare that
40:50 - what we want to do is we want to say
40:52 - distances
40:53 - of j of zero
40:57 - that's this variable but
41:00 - this variable is just a number right
41:02 - that's that was the zeroth element or
41:04 - the first element or whatever
41:06 - it was so we can't ask for the class of
41:07 - a number
41:09 - we want to ask for the point
41:12 - at that number which looks really
41:16 - ugly and so again let me uh
41:20 - let me log
41:23 - just this points of distances of j of
41:26 - zero
41:27 - [Laughter]
41:31 - right which is so now we're logging the
41:33 - points and the thing that we want to
41:35 - grab from the point is the class which
41:36 - is either one or zero so
41:37 - now this if statement should be working
41:39 - and we got to make sure to do that for
41:40 - the second if statement
41:43 - good catch i uh definitely wasn't even
41:46 - thinking that
41:50 - cool all right what what next you want
41:54 - what's the what's the next point so
41:55 - we've got
41:56 - um we've now counted our neighbors
41:59 - whether they're of class zero or class
42:00 - one um
42:02 - what should we do with that now well now
42:04 - we gotta see which one wins right we
42:05 - gotta see if class zero has a greater
42:08 - number than class
42:09 - class one yeah
42:12 - and again there's gonna be an
42:14 - interesting yeah thank you
42:16 - uh there's going to be an interesting
42:17 - tie breaker here um because if class 0
42:19 - is greater than class 1 then something
42:20 - happens
42:22 - otherwise something else is going to
42:24 - happen
42:26 - um let's see 0 was
42:29 - red so i'm going to say
42:34 - if class 0 is greater than class 1
42:37 - i'm going to draw a red circle
42:40 - otherwise i'm going to draw a
42:44 - green circle and then finally
42:47 - i want to actually you know color in my
42:50 - my background where my mouse is so i
42:52 - want to draw an ellipse
42:54 - at mouse x mouse
42:57 - y and then let's make it 10 by 10 or
43:00 - maybe even smaller than that five by
43:02 - five
43:08 - and okay cool so it's kind of working uh
43:12 - uh something is happening with the
43:13 - background where actually this might
43:15 - even be a better representation where
43:16 - i'm not
43:17 - possibly drawing it over and over and
43:19 - over again um
43:21 - cool so yeah i think i think that this
43:23 - is
43:25 - the part that's doing the classification
43:27 - is just setting the fill which is a
43:29 - little bit
43:30 - uh it feels a little anticlimactic right
43:33 - we do like all of this work
43:34 - we like we compare all of the distances
43:37 - we sort our lists we then count up the
43:40 - neighbors
43:40 - and all we do at the end of the day is
43:43 - choose what color to
43:44 - draw our mouse but again that's kind of
43:46 - the point of all of this where
43:49 - we want to classify our mouse point
43:54 - um all right do you want what's the
43:56 - implication of the tie here with
43:58 - um what if there are uh
44:02 - four if i look at my four nearest
44:05 - neighbors
44:06 - and to our green and to our red the way
44:09 - that we've coded it right now who wins
44:12 - the way that we've coded it it's going
44:14 - to be green that will always win
44:16 - right because we
44:19 - class zero has to be has to be greater
44:22 - than class one
44:24 - so the only way that class zero will win
44:26 - is if it's
44:27 - three if there are three uh neighbors
44:29 - that are red
44:30 - um but if it's two then it's gonna think
44:32 - that it's gonna be
44:33 - green right and if i if we change this
44:36 - if i said
44:37 - if class zero is greater than or equal
44:39 - to class one
44:40 - now if it's two two then we've then
44:43 - we're classifying our mouse pointer as
44:45 - um red rather than green but i see that
44:48 - it's like a
44:49 - really interesting opportunity to do um
44:52 - a interesting visualization here for me
44:54 - in my perspective because
44:56 - you know for me i care a little less
44:57 - about the exactness
44:59 - of this um science and i'm like oh this
45:02 - is gonna be an interesting place where
45:04 - we could do if class 0 is greater than
45:08 - class 1 then we could have it red if
45:10 - it's
45:11 - less than class 1 then we could have it
45:12 - green but if it's equal to each other
45:15 - then we could have it colored a mix of
45:17 - green and red
45:18 - right cool yeah um
45:22 - class one is greater than class zero
45:27 - and then else meaning they're equal then
45:30 - we could fill uh
45:32 - 255 255 0.
45:36 - and so let's see again we're going to
45:37 - have to make sure that we're comparing
45:38 - an
45:39 - even number of neighbors just so we get
45:42 - the opportunity for them to be tied
45:44 - um and then let's see if we can find a
45:47 - uh
45:49 - all right can we eyeball a tie uh
45:52 - let's see think like here
45:56 - there we go it's yellow um i think
45:59 - before i take the
46:00 - take the background off it would be
46:01 - easier to see yeah and this will let me
46:04 - uh
46:05 - let me make that my mouse pointer uh
46:07 - slightly bigger
46:09 - just because it is hard to see
46:13 - and then what is white is it uh
46:17 - 255 but we might want to move that to
46:19 - setup so that we can just draw on top of
46:21 - it
46:22 - sure yeah there's some yeah so i'm just
46:26 - going to draw the background at the
46:27 - start
46:27 - so now as i mouse over it'll look like
46:30 - i'm uh
46:36 - yeah the the yellow is interesting uh
46:40 - in in most
46:43 - in most machine learning algorithms
46:45 - you're not going to want
46:46 - a tie because it's uh you don't know
46:49 - what to do with that so again there's
46:50 - like lots of different strategies on how
46:51 - to break the tie
46:53 - um i mean one of the most simple ones is
46:55 - just
46:56 - randomly picking one of the classes um
46:58 - and that way you can get like a
46:59 - definitive answer because
47:01 - um yeah sometimes you don't you don't
47:04 - really know what to do with uh with a
47:05 - tie
47:06 - right which is why i'm saying that if
47:08 - you were going if you were using this
47:10 - algorithm for
47:11 - straight up machine learning algorithm
47:13 - you wouldn't want to do that
47:15 - but i'm like putting in a bit of like a
47:17 - twist from my perspective where i only
47:19 - care about creating
47:20 - you know beautiful looking things
47:23 - then i think this is like a great
47:25 - opportunity to allow for that tie
47:27 - um and create um to me kind of is this
47:30 - this
47:31 - sort of algorithm the way that i see it
47:33 - um we could create like a really
47:35 - interesting gradient visualization
47:38 - so if we were to actually you know
47:40 - remove that display
47:41 - in draw um so that we don't actually
47:45 - draw the points
47:46 - and then you could just have you know
47:48 - users just play around with the mouse
47:51 - so they don't really know um what kind
47:54 - of
47:54 - a color that they're gonna get but this
47:56 - is like um
47:58 - basically like a pain tool that you
47:59 - don't know what area is gonna be colored
48:01 - and what but it's totally decided
48:03 - um yeah based on
48:08 - the kenya's algorithm that's super
48:10 - clever where
48:11 - now i just have a uh a blank slate but
48:14 - there are those points in the background
48:16 - that um that
48:19 - are determining the color interesting
48:23 - it's so hard to get red i know and now
48:26 - it's like
48:26 - it's hard to debug now so we don't see
48:29 - it but
48:29 - [Laughter]
48:30 - here if we run it again i'm sure we will
48:32 - uh
48:35 - yeah cause the thing is that remember
48:36 - we're randomizing the class of every
48:38 - point when we hit the run button and so
48:40 - it's possible that
48:41 - um we're just not getting a lot of red
48:43 - although two in a row now
48:45 - there we go there's some red so there's
48:46 - probably a cluster of red points
48:49 - you know right in this area
48:52 - yeah um cool
48:55 - any other ideas that you have to to make
48:57 - this kind of visually interesting to you
48:59 - on
49:00 - um the other thing i think would be
49:01 - really cool is if we had like you know
49:03 - obviously having more than one
49:04 - class is going to be interesting but if
49:07 - we were to also
49:08 - not just use um the mouse but we could
49:11 - also
49:12 - randomly select different things so we
49:15 - could have like scattered
49:16 - almost like um you know like paint
49:19 - falling on the paper but then
49:21 - the color of the paint depends on where
49:22 - it falls on the paint a paper
49:25 - so we could um instead of using mouse
49:27 - but then
49:28 - i don't know if it's going to be
49:29 - something that could be easily doable
49:33 - let's i think we can do it so yeah i
49:35 - think we put a random
49:37 - instead of mouse x and mouse y yep
49:40 - exactly so
49:41 - let's do classify we'll keep calling it
49:44 - classify
49:44 - mouse but we'll say x and y
49:48 - so this now takes three points and we
49:50 - want the distance from
49:51 - x and y to
49:55 - the points in our array and then
49:58 - we use the mouse anywhere else and then
49:59 - we want to draw the
50:01 - the thing at x and y rather than our
50:04 - mouse
50:05 - and then when we call it um
50:09 - let's do classify mouse
50:12 - we can we can stick we can still use
50:14 - four neighbors but we want
50:15 - random um width
50:19 - and random height
50:25 - and then let's even make these dots a
50:28 - little bit bigger
50:28 - just so it fills up quicker
50:32 - totally overheating good call yeah
50:35 - uh i probably could just put it at the
50:39 - top
50:39 - but um
50:46 - nice and you can like obviously hone in
50:50 - on it you can put it in like um
50:52 - so opacity and all the fills and you can
50:55 - put in like
50:56 - um you know you can even create
50:59 - another class on top of this so that
51:01 - basically the way that you draw it
51:03 - would be drawing an instance of a new
51:06 - class
51:06 - so then you could decide on like the
51:09 - different shape of different sizes for
51:11 - each of these drops as well
51:12 - all that sorts of things and um you
51:15 - could do even further
51:16 - things like um
51:20 - i don't know i think this this is like a
51:22 - really interesting like
51:23 - like a pattern making almost yeah it's
51:26 - cool
51:26 - oh my god look at that
51:31 - um yeah when i when i first made this uh
51:34 - it's
51:34 - the original thing is at the end of the
51:36 - um
51:38 - my computer is like totally overheating
51:40 - from from printing all of those arrays
51:43 - but
51:43 - um the original
51:47 - is at the very end of the k-nearest
51:49 - neighbor course
51:51 - um
51:55 - let it load again this is the uh i've
51:59 - put this solution code to this exact
52:01 - thing in the youtube description um
52:05 - it was just like captivating to like
52:07 - draw this out and then it's like a
52:08 - rorschach test of like oh what like what
52:10 - uh
52:10 - what image do you see you and uh when
52:12 - you do k-nearest neighbor here
52:14 - um but you can see some of the other
52:15 - details that i added
52:17 - were i highlight which um
52:20 - which neighbors are the closest
52:21 - neighbors um
52:23 - and then i also added some uh some
52:26 - abilities for you to
52:28 - play with the inputs so you can
52:29 - re-randomize the points which just kind
52:31 - of like refreshes everything
52:33 - um but then i can say okay this is what
52:36 - the space looks like
52:37 - with three neighbors if i kick that up
52:39 - to five or six
52:41 - this space is gonna look look slightly
52:44 - differently
52:47 - yeah i'm also like almost getting like
52:49 - an inspiration of creating like um
52:51 - abstract pointillism um visualization
52:55 - by you know putting in more classes in
52:57 - there so you could you could use you
52:59 - know
52:59 - a gradient of five five different colors
53:02 - and like
53:03 - create all these like pointless
53:04 - pointless and things for like a bigger
53:07 - canvas with like smaller points that's
53:09 - gonna make it a little
53:10 - you know the points a lot more finer i
53:12 - think yeah interesting
53:14 - that's a cool idea let me find um man
53:17 - let me find another course that we have
53:19 - on codecademy because it
53:20 - speaks to what you were talking about a
53:22 - little bit um
53:23 - so what we just did was classification
53:26 - where
53:27 - the final output of our thing is
53:30 - your unclassified point is either um
53:33 - zero or one right it's either red or
53:35 - green another thing that you can do with
53:37 - k nearest neighbor is g1 like you said
53:38 - if you have
53:39 - kind of multiple classes what you can do
53:42 - is you can
53:44 - um run a regression on it where the
53:46 - output of that isn't
53:47 - just zero or one it's some
53:50 - point along a spectrum so like zero and
53:53 - five
53:54 - um and again kind of really similar
53:58 - um really similar concept of you're
54:00 - comparing points but then at the end of
54:02 - the day
54:03 - you know this point had a had a value of
54:05 - zero that point had a value of five your
54:07 - third neighbor had a value of three
54:09 - you know you average those values
54:10 - together or you do something with those
54:11 - values together to get a final
54:14 - uh a final answer of like 2.5
54:17 - um another idea
54:20 - that i had um was we could do a thing
54:23 - where you know similar to the one
54:25 - one that we had before we use the mouse
54:27 - and if you click on it
54:28 - it gets attract you could um code it
54:30 - with a little bit more physics in there
54:32 - and you could have that point attracted
54:34 - to one classification category versus
54:36 - another
54:38 - that could be really interesting kind of
54:40 - reminds me of
54:41 - like the pinball machiney sort of aspect
54:43 - where you drop a bowl in and you could
54:45 - it could go to one side versus the other
54:47 - based on which category yeah
54:50 - that could be also a really fun thing to
54:52 - create try to create too
54:55 - if anyone wants to take up the challenge
54:58 - yeah i would love to see if if folks
55:00 - have been have watched through this
55:01 - whole thing and you're interested in it
55:02 - i would love to see
55:03 - kind of what variations you can make of
55:05 - this
55:06 - yeah what it could be really really cool
55:09 - if like
55:10 - anyone creates like a you know a remix
55:12 - of the
55:13 - p5.js sketch that we post as a web
55:16 - editor if you want to like
55:18 - drop in your own web editor links as
55:20 - like comments in the video that will be
55:22 - really cool to see yeah that would be
55:26 - that would be awesome um so this is an
55:28 - example again using movie
55:30 - uh movie stuff um this is an example of
55:33 - regression
55:33 - where now we're not it's not a binary
55:35 - thing of yes i liked it or no i didn't
55:37 - like it
55:38 - this is something where um i'm going to
55:41 - go ahead
55:42 - and rate
55:45 - there has to be at least 5 because right
55:47 - now k is five i'm going to rate five
55:48 - movies
55:49 - and now that those are in all of the
55:51 - ones that i haven't rated
55:52 - um are recommend uh
55:56 - recommended and again you have to think
55:58 - to yourself okay what are the features
56:00 - of these points that like you can
56:03 - picture the
56:04 - you can picture the visual visualization
56:06 - right as
56:07 - dots in some space and again i think
56:10 - let's see if we say it in here um
56:15 - um
56:22 - man i don't know if i uh
56:30 - man yeah i don't know what uh what
56:32 - features um
56:33 - we're actually running this on i think
56:35 - it's like release year length
56:37 - and budget or something like that and
56:38 - that's that's how the points are being
56:40 - drawn in the space and then we find our
56:42 - nearest neighbors and so as you
56:44 - you know if i go ahead and
56:47 - uh start rating old movies really low
56:50 - you'll find that like the other old
56:52 - movies will also start to drop
56:54 - compared to the the recent movies or
56:56 - something something like that um
56:59 - that's fun yeah like if i wanted to do
57:02 - like more than one gradient i guess this
57:04 - is sort of like the algorithm that we'll
57:06 - take a look at to apply behind the
57:07 - scenes
57:09 - yeah exactly um a couple more little
57:13 - like
57:13 - machine learning tidbits or things to uh
57:17 - think about this for this algorithm is
57:19 - right one of the things
57:21 - that comes up with algorithms like this
57:23 - is the idea of a column start problem
57:25 - where again this algorithm is kind of
57:27 - useless if i don't have a bunch of
57:29 - existing data
57:30 - and so it's great that this exact
57:32 - algorithm exists behind the scenes but
57:34 - in order for it to be
57:35 - useful i have to actually start giving
57:37 - it some of my own data
57:39 - right i have to start rating movies
57:40 - myself um
57:42 - so that's an example of the cone start
57:44 - problem of it takes some time
57:46 - for this algorithm to actually be useful
57:48 - because you need to give it um
57:50 - some base points yeah some some starting
57:53 - point um
57:54 - and then the the final thing that i want
57:56 - to say about this algorithm is that
57:58 - this is an example of a lazy algorithm
58:02 - which means um let me actually go to
58:08 - um the final version
58:19 - so this is a lazy algorithm
58:23 - because it doesn't do any work
58:26 - until you show up with a new point so
58:29 - the moment i show up with an
58:30 - unclassified point
58:31 - it has to do all of the work right then
58:33 - right the points are just sitting in
58:35 - space i show up with a new point
58:36 - and it compares uh it compares that
58:40 - point to every point in the space and so
58:41 - you could
58:42 - you could imagine if there's you know a
58:44 - hundred thousand points in the space
58:45 - that's a lot of work that it has to do
58:47 - it has to make a hundred thousand
58:48 - comparisons
58:49 - um that's in contrast to i think it's
58:52 - called
58:53 - eager learner learning algorithms where
58:56 - these other algorithms they kind of do
58:58 - the pre-processing ahead of time
59:00 - where they have a sense of the decision
59:03 - space they have a sense
59:04 - of where things are going to turn green
59:06 - versus where things are going to turn
59:07 - blue
59:08 - and in those algorithms you show up with
59:11 - a new point and it doesn't have to do
59:12 - all the math
59:13 - then it just says hey you fell in this
59:15 - space and i earlier i calculated that
59:17 - that space should be green
59:19 - versus this lazy approach which it
59:21 - doesn't know anything about the space it
59:23 - just knows
59:24 - it knows where the points are and when a
59:25 - new point shows up it has to do all of
59:27 - the math
59:28 - um yeah so kind of two different styles
59:31 - of algorithms
59:33 - almost makes me um think that we could
59:35 - do
59:36 - the eager version as a grid and then we
59:39 - could
59:39 - have all the points in each of the grid
59:42 - cells calculated if the mouse is over
59:44 - then it changes the color of the grid
59:45 - too
59:46 - that could be fun too yeah that's kind
59:48 - of um
59:50 - yeah that's kind of how some of those
59:51 - algorithms work where
59:53 - um yeah it's like
59:56 - yeah you can visualize it as already the
59:59 - thing that you see is already kind of
60:01 - like the filmed in version of this
60:02 - picture where you already see
60:03 - like the boundaries and so then when a
60:06 - point lands it just kind of classifies
60:07 - it as one or the other
60:10 - cool it's super interesting yeah um
60:14 - yeah i love uh i love p5 because you're
60:16 - able to like this is a
60:18 - complicated algorithm right i didn't
60:19 - learn this until like well into college
60:22 - and so being able to like super quickly
60:24 - right we did that in under an hour of
60:25 - being able to visualize it and kind of
60:27 - get a
60:28 - a good conceptual understanding of what
60:30 - the algorithm does i think it's
60:32 - i love p5 for it because it just makes
60:34 - stuff like that so fun
60:36 - yeah cool um cool g1 do you want to plug
60:40 - what we're doing next week
60:42 - yeah next week is going to be our final
60:45 - live stream series for
60:46 - um creative coding with kirk academy and
60:48 - what we're going to do next week is
60:50 - i'm personally really really a huge fan
60:52 - of you know
60:53 - these things but we're going to be
60:55 - basically creating a visualization
60:57 - that's driven by
60:58 - audio so what we're going to do is we're
61:00 - going to learn how to
61:02 - import in a audio file inside of our
61:05 - p5.js sketch we're going to learn how to
61:07 - play it we're going to also
61:09 - learn how to analyze the music data
61:12 - itself
61:13 - um program click a probe inter using
61:16 - programming and we're going to use
61:17 - specifically what's called an
61:19 - fft or fast fourier transform algorithm
61:22 - it sounds
61:22 - really complicated but the thing with
61:24 - b5.js is that
61:25 - you you don't have to know too much
61:27 - about it there's already a class
61:29 - built in for you there's already a
61:30 - function built in for you and we're
61:31 - going to use that
61:32 - and make things move based on the
61:35 - frequency and the beats in a music
61:37 - so that's gonna be hopefully really
61:39 - interesting to the end thing
61:41 - for a lot of people and so it's kind of
61:43 - also like a boom at the end being like
61:46 - like a really interesting thing that you
61:48 - can create using
61:49 - music and also visualization so we're
61:52 - going to be doing that next week
61:53 - and yeah and you're doing that with nick
61:55 - right yeah nice
61:57 - cool all right well i think that is all
62:00 - for us for today so
62:02 - yeah thank you uh thank you for watching
62:03 - and we'll see you next